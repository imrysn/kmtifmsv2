/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ 55364:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

// MySQL Database Configuration
// This replaces the SQLite configuration to solve multi-user corruption issues

// Load environment variables from .env file
(__nccwpck_require__(18889).config)();

const mysql = __nccwpck_require__(27588);
const path = __nccwpck_require__(16928);
const fs = __nccwpck_require__(79896);
const os = __nccwpck_require__(70857);

// ============================================================================
// CONFIGURATION
// ============================================================================

// Check if MySQL should be used
const USE_MYSQL = process.env.USE_MYSQL === 'true' || process.env.DB_HOST;

// Environment-based configuration
const isProduction = process.env.NODE_ENV === 'production' || USE_MYSQL;
const isDevelopment = !isProduction;

// MySQL Connection Configuration
const MYSQL_CONFIG = {
  // Read from environment variables
  host: process.env.DB_HOST || 'localhost',
  port: parseInt(process.env.DB_PORT) || 3306,
  user: process.env.DB_USER || 'root',
  password: process.env.DB_PASSWORD || '',
  database: process.env.DB_NAME || (isProduction ? 'kmtifms' : 'kmtifms_dev'),
  waitForConnections: true,
  connectionLimit: 20,        // FIXED: Increased for better concurrency
  queueLimit: 50,             // FIXED: Prevent memory overflow from unlimited queue
  acquireTimeout: 10000,      // FIXED: Timeout after 10s instead of hanging forever
  enableKeepAlive: true,
  keepAliveInitialDelay: 0,
  // Connection health checks
  maxIdle: 10,                // ADDED: Close idle connections after 10 connections
  idleTimeout: 60000          // ADDED: Close connections idle for 60s
};

// Current configuration
const currentConfig = MYSQL_CONFIG;

// ============================================================================
// CONNECTION POOL
// ============================================================================

let pool = null;

// Create connection pool
function createPool() {
  if (!pool) {
    try {
      pool = mysql.createPool(currentConfig);
      console.log(`‚úÖ MySQL pool created`);
      console.log(`üìä Database: ${currentConfig.database} @ ${currentConfig.host}:${currentConfig.port}`);
    } catch (error) {
      console.error('‚ùå Failed to create MySQL pool:', error.message);
      throw error;
    }
  }
  return pool;
}

// Get connection pool
function getPool() {
  if (!pool) {
    return createPool();
  }
  return pool;
}

// Test database connection
async function testConnection() {
  try {
    const pool = getPool();
    const connection = await pool.getConnection();
    console.log('‚úÖ MySQL connection successful');
    connection.release();
    return true;
  } catch (error) {
    console.error('‚ùå MySQL connection failed:', error.message);
    console.error('üí° Please check:');
    console.error('   1. MySQL server is running');
    console.error('   2. Database credentials are correct in .env');
    console.error('   3. Network connectivity to database server');
    console.error('   4. Firewall allows MySQL port (3306)');
    console.error('\nüîç Current configuration:');
    console.error(`   Host: ${currentConfig.host}`);
    console.error(`   Port: ${currentConfig.port}`);
    console.error(`   Database: ${currentConfig.database}`);
    console.error(`   User: ${currentConfig.user}`);
    return false;
  }
}

// Execute query with error handling
async function query(sql, params = []) {
  const pool = getPool();
  try {
    const [results] = await pool.execute(sql, params);
    return results;
  } catch (error) {
    console.error('‚ùå Query error:', error.message);
    console.error('SQL:', sql);
    throw error;
  }
}

// Execute query and return first result
async function queryOne(sql, params = []) {
  const results = await query(sql, params);
  return results[0] || null;
}

// Execute transaction
async function transaction(callback) {
  const pool = getPool();
  const connection = await pool.getConnection();
  
  try {
    await connection.beginTransaction();
    const result = await callback(connection);
    await connection.commit();
    return result;
  } catch (error) {
    await connection.rollback();
    console.error('‚ùå Transaction failed:', error.message);
    throw error;
  } finally {
    connection.release();
  }
}

// Close all connections (for graceful shutdown)
async function closePool() {
  if (pool) {
    try {
      await pool.end();
      console.log('‚úÖ MySQL pool closed');
      pool = null;
    } catch (error) {
      console.error('‚ùå Error closing MySQL pool:', error.message);
    }
  }
}

// ============================================================================
// NETWORK PATHS
// ============================================================================

// Network data path configuration
const networkDataPath = isProduction
  ? '\\\\KMTI-NAS\\Shared\\data'
  : path.join(__dirname, '..', 'local-test', 'data');

const networkProjectsPath = isProduction
  ? '\\\\KMTI-NAS\\Shared\\Public\\PROJECTS'
  : path.join(__dirname, '..', 'local-test', 'PROJECTS');

// Returns a sensible default path suitable for native file pickers.
// Prefer the networkProjectsPath when configured, otherwise fall back to user's Documents or home.
function getDefaultProjectPickerPath() {
  // Prefer the configured NETWORK PROJECTS path first (use the string even if it isn't accessible).
  if (networkProjectsPath) {
    return networkProjectsPath;
  }

  // Then fall back to Documents folder if available
  const home = os.homedir() || '';
  const documents = path.join(home, 'Documents');
  try {
    if (documents && fs.existsSync(documents)) {
      return documents;
    }
  } catch (e) {
    // ignore
  }

  // Final fallback to home or networkDataPath string
  return home || networkDataPath;
}

// Explicit getter for the network PROJECTS path (useful for preload/exposed APIs)
function getNetworkProjectsPath() {
  return networkProjectsPath;
}

// Helper to build options for native file pickers (e.g. Electron dialog.showOpenDialog)
// Pass extra options to merge with the defaults.
function defaultOpenDialogOptions(extra = {}) {
  return Object.assign({
    defaultPath: getDefaultProjectPickerPath()
  }, extra);
}

// ============================================================================
// EXPORTS
// ============================================================================

module.exports = {
  // Connection functions
  getPool,
  createPool,
  testConnection,
  closePool,
  
  // Query functions
  query,
  queryOne,
  transaction,
  
  // Configuration
  config: currentConfig,
  networkDataPath,
  networkProjectsPath,
  isProduction,
  isDevelopment,
  // Explicit network projects getter for preload/electron usage
  getNetworkProjectsPath,
  // Helpers for native file pickers
  getDefaultProjectPickerPath,
  defaultOpenDialogOptions,
  
  // Legacy compatibility (for gradual migration)
  // These provide a similar interface to the old SQLite db object
  db: {
    query,
    queryOne,
    transaction
  }
};


/***/ }),

/***/ 39693:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

/*

The MIT License (MIT)

Original Library
  - Copyright (c) Marak Squires

Additional functionality
 - Copyright (c) Sindre Sorhus <sindresorhus@gmail.com> (sindresorhus.com)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

*/

var colors = {};
module['exports'] = colors;

colors.themes = {};

var util = __nccwpck_require__(39023);
var ansiStyles = colors.styles = __nccwpck_require__(72251);
var defineProps = Object.defineProperties;
var newLineRegex = new RegExp(/[\r\n]+/g);

colors.supportsColor = (__nccwpck_require__(98740).supportsColor);

if (typeof colors.enabled === 'undefined') {
  colors.enabled = colors.supportsColor() !== false;
}

colors.enable = function() {
  colors.enabled = true;
};

colors.disable = function() {
  colors.enabled = false;
};

colors.stripColors = colors.strip = function(str) {
  return ('' + str).replace(/\x1B\[\d+m/g, '');
};

// eslint-disable-next-line no-unused-vars
var stylize = colors.stylize = function stylize(str, style) {
  if (!colors.enabled) {
    return str+'';
  }

  var styleMap = ansiStyles[style];

  // Stylize should work for non-ANSI styles, too
  if (!styleMap && style in colors) {
    // Style maps like trap operate as functions on strings;
    // they don't have properties like open or close.
    return colors[style](str);
  }

  return styleMap.open + str + styleMap.close;
};

var matchOperatorsRe = /[|\\{}()[\]^$+*?.]/g;
var escapeStringRegexp = function(str) {
  if (typeof str !== 'string') {
    throw new TypeError('Expected a string');
  }
  return str.replace(matchOperatorsRe, '\\$&');
};

function build(_styles) {
  var builder = function builder() {
    return applyStyle.apply(builder, arguments);
  };
  builder._styles = _styles;
  // __proto__ is used because we must return a function, but there is
  // no way to create a function with a different prototype.
  builder.__proto__ = proto;
  return builder;
}

var styles = (function() {
  var ret = {};
  ansiStyles.grey = ansiStyles.gray;
  Object.keys(ansiStyles).forEach(function(key) {
    ansiStyles[key].closeRe =
      new RegExp(escapeStringRegexp(ansiStyles[key].close), 'g');
    ret[key] = {
      get: function() {
        return build(this._styles.concat(key));
      },
    };
  });
  return ret;
})();

var proto = defineProps(function colors() {}, styles);

function applyStyle() {
  var args = Array.prototype.slice.call(arguments);

  var str = args.map(function(arg) {
    // Use weak equality check so we can colorize null/undefined in safe mode
    if (arg != null && arg.constructor === String) {
      return arg;
    } else {
      return util.inspect(arg);
    }
  }).join(' ');

  if (!colors.enabled || !str) {
    return str;
  }

  var newLinesPresent = str.indexOf('\n') != -1;

  var nestedStyles = this._styles;

  var i = nestedStyles.length;
  while (i--) {
    var code = ansiStyles[nestedStyles[i]];
    str = code.open + str.replace(code.closeRe, code.open) + code.close;
    if (newLinesPresent) {
      str = str.replace(newLineRegex, function(match) {
        return code.close + match + code.open;
      });
    }
  }

  return str;
}

colors.setTheme = function(theme) {
  if (typeof theme === 'string') {
    console.log('colors.setTheme now only accepts an object, not a string.  ' +
      'If you are trying to set a theme from a file, it is now your (the ' +
      'caller\'s) responsibility to require the file.  The old syntax ' +
      'looked like colors.setTheme(__dirname + ' +
      '\'/../themes/generic-logging.js\'); The new syntax looks like '+
      'colors.setTheme(require(__dirname + ' +
      '\'/../themes/generic-logging.js\'));');
    return;
  }
  for (var style in theme) {
    (function(style) {
      colors[style] = function(str) {
        if (typeof theme[style] === 'object') {
          var out = str;
          for (var i in theme[style]) {
            out = colors[theme[style][i]](out);
          }
          return out;
        }
        return colors[theme[style]](str);
      };
    })(style);
  }
};

function init() {
  var ret = {};
  Object.keys(styles).forEach(function(name) {
    ret[name] = {
      get: function() {
        return build([name]);
      },
    };
  });
  return ret;
}

var sequencer = function sequencer(map, str) {
  var exploded = str.split('');
  exploded = exploded.map(map);
  return exploded.join('');
};

// custom formatter methods
colors.trap = __nccwpck_require__(32154);
colors.zalgo = __nccwpck_require__(89312);

// maps
colors.maps = {};
colors.maps.america = __nccwpck_require__(88881)(colors);
colors.maps.zebra = __nccwpck_require__(45337)(colors);
colors.maps.rainbow = __nccwpck_require__(18543)(colors);
colors.maps.random = __nccwpck_require__(51298)(colors);

for (var map in colors.maps) {
  (function(map) {
    colors[map] = function(str) {
      return sequencer(colors.maps[map], str);
    };
  })(map);
}

defineProps(colors, init());


/***/ }),

/***/ 32154:
/***/ ((module) => {

module['exports'] = function runTheTrap(text, options) {
  var result = '';
  text = text || 'Run the trap, drop the bass';
  text = text.split('');
  var trap = {
    a: ['\u0040', '\u0104', '\u023a', '\u0245', '\u0394', '\u039b', '\u0414'],
    b: ['\u00df', '\u0181', '\u0243', '\u026e', '\u03b2', '\u0e3f'],
    c: ['\u00a9', '\u023b', '\u03fe'],
    d: ['\u00d0', '\u018a', '\u0500', '\u0501', '\u0502', '\u0503'],
    e: ['\u00cb', '\u0115', '\u018e', '\u0258', '\u03a3', '\u03be', '\u04bc',
      '\u0a6c'],
    f: ['\u04fa'],
    g: ['\u0262'],
    h: ['\u0126', '\u0195', '\u04a2', '\u04ba', '\u04c7', '\u050a'],
    i: ['\u0f0f'],
    j: ['\u0134'],
    k: ['\u0138', '\u04a0', '\u04c3', '\u051e'],
    l: ['\u0139'],
    m: ['\u028d', '\u04cd', '\u04ce', '\u0520', '\u0521', '\u0d69'],
    n: ['\u00d1', '\u014b', '\u019d', '\u0376', '\u03a0', '\u048a'],
    o: ['\u00d8', '\u00f5', '\u00f8', '\u01fe', '\u0298', '\u047a', '\u05dd',
      '\u06dd', '\u0e4f'],
    p: ['\u01f7', '\u048e'],
    q: ['\u09cd'],
    r: ['\u00ae', '\u01a6', '\u0210', '\u024c', '\u0280', '\u042f'],
    s: ['\u00a7', '\u03de', '\u03df', '\u03e8'],
    t: ['\u0141', '\u0166', '\u0373'],
    u: ['\u01b1', '\u054d'],
    v: ['\u05d8'],
    w: ['\u0428', '\u0460', '\u047c', '\u0d70'],
    x: ['\u04b2', '\u04fe', '\u04fc', '\u04fd'],
    y: ['\u00a5', '\u04b0', '\u04cb'],
    z: ['\u01b5', '\u0240'],
  };
  text.forEach(function(c) {
    c = c.toLowerCase();
    var chars = trap[c] || [' '];
    var rand = Math.floor(Math.random() * chars.length);
    if (typeof trap[c] !== 'undefined') {
      result += trap[c][rand];
    } else {
      result += c;
    }
  });
  return result;
};


/***/ }),

/***/ 89312:
/***/ ((module) => {

// please no
module['exports'] = function zalgo(text, options) {
  text = text || '   he is here   ';
  var soul = {
    'up': [
      'Ãç', 'Ãé', 'ÃÑ', 'ÃÖ',
      'Ãø', 'Ãë', 'ÃÜ', 'Ãê',
      'Õí', 'Õó', 'Õë', 'Ãá',
      'Ãà', 'Ãä', 'ÕÇ', 'Ãì',
      'Ãà', 'Õä', 'Õã', 'Õå',
      'ÃÉ', 'ÃÇ', 'Ãå', 'Õê',
      'ÃÄ', 'ÃÅ', 'Ãã', 'Ãè',
      'Ãí', 'Ãì', 'Ãî', 'ÃΩ',
      'Ãâ', 'Õ£', 'Õ§', 'Õ•',
      'Õ¶', 'Õß', 'Õ®', 'Õ©',
      'Õ™', 'Õ´', 'Õ¨', 'Õ≠',
      'ÕÆ', 'ÕØ', 'Ãæ', 'Õõ',
      'ÕÜ', 'Ãö',
    ],
    'down': [
      'Ãñ', 'Ãó', 'Ãò', 'Ãô',
      'Ãú', 'Ãù', 'Ãû', 'Ãü',
      'Ã†', 'Ã§', 'Ã•', 'Ã¶',
      'Ã©', 'Ã™', 'Ã´', 'Ã¨',
      'Ã≠', 'ÃÆ', 'ÃØ', 'Ã∞',
      'Ã±', 'Ã≤', 'Ã≥', 'Ãπ',
      'Ã∫', 'Ãª', 'Ãº', 'ÕÖ',
      'Õá', 'Õà', 'Õâ', 'Õç',
      'Õé', 'Õì', 'Õî', 'Õï',
      'Õñ', 'Õô', 'Õö', 'Ã£',
    ],
    'mid': [
      'Ãï', 'Ãõ', 'ÃÄ', 'ÃÅ',
      'Õò', 'Ã°', 'Ã¢', 'Ãß',
      'Ã®', 'Ã¥', 'Ãµ', 'Ã∂',
      'Õú', 'Õù', 'Õû',
      'Õü', 'Õ†', 'Õ¢', 'Ã∏',
      'Ã∑', 'Õ°', ' “â',
    ],
  };
  var all = [].concat(soul.up, soul.down, soul.mid);

  function randomNumber(range) {
    var r = Math.floor(Math.random() * range);
    return r;
  }

  function isChar(character) {
    var bool = false;
    all.filter(function(i) {
      bool = (i === character);
    });
    return bool;
  }


  function heComes(text, options) {
    var result = '';
    var counts;
    var l;
    options = options || {};
    options['up'] =
      typeof options['up'] !== 'undefined' ? options['up'] : true;
    options['mid'] =
      typeof options['mid'] !== 'undefined' ? options['mid'] : true;
    options['down'] =
      typeof options['down'] !== 'undefined' ? options['down'] : true;
    options['size'] =
      typeof options['size'] !== 'undefined' ? options['size'] : 'maxi';
    text = text.split('');
    for (l in text) {
      if (isChar(l)) {
        continue;
      }
      result = result + text[l];
      counts = {'up': 0, 'down': 0, 'mid': 0};
      switch (options.size) {
        case 'mini':
          counts.up = randomNumber(8);
          counts.mid = randomNumber(2);
          counts.down = randomNumber(8);
          break;
        case 'maxi':
          counts.up = randomNumber(16) + 3;
          counts.mid = randomNumber(4) + 1;
          counts.down = randomNumber(64) + 3;
          break;
        default:
          counts.up = randomNumber(8) + 1;
          counts.mid = randomNumber(6) / 2;
          counts.down = randomNumber(8) + 1;
          break;
      }

      var arr = ['up', 'mid', 'down'];
      for (var d in arr) {
        var index = arr[d];
        for (var i = 0; i <= counts[index]; i++) {
          if (options[index]) {
            result = result + soul[index][randomNumber(soul[index].length)];
          }
        }
      }
    }
    return result;
  }
  // don't summon him
  return heComes(text, options);
};



/***/ }),

/***/ 88881:
/***/ ((module) => {

module['exports'] = function(colors) {
  return function(letter, i, exploded) {
    if (letter === ' ') return letter;
    switch (i%3) {
      case 0: return colors.red(letter);
      case 1: return colors.white(letter);
      case 2: return colors.blue(letter);
    }
  };
};


/***/ }),

/***/ 18543:
/***/ ((module) => {

module['exports'] = function(colors) {
  // RoY G BiV
  var rainbowColors = ['red', 'yellow', 'green', 'blue', 'magenta'];
  return function(letter, i, exploded) {
    if (letter === ' ') {
      return letter;
    } else {
      return colors[rainbowColors[i++ % rainbowColors.length]](letter);
    }
  };
};



/***/ }),

/***/ 51298:
/***/ ((module) => {

module['exports'] = function(colors) {
  var available = ['underline', 'inverse', 'grey', 'yellow', 'red', 'green',
    'blue', 'white', 'cyan', 'magenta', 'brightYellow', 'brightRed',
    'brightGreen', 'brightBlue', 'brightWhite', 'brightCyan', 'brightMagenta'];
  return function(letter, i, exploded) {
    return letter === ' ' ? letter :
      colors[
          available[Math.round(Math.random() * (available.length - 2))]
      ](letter);
  };
};


/***/ }),

/***/ 45337:
/***/ ((module) => {

module['exports'] = function(colors) {
  return function(letter, i, exploded) {
    return i % 2 === 0 ? letter : colors.inverse(letter);
  };
};


/***/ }),

/***/ 72251:
/***/ ((module) => {

/*
The MIT License (MIT)

Copyright (c) Sindre Sorhus <sindresorhus@gmail.com> (sindresorhus.com)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

*/

var styles = {};
module['exports'] = styles;

var codes = {
  reset: [0, 0],

  bold: [1, 22],
  dim: [2, 22],
  italic: [3, 23],
  underline: [4, 24],
  inverse: [7, 27],
  hidden: [8, 28],
  strikethrough: [9, 29],

  black: [30, 39],
  red: [31, 39],
  green: [32, 39],
  yellow: [33, 39],
  blue: [34, 39],
  magenta: [35, 39],
  cyan: [36, 39],
  white: [37, 39],
  gray: [90, 39],
  grey: [90, 39],

  brightRed: [91, 39],
  brightGreen: [92, 39],
  brightYellow: [93, 39],
  brightBlue: [94, 39],
  brightMagenta: [95, 39],
  brightCyan: [96, 39],
  brightWhite: [97, 39],

  bgBlack: [40, 49],
  bgRed: [41, 49],
  bgGreen: [42, 49],
  bgYellow: [43, 49],
  bgBlue: [44, 49],
  bgMagenta: [45, 49],
  bgCyan: [46, 49],
  bgWhite: [47, 49],
  bgGray: [100, 49],
  bgGrey: [100, 49],

  bgBrightRed: [101, 49],
  bgBrightGreen: [102, 49],
  bgBrightYellow: [103, 49],
  bgBrightBlue: [104, 49],
  bgBrightMagenta: [105, 49],
  bgBrightCyan: [106, 49],
  bgBrightWhite: [107, 49],

  // legacy styles for colors pre v1.0.0
  blackBG: [40, 49],
  redBG: [41, 49],
  greenBG: [42, 49],
  yellowBG: [43, 49],
  blueBG: [44, 49],
  magentaBG: [45, 49],
  cyanBG: [46, 49],
  whiteBG: [47, 49],

};

Object.keys(codes).forEach(function(key) {
  var val = codes[key];
  var style = styles[key] = [];
  style.open = '\u001b[' + val[0] + 'm';
  style.close = '\u001b[' + val[1] + 'm';
});


/***/ }),

/***/ 34982:
/***/ ((module) => {

"use strict";
/*
MIT License

Copyright (c) Sindre Sorhus <sindresorhus@gmail.com> (sindresorhus.com)

Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
of the Software, and to permit persons to whom the Software is furnished to do
so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/



module.exports = function(flag, argv) {
  argv = argv || process.argv || [];

  var terminatorPos = argv.indexOf('--');
  var prefix = /^-{1,2}/.test(flag) ? '' : '--';
  var pos = argv.indexOf(prefix + flag);

  return pos !== -1 && (terminatorPos === -1 ? true : pos < terminatorPos);
};


/***/ }),

/***/ 98740:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";
/*
The MIT License (MIT)

Copyright (c) Sindre Sorhus <sindresorhus@gmail.com> (sindresorhus.com)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

*/



var os = __nccwpck_require__(70857);
var hasFlag = __nccwpck_require__(34982);

var env = process.env;

var forceColor = void 0;
if (hasFlag('no-color') || hasFlag('no-colors') || hasFlag('color=false')) {
  forceColor = false;
} else if (hasFlag('color') || hasFlag('colors') || hasFlag('color=true')
           || hasFlag('color=always')) {
  forceColor = true;
}
if ('FORCE_COLOR' in env) {
  forceColor = env.FORCE_COLOR.length === 0
    || parseInt(env.FORCE_COLOR, 10) !== 0;
}

function translateLevel(level) {
  if (level === 0) {
    return false;
  }

  return {
    level: level,
    hasBasic: true,
    has256: level >= 2,
    has16m: level >= 3,
  };
}

function supportsColor(stream) {
  if (forceColor === false) {
    return 0;
  }

  if (hasFlag('color=16m') || hasFlag('color=full')
      || hasFlag('color=truecolor')) {
    return 3;
  }

  if (hasFlag('color=256')) {
    return 2;
  }

  if (stream && !stream.isTTY && forceColor !== true) {
    return 0;
  }

  var min = forceColor ? 1 : 0;

  if (process.platform === 'win32') {
    // Node.js 7.5.0 is the first version of Node.js to include a patch to
    // libuv that enables 256 color output on Windows. Anything earlier and it
    // won't work. However, here we target Node.js 8 at minimum as it is an LTS
    // release, and Node.js 7 is not. Windows 10 build 10586 is the first
    // Windows release that supports 256 colors. Windows 10 build 14931 is the
    // first release that supports 16m/TrueColor.
    var osRelease = os.release().split('.');
    if (Number(process.versions.node.split('.')[0]) >= 8
        && Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
      return Number(osRelease[2]) >= 14931 ? 3 : 2;
    }

    return 1;
  }

  if ('CI' in env) {
    if (['TRAVIS', 'CIRCLECI', 'APPVEYOR', 'GITLAB_CI'].some(function(sign) {
      return sign in env;
    }) || env.CI_NAME === 'codeship') {
      return 1;
    }

    return min;
  }

  if ('TEAMCITY_VERSION' in env) {
    return (/^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0
    );
  }

  if ('TERM_PROGRAM' in env) {
    var version = parseInt((env.TERM_PROGRAM_VERSION || '').split('.')[0], 10);

    switch (env.TERM_PROGRAM) {
      case 'iTerm.app':
        return version >= 3 ? 3 : 2;
      case 'Hyper':
        return 3;
      case 'Apple_Terminal':
        return 2;
      // No default
    }
  }

  if (/-256(color)?$/i.test(env.TERM)) {
    return 2;
  }

  if (/^screen|^xterm|^vt100|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
    return 1;
  }

  if ('COLORTERM' in env) {
    return 1;
  }

  if (env.TERM === 'dumb') {
    return min;
  }

  return min;
}

function getSupportLevel(stream) {
  var level = supportsColor(stream);
  return translateLevel(level);
}

module.exports = {
  supportsColor: getSupportLevel,
  stdout: getSupportLevel(process.stdout),
  stderr: getSupportLevel(process.stderr),
};


/***/ }),

/***/ 72708:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

//
// Remark: Requiring this file will use the "safe" colors API,
// which will not touch String.prototype.
//
//   var colors = require('colors/safe');
//   colors.red("foo")
//
//
var colors = __nccwpck_require__(39693);
module['exports'] = colors;


/***/ }),

/***/ 63451:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var enabled = __nccwpck_require__(85909);

/**
 * Creates a new Adapter.
 *
 * @param {Function} fn Function that returns the value.
 * @returns {Function} The adapter logic.
 * @public
 */
module.exports = function create(fn) {
  return function adapter(namespace) {
    try {
      return enabled(namespace, fn());
    } catch (e) { /* Any failure means that we found nothing */ }

    return false;
  };
}


/***/ }),

/***/ 11159:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var adapter = __nccwpck_require__(63451);

/**
 * Extracts the values from process.env.
 *
 * @type {Function}
 * @public
 */
module.exports = adapter(function processenv() {
  return process.env.DEBUG || process.env.DIAGNOSTICS;
});


/***/ }),

/***/ 39094:
/***/ ((module) => {

/**
 * Contains all configured adapters for the given environment.
 *
 * @type {Array}
 * @public
 */
var adapters = [];

/**
 * Contains all modifier functions.
 *
 * @typs {Array}
 * @public
 */
var modifiers = [];

/**
 * Our default logger.
 *
 * @public
 */
var logger = function devnull() {};

/**
 * Register a new adapter that will used to find environments.
 *
 * @param {Function} adapter A function that will return the possible env.
 * @returns {Boolean} Indication of a successful add.
 * @public
 */
function use(adapter) {
  if (~adapters.indexOf(adapter)) return false;

  adapters.push(adapter);
  return true;
}

/**
 * Assign a new log method.
 *
 * @param {Function} custom The log method.
 * @public
 */
function set(custom) {
  logger = custom;
}

/**
 * Check if the namespace is allowed by any of our adapters.
 *
 * @param {String} namespace The namespace that needs to be enabled
 * @returns {Boolean|Promise} Indication if the namespace is enabled by our adapters.
 * @public
 */
function enabled(namespace) {
  var async = [];

  for (var i = 0; i < adapters.length; i++) {
    if (adapters[i].async) {
      async.push(adapters[i]);
      continue;
    }

    if (adapters[i](namespace)) return true;
  }

  if (!async.length) return false;

  //
  // Now that we know that we Async functions, we know we run in an ES6
  // environment and can use all the API's that they offer, in this case
  // we want to return a Promise so that we can `await` in React-Native
  // for an async adapter.
  //
  return new Promise(function pinky(resolve) {
    Promise.all(
      async.map(function prebind(fn) {
        return fn(namespace);
      })
    ).then(function resolved(values) {
      resolve(values.some(Boolean));
    });
  });
}

/**
 * Add a new message modifier to the debugger.
 *
 * @param {Function} fn Modification function.
 * @returns {Boolean} Indication of a successful add.
 * @public
 */
function modify(fn) {
  if (~modifiers.indexOf(fn)) return false;

  modifiers.push(fn);
  return true;
}

/**
 * Write data to the supplied logger.
 *
 * @param {Object} meta Meta information about the log.
 * @param {Array} args Arguments for console.log.
 * @public
 */
function write() {
  logger.apply(logger, arguments);
}

/**
 * Process the message with the modifiers.
 *
 * @param {Mixed} message The message to be transformed by modifers.
 * @returns {String} Transformed message.
 * @public
 */
function process(message) {
  for (var i = 0; i < modifiers.length; i++) {
    message = modifiers[i].apply(modifiers[i], arguments);
  }

  return message;
}

/**
 * Introduce options to the logger function.
 *
 * @param {Function} fn Calback function.
 * @param {Object} options Properties to introduce on fn.
 * @returns {Function} The passed function
 * @public
 */
function introduce(fn, options) {
  var has = Object.prototype.hasOwnProperty;

  for (var key in options) {
    if (has.call(options, key)) {
      fn[key] = options[key];
    }
  }

  return fn;
}

/**
 * Nope, we're not allowed to write messages.
 *
 * @returns {Boolean} false
 * @public
 */
function nope(options) {
  options.enabled = false;
  options.modify = modify;
  options.set = set;
  options.use = use;

  return introduce(function diagnopes() {
    return false;
  }, options);
}

/**
 * Yep, we're allowed to write debug messages.
 *
 * @param {Object} options The options for the process.
 * @returns {Function} The function that does the logging.
 * @public
 */
function yep(options) {
  /**
   * The function that receives the actual debug information.
   *
   * @returns {Boolean} indication that we're logging.
   * @public
   */
  function diagnostics() {
    var args = Array.prototype.slice.call(arguments, 0);

    write.call(write, options, process(args, options));
    return true;
  }

  options.enabled = true;
  options.modify = modify;
  options.set = set;
  options.use = use;

  return introduce(diagnostics, options);
}

/**
 * Simple helper function to introduce various of helper methods to our given
 * diagnostics function.
 *
 * @param {Function} diagnostics The diagnostics function.
 * @returns {Function} diagnostics
 * @public
 */
module.exports = function create(diagnostics) {
  diagnostics.introduce = introduce;
  diagnostics.enabled = enabled;
  diagnostics.process = process;
  diagnostics.modify = modify;
  diagnostics.write = write;
  diagnostics.nope = nope;
  diagnostics.yep = yep;
  diagnostics.set = set;
  diagnostics.use = use;

  return diagnostics;
}


/***/ }),

/***/ 60602:
/***/ ((module) => {

/**
 * An idiot proof logger to be used as default. We've wrapped it in a try/catch
 * statement to ensure the environments without the `console` API do not crash
 * as well as an additional fix for ancient browsers like IE8 where the
 * `console.log` API doesn't have an `apply`, so we need to use the Function's
 * apply functionality to apply the arguments.
 *
 * @param {Object} meta Options of the logger.
 * @param {Array} messages The actuall message that needs to be logged.
 * @public
 */
module.exports = function (meta, messages) {
  //
  // So yea. IE8 doesn't have an apply so we need a work around to puke the
  // arguments in place.
  //
  try { Function.prototype.apply.call(console.log, console, messages); }
  catch (e) {}
}


/***/ }),

/***/ 60910:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var colorspace = __nccwpck_require__(44174);
var kuler = __nccwpck_require__(19703);

/**
 * Prefix the messages with a colored namespace.
 *
 * @param {Array} args The messages array that is getting written.
 * @param {Object} options Options for diagnostics.
 * @returns {Array} Altered messages array.
 * @public
 */
module.exports = function ansiModifier(args, options) {
  var namespace = options.namespace;
  var ansi = options.colors !== false
  ? kuler(namespace +':', colorspace(namespace))
  : namespace +':';

  args[0] = ansi +' '+ args[0];
  return args;
};


/***/ }),

/***/ 57570:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var create = __nccwpck_require__(39094);
var tty = (__nccwpck_require__(52018).isatty)(1);

/**
 * Create a new diagnostics logger.
 *
 * @param {String} namespace The namespace it should enable.
 * @param {Object} options Additional options.
 * @returns {Function} The logger.
 * @public
 */
var diagnostics = create(function dev(namespace, options) {
  options = options || {};
  options.colors = 'colors' in options ? options.colors : tty;
  options.namespace = namespace;
  options.prod = false;
  options.dev = true;

  if (!dev.enabled(namespace) && !(options.force || dev.force)) {
    return dev.nope(options);
  }
  
  return dev.yep(options);
});

//
// Configure the logger for the given environment.
//
diagnostics.modify(__nccwpck_require__(60910));
diagnostics.use(__nccwpck_require__(11159));
diagnostics.set(__nccwpck_require__(60602));

//
// Expose the diagnostics logger.
//
module.exports = diagnostics;


/***/ }),

/***/ 1379:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

//
// Select the correct build version depending on the environment.
//
if (process.env.NODE_ENV === 'production') {
  module.exports = __nccwpck_require__(86400);
} else {
  module.exports = __nccwpck_require__(57570);
}


/***/ }),

/***/ 86400:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var create = __nccwpck_require__(39094);

/**
 * Create a new diagnostics logger.
 *
 * @param {String} namespace The namespace it should enable.
 * @param {Object} options Additional options.
 * @returns {Function} The logger.
 * @public
 */
var diagnostics = create(function prod(namespace, options) {
  options = options || {};
  options.namespace = namespace;
  options.prod = true;
  options.dev = false;

  if (!(options.force || prod.force)) return prod.nope(options);
  return prod.yep(options);
});

//
// Expose the diagnostics logger.
//
module.exports = diagnostics;


/***/ }),

/***/ 70148:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.uriDecode = void 0;
const HEX = {
    '0': 0,
    '1': 1,
    '2': 2,
    '3': 3,
    '4': 4,
    '5': 5,
    '6': 6,
    '7': 7,
    '8': 8,
    '9': 9,
    a: 10,
    A: 10,
    b: 11,
    B: 11,
    c: 12,
    C: 12,
    d: 13,
    D: 13,
    e: 14,
    E: 14,
    f: 15,
    F: 15
};
const UTF8 = {
    accept: 12,
    reject: 0,
    data: [
        // Maps bytes to character to a transition
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2,
        2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
        3, 3, 3, 3, 3, 3, 3, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
        5, 5, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 8, 7, 7, 10, 9, 9, 9, 11, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
        // Maps a state to a new state when adding a transition
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 0, 0, 0, 0, 24, 36, 48, 60, 72, 84, 96, 0, 12, 12, 12, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24, 24, 24, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24, 24, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 48, 48, 48, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 48, 48, 0, 0, 0, 0, 0, 0, 0, 0, 0, 48, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0,
        // Maps the current transition to a mask that needs to apply to the byte
        0x7f, 0x3f, 0x3f, 0x3f, 0x00, 0x1f, 0x0f, 0x0f, 0x0f, 0x07, 0x07, 0x07
    ]
};
/**
 * Faster version of decodeURIComponent() that does not throw.
 *
 * @param string - the URL string to decode.
 *
 * @returns the decoded string or null if invalid.
 */
function uriDecode(string) {
    let percentPos = string.indexOf('%');
    if (percentPos === -1) {
        return string;
    }
    let decoded = '';
    let last = 0;
    let codepoint = 0;
    let startOfOctets = percentPos;
    let state = UTF8.accept;
    while (percentPos > -1 && percentPos < string.length) {
        const high = resolveHex(string[percentPos + 1], 4);
        const low = resolveHex(string[percentPos + 2], 0);
        const byte = high | low;
        const type = UTF8.data[byte];
        state = UTF8.data[256 + state + type];
        codepoint = (codepoint << 6) | (byte & UTF8.data[364 + type]);
        if (state === UTF8.accept) {
            decoded += string.slice(last, startOfOctets);
            decoded +=
                codepoint <= 0xffff
                    ? String.fromCharCode(codepoint)
                    : String.fromCharCode(0xd7c0 + (codepoint >> 10), 0xdc00 + (codepoint & 0x3ff));
            codepoint = 0;
            last = percentPos + 3;
            percentPos = string.indexOf('%', last);
            startOfOctets = percentPos;
            continue;
        }
        if (state === UTF8.reject) {
            return null;
        }
        percentPos += 3;
        if (percentPos >= string.length || string[percentPos] !== '%') {
            return null;
        }
    }
    return decoded + string.slice(last);
}
exports.uriDecode = uriDecode;
function resolveHex(char, shift) {
    const i = HEX[char];
    return i === undefined ? 255 : i << shift;
}
// Adapted from:
// Copyright (c) 2017-2019 Justin Ridgewell, MIT Licensed, https://github.com/jridgewell/safe-decode-string-component
// Copyright (c) 2008-2009 Bjoern Hoehrmann <bjoern@hoehrmann.de>, MIT Licensed, http://bjoern.hoehrmann.de/utf-8/decoder/dfa/
//# sourceMappingURL=decode.js.map

/***/ }),

/***/ 3386:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.validateDomainOptions = exports.isDomainValid = exports.analyzeDomain = void 0;
const Url = __nccwpck_require__(87016);
const errors_1 = __nccwpck_require__(28161);
const MIN_DOMAIN_SEGMENTS = 2;
const NON_ASCII_RX = /[^\x00-\x7f]/;
const DOMAIN_CONTROL_RX = /[\x00-\x20@\:\/\\#!\$&\'\(\)\*\+,;=\?]/; // Control + space + separators
const TLD_SEGMENT_RX = /^[a-zA-Z](?:[a-zA-Z0-9\-]*[a-zA-Z0-9])?$/;
const DOMAIN_SEGMENT_RX = /^[a-zA-Z0-9](?:[a-zA-Z0-9\-]*[a-zA-Z0-9])?$/;
const DOMAIN_UNDERSCORE_SEGMENT_RX = /^[a-zA-Z0-9_](?:[a-zA-Z0-9\-]*[a-zA-Z0-9])?$/;
const URL_IMPL = Url.URL || URL; // $lab:coverage:ignore$
function isTldsAllow(tlds) {
    return !!tlds.allow;
}
/**
 * Analyzes a string to verify it is a valid domain name.
 *
 * @param domain - the domain name to validate.
 * @param options - optional settings.
 *
 * @return - undefined when valid, otherwise an object with single error key with a string message value.
 */
function analyzeDomain(domain, options = {}) {
    if (!domain) {
        // Catch null / undefined
        return (0, errors_1.errorCode)('DOMAIN_NON_EMPTY_STRING');
    }
    if (typeof domain !== 'string') {
        throw new Error('Invalid input: domain must be a string');
    }
    if (domain.length > 256) {
        return (0, errors_1.errorCode)('DOMAIN_TOO_LONG');
    }
    const ascii = !NON_ASCII_RX.test(domain);
    if (!ascii) {
        if (options.allowUnicode === false) {
            // Defaults to true
            return (0, errors_1.errorCode)('DOMAIN_INVALID_UNICODE_CHARS');
        }
        domain = domain.normalize('NFC');
    }
    if (DOMAIN_CONTROL_RX.test(domain)) {
        return (0, errors_1.errorCode)('DOMAIN_INVALID_CHARS');
    }
    domain = punycode(domain);
    // https://tools.ietf.org/html/rfc1035 section 2.3.1
    if (options.allowFullyQualified && domain[domain.length - 1] === '.') {
        domain = domain.slice(0, -1);
    }
    const minDomainSegments = options.minDomainSegments || MIN_DOMAIN_SEGMENTS;
    const segments = domain.split('.');
    if (segments.length < minDomainSegments) {
        return (0, errors_1.errorCode)('DOMAIN_SEGMENTS_COUNT');
    }
    if (options.maxDomainSegments) {
        if (segments.length > options.maxDomainSegments) {
            return (0, errors_1.errorCode)('DOMAIN_SEGMENTS_COUNT_MAX');
        }
    }
    const tlds = options.tlds;
    if (tlds) {
        const tld = segments[segments.length - 1].toLowerCase();
        if (isTldsAllow(tlds)) {
            if (!tlds.allow.has(tld)) {
                return (0, errors_1.errorCode)('DOMAIN_FORBIDDEN_TLDS');
            }
        }
        else if (tlds.deny.has(tld)) {
            return (0, errors_1.errorCode)('DOMAIN_FORBIDDEN_TLDS');
        }
    }
    for (let i = 0; i < segments.length; ++i) {
        const segment = segments[i];
        if (!segment.length) {
            return (0, errors_1.errorCode)('DOMAIN_EMPTY_SEGMENT');
        }
        if (segment.length > 63) {
            return (0, errors_1.errorCode)('DOMAIN_LONG_SEGMENT');
        }
        if (i < segments.length - 1) {
            if (options.allowUnderscore) {
                if (!DOMAIN_UNDERSCORE_SEGMENT_RX.test(segment)) {
                    return (0, errors_1.errorCode)('DOMAIN_INVALID_CHARS');
                }
            }
            else {
                if (!DOMAIN_SEGMENT_RX.test(segment)) {
                    return (0, errors_1.errorCode)('DOMAIN_INVALID_CHARS');
                }
            }
        }
        else {
            if (!TLD_SEGMENT_RX.test(segment)) {
                return (0, errors_1.errorCode)('DOMAIN_INVALID_TLDS_CHARS');
            }
        }
    }
    return null;
}
exports.analyzeDomain = analyzeDomain;
/**
 * Analyzes a string to verify it is a valid domain name.
 *
 * @param domain - the domain name to validate.
 * @param options - optional settings.
 *
 * @return - true when valid, otherwise false.
 */
function isDomainValid(domain, options) {
    return !analyzeDomain(domain, options);
}
exports.isDomainValid = isDomainValid;
function punycode(domain) {
    if (domain.includes('%')) {
        domain = domain.replace(/%/g, '%25');
    }
    try {
        return new URL_IMPL(`http://${domain}`).host;
    }
    catch (err) {
        return domain;
    }
}
function validateDomainOptions(options) {
    if (!options) {
        return;
    }
    if (typeof options.tlds !== 'object') {
        throw new Error('Invalid options: tlds must be a boolean or an object');
    }
    if (isTldsAllow(options.tlds)) {
        if (options.tlds.allow instanceof Set === false) {
            throw new Error('Invalid options: tlds.allow must be a Set object or true');
        }
        if (options.tlds.deny) {
            throw new Error('Invalid options: cannot specify both tlds.allow and tlds.deny lists');
        }
    }
    else {
        if (options.tlds.deny instanceof Set === false) {
            throw new Error('Invalid options: tlds.deny must be a Set object');
        }
    }
}
exports.validateDomainOptions = validateDomainOptions;
//# sourceMappingURL=domain.js.map

/***/ }),

/***/ 35108:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isEmailValid = exports.analyzeEmail = void 0;
const Util = __nccwpck_require__(39023);
const domain_1 = __nccwpck_require__(3386);
const errors_1 = __nccwpck_require__(28161);
const NON_ASCII_RX = /[^\x00-\x7f]/;
const ENCODER_IMPL = new (Util.TextEncoder || TextEncoder)(); // $lab:coverage:ignore$
/**
 * Analyzes a string to verify it is a valid email address.
 *
 * @param email - the email address to validate.
 * @param options - optional settings.
 *
 * @return - undefined when valid, otherwise an object with single error key with a string message value.
 */
function analyzeEmail(email, options) {
    return validateEmail(email, options);
}
exports.analyzeEmail = analyzeEmail;
/**
 * Analyzes a string to verify it is a valid email address.
 *
 * @param email - the email address to validate.
 * @param options - optional settings.
 *
 * @return - true when valid, otherwise false.
 */
function isEmailValid(email, options) {
    return !validateEmail(email, options);
}
exports.isEmailValid = isEmailValid;
function validateEmail(email, options = {}) {
    if (typeof email !== 'string') {
        throw new Error('Invalid input: email must be a string');
    }
    if (!email) {
        return (0, errors_1.errorCode)('EMPTY_STRING');
    }
    // Unicode
    const ascii = !NON_ASCII_RX.test(email);
    if (!ascii) {
        if (options.allowUnicode === false) {
            // Defaults to true
            return (0, errors_1.errorCode)('FORBIDDEN_UNICODE');
        }
        email = email.normalize('NFC');
    }
    // Basic structure
    const parts = email.split('@');
    if (parts.length !== 2) {
        return parts.length > 2 ? (0, errors_1.errorCode)('MULTIPLE_AT_CHAR') : (0, errors_1.errorCode)('MISSING_AT_CHAR');
    }
    const [local, domain] = parts;
    if (!local) {
        return (0, errors_1.errorCode)('EMPTY_LOCAL');
    }
    if (!options.ignoreLength) {
        if (email.length > 254) {
            // http://tools.ietf.org/html/rfc5321#section-4.5.3.1.3
            return (0, errors_1.errorCode)('ADDRESS_TOO_LONG');
        }
        if (ENCODER_IMPL.encode(local).length > 64) {
            // http://tools.ietf.org/html/rfc5321#section-4.5.3.1.1
            return (0, errors_1.errorCode)('LOCAL_TOO_LONG');
        }
    }
    // Validate parts
    return validateLocal(local, ascii) || (0, domain_1.analyzeDomain)(domain, options);
}
function validateLocal(local, ascii) {
    const segments = local.split('.');
    for (const segment of segments) {
        if (!segment.length) {
            return (0, errors_1.errorCode)('EMPTY_LOCAL_SEGMENT');
        }
        if (ascii) {
            if (!ATEXT_RX.test(segment)) {
                return (0, errors_1.errorCode)('INVALID_LOCAL_CHARS');
            }
            continue;
        }
        for (const char of segment) {
            if (ATEXT_RX.test(char)) {
                continue;
            }
            const binary = toBinary(char);
            if (!ATOM_RX.test(binary)) {
                return (0, errors_1.errorCode)('INVALID_LOCAL_CHARS');
            }
        }
    }
    return null;
}
function toBinary(char) {
    return Array.from(ENCODER_IMPL.encode(char), (v) => String.fromCharCode(v)).join('');
}
/*
    From RFC 5321:

        Mailbox         =   Local-part "@" ( Domain / address-literal )

        Local-part      =   Dot-string / Quoted-string
        Dot-string      =   Atom *("."  Atom)
        Atom            =   1*atext
        atext           =   ALPHA / DIGIT / "!" / "#" / "$" / "%" / "&" / "'" / "*" / "+" / "-" / "/" / "=" / "?" / "^" / "_" / "`" / "{" / "|" / "}" / "~"

        Domain          =   sub-domain *("." sub-domain)
        sub-domain      =   Let-dig [Ldh-str]
        Let-dig         =   ALPHA / DIGIT
        Ldh-str         =   *( ALPHA / DIGIT / "-" ) Let-dig

        ALPHA           =   %x41-5A / %x61-7A        ; a-z, A-Z
        DIGIT           =   %x30-39                  ; 0-9

    From RFC 6531:

        sub-domain      =/  U-label
        atext           =/  UTF8-non-ascii

        UTF8-non-ascii  =   UTF8-2 / UTF8-3 / UTF8-4

        UTF8-2          =   %xC2-DF UTF8-tail
        UTF8-3          =   %xE0 %xA0-BF UTF8-tail /
                            %xE1-EC 2( UTF8-tail ) /
                            %xED %x80-9F UTF8-tail /
                            %xEE-EF 2( UTF8-tail )
        UTF8-4          =   %xF0 %x90-BF 2( UTF8-tail ) /
                            %xF1-F3 3( UTF8-tail ) /
                            %xF4 %x80-8F 2( UTF8-tail )

        UTF8-tail       =   %x80-BF

    Note: The following are not supported:

        RFC 5321: address-literal, Quoted-string
        RFC 5322: obs-*, CFWS
*/
const ATEXT_RX = /^[\w!#\$%&'\*\+\-/=\?\^`\{\|\}~]+$/; // _ included in \w
const ATOM_RX = new RegExp([
    //  %xC2-DF UTF8-tail
    '(?:[\\xc2-\\xdf][\\x80-\\xbf])',
    //  %xE0 %xA0-BF UTF8-tail              %xE1-EC 2( UTF8-tail )            %xED %x80-9F UTF8-tail              %xEE-EF 2( UTF8-tail )
    '(?:\\xe0[\\xa0-\\xbf][\\x80-\\xbf])|(?:[\\xe1-\\xec][\\x80-\\xbf]{2})|(?:\\xed[\\x80-\\x9f][\\x80-\\xbf])|(?:[\\xee-\\xef][\\x80-\\xbf]{2})',
    //  %xF0 %x90-BF 2( UTF8-tail )            %xF1-F3 3( UTF8-tail )            %xF4 %x80-8F 2( UTF8-tail )
    '(?:\\xf0[\\x90-\\xbf][\\x80-\\xbf]{2})|(?:[\\xf1-\\xf3][\\x80-\\xbf]{3})|(?:\\xf4[\\x80-\\x8f][\\x80-\\xbf]{2})'
].join('|'));
//# sourceMappingURL=email.js.map

/***/ }),

/***/ 28161:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.errorCode = exports.errorCodes = void 0;
exports.errorCodes = {
    EMPTY_STRING: 'Address must be a non-empty string',
    FORBIDDEN_UNICODE: 'Address contains forbidden Unicode characters',
    MULTIPLE_AT_CHAR: 'Address cannot contain more than one @ character',
    MISSING_AT_CHAR: 'Address must contain one @ character',
    EMPTY_LOCAL: 'Address local part cannot be empty',
    ADDRESS_TOO_LONG: 'Address too long',
    LOCAL_TOO_LONG: 'Address local part too long',
    EMPTY_LOCAL_SEGMENT: 'Address local part contains empty dot-separated segment',
    INVALID_LOCAL_CHARS: 'Address local part contains invalid character',
    DOMAIN_NON_EMPTY_STRING: 'Domain must be a non-empty string',
    DOMAIN_TOO_LONG: 'Domain too long',
    DOMAIN_INVALID_UNICODE_CHARS: 'Domain contains forbidden Unicode characters',
    DOMAIN_INVALID_CHARS: 'Domain contains invalid character',
    DOMAIN_INVALID_TLDS_CHARS: 'Domain contains invalid tld character',
    DOMAIN_SEGMENTS_COUNT: 'Domain lacks the minimum required number of segments',
    DOMAIN_SEGMENTS_COUNT_MAX: 'Domain contains too many segments',
    DOMAIN_FORBIDDEN_TLDS: 'Domain uses forbidden TLD',
    DOMAIN_EMPTY_SEGMENT: 'Domain contains empty dot-separated segment',
    DOMAIN_LONG_SEGMENT: 'Domain contains dot-separated segment that is too long'
};
function errorCode(code) {
    return { code, error: exports.errorCodes[code] };
}
exports.errorCode = errorCode;
//# sourceMappingURL=errors.js.map

/***/ }),

/***/ 12336:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.uriDecode = exports.uriRegex = exports.ipRegex = exports.errorCodes = void 0;
__exportStar(__nccwpck_require__(3386), exports);
__exportStar(__nccwpck_require__(35108), exports);
var errors_1 = __nccwpck_require__(28161);
Object.defineProperty(exports, "errorCodes", ({ enumerable: true, get: function () { return errors_1.errorCodes; } }));
var ip_1 = __nccwpck_require__(79715);
Object.defineProperty(exports, "ipRegex", ({ enumerable: true, get: function () { return ip_1.ipRegex; } }));
var uri_1 = __nccwpck_require__(21198);
Object.defineProperty(exports, "uriRegex", ({ enumerable: true, get: function () { return uri_1.uriRegex; } }));
var decode_1 = __nccwpck_require__(70148);
Object.defineProperty(exports, "uriDecode", ({ enumerable: true, get: function () { return decode_1.uriDecode; } }));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 79715:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ipRegex = void 0;
const hoek_1 = __nccwpck_require__(91884);
const uri_1 = __nccwpck_require__(21198);
/**
 * Generates a regular expression used to validate IP addresses.
 *
 * @param options - optional settings.
 *
 * @returns an object with the regular expression and meta data.
 */
function ipRegex(options = {}) {
    // CIDR
    const cidr = options.cidr || 'optional';
    (0, hoek_1.assert)(['required', 'optional', 'forbidden'].includes(cidr), 'options.cidr must be one of required, optional, forbidden');
    // Versions
    (0, hoek_1.assert)(options.version === undefined || typeof options.version === 'string' || Array.isArray(options.version), 'options.version must be a string or an array of string');
    let versions = options.version || ['ipv4', 'ipv6', 'ipvfuture'];
    if (!Array.isArray(versions)) {
        versions = [versions];
    }
    (0, hoek_1.assert)(versions.length >= 1, 'options.version must have at least 1 version specified');
    for (const version of versions) {
        (0, hoek_1.assert)(typeof version === 'string' && version === version.toLowerCase(), 'Invalid options.version value');
        (0, hoek_1.assert)(['ipv4', 'ipv6', 'ipvfuture'].includes(version), 'options.version contains unknown version ' + version + ' - must be one of ipv4, ipv6, ipvfuture');
    }
    versions = Array.from(new Set(versions));
    // Regex
    const parts = versions.map((version) => {
        // Forbidden
        if (cidr === 'forbidden') {
            return uri_1.ipVersions[version];
        }
        // Required
        const cidrpart = `\\/${version === 'ipv4' ? uri_1.ipVersions.v4Cidr : uri_1.ipVersions.v6Cidr}`;
        if (cidr === 'required') {
            return `${uri_1.ipVersions[version]}${cidrpart}`;
        }
        // Optional
        return `${uri_1.ipVersions[version]}(?:${cidrpart})?`;
    });
    const raw = `(?:${parts.join('|')})`;
    const regex = new RegExp(`^${raw}$`);
    return { cidr, versions, regex, raw };
}
exports.ipRegex = ipRegex;
//# sourceMappingURL=ip.js.map

/***/ }),

/***/ 21198:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.uriRegex = exports.ipVersions = void 0;
const hoek_1 = __nccwpck_require__(91884);
function generate() {
    const rfc3986 = {};
    const hexDigit = '\\dA-Fa-f'; // HEXDIG = DIGIT / "A" / "B" / "C" / "D" / "E" / "F"
    const hexDigitOnly = '[' + hexDigit + ']';
    const unreserved = '\\w-\\.~'; // unreserved = ALPHA / DIGIT / "-" / "." / "_" / "~"
    const subDelims = "!\\$&'\\(\\)\\*\\+,;="; // sub-delims = "!" / "$" / "&" / "'" / "(" / ")" / "*" / "+" / "," / ";" / "="
    const pctEncoded = '%' + hexDigit; // pct-encoded = "%" HEXDIG HEXDIG
    const pchar = unreserved + pctEncoded + subDelims + ':@'; // pchar = unreserved / pct-encoded / sub-delims / ":" / "@"
    const pcharOnly = '[' + pchar + ']';
    const decOctect = '(?:0{0,2}\\d|0?[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5])'; // dec-octet = DIGIT / %x31-39 DIGIT / "1" 2DIGIT / "2" %x30-34 DIGIT / "25" %x30-35  ; 0-9 / 10-99 / 100-199 / 200-249 / 250-255
    rfc3986.ipv4address = '(?:' + decOctect + '\\.){3}' + decOctect; // IPv4address = dec-octet "." dec-octet "." dec-octet "." dec-octet
    /*
        h16 = 1*4HEXDIG ; 16 bits of address represented in hexadecimal
        ls32 = ( h16 ":" h16 ) / IPv4address ; least-significant 32 bits of address
        IPv6address =                            6( h16 ":" ) ls32
                    /                       "::" 5( h16 ":" ) ls32
                    / [               h16 ] "::" 4( h16 ":" ) ls32
                    / [ *1( h16 ":" ) h16 ] "::" 3( h16 ":" ) ls32
                    / [ *2( h16 ":" ) h16 ] "::" 2( h16 ":" ) ls32
                    / [ *3( h16 ":" ) h16 ] "::"    h16 ":"   ls32
                    / [ *4( h16 ":" ) h16 ] "::"              ls32
                    / [ *5( h16 ":" ) h16 ] "::"              h16
                    / [ *6( h16 ":" ) h16 ] "::"
    */
    const h16 = hexDigitOnly + '{1,4}';
    const ls32 = '(?:' + h16 + ':' + h16 + '|' + rfc3986.ipv4address + ')';
    const IPv6SixHex = '(?:' + h16 + ':){6}' + ls32;
    const IPv6FiveHex = '::(?:' + h16 + ':){5}' + ls32;
    const IPv6FourHex = '(?:' + h16 + ')?::(?:' + h16 + ':){4}' + ls32;
    const IPv6ThreeHex = '(?:(?:' + h16 + ':){0,1}' + h16 + ')?::(?:' + h16 + ':){3}' + ls32;
    const IPv6TwoHex = '(?:(?:' + h16 + ':){0,2}' + h16 + ')?::(?:' + h16 + ':){2}' + ls32;
    const IPv6OneHex = '(?:(?:' + h16 + ':){0,3}' + h16 + ')?::' + h16 + ':' + ls32;
    const IPv6NoneHex = '(?:(?:' + h16 + ':){0,4}' + h16 + ')?::' + ls32;
    const IPv6NoneHex2 = '(?:(?:' + h16 + ':){0,5}' + h16 + ')?::' + h16;
    const IPv6NoneHex3 = '(?:(?:' + h16 + ':){0,6}' + h16 + ')?::';
    rfc3986.ipv4Cidr = '(?:\\d|[1-2]\\d|3[0-2])'; // IPv4 cidr = DIGIT / %x31-32 DIGIT / "3" %x30-32  ; 0-9 / 10-29 / 30-32
    rfc3986.ipv6Cidr = '(?:0{0,2}\\d|0?[1-9]\\d|1[01]\\d|12[0-8])'; // IPv6 cidr = DIGIT / %x31-39 DIGIT / "1" %x0-1 DIGIT / "12" %x0-8;   0-9 / 10-99 / 100-119 / 120-128
    rfc3986.ipv6address =
        '(?:' +
            IPv6SixHex +
            '|' +
            IPv6FiveHex +
            '|' +
            IPv6FourHex +
            '|' +
            IPv6ThreeHex +
            '|' +
            IPv6TwoHex +
            '|' +
            IPv6OneHex +
            '|' +
            IPv6NoneHex +
            '|' +
            IPv6NoneHex2 +
            '|' +
            IPv6NoneHex3 +
            ')';
    rfc3986.ipvFuture = 'v' + hexDigitOnly + '+\\.[' + unreserved + subDelims + ':]+'; // IPvFuture = "v" 1*HEXDIG "." 1*( unreserved / sub-delims / ":" )
    rfc3986.scheme = '[a-zA-Z][a-zA-Z\\d+-\\.]*'; // scheme = ALPHA *( ALPHA / DIGIT / "+" / "-" / "." )
    rfc3986.schemeRegex = new RegExp(rfc3986.scheme);
    const userinfo = '[' + unreserved + pctEncoded + subDelims + ':]*'; // userinfo = *( unreserved / pct-encoded / sub-delims / ":" )
    const IPLiteral = '\\[(?:' + rfc3986.ipv6address + '|' + rfc3986.ipvFuture + ')\\]'; // IP-literal = "[" ( IPv6address / IPvFuture  ) "]"
    const regName = '[' + unreserved + pctEncoded + subDelims + ']{1,255}'; // reg-name = *( unreserved / pct-encoded / sub-delims )
    const host = '(?:' + IPLiteral + '|' + rfc3986.ipv4address + '|' + regName + ')'; // host = IP-literal / IPv4address / reg-name
    const port = '\\d*'; // port = *DIGIT
    const authority = '(?:' + userinfo + '@)?' + host + '(?::' + port + ')?'; // authority   = [ userinfo "@" ] host [ ":" port ]
    const authorityCapture = '(?:' + userinfo + '@)?(' + host + ')(?::' + port + ')?';
    /*
        segment       = *pchar
        segment-nz    = 1*pchar
        path          = path-abempty    ; begins with "/" '|' is empty
                    / path-absolute   ; begins with "/" but not "//"
                    / path-noscheme   ; begins with a non-colon segment
                    / path-rootless   ; begins with a segment
                    / path-empty      ; zero characters
        path-abempty  = *( "/" segment )
        path-absolute = "/" [ segment-nz *( "/" segment ) ]
        path-rootless = segment-nz *( "/" segment )
    */
    const segment = pcharOnly + '*';
    const segmentNz = pcharOnly + '+';
    const segmentNzNc = '[' + unreserved + pctEncoded + subDelims + '@' + ']+';
    const pathEmpty = '';
    const pathAbEmpty = '(?:\\/' + segment + ')*';
    const pathAbsolute = '\\/(?:' + segmentNz + pathAbEmpty + ')?';
    const pathRootless = segmentNz + pathAbEmpty;
    const pathNoScheme = segmentNzNc + pathAbEmpty;
    const pathAbNoAuthority = '(?:\\/\\/\\/' + segment + pathAbEmpty + ')'; // Used by file:///
    // hier-part = "//" authority path
    rfc3986.hierPart =
        '(?:' +
            '(?:\\/\\/' +
            authority +
            pathAbEmpty +
            ')' +
            '|' +
            pathAbsolute +
            '|' +
            pathRootless +
            '|' +
            pathAbNoAuthority +
            ')';
    rfc3986.hierPartCapture =
        '(?:' + '(?:\\/\\/' + authorityCapture + pathAbEmpty + ')' + '|' + pathAbsolute + '|' + pathRootless + ')';
    // relative-part = "//" authority path-abempty / path-absolute / path-noscheme / path-empty
    rfc3986.relativeRef =
        '(?:' +
            '(?:\\/\\/' +
            authority +
            pathAbEmpty +
            ')' +
            '|' +
            pathAbsolute +
            '|' +
            pathNoScheme +
            '|' +
            pathEmpty +
            ')';
    rfc3986.relativeRefCapture =
        '(?:' +
            '(?:\\/\\/' +
            authorityCapture +
            pathAbEmpty +
            ')' +
            '|' +
            pathAbsolute +
            '|' +
            pathNoScheme +
            '|' +
            pathEmpty +
            ')';
    // query = *( pchar / "/" / "?" )
    // query = *( pchar / "[" / "]" / "/" / "?" )
    rfc3986.query = '[' + pchar + '\\/\\?]*(?=#|$)'; //Finish matching either at the fragment part '|' end of the line.
    rfc3986.queryWithSquareBrackets = '[' + pchar + '\\[\\]\\/\\?]*(?=#|$)';
    // fragment = *( pchar / "/" / "?" )
    rfc3986.fragment = '[' + pchar + '\\/\\?]*';
    return rfc3986;
}
const rfc3986 = generate();
exports.ipVersions = {
    v4Cidr: rfc3986.ipv4Cidr,
    v6Cidr: rfc3986.ipv6Cidr,
    ipv4: rfc3986.ipv4address,
    ipv6: rfc3986.ipv6address,
    ipvfuture: rfc3986.ipvFuture
};
function createRegex(options) {
    const rfc = rfc3986;
    // Construct expression
    const query = options.allowQuerySquareBrackets ? rfc.queryWithSquareBrackets : rfc.query;
    const suffix = '(?:\\?' + query + ')?' + '(?:#' + rfc.fragment + ')?';
    // relative-ref = relative-part [ "?" query ] [ "#" fragment ]
    const relative = options.domain ? rfc.relativeRefCapture : rfc.relativeRef;
    if (options.relativeOnly) {
        return wrap(relative + suffix);
    }
    // Custom schemes
    let customScheme = '';
    if (options.scheme) {
        (0, hoek_1.assert)(options.scheme instanceof RegExp || typeof options.scheme === 'string' || Array.isArray(options.scheme), 'scheme must be a RegExp, String, or Array');
        const schemes = [].concat(options.scheme);
        (0, hoek_1.assert)(schemes.length >= 1, 'scheme must have at least 1 scheme specified');
        // Flatten the array into a string to be used to match the schemes
        const selections = [];
        for (let i = 0; i < schemes.length; ++i) {
            const scheme = schemes[i];
            (0, hoek_1.assert)(scheme instanceof RegExp || typeof scheme === 'string', 'scheme at position ' + i + ' must be a RegExp or String');
            if (scheme instanceof RegExp) {
                selections.push(scheme.source.toString());
            }
            else {
                (0, hoek_1.assert)(rfc.schemeRegex.test(scheme), 'scheme at position ' + i + ' must be a valid scheme');
                selections.push((0, hoek_1.escapeRegex)(scheme));
            }
        }
        customScheme = selections.join('|');
    }
    // URI = scheme ":" hier-part [ "?" query ] [ "#" fragment ]
    const scheme = customScheme ? '(?:' + customScheme + ')' : rfc.scheme;
    const absolute = '(?:' + scheme + ':' + (options.domain ? rfc.hierPartCapture : rfc.hierPart) + ')';
    const prefix = options.allowRelative ? '(?:' + absolute + '|' + relative + ')' : absolute;
    return wrap(prefix + suffix, customScheme);
}
function wrap(raw, scheme = null) {
    raw = `(?=.)(?!https?\:/(?:$|[^/]))(?!https?\:///)(?!https?\:[^/])${raw}`; // Require at least one character and explicitly forbid 'http:/' or HTTP with empty domain
    return {
        raw,
        regex: new RegExp(`^${raw}$`),
        scheme
    };
}
const genericUriRegex = createRegex({});
/**
 * Generates a regular expression used to validate URI addresses.
 *
 * @param options - optional settings.
 *
 * @returns an object with the regular expression and meta data.
 */
function uriRegex(options = {}) {
    if (options.scheme ||
        options.allowRelative ||
        options.relativeOnly ||
        options.allowQuerySquareBrackets ||
        options.domain) {
        return createRegex(options);
    }
    return genericUriRegex;
}
exports.uriRegex = uriRegex;
//# sourceMappingURL=uri.js.map

/***/ }),

/***/ 41041:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


const internals = {
    operators: ['!', '^', '*', '/', '%', '+', '-', '<', '<=', '>', '>=', '==', '!=', '&&', '||', '??'],
    operatorCharacters: ['!', '^', '*', '/', '%', '+', '-', '<', '=', '>', '&', '|', '?'],
    operatorsOrder: [['^'], ['*', '/', '%'], ['+', '-'], ['<', '<=', '>', '>='], ['==', '!='], ['&&'], ['||', '??']],
    operatorsPrefix: ['!', 'n'],

    literals: {
        '"': '"',
        '`': '`',
        '\'': '\'',
        '[': ']'
    },

    numberRx: /^(?:[0-9]*(\.[0-9]*)?){1}$/,
    tokenRx: /^[\w\$\#\.\@\:\{\}]+$/,

    symbol: Symbol('formula'),
    settings: Symbol('settings')
};


exports.Parser = class {

    constructor(string, options = {}) {

        if (!options[internals.settings] &&
            options.constants) {

            for (const constant in options.constants) {
                const value = options.constants[constant];
                if (value !== null &&
                    !['boolean', 'number', 'string'].includes(typeof value)) {

                    throw new Error(`Formula constant ${constant} contains invalid ${typeof value} value type`);
                }
            }
        }

        this.settings = options[internals.settings] ? options : Object.assign({ [internals.settings]: true, constants: {}, functions: {} }, options);
        this.single = null;

        this._parts = null;
        this._parse(string);
    }

    _parse(string) {

        let parts = [];
        let current = '';
        let parenthesis = 0;
        let literal = false;

        const flush = (inner) => {

            if (parenthesis) {
                throw new Error('Formula missing closing parenthesis');
            }

            const last = parts.length ? parts[parts.length - 1] : null;

            if (!literal &&
                !current &&
                !inner) {

                return;
            }

            if (last &&
                last.type === 'reference' &&
                inner === ')') {                                                                // Function

                last.type = 'function';
                last.value = this._subFormula(current, last.value);
                current = '';
                return;
            }

            if (inner === ')') {                                                                // Segment
                const sub = new exports.Parser(current, this.settings);
                parts.push({ type: 'segment', value: sub });
            }
            else if (literal) {
                if (literal === ']') {                                                          // Reference
                    parts.push({ type: 'reference', value: current });
                    current = '';
                    return;
                }

                parts.push({ type: 'literal', value: current });                                // Literal
            }
            else if (internals.operatorCharacters.includes(current)) {                          // Operator
                if (last &&
                    last.type === 'operator' &&
                    internals.operators.includes(last.value + current)) {                       // 2 characters operator

                    last.value += current;
                }
                else {
                    parts.push({ type: 'operator', value: current });
                }
            }
            else if (current.match(internals.numberRx)) {                                       // Number
                parts.push({ type: 'constant', value: parseFloat(current) });
            }
            else if (this.settings.constants[current] !== undefined) {                          // Constant
                parts.push({ type: 'constant', value: this.settings.constants[current] });
            }
            else {                                                                              // Reference
                if (!current.match(internals.tokenRx)) {
                    throw new Error(`Formula contains invalid token: ${current}`);
                }

                parts.push({ type: 'reference', value: current });
            }

            current = '';
        };

        for (const c of string) {
            if (literal) {
                if (c === literal) {
                    flush();
                    literal = false;
                }
                else {
                    current += c;
                }
            }
            else if (parenthesis) {
                if (c === '(') {
                    current += c;
                    ++parenthesis;
                }
                else if (c === ')') {
                    --parenthesis;
                    if (!parenthesis) {
                        flush(c);
                    }
                    else {
                        current += c;
                    }
                }
                else {
                    current += c;
                }
            }
            else if (c in internals.literals) {
                literal = internals.literals[c];
            }
            else if (c === '(') {
                flush();
                ++parenthesis;
            }
            else if (internals.operatorCharacters.includes(c)) {
                flush();
                current = c;
                flush();
            }
            else if (c !== ' ') {
                current += c;
            }
            else {
                flush();
            }
        }

        flush();

        // Replace prefix - to internal negative operator

        parts = parts.map((part, i) => {

            if (part.type !== 'operator' ||
                part.value !== '-' ||
                i && parts[i - 1].type !== 'operator') {

                return part;
            }

            return { type: 'operator', value: 'n' };
        });

        // Validate tokens order

        let operator = false;
        for (const part of parts) {
            if (part.type === 'operator') {
                if (internals.operatorsPrefix.includes(part.value)) {
                    continue;
                }

                if (!operator) {
                    throw new Error('Formula contains an operator in invalid position');
                }

                if (!internals.operators.includes(part.value)) {
                    throw new Error(`Formula contains an unknown operator ${part.value}`);
                }
            }
            else if (operator) {
                throw new Error('Formula missing expected operator');
            }

            operator = !operator;
        }

        if (!operator) {
            throw new Error('Formula contains invalid trailing operator');
        }

        // Identify single part

        if (parts.length === 1 &&
            ['reference', 'literal', 'constant'].includes(parts[0].type)) {

            this.single = { type: parts[0].type === 'reference' ? 'reference' : 'value', value: parts[0].value };
        }

        // Process parts

        this._parts = parts.map((part) => {

            // Operators

            if (part.type === 'operator') {
                return internals.operatorsPrefix.includes(part.value) ? part : part.value;
            }

            // Literals, constants, segments

            if (part.type !== 'reference') {
                return part.value;
            }

            // References

            if (this.settings.tokenRx &&
                !this.settings.tokenRx.test(part.value)) {

                throw new Error(`Formula contains invalid reference ${part.value}`);
            }

            if (this.settings.reference) {
                return this.settings.reference(part.value);
            }

            return internals.reference(part.value);
        });
    }

    _subFormula(string, name) {

        const method = this.settings.functions[name];
        if (typeof method !== 'function') {
            throw new Error(`Formula contains unknown function ${name}`);
        }

        let args = [];
        if (string) {
            let current = '';
            let parenthesis = 0;
            let literal = false;

            const flush = () => {

                if (!current) {
                    throw new Error(`Formula contains function ${name} with invalid arguments ${string}`);
                }

                args.push(current);
                current = '';
            };

            for (let i = 0; i < string.length; ++i) {
                const c = string[i];
                if (literal) {
                    current += c;
                    if (c === literal) {
                        literal = false;
                    }
                }
                else if (c in internals.literals &&
                    !parenthesis) {

                    current += c;
                    literal = internals.literals[c];
                }
                else if (c === ',' &&
                    !parenthesis) {

                    flush();
                }
                else {
                    current += c;
                    if (c === '(') {
                        ++parenthesis;
                    }
                    else if (c === ')') {
                        --parenthesis;
                    }
                }
            }

            flush();
        }

        args = args.map((arg) => new exports.Parser(arg, this.settings));

        return function (context) {

            const innerValues = [];
            for (const arg of args) {
                innerValues.push(arg.evaluate(context));
            }

            return method.call(context, ...innerValues);
        };
    }

    evaluate(context) {

        const parts = this._parts.slice();

        // Prefix operators

        for (let i = parts.length - 2; i >= 0; --i) {
            const part = parts[i];
            if (part &&
                part.type === 'operator') {

                const current = parts[i + 1];
                parts.splice(i + 1, 1);
                const value = internals.evaluate(current, context);
                parts[i] = internals.single(part.value, value);
            }
        }

        // Left-right operators

        internals.operatorsOrder.forEach((set) => {

            for (let i = 1; i < parts.length - 1;) {
                if (set.includes(parts[i])) {
                    const operator = parts[i];
                    const left = internals.evaluate(parts[i - 1], context);
                    const right = internals.evaluate(parts[i + 1], context);

                    parts.splice(i, 2);
                    const result = internals.calculate(operator, left, right);
                    parts[i - 1] = result === 0 ? 0 : result;                               // Convert -0
                }
                else {
                    i += 2;
                }
            }
        });

        return internals.evaluate(parts[0], context);
    }
};


exports.Parser.prototype[internals.symbol] = true;


internals.reference = function (name) {

    return function (context) {

        return context && context[name] !== undefined ? context[name] : null;
    };
};


internals.evaluate = function (part, context) {

    if (part === null) {
        return null;
    }

    if (typeof part === 'function') {
        return part(context);
    }

    if (part[internals.symbol]) {
        return part.evaluate(context);
    }

    return part;
};


internals.single = function (operator, value) {

    if (operator === '!') {
        return value ? false : true;
    }

    // operator === 'n'

    const negative = -value;
    if (negative === 0) {       // Override -0
        return 0;
    }

    return negative;
};


internals.calculate = function (operator, left, right) {

    if (operator === '??') {
        return internals.exists(left) ? left : right;
    }

    if (typeof left === 'string' ||
        typeof right === 'string') {

        if (operator === '+') {
            left = internals.exists(left) ? left : '';
            right = internals.exists(right) ? right : '';
            return left + right;
        }
    }
    else {
        switch (operator) {
            case '^': return Math.pow(left, right);
            case '*': return left * right;
            case '/': return left / right;
            case '%': return left % right;
            case '+': return left + right;
            case '-': return left - right;
        }
    }

    switch (operator) {
        case '<': return left < right;
        case '<=': return left <= right;
        case '>': return left > right;
        case '>=': return left >= right;
        case '==': return left === right;
        case '!=': return left !== right;
        case '&&': return left && right;
        case '||': return left || right;
    }

    return null;
};


internals.exists = function (value) {

    return value !== null && value !== undefined;
};


/***/ }),

/***/ 4051:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


const Assert = __nccwpck_require__(15676);
const Clone = __nccwpck_require__(7185);
const Merge = __nccwpck_require__(41584);
const Reach = __nccwpck_require__(73299);


const internals = {};


module.exports = function (defaults, source, options = {}) {

    Assert(defaults && typeof defaults === 'object', 'Invalid defaults value: must be an object');
    Assert(!source || source === true || typeof source === 'object', 'Invalid source value: must be true, falsy or an object');
    Assert(typeof options === 'object', 'Invalid options: must be an object');

    if (!source) {                                                  // If no source, return null
        return null;
    }

    if (options.shallow) {
        return internals.applyToDefaultsWithShallow(defaults, source, options);
    }

    const copy = Clone(defaults);

    if (source === true) {                                          // If source is set to true, use defaults
        return copy;
    }

    const nullOverride = options.nullOverride !== undefined ? options.nullOverride : false;
    return Merge(copy, source, { nullOverride, mergeArrays: false });
};


internals.applyToDefaultsWithShallow = function (defaults, source, options) {

    const keys = options.shallow;
    Assert(Array.isArray(keys), 'Invalid keys');

    const seen = new Map();
    const merge = source === true ? null : new Set();

    for (let key of keys) {
        key = Array.isArray(key) ? key : key.split('.');            // Pre-split optimization

        const ref = Reach(defaults, key);
        if (ref &&
            typeof ref === 'object') {

            seen.set(ref, merge && Reach(source, key) || ref);
        }
        else if (merge) {
            merge.add(key);
        }
    }

    const copy = Clone(defaults, {}, seen);

    if (!merge) {
        return copy;
    }

    for (const key of merge) {
        internals.reachCopy(copy, source, key);
    }

    const nullOverride = options.nullOverride !== undefined ? options.nullOverride : false;
    return Merge(copy, source, { nullOverride, mergeArrays: false });
};


internals.reachCopy = function (dst, src, path) {

    for (const segment of path) {
        if (!(segment in src)) {
            return;
        }

        const val = src[segment];

        if (typeof val !== 'object' || val === null) {
            return;
        }

        src = val;
    }

    const value = src;
    let ref = dst;
    for (let i = 0; i < path.length - 1; ++i) {
        const segment = path[i];
        if (typeof ref[segment] !== 'object') {
            ref[segment] = {};
        }

        ref = ref[segment];
    }

    ref[path[path.length - 1]] = value;
};


/***/ }),

/***/ 15676:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


const AssertError = __nccwpck_require__(16004);
const Stringify = __nccwpck_require__(35265);


const internals = {};


const assert = module.exports = function (condition, ...args) {

    if (condition) {
        return;
    }

    if (args.length === 1 &&
        args[0] instanceof Error) {

        throw args[0];
    }

    const msgs = args
        .filter((arg) => arg !== '')
        .map((arg) => {

            return typeof arg === 'string' ? arg : arg instanceof Error ? arg.message : Stringify(arg);
        });

    throw new AssertError(msgs.join(' '), assert);
};


/***/ }),

/***/ 16004:
/***/ ((module) => {

"use strict";


const internals = {};


module.exports = class AssertError extends Error {

    name = 'AssertError';

    constructor(message, ctor) {

        super(message || 'Unknown error');

        if (typeof Error.captureStackTrace === 'function') {            // $lab:coverage:ignore$
            Error.captureStackTrace(this, ctor);
        }
    }
};


/***/ }),

/***/ 17630:
/***/ ((module) => {

"use strict";


const internals = {};


module.exports = internals.Bench = class {

    constructor() {

        this.ts = 0;
        this.reset();
    }

    reset() {

        this.ts = internals.Bench.now();
    }

    elapsed() {

        return internals.Bench.now() - this.ts;
    }

    static now() {

        const ts = process.hrtime();
        return (ts[0] * 1e3) + (ts[1] / 1e6);
    }
};


/***/ }),

/***/ 70481:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


const Ignore = __nccwpck_require__(8836);


const internals = {};


module.exports = function () {

    return new Promise(Ignore);
};


/***/ }),

/***/ 7185:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


const Reach = __nccwpck_require__(73299);
const Types = __nccwpck_require__(60265);
const Utils = __nccwpck_require__(53829);


const internals = {
    needsProtoHack: new Set([Types.set, Types.map, Types.weakSet, Types.weakMap]),
    structuredCloneExists: typeof structuredClone === 'function'
};


module.exports = internals.clone = function (obj, options = {}, _seen = null) {

    if (typeof obj !== 'object' ||
        obj === null) {

        return obj;
    }

    let clone = internals.clone;
    let seen = _seen;

    if (options.shallow) {
        if (options.shallow !== true) {
            return internals.cloneWithShallow(obj, options);
        }

        clone = (value) => value;
    }
    else if (seen) {
        const lookup = seen.get(obj);
        if (lookup) {
            return lookup;
        }
    }
    else {
        seen = new Map();
    }

    // Built-in object types

    const baseProto = Types.getInternalProto(obj);
    switch (baseProto) {
        case Types.buffer:
            return Buffer?.from(obj);
        case Types.date:
            return new Date(obj.getTime());
        case Types.regex:
        case Types.url:
            return new baseProto.constructor(obj);
    }

    // Generic objects

    const newObj = internals.base(obj, baseProto, options);
    if (newObj === obj) {
        return obj;
    }

    if (seen) {
        seen.set(obj, newObj);                              // Set seen, since obj could recurse
    }

    if (baseProto === Types.set) {
        for (const value of obj) {
            newObj.add(clone(value, options, seen));
        }
    }
    else if (baseProto === Types.map) {
        for (const [key, value] of obj) {
            newObj.set(key, clone(value, options, seen));
        }
    }

    const keys = Utils.keys(obj, options);
    for (const key of keys) {
        if (key === '__proto__') {
            continue;
        }

        if (baseProto === Types.array &&
            key === 'length') {

            newObj.length = obj.length;
            continue;
        }

        // Can only be covered in node 21+
        /* $lab:coverage:off$ */
        if (internals.structuredCloneExists &&
            baseProto === Types.error &&
            key === 'stack') {

            continue;       // Already a part of the base object
        }
        /* $lab:coverage:on$ */

        const descriptor = Object.getOwnPropertyDescriptor(obj, key);
        if (descriptor) {
            if (descriptor.get ||
                descriptor.set) {

                Object.defineProperty(newObj, key, descriptor);
            }
            else if (descriptor.enumerable) {
                newObj[key] = clone(obj[key], options, seen);
            }
            else {
                Object.defineProperty(newObj, key, { enumerable: false, writable: true, configurable: true, value: clone(obj[key], options, seen) });
            }
        }
        else {
            Object.defineProperty(newObj, key, {
                enumerable: true,
                writable: true,
                configurable: true,
                value: clone(obj[key], options, seen)
            });
        }
    }

    return newObj;
};


internals.cloneWithShallow = function (source, options) {

    const keys = options.shallow;
    options = Object.assign({}, options);
    options.shallow = false;

    const seen = new Map();

    for (const key of keys) {
        const ref = Reach(source, key);
        if (typeof ref === 'object' ||
            typeof ref === 'function') {

            seen.set(ref, ref);
        }
    }

    return internals.clone(source, options, seen);
};


internals.base = function (obj, baseProto, options) {

    if (options.prototype === false) {                  // Defaults to true
        if (internals.needsProtoHack.has(baseProto)) {
            return new baseProto.constructor();
        }

        return baseProto === Types.array ? [] : {};
    }

    const proto = Object.getPrototypeOf(obj);
    if (proto &&
        proto.isImmutable) {

        return obj;
    }

    if (baseProto === Types.array) {
        const newObj = [];
        if (proto !== baseProto) {
            Object.setPrototypeOf(newObj, proto);
        }

        return newObj;
    }
    // Can only be covered in node 21+
    /* $lab:coverage:off$ */
    else if (baseProto === Types.error && internals.structuredCloneExists &&
        (proto === baseProto || Error.isPrototypeOf(proto.constructor))) {      // Don't match Util.inherit() subclassed errors

        const err = structuredClone(obj);                                       // Needed to copy internal stack state
        if (Object.getPrototypeOf(err) !== proto) {
            Object.setPrototypeOf(err, proto);                                  // Fix prototype
        }

        return err;
    }
    /* $lab:coverage:on$ */

    if (internals.needsProtoHack.has(baseProto)) {
        const newObj = new proto.constructor();
        if (proto !== baseProto) {
            Object.setPrototypeOf(newObj, proto);
        }

        return newObj;
    }

    return Object.create(proto);
};


/***/ }),

/***/ 49788:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


const Assert = __nccwpck_require__(15676);
const DeepEqual = __nccwpck_require__(41058);
const EscapeRegex = __nccwpck_require__(33574);
const Utils = __nccwpck_require__(53829);


const internals = {};


module.exports = function (ref, values, options = {}) {        // options: { deep, once, only, part, symbols }

    /*
        string -> string(s)
        array -> item(s)
        object -> key(s)
        object -> object (key:value)
    */

    if (typeof values !== 'object') {
        values = [values];
    }

    Assert(!Array.isArray(values) || values.length, 'Values array cannot be empty');

    // String

    if (typeof ref === 'string') {
        return internals.string(ref, values, options);
    }

    // Array

    if (Array.isArray(ref)) {
        return internals.array(ref, values, options);
    }

    // Object

    Assert(typeof ref === 'object', 'Reference must be string or an object');
    return internals.object(ref, values, options);
};


internals.array = function (ref, values, options) {

    if (!Array.isArray(values)) {
        values = [values];
    }

    if (!ref.length) {
        return false;
    }

    if (options.only &&
        options.once &&
        ref.length !== values.length) {

        return false;
    }

    let compare;

    // Map values

    const map = new Map();
    for (const value of values) {
        if (!options.deep ||
            !value ||
            typeof value !== 'object') {

            const existing = map.get(value);
            if (existing) {
                ++existing.allowed;
            }
            else {
                map.set(value, { allowed: 1, hits: 0 });
            }
        }
        else {
            compare = compare ?? internals.compare(options);

            let found = false;
            for (const [key, existing] of map.entries()) {
                if (compare(key, value)) {
                    ++existing.allowed;
                    found = true;
                    break;
                }
            }

            if (!found) {
                map.set(value, { allowed: 1, hits: 0 });
            }
        }
    }

    // Lookup values

    let hits = 0;
    for (const item of ref) {
        let match;
        if (!options.deep ||
            !item ||
            typeof item !== 'object') {

            match = map.get(item);
        }
        else {
            compare = compare ?? internals.compare(options);

            for (const [key, existing] of map.entries()) {
                if (compare(key, item)) {
                    match = existing;
                    break;
                }
            }
        }

        if (match) {
            ++match.hits;
            ++hits;

            if (options.once &&
                match.hits > match.allowed) {

                return false;
            }
        }
    }

    // Validate results

    if (options.only &&
        hits !== ref.length) {

        return false;
    }

    for (const match of map.values()) {
        if (match.hits === match.allowed) {
            continue;
        }

        if (match.hits < match.allowed &&
            !options.part) {

            return false;
        }
    }

    return !!hits;
};


internals.object = function (ref, values, options) {

    Assert(options.once === undefined, 'Cannot use option once with object');

    const keys = Utils.keys(ref, options);
    if (!keys.length) {
        return false;
    }

    // Keys list

    if (Array.isArray(values)) {
        return internals.array(keys, values, options);
    }

    // Key value pairs

    const symbols = Object.getOwnPropertySymbols(values).filter((sym) => values.propertyIsEnumerable(sym));
    const targets = [...Object.keys(values), ...symbols];

    const compare = internals.compare(options);
    const set = new Set(targets);

    for (const key of keys) {
        if (!set.has(key)) {
            if (options.only) {
                return false;
            }

            continue;
        }

        if (!compare(values[key], ref[key])) {
            return false;
        }

        set.delete(key);
    }

    if (set.size) {
        return options.part ? set.size < targets.length : false;
    }

    return true;
};


internals.string = function (ref, values, options) {

    // Empty string

    if (ref === '') {
        return values.length === 1 && values[0] === '' ||               // '' contains ''
            !options.once && !values.some((v) => v !== '');             // '' contains multiple '' if !once
    }

    // Map values

    const map = new Map();
    const patterns = [];

    for (const value of values) {
        Assert(typeof value === 'string', 'Cannot compare string reference to non-string value');

        if (value) {
            const existing = map.get(value);
            if (existing) {
                ++existing.allowed;
            }
            else {
                map.set(value, { allowed: 1, hits: 0 });
                patterns.push(EscapeRegex(value));
            }
        }
        else if (options.once ||
            options.only) {

            return false;
        }
    }

    if (!patterns.length) {                     // Non-empty string contains unlimited empty string
        return true;
    }

    // Match patterns

    const regex = new RegExp(`(${patterns.join('|')})`, 'g');
    const leftovers = ref.replace(regex, ($0, $1) => {

        ++map.get($1).hits;
        return '';                              // Remove from string
    });

    // Validate results

    if (options.only &&
        leftovers) {

        return false;
    }

    let any = false;
    for (const match of map.values()) {
        if (match.hits) {
            any = true;
        }

        if (match.hits === match.allowed) {
            continue;
        }

        if (match.hits < match.allowed &&
            !options.part) {

            return false;
        }

        // match.hits > match.allowed

        if (options.once) {
            return false;
        }
    }

    return !!any;
};


internals.compare = function (options) {

    if (!options.deep) {
        return internals.shallow;
    }

    const hasOnly = options.only !== undefined;
    const hasPart = options.part !== undefined;

    const flags = {
        prototype: hasOnly ? options.only : hasPart ? !options.part : false,
        part: hasOnly ? !options.only : hasPart ? options.part : false
    };

    return (a, b) => DeepEqual(a, b, flags);
};


internals.shallow = function (a, b) {

    return a === b;
};


/***/ }),

/***/ 41058:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


const Types = __nccwpck_require__(60265);


const internals = {
    mismatched: null
};


module.exports = function (obj, ref, options) {

    options = Object.assign({ prototype: true }, options);

    return !!internals.isDeepEqual(obj, ref, options, []);
};


internals.isDeepEqual = function (obj, ref, options, seen) {

    if (obj === ref) {                                                      // Copied from Deep-eql, copyright(c) 2013 Jake Luer, jake@alogicalparadox.com, MIT Licensed, https://github.com/chaijs/deep-eql
        return obj !== 0 || 1 / obj === 1 / ref;
    }

    const type = typeof obj;

    if (type !== typeof ref) {
        return false;
    }

    if (obj === null ||
        ref === null) {

        return false;
    }

    if (type === 'function') {
        if (!options.deepFunction ||
            obj.toString() !== ref.toString()) {

            return false;
        }

        // Continue as object
    }
    else if (type !== 'object') {
        return obj !== obj && ref !== ref;                                  // NaN
    }

    const instanceType = internals.getSharedType(obj, ref, !!options.prototype);
    switch (instanceType) {
        case Types.buffer:
            return Buffer && Buffer.prototype.equals.call(obj, ref);        // $lab:coverage:ignore$
        case Types.promise:
            return obj === ref;
        case Types.regex:
        case Types.url:
            return obj.toString() === ref.toString();
        case internals.mismatched:
            return false;
    }

    for (let i = seen.length - 1; i >= 0; --i) {
        if (seen[i].isSame(obj, ref)) {
            return true;                                                    // If previous comparison failed, it would have stopped execution
        }
    }

    seen.push(new internals.SeenEntry(obj, ref));

    try {
        return !!internals.isDeepEqualObj(instanceType, obj, ref, options, seen);
    }
    finally {
        seen.pop();
    }
};


internals.getSharedType = function (obj, ref, checkPrototype) {

    if (checkPrototype) {
        if (Object.getPrototypeOf(obj) !== Object.getPrototypeOf(ref)) {
            return internals.mismatched;
        }

        return Types.getInternalProto(obj);
    }

    const type = Types.getInternalProto(obj);
    if (type !== Types.getInternalProto(ref)) {
        return internals.mismatched;
    }

    return type;
};


internals.valueOf = function (obj) {

    const objValueOf = obj.valueOf;
    if (objValueOf === undefined) {
        return obj;
    }

    try {
        return objValueOf.call(obj);
    }
    catch (err) {
        return err;
    }
};


internals.hasOwnEnumerableProperty = function (obj, key) {

    return Object.prototype.propertyIsEnumerable.call(obj, key);
};


internals.isSetSimpleEqual = function (obj, ref) {

    for (const entry of Set.prototype.values.call(obj)) {
        if (!Set.prototype.has.call(ref, entry)) {
            return false;
        }
    }

    return true;
};


internals.isDeepEqualObj = function (instanceType, obj, ref, options, seen) {

    const { isDeepEqual, valueOf, hasOwnEnumerableProperty } = internals;
    const { keys, getOwnPropertySymbols } = Object;

    if (instanceType === Types.array) {
        if (options.part) {

            // Check if any index match any other index

            for (const objValue of obj) {
                for (const refValue of ref) {
                    if (isDeepEqual(objValue, refValue, options, seen)) {
                        return true;
                    }
                }
            }
        }
        else {
            if (obj.length !== ref.length) {
                return false;
            }

            for (let i = 0; i < obj.length; ++i) {
                if (!isDeepEqual(obj[i], ref[i], options, seen)) {
                    return false;
                }
            }

            return true;
        }
    }
    else if (instanceType === Types.set) {
        if (obj.size !== ref.size) {
            return false;
        }

        if (!internals.isSetSimpleEqual(obj, ref)) {

            // Check for deep equality

            const ref2 = new Set(Set.prototype.values.call(ref));
            for (const objEntry of Set.prototype.values.call(obj)) {
                if (ref2.delete(objEntry)) {
                    continue;
                }

                let found = false;
                for (const refEntry of ref2) {
                    if (isDeepEqual(objEntry, refEntry, options, seen)) {
                        ref2.delete(refEntry);
                        found = true;
                        break;
                    }
                }

                if (!found) {
                    return false;
                }
            }
        }
    }
    else if (instanceType === Types.map) {
        if (obj.size !== ref.size) {
            return false;
        }

        for (const [key, value] of Map.prototype.entries.call(obj)) {
            if (value === undefined && !Map.prototype.has.call(ref, key)) {
                return false;
            }

            if (!isDeepEqual(value, Map.prototype.get.call(ref, key), options, seen)) {
                return false;
            }
        }
    }
    else if (instanceType === Types.error) {

        // Always check name and message

        if (obj.name !== ref.name ||
            obj.message !== ref.message) {

            return false;
        }
    }

    // Check .valueOf()

    const valueOfObj = valueOf(obj);
    const valueOfRef = valueOf(ref);
    if ((obj !== valueOfObj || ref !== valueOfRef) &&
        !isDeepEqual(valueOfObj, valueOfRef, options, seen)) {

        return false;
    }

    // Check properties

    const objKeys = keys(obj);
    if (!options.part &&
        objKeys.length !== keys(ref).length &&
        !options.skip) {

        return false;
    }

    let skipped = 0;
    for (const key of objKeys) {
        if (options.skip &&
            options.skip.includes(key)) {

            if (ref[key] === undefined) {
                ++skipped;
            }

            continue;
        }

        if (!hasOwnEnumerableProperty(ref, key)) {
            return false;
        }

        if (!isDeepEqual(obj[key], ref[key], options, seen)) {
            return false;
        }
    }

    if (!options.part &&
        objKeys.length - skipped !== keys(ref).length) {

        return false;
    }

    // Check symbols

    if (options.symbols !== false) {                                // Defaults to true
        const objSymbols = getOwnPropertySymbols(obj);
        const refSymbols = new Set(getOwnPropertySymbols(ref));

        for (const key of objSymbols) {
            if (!options.skip?.includes(key)) {

                if (hasOwnEnumerableProperty(obj, key)) {
                    if (!hasOwnEnumerableProperty(ref, key)) {
                        return false;
                    }

                    if (!isDeepEqual(obj[key], ref[key], options, seen)) {
                        return false;
                    }
                }
                else if (hasOwnEnumerableProperty(ref, key)) {
                    return false;
                }
            }

            refSymbols.delete(key);
        }

        for (const key of refSymbols) {
            if (hasOwnEnumerableProperty(ref, key)) {
                return false;
            }
        }
    }

    return true;
};


internals.SeenEntry = class {

    constructor(obj, ref) {

        this.obj = obj;
        this.ref = ref;
    }

    isSame(obj, ref) {

        return this.obj === obj && this.ref === ref;
    }
};


/***/ }),

/***/ 11306:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


const Assert = __nccwpck_require__(15676);


const internals = {};


module.exports = function (attribute) {

    // Allowed value characters: !#$%&'()*+,-./:;<=>?@[]^_`{|}~ and space, a-z, A-Z, 0-9, \, "

    Assert(/^[ \w\!#\$%&'\(\)\*\+,\-\.\/\:;<\=>\?@\[\]\^`\{\|\}~\"\\]*$/.test(attribute), 'Bad attribute value (' + attribute + ')');

    return attribute.replace(/\\/g, '\\\\').replace(/\"/g, '\\"');                             // Escape quotes and slash
};


/***/ }),

/***/ 98972:
/***/ ((module) => {

"use strict";


const internals = {};


module.exports = function (input) {

    if (!input) {
        return '';
    }

    let escaped = '';

    for (let i = 0; i < input.length; ++i) {

        const charCode = input.charCodeAt(i);

        if (internals.isSafe(charCode)) {
            escaped += input[i];
        }
        else {
            escaped += internals.escapeHtmlChar(charCode);
        }
    }

    return escaped;
};


internals.escapeHtmlChar = function (charCode) {

    const namedEscape = internals.namedHtml.get(charCode);
    if (namedEscape) {
        return namedEscape;
    }

    if (charCode >= 256) {
        return '&#' + charCode + ';';
    }

    const hexValue = charCode.toString(16).padStart(2, '0');
    return `&#x${hexValue};`;
};


internals.isSafe = function (charCode) {

    return internals.safeCharCodes.has(charCode);
};


internals.namedHtml = new Map([
    [38, '&amp;'],
    [60, '&lt;'],
    [62, '&gt;'],
    [34, '&quot;'],
    [160, '&nbsp;'],
    [162, '&cent;'],
    [163, '&pound;'],
    [164, '&curren;'],
    [169, '&copy;'],
    [174, '&reg;']
]);


internals.safeCharCodes = (function () {

    const safe = new Set();

    for (let i = 32; i < 123; ++i) {

        if ((i >= 97) ||                    // a-z
            (i >= 65 && i <= 90) ||         // A-Z
            (i >= 48 && i <= 57) ||         // 0-9
            i === 32 ||                     // space
            i === 46 ||                     // .
            i === 44 ||                     // ,
            i === 45 ||                     // -
            i === 58 ||                     // :
            i === 95) {                     // _

            safe.add(i);
        }
    }

    return safe;
}());


/***/ }),

/***/ 69691:
/***/ ((module) => {

"use strict";


const internals = {};


module.exports = function (input) {

    if (!input) {
        return '';
    }

    return input.replace(/[<>&\u2028\u2029]/g, internals.escape);
};


internals.escape = function (char) {

    return internals.replacements.get(char);
};


internals.replacements = new Map([
    ['<', '\\u003c'],
    ['>', '\\u003e'],
    ['&', '\\u0026'],
    ['\u2028', '\\u2028'],
    ['\u2029', '\\u2029']
]);


/***/ }),

/***/ 33574:
/***/ ((module) => {

"use strict";


const internals = {};


module.exports = function (string) {

    // Escape ^$.*+-?=!:|\/()[]{},

    return string.replace(/[\^\$\.\*\+\-\?\=\!\:\|\\\/\(\)\[\]\{\}\,]/g, '\\$&');
};


/***/ }),

/***/ 16686:
/***/ ((module) => {

"use strict";


const internals = {};


module.exports = internals.flatten = function (array, target) {

    const result = target || [];

    for (const entry of array) {
        if (Array.isArray(entry)) {
            internals.flatten(entry, result);
        }
        else {
            result.push(entry);
        }
    }

    return result;
};


/***/ }),

/***/ 8836:
/***/ ((module) => {

"use strict";


const internals = {};


module.exports = function () { };


/***/ }),

/***/ 91884:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


exports.applyToDefaults = __nccwpck_require__(4051);

exports.assert = __nccwpck_require__(15676);

exports.AssertError = __nccwpck_require__(16004);

exports.Bench = __nccwpck_require__(17630);

exports.block = __nccwpck_require__(70481);

exports.clone = __nccwpck_require__(7185);

exports.contain = __nccwpck_require__(49788);

exports.deepEqual = __nccwpck_require__(41058);

exports.escapeHeaderAttribute = __nccwpck_require__(11306);

exports.escapeHtml = __nccwpck_require__(98972);

exports.escapeJson = __nccwpck_require__(69691);

exports.escapeRegex = __nccwpck_require__(33574);

exports.flatten = __nccwpck_require__(16686);

exports.ignore = __nccwpck_require__(8836);

exports.intersect = __nccwpck_require__(36733);

exports.isPromise = __nccwpck_require__(36577);

exports.merge = __nccwpck_require__(41584);

exports.once = __nccwpck_require__(2007);

exports.reach = __nccwpck_require__(73299);

exports.reachTemplate = __nccwpck_require__(19921);

exports.stringify = __nccwpck_require__(35265);

exports.wait = __nccwpck_require__(82907);


/***/ }),

/***/ 36733:
/***/ ((module) => {

"use strict";


const internals = {};


module.exports = function (array1, array2, options = {}) {

    if (!array1 ||
        !array2) {

        return (options.first ? null : []);
    }

    const common = [];
    const hash = (Array.isArray(array1) ? new Set(array1) : array1);
    const found = new Set();
    for (const value of array2) {
        if (internals.has(hash, value) &&
            !found.has(value)) {

            if (options.first) {
                return value;
            }

            common.push(value);
            found.add(value);
        }
    }

    return (options.first ? null : common);
};


internals.has = function (ref, key) {

    if (typeof ref.has === 'function') {
        return ref.has(key);
    }

    return ref[key] !== undefined;
};


/***/ }),

/***/ 36577:
/***/ ((module) => {

"use strict";


const internals = {};


module.exports = function (promise) {

    return typeof promise?.then === 'function';
};


/***/ }),

/***/ 41584:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


const Assert = __nccwpck_require__(15676);
const Clone = __nccwpck_require__(7185);
const Utils = __nccwpck_require__(53829);


const internals = {};


module.exports = internals.merge = function (target, source, options) {

    Assert(target && typeof target === 'object', 'Invalid target value: must be an object');
    Assert(source === null || source === undefined || typeof source === 'object', 'Invalid source value: must be null, undefined, or an object');

    if (!source) {
        return target;
    }

    options = Object.assign({ nullOverride: true, mergeArrays: true }, options);

    if (Array.isArray(source)) {
        Assert(Array.isArray(target), 'Cannot merge array onto an object');
        if (!options.mergeArrays) {
            target.length = 0;                                                          // Must not change target assignment
        }

        for (let i = 0; i < source.length; ++i) {
            target.push(Clone(source[i], { symbols: options.symbols }));
        }

        return target;
    }

    const keys = Utils.keys(source, options);
    for (let i = 0; i < keys.length; ++i) {
        const key = keys[i];
        if (key === '__proto__' ||
            !Object.prototype.propertyIsEnumerable.call(source, key)) {

            continue;
        }

        const value = source[key];
        if (value &&
            typeof value === 'object') {

            if (target[key] === value) {
                continue;                                           // Can occur for shallow merges
            }

            if (!target[key] ||
                typeof target[key] !== 'object' ||
                (Array.isArray(target[key]) !== Array.isArray(value)) ||
                value instanceof Date ||
                (Buffer && Buffer.isBuffer(value)) ||               // $lab:coverage:ignore$
                value instanceof RegExp) {

                target[key] = Clone(value, { symbols: options.symbols });
            }
            else {
                internals.merge(target[key], value, options);
            }
        }
        else {
            if (value !== null &&
                value !== undefined) {                              // Explicit to preserve empty strings

                target[key] = value;
            }
            else if (options.nullOverride) {
                target[key] = value;
            }
        }
    }

    return target;
};


/***/ }),

/***/ 2007:
/***/ ((module) => {

"use strict";


const internals = {
    wrapped: Symbol('wrapped')
};


module.exports = function (method) {

    if (method[internals.wrapped]) {
        return method;
    }

    let once = false;
    const wrappedFn = function (...args) {

        if (!once) {
            once = true;
            method(...args);
        }
    };

    wrappedFn[internals.wrapped] = true;
    return wrappedFn;
};


/***/ }),

/***/ 73299:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


const Assert = __nccwpck_require__(15676);


const internals = {};


module.exports = function (obj, chain, options) {

    if (chain === false ||
        chain === null ||
        chain === undefined) {

        return obj;
    }

    options = options || {};
    if (typeof options === 'string') {
        options = { separator: options };
    }

    const isChainArray = Array.isArray(chain);

    Assert(!isChainArray || !options.separator, 'Separator option is not valid for array-based chain');

    const path = isChainArray ? chain : chain.split(options.separator || '.');
    let ref = obj;
    for (let i = 0; i < path.length; ++i) {
        let key = path[i];
        const type = options.iterables && internals.iterables(ref);

        if (Array.isArray(ref) ||
            type === 'set') {

            const number = Number(key);
            if (Number.isInteger(number)) {
                key = number < 0 ? ref.length + number : number;
            }
        }

        if (!ref ||
            typeof ref === 'function' && options.functions === false ||         // Defaults to true
            !type && ref[key] === undefined) {

            Assert(!options.strict || i + 1 === path.length, 'Missing segment', key, 'in reach path ', chain);
            Assert(typeof ref === 'object' || options.functions === true || typeof ref !== 'function', 'Invalid segment', key, 'in reach path ', chain);
            ref = options.default;
            break;
        }

        if (!type) {
            ref = ref[key];
        }
        else if (type === 'set') {
            ref = [...ref][key];
        }
        else {  // type === 'map'
            ref = ref.get(key);
        }
    }

    return ref;
};


internals.iterables = function (ref) {

    if (ref instanceof Set) {
        return 'set';
    }

    if (ref instanceof Map) {
        return 'map';
    }
};


/***/ }),

/***/ 19921:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


const Reach = __nccwpck_require__(73299);


const internals = {};


module.exports = function (obj, template, options) {

    return template.replace(/{([^{}]+)}/g, ($0, chain) => {

        const value = Reach(obj, chain, options);
        return value ?? '';
    });
};


/***/ }),

/***/ 35265:
/***/ ((module) => {

"use strict";


const internals = {};


module.exports = function (...args) {

    try {
        return JSON.stringify(...args);
    }
    catch (err) {
        return '[Cannot display object: ' + err.message + ']';
    }
};


/***/ }),

/***/ 60265:
/***/ ((module, exports) => {

"use strict";


const internals = {};


exports = module.exports = {
    array: Array.prototype,
    buffer: Buffer && Buffer.prototype,             // $lab:coverage:ignore$
    date: Date.prototype,
    error: Error.prototype,
    generic: Object.prototype,
    map: Map.prototype,
    promise: Promise.prototype,
    regex: RegExp.prototype,
    set: Set.prototype,
    url: URL.prototype,
    weakMap: WeakMap.prototype,
    weakSet: WeakSet.prototype
};


internals.typeMap = new Map([
    ['[object Error]', exports.error],
    ['[object Map]', exports.map],
    ['[object Promise]', exports.promise],
    ['[object Set]', exports.set],
    ['[object URL]', exports.url],
    ['[object WeakMap]', exports.weakMap],
    ['[object WeakSet]', exports.weakSet]
]);


exports.getInternalProto = function (obj) {

    if (Array.isArray(obj)) {
        return exports.array;
    }

    if (Buffer && obj instanceof Buffer) {          // $lab:coverage:ignore$
        return exports.buffer;
    }

    if (obj instanceof Date) {
        return exports.date;
    }

    if (obj instanceof RegExp) {
        return exports.regex;
    }

    if (obj instanceof Error) {
        return exports.error;
    }

    const objName = Object.prototype.toString.call(obj);
    return internals.typeMap.get(objName) || exports.generic;
};


/***/ }),

/***/ 53829:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


const internals = {};


exports.keys = function (obj, options = {}) {

    return options.symbols !== false ? Reflect.ownKeys(obj) : Object.getOwnPropertyNames(obj);  // Defaults to true
};


/***/ }),

/***/ 82907:
/***/ ((module) => {

"use strict";


const internals = {
    maxTimer: 2 ** 31 - 1              // ~25 days
};


module.exports = function (timeout, returnValue, options) {

    if (typeof timeout === 'bigint') {
        timeout = Number(timeout);
    }

    if (timeout >= Number.MAX_SAFE_INTEGER) {         // Thousands of years
        timeout = Infinity;
    }

    if (typeof timeout !== 'number' && timeout !== undefined) {
        throw new TypeError('Timeout must be a number or bigint');
    }

    return new Promise((resolve) => {

        const _setTimeout = options ? options.setTimeout : setTimeout;

        const activate = () => {

            const time = Math.min(timeout, internals.maxTimer);
            timeout -= time;
            _setTimeout(() => (timeout > 0 ? activate() : resolve(returnValue)), time);
        };

        if (timeout !== Infinity) {
            activate();
        }
    });
};


/***/ }),

/***/ 16422:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


const internals = {};


exports.location = function (depth = 0) {

    const orig = Error.prepareStackTrace;
    Error.prepareStackTrace = (ignore, stack) => stack;

    const capture = {};
    Error.captureStackTrace(capture, this);
    const line = capture.stack[depth + 1];

    Error.prepareStackTrace = orig;

    return {
        filename: line.getFileName(),
        line: line.getLineNumber()
    };
};


/***/ }),

/***/ 97541:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


const { assert } = __nccwpck_require__(91884);


const internals = {};


exports.Sorter = class {

    constructor() {

        this._items = [];
        this.nodes = [];
    }

    add(nodes, options) {

        options = options ?? {};

        // Validate rules

        const before = [].concat(options.before ?? []);
        const after = [].concat(options.after ?? []);
        const group = options.group ?? '?';
        const sort = options.sort ?? 0;                   // Used for merging only

        assert(!before.includes(group), `Item cannot come before itself: ${group}`);
        assert(!before.includes('?'), 'Item cannot come before unassociated items');
        assert(!after.includes(group), `Item cannot come after itself: ${group}`);
        assert(!after.includes('?'), 'Item cannot come after unassociated items');

        if (!Array.isArray(nodes)) {
            nodes = [nodes];
        }

        for (const node of nodes) {
            const item = {
                seq: this._items.length,
                sort,
                before,
                after,
                group,
                node
            };

            this._items.push(item);
        }

        // Insert event

        if (!options.manual) {
            const valid = this._sort();
            assert(valid, 'item', group !== '?' ? `added into group ${group}` : '', 'created a dependencies error');
        }

        return this.nodes;
    }

    merge(others) {

        if (!Array.isArray(others)) {
            others = [others];
        }

        for (const other of others) {
            if (other) {
                for (const item of other._items) {
                    this._items.push(Object.assign({}, item));      // Shallow cloned
                }
            }
        }

        // Sort items

        this._items.sort(internals.mergeSort);
        for (let i = 0; i < this._items.length; ++i) {
            this._items[i].seq = i;
        }

        const valid = this._sort();
        assert(valid, 'merge created a dependencies error');

        return this.nodes;
    }

    sort() {

        const valid = this._sort();
        assert(valid, 'sort created a dependencies error');

        return this.nodes;
    }

    _sort() {

        // Construct graph

        const graph = {};
        const graphAfters = Object.create(null);            // A prototype can bungle lookups w/ false positives
        const groups = Object.create(null);

        for (const item of this._items) {
            const seq = item.seq;                           // Unique across all items
            const group = item.group;

            // Determine Groups

            groups[group] = groups[group] ?? [];
            groups[group].push(seq);

            // Build intermediary graph using 'before'

            graph[seq] = item.before;

            // Build second intermediary graph with 'after'

            for (const after of item.after) {
                graphAfters[after] = graphAfters[after] ?? [];
                graphAfters[after].push(seq);
            }
        }

        // Expand intermediary graph

        for (const node in graph) {
            const expandedGroups = [];

            for (const graphNodeItem in graph[node]) {
                const group = graph[node][graphNodeItem];
                groups[group] = groups[group] ?? [];
                expandedGroups.push(...groups[group]);
            }

            graph[node] = expandedGroups;
        }

        // Merge intermediary graph using graphAfters into final graph

        for (const group in graphAfters) {
            if (groups[group]) {
                for (const node of groups[group]) {
                    graph[node].push(...graphAfters[group]);
                }
            }
        }

        // Compile ancestors

        const ancestors = {};
        for (const node in graph) {
            const children = graph[node];
            for (const child of children) {
                ancestors[child] = ancestors[child] ?? [];
                ancestors[child].push(node);
            }
        }

        // Topo sort

        const visited = {};
        const sorted = [];

        for (let i = 0; i < this._items.length; ++i) {          // Looping through item.seq values out of order
            let next = i;

            if (ancestors[i]) {
                next = null;
                for (let j = 0; j < this._items.length; ++j) {  // As above, these are item.seq values
                    if (visited[j] === true) {
                        continue;
                    }

                    if (!ancestors[j]) {
                        ancestors[j] = [];
                    }

                    const shouldSeeCount = ancestors[j].length;
                    let seenCount = 0;
                    for (let k = 0; k < shouldSeeCount; ++k) {
                        if (visited[ancestors[j][k]]) {
                            ++seenCount;
                        }
                    }

                    if (seenCount === shouldSeeCount) {
                        next = j;
                        break;
                    }
                }
            }

            if (next !== null) {
                visited[next] = true;
                sorted.push(next);
            }
        }

        if (sorted.length !== this._items.length) {
            return false;
        }

        const seqIndex = {};
        for (const item of this._items) {
            seqIndex[item.seq] = item;
        }

        this._items = [];
        this.nodes = [];

        for (const value of sorted) {
            const sortedItem = seqIndex[value];
            this.nodes.push(sortedItem.node);
            this._items.push(sortedItem);
        }

        return true;
    }
};


internals.mergeSort = (a, b) => {

    return a.sort === b.sort ? 0 : (a.sort < b.sort ? -1 : 1);
};


/***/ }),

/***/ 44174:
/***/ ((module) => {

"use strict";


var cssKeywords = {
	aliceblue: [240, 248, 255],
	antiquewhite: [250, 235, 215],
	aqua: [0, 255, 255],
	aquamarine: [127, 255, 212],
	azure: [240, 255, 255],
	beige: [245, 245, 220],
	bisque: [255, 228, 196],
	black: [0, 0, 0],
	blanchedalmond: [255, 235, 205],
	blue: [0, 0, 255],
	blueviolet: [138, 43, 226],
	brown: [165, 42, 42],
	burlywood: [222, 184, 135],
	cadetblue: [95, 158, 160],
	chartreuse: [127, 255, 0],
	chocolate: [210, 105, 30],
	coral: [255, 127, 80],
	cornflowerblue: [100, 149, 237],
	cornsilk: [255, 248, 220],
	crimson: [220, 20, 60],
	cyan: [0, 255, 255],
	darkblue: [0, 0, 139],
	darkcyan: [0, 139, 139],
	darkgoldenrod: [184, 134, 11],
	darkgray: [169, 169, 169],
	darkgreen: [0, 100, 0],
	darkgrey: [169, 169, 169],
	darkkhaki: [189, 183, 107],
	darkmagenta: [139, 0, 139],
	darkolivegreen: [85, 107, 47],
	darkorange: [255, 140, 0],
	darkorchid: [153, 50, 204],
	darkred: [139, 0, 0],
	darksalmon: [233, 150, 122],
	darkseagreen: [143, 188, 143],
	darkslateblue: [72, 61, 139],
	darkslategray: [47, 79, 79],
	darkslategrey: [47, 79, 79],
	darkturquoise: [0, 206, 209],
	darkviolet: [148, 0, 211],
	deeppink: [255, 20, 147],
	deepskyblue: [0, 191, 255],
	dimgray: [105, 105, 105],
	dimgrey: [105, 105, 105],
	dodgerblue: [30, 144, 255],
	firebrick: [178, 34, 34],
	floralwhite: [255, 250, 240],
	forestgreen: [34, 139, 34],
	fuchsia: [255, 0, 255],
	gainsboro: [220, 220, 220],
	ghostwhite: [248, 248, 255],
	gold: [255, 215, 0],
	goldenrod: [218, 165, 32],
	gray: [128, 128, 128],
	green: [0, 128, 0],
	greenyellow: [173, 255, 47],
	grey: [128, 128, 128],
	honeydew: [240, 255, 240],
	hotpink: [255, 105, 180],
	indianred: [205, 92, 92],
	indigo: [75, 0, 130],
	ivory: [255, 255, 240],
	khaki: [240, 230, 140],
	lavender: [230, 230, 250],
	lavenderblush: [255, 240, 245],
	lawngreen: [124, 252, 0],
	lemonchiffon: [255, 250, 205],
	lightblue: [173, 216, 230],
	lightcoral: [240, 128, 128],
	lightcyan: [224, 255, 255],
	lightgoldenrodyellow: [250, 250, 210],
	lightgray: [211, 211, 211],
	lightgreen: [144, 238, 144],
	lightgrey: [211, 211, 211],
	lightpink: [255, 182, 193],
	lightsalmon: [255, 160, 122],
	lightseagreen: [32, 178, 170],
	lightskyblue: [135, 206, 250],
	lightslategray: [119, 136, 153],
	lightslategrey: [119, 136, 153],
	lightsteelblue: [176, 196, 222],
	lightyellow: [255, 255, 224],
	lime: [0, 255, 0],
	limegreen: [50, 205, 50],
	linen: [250, 240, 230],
	magenta: [255, 0, 255],
	maroon: [128, 0, 0],
	mediumaquamarine: [102, 205, 170],
	mediumblue: [0, 0, 205],
	mediumorchid: [186, 85, 211],
	mediumpurple: [147, 112, 219],
	mediumseagreen: [60, 179, 113],
	mediumslateblue: [123, 104, 238],
	mediumspringgreen: [0, 250, 154],
	mediumturquoise: [72, 209, 204],
	mediumvioletred: [199, 21, 133],
	midnightblue: [25, 25, 112],
	mintcream: [245, 255, 250],
	mistyrose: [255, 228, 225],
	moccasin: [255, 228, 181],
	navajowhite: [255, 222, 173],
	navy: [0, 0, 128],
	oldlace: [253, 245, 230],
	olive: [128, 128, 0],
	olivedrab: [107, 142, 35],
	orange: [255, 165, 0],
	orangered: [255, 69, 0],
	orchid: [218, 112, 214],
	palegoldenrod: [238, 232, 170],
	palegreen: [152, 251, 152],
	paleturquoise: [175, 238, 238],
	palevioletred: [219, 112, 147],
	papayawhip: [255, 239, 213],
	peachpuff: [255, 218, 185],
	peru: [205, 133, 63],
	pink: [255, 192, 203],
	plum: [221, 160, 221],
	powderblue: [176, 224, 230],
	purple: [128, 0, 128],
	rebeccapurple: [102, 51, 153],
	red: [255, 0, 0],
	rosybrown: [188, 143, 143],
	royalblue: [65, 105, 225],
	saddlebrown: [139, 69, 19],
	salmon: [250, 128, 114],
	sandybrown: [244, 164, 96],
	seagreen: [46, 139, 87],
	seashell: [255, 245, 238],
	sienna: [160, 82, 45],
	silver: [192, 192, 192],
	skyblue: [135, 206, 235],
	slateblue: [106, 90, 205],
	slategray: [112, 128, 144],
	slategrey: [112, 128, 144],
	snow: [255, 250, 250],
	springgreen: [0, 255, 127],
	steelblue: [70, 130, 180],
	tan: [210, 180, 140],
	teal: [0, 128, 128],
	thistle: [216, 191, 216],
	tomato: [255, 99, 71],
	turquoise: [64, 224, 208],
	violet: [238, 130, 238],
	wheat: [245, 222, 179],
	white: [255, 255, 255],
	whitesmoke: [245, 245, 245],
	yellow: [255, 255, 0],
	yellowgreen: [154, 205, 50]
};

const reverseNames = Object.create(null);

// Create a list of reverse color names
for (const name in cssKeywords) {
	if (Object.hasOwn(cssKeywords, name)) {
		reverseNames[cssKeywords[name]] = name;
	}
}

const cs = {
	to: {},
	get: {},
};

cs.get = function (string) {
	const prefix = string.slice(0, 3).toLowerCase();
	let value;
	let model;
	switch (prefix) {
		case 'hsl': {
			value = cs.get.hsl(string);
			model = 'hsl';
			break;
		}

		case 'hwb': {
			value = cs.get.hwb(string);
			model = 'hwb';
			break;
		}

		default: {
			value = cs.get.rgb(string);
			model = 'rgb';
			break;
		}
	}

	if (!value) {
		return null;
	}

	return {model, value};
};

cs.get.rgb = function (string) {
	if (!string) {
		return null;
	}

	const abbr = /^#([a-f\d]{3,4})$/i;
	const hex = /^#([a-f\d]{6})([a-f\d]{2})?$/i;
	const rgba = /^rgba?\(\s*([+-]?\d+)(?=[\s,])\s*(?:,\s*)?([+-]?\d+)(?=[\s,])\s*(?:,\s*)?([+-]?\d+)\s*(?:[\s,|/]\s*([+-]?[\d.]+)(%?)\s*)?\)$/;
	const per = /^rgba?\(\s*([+-]?[\d.]+)%\s*,?\s*([+-]?[\d.]+)%\s*,?\s*([+-]?[\d.]+)%\s*(?:[\s,|/]\s*([+-]?[\d.]+)(%?)\s*)?\)$/;
	const keyword = /^(\w+)$/;

	let rgb = [0, 0, 0, 1];
	let match;
	let i;
	let hexAlpha;

	if (match = string.match(hex)) {
		hexAlpha = match[2];
		match = match[1];

		for (i = 0; i < 3; i++) {
			// https://jsperf.com/slice-vs-substr-vs-substring-methods-long-string/19
			const i2 = i * 2;
			rgb[i] = Number.parseInt(match.slice(i2, i2 + 2), 16);
		}

		if (hexAlpha) {
			rgb[3] = Number.parseInt(hexAlpha, 16) / 255;
		}
	} else if (match = string.match(abbr)) {
		match = match[1];
		hexAlpha = match[3];

		for (i = 0; i < 3; i++) {
			rgb[i] = Number.parseInt(match[i] + match[i], 16);
		}

		if (hexAlpha) {
			rgb[3] = Number.parseInt(hexAlpha + hexAlpha, 16) / 255;
		}
	} else if (match = string.match(rgba)) {
		for (i = 0; i < 3; i++) {
			rgb[i] = Number.parseInt(match[i + 1], 10);
		}

		if (match[4]) {
			rgb[3] = match[5] ? Number.parseFloat(match[4]) * 0.01 : Number.parseFloat(match[4]);
		}
	} else if (match = string.match(per)) {
		for (i = 0; i < 3; i++) {
			rgb[i] = Math.round(Number.parseFloat(match[i + 1]) * 2.55);
		}

		if (match[4]) {
			rgb[3] = match[5] ? Number.parseFloat(match[4]) * 0.01 : Number.parseFloat(match[4]);
		}
	} else if (match = string.match(keyword)) {
		if (match[1] === 'transparent') {
			return [0, 0, 0, 0];
		}

		if (!Object.hasOwn(cssKeywords, match[1])) {
			return null;
		}

		rgb = cssKeywords[match[1]];
		rgb[3] = 1;

		return rgb;
	} else {
		return null;
	}

	for (i = 0; i < 3; i++) {
		rgb[i] = clamp(rgb[i], 0, 255);
	}

	rgb[3] = clamp(rgb[3], 0, 1);

	return rgb;
};

cs.get.hsl = function (string) {
	if (!string) {
		return null;
	}

	const hsl = /^hsla?\(\s*([+-]?(?:\d{0,3}\.)?\d+)(?:deg)?\s*,?\s*([+-]?[\d.]+)%\s*,?\s*([+-]?[\d.]+)%\s*(?:[,|/]\s*([+-]?(?=\.\d|\d)(?:0|[1-9]\d*)?(?:\.\d*)?(?:[eE][+-]?\d+)?)\s*)?\)$/;
	const match = string.match(hsl);

	if (match) {
		const alpha = Number.parseFloat(match[4]);
		const h = ((Number.parseFloat(match[1]) % 360) + 360) % 360;
		const s = clamp(Number.parseFloat(match[2]), 0, 100);
		const l = clamp(Number.parseFloat(match[3]), 0, 100);
		const a = clamp(Number.isNaN(alpha) ? 1 : alpha, 0, 1);

		return [h, s, l, a];
	}

	return null;
};

cs.get.hwb = function (string) {
	if (!string) {
		return null;
	}

	const hwb = /^hwb\(\s*([+-]?\d{0,3}(?:\.\d+)?)(?:deg)?\s*[\s,]\s*([+-]?[\d.]+)%\s*[\s,]\s*([+-]?[\d.]+)%\s*(?:[\s,]\s*([+-]?(?=\.\d|\d)(?:0|[1-9]\d*)?(?:\.\d*)?(?:[eE][+-]?\d+)?)\s*)?\)$/;
	const match = string.match(hwb);

	if (match) {
		const alpha = Number.parseFloat(match[4]);
		const h = ((Number.parseFloat(match[1]) % 360) + 360) % 360;
		const w = clamp(Number.parseFloat(match[2]), 0, 100);
		const b = clamp(Number.parseFloat(match[3]), 0, 100);
		const a = clamp(Number.isNaN(alpha) ? 1 : alpha, 0, 1);
		return [h, w, b, a];
	}

	return null;
};

cs.to.hex = function (...rgba) {
	return (
		'#' +
		hexDouble(rgba[0]) +
		hexDouble(rgba[1]) +
		hexDouble(rgba[2]) +
		(rgba[3] < 1
			? (hexDouble(Math.round(rgba[3] * 255)))
			: '')
	);
};

cs.to.rgb = function (...rgba) {
	return rgba.length < 4 || rgba[3] === 1
		? 'rgb(' + Math.round(rgba[0]) + ', ' + Math.round(rgba[1]) + ', ' + Math.round(rgba[2]) + ')'
		: 'rgba(' + Math.round(rgba[0]) + ', ' + Math.round(rgba[1]) + ', ' + Math.round(rgba[2]) + ', ' + rgba[3] + ')';
};

cs.to.rgb.percent = function (...rgba) {
	const r = Math.round(rgba[0] / 255 * 100);
	const g = Math.round(rgba[1] / 255 * 100);
	const b = Math.round(rgba[2] / 255 * 100);

	return rgba.length < 4 || rgba[3] === 1
		? 'rgb(' + r + '%, ' + g + '%, ' + b + '%)'
		: 'rgba(' + r + '%, ' + g + '%, ' + b + '%, ' + rgba[3] + ')';
};

cs.to.hsl = function (...hsla) {
	return hsla.length < 4 || hsla[3] === 1
		? 'hsl(' + hsla[0] + ', ' + hsla[1] + '%, ' + hsla[2] + '%)'
		: 'hsla(' + hsla[0] + ', ' + hsla[1] + '%, ' + hsla[2] + '%, ' + hsla[3] + ')';
};

// Hwb is a bit different than rgb(a) & hsl(a) since there is no alpha specific syntax
// (hwb have alpha optional & 1 is default value)
cs.to.hwb = function (...hwba) {
	let a = '';
	if (hwba.length >= 4 && hwba[3] !== 1) {
		a = ', ' + hwba[3];
	}

	return 'hwb(' + hwba[0] + ', ' + hwba[1] + '%, ' + hwba[2] + '%' + a + ')';
};

cs.to.keyword = function (...rgb) {
	return reverseNames[rgb.slice(0, 3)];
};

// Helpers
function clamp(number_, min, max) {
	return Math.min(Math.max(min, number_), max);
}

function hexDouble(number_) {
	const string_ = Math.round(number_).toString(16).toUpperCase();
	return (string_.length < 2) ? '0' + string_ : string_;
}

/* MIT license */
/* eslint-disable no-mixed-operators */

// NOTE: conversions should only return primitive values (i.e. arrays, or
//       values that give correct `typeof` results).
//       do not use box values types (i.e. Number(), String(), etc.)

const reverseKeywords = {};
for (const key of Object.keys(cssKeywords)) {
	reverseKeywords[cssKeywords[key]] = key;
}

const convert$1 = {
	rgb: {channels: 3, labels: 'rgb'},
	hsl: {channels: 3, labels: 'hsl'},
	hsv: {channels: 3, labels: 'hsv'},
	hwb: {channels: 3, labels: 'hwb'},
	cmyk: {channels: 4, labels: 'cmyk'},
	xyz: {channels: 3, labels: 'xyz'},
	lab: {channels: 3, labels: 'lab'},
	oklab: {channels: 3, labels: ['okl', 'oka', 'okb']},
	lch: {channels: 3, labels: 'lch'},
	oklch: {channels: 3, labels: ['okl', 'okc', 'okh']},
	hex: {channels: 1, labels: ['hex']},
	keyword: {channels: 1, labels: ['keyword']},
	ansi16: {channels: 1, labels: ['ansi16']},
	ansi256: {channels: 1, labels: ['ansi256']},
	hcg: {channels: 3, labels: ['h', 'c', 'g']},
	apple: {channels: 3, labels: ['r16', 'g16', 'b16']},
	gray: {channels: 1, labels: ['gray']},
};

// LAB f(t) constant
const LAB_FT = (6 / 29) ** 3;

// SRGB non-linear transform functions
function srgbNonlinearTransform(c) {
	const cc = c > 0.003_130_8
		? ((1.055 * (c ** (1 / 2.4))) - 0.055)
		: c * 12.92;
	return Math.min(Math.max(0, cc), 1);
}

function srgbNonlinearTransformInv(c) {
	return c > 0.040_45 ? (((c + 0.055) / 1.055) ** 2.4) : (c / 12.92);
}

// Hide .channels and .labels properties
for (const model of Object.keys(convert$1)) {
	if (!('channels' in convert$1[model])) {
		throw new Error('missing channels property: ' + model);
	}

	if (!('labels' in convert$1[model])) {
		throw new Error('missing channel labels property: ' + model);
	}

	if (convert$1[model].labels.length !== convert$1[model].channels) {
		throw new Error('channel and label counts mismatch: ' + model);
	}

	const {channels, labels} = convert$1[model];
	delete convert$1[model].channels;
	delete convert$1[model].labels;
	Object.defineProperty(convert$1[model], 'channels', {value: channels});
	Object.defineProperty(convert$1[model], 'labels', {value: labels});
}

convert$1.rgb.hsl = function (rgb) {
	const r = rgb[0] / 255;
	const g = rgb[1] / 255;
	const b = rgb[2] / 255;
	const min = Math.min(r, g, b);
	const max = Math.max(r, g, b);
	const delta = max - min;
	let h;
	let s;

	switch (max) {
		case min: {
			h = 0;

			break;
		}

		case r: {
			h = (g - b) / delta;

			break;
		}

		case g: {
			h = 2 + (b - r) / delta;

			break;
		}

		case b: {
			h = 4 + (r - g) / delta;

			break;
		}
	// No default
	}

	h = Math.min(h * 60, 360);

	if (h < 0) {
		h += 360;
	}

	const l = (min + max) / 2;

	if (max === min) {
		s = 0;
	} else if (l <= 0.5) {
		s = delta / (max + min);
	} else {
		s = delta / (2 - max - min);
	}

	return [h, s * 100, l * 100];
};

convert$1.rgb.hsv = function (rgb) {
	let rdif;
	let gdif;
	let bdif;
	let h;
	let s;

	const r = rgb[0] / 255;
	const g = rgb[1] / 255;
	const b = rgb[2] / 255;
	const v = Math.max(r, g, b);
	const diff = v - Math.min(r, g, b);
	const diffc = function (c) {
		return (v - c) / 6 / diff + 1 / 2;
	};

	if (diff === 0) {
		h = 0;
		s = 0;
	} else {
		s = diff / v;
		rdif = diffc(r);
		gdif = diffc(g);
		bdif = diffc(b);

		switch (v) {
			case r: {
				h = bdif - gdif;

				break;
			}

			case g: {
				h = (1 / 3) + rdif - bdif;

				break;
			}

			case b: {
				h = (2 / 3) + gdif - rdif;

				break;
			}
		// No default
		}

		if (h < 0) {
			h += 1;
		} else if (h > 1) {
			h -= 1;
		}
	}

	return [
		h * 360,
		s * 100,
		v * 100,
	];
};

convert$1.rgb.hwb = function (rgb) {
	const r = rgb[0];
	const g = rgb[1];
	let b = rgb[2];
	const h = convert$1.rgb.hsl(rgb)[0];
	const w = 1 / 255 * Math.min(r, Math.min(g, b));

	b = 1 - 1 / 255 * Math.max(r, Math.max(g, b));

	return [h, w * 100, b * 100];
};

convert$1.rgb.oklab = function (rgb) {
	// Assume sRGB
	const r = srgbNonlinearTransformInv(rgb[0] / 255);
	const g = srgbNonlinearTransformInv(rgb[1] / 255);
	const b = srgbNonlinearTransformInv(rgb[2] / 255);

	const lp = Math.cbrt(0.412_221_470_8 * r + 0.536_332_536_3 * g + 0.051_445_992_9 * b);
	const mp = Math.cbrt(0.211_903_498_2 * r + 0.680_699_545_1 * g + 0.107_396_956_6 * b);
	const sp = Math.cbrt(0.088_302_461_9 * r + 0.281_718_837_6 * g + 0.629_978_700_5 * b);

	const l = 0.210_454_255_3 * lp + 0.793_617_785 * mp - 0.004_072_046_8 * sp;
	const aa = 1.977_998_495_1 * lp - 2.428_592_205 * mp + 0.450_593_709_9 * sp;
	const bb = 0.025_904_037_1 * lp + 0.782_771_766_2 * mp - 0.808_675_766 * sp;

	return [l * 100, aa * 100, bb * 100];
};

convert$1.rgb.cmyk = function (rgb) {
	const r = rgb[0] / 255;
	const g = rgb[1] / 255;
	const b = rgb[2] / 255;

	const k = Math.min(1 - r, 1 - g, 1 - b);
	const c = (1 - r - k) / (1 - k) || 0;
	const m = (1 - g - k) / (1 - k) || 0;
	const y = (1 - b - k) / (1 - k) || 0;

	return [c * 100, m * 100, y * 100, k * 100];
};

function comparativeDistance(x, y) {
	/*
		See https://en.m.wikipedia.org/wiki/Euclidean_distance#Squared_Euclidean_distance
	*/
	return (
		((x[0] - y[0]) ** 2) +
		((x[1] - y[1]) ** 2) +
		((x[2] - y[2]) ** 2)
	);
}

convert$1.rgb.keyword = function (rgb) {
	const reversed = reverseKeywords[rgb];
	if (reversed) {
		return reversed;
	}

	let currentClosestDistance = Number.POSITIVE_INFINITY;
	let currentClosestKeyword;

	for (const keyword of Object.keys(cssKeywords)) {
		const value = cssKeywords[keyword];

		// Compute comparative distance
		const distance = comparativeDistance(rgb, value);

		// Check if its less, if so set as closest
		if (distance < currentClosestDistance) {
			currentClosestDistance = distance;
			currentClosestKeyword = keyword;
		}
	}

	return currentClosestKeyword;
};

convert$1.keyword.rgb = function (keyword) {
	return cssKeywords[keyword];
};

convert$1.rgb.xyz = function (rgb) {
	// Assume sRGB
	const r = srgbNonlinearTransformInv(rgb[0] / 255);
	const g = srgbNonlinearTransformInv(rgb[1] / 255);
	const b = srgbNonlinearTransformInv(rgb[2] / 255);

	const x = (r * 0.412_456_4) + (g * 0.357_576_1) + (b * 0.180_437_5);
	const y = (r * 0.212_672_9) + (g * 0.715_152_2) + (b * 0.072_175);
	const z = (r * 0.019_333_9) + (g * 0.119_192) + (b * 0.950_304_1);

	return [x * 100, y * 100, z * 100];
};

convert$1.rgb.lab = function (rgb) {
	const xyz = convert$1.rgb.xyz(rgb);
	let x = xyz[0];
	let y = xyz[1];
	let z = xyz[2];

	x /= 95.047;
	y /= 100;
	z /= 108.883;

	x = x > LAB_FT ? (x ** (1 / 3)) : (7.787 * x) + (16 / 116);
	y = y > LAB_FT ? (y ** (1 / 3)) : (7.787 * y) + (16 / 116);
	z = z > LAB_FT ? (z ** (1 / 3)) : (7.787 * z) + (16 / 116);

	const l = (116 * y) - 16;
	const a = 500 * (x - y);
	const b = 200 * (y - z);

	return [l, a, b];
};

convert$1.hsl.rgb = function (hsl) {
	const h = hsl[0] / 360;
	const s = hsl[1] / 100;
	const l = hsl[2] / 100;
	let t3;
	let value;

	if (s === 0) {
		value = l * 255;
		return [value, value, value];
	}

	const t2 = l < 0.5 ? l * (1 + s) : l + s - l * s;

	const t1 = 2 * l - t2;

	const rgb = [0, 0, 0];
	for (let i = 0; i < 3; i++) {
		t3 = h + 1 / 3 * -(i - 1);
		if (t3 < 0) {
			t3++;
		}

		if (t3 > 1) {
			t3--;
		}

		if (6 * t3 < 1) {
			value = t1 + (t2 - t1) * 6 * t3;
		} else if (2 * t3 < 1) {
			value = t2;
		} else if (3 * t3 < 2) {
			value = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
		} else {
			value = t1;
		}

		rgb[i] = value * 255;
	}

	return rgb;
};

convert$1.hsl.hsv = function (hsl) {
	const h = hsl[0];
	let s = hsl[1] / 100;
	let l = hsl[2] / 100;
	let smin = s;
	const lmin = Math.max(l, 0.01);

	l *= 2;
	s *= (l <= 1) ? l : 2 - l;
	smin *= lmin <= 1 ? lmin : 2 - lmin;
	const v = (l + s) / 2;
	const sv = l === 0 ? (2 * smin) / (lmin + smin) : (2 * s) / (l + s);

	return [h, sv * 100, v * 100];
};

convert$1.hsv.rgb = function (hsv) {
	const h = hsv[0] / 60;
	const s = hsv[1] / 100;
	let v = hsv[2] / 100;
	const hi = Math.floor(h) % 6;

	const f = h - Math.floor(h);
	const p = 255 * v * (1 - s);
	const q = 255 * v * (1 - (s * f));
	const t = 255 * v * (1 - (s * (1 - f)));
	v *= 255;

	switch (hi) {
		case 0: {
			return [v, t, p];
		}

		case 1: {
			return [q, v, p];
		}

		case 2: {
			return [p, v, t];
		}

		case 3: {
			return [p, q, v];
		}

		case 4: {
			return [t, p, v];
		}

		case 5: {
			return [v, p, q];
		}
	}
};

convert$1.hsv.hsl = function (hsv) {
	const h = hsv[0];
	const s = hsv[1] / 100;
	const v = hsv[2] / 100;
	const vmin = Math.max(v, 0.01);
	let sl;
	let l;

	l = (2 - s) * v;
	const lmin = (2 - s) * vmin;
	sl = s * vmin;
	sl /= (lmin <= 1) ? lmin : 2 - lmin;
	sl = sl || 0;
	l /= 2;

	return [h, sl * 100, l * 100];
};

// http://dev.w3.org/csswg/css-color/#hwb-to-rgb
convert$1.hwb.rgb = function (hwb) {
	const h = hwb[0] / 360;
	let wh = hwb[1] / 100;
	let bl = hwb[2] / 100;
	const ratio = wh + bl;
	let f;

	// Wh + bl cant be > 1
	if (ratio > 1) {
		wh /= ratio;
		bl /= ratio;
	}

	const i = Math.floor(6 * h);
	const v = 1 - bl;
	f = 6 * h - i;

	// eslint-disable-next-line no-bitwise
	if ((i & 0x01) !== 0) {
		f = 1 - f;
	}

	const n = wh + f * (v - wh); // Linear interpolation

	let r;
	let g;
	let b;
	/* eslint-disable max-statements-per-line,no-multi-spaces, default-case-last */
	switch (i) {
		default:
		case 6:
		case 0: { r = v;  g = n;  b = wh; break;
		}

		case 1: { r = n;  g = v;  b = wh; break;
		}

		case 2: { r = wh; g = v;  b = n; break;
		}

		case 3: { r = wh; g = n;  b = v; break;
		}

		case 4: { r = n;  g = wh; b = v; break;
		}

		case 5: { r = v;  g = wh; b = n; break;
		}
	}
	/* eslint-enable max-statements-per-line,no-multi-spaces, default-case-last */

	return [r * 255, g * 255, b * 255];
};

convert$1.cmyk.rgb = function (cmyk) {
	const c = cmyk[0] / 100;
	const m = cmyk[1] / 100;
	const y = cmyk[2] / 100;
	const k = cmyk[3] / 100;

	const r = 1 - Math.min(1, c * (1 - k) + k);
	const g = 1 - Math.min(1, m * (1 - k) + k);
	const b = 1 - Math.min(1, y * (1 - k) + k);

	return [r * 255, g * 255, b * 255];
};

convert$1.xyz.rgb = function (xyz) {
	const x = xyz[0] / 100;
	const y = xyz[1] / 100;
	const z = xyz[2] / 100;
	let r;
	let g;
	let b;

	r = (x * 3.240_454_2) + (y * -1.537_138_5) + (z * -0.498_531_4);
	g = (x * -0.969_266) + (y * 1.876_010_8) + (z * 0.041_556);
	b = (x * 0.055_643_4) + (y * -0.204_025_9) + (z * 1.057_225_2);

	// Assume sRGB
	r = srgbNonlinearTransform(r);
	g = srgbNonlinearTransform(g);
	b = srgbNonlinearTransform(b);

	return [r * 255, g * 255, b * 255];
};

convert$1.xyz.lab = function (xyz) {
	let x = xyz[0];
	let y = xyz[1];
	let z = xyz[2];

	x /= 95.047;
	y /= 100;
	z /= 108.883;

	x = x > LAB_FT ? (x ** (1 / 3)) : (7.787 * x) + (16 / 116);
	y = y > LAB_FT ? (y ** (1 / 3)) : (7.787 * y) + (16 / 116);
	z = z > LAB_FT ? (z ** (1 / 3)) : (7.787 * z) + (16 / 116);

	const l = (116 * y) - 16;
	const a = 500 * (x - y);
	const b = 200 * (y - z);

	return [l, a, b];
};

convert$1.xyz.oklab = function (xyz) {
	const x = xyz[0] / 100;
	const y = xyz[1] / 100;
	const z = xyz[2] / 100;

	const lp = Math.cbrt(0.818_933_010_1 * x + 0.361_866_742_4 * y - 0.128_859_713_7 * z);
	const mp = Math.cbrt(0.032_984_543_6 * x + 0.929_311_871_5 * y + 0.036_145_638_7 * z);
	const sp = Math.cbrt(0.048_200_301_8 * x + 0.264_366_269_1 * y + 0.633_851_707 * z);

	const l = 0.210_454_255_3 * lp + 0.793_617_785 * mp - 0.004_072_046_8 * sp;
	const a = 1.977_998_495_1 * lp - 2.428_592_205 * mp + 0.450_593_709_9 * sp;
	const b = 0.025_904_037_1 * lp + 0.782_771_766_2 * mp - 0.808_675_766 * sp;

	return [l * 100, a * 100, b * 100];
};

convert$1.oklab.oklch = function (oklab) {
	return convert$1.lab.lch(oklab);
};

convert$1.oklab.xyz = function (oklab) {
	const ll = oklab[0] / 100;
	const a = oklab[1] / 100;
	const b = oklab[2] / 100;

	const l = (0.999_999_998 * ll + 0.396_337_792 * a + 0.215_803_758 * b) ** 3;
	const m = (1.000_000_008 * ll - 0.105_561_342 * a - 0.063_854_175 * b) ** 3;
	const s = (1.000_000_055 * ll - 0.089_484_182 * a - 1.291_485_538 * b) ** 3;

	const x = 1.227_013_851 * l - 0.557_799_98 * m + 0.281_256_149 * s;
	const y = -0.040_580_178 * l + 1.112_256_87 * m - 0.071_676_679 * s;
	const z = -0.076_381_285 * l - 0.421_481_978 * m + 1.586_163_22 * s;

	return [x * 100, y * 100, z * 100];
};

convert$1.oklab.rgb = function (oklab) {
	const ll = oklab[0] / 100;
	const aa = oklab[1] / 100;
	const bb = oklab[2] / 100;

	const l = (ll + 0.396_337_777_4 * aa + 0.215_803_757_3 * bb) ** 3;
	const m = (ll - 0.105_561_345_8 * aa - 0.063_854_172_8 * bb) ** 3;
	const s = (ll - 0.089_484_177_5 * aa - 1.291_485_548 * bb) ** 3;

	// Assume sRGB
	const r = srgbNonlinearTransform(4.076_741_662_1 * l - 3.307_711_591_3 * m + 0.230_969_929_2 * s);
	const g = srgbNonlinearTransform(-1.268_438_004_6 * l + 2.609_757_401_1 * m - 0.341_319_396_5 * s);
	const b = srgbNonlinearTransform(-0.004_196_086_3 * l - 0.703_418_614_7 * m + 1.707_614_701 * s);

	return [r * 255, g * 255, b * 255];
};

convert$1.oklch.oklab = function (oklch) {
	return convert$1.lch.lab(oklch);
};

convert$1.lab.xyz = function (lab) {
	const l = lab[0];
	const a = lab[1];
	const b = lab[2];
	let x;
	let y;
	let z;

	y = (l + 16) / 116;
	x = a / 500 + y;
	z = y - b / 200;

	const y2 = y ** 3;
	const x2 = x ** 3;
	const z2 = z ** 3;
	y = y2 > LAB_FT ? y2 : (y - 16 / 116) / 7.787;
	x = x2 > LAB_FT ? x2 : (x - 16 / 116) / 7.787;
	z = z2 > LAB_FT ? z2 : (z - 16 / 116) / 7.787;

	// Illuminant D65 XYZ Tristrimulus Values
	// https://en.wikipedia.org/wiki/CIE_1931_color_space
	x *= 95.047;
	y *= 100;
	z *= 108.883;

	return [x, y, z];
};

convert$1.lab.lch = function (lab) {
	const l = lab[0];
	const a = lab[1];
	const b = lab[2];
	let h;

	const hr = Math.atan2(b, a);
	h = hr * 360 / 2 / Math.PI;

	if (h < 0) {
		h += 360;
	}

	const c = Math.sqrt(a * a + b * b);

	return [l, c, h];
};

convert$1.lch.lab = function (lch) {
	const l = lch[0];
	const c = lch[1];
	const h = lch[2];

	const hr = h / 360 * 2 * Math.PI;
	const a = c * Math.cos(hr);
	const b = c * Math.sin(hr);

	return [l, a, b];
};

convert$1.rgb.ansi16 = function (args, saturation = null) {
	const [r, g, b] = args;
	let value = saturation === null ? convert$1.rgb.hsv(args)[2] : saturation; // Hsv -> ansi16 optimization

	value = Math.round(value / 50);

	if (value === 0) {
		return 30;
	}

	let ansi = 30
		/* eslint-disable no-bitwise */
		+ ((Math.round(b / 255) << 2)
		| (Math.round(g / 255) << 1)
		| Math.round(r / 255));
		/* eslint-enable no-bitwise */

	if (value === 2) {
		ansi += 60;
	}

	return ansi;
};

convert$1.hsv.ansi16 = function (args) {
	// Optimization here; we already know the value and don't need to get
	// it converted for us.
	return convert$1.rgb.ansi16(convert$1.hsv.rgb(args), args[2]);
};

convert$1.rgb.ansi256 = function (args) {
	const r = args[0];
	const g = args[1];
	const b = args[2];

	// We use the extended greyscale palette here, with the exception of
	// black and white. normal palette only has 4 greyscale shades.
	// eslint-disable-next-line no-bitwise
	if (r >> 4 === g >> 4 && g >> 4 === b >> 4) {
		if (r < 8) {
			return 16;
		}

		if (r > 248) {
			return 231;
		}

		return Math.round(((r - 8) / 247) * 24) + 232;
	}

	const ansi = 16
		+ (36 * Math.round(r / 255 * 5))
		+ (6 * Math.round(g / 255 * 5))
		+ Math.round(b / 255 * 5);

	return ansi;
};

convert$1.ansi16.rgb = function (args) {
	args = args[0];

	let color = args % 10;

	// Handle greyscale
	if (color === 0 || color === 7) {
		if (args > 50) {
			color += 3.5;
		}

		color = color / 10.5 * 255;

		return [color, color, color];
	}

	const mult = (Math.trunc(args > 50) + 1) * 0.5;
	/* eslint-disable no-bitwise */
	const r = ((color & 1) * mult) * 255;
	const g = (((color >> 1) & 1) * mult) * 255;
	const b = (((color >> 2) & 1) * mult) * 255;
	/* eslint-enable no-bitwise */

	return [r, g, b];
};

convert$1.ansi256.rgb = function (args) {
	args = args[0];

	// Handle greyscale
	if (args >= 232) {
		const c = (args - 232) * 10 + 8;
		return [c, c, c];
	}

	args -= 16;

	let rem;
	const r = Math.floor(args / 36) / 5 * 255;
	const g = Math.floor((rem = args % 36) / 6) / 5 * 255;
	const b = (rem % 6) / 5 * 255;

	return [r, g, b];
};

convert$1.rgb.hex = function (args) {
	/* eslint-disable no-bitwise */
	const integer = ((Math.round(args[0]) & 0xFF) << 16)
		+ ((Math.round(args[1]) & 0xFF) << 8)
		+ (Math.round(args[2]) & 0xFF);
	/* eslint-enable no-bitwise */

	const string = integer.toString(16).toUpperCase();
	return '000000'.slice(string.length) + string;
};

convert$1.hex.rgb = function (args) {
	const match = args.toString(16).match(/[a-f\d]{6}|[a-f\d]{3}/i);
	if (!match) {
		return [0, 0, 0];
	}

	let colorString = match[0];

	if (match[0].length === 3) {
		colorString = [...colorString].map(char => char + char).join('');
	}

	const integer = Number.parseInt(colorString, 16);
	/* eslint-disable no-bitwise */
	const r = (integer >> 16) & 0xFF;
	const g = (integer >> 8) & 0xFF;
	const b = integer & 0xFF;
	/* eslint-enable no-bitwise */

	return [r, g, b];
};

convert$1.rgb.hcg = function (rgb) {
	const r = rgb[0] / 255;
	const g = rgb[1] / 255;
	const b = rgb[2] / 255;
	const max = Math.max(Math.max(r, g), b);
	const min = Math.min(Math.min(r, g), b);
	const chroma = (max - min);
	let hue;

	const grayscale = chroma < 1 ? min / (1 - chroma) : 0;

	if (chroma <= 0) {
		hue = 0;
	} else if (max === r) {
		hue = ((g - b) / chroma) % 6;
	} else if (max === g) {
		hue = 2 + (b - r) / chroma;
	} else {
		hue = 4 + (r - g) / chroma;
	}

	hue /= 6;
	hue %= 1;

	return [hue * 360, chroma * 100, grayscale * 100];
};

convert$1.hsl.hcg = function (hsl) {
	const s = hsl[1] / 100;
	const l = hsl[2] / 100;

	const c = l < 0.5 ? (2 * s * l) : (2 * s * (1 - l));

	let f = 0;
	if (c < 1) {
		f = (l - 0.5 * c) / (1 - c);
	}

	return [hsl[0], c * 100, f * 100];
};

convert$1.hsv.hcg = function (hsv) {
	const s = hsv[1] / 100;
	const v = hsv[2] / 100;

	const c = s * v;
	let f = 0;

	if (c < 1) {
		f = (v - c) / (1 - c);
	}

	return [hsv[0], c * 100, f * 100];
};

convert$1.hcg.rgb = function (hcg) {
	const h = hcg[0] / 360;
	const c = hcg[1] / 100;
	const g = hcg[2] / 100;

	if (c === 0) {
		return [g * 255, g * 255, g * 255];
	}

	const pure = [0, 0, 0];
	const hi = (h % 1) * 6;
	const v = hi % 1;
	const w = 1 - v;
	let mg = 0;

	/* eslint-disable max-statements-per-line */
	switch (Math.floor(hi)) {
		case 0: {
			pure[0] = 1; pure[1] = v; pure[2] = 0; break;
		}

		case 1: {
			pure[0] = w; pure[1] = 1; pure[2] = 0; break;
		}

		case 2: {
			pure[0] = 0; pure[1] = 1; pure[2] = v; break;
		}

		case 3: {
			pure[0] = 0; pure[1] = w; pure[2] = 1; break;
		}

		case 4: {
			pure[0] = v; pure[1] = 0; pure[2] = 1; break;
		}

		default: {
			pure[0] = 1; pure[1] = 0; pure[2] = w;
		}
	}
	/* eslint-enable max-statements-per-line */

	mg = (1 - c) * g;

	return [
		(c * pure[0] + mg) * 255,
		(c * pure[1] + mg) * 255,
		(c * pure[2] + mg) * 255,
	];
};

convert$1.hcg.hsv = function (hcg) {
	const c = hcg[1] / 100;
	const g = hcg[2] / 100;

	const v = c + g * (1 - c);
	let f = 0;

	if (v > 0) {
		f = c / v;
	}

	return [hcg[0], f * 100, v * 100];
};

convert$1.hcg.hsl = function (hcg) {
	const c = hcg[1] / 100;
	const g = hcg[2] / 100;

	const l = g * (1 - c) + 0.5 * c;
	let s = 0;

	if (l > 0 && l < 0.5) {
		s = c / (2 * l);
	} else if (l >= 0.5 && l < 1) {
		s = c / (2 * (1 - l));
	}

	return [hcg[0], s * 100, l * 100];
};

convert$1.hcg.hwb = function (hcg) {
	const c = hcg[1] / 100;
	const g = hcg[2] / 100;
	const v = c + g * (1 - c);
	return [hcg[0], (v - c) * 100, (1 - v) * 100];
};

convert$1.hwb.hcg = function (hwb) {
	const w = hwb[1] / 100;
	const b = hwb[2] / 100;
	const v = 1 - b;
	const c = v - w;
	let g = 0;

	if (c < 1) {
		g = (v - c) / (1 - c);
	}

	return [hwb[0], c * 100, g * 100];
};

convert$1.apple.rgb = function (apple) {
	return [(apple[0] / 65_535) * 255, (apple[1] / 65_535) * 255, (apple[2] / 65_535) * 255];
};

convert$1.rgb.apple = function (rgb) {
	return [(rgb[0] / 255) * 65_535, (rgb[1] / 255) * 65_535, (rgb[2] / 255) * 65_535];
};

convert$1.gray.rgb = function (args) {
	return [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];
};

convert$1.gray.hsl = function (args) {
	return [0, 0, args[0]];
};

convert$1.gray.hsv = convert$1.gray.hsl;

convert$1.gray.hwb = function (gray) {
	return [0, 100, gray[0]];
};

convert$1.gray.cmyk = function (gray) {
	return [0, 0, 0, gray[0]];
};

convert$1.gray.lab = function (gray) {
	return [gray[0], 0, 0];
};

convert$1.gray.hex = function (gray) {
	/* eslint-disable no-bitwise */
	const value = Math.round(gray[0] / 100 * 255) & 0xFF;
	const integer = (value << 16) + (value << 8) + value;
	/* eslint-enable no-bitwise */

	const string = integer.toString(16).toUpperCase();
	return '000000'.slice(string.length) + string;
};

convert$1.rgb.gray = function (rgb) {
	const value = (rgb[0] + rgb[1] + rgb[2]) / 3;
	return [value / 255 * 100];
};

/*
	This function routes a model to all other models.

	all functions that are routed have a property `.conversion` attached
	to the returned synthetic function. This property is an array
	of strings, each with the steps in between the 'from' and 'to'
	color models (inclusive).

	conversions that are not possible simply are not included.
*/

function buildGraph() {
	const graph = {};
	// https://jsperf.com/object-keys-vs-for-in-with-closure/3
	const models = Object.keys(convert$1);

	for (let {length} = models, i = 0; i < length; i++) {
		graph[models[i]] = {
			// http://jsperf.com/1-vs-infinity
			// micro-opt, but this is simple.
			distance: -1,
			parent: null,
		};
	}

	return graph;
}

// https://en.wikipedia.org/wiki/Breadth-first_search
function deriveBFS(fromModel) {
	const graph = buildGraph();
	const queue = [fromModel]; // Unshift -> queue -> pop

	graph[fromModel].distance = 0;

	while (queue.length > 0) {
		const current = queue.pop();
		const adjacents = Object.keys(convert$1[current]);

		for (let {length} = adjacents, i = 0; i < length; i++) {
			const adjacent = adjacents[i];
			const node = graph[adjacent];

			if (node.distance === -1) {
				node.distance = graph[current].distance + 1;
				node.parent = current;
				queue.unshift(adjacent);
			}
		}
	}

	return graph;
}

function link(from, to) {
	return function (args) {
		return to(from(args));
	};
}

function wrapConversion(toModel, graph) {
	const path = [graph[toModel].parent, toModel];
	let fn = convert$1[graph[toModel].parent][toModel];

	let cur = graph[toModel].parent;
	while (graph[cur].parent) {
		path.unshift(graph[cur].parent);
		fn = link(convert$1[graph[cur].parent][cur], fn);
		cur = graph[cur].parent;
	}

	fn.conversion = path;
	return fn;
}

function route(fromModel) {
	const graph = deriveBFS(fromModel);
	const conversion = {};

	const models = Object.keys(graph);
	for (let {length} = models, i = 0; i < length; i++) {
		const toModel = models[i];
		const node = graph[toModel];

		if (node.parent === null) {
			// No possible conversion, or this node is the source model.
			continue;
		}

		conversion[toModel] = wrapConversion(toModel, graph);
	}

	return conversion;
}

const convert = {};

const models = Object.keys(convert$1);

function wrapRaw(fn) {
	const wrappedFn = function (...args) {
		const arg0 = args[0];
		if (arg0 === undefined || arg0 === null) {
			return arg0;
		}

		if (arg0.length > 1) {
			args = arg0;
		}

		return fn(args);
	};

	// Preserve .conversion property if there is one
	if ('conversion' in fn) {
		wrappedFn.conversion = fn.conversion;
	}

	return wrappedFn;
}

function wrapRounded(fn) {
	const wrappedFn = function (...args) {
		const arg0 = args[0];

		if (arg0 === undefined || arg0 === null) {
			return arg0;
		}

		if (arg0.length > 1) {
			args = arg0;
		}

		const result = fn(args);

		// We're assuming the result is an array here.
		// see notice in conversions.js; don't use box types
		// in conversion functions.
		if (typeof result === 'object') {
			for (let {length} = result, i = 0; i < length; i++) {
				result[i] = Math.round(result[i]);
			}
		}

		return result;
	};

	// Preserve .conversion property if there is one
	if ('conversion' in fn) {
		wrappedFn.conversion = fn.conversion;
	}

	return wrappedFn;
}

for (const fromModel of models) {
	convert[fromModel] = {};

	Object.defineProperty(convert[fromModel], 'channels', {value: convert$1[fromModel].channels});
	Object.defineProperty(convert[fromModel], 'labels', {value: convert$1[fromModel].labels});

	const routes = route(fromModel);
	const routeModels = Object.keys(routes);

	for (const toModel of routeModels) {
		const fn = routes[toModel];

		convert[fromModel][toModel] = wrapRounded(fn);
		convert[fromModel][toModel].raw = wrapRaw(fn);
	}
}

const skippedModels = [
	// To be honest, I don't really feel like keyword belongs in color convert, but eh.
	'keyword',

	// Gray conflicts with some method names, and has its own method defined.
	'gray',

	// Shouldn't really be in color-convert either...
	'hex',
];

const hashedModelKeys = {};
for (const model of Object.keys(convert)) {
	hashedModelKeys[[...convert[model].labels].sort().join('')] = model;
}

const limiters = {};

function Color(object, model) {
	if (!(this instanceof Color)) {
		return new Color(object, model);
	}

	if (model && model in skippedModels) {
		model = null;
	}

	if (model && !(model in convert)) {
		throw new Error('Unknown model: ' + model);
	}

	let i;
	let channels;

	if (object == null) { // eslint-disable-line no-eq-null,eqeqeq
		this.model = 'rgb';
		this.color = [0, 0, 0];
		this.valpha = 1;
	} else if (object instanceof Color) {
		this.model = object.model;
		this.color = [...object.color];
		this.valpha = object.valpha;
	} else if (typeof object === 'string') {
		const result = cs.get(object);
		if (result === null) {
			throw new Error('Unable to parse color from string: ' + object);
		}

		this.model = result.model;
		channels = convert[this.model].channels;
		this.color = result.value.slice(0, channels);
		this.valpha = typeof result.value[channels] === 'number' ? result.value[channels] : 1;
	} else if (object.length > 0) {
		this.model = model || 'rgb';
		channels = convert[this.model].channels;
		const newArray = Array.prototype.slice.call(object, 0, channels);
		this.color = zeroArray(newArray, channels);
		this.valpha = typeof object[channels] === 'number' ? object[channels] : 1;
	} else if (typeof object === 'number') {
		// This is always RGB - can be converted later on.
		this.model = 'rgb';
		this.color = [
			(object >> 16) & 0xFF,
			(object >> 8) & 0xFF,
			object & 0xFF,
		];
		this.valpha = 1;
	} else {
		this.valpha = 1;

		const keys = Object.keys(object);
		if ('alpha' in object) {
			keys.splice(keys.indexOf('alpha'), 1);
			this.valpha = typeof object.alpha === 'number' ? object.alpha : 0;
		}

		const hashedKeys = keys.sort().join('');
		if (!(hashedKeys in hashedModelKeys)) {
			throw new Error('Unable to parse color from object: ' + JSON.stringify(object));
		}

		this.model = hashedModelKeys[hashedKeys];

		const {labels} = convert[this.model];
		const color = [];
		for (i = 0; i < labels.length; i++) {
			color.push(object[labels[i]]);
		}

		this.color = zeroArray(color);
	}

	// Perform limitations (clamping, etc.)
	if (limiters[this.model]) {
		channels = convert[this.model].channels;
		for (i = 0; i < channels; i++) {
			const limit = limiters[this.model][i];
			if (limit) {
				this.color[i] = limit(this.color[i]);
			}
		}
	}

	this.valpha = Math.max(0, Math.min(1, this.valpha));

	if (Object.freeze) {
		Object.freeze(this);
	}
}

Color.prototype = {
	toString() {
		return this.string();
	},

	toJSON() {
		return this[this.model]();
	},

	string(places) {
		let self = this.model in cs.to ? this : this.rgb();
		self = self.round(typeof places === 'number' ? places : 1);
		const arguments_ = self.valpha === 1 ? self.color : [...self.color, this.valpha];
		return cs.to[self.model](...arguments_);
	},

	percentString(places) {
		const self = this.rgb().round(typeof places === 'number' ? places : 1);
		const arguments_ = self.valpha === 1 ? self.color : [...self.color, this.valpha];
		return cs.to.rgb.percent(...arguments_);
	},

	array() {
		return this.valpha === 1 ? [...this.color] : [...this.color, this.valpha];
	},

	object() {
		const result = {};
		const {channels} = convert[this.model];
		const {labels} = convert[this.model];

		for (let i = 0; i < channels; i++) {
			result[labels[i]] = this.color[i];
		}

		if (this.valpha !== 1) {
			result.alpha = this.valpha;
		}

		return result;
	},

	unitArray() {
		const rgb = this.rgb().color;
		rgb[0] /= 255;
		rgb[1] /= 255;
		rgb[2] /= 255;

		if (this.valpha !== 1) {
			rgb.push(this.valpha);
		}

		return rgb;
	},

	unitObject() {
		const rgb = this.rgb().object();
		rgb.r /= 255;
		rgb.g /= 255;
		rgb.b /= 255;

		if (this.valpha !== 1) {
			rgb.alpha = this.valpha;
		}

		return rgb;
	},

	round(places) {
		places = Math.max(places || 0, 0);
		return new Color([...this.color.map(roundToPlace(places)), this.valpha], this.model);
	},

	alpha(value) {
		if (value !== undefined) {
			return new Color([...this.color, Math.max(0, Math.min(1, value))], this.model);
		}

		return this.valpha;
	},

	// Rgb
	red: getset('rgb', 0, maxfn(255)),
	green: getset('rgb', 1, maxfn(255)),
	blue: getset('rgb', 2, maxfn(255)),

	hue: getset(['hsl', 'hsv', 'hsl', 'hwb', 'hcg'], 0, value => ((value % 360) + 360) % 360),

	saturationl: getset('hsl', 1, maxfn(100)),
	lightness: getset('hsl', 2, maxfn(100)),

	saturationv: getset('hsv', 1, maxfn(100)),
	value: getset('hsv', 2, maxfn(100)),

	chroma: getset('hcg', 1, maxfn(100)),
	gray: getset('hcg', 2, maxfn(100)),

	white: getset('hwb', 1, maxfn(100)),
	wblack: getset('hwb', 2, maxfn(100)),

	cyan: getset('cmyk', 0, maxfn(100)),
	magenta: getset('cmyk', 1, maxfn(100)),
	yellow: getset('cmyk', 2, maxfn(100)),
	black: getset('cmyk', 3, maxfn(100)),

	x: getset('xyz', 0, maxfn(95.047)),
	y: getset('xyz', 1, maxfn(100)),
	z: getset('xyz', 2, maxfn(108.833)),

	l: getset('lab', 0, maxfn(100)),
	a: getset('lab', 1),
	b: getset('lab', 2),

	keyword(value) {
		if (value !== undefined) {
			return new Color(value);
		}

		return convert[this.model].keyword(this.color);
	},

	hex(value) {
		if (value !== undefined) {
			return new Color(value);
		}

		return cs.to.hex(...this.rgb().round().color);
	},

	hexa(value) {
		if (value !== undefined) {
			return new Color(value);
		}

		const rgbArray = this.rgb().round().color;

		let alphaHex = Math.round(this.valpha * 255).toString(16).toUpperCase();
		if (alphaHex.length === 1) {
			alphaHex = '0' + alphaHex;
		}

		return cs.to.hex(...rgbArray) + alphaHex;
	},

	rgbNumber() {
		const rgb = this.rgb().color;
		return ((rgb[0] & 0xFF) << 16) | ((rgb[1] & 0xFF) << 8) | (rgb[2] & 0xFF);
	},

	luminosity() {
		// http://www.w3.org/TR/WCAG20/#relativeluminancedef
		const rgb = this.rgb().color;

		const lum = [];
		for (const [i, element] of rgb.entries()) {
			const chan = element / 255;
			lum[i] = (chan <= 0.04045) ? chan / 12.92 : ((chan + 0.055) / 1.055) ** 2.4;
		}

		return 0.2126 * lum[0] + 0.7152 * lum[1] + 0.0722 * lum[2];
	},

	contrast(color2) {
		// http://www.w3.org/TR/WCAG20/#contrast-ratiodef
		const lum1 = this.luminosity();
		const lum2 = color2.luminosity();

		if (lum1 > lum2) {
			return (lum1 + 0.05) / (lum2 + 0.05);
		}

		return (lum2 + 0.05) / (lum1 + 0.05);
	},

	level(color2) {
		// https://www.w3.org/TR/WCAG/#contrast-enhanced
		const contrastRatio = this.contrast(color2);
		if (contrastRatio >= 7) {
			return 'AAA';
		}

		return (contrastRatio >= 4.5) ? 'AA' : '';
	},

	isDark() {
		// YIQ equation from http://24ways.org/2010/calculating-color-contrast
		const rgb = this.rgb().color;
		const yiq = (rgb[0] * 2126 + rgb[1] * 7152 + rgb[2] * 722) / 10000;
		return yiq < 128;
	},

	isLight() {
		return !this.isDark();
	},

	negate() {
		const rgb = this.rgb();
		for (let i = 0; i < 3; i++) {
			rgb.color[i] = 255 - rgb.color[i];
		}

		return rgb;
	},

	lighten(ratio) {
		const hsl = this.hsl();
		hsl.color[2] += hsl.color[2] * ratio;
		return hsl;
	},

	darken(ratio) {
		const hsl = this.hsl();
		hsl.color[2] -= hsl.color[2] * ratio;
		return hsl;
	},

	saturate(ratio) {
		const hsl = this.hsl();
		hsl.color[1] += hsl.color[1] * ratio;
		return hsl;
	},

	desaturate(ratio) {
		const hsl = this.hsl();
		hsl.color[1] -= hsl.color[1] * ratio;
		return hsl;
	},

	whiten(ratio) {
		const hwb = this.hwb();
		hwb.color[1] += hwb.color[1] * ratio;
		return hwb;
	},

	blacken(ratio) {
		const hwb = this.hwb();
		hwb.color[2] += hwb.color[2] * ratio;
		return hwb;
	},

	grayscale() {
		// http://en.wikipedia.org/wiki/Grayscale#Converting_colour_to_grayscale
		const rgb = this.rgb().color;
		const value = rgb[0] * 0.3 + rgb[1] * 0.59 + rgb[2] * 0.11;
		return Color.rgb(value, value, value);
	},

	fade(ratio) {
		return this.alpha(this.valpha - (this.valpha * ratio));
	},

	opaquer(ratio) {
		return this.alpha(this.valpha + (this.valpha * ratio));
	},

	rotate(degrees) {
		const hsl = this.hsl();
		let hue = hsl.color[0];
		hue = (hue + degrees) % 360;
		hue = hue < 0 ? 360 + hue : hue;
		hsl.color[0] = hue;
		return hsl;
	},

	mix(mixinColor, weight) {
		// Ported from sass implementation in C
		// https://github.com/sass/libsass/blob/0e6b4a2850092356aa3ece07c6b249f0221caced/functions.cpp#L209
		if (!mixinColor || !mixinColor.rgb) {
			throw new Error('Argument to "mix" was not a Color instance, but rather an instance of ' + typeof mixinColor);
		}

		const color1 = mixinColor.rgb();
		const color2 = this.rgb();
		const p = weight === undefined ? 0.5 : weight;

		const w = 2 * p - 1;
		const a = color1.alpha() - color2.alpha();

		const w1 = (((w * a === -1) ? w : (w + a) / (1 + w * a)) + 1) / 2;
		const w2 = 1 - w1;

		return Color.rgb(
			w1 * color1.red() + w2 * color2.red(),
			w1 * color1.green() + w2 * color2.green(),
			w1 * color1.blue() + w2 * color2.blue(),
			color1.alpha() * p + color2.alpha() * (1 - p));
	},
};

// Model conversion methods and static constructors
for (const model of Object.keys(convert)) {
	if (skippedModels.includes(model)) {
		continue;
	}

	const {channels} = convert[model];

	// Conversion methods
	Color.prototype[model] = function (...arguments_) {
		if (this.model === model) {
			return new Color(this);
		}

		if (arguments_.length > 0) {
			return new Color(arguments_, model);
		}

		return new Color([...assertArray(convert[this.model][model].raw(this.color)), this.valpha], model);
	};

	// 'static' construction methods
	Color[model] = function (...arguments_) {
		let color = arguments_[0];
		if (typeof color === 'number') {
			color = zeroArray(arguments_, channels);
		}

		return new Color(color, model);
	};
}

function roundTo(number, places) {
	return Number(number.toFixed(places));
}

function roundToPlace(places) {
	return function (number) {
		return roundTo(number, places);
	};
}

function getset(model, channel, modifier) {
	model = Array.isArray(model) ? model : [model];

	for (const m of model) {
		(limiters[m] ||= [])[channel] = modifier;
	}

	model = model[0];

	return function (value) {
		let result;

		if (value !== undefined) {
			if (modifier) {
				value = modifier(value);
			}

			result = this[model]();
			result.color[channel] = value;
			return result;
		}

		result = this[model]().color[channel];
		if (modifier) {
			result = modifier(result);
		}

		return result;
	};
}

function maxfn(max) {
	return function (v) {
		return Math.max(0, Math.min(max, v));
	};
}

function assertArray(value) {
	return Array.isArray(value) ? value : [value];
}

function zeroArray(array, length) {
	for (let i = 0; i < length; i++) {
		if (typeof array[i] !== 'number') {
			array[i] = 0;
		}
	}

	return array;
}

function getDefaultExportFromCjs (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

/***
 * Convert string to hex color.
 *
 * @param {String} str Text to hash and convert to hex.
 * @returns {String}
 * @api public
 */
var textHex = function hex(str) {
  for (
    var i = 0, hash = 0;
    i < str.length;
    hash = str.charCodeAt(i++) + ((hash << 5) - hash)
  );

  var color = Math.floor(
    Math.abs(
      (Math.sin(hash) * 10000) % 1 * 16777216
    )
  ).toString(16);

  return '#' + Array(6 - color.length + 1).join('0') + color;
};

var hex = /*@__PURE__*/getDefaultExportFromCjs(textHex);

/**
 * Generate a color for a given name. But be reasonably smart about it by
 * understanding name spaces and coloring each namespace a bit lighter so they
 * still have the same base color as the root.
 *
 * @param {string} namespace The namespace
 * @param {string} [delimiter] The delimiter
 * @returns {string} color
 */
function colorspace(namespace, delimiter) {
  const split = namespace.split(delimiter || ':');
  let base = hex(split[0]);
  if (!split.length) return base;
  for (let i = 0, l = split.length - 1; i < l; i++) {
    base = Color(base).mix(Color(hex(split[i + 1]))).saturate(1).hex();
  }
  return base;
}

module.exports = colorspace;


/***/ }),

/***/ 86661:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";
/*!
 * accepts
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module dependencies.
 * @private
 */

var Negotiator = __nccwpck_require__(60668)
var mime = __nccwpck_require__(14096)

/**
 * Module exports.
 * @public
 */

module.exports = Accepts

/**
 * Create a new Accepts object for the given req.
 *
 * @param {object} req
 * @public
 */

function Accepts (req) {
  if (!(this instanceof Accepts)) {
    return new Accepts(req)
  }

  this.headers = req.headers
  this.negotiator = new Negotiator(req)
}

/**
 * Check if the given `type(s)` is acceptable, returning
 * the best match when true, otherwise `undefined`, in which
 * case you should respond with 406 "Not Acceptable".
 *
 * The `type` value may be a single mime type string
 * such as "application/json", the extension name
 * such as "json" or an array `["json", "html", "text/plain"]`. When a list
 * or array is given the _best_ match, if any is returned.
 *
 * Examples:
 *
 *     // Accept: text/html
 *     this.types('html');
 *     // => "html"
 *
 *     // Accept: text/*, application/json
 *     this.types('html');
 *     // => "html"
 *     this.types('text/html');
 *     // => "text/html"
 *     this.types('json', 'text');
 *     // => "json"
 *     this.types('application/json');
 *     // => "application/json"
 *
 *     // Accept: text/*, application/json
 *     this.types('image/png');
 *     this.types('png');
 *     // => undefined
 *
 *     // Accept: text/*;q=.5, application/json
 *     this.types(['html', 'json']);
 *     this.types('html', 'json');
 *     // => "json"
 *
 * @param {String|Array} types...
 * @return {String|Array|Boolean}
 * @public
 */

Accepts.prototype.type =
Accepts.prototype.types = function (types_) {
  var types = types_

  // support flattened arguments
  if (types && !Array.isArray(types)) {
    types = new Array(arguments.length)
    for (var i = 0; i < types.length; i++) {
      types[i] = arguments[i]
    }
  }

  // no types, return all requested types
  if (!types || types.length === 0) {
    return this.negotiator.mediaTypes()
  }

  // no accept header, return first given type
  if (!this.headers.accept) {
    return types[0]
  }

  var mimes = types.map(extToMime)
  var accepts = this.negotiator.mediaTypes(mimes.filter(validMime))
  var first = accepts[0]

  return first
    ? types[mimes.indexOf(first)]
    : false
}

/**
 * Return accepted encodings or best fit based on `encodings`.
 *
 * Given `Accept-Encoding: gzip, deflate`
 * an array sorted by quality is returned:
 *
 *     ['gzip', 'deflate']
 *
 * @param {String|Array} encodings...
 * @return {String|Array}
 * @public
 */

Accepts.prototype.encoding =
Accepts.prototype.encodings = function (encodings_) {
  var encodings = encodings_

  // support flattened arguments
  if (encodings && !Array.isArray(encodings)) {
    encodings = new Array(arguments.length)
    for (var i = 0; i < encodings.length; i++) {
      encodings[i] = arguments[i]
    }
  }

  // no encodings, return all requested encodings
  if (!encodings || encodings.length === 0) {
    return this.negotiator.encodings()
  }

  return this.negotiator.encodings(encodings)[0] || false
}

/**
 * Return accepted charsets or best fit based on `charsets`.
 *
 * Given `Accept-Charset: utf-8, iso-8859-1;q=0.2, utf-7;q=0.5`
 * an array sorted by quality is returned:
 *
 *     ['utf-8', 'utf-7', 'iso-8859-1']
 *
 * @param {String|Array} charsets...
 * @return {String|Array}
 * @public
 */

Accepts.prototype.charset =
Accepts.prototype.charsets = function (charsets_) {
  var charsets = charsets_

  // support flattened arguments
  if (charsets && !Array.isArray(charsets)) {
    charsets = new Array(arguments.length)
    for (var i = 0; i < charsets.length; i++) {
      charsets[i] = arguments[i]
    }
  }

  // no charsets, return all requested charsets
  if (!charsets || charsets.length === 0) {
    return this.negotiator.charsets()
  }

  return this.negotiator.charsets(charsets)[0] || false
}

/**
 * Return accepted languages or best fit based on `langs`.
 *
 * Given `Accept-Language: en;q=0.8, es, pt`
 * an array sorted by quality is returned:
 *
 *     ['es', 'pt', 'en']
 *
 * @param {String|Array} langs...
 * @return {Array|String}
 * @public
 */

Accepts.prototype.lang =
Accepts.prototype.langs =
Accepts.prototype.language =
Accepts.prototype.languages = function (languages_) {
  var languages = languages_

  // support flattened arguments
  if (languages && !Array.isArray(languages)) {
    languages = new Array(arguments.length)
    for (var i = 0; i < languages.length; i++) {
      languages[i] = arguments[i]
    }
  }

  // no languages, return all requested languages
  if (!languages || languages.length === 0) {
    return this.negotiator.languages()
  }

  return this.negotiator.languages(languages)[0] || false
}

/**
 * Convert extnames to mime.
 *
 * @param {String} type
 * @return {String}
 * @private
 */

function extToMime (type) {
  return type.indexOf('/') === -1
    ? mime.lookup(type)
    : type
}

/**
 * Check if mime is valid.
 *
 * @param {String} type
 * @return {String}
 * @private
 */

function validMime (type) {
  return typeof type === 'string'
}


/***/ }),

/***/ 85541:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var parsePath = __nccwpck_require__(35656)
var setValue = __nccwpck_require__(90929)

function appendField (store, key, value) {
  var steps = parsePath(key)

  steps.reduce(function (context, step) {
    return setValue(context, step, context[step.key], value)
  }, store)
}

module.exports = appendField


/***/ }),

/***/ 35656:
/***/ ((module) => {

var reFirstKey = /^[^\[]*/
var reDigitPath = /^\[(\d+)\]/
var reNormalPath = /^\[([^\]]+)\]/

function parsePath (key) {
  function failure () {
    return [{ type: 'object', key: key, last: true }]
  }

  var firstKey = reFirstKey.exec(key)[0]
  if (!firstKey) return failure()

  var len = key.length
  var pos = firstKey.length
  var tail = { type: 'object', key: firstKey }
  var steps = [tail]

  while (pos < len) {
    var m

    if (key[pos] === '[' && key[pos + 1] === ']') {
      pos += 2
      tail.append = true
      if (pos !== len) return failure()
      continue
    }

    m = reDigitPath.exec(key.substring(pos))
    if (m !== null) {
      pos += m[0].length
      tail.nextType = 'array'
      tail = { type: 'array', key: parseInt(m[1], 10) }
      steps.push(tail)
      continue
    }

    m = reNormalPath.exec(key.substring(pos))
    if (m !== null) {
      pos += m[0].length
      tail.nextType = 'object'
      tail = { type: 'object', key: m[1] }
      steps.push(tail)
      continue
    }

    return failure()
  }

  tail.last = true
  return steps
}

module.exports = parsePath


/***/ }),

/***/ 90929:
/***/ ((module) => {

function valueType (value) {
  if (value === undefined) return 'undefined'
  if (Array.isArray(value)) return 'array'
  if (typeof value === 'object') return 'object'
  return 'scalar'
}

function setLastValue (context, step, currentValue, entryValue) {
  switch (valueType(currentValue)) {
    case 'undefined':
      if (step.append) {
        context[step.key] = [entryValue]
      } else {
        context[step.key] = entryValue
      }
      break
    case 'array':
      context[step.key].push(entryValue)
      break
    case 'object':
      return setLastValue(currentValue, { type: 'object', key: '', last: true }, currentValue[''], entryValue)
    case 'scalar':
      context[step.key] = [context[step.key], entryValue]
      break
  }

  return context
}

function setValue (context, step, currentValue, entryValue) {
  if (step.last) return setLastValue(context, step, currentValue, entryValue)

  var obj
  switch (valueType(currentValue)) {
    case 'undefined':
      if (step.nextType === 'array') {
        context[step.key] = []
      } else {
        context[step.key] = Object.create(null)
      }
      return context[step.key]
    case 'object':
      return context[step.key]
    case 'array':
      if (step.nextType === 'array') {
        return currentValue
      }

      obj = Object.create(null)
      context[step.key] = obj
      currentValue.forEach(function (item, i) {
        if (item !== undefined) obj['' + i] = item
      })

      return obj
    case 'scalar':
      obj = Object.create(null)
      obj[''] = currentValue
      context[step.key] = obj
      return obj
  }
}

module.exports = setValue


/***/ }),

/***/ 79560:
/***/ ((module) => {

"use strict";


/**
 * Expose `arrayFlatten`.
 */
module.exports = arrayFlatten

/**
 * Recursive flatten function with depth.
 *
 * @param  {Array}  array
 * @param  {Array}  result
 * @param  {Number} depth
 * @return {Array}
 */
function flattenWithDepth (array, result, depth) {
  for (var i = 0; i < array.length; i++) {
    var value = array[i]

    if (depth > 0 && Array.isArray(value)) {
      flattenWithDepth(value, result, depth - 1)
    } else {
      result.push(value)
    }
  }

  return result
}

/**
 * Recursive flatten function. Omitting depth is slightly faster.
 *
 * @param  {Array} array
 * @param  {Array} result
 * @return {Array}
 */
function flattenForever (array, result) {
  for (var i = 0; i < array.length; i++) {
    var value = array[i]

    if (Array.isArray(value)) {
      flattenForever(value, result)
    } else {
      result.push(value)
    }
  }

  return result
}

/**
 * Flatten an array, with the ability to define a depth.
 *
 * @param  {Array}  array
 * @param  {Number} depth
 * @return {Array}
 */
function arrayFlatten (array, depth) {
  if (depth == null) {
    return flattenForever(array, [])
  }

  return flattenWithDepth(array, [], depth)
}


/***/ }),

/***/ 38300:
/***/ ((module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports["default"] = asyncify;

var _initialParams = __nccwpck_require__(70890);

var _initialParams2 = _interopRequireDefault(_initialParams);

var _setImmediate = __nccwpck_require__(63787);

var _setImmediate2 = _interopRequireDefault(_setImmediate);

var _wrapAsync = __nccwpck_require__(76212);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Take a sync function and make it async, passing its return value to a
 * callback. This is useful for plugging sync functions into a waterfall,
 * series, or other async functions. Any arguments passed to the generated
 * function will be passed to the wrapped function (except for the final
 * callback argument). Errors thrown will be passed to the callback.
 *
 * If the function passed to `asyncify` returns a Promise, that promises's
 * resolved/rejected state will be used to call the callback, rather than simply
 * the synchronous return value.
 *
 * This also means you can asyncify ES2017 `async` functions.
 *
 * @name asyncify
 * @static
 * @memberOf module:Utils
 * @method
 * @alias wrapSync
 * @category Util
 * @param {Function} func - The synchronous function, or Promise-returning
 * function to convert to an {@link AsyncFunction}.
 * @returns {AsyncFunction} An asynchronous wrapper of the `func`. To be
 * invoked with `(args..., callback)`.
 * @example
 *
 * // passing a regular synchronous function
 * async.waterfall([
 *     async.apply(fs.readFile, filename, "utf8"),
 *     async.asyncify(JSON.parse),
 *     function (data, next) {
 *         // data is the result of parsing the text.
 *         // If there was a parsing error, it would have been caught.
 *     }
 * ], callback);
 *
 * // passing a function returning a promise
 * async.waterfall([
 *     async.apply(fs.readFile, filename, "utf8"),
 *     async.asyncify(function (contents) {
 *         return db.model.create(contents);
 *     }),
 *     function (model, next) {
 *         // `model` is the instantiated model object.
 *         // If there was an error, this function would be skipped.
 *     }
 * ], callback);
 *
 * // es2017 example, though `asyncify` is not needed if your JS environment
 * // supports async functions out of the box
 * var q = async.queue(async.asyncify(async function(file) {
 *     var intermediateStep = await processFile(file);
 *     return await somePromise(intermediateStep)
 * }));
 *
 * q.push(files);
 */
function asyncify(func) {
    if ((0, _wrapAsync.isAsync)(func)) {
        return function (...args /*, callback*/) {
            const callback = args.pop();
            const promise = func.apply(this, args);
            return handlePromise(promise, callback);
        };
    }

    return (0, _initialParams2.default)(function (args, callback) {
        var result;
        try {
            result = func.apply(this, args);
        } catch (e) {
            return callback(e);
        }
        // if result is Promise object
        if (result && typeof result.then === 'function') {
            return handlePromise(result, callback);
        } else {
            callback(null, result);
        }
    });
}

function handlePromise(promise, callback) {
    return promise.then(value => {
        invokeCallback(callback, null, value);
    }, err => {
        invokeCallback(callback, err && (err instanceof Error || err.message) ? err : new Error(err));
    });
}

function invokeCallback(callback, error, value) {
    try {
        callback(error, value);
    } catch (err) {
        (0, _setImmediate2.default)(e => {
            throw e;
        }, err);
    }
}
module.exports = exports.default;

/***/ }),

/***/ 96186:
/***/ ((module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
    value: true
}));

var _isArrayLike = __nccwpck_require__(53078);

var _isArrayLike2 = _interopRequireDefault(_isArrayLike);

var _breakLoop = __nccwpck_require__(80265);

var _breakLoop2 = _interopRequireDefault(_breakLoop);

var _eachOfLimit = __nccwpck_require__(8991);

var _eachOfLimit2 = _interopRequireDefault(_eachOfLimit);

var _once = __nccwpck_require__(63491);

var _once2 = _interopRequireDefault(_once);

var _onlyOnce = __nccwpck_require__(64085);

var _onlyOnce2 = _interopRequireDefault(_onlyOnce);

var _wrapAsync = __nccwpck_require__(76212);

var _wrapAsync2 = _interopRequireDefault(_wrapAsync);

var _awaitify = __nccwpck_require__(5534);

var _awaitify2 = _interopRequireDefault(_awaitify);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// eachOf implementation optimized for array-likes
function eachOfArrayLike(coll, iteratee, callback) {
    callback = (0, _once2.default)(callback);
    var index = 0,
        completed = 0,
        { length } = coll,
        canceled = false;
    if (length === 0) {
        callback(null);
    }

    function iteratorCallback(err, value) {
        if (err === false) {
            canceled = true;
        }
        if (canceled === true) return;
        if (err) {
            callback(err);
        } else if (++completed === length || value === _breakLoop2.default) {
            callback(null);
        }
    }

    for (; index < length; index++) {
        iteratee(coll[index], index, (0, _onlyOnce2.default)(iteratorCallback));
    }
}

// a generic version of eachOf which can handle array, object, and iterator cases.
function eachOfGeneric(coll, iteratee, callback) {
    return (0, _eachOfLimit2.default)(coll, Infinity, iteratee, callback);
}

/**
 * Like [`each`]{@link module:Collections.each}, except that it passes the key (or index) as the second argument
 * to the iteratee.
 *
 * @name eachOf
 * @static
 * @memberOf module:Collections
 * @method
 * @alias forEachOf
 * @category Collection
 * @see [async.each]{@link module:Collections.each}
 * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
 * @param {AsyncFunction} iteratee - A function to apply to each
 * item in `coll`.
 * The `key` is the item's key, or index in the case of an array.
 * Invoked with (item, key, callback).
 * @param {Function} [callback] - A callback which is called when all
 * `iteratee` functions have finished, or an error occurs. Invoked with (err).
 * @returns {Promise} a promise, if a callback is omitted
 * @example
 *
 * // dev.json is a file containing a valid json object config for dev environment
 * // dev.json is a file containing a valid json object config for test environment
 * // prod.json is a file containing a valid json object config for prod environment
 * // invalid.json is a file with a malformed json object
 *
 * let configs = {}; //global variable
 * let validConfigFileMap = {dev: 'dev.json', test: 'test.json', prod: 'prod.json'};
 * let invalidConfigFileMap = {dev: 'dev.json', test: 'test.json', invalid: 'invalid.json'};
 *
 * // asynchronous function that reads a json file and parses the contents as json object
 * function parseFile(file, key, callback) {
 *     fs.readFile(file, "utf8", function(err, data) {
 *         if (err) return calback(err);
 *         try {
 *             configs[key] = JSON.parse(data);
 *         } catch (e) {
 *             return callback(e);
 *         }
 *         callback();
 *     });
 * }
 *
 * // Using callbacks
 * async.forEachOf(validConfigFileMap, parseFile, function (err) {
 *     if (err) {
 *         console.error(err);
 *     } else {
 *         console.log(configs);
 *         // configs is now a map of JSON data, e.g.
 *         // { dev: //parsed dev.json, test: //parsed test.json, prod: //parsed prod.json}
 *     }
 * });
 *
 * //Error handing
 * async.forEachOf(invalidConfigFileMap, parseFile, function (err) {
 *     if (err) {
 *         console.error(err);
 *         // JSON parse error exception
 *     } else {
 *         console.log(configs);
 *     }
 * });
 *
 * // Using Promises
 * async.forEachOf(validConfigFileMap, parseFile)
 * .then( () => {
 *     console.log(configs);
 *     // configs is now a map of JSON data, e.g.
 *     // { dev: //parsed dev.json, test: //parsed test.json, prod: //parsed prod.json}
 * }).catch( err => {
 *     console.error(err);
 * });
 *
 * //Error handing
 * async.forEachOf(invalidConfigFileMap, parseFile)
 * .then( () => {
 *     console.log(configs);
 * }).catch( err => {
 *     console.error(err);
 *     // JSON parse error exception
 * });
 *
 * // Using async/await
 * async () => {
 *     try {
 *         let result = await async.forEachOf(validConfigFileMap, parseFile);
 *         console.log(configs);
 *         // configs is now a map of JSON data, e.g.
 *         // { dev: //parsed dev.json, test: //parsed test.json, prod: //parsed prod.json}
 *     }
 *     catch (err) {
 *         console.log(err);
 *     }
 * }
 *
 * //Error handing
 * async () => {
 *     try {
 *         let result = await async.forEachOf(invalidConfigFileMap, parseFile);
 *         console.log(configs);
 *     }
 *     catch (err) {
 *         console.log(err);
 *         // JSON parse error exception
 *     }
 * }
 *
 */
function eachOf(coll, iteratee, callback) {
    var eachOfImplementation = (0, _isArrayLike2.default)(coll) ? eachOfArrayLike : eachOfGeneric;
    return eachOfImplementation(coll, (0, _wrapAsync2.default)(iteratee), callback);
}

exports["default"] = (0, _awaitify2.default)(eachOf, 3);
module.exports = exports.default;

/***/ }),

/***/ 8991:
/***/ ((module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
    value: true
}));

var _eachOfLimit2 = __nccwpck_require__(34543);

var _eachOfLimit3 = _interopRequireDefault(_eachOfLimit2);

var _wrapAsync = __nccwpck_require__(76212);

var _wrapAsync2 = _interopRequireDefault(_wrapAsync);

var _awaitify = __nccwpck_require__(5534);

var _awaitify2 = _interopRequireDefault(_awaitify);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * The same as [`eachOf`]{@link module:Collections.eachOf} but runs a maximum of `limit` async operations at a
 * time.
 *
 * @name eachOfLimit
 * @static
 * @memberOf module:Collections
 * @method
 * @see [async.eachOf]{@link module:Collections.eachOf}
 * @alias forEachOfLimit
 * @category Collection
 * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
 * @param {number} limit - The maximum number of async operations at a time.
 * @param {AsyncFunction} iteratee - An async function to apply to each
 * item in `coll`. The `key` is the item's key, or index in the case of an
 * array.
 * Invoked with (item, key, callback).
 * @param {Function} [callback] - A callback which is called when all
 * `iteratee` functions have finished, or an error occurs. Invoked with (err).
 * @returns {Promise} a promise, if a callback is omitted
 */
function eachOfLimit(coll, limit, iteratee, callback) {
    return (0, _eachOfLimit3.default)(limit)(coll, (0, _wrapAsync2.default)(iteratee), callback);
}

exports["default"] = (0, _awaitify2.default)(eachOfLimit, 4);
module.exports = exports.default;

/***/ }),

/***/ 5283:
/***/ ((module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
    value: true
}));

var _eachOfLimit = __nccwpck_require__(8991);

var _eachOfLimit2 = _interopRequireDefault(_eachOfLimit);

var _awaitify = __nccwpck_require__(5534);

var _awaitify2 = _interopRequireDefault(_awaitify);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * The same as [`eachOf`]{@link module:Collections.eachOf} but runs only a single async operation at a time.
 *
 * @name eachOfSeries
 * @static
 * @memberOf module:Collections
 * @method
 * @see [async.eachOf]{@link module:Collections.eachOf}
 * @alias forEachOfSeries
 * @category Collection
 * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
 * @param {AsyncFunction} iteratee - An async function to apply to each item in
 * `coll`.
 * Invoked with (item, key, callback).
 * @param {Function} [callback] - A callback which is called when all `iteratee`
 * functions have finished, or an error occurs. Invoked with (err).
 * @returns {Promise} a promise, if a callback is omitted
 */
function eachOfSeries(coll, iteratee, callback) {
    return (0, _eachOfLimit2.default)(coll, 1, iteratee, callback);
}
exports["default"] = (0, _awaitify2.default)(eachOfSeries, 3);
module.exports = exports.default;

/***/ }),

/***/ 63650:
/***/ ((module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
    value: true
}));

var _eachOf = __nccwpck_require__(96186);

var _eachOf2 = _interopRequireDefault(_eachOf);

var _withoutIndex = __nccwpck_require__(42914);

var _withoutIndex2 = _interopRequireDefault(_withoutIndex);

var _wrapAsync = __nccwpck_require__(76212);

var _wrapAsync2 = _interopRequireDefault(_wrapAsync);

var _awaitify = __nccwpck_require__(5534);

var _awaitify2 = _interopRequireDefault(_awaitify);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Applies the function `iteratee` to each item in `coll`, in parallel.
 * The `iteratee` is called with an item from the list, and a callback for when
 * it has finished. If the `iteratee` passes an error to its `callback`, the
 * main `callback` (for the `each` function) is immediately called with the
 * error.
 *
 * Note, that since this function applies `iteratee` to each item in parallel,
 * there is no guarantee that the iteratee functions will complete in order.
 *
 * @name each
 * @static
 * @memberOf module:Collections
 * @method
 * @alias forEach
 * @category Collection
 * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
 * @param {AsyncFunction} iteratee - An async function to apply to
 * each item in `coll`. Invoked with (item, callback).
 * The array index is not passed to the iteratee.
 * If you need the index, use `eachOf`.
 * @param {Function} [callback] - A callback which is called when all
 * `iteratee` functions have finished, or an error occurs. Invoked with (err).
 * @returns {Promise} a promise, if a callback is omitted
 * @example
 *
 * // dir1 is a directory that contains file1.txt, file2.txt
 * // dir2 is a directory that contains file3.txt, file4.txt
 * // dir3 is a directory that contains file5.txt
 * // dir4 does not exist
 *
 * const fileList = [ 'dir1/file2.txt', 'dir2/file3.txt', 'dir/file5.txt'];
 * const withMissingFileList = ['dir1/file1.txt', 'dir4/file2.txt'];
 *
 * // asynchronous function that deletes a file
 * const deleteFile = function(file, callback) {
 *     fs.unlink(file, callback);
 * };
 *
 * // Using callbacks
 * async.each(fileList, deleteFile, function(err) {
 *     if( err ) {
 *         console.log(err);
 *     } else {
 *         console.log('All files have been deleted successfully');
 *     }
 * });
 *
 * // Error Handling
 * async.each(withMissingFileList, deleteFile, function(err){
 *     console.log(err);
 *     // [ Error: ENOENT: no such file or directory ]
 *     // since dir4/file2.txt does not exist
 *     // dir1/file1.txt could have been deleted
 * });
 *
 * // Using Promises
 * async.each(fileList, deleteFile)
 * .then( () => {
 *     console.log('All files have been deleted successfully');
 * }).catch( err => {
 *     console.log(err);
 * });
 *
 * // Error Handling
 * async.each(fileList, deleteFile)
 * .then( () => {
 *     console.log('All files have been deleted successfully');
 * }).catch( err => {
 *     console.log(err);
 *     // [ Error: ENOENT: no such file or directory ]
 *     // since dir4/file2.txt does not exist
 *     // dir1/file1.txt could have been deleted
 * });
 *
 * // Using async/await
 * async () => {
 *     try {
 *         await async.each(files, deleteFile);
 *     }
 *     catch (err) {
 *         console.log(err);
 *     }
 * }
 *
 * // Error Handling
 * async () => {
 *     try {
 *         await async.each(withMissingFileList, deleteFile);
 *     }
 *     catch (err) {
 *         console.log(err);
 *         // [ Error: ENOENT: no such file or directory ]
 *         // since dir4/file2.txt does not exist
 *         // dir1/file1.txt could have been deleted
 *     }
 * }
 *
 */
function eachLimit(coll, iteratee, callback) {
    return (0, _eachOf2.default)(coll, (0, _withoutIndex2.default)((0, _wrapAsync2.default)(iteratee)), callback);
}

exports["default"] = (0, _awaitify2.default)(eachLimit, 3);
module.exports = exports.default;

/***/ }),

/***/ 79325:
/***/ ((module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports["default"] = asyncEachOfLimit;

var _breakLoop = __nccwpck_require__(80265);

var _breakLoop2 = _interopRequireDefault(_breakLoop);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// for async generators
function asyncEachOfLimit(generator, limit, iteratee, callback) {
    let done = false;
    let canceled = false;
    let awaiting = false;
    let running = 0;
    let idx = 0;

    function replenish() {
        //console.log('replenish')
        if (running >= limit || awaiting || done) return;
        //console.log('replenish awaiting')
        awaiting = true;
        generator.next().then(({ value, done: iterDone }) => {
            //console.log('got value', value)
            if (canceled || done) return;
            awaiting = false;
            if (iterDone) {
                done = true;
                if (running <= 0) {
                    //console.log('done nextCb')
                    callback(null);
                }
                return;
            }
            running++;
            iteratee(value, idx, iterateeCallback);
            idx++;
            replenish();
        }).catch(handleError);
    }

    function iterateeCallback(err, result) {
        //console.log('iterateeCallback')
        running -= 1;
        if (canceled) return;
        if (err) return handleError(err);

        if (err === false) {
            done = true;
            canceled = true;
            return;
        }

        if (result === _breakLoop2.default || done && running <= 0) {
            done = true;
            //console.log('done iterCb')
            return callback(null);
        }
        replenish();
    }

    function handleError(err) {
        if (canceled) return;
        awaiting = false;
        done = true;
        callback(err);
    }

    replenish();
}
module.exports = exports.default;

/***/ }),

/***/ 5534:
/***/ ((module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports["default"] = awaitify;
// conditionally promisify a function.
// only return a promise if a callback is omitted
function awaitify(asyncFn, arity) {
    if (!arity) arity = asyncFn.length;
    if (!arity) throw new Error('arity is undefined');
    function awaitable(...args) {
        if (typeof args[arity - 1] === 'function') {
            return asyncFn.apply(this, args);
        }

        return new Promise((resolve, reject) => {
            args[arity - 1] = (err, ...cbArgs) => {
                if (err) return reject(err);
                resolve(cbArgs.length > 1 ? cbArgs : cbArgs[0]);
            };
            asyncFn.apply(this, args);
        });
    }

    return awaitable;
}
module.exports = exports.default;

/***/ }),

/***/ 80265:
/***/ ((module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
    value: true
}));
// A temporary value used to identify if the loop should be broken.
// See #1064, #1293
const breakLoop = {};
exports["default"] = breakLoop;
module.exports = exports.default;

/***/ }),

/***/ 34543:
/***/ ((module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
    value: true
}));

var _once = __nccwpck_require__(63491);

var _once2 = _interopRequireDefault(_once);

var _iterator = __nccwpck_require__(29052);

var _iterator2 = _interopRequireDefault(_iterator);

var _onlyOnce = __nccwpck_require__(64085);

var _onlyOnce2 = _interopRequireDefault(_onlyOnce);

var _wrapAsync = __nccwpck_require__(76212);

var _asyncEachOfLimit = __nccwpck_require__(79325);

var _asyncEachOfLimit2 = _interopRequireDefault(_asyncEachOfLimit);

var _breakLoop = __nccwpck_require__(80265);

var _breakLoop2 = _interopRequireDefault(_breakLoop);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports["default"] = limit => {
    return (obj, iteratee, callback) => {
        callback = (0, _once2.default)(callback);
        if (limit <= 0) {
            throw new RangeError('concurrency limit cannot be less than 1');
        }
        if (!obj) {
            return callback(null);
        }
        if ((0, _wrapAsync.isAsyncGenerator)(obj)) {
            return (0, _asyncEachOfLimit2.default)(obj, limit, iteratee, callback);
        }
        if ((0, _wrapAsync.isAsyncIterable)(obj)) {
            return (0, _asyncEachOfLimit2.default)(obj[Symbol.asyncIterator](), limit, iteratee, callback);
        }
        var nextElem = (0, _iterator2.default)(obj);
        var done = false;
        var canceled = false;
        var running = 0;
        var looping = false;

        function iterateeCallback(err, value) {
            if (canceled) return;
            running -= 1;
            if (err) {
                done = true;
                callback(err);
            } else if (err === false) {
                done = true;
                canceled = true;
            } else if (value === _breakLoop2.default || done && running <= 0) {
                done = true;
                return callback(null);
            } else if (!looping) {
                replenish();
            }
        }

        function replenish() {
            looping = true;
            while (running < limit && !done) {
                var elem = nextElem();
                if (elem === null) {
                    done = true;
                    if (running <= 0) {
                        callback(null);
                    }
                    return;
                }
                running += 1;
                iteratee(elem.value, elem.key, (0, _onlyOnce2.default)(iterateeCallback));
            }
            looping = false;
        }

        replenish();
    };
};

module.exports = exports.default;

/***/ }),

/***/ 62350:
/***/ ((module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
    value: true
}));

exports["default"] = function (coll) {
    return coll[Symbol.iterator] && coll[Symbol.iterator]();
};

module.exports = exports.default;

/***/ }),

/***/ 70890:
/***/ ((module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
    value: true
}));

exports["default"] = function (fn) {
    return function (...args /*, callback*/) {
        var callback = args.pop();
        return fn.call(this, args, callback);
    };
};

module.exports = exports.default;

/***/ }),

/***/ 53078:
/***/ ((module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports["default"] = isArrayLike;
function isArrayLike(value) {
    return value && typeof value.length === 'number' && value.length >= 0 && value.length % 1 === 0;
}
module.exports = exports.default;

/***/ }),

/***/ 29052:
/***/ ((module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports["default"] = createIterator;

var _isArrayLike = __nccwpck_require__(53078);

var _isArrayLike2 = _interopRequireDefault(_isArrayLike);

var _getIterator = __nccwpck_require__(62350);

var _getIterator2 = _interopRequireDefault(_getIterator);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function createArrayIterator(coll) {
    var i = -1;
    var len = coll.length;
    return function next() {
        return ++i < len ? { value: coll[i], key: i } : null;
    };
}

function createES2015Iterator(iterator) {
    var i = -1;
    return function next() {
        var item = iterator.next();
        if (item.done) return null;
        i++;
        return { value: item.value, key: i };
    };
}

function createObjectIterator(obj) {
    var okeys = obj ? Object.keys(obj) : [];
    var i = -1;
    var len = okeys.length;
    return function next() {
        var key = okeys[++i];
        if (key === '__proto__') {
            return next();
        }
        return i < len ? { value: obj[key], key } : null;
    };
}

function createIterator(coll) {
    if ((0, _isArrayLike2.default)(coll)) {
        return createArrayIterator(coll);
    }

    var iterator = (0, _getIterator2.default)(coll);
    return iterator ? createES2015Iterator(iterator) : createObjectIterator(coll);
}
module.exports = exports.default;

/***/ }),

/***/ 63491:
/***/ ((module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports["default"] = once;
function once(fn) {
    function wrapper(...args) {
        if (fn === null) return;
        var callFn = fn;
        fn = null;
        callFn.apply(this, args);
    }
    Object.assign(wrapper, fn);
    return wrapper;
}
module.exports = exports.default;

/***/ }),

/***/ 64085:
/***/ ((module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports["default"] = onlyOnce;
function onlyOnce(fn) {
    return function (...args) {
        if (fn === null) throw new Error("Callback was already called.");
        var callFn = fn;
        fn = null;
        callFn.apply(this, args);
    };
}
module.exports = exports.default;

/***/ }),

/***/ 8149:
/***/ ((module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
    value: true
}));

var _isArrayLike = __nccwpck_require__(53078);

var _isArrayLike2 = _interopRequireDefault(_isArrayLike);

var _wrapAsync = __nccwpck_require__(76212);

var _wrapAsync2 = _interopRequireDefault(_wrapAsync);

var _awaitify = __nccwpck_require__(5534);

var _awaitify2 = _interopRequireDefault(_awaitify);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports["default"] = (0, _awaitify2.default)((eachfn, tasks, callback) => {
    var results = (0, _isArrayLike2.default)(tasks) ? [] : {};

    eachfn(tasks, (task, key, taskCb) => {
        (0, _wrapAsync2.default)(task)((err, ...result) => {
            if (result.length < 2) {
                [result] = result;
            }
            results[key] = result;
            taskCb(err);
        });
    }, err => callback(err, results));
}, 3);
module.exports = exports.default;

/***/ }),

/***/ 63787:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.fallback = fallback;
exports.wrap = wrap;
/* istanbul ignore file */

var hasQueueMicrotask = exports.hasQueueMicrotask = typeof queueMicrotask === 'function' && queueMicrotask;
var hasSetImmediate = exports.hasSetImmediate = typeof setImmediate === 'function' && setImmediate;
var hasNextTick = exports.hasNextTick = typeof process === 'object' && typeof process.nextTick === 'function';

function fallback(fn) {
    setTimeout(fn, 0);
}

function wrap(defer) {
    return (fn, ...args) => defer(() => fn(...args));
}

var _defer;

if (hasQueueMicrotask) {
    _defer = queueMicrotask;
} else if (hasSetImmediate) {
    _defer = setImmediate;
} else if (hasNextTick) {
    _defer = process.nextTick;
} else {
    _defer = fallback;
}

exports["default"] = wrap(_defer);

/***/ }),

/***/ 42914:
/***/ ((module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports["default"] = _withoutIndex;
function _withoutIndex(iteratee) {
    return (value, index, callback) => iteratee(value, callback);
}
module.exports = exports.default;

/***/ }),

/***/ 76212:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.isAsyncIterable = exports.isAsyncGenerator = exports.isAsync = undefined;

var _asyncify = __nccwpck_require__(38300);

var _asyncify2 = _interopRequireDefault(_asyncify);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function isAsync(fn) {
    return fn[Symbol.toStringTag] === 'AsyncFunction';
}

function isAsyncGenerator(fn) {
    return fn[Symbol.toStringTag] === 'AsyncGenerator';
}

function isAsyncIterable(obj) {
    return typeof obj[Symbol.asyncIterator] === 'function';
}

function wrapAsync(asyncFn) {
    if (typeof asyncFn !== 'function') throw new Error('expected a function');
    return isAsync(asyncFn) ? (0, _asyncify2.default)(asyncFn) : asyncFn;
}

exports["default"] = wrapAsync;
exports.isAsync = isAsync;
exports.isAsyncGenerator = isAsyncGenerator;
exports.isAsyncIterable = isAsyncIterable;

/***/ }),

/***/ 58719:
/***/ ((module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports["default"] = series;

var _parallel2 = __nccwpck_require__(8149);

var _parallel3 = _interopRequireDefault(_parallel2);

var _eachOfSeries = __nccwpck_require__(5283);

var _eachOfSeries2 = _interopRequireDefault(_eachOfSeries);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Run the functions in the `tasks` collection in series, each one running once
 * the previous function has completed. If any functions in the series pass an
 * error to its callback, no more functions are run, and `callback` is
 * immediately called with the value of the error. Otherwise, `callback`
 * receives an array of results when `tasks` have completed.
 *
 * It is also possible to use an object instead of an array. Each property will
 * be run as a function, and the results will be passed to the final `callback`
 * as an object instead of an array. This can be a more readable way of handling
 *  results from {@link async.series}.
 *
 * **Note** that while many implementations preserve the order of object
 * properties, the [ECMAScript Language Specification](http://www.ecma-international.org/ecma-262/5.1/#sec-8.6)
 * explicitly states that
 *
 * > The mechanics and order of enumerating the properties is not specified.
 *
 * So if you rely on the order in which your series of functions are executed,
 * and want this to work on all platforms, consider using an array.
 *
 * @name series
 * @static
 * @memberOf module:ControlFlow
 * @method
 * @category Control Flow
 * @param {Array|Iterable|AsyncIterable|Object} tasks - A collection containing
 * [async functions]{@link AsyncFunction} to run in series.
 * Each function can complete with any number of optional `result` values.
 * @param {Function} [callback] - An optional callback to run once all the
 * functions have completed. This function gets a results array (or object)
 * containing all the result arguments passed to the `task` callbacks. Invoked
 * with (err, result).
 * @return {Promise} a promise, if no callback is passed
 * @example
 *
 * //Using Callbacks
 * async.series([
 *     function(callback) {
 *         setTimeout(function() {
 *             // do some async task
 *             callback(null, 'one');
 *         }, 200);
 *     },
 *     function(callback) {
 *         setTimeout(function() {
 *             // then do another async task
 *             callback(null, 'two');
 *         }, 100);
 *     }
 * ], function(err, results) {
 *     console.log(results);
 *     // results is equal to ['one','two']
 * });
 *
 * // an example using objects instead of arrays
 * async.series({
 *     one: function(callback) {
 *         setTimeout(function() {
 *             // do some async task
 *             callback(null, 1);
 *         }, 200);
 *     },
 *     two: function(callback) {
 *         setTimeout(function() {
 *             // then do another async task
 *             callback(null, 2);
 *         }, 100);
 *     }
 * }, function(err, results) {
 *     console.log(results);
 *     // results is equal to: { one: 1, two: 2 }
 * });
 *
 * //Using Promises
 * async.series([
 *     function(callback) {
 *         setTimeout(function() {
 *             callback(null, 'one');
 *         }, 200);
 *     },
 *     function(callback) {
 *         setTimeout(function() {
 *             callback(null, 'two');
 *         }, 100);
 *     }
 * ]).then(results => {
 *     console.log(results);
 *     // results is equal to ['one','two']
 * }).catch(err => {
 *     console.log(err);
 * });
 *
 * // an example using an object instead of an array
 * async.series({
 *     one: function(callback) {
 *         setTimeout(function() {
 *             // do some async task
 *             callback(null, 1);
 *         }, 200);
 *     },
 *     two: function(callback) {
 *         setTimeout(function() {
 *             // then do another async task
 *             callback(null, 2);
 *         }, 100);
 *     }
 * }).then(results => {
 *     console.log(results);
 *     // results is equal to: { one: 1, two: 2 }
 * }).catch(err => {
 *     console.log(err);
 * });
 *
 * //Using async/await
 * async () => {
 *     try {
 *         let results = await async.series([
 *             function(callback) {
 *                 setTimeout(function() {
 *                     // do some async task
 *                     callback(null, 'one');
 *                 }, 200);
 *             },
 *             function(callback) {
 *                 setTimeout(function() {
 *                     // then do another async task
 *                     callback(null, 'two');
 *                 }, 100);
 *             }
 *         ]);
 *         console.log(results);
 *         // results is equal to ['one','two']
 *     }
 *     catch (err) {
 *         console.log(err);
 *     }
 * }
 *
 * // an example using an object instead of an array
 * async () => {
 *     try {
 *         let results = await async.parallel({
 *             one: function(callback) {
 *                 setTimeout(function() {
 *                     // do some async task
 *                     callback(null, 1);
 *                 }, 200);
 *             },
 *            two: function(callback) {
 *                 setTimeout(function() {
 *                     // then do another async task
 *                     callback(null, 2);
 *                 }, 100);
 *            }
 *         });
 *         console.log(results);
 *         // results is equal to: { one: 1, two: 2 }
 *     }
 *     catch (err) {
 *         console.log(err);
 *     }
 * }
 *
 */
function series(tasks, callback) {
    return (0, _parallel3.default)(_eachOfSeries2.default, tasks, callback);
}
module.exports = exports.default;

/***/ }),

/***/ 45675:
/***/ ((module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const defaults_js_1 = __nccwpck_require__(43981);
const proxies_js_1 = __nccwpck_require__(48579);
const proxyBundle = {
    ca: proxies_js_1.proxies,
};
const profiles = {
    ca: [...defaults_js_1.defaults, ...proxies_js_1.proxies],
};
module.exports = profiles;
module.exports.proxyBundle = proxyBundle;
module.exports["default"] = profiles;


/***/ }),

/***/ 43981:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.defaults = void 0;
/**
 * CA Certificates for **Amazon RDS** (2024)
 *
 * - https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/UsingWithRDS.SSL.html
 * - https://docs.amazonaws.cn/en_us/AmazonRDS/latest/AuroraUserGuide/UsingWithRDS.SSL.html
 * - https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/aurora-serverless.html#aurora-serverless.tls
 */
exports.defaults = [
    '-----BEGIN CERTIFICATE-----\n' +
        'MIIEEjCCAvqgAwIBAgIJAM2ZN/+nPi27MA0GCSqGSIb3DQEBCwUAMIGVMQswCQYD\n' +
        'VQQGEwJVUzEQMA4GA1UEBwwHU2VhdHRsZTETMBEGA1UECAwKV2FzaGluZ3RvbjEi\n' +
        'MCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywgSW5jLjETMBEGA1UECwwKQW1h\n' +
        'em9uIFJEUzEmMCQGA1UEAwwdQW1hem9uIFJEUyBhZi1zb3V0aC0xIFJvb3QgQ0Ew\n' +
        'HhcNMTkxMDI4MTgwNTU4WhcNMjQxMDI2MTgwNTU4WjCBlTELMAkGA1UEBhMCVVMx\n' +
        'EDAOBgNVBAcMB1NlYXR0bGUxEzARBgNVBAgMCldhc2hpbmd0b24xIjAgBgNVBAoM\n' +
        'GUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4xEzARBgNVBAsMCkFtYXpvbiBSRFMx\n' +
        'JjAkBgNVBAMMHUFtYXpvbiBSRFMgYWYtc291dGgtMSBSb290IENBMIIBIjANBgkq\n' +
        'hkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAwR2351uPMZaJk2gMGT+1sk8HE9MQh2rc\n' +
        '/sCnbxGn2p1c7Oi9aBbd/GiFijeJb2BXvHU+TOq3d3Jjqepq8tapXVt4ojbTJNyC\n' +
        'J5E7r7KjTktKdLxtBE1MK25aY+IRJjtdU6vG3KiPKUT1naO3xs3yt0F76WVuFivd\n' +
        '9OHv2a+KHvPkRUWIxpmAHuMY9SIIMmEZtVE7YZGx5ah0iO4JzItHcbVR0y0PBH55\n' +
        'arpFBddpIVHCacp1FUPxSEWkOpI7q0AaU4xfX0fe1BV5HZYRKpBOIp1TtZWvJD+X\n' +
        'jGUtL1BEsT5vN5g9MkqdtYrC+3SNpAk4VtpvJrdjraI/hhvfeXNnAwIDAQABo2Mw\n' +
        'YTAOBgNVHQ8BAf8EBAMCAQYwDwYDVR0TAQH/BAUwAwEB/zAdBgNVHQ4EFgQUEEi/\n' +
        'WWMcBJsoGXg+EZwkQ0MscZQwHwYDVR0jBBgwFoAUEEi/WWMcBJsoGXg+EZwkQ0Ms\n' +
        'cZQwDQYJKoZIhvcNAQELBQADggEBAGDZ5js5Pc/gC58LJrwMPXFhJDBS8QuDm23C\n' +
        'FFUdlqucskwOS3907ErK1ZkmVJCIqFLArHqskFXMAkRZ2PNR7RjWLqBs+0znG5yH\n' +
        'hRKb4DXzhUFQ18UBRcvT6V6zN97HTRsEEaNhM/7k8YLe7P8vfNZ28VIoJIGGgv9D\n' +
        'wQBBvkxQ71oOmAG0AwaGD0ORGUfbYry9Dz4a4IcUsZyRWRMADixgrFv6VuETp26s\n' +
        '/+z+iqNaGWlELBKh3iQCT6Y/1UnkPLO42bxrCSyOvshdkYN58Q2gMTE1SVTqyo8G\n' +
        'Lw8lLAz9bnvUSgHzB3jRrSx6ggF/WRMRYlR++y6LXP4SAsSAaC0=\n' +
        '-----END CERTIFICATE-----\n',
    '-----BEGIN CERTIFICATE-----\n' +
        'MIIEEjCCAvqgAwIBAgIJAJYM4LxvTZA6MA0GCSqGSIb3DQEBCwUAMIGVMQswCQYD\n' +
        'VQQGEwJVUzEQMA4GA1UEBwwHU2VhdHRsZTETMBEGA1UECAwKV2FzaGluZ3RvbjEi\n' +
        'MCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywgSW5jLjETMBEGA1UECwwKQW1h\n' +
        'em9uIFJEUzEmMCQGA1UEAwwdQW1hem9uIFJEUyBldS1zb3V0aC0xIFJvb3QgQ0Ew\n' +
        'HhcNMTkxMDMwMjAyMDM2WhcNMjQxMDI4MjAyMDM2WjCBlTELMAkGA1UEBhMCVVMx\n' +
        'EDAOBgNVBAcMB1NlYXR0bGUxEzARBgNVBAgMCldhc2hpbmd0b24xIjAgBgNVBAoM\n' +
        'GUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4xEzARBgNVBAsMCkFtYXpvbiBSRFMx\n' +
        'JjAkBgNVBAMMHUFtYXpvbiBSRFMgZXUtc291dGgtMSBSb290IENBMIIBIjANBgkq\n' +
        'hkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAqM921jXCXeqpRNCS9CBPOe5N7gMaEt+D\n' +
        's5uR3riZbqzRlHGiF1jZihkXfHAIQewDwy+Yz+Oec1aEZCQMhUHxZJPusuX0cJfj\n' +
        'b+UluFqHIijL2TfXJ3D0PVLLoNTQJZ8+GAPECyojAaNuoHbdVqxhOcznMsXIXVFq\n' +
        'yVLKDGvyKkJjai/iSPDrQMXufg3kWt0ISjNLvsG5IFXgP4gttsM8i0yvRd4QcHoo\n' +
        'DjvH7V3cS+CQqW5SnDrGnHToB0RLskE1ET+oNOfeN9PWOxQprMOX/zmJhnJQlTqD\n' +
        'QP7jcf7SddxrKFjuziFiouskJJyNDsMjt1Lf60+oHZhed2ogTeifGwIDAQABo2Mw\n' +
        'YTAOBgNVHQ8BAf8EBAMCAQYwDwYDVR0TAQH/BAUwAwEB/zAdBgNVHQ4EFgQUFBAF\n' +
        'cgJe/BBuZiGeZ8STfpkgRYQwHwYDVR0jBBgwFoAUFBAFcgJe/BBuZiGeZ8STfpkg\n' +
        'RYQwDQYJKoZIhvcNAQELBQADggEBAKAYUtlvDuX2UpZW9i1QgsjFuy/ErbW0dLHU\n' +
        'e/IcFtju2z6RLZ+uF+5A8Kme7IKG1hgt8s+w9TRVQS/7ukQzoK3TaN6XKXRosjtc\n' +
        'o9Rm4gYWM8bmglzY1TPNaiI4HC7546hSwJhubjN0bXCuj/0sHD6w2DkiGuwKNAef\n' +
        'yTu5vZhPkeNyXLykxkzz7bNp2/PtMBnzIp+WpS7uUDmWyScGPohKMq5PqvL59z+L\n' +
        'ZI3CYeMZrJ5VpXUg3fNNIz/83N3G0sk7wr0ohs/kHTP7xPOYB0zD7Ku4HA0Q9Swf\n' +
        'WX0qr6UQgTPMjfYDLffI7aEId0gxKw1eGYc6Cq5JAZ3ipi/cBFc=\n' +
        '-----END CERTIFICATE-----\n',
    '-----BEGIN CERTIFICATE-----\n' +
        'MIIEEjCCAvqgAwIBAgIJANew34ehz5l8MA0GCSqGSIb3DQEBCwUAMIGVMQswCQYD\n' +
        'VQQGEwJVUzEQMA4GA1UEBwwHU2VhdHRsZTETMBEGA1UECAwKV2FzaGluZ3RvbjEi\n' +
        'MCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywgSW5jLjETMBEGA1UECwwKQW1h\n' +
        'em9uIFJEUzEmMCQGA1UEAwwdQW1hem9uIFJEUyBtZS1zb3V0aC0xIFJvb3QgQ0Ew\n' +
        'HhcNMTkwNTEwMjE0ODI3WhcNMjQwNTA4MjE0ODI3WjCBlTELMAkGA1UEBhMCVVMx\n' +
        'EDAOBgNVBAcMB1NlYXR0bGUxEzARBgNVBAgMCldhc2hpbmd0b24xIjAgBgNVBAoM\n' +
        'GUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4xEzARBgNVBAsMCkFtYXpvbiBSRFMx\n' +
        'JjAkBgNVBAMMHUFtYXpvbiBSRFMgbWUtc291dGgtMSBSb290IENBMIIBIjANBgkq\n' +
        'hkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAp7BYV88MukcY+rq0r79+C8UzkT30fEfT\n' +
        'aPXbx1d6M7uheGN4FMaoYmL+JE1NZPaMRIPTHhFtLSdPccInvenRDIatcXX+jgOk\n' +
        'UA6lnHQ98pwN0pfDUyz/Vph4jBR9LcVkBbe0zdoKKp+HGbMPRU0N2yNrog9gM5O8\n' +
        'gkU/3O2csJ/OFQNnj4c2NQloGMUpEmedwJMOyQQfcUyt9CvZDfIPNnheUS29jGSw\n' +
        'ERpJe/AENu8Pxyc72jaXQuD+FEi2Ck6lBkSlWYQFhTottAeGvVFNCzKszCntrtqd\n' +
        'rdYUwurYsLTXDHv9nW2hfDUQa0mhXf9gNDOBIVAZugR9NqNRNyYLHQIDAQABo2Mw\n' +
        'YTAOBgNVHQ8BAf8EBAMCAQYwDwYDVR0TAQH/BAUwAwEB/zAdBgNVHQ4EFgQU54cf\n' +
        'DjgwBx4ycBH8+/r8WXdaiqYwHwYDVR0jBBgwFoAU54cfDjgwBx4ycBH8+/r8WXda\n' +
        'iqYwDQYJKoZIhvcNAQELBQADggEBAIIMTSPx/dR7jlcxggr+O6OyY49Rlap2laKA\n' +
        'eC/XI4ySP3vQkIFlP822U9Kh8a9s46eR0uiwV4AGLabcu0iKYfXjPkIprVCqeXV7\n' +
        'ny9oDtrbflyj7NcGdZLvuzSwgl9SYTJp7PVCZtZutsPYlbJrBPHwFABvAkMvRtDB\n' +
        'hitIg4AESDGPoCl94sYHpfDfjpUDMSrAMDUyO6DyBdZH5ryRMAs3lGtsmkkNUrso\n' +
        'aTW6R05681Z0mvkRdb+cdXtKOSuDZPoe2wJJIaz3IlNQNSrB5TImMYgmt6iAsFhv\n' +
        '3vfTSTKrZDNTJn4ybG6pq1zWExoXsktZPylJly6R3RBwV6nwqBM=\n' +
        '-----END CERTIFICATE-----\n',
    '-----BEGIN CERTIFICATE-----\n' +
        'MIIEBjCCAu6gAwIBAgIJAMc0ZzaSUK51MA0GCSqGSIb3DQEBCwUAMIGPMQswCQYD\n' +
        'VQQGEwJVUzEQMA4GA1UEBwwHU2VhdHRsZTETMBEGA1UECAwKV2FzaGluZ3RvbjEi\n' +
        'MCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywgSW5jLjETMBEGA1UECwwKQW1h\n' +
        'em9uIFJEUzEgMB4GA1UEAwwXQW1hem9uIFJEUyBSb290IDIwMTkgQ0EwHhcNMTkw\n' +
        'ODIyMTcwODUwWhcNMjQwODIyMTcwODUwWjCBjzELMAkGA1UEBhMCVVMxEDAOBgNV\n' +
        'BAcMB1NlYXR0bGUxEzARBgNVBAgMCldhc2hpbmd0b24xIjAgBgNVBAoMGUFtYXpv\n' +
        'biBXZWIgU2VydmljZXMsIEluYy4xEzARBgNVBAsMCkFtYXpvbiBSRFMxIDAeBgNV\n' +
        'BAMMF0FtYXpvbiBSRFMgUm9vdCAyMDE5IENBMIIBIjANBgkqhkiG9w0BAQEFAAOC\n' +
        'AQ8AMIIBCgKCAQEArXnF/E6/Qh+ku3hQTSKPMhQQlCpoWvnIthzX6MK3p5a0eXKZ\n' +
        'oWIjYcNNG6UwJjp4fUXl6glp53Jobn+tWNX88dNH2n8DVbppSwScVE2LpuL+94vY\n' +
        '0EYE/XxN7svKea8YvlrqkUBKyxLxTjh+U/KrGOaHxz9v0l6ZNlDbuaZw3qIWdD/I\n' +
        '6aNbGeRUVtpM6P+bWIoxVl/caQylQS6CEYUk+CpVyJSkopwJlzXT07tMoDL5WgX9\n' +
        'O08KVgDNz9qP/IGtAcRduRcNioH3E9v981QO1zt/Gpb2f8NqAjUUCUZzOnij6mx9\n' +
        'McZ+9cWX88CRzR0vQODWuZscgI08NvM69Fn2SQIDAQABo2MwYTAOBgNVHQ8BAf8E\n' +
        'BAMCAQYwDwYDVR0TAQH/BAUwAwEB/zAdBgNVHQ4EFgQUc19g2LzLA5j0Kxc0LjZa\n' +
        'pmD/vB8wHwYDVR0jBBgwFoAUc19g2LzLA5j0Kxc0LjZapmD/vB8wDQYJKoZIhvcN\n' +
        'AQELBQADggEBAHAG7WTmyjzPRIM85rVj+fWHsLIvqpw6DObIjMWokpliCeMINZFV\n' +
        'ynfgBKsf1ExwbvJNzYFXW6dihnguDG9VMPpi2up/ctQTN8tm9nDKOy08uNZoofMc\n' +
        'NUZxKCEkVKZv+IL4oHoeayt8egtv3ujJM6V14AstMQ6SwvwvA93EP/Ug2e4WAXHu\n' +
        'cbI1NAbUgVDqp+DRdfvZkgYKryjTWd/0+1fS8X1bBZVWzl7eirNVnHbSH2ZDpNuY\n' +
        '0SBd8dj5F6ld3t58ydZbrTHze7JJOd8ijySAp4/kiu9UfZWuTPABzDa/DSdz9Dk/\n' +
        'zPW4CXXvhLmE02TA9/HeCw3KEHIwicNuEfw=\n' +
        '-----END CERTIFICATE-----\n',
    '-----BEGIN CERTIFICATE-----\n' +
        'MIIEEDCCAvigAwIBAgIJAKFMXyltvuRdMA0GCSqGSIb3DQEBCwUAMIGUMQswCQYD\n' +
        'VQQGEwJVUzEQMA4GA1UEBwwHU2VhdHRsZTETMBEGA1UECAwKV2FzaGluZ3RvbjEi\n' +
        'MCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywgSW5jLjETMBEGA1UECwwKQW1h\n' +
        'em9uIFJEUzElMCMGA1UEAwwcQW1hem9uIFJEUyBCZXRhIFJvb3QgMjAxOSBDQTAe\n' +
        'Fw0xOTA4MTkxNzM4MjZaFw0yNDA4MTkxNzM4MjZaMIGUMQswCQYDVQQGEwJVUzEQ\n' +
        'MA4GA1UEBwwHU2VhdHRsZTETMBEGA1UECAwKV2FzaGluZ3RvbjEiMCAGA1UECgwZ\n' +
        'QW1hem9uIFdlYiBTZXJ2aWNlcywgSW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzEl\n' +
        'MCMGA1UEAwwcQW1hem9uIFJEUyBCZXRhIFJvb3QgMjAxOSBDQTCCASIwDQYJKoZI\n' +
        'hvcNAQEBBQADggEPADCCAQoCggEBAMkZdnIH9ndatGAcFo+DppGJ1HUt4x+zeO+0\n' +
        'ZZ29m0sfGetVulmTlv2d5b66e+QXZFWpcPQMouSxxYTW08TbrQiZngKr40JNXftA\n' +
        'atvzBqIImD4II0ZX5UEVj2h98qe/ypW5xaDN7fEa5e8FkYB1TEemPaWIbNXqchcL\n' +
        'tV7IJPr3Cd7Z5gZJlmujIVDPpMuSiNaal9/6nT9oqN+JSM1fx5SzrU5ssg1Vp1vv\n' +
        '5Xab64uOg7wCJRB9R2GC9XD04odX6VcxUAGrZo6LR64ZSifupo3l+R5sVOc5i8NH\n' +
        'skdboTzU9H7+oSdqoAyhIU717PcqeDum23DYlPE2nGBWckE+eT8CAwEAAaNjMGEw\n' +
        'DgYDVR0PAQH/BAQDAgEGMA8GA1UdEwEB/wQFMAMBAf8wHQYDVR0OBBYEFK2hDBWl\n' +
        'sbHzt/EHd0QYOooqcFPhMB8GA1UdIwQYMBaAFK2hDBWlsbHzt/EHd0QYOooqcFPh\n' +
        'MA0GCSqGSIb3DQEBCwUAA4IBAQAO/718k8EnOqJDx6wweUscGTGL/QdKXUzTVRAx\n' +
        'JUsjNUv49mH2HQVEW7oxszfH6cPCaupNAddMhQc4C/af6GHX8HnqfPDk27/yBQI+\n' +
        'yBBvIanGgxv9c9wBbmcIaCEWJcsLp3HzXSYHmjiqkViXwCpYfkoV3Ns2m8bp+KCO\n' +
        'y9XmcCKRaXkt237qmoxoh2sGmBHk2UlQtOsMC0aUQ4d7teAJG0q6pbyZEiPyKZY1\n' +
        'XR/UVxMJL0Q4iVpcRS1kaNCMfqS2smbLJeNdsan8pkw1dvPhcaVTb7CvjhJtjztF\n' +
        'YfDzAI5794qMlWxwilKMmUvDlPPOTen8NNHkLwWvyFCH7Doh\n' +
        '-----END CERTIFICATE-----\n',
    '-----BEGIN CERTIFICATE-----\n' +
        'MIIEFjCCAv6gAwIBAgIJAMzYZJ+R9NBVMA0GCSqGSIb3DQEBCwUAMIGXMQswCQYD\n' +
        'VQQGEwJVUzEQMA4GA1UEBwwHU2VhdHRsZTETMBEGA1UECAwKV2FzaGluZ3RvbjEi\n' +
        'MCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywgSW5jLjETMBEGA1UECwwKQW1h\n' +
        'em9uIFJEUzEoMCYGA1UEAwwfQW1hem9uIFJEUyBQcmV2aWV3IFJvb3QgMjAxOSBD\n' +
        'QTAeFw0xOTA4MjEyMjI5NDlaFw0yNDA4MjEyMjI5NDlaMIGXMQswCQYDVQQGEwJV\n' +
        'UzEQMA4GA1UEBwwHU2VhdHRsZTETMBEGA1UECAwKV2FzaGluZ3RvbjEiMCAGA1UE\n' +
        'CgwZQW1hem9uIFdlYiBTZXJ2aWNlcywgSW5jLjETMBEGA1UECwwKQW1hem9uIFJE\n' +
        'UzEoMCYGA1UEAwwfQW1hem9uIFJEUyBQcmV2aWV3IFJvb3QgMjAxOSBDQTCCASIw\n' +
        'DQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBAM7kkS6vjgKKQTPynC2NjdN5aPPV\n' +
        'O71G0JJS/2ARVBVJd93JLiGovVJilfWYfwZCs4gTRSSjrUD4D4HyqCd6A+eEEtJq\n' +
        'M0DEC7i0dC+9WNTsPszuB206Jy2IUmxZMIKJAA1NHSbIMjB+b6/JhbSUi7nKdbR/\n' +
        'brj83bF+RoSA+ogrgX7mQbxhmFcoZN9OGaJgYKsKWUt5Wqv627KkGodUK8mDepgD\n' +
        'S3ZfoRQRx3iceETpcmHJvaIge6+vyDX3d9Z22jmvQ4AKv3py2CmU2UwuhOltFDwB\n' +
        '0ddtb39vgwrJxaGfiMRHpEP1DfNLWHAnA69/pgZPwIggidS+iBPUhgucMp8CAwEA\n' +
        'AaNjMGEwDgYDVR0PAQH/BAQDAgEGMA8GA1UdEwEB/wQFMAMBAf8wHQYDVR0OBBYE\n' +
        'FGnTGpQuQ2H/DZlXMQijZEhjs7TdMB8GA1UdIwQYMBaAFGnTGpQuQ2H/DZlXMQij\n' +
        'ZEhjs7TdMA0GCSqGSIb3DQEBCwUAA4IBAQC3xz1vQvcXAfpcZlngiRWeqU8zQAMQ\n' +
        'LZPCFNv7PVk4pmqX+ZiIRo4f9Zy7TrOVcboCnqmP/b/mNq0gVF4O+88jwXJZD+f8\n' +
        '/RnABMZcnGU+vK0YmxsAtYU6TIb1uhRFmbF8K80HHbj9vSjBGIQdPCbvmR2zY6VJ\n' +
        'BYM+w9U9hp6H4DVMLKXPc1bFlKA5OBTgUtgkDibWJKFOEPW3UOYwp9uq6pFoN0AO\n' +
        'xMTldqWFsOF3bJIlvOY0c/1EFZXu3Ns6/oCP//Ap9vumldYMUZWmbK+gK33FPOXV\n' +
        '8BQ6jNC29icv7lLDpRPwjibJBXX+peDR5UK4FdYcswWEB1Tix5X8dYu6\n' +
        '-----END CERTIFICATE-----\n',
    '-----BEGIN CERTIFICATE-----\n' +
        'MIIECTCCAvGgAwIBAgICEAAwDQYJKoZIhvcNAQELBQAwgZUxCzAJBgNVBAYTAlVT\n' +
        'MRAwDgYDVQQHDAdTZWF0dGxlMRMwEQYDVQQIDApXYXNoaW5ndG9uMSIwIAYDVQQK\n' +
        'DBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMuMRMwEQYDVQQLDApBbWF6b24gUkRT\n' +
        'MSYwJAYDVQQDDB1BbWF6b24gUkRTIGFmLXNvdXRoLTEgUm9vdCBDQTAeFw0xOTEw\n' +
        'MjgxODA2NTNaFw0yNDEwMjgxODA2NTNaMIGQMQswCQYDVQQGEwJVUzETMBEGA1UE\n' +
        'CAwKV2FzaGluZ3RvbjEQMA4GA1UEBwwHU2VhdHRsZTEiMCAGA1UECgwZQW1hem9u\n' +
        'IFdlYiBTZXJ2aWNlcywgSW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzEhMB8GA1UE\n' +
        'AwwYQW1hem9uIFJEUyBhZi1zb3V0aC0xIENBMIIBIjANBgkqhkiG9w0BAQEFAAOC\n' +
        'AQ8AMIIBCgKCAQEAvtV1OqmFa8zCVQSKOvPUJERLVFtd4rZmDpImc5rIoeBk7w/P\n' +
        '9lcKUJjO8R/w1a2lJXx3oQ81tiY0Piw6TpT62YWVRMWrOw8+Vxq1dNaDSFp9I8d0\n' +
        'UHillSSbOk6FOrPDp+R6AwbGFqUDebbN5LFFoDKbhNmH1BVS0a6YNKpGigLRqhka\n' +
        'cClPslWtPqtjbaP3Jbxl26zWzLo7OtZl98dR225pq8aApNBwmtgA7Gh60HK/cX0t\n' +
        '32W94n8D+GKSg6R4MKredVFqRTi9hCCNUu0sxYPoELuM+mHiqB5NPjtm92EzCWs+\n' +
        '+vgWhMc6GxG+82QSWx1Vj8sgLqtE/vLrWddf5QIDAQABo2YwZDAOBgNVHQ8BAf8E\n' +
        'BAMCAQYwEgYDVR0TAQH/BAgwBgEB/wIBADAdBgNVHQ4EFgQUuLB4gYVJrSKJj/Gz\n' +
        'pqc6yeA+RcAwHwYDVR0jBBgwFoAUEEi/WWMcBJsoGXg+EZwkQ0MscZQwDQYJKoZI\n' +
        'hvcNAQELBQADggEBABauYOZxUhe9/RhzGJ8MsWCz8eKcyDVd4FCnY6Qh+9wcmYNT\n' +
        'LtnD88LACtJKb/b81qYzcB0Em6+zVJ3Z9jznfr6buItE6es9wAoja22Xgv44BTHL\n' +
        'rimbgMwpTt3uEMXDffaS0Ww6YWb3pSE0XYI2ISMWz+xRERRf+QqktSaL39zuiaW5\n' +
        'tfZMre+YhohRa/F0ZQl3RCd6yFcLx4UoSPqQsUl97WhYzwAxZZfwvLJXOc4ATt3u\n' +
        'VlCUylNDkaZztDJc/yN5XQoK9W5nOt2cLu513MGYKbuarQr8f+gYU8S+qOyuSRSP\n' +
        'NRITzwCRVnsJE+2JmcRInn/NcanB7uOGqTvJ9+c=\n' +
        '-----END CERTIFICATE-----\n',
    '-----BEGIN CERTIFICATE-----\n' +
        'MIIECTCCAvGgAwIBAgICEAAwDQYJKoZIhvcNAQELBQAwgZUxCzAJBgNVBAYTAlVT\n' +
        'MRAwDgYDVQQHDAdTZWF0dGxlMRMwEQYDVQQIDApXYXNoaW5ndG9uMSIwIAYDVQQK\n' +
        'DBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMuMRMwEQYDVQQLDApBbWF6b24gUkRT\n' +
        'MSYwJAYDVQQDDB1BbWF6b24gUkRTIGV1LXNvdXRoLTEgUm9vdCBDQTAeFw0xOTEw\n' +
        'MzAyMDIxMzBaFw0yNDEwMzAyMDIxMzBaMIGQMQswCQYDVQQGEwJVUzETMBEGA1UE\n' +
        'CAwKV2FzaGluZ3RvbjEQMA4GA1UEBwwHU2VhdHRsZTEiMCAGA1UECgwZQW1hem9u\n' +
        'IFdlYiBTZXJ2aWNlcywgSW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzEhMB8GA1UE\n' +
        'AwwYQW1hem9uIFJEUyBldS1zb3V0aC0xIENBMIIBIjANBgkqhkiG9w0BAQEFAAOC\n' +
        'AQ8AMIIBCgKCAQEAtEyjYcajx6xImJn8Vz1zjdmL4ANPgQXwF7+tF7xccmNAZETb\n' +
        'bzb3I9i5fZlmrRaVznX+9biXVaGxYzIUIR3huQ3Q283KsDYnVuGa3mk690vhvJbB\n' +
        'QIPgKa5mVwJppnuJm78KqaSpi0vxyCPe3h8h6LLFawVyWrYNZ4okli1/U582eef8\n' +
        'RzJp/Ear3KgHOLIiCdPDF0rjOdCG1MOlDLixVnPn9IYOciqO+VivXBg+jtfc5J+L\n' +
        'AaPm0/Yx4uELt1tkbWkm4BvTU/gBOODnYziITZM0l6Fgwvbwgq5duAtKW+h031lC\n' +
        '37rEvrclqcp4wrsUYcLAWX79ZyKIlRxcAdvEhQIDAQABo2YwZDAOBgNVHQ8BAf8E\n' +
        'BAMCAQYwEgYDVR0TAQH/BAgwBgEB/wIBADAdBgNVHQ4EFgQU7zPyc0azQxnBCe7D\n' +
        'b9KAadH1QSEwHwYDVR0jBBgwFoAUFBAFcgJe/BBuZiGeZ8STfpkgRYQwDQYJKoZI\n' +
        'hvcNAQELBQADggEBAFGaNiYxg7yC/xauXPlaqLCtwbm2dKyK9nIFbF/7be8mk7Q3\n' +
        'MOA0of1vGHPLVQLr6bJJpD9MAbUcm4cPAwWaxwcNpxOjYOFDaq10PCK4eRAxZWwF\n' +
        'NJRIRmGsl8NEsMNTMCy8X+Kyw5EzH4vWFl5Uf2bGKOeFg0zt43jWQVOX6C+aL3Cd\n' +
        'pRS5MhmYpxMG8irrNOxf4NVFE2zpJOCm3bn0STLhkDcV/ww4zMzObTJhiIb5wSWn\n' +
        'EXKKWhUXuRt7A2y1KJtXpTbSRHQxE++69Go1tWhXtRiULCJtf7wF2Ksm0RR/AdXT\n' +
        '1uR1vKyH5KBJPX3ppYkQDukoHTFR0CpB+G84NLo=\n' +
        '-----END CERTIFICATE-----\n',
    '-----BEGIN CERTIFICATE-----\n' +
        'MIIECTCCAvGgAwIBAgICEAAwDQYJKoZIhvcNAQELBQAwgZUxCzAJBgNVBAYTAlVT\n' +
        'MRAwDgYDVQQHDAdTZWF0dGxlMRMwEQYDVQQIDApXYXNoaW5ndG9uMSIwIAYDVQQK\n' +
        'DBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMuMRMwEQYDVQQLDApBbWF6b24gUkRT\n' +
        'MSYwJAYDVQQDDB1BbWF6b24gUkRTIG1lLXNvdXRoLTEgUm9vdCBDQTAeFw0xOTA1\n' +
        'MTAyMTU4NDNaFw0yNTA2MDExMjAwMDBaMIGQMQswCQYDVQQGEwJVUzETMBEGA1UE\n' +
        'CAwKV2FzaGluZ3RvbjEQMA4GA1UEBwwHU2VhdHRsZTEiMCAGA1UECgwZQW1hem9u\n' +
        'IFdlYiBTZXJ2aWNlcywgSW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzEhMB8GA1UE\n' +
        'AwwYQW1hem9uIFJEUyBtZS1zb3V0aC0xIENBMIIBIjANBgkqhkiG9w0BAQEFAAOC\n' +
        'AQ8AMIIBCgKCAQEAudOYPZH+ihJAo6hNYMB5izPVBe3TYhnZm8+X3IoaaYiKtsp1\n' +
        'JJhkTT0CEejYIQ58Fh4QrMUyWvU8qsdK3diNyQRoYLbctsBPgxBR1u07eUJDv38/\n' +
        'C1JlqgHmMnMi4y68Iy7ymv50QgAMuaBqgEBRI1R6Lfbyrb2YvH5txjJyTVMwuCfd\n' +
        'YPAtZVouRz0JxmnfsHyxjE+So56uOKTDuw++Ho4HhZ7Qveej7XB8b+PIPuroknd3\n' +
        'FQB5RVbXRvt5ZcVD4F2fbEdBniF7FAF4dEiofVCQGQ2nynT7dZdEIPfPdH3n7ZmE\n' +
        'lAOmwHQ6G83OsiHRBLnbp+QZRgOsjkHJxT20bQIDAQABo2YwZDAOBgNVHQ8BAf8E\n' +
        'BAMCAQYwEgYDVR0TAQH/BAgwBgEB/wIBADAdBgNVHQ4EFgQUOEVDM7VomRH4HVdA\n' +
        'QvIMNq2tXOcwHwYDVR0jBBgwFoAU54cfDjgwBx4ycBH8+/r8WXdaiqYwDQYJKoZI\n' +
        'hvcNAQELBQADggEBAHhvMssj+Th8IpNePU6RH0BiL6o9c437R3Q4IEJeFdYL+nZz\n' +
        'PW/rELDPvLRUNMfKM+KzduLZ+l29HahxefejYPXtvXBlq/E/9czFDD4fWXg+zVou\n' +
        'uDXhyrV4kNmP4S0eqsAP/jQHPOZAMFA4yVwO9hlqmePhyDnszCh9c1PfJSBh49+b\n' +
        '4w7i/L3VBOMt8j3EKYvqz0gVfpeqhJwL4Hey8UbVfJRFJMJzfNHpePqtDRAY7yjV\n' +
        'PYquRaV2ab/E+/7VFkWMM4tazYz/qsYA2jSH+4xDHvYk8LnsbcrF9iuidQmEc5sb\n' +
        'FgcWaSKG4DJjcI5k7AJLWcXyTDt21Ci43LE+I9Q=\n' +
        '-----END CERTIFICATE-----\n',
    '-----BEGIN CERTIFICATE-----\n' +
        'MIIECDCCAvCgAwIBAgICVIYwDQYJKoZIhvcNAQELBQAwgY8xCzAJBgNVBAYTAlVT\n' +
        'MRAwDgYDVQQHDAdTZWF0dGxlMRMwEQYDVQQIDApXYXNoaW5ndG9uMSIwIAYDVQQK\n' +
        'DBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMuMRMwEQYDVQQLDApBbWF6b24gUkRT\n' +
        'MSAwHgYDVQQDDBdBbWF6b24gUkRTIFJvb3QgMjAxOSBDQTAeFw0xOTA5MDQxNzEz\n' +
        'MDRaFw0yNDA4MjIxNzA4NTBaMIGVMQswCQYDVQQGEwJVUzETMBEGA1UECAwKV2Fz\n' +
        'aGluZ3RvbjEQMA4GA1UEBwwHU2VhdHRsZTEiMCAGA1UECgwZQW1hem9uIFdlYiBT\n' +
        'ZXJ2aWNlcywgSW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzEmMCQGA1UEAwwdQW1h\n' +
        'em9uIFJEUyBhcC1zb3V0aC0xIDIwMTkgQ0EwggEiMA0GCSqGSIb3DQEBAQUAA4IB\n' +
        'DwAwggEKAoIBAQDUYOz1hGL42yUCrcsMSOoU8AeD/3KgZ4q7gP+vAz1WnY9K/kim\n' +
        'eWN/2Qqzlo3+mxSFQFyD4MyV3+CnCPnBl9Sh1G/F6kThNiJ7dEWSWBQGAB6HMDbC\n' +
        'BaAsmUc1UIz8sLTL3fO+S9wYhA63Wun0Fbm/Rn2yk/4WnJAaMZcEtYf6e0KNa0LM\n' +
        'p/kN/70/8cD3iz3dDR8zOZFpHoCtf0ek80QqTich0A9n3JLxR6g6tpwoYviVg89e\n' +
        'qCjQ4axxOkWWeusLeTJCcY6CkVyFvDAKvcUl1ytM5AiaUkXblE7zDFXRM4qMMRdt\n' +
        'lPm8d3pFxh0fRYk8bIKnpmtOpz3RIctDrZZxAgMBAAGjZjBkMA4GA1UdDwEB/wQE\n' +
        'AwIBBjASBgNVHRMBAf8ECDAGAQH/AgEAMB0GA1UdDgQWBBT99wKJftD3jb4sHoHG\n' +
        'i3uGlH6W6TAfBgNVHSMEGDAWgBRzX2DYvMsDmPQrFzQuNlqmYP+8HzANBgkqhkiG\n' +
        '9w0BAQsFAAOCAQEAZ17hhr3dII3hUfuHQ1hPWGrpJOX/G9dLzkprEIcCidkmRYl+\n' +
        'hu1Pe3caRMh/17+qsoEErmnVq5jNY9X1GZL04IZH8YbHc7iRHw3HcWAdhN8633+K\n' +
        'jYEB2LbJ3vluCGnCejq9djDb6alOugdLMJzxOkHDhMZ6/gYbECOot+ph1tQuZXzD\n' +
        'tZ7prRsrcuPBChHlPjmGy8M9z8u+kF196iNSUGC4lM8vLkHM7ycc1/ZOwRq9aaTe\n' +
        'iOghbQQyAEe03MWCyDGtSmDfr0qEk+CHN+6hPiaL8qKt4s+V9P7DeK4iW08ny8Ox\n' +
        'AVS7u0OK/5+jKMAMrKwpYrBydOjTUTHScocyNw==\n' +
        '-----END CERTIFICATE-----\n',
    '-----BEGIN CERTIFICATE-----\n' +
        'MIIEBzCCAu+gAwIBAgICQ2QwDQYJKoZIhvcNAQELBQAwgY8xCzAJBgNVBAYTAlVT\n' +
        'MRAwDgYDVQQHDAdTZWF0dGxlMRMwEQYDVQQIDApXYXNoaW5ndG9uMSIwIAYDVQQK\n' +
        'DBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMuMRMwEQYDVQQLDApBbWF6b24gUkRT\n' +
        'MSAwHgYDVQQDDBdBbWF6b24gUkRTIFJvb3QgMjAxOSBDQTAeFw0xOTA5MDUxODQ2\n' +
        'MjlaFw0yNDA4MjIxNzA4NTBaMIGUMQswCQYDVQQGEwJVUzETMBEGA1UECAwKV2Fz\n' +
        'aGluZ3RvbjEQMA4GA1UEBwwHU2VhdHRsZTEiMCAGA1UECgwZQW1hem9uIFdlYiBT\n' +
        'ZXJ2aWNlcywgSW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzElMCMGA1UEAwwcQW1h\n' +
        'em9uIFJEUyBzYS1lYXN0LTEgMjAxOSBDQTCCASIwDQYJKoZIhvcNAQEBBQADggEP\n' +
        'ADCCAQoCggEBAMMvR+ReRnOzqJzoaPipNTt1Z2VA968jlN1+SYKUrYM3No+Vpz0H\n' +
        'M6Tn0oYB66ByVsXiGc28ulsqX1HbHsxqDPwvQTKvO7SrmDokoAkjJgLocOLUAeld\n' +
        '5AwvUjxGRP6yY90NV7X786MpnYb2Il9DIIaV9HjCmPt+rjy2CZjS0UjPjCKNfB8J\n' +
        'bFjgW6GGscjeyGb/zFwcom5p4j0rLydbNaOr9wOyQrtt3ZQWLYGY9Zees/b8pmcc\n' +
        'Jt+7jstZ2UMV32OO/kIsJ4rMUn2r/uxccPwAc1IDeRSSxOrnFKhW3Cu69iB3bHp7\n' +
        'JbawY12g7zshE4I14sHjv3QoXASoXjx4xgMCAwEAAaNmMGQwDgYDVR0PAQH/BAQD\n' +
        'AgEGMBIGA1UdEwEB/wQIMAYBAf8CAQAwHQYDVR0OBBYEFI1Fc/Ql2jx+oJPgBVYq\n' +
        'ccgP0pQ8MB8GA1UdIwQYMBaAFHNfYNi8ywOY9CsXNC42WqZg/7wfMA0GCSqGSIb3\n' +
        'DQEBCwUAA4IBAQB4VVVabVp70myuYuZ3vltQIWqSUMhkaTzehMgGcHjMf9iLoZ/I\n' +
        '93KiFUSGnek5cRePyS9wcpp0fcBT3FvkjpUdCjVtdttJgZFhBxgTd8y26ImdDDMR\n' +
        '4+BUuhI5msvjL08f+Vkkpu1GQcGmyFVPFOy/UY8iefu+QyUuiBUnUuEDd49Hw0Fn\n' +
        '/kIPII6Vj82a2mWV/Q8e+rgN8dIRksRjKI03DEoP8lhPlsOkhdwU6Uz9Vu6NOB2Q\n' +
        'Ls1kbcxAc7cFSyRVJEhh12Sz9d0q/CQSTFsVJKOjSNQBQfVnLz1GwO/IieUEAr4C\n' +
        'jkTntH0r1LX5b/GwN4R887LvjAEdTbg1his7\n' +
        '-----END CERTIFICATE-----\n',
    '-----BEGIN CERTIFICATE-----\n' +
        'MIIECDCCAvCgAwIBAgIDAIkHMA0GCSqGSIb3DQEBCwUAMIGPMQswCQYDVQQGEwJV\n' +
        'UzEQMA4GA1UEBwwHU2VhdHRsZTETMBEGA1UECAwKV2FzaGluZ3RvbjEiMCAGA1UE\n' +
        'CgwZQW1hem9uIFdlYiBTZXJ2aWNlcywgSW5jLjETMBEGA1UECwwKQW1hem9uIFJE\n' +
        'UzEgMB4GA1UEAwwXQW1hem9uIFJEUyBSb290IDIwMTkgQ0EwHhcNMTkwOTA2MTc0\n' +
        'MDIxWhcNMjQwODIyMTcwODUwWjCBlDELMAkGA1UEBhMCVVMxEzARBgNVBAgMCldh\n' +
        'c2hpbmd0b24xEDAOBgNVBAcMB1NlYXR0bGUxIjAgBgNVBAoMGUFtYXpvbiBXZWIg\n' +
        'U2VydmljZXMsIEluYy4xEzARBgNVBAsMCkFtYXpvbiBSRFMxJTAjBgNVBAMMHEFt\n' +
        'YXpvbiBSRFMgdXMtd2VzdC0xIDIwMTkgQ0EwggEiMA0GCSqGSIb3DQEBAQUAA4IB\n' +
        'DwAwggEKAoIBAQDD2yzbbAl77OofTghDMEf624OvU0eS9O+lsdO0QlbfUfWa1Kd6\n' +
        '0WkgjkLZGfSRxEHMCnrv4UPBSK/Qwn6FTjkDLgemhqBtAnplN4VsoDL+BkRX4Wwq\n' +
        '/dSQJE2b+0hm9w9UMVGFDEq1TMotGGTD2B71eh9HEKzKhGzqiNeGsiX4VV+LJzdH\n' +
        'uM23eGisNqmd4iJV0zcAZ+Gbh2zK6fqTOCvXtm7Idccv8vZZnyk1FiWl3NR4WAgK\n' +
        'AkvWTIoFU3Mt7dIXKKClVmvssG8WHCkd3Xcb4FHy/G756UZcq67gMMTX/9fOFM/v\n' +
        'l5C0+CHl33Yig1vIDZd+fXV1KZD84dEJfEvHAgMBAAGjZjBkMA4GA1UdDwEB/wQE\n' +
        'AwIBBjASBgNVHRMBAf8ECDAGAQH/AgEAMB0GA1UdDgQWBBR+ap20kO/6A7pPxo3+\n' +
        'T3CfqZpQWjAfBgNVHSMEGDAWgBRzX2DYvMsDmPQrFzQuNlqmYP+8HzANBgkqhkiG\n' +
        '9w0BAQsFAAOCAQEAHCJky2tPjPttlDM/RIqExupBkNrnSYnOK4kr9xJ3sl8UF2DA\n' +
        'PAnYsjXp3rfcjN/k/FVOhxwzi3cXJF/2Tjj39Bm/OEfYTOJDNYtBwB0VVH4ffa/6\n' +
        'tZl87jaIkrxJcreeeHqYMnIxeN0b/kliyA+a5L2Yb0VPjt9INq34QDc1v74FNZ17\n' +
        '4z8nr1nzg4xsOWu0Dbjo966lm4nOYIGBRGOKEkHZRZ4mEiMgr3YLkv8gSmeitx57\n' +
        'Z6dVemNtUic/LVo5Iqw4n3TBS0iF2C1Q1xT/s3h+0SXZlfOWttzSluDvoMv5PvCd\n' +
        'pFjNn+aXLAALoihL1MJSsxydtsLjOBro5eK0Vw==\n' +
        '-----END CERTIFICATE-----\n',
    '-----BEGIN CERTIFICATE-----\n' +
        'MIIEDDCCAvSgAwIBAgICOFAwDQYJKoZIhvcNAQELBQAwgY8xCzAJBgNVBAYTAlVT\n' +
        'MRAwDgYDVQQHDAdTZWF0dGxlMRMwEQYDVQQIDApXYXNoaW5ndG9uMSIwIAYDVQQK\n' +
        'DBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMuMRMwEQYDVQQLDApBbWF6b24gUkRT\n' +
        'MSAwHgYDVQQDDBdBbWF6b24gUkRTIFJvb3QgMjAxOSBDQTAeFw0xOTA5MTAxNzQ2\n' +
        'MjFaFw0yNDA4MjIxNzA4NTBaMIGZMQswCQYDVQQGEwJVUzETMBEGA1UECAwKV2Fz\n' +
        'aGluZ3RvbjEQMA4GA1UEBwwHU2VhdHRsZTEiMCAGA1UECgwZQW1hem9uIFdlYiBT\n' +
        'ZXJ2aWNlcywgSW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzEqMCgGA1UEAwwhQW1h\n' +
        'em9uIFJEUyBhcC1ub3J0aGVhc3QtMiAyMDE5IENBMIIBIjANBgkqhkiG9w0BAQEF\n' +
        'AAOCAQ8AMIIBCgKCAQEAzU72e6XbaJbi4HjJoRNjKxzUEuChKQIt7k3CWzNnmjc5\n' +
        '8I1MjCpa2W1iw1BYVysXSNSsLOtUsfvBZxi/1uyMn5ZCaf9aeoA9UsSkFSZBjOCN\n' +
        'DpKPCmfV1zcEOvJz26+1m8WDg+8Oa60QV0ou2AU1tYcw98fOQjcAES0JXXB80P2s\n' +
        '3UfkNcnDz+l4k7j4SllhFPhH6BQ4lD2NiFAP4HwoG6FeJUn45EPjzrydxjq6v5Fc\n' +
        'cQ8rGuHADVXotDbEhaYhNjIrsPL+puhjWfhJjheEw8c4whRZNp6gJ/b6WEes/ZhZ\n' +
        'h32DwsDsZw0BfRDUMgUn8TdecNexHUw8vQWeC181hwIDAQABo2YwZDAOBgNVHQ8B\n' +
        'Af8EBAMCAQYwEgYDVR0TAQH/BAgwBgEB/wIBADAdBgNVHQ4EFgQUwW9bWgkWkr0U\n' +
        'lrOsq2kvIdrECDgwHwYDVR0jBBgwFoAUc19g2LzLA5j0Kxc0LjZapmD/vB8wDQYJ\n' +
        'KoZIhvcNAQELBQADggEBAEugF0Gj7HVhX0ehPZoGRYRt3PBuI2YjfrrJRTZ9X5wc\n' +
        '9T8oHmw07mHmNy1qqWvooNJg09bDGfB0k5goC2emDiIiGfc/kvMLI7u+eQOoMKj6\n' +
        'mkfCncyRN3ty08Po45vTLBFZGUvtQmjM6yKewc4sXiASSBmQUpsMbiHRCL72M5qV\n' +
        'obcJOjGcIdDTmV1BHdWT+XcjynsGjUqOvQWWhhLPrn4jWe6Xuxll75qlrpn3IrIx\n' +
        'CRBv/5r7qbcQJPOgwQsyK4kv9Ly8g7YT1/vYBlR3cRsYQjccw5ceWUj2DrMVWhJ4\n' +
        'prf+E3Aa4vYmLLOUUvKnDQ1k3RGNu56V0tonsQbfsaM=\n' +
        '-----END CERTIFICATE-----\n',
    '-----BEGIN CERTIFICATE-----\n' +
        'MIIECjCCAvKgAwIBAgICEzUwDQYJKoZIhvcNAQELBQAwgY8xCzAJBgNVBAYTAlVT\n' +
        'MRAwDgYDVQQHDAdTZWF0dGxlMRMwEQYDVQQIDApXYXNoaW5ndG9uMSIwIAYDVQQK\n' +
        'DBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMuMRMwEQYDVQQLDApBbWF6b24gUkRT\n' +
        'MSAwHgYDVQQDDBdBbWF6b24gUkRTIFJvb3QgMjAxOSBDQTAeFw0xOTA5MTAyMDUy\n' +
        'MjVaFw0yNDA4MjIxNzA4NTBaMIGXMQswCQYDVQQGEwJVUzETMBEGA1UECAwKV2Fz\n' +
        'aGluZ3RvbjEQMA4GA1UEBwwHU2VhdHRsZTEiMCAGA1UECgwZQW1hem9uIFdlYiBT\n' +
        'ZXJ2aWNlcywgSW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzEoMCYGA1UEAwwfQW1h\n' +
        'em9uIFJEUyBjYS1jZW50cmFsLTEgMjAxOSBDQTCCASIwDQYJKoZIhvcNAQEBBQAD\n' +
        'ggEPADCCAQoCggEBAOxHqdcPSA2uBjsCP4DLSlqSoPuQ/X1kkJLusVRKiQE2zayB\n' +
        'viuCBt4VB9Qsh2rW3iYGM+usDjltGnI1iUWA5KHcvHszSMkWAOYWLiMNKTlg6LCp\n' +
        'XnE89tvj5dIH6U8WlDvXLdjB/h30gW9JEX7S8supsBSci2GxEzb5mRdKaDuuF/0O\n' +
        'qvz4YE04pua3iZ9QwmMFuTAOYzD1M72aOpj+7Ac+YLMM61qOtU+AU6MndnQkKoQi\n' +
        'qmUN2A9IFaqHFzRlSdXwKCKUA4otzmz+/N3vFwjb5F4DSsbsrMfjeHMo6o/nb6Nh\n' +
        'YDb0VJxxPee6TxSuN7CQJ2FxMlFUezcoXqwqXD0CAwEAAaNmMGQwDgYDVR0PAQH/\n' +
        'BAQDAgEGMBIGA1UdEwEB/wQIMAYBAf8CAQAwHQYDVR0OBBYEFDGGpon9WfIpsggE\n' +
        'CxHq8hZ7E2ESMB8GA1UdIwQYMBaAFHNfYNi8ywOY9CsXNC42WqZg/7wfMA0GCSqG\n' +
        'SIb3DQEBCwUAA4IBAQAvpeQYEGZvoTVLgV9rd2+StPYykMsmFjWQcyn3dBTZRXC2\n' +
        'lKq7QhQczMAOhEaaN29ZprjQzsA2X/UauKzLR2Uyqc2qOeO9/YOl0H3qauo8C/W9\n' +
        'r8xqPbOCDLEXlOQ19fidXyyEPHEq5WFp8j+fTh+s8WOx2M7IuC0ANEetIZURYhSp\n' +
        'xl9XOPRCJxOhj7JdelhpweX0BJDNHeUFi0ClnFOws8oKQ7sQEv66d5ddxqqZ3NVv\n' +
        'RbCvCtEutQMOUMIuaygDlMn1anSM8N7Wndx8G6+Uy67AnhjGx7jw/0YPPxopEj6x\n' +
        'JXP8j0sJbcT9K/9/fPVLNT25RvQ/93T2+IQL4Ca2\n' +
        '-----END CERTIFICATE-----\n',
    '-----BEGIN CERTIFICATE-----\n' +
        'MIIEBzCCAu+gAwIBAgICYpgwDQYJKoZIhvcNAQELBQAwgY8xCzAJBgNVBAYTAlVT\n' +
        'MRAwDgYDVQQHDAdTZWF0dGxlMRMwEQYDVQQIDApXYXNoaW5ndG9uMSIwIAYDVQQK\n' +
        'DBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMuMRMwEQYDVQQLDApBbWF6b24gUkRT\n' +
        'MSAwHgYDVQQDDBdBbWF6b24gUkRTIFJvb3QgMjAxOSBDQTAeFw0xOTA5MTExNzMx\n' +
        'NDhaFw0yNDA4MjIxNzA4NTBaMIGUMQswCQYDVQQGEwJVUzETMBEGA1UECAwKV2Fz\n' +
        'aGluZ3RvbjEQMA4GA1UEBwwHU2VhdHRsZTEiMCAGA1UECgwZQW1hem9uIFdlYiBT\n' +
        'ZXJ2aWNlcywgSW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzElMCMGA1UEAwwcQW1h\n' +
        'em9uIFJEUyBldS13ZXN0LTEgMjAxOSBDQTCCASIwDQYJKoZIhvcNAQEBBQADggEP\n' +
        'ADCCAQoCggEBAMk3YdSZ64iAYp6MyyKtYJtNzv7zFSnnNf6vv0FB4VnfITTMmOyZ\n' +
        'LXqKAT2ahZ00hXi34ewqJElgU6eUZT/QlzdIu359TEZyLVPwURflL6SWgdG01Q5X\n' +
        'O++7fSGcBRyIeuQWs9FJNIIqK8daF6qw0Rl5TXfu7P9dBc3zkgDXZm2DHmxGDD69\n' +
        '7liQUiXzoE1q2Z9cA8+jirDioJxN9av8hQt12pskLQumhlArsMIhjhHRgF03HOh5\n' +
        'tvi+RCfihVOxELyIRTRpTNiIwAqfZxxTWFTgfn+gijTmd0/1DseAe82aYic8JbuS\n' +
        'EMbrDduAWsqrnJ4GPzxHKLXX0JasCUcWyMECAwEAAaNmMGQwDgYDVR0PAQH/BAQD\n' +
        'AgEGMBIGA1UdEwEB/wQIMAYBAf8CAQAwHQYDVR0OBBYEFPLtsq1NrwJXO13C9eHt\n' +
        'sLY11AGwMB8GA1UdIwQYMBaAFHNfYNi8ywOY9CsXNC42WqZg/7wfMA0GCSqGSIb3\n' +
        'DQEBCwUAA4IBAQAnWBKj5xV1A1mYd0kIgDdkjCwQkiKF5bjIbGkT3YEFFbXoJlSP\n' +
        '0lZZ/hDaOHI8wbLT44SzOvPEEmWF9EE7SJzkvSdQrUAWR9FwDLaU427ALI3ngNHy\n' +
        'lGJ2hse1fvSRNbmg8Sc9GBv8oqNIBPVuw+AJzHTacZ1OkyLZrz1c1QvwvwN2a+Jd\n' +
        'vH0V0YIhv66llKcYDMUQJAQi4+8nbRxXWv6Gq3pvrFoorzsnkr42V3JpbhnYiK+9\n' +
        'nRKd4uWl62KRZjGkfMbmsqZpj2fdSWMY1UGyN1k+kDmCSWYdrTRDP0xjtIocwg+A\n' +
        'J116n4hV/5mbA0BaPiS2krtv17YAeHABZcvz\n' +
        '-----END CERTIFICATE-----\n',
    '-----BEGIN CERTIFICATE-----\n' +
        'MIIECjCCAvKgAwIBAgICV2YwDQYJKoZIhvcNAQELBQAwgY8xCzAJBgNVBAYTAlVT\n' +
        'MRAwDgYDVQQHDAdTZWF0dGxlMRMwEQYDVQQIDApXYXNoaW5ndG9uMSIwIAYDVQQK\n' +
        'DBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMuMRMwEQYDVQQLDApBbWF6b24gUkRT\n' +
        'MSAwHgYDVQQDDBdBbWF6b24gUkRTIFJvb3QgMjAxOSBDQTAeFw0xOTA5MTExOTM2\n' +
        'MjBaFw0yNDA4MjIxNzA4NTBaMIGXMQswCQYDVQQGEwJVUzETMBEGA1UECAwKV2Fz\n' +
        'aGluZ3RvbjEQMA4GA1UEBwwHU2VhdHRsZTEiMCAGA1UECgwZQW1hem9uIFdlYiBT\n' +
        'ZXJ2aWNlcywgSW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzEoMCYGA1UEAwwfQW1h\n' +
        'em9uIFJEUyBldS1jZW50cmFsLTEgMjAxOSBDQTCCASIwDQYJKoZIhvcNAQEBBQAD\n' +
        'ggEPADCCAQoCggEBAMEx54X2pHVv86APA0RWqxxRNmdkhAyp2R1cFWumKQRofoFv\n' +
        'n+SPXdkpIINpMuEIGJANozdiEz7SPsrAf8WHyD93j/ZxrdQftRcIGH41xasetKGl\n' +
        'I67uans8d+pgJgBKGb/Z+B5m+UsIuEVekpvgpwKtmmaLFC/NCGuSsJoFsRqoa6Gh\n' +
        'm34W6yJoY87UatddCqLY4IIXaBFsgK9Q/wYzYLbnWM6ZZvhJ52VMtdhcdzeTHNW0\n' +
        '5LGuXJOF7Ahb4JkEhoo6TS2c0NxB4l4MBfBPgti+O7WjR3FfZHpt18A6Zkq6A2u6\n' +
        'D/oTSL6c9/3sAaFTFgMyL3wHb2YlW0BPiljZIqECAwEAAaNmMGQwDgYDVR0PAQH/\n' +
        'BAQDAgEGMBIGA1UdEwEB/wQIMAYBAf8CAQAwHQYDVR0OBBYEFOcAToAc6skWffJa\n' +
        'TnreaswAfrbcMB8GA1UdIwQYMBaAFHNfYNi8ywOY9CsXNC42WqZg/7wfMA0GCSqG\n' +
        'SIb3DQEBCwUAA4IBAQA1d0Whc1QtspK496mFWfFEQNegLh0a9GWYlJm+Htcj5Nxt\n' +
        'DAIGXb+8xrtOZFHmYP7VLCT5Zd2C+XytqseK/+s07iAr0/EPF+O2qcyQWMN5KhgE\n' +
        'cXw2SwuP9FPV3i+YAm11PBVeenrmzuk9NrdHQ7TxU4v7VGhcsd2C++0EisrmquWH\n' +
        'mgIfmVDGxphwoES52cY6t3fbnXmTkvENvR+h3rj+fUiSz0aSo+XZUGHPgvuEKM/W\n' +
        'CBD9Smc9CBoBgvy7BgHRgRUmwtABZHFUIEjHI5rIr7ZvYn+6A0O6sogRfvVYtWFc\n' +
        'qpyrW1YX8mD0VlJ8fGKM3G+aCOsiiPKDV/Uafrm+\n' +
        '-----END CERTIFICATE-----\n',
    '-----BEGIN CERTIFICATE-----\n' +
        'MIIECDCCAvCgAwIBAgICGAcwDQYJKoZIhvcNAQELBQAwgY8xCzAJBgNVBAYTAlVT\n' +
        'MRAwDgYDVQQHDAdTZWF0dGxlMRMwEQYDVQQIDApXYXNoaW5ndG9uMSIwIAYDVQQK\n' +
        'DBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMuMRMwEQYDVQQLDApBbWF6b24gUkRT\n' +
        'MSAwHgYDVQQDDBdBbWF6b24gUkRTIFJvb3QgMjAxOSBDQTAeFw0xOTA5MTIxODE5\n' +
        'NDRaFw0yNDA4MjIxNzA4NTBaMIGVMQswCQYDVQQGEwJVUzETMBEGA1UECAwKV2Fz\n' +
        'aGluZ3RvbjEQMA4GA1UEBwwHU2VhdHRsZTEiMCAGA1UECgwZQW1hem9uIFdlYiBT\n' +
        'ZXJ2aWNlcywgSW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzEmMCQGA1UEAwwdQW1h\n' +
        'em9uIFJEUyBldS1ub3J0aC0xIDIwMTkgQ0EwggEiMA0GCSqGSIb3DQEBAQUAA4IB\n' +
        'DwAwggEKAoIBAQCiIYnhe4UNBbdBb/nQxl5giM0XoVHWNrYV5nB0YukA98+TPn9v\n' +
        'Aoj1RGYmtryjhrf01Kuv8SWO+Eom95L3zquoTFcE2gmxCfk7bp6qJJ3eHOJB+QUO\n' +
        'XsNRh76fwDzEF1yTeZWH49oeL2xO13EAx4PbZuZpZBttBM5zAxgZkqu4uWQczFEs\n' +
        'JXfla7z2fvWmGcTagX10O5C18XaFroV0ubvSyIi75ue9ykg/nlFAeB7O0Wxae88e\n' +
        'uhiBEFAuLYdqWnsg3459NfV8Yi1GnaitTym6VI3tHKIFiUvkSiy0DAlAGV2iiyJE\n' +
        'q+DsVEO4/hSINJEtII4TMtysOsYPpINqeEzRAgMBAAGjZjBkMA4GA1UdDwEB/wQE\n' +
        'AwIBBjASBgNVHRMBAf8ECDAGAQH/AgEAMB0GA1UdDgQWBBRR0UpnbQyjnHChgmOc\n' +
        'hnlc0PogzTAfBgNVHSMEGDAWgBRzX2DYvMsDmPQrFzQuNlqmYP+8HzANBgkqhkiG\n' +
        '9w0BAQsFAAOCAQEAKJD4xVzSf4zSGTBJrmamo86jl1NHQxXUApAZuBZEc8tqC6TI\n' +
        'T5CeoSr9CMuVC8grYyBjXblC4OsM5NMvmsrXl/u5C9dEwtBFjo8mm53rOOIm1fxl\n' +
        'I1oYB/9mtO9ANWjkykuLzWeBlqDT/i7ckaKwalhLODsRDO73vRhYNjsIUGloNsKe\n' +
        'pxw3dzHwAZx4upSdEVG4RGCZ1D0LJ4Gw40OfD69hfkDfRVVxKGrbEzqxXRvovmDc\n' +
        'tKLdYZO/6REoca36v4BlgIs1CbUXJGLSXUwtg7YXGLSVBJ/U0+22iGJmBSNcoyUN\n' +
        'cjPFD9JQEhDDIYYKSGzIYpvslvGc4T5ISXFiuQ==\n' +
        '-----END CERTIFICATE-----\n',
    '-----BEGIN CERTIFICATE-----\n' +
        'MIIEBzCCAu+gAwIBAgICZIEwDQYJKoZIhvcNAQELBQAwgY8xCzAJBgNVBAYTAlVT\n' +
        'MRAwDgYDVQQHDAdTZWF0dGxlMRMwEQYDVQQIDApXYXNoaW5ndG9uMSIwIAYDVQQK\n' +
        'DBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMuMRMwEQYDVQQLDApBbWF6b24gUkRT\n' +
        'MSAwHgYDVQQDDBdBbWF6b24gUkRTIFJvb3QgMjAxOSBDQTAeFw0xOTA5MTIyMTMy\n' +
        'MzJaFw0yNDA4MjIxNzA4NTBaMIGUMQswCQYDVQQGEwJVUzETMBEGA1UECAwKV2Fz\n' +
        'aGluZ3RvbjEQMA4GA1UEBwwHU2VhdHRsZTEiMCAGA1UECgwZQW1hem9uIFdlYiBT\n' +
        'ZXJ2aWNlcywgSW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzElMCMGA1UEAwwcQW1h\n' +
        'em9uIFJEUyBldS13ZXN0LTIgMjAxOSBDQTCCASIwDQYJKoZIhvcNAQEBBQADggEP\n' +
        'ADCCAQoCggEBALGiwqjiF7xIjT0Sx7zB3764K2T2a1DHnAxEOr+/EIftWKxWzT3u\n' +
        'PFwS2eEZcnKqSdRQ+vRzonLBeNLO4z8aLjQnNbkizZMBuXGm4BqRm1Kgq3nlLDQn\n' +
        '7YqdijOq54SpShvR/8zsO4sgMDMmHIYAJJOJqBdaus2smRt0NobIKc0liy7759KB\n' +
        '6kmQ47Gg+kfIwxrQA5zlvPLeQImxSoPi9LdbRoKvu7Iot7SOa+jGhVBh3VdqndJX\n' +
        '7tm/saj4NE375csmMETFLAOXjat7zViMRwVorX4V6AzEg1vkzxXpA9N7qywWIT5Y\n' +
        'fYaq5M8i6vvLg0CzrH9fHORtnkdjdu1y+0MCAwEAAaNmMGQwDgYDVR0PAQH/BAQD\n' +
        'AgEGMBIGA1UdEwEB/wQIMAYBAf8CAQAwHQYDVR0OBBYEFFOhOx1yt3Z7mvGB9jBv\n' +
        '2ymdZwiOMB8GA1UdIwQYMBaAFHNfYNi8ywOY9CsXNC42WqZg/7wfMA0GCSqGSIb3\n' +
        'DQEBCwUAA4IBAQBehqY36UGDvPVU9+vtaYGr38dBbp+LzkjZzHwKT1XJSSUc2wqM\n' +
        'hnCIQKilonrTIvP1vmkQi8qHPvDRtBZKqvz/AErW/ZwQdZzqYNFd+BmOXaeZWV0Q\n' +
        'oHtDzXmcwtP8aUQpxN0e1xkWb1E80qoy+0uuRqb/50b/R4Q5qqSfJhkn6z8nwB10\n' +
        '7RjLtJPrK8igxdpr3tGUzfAOyiPrIDncY7UJaL84GFp7WWAkH0WG3H8Y8DRcRXOU\n' +
        'mqDxDLUP3rNuow3jnGxiUY+gGX5OqaZg4f4P6QzOSmeQYs6nLpH0PiN00+oS1BbD\n' +
        'bpWdZEttILPI+vAYkU4QuBKKDjJL6HbSd+cn\n' +
        '-----END CERTIFICATE-----\n',
    '-----BEGIN CERTIFICATE-----\n' +
        'MIIECDCCAvCgAwIBAgIDAIVCMA0GCSqGSIb3DQEBCwUAMIGPMQswCQYDVQQGEwJV\n' +
        'UzEQMA4GA1UEBwwHU2VhdHRsZTETMBEGA1UECAwKV2FzaGluZ3RvbjEiMCAGA1UE\n' +
        'CgwZQW1hem9uIFdlYiBTZXJ2aWNlcywgSW5jLjETMBEGA1UECwwKQW1hem9uIFJE\n' +
        'UzEgMB4GA1UEAwwXQW1hem9uIFJEUyBSb290IDIwMTkgQ0EwHhcNMTkwOTEzMTcw\n' +
        'NjQxWhcNMjQwODIyMTcwODUwWjCBlDELMAkGA1UEBhMCVVMxEzARBgNVBAgMCldh\n' +
        'c2hpbmd0b24xEDAOBgNVBAcMB1NlYXR0bGUxIjAgBgNVBAoMGUFtYXpvbiBXZWIg\n' +
        'U2VydmljZXMsIEluYy4xEzARBgNVBAsMCkFtYXpvbiBSRFMxJTAjBgNVBAMMHEFt\n' +
        'YXpvbiBSRFMgdXMtZWFzdC0yIDIwMTkgQ0EwggEiMA0GCSqGSIb3DQEBAQUAA4IB\n' +
        'DwAwggEKAoIBAQDE+T2xYjUbxOp+pv+gRA3FO24+1zCWgXTDF1DHrh1lsPg5k7ht\n' +
        '2KPYzNc+Vg4E+jgPiW0BQnA6jStX5EqVh8BU60zELlxMNvpg4KumniMCZ3krtMUC\n' +
        'au1NF9rM7HBh+O+DYMBLK5eSIVt6lZosOb7bCi3V6wMLA8YqWSWqabkxwN4w0vXI\n' +
        '8lu5uXXFRemHnlNf+yA/4YtN4uaAyd0ami9+klwdkZfkrDOaiy59haOeBGL8EB/c\n' +
        'dbJJlguHH5CpCscs3RKtOOjEonXnKXldxarFdkMzi+aIIjQ8GyUOSAXHtQHb3gZ4\n' +
        'nS6Ey0CMlwkB8vUObZU9fnjKJcL5QCQqOfwvAgMBAAGjZjBkMA4GA1UdDwEB/wQE\n' +
        'AwIBBjASBgNVHRMBAf8ECDAGAQH/AgEAMB0GA1UdDgQWBBQUPuRHohPxx4VjykmH\n' +
        '6usGrLL1ETAfBgNVHSMEGDAWgBRzX2DYvMsDmPQrFzQuNlqmYP+8HzANBgkqhkiG\n' +
        '9w0BAQsFAAOCAQEAUdR9Vb3y33Yj6X6KGtuthZ08SwjImVQPtknzpajNE5jOJAh8\n' +
        'quvQnU9nlnMO85fVDU1Dz3lLHGJ/YG1pt1Cqq2QQ200JcWCvBRgdvH6MjHoDQpqZ\n' +
        'HvQ3vLgOGqCLNQKFuet9BdpsHzsctKvCVaeBqbGpeCtt3Hh/26tgx0rorPLw90A2\n' +
        'V8QSkZJjlcKkLa58N5CMM8Xz8KLWg3MZeT4DmlUXVCukqK2RGuP2L+aME8dOxqNv\n' +
        'OnOz1zrL5mR2iJoDpk8+VE/eBDmJX40IJk6jBjWoxAO/RXq+vBozuF5YHN1ujE92\n' +
        'tO8HItgTp37XT8bJBAiAnt5mxw+NLSqtxk2QdQ==\n' +
        '-----END CERTIFICATE-----\n',
    '-----BEGIN CERTIFICATE-----\n' +
        'MIIEDDCCAvSgAwIBAgICY4kwDQYJKoZIhvcNAQELBQAwgY8xCzAJBgNVBAYTAlVT\n' +
        'MRAwDgYDVQQHDAdTZWF0dGxlMRMwEQYDVQQIDApXYXNoaW5ndG9uMSIwIAYDVQQK\n' +
        'DBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMuMRMwEQYDVQQLDApBbWF6b24gUkRT\n' +
        'MSAwHgYDVQQDDBdBbWF6b24gUkRTIFJvb3QgMjAxOSBDQTAeFw0xOTA5MTMyMDEx\n' +
        'NDJaFw0yNDA4MjIxNzA4NTBaMIGZMQswCQYDVQQGEwJVUzETMBEGA1UECAwKV2Fz\n' +
        'aGluZ3RvbjEQMA4GA1UEBwwHU2VhdHRsZTEiMCAGA1UECgwZQW1hem9uIFdlYiBT\n' +
        'ZXJ2aWNlcywgSW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzEqMCgGA1UEAwwhQW1h\n' +
        'em9uIFJEUyBhcC1zb3V0aGVhc3QtMSAyMDE5IENBMIIBIjANBgkqhkiG9w0BAQEF\n' +
        'AAOCAQ8AMIIBCgKCAQEAr5u9OuLL/OF/fBNUX2kINJLzFl4DnmrhnLuSeSnBPgbb\n' +
        'qddjf5EFFJBfv7IYiIWEFPDbDG5hoBwgMup5bZDbas+ZTJTotnnxVJTQ6wlhTmns\n' +
        'eHECcg2pqGIKGrxZfbQhlj08/4nNAPvyYCTS0bEcmQ1emuDPyvJBYDDLDU6AbCB5\n' +
        '6Z7YKFQPTiCBblvvNzchjLWF9IpkqiTsPHiEt21sAdABxj9ityStV3ja/W9BfgxH\n' +
        'wzABSTAQT6FbDwmQMo7dcFOPRX+hewQSic2Rn1XYjmNYzgEHisdUsH7eeXREAcTw\n' +
        '61TRvaLH8AiOWBnTEJXPAe6wYfrcSd1pD0MXpoB62wIDAQABo2YwZDAOBgNVHQ8B\n' +
        'Af8EBAMCAQYwEgYDVR0TAQH/BAgwBgEB/wIBADAdBgNVHQ4EFgQUytwMiomQOgX5\n' +
        'Ichd+2lDWRUhkikwHwYDVR0jBBgwFoAUc19g2LzLA5j0Kxc0LjZapmD/vB8wDQYJ\n' +
        'KoZIhvcNAQELBQADggEBACf6lRDpfCD7BFRqiWM45hqIzffIaysmVfr+Jr+fBTjP\n' +
        'uYe/ba1omSrNGG23bOcT9LJ8hkQJ9d+FxUwYyICQNWOy6ejicm4z0C3VhphbTPqj\n' +
        'yjpt9nG56IAcV8BcRJh4o/2IfLNzC/dVuYJV8wj7XzwlvjysenwdrJCoLadkTr1h\n' +
        'eIdG6Le07sB9IxrGJL9e04afk37h7c8ESGSE4E+oS4JQEi3ATq8ne1B9DQ9SasXi\n' +
        'IRmhNAaISDzOPdyLXi9N9V9Lwe/DHcja7hgLGYx3UqfjhLhOKwp8HtoZORixAmOI\n' +
        'HfILgNmwyugAbuZoCazSKKBhQ0wgO0WZ66ZKTMG8Oho=\n' +
        '-----END CERTIFICATE-----\n',
    '-----BEGIN CERTIFICATE-----\n' +
        'MIIEBzCCAu+gAwIBAgICUYkwDQYJKoZIhvcNAQELBQAwgY8xCzAJBgNVBAYTAlVT\n' +
        'MRAwDgYDVQQHDAdTZWF0dGxlMRMwEQYDVQQIDApXYXNoaW5ndG9uMSIwIAYDVQQK\n' +
        'DBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMuMRMwEQYDVQQLDApBbWF6b24gUkRT\n' +
        'MSAwHgYDVQQDDBdBbWF6b24gUkRTIFJvb3QgMjAxOSBDQTAeFw0xOTA5MTYxODIx\n' +
        'MTVaFw0yNDA4MjIxNzA4NTBaMIGUMQswCQYDVQQGEwJVUzETMBEGA1UECAwKV2Fz\n' +
        'aGluZ3RvbjEQMA4GA1UEBwwHU2VhdHRsZTEiMCAGA1UECgwZQW1hem9uIFdlYiBT\n' +
        'ZXJ2aWNlcywgSW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzElMCMGA1UEAwwcQW1h\n' +
        'em9uIFJEUyB1cy13ZXN0LTIgMjAxOSBDQTCCASIwDQYJKoZIhvcNAQEBBQADggEP\n' +
        'ADCCAQoCggEBANCEZBZyu6yJQFZBJmSUZfSZd3Ui2gitczMKC4FLr0QzkbxY+cLa\n' +
        'uVONIOrPt4Rwi+3h/UdnUg917xao3S53XDf1TDMFEYp4U8EFPXqCn/GXBIWlU86P\n' +
        'PvBN+gzw3nS+aco7WXb+woTouvFVkk8FGU7J532llW8o/9ydQyDIMtdIkKTuMfho\n' +
        'OiNHSaNc+QXQ32TgvM9A/6q7ksUoNXGCP8hDOkSZ/YOLiI5TcdLh/aWj00ziL5bj\n' +
        'pvytiMZkilnc9dLY9QhRNr0vGqL0xjmWdoEXz9/OwjmCihHqJq+20MJPsvFm7D6a\n' +
        '2NKybR9U+ddrjb8/iyLOjURUZnj5O+2+OPcCAwEAAaNmMGQwDgYDVR0PAQH/BAQD\n' +
        'AgEGMBIGA1UdEwEB/wQIMAYBAf8CAQAwHQYDVR0OBBYEFEBxMBdv81xuzqcK5TVu\n' +
        'pHj+Aor8MB8GA1UdIwQYMBaAFHNfYNi8ywOY9CsXNC42WqZg/7wfMA0GCSqGSIb3\n' +
        'DQEBCwUAA4IBAQBZkfiVqGoJjBI37aTlLOSjLcjI75L5wBrwO39q+B4cwcmpj58P\n' +
        '3sivv+jhYfAGEbQnGRzjuFoyPzWnZ1DesRExX+wrmHsLLQbF2kVjLZhEJMHF9eB7\n' +
        'GZlTPdTzHErcnuXkwA/OqyXMpj9aghcQFuhCNguEfnROY9sAoK2PTfnTz9NJHL+Q\n' +
        'UpDLEJEUfc0GZMVWYhahc0x38ZnSY2SKacIPECQrTI0KpqZv/P+ijCEcMD9xmYEb\n' +
        'jL4en+XKS1uJpw5fIU5Sj0MxhdGstH6S84iAE5J3GM3XHklGSFwwqPYvuTXvANH6\n' +
        'uboynxRgSae59jIlAK6Jrr6GWMwQRbgcaAlW\n' +
        '-----END CERTIFICATE-----\n',
    '-----BEGIN CERTIFICATE-----\n' +
        'MIIEDDCCAvSgAwIBAgICEkYwDQYJKoZIhvcNAQELBQAwgY8xCzAJBgNVBAYTAlVT\n' +
        'MRAwDgYDVQQHDAdTZWF0dGxlMRMwEQYDVQQIDApXYXNoaW5ndG9uMSIwIAYDVQQK\n' +
        'DBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMuMRMwEQYDVQQLDApBbWF6b24gUkRT\n' +
        'MSAwHgYDVQQDDBdBbWF6b24gUkRTIFJvb3QgMjAxOSBDQTAeFw0xOTA5MTYxOTUz\n' +
        'NDdaFw0yNDA4MjIxNzA4NTBaMIGZMQswCQYDVQQGEwJVUzETMBEGA1UECAwKV2Fz\n' +
        'aGluZ3RvbjEQMA4GA1UEBwwHU2VhdHRsZTEiMCAGA1UECgwZQW1hem9uIFdlYiBT\n' +
        'ZXJ2aWNlcywgSW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzEqMCgGA1UEAwwhQW1h\n' +
        'em9uIFJEUyBhcC1zb3V0aGVhc3QtMiAyMDE5IENBMIIBIjANBgkqhkiG9w0BAQEF\n' +
        'AAOCAQ8AMIIBCgKCAQEAufodI2Flker8q7PXZG0P0vmFSlhQDw907A6eJuF/WeMo\n' +
        'GHnll3b4S6nC3oRS3nGeRMHbyU2KKXDwXNb3Mheu+ox+n5eb/BJ17eoj9HbQR1cd\n' +
        'gEkIciiAltf8gpMMQH4anP7TD+HNFlZnP7ii3geEJB2GGXSxgSWvUzH4etL67Zmn\n' +
        'TpGDWQMB0T8lK2ziLCMF4XAC/8xDELN/buHCNuhDpxpPebhct0T+f6Arzsiswt2j\n' +
        '7OeNeLLZwIZvVwAKF7zUFjC6m7/VmTQC8nidVY559D6l0UhhU0Co/txgq3HVsMOH\n' +
        'PbxmQUwJEKAzQXoIi+4uZzHFZrvov/nDTNJUhC6DqwIDAQABo2YwZDAOBgNVHQ8B\n' +
        'Af8EBAMCAQYwEgYDVR0TAQH/BAgwBgEB/wIBADAdBgNVHQ4EFgQUwaZpaCme+EiV\n' +
        'M5gcjeHZSTgOn4owHwYDVR0jBBgwFoAUc19g2LzLA5j0Kxc0LjZapmD/vB8wDQYJ\n' +
        'KoZIhvcNAQELBQADggEBAAR6a2meCZuXO2TF9bGqKGtZmaah4pH2ETcEVUjkvXVz\n' +
        'sl+ZKbYjrun+VkcMGGKLUjS812e7eDF726ptoku9/PZZIxlJB0isC/0OyixI8N4M\n' +
        'NsEyvp52XN9QundTjkl362bomPnHAApeU0mRbMDRR2JdT70u6yAzGLGsUwMkoNnw\n' +
        '1VR4XKhXHYGWo7KMvFrZ1KcjWhubxLHxZWXRulPVtGmyWg/MvE6KF+2XMLhojhUL\n' +
        '+9jB3Fpn53s6KMx5tVq1x8PukHmowcZuAF8k+W4gk8Y68wIwynrdZrKRyRv6CVtR\n' +
        'FZ8DeJgoNZT3y/GT254VqMxxfuy2Ccb/RInd16tEvVk=\n' +
        '-----END CERTIFICATE-----\n',
    '-----BEGIN CERTIFICATE-----\n' +
        'MIIEDDCCAvSgAwIBAgICOYIwDQYJKoZIhvcNAQELBQAwgY8xCzAJBgNVBAYTAlVT\n' +
        'MRAwDgYDVQQHDAdTZWF0dGxlMRMwEQYDVQQIDApXYXNoaW5ndG9uMSIwIAYDVQQK\n' +
        'DBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMuMRMwEQYDVQQLDApBbWF6b24gUkRT\n' +
        'MSAwHgYDVQQDDBdBbWF6b24gUkRTIFJvb3QgMjAxOSBDQTAeFw0xOTA5MTcyMDA1\n' +
        'MjlaFw0yNDA4MjIxNzA4NTBaMIGZMQswCQYDVQQGEwJVUzETMBEGA1UECAwKV2Fz\n' +
        'aGluZ3RvbjEQMA4GA1UEBwwHU2VhdHRsZTEiMCAGA1UECgwZQW1hem9uIFdlYiBT\n' +
        'ZXJ2aWNlcywgSW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzEqMCgGA1UEAwwhQW1h\n' +
        'em9uIFJEUyBhcC1ub3J0aGVhc3QtMyAyMDE5IENBMIIBIjANBgkqhkiG9w0BAQEF\n' +
        'AAOCAQ8AMIIBCgKCAQEA4dMak8W+XW8y/2F6nRiytFiA4XLwePadqWebGtlIgyCS\n' +
        'kbug8Jv5w7nlMkuxOxoUeD4WhI6A9EkAn3r0REM/2f0aYnd2KPxeqS2MrtdxxHw1\n' +
        'xoOxk2x0piNSlOz6yog1idsKR5Wurf94fvM9FdTrMYPPrDabbGqiBMsZZmoHLvA3\n' +
        'Z+57HEV2tU0Ei3vWeGIqnNjIekS+E06KhASxrkNU5vi611UsnYZlSi0VtJsH4UGV\n' +
        'LhnHl53aZL0YFO5mn/fzuNG/51qgk/6EFMMhaWInXX49Dia9FnnuWXwVwi6uX1Wn\n' +
        '7kjoHi5VtmC8ZlGEHroxX2DxEr6bhJTEpcLMnoQMqwIDAQABo2YwZDAOBgNVHQ8B\n' +
        'Af8EBAMCAQYwEgYDVR0TAQH/BAgwBgEB/wIBADAdBgNVHQ4EFgQUsUI5Cb3SWB8+\n' +
        'gv1YLN/ABPMdxSAwHwYDVR0jBBgwFoAUc19g2LzLA5j0Kxc0LjZapmD/vB8wDQYJ\n' +
        'KoZIhvcNAQELBQADggEBAJAF3E9PM1uzVL8YNdzb6fwJrxxqI2shvaMVmC1mXS+w\n' +
        'G0zh4v2hBZOf91l1EO0rwFD7+fxoI6hzQfMxIczh875T6vUXePKVOCOKI5wCrDad\n' +
        'zQbVqbFbdhsBjF4aUilOdtw2qjjs9JwPuB0VXN4/jY7m21oKEOcnpe36+7OiSPjN\n' +
        'xngYewCXKrSRqoj3mw+0w/+exYj3Wsush7uFssX18av78G+ehKPIVDXptOCP/N7W\n' +
        '8iKVNeQ2QGTnu2fzWsGUSvMGyM7yqT+h1ILaT//yQS8er511aHMLc142bD4D9VSy\n' +
        'DgactwPDTShK/PXqhvNey9v/sKXm4XatZvwcc8KYlW4=\n' +
        '-----END CERTIFICATE-----\n',
    '-----BEGIN CERTIFICATE-----\n' +
        'MIIEDDCCAvSgAwIBAgICcEUwDQYJKoZIhvcNAQELBQAwgY8xCzAJBgNVBAYTAlVT\n' +
        'MRAwDgYDVQQHDAdTZWF0dGxlMRMwEQYDVQQIDApXYXNoaW5ndG9uMSIwIAYDVQQK\n' +
        'DBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMuMRMwEQYDVQQLDApBbWF6b24gUkRT\n' +
        'MSAwHgYDVQQDDBdBbWF6b24gUkRTIFJvb3QgMjAxOSBDQTAeFw0xOTA5MTgxNjU2\n' +
        'MjBaFw0yNDA4MjIxNzA4NTBaMIGZMQswCQYDVQQGEwJVUzETMBEGA1UECAwKV2Fz\n' +
        'aGluZ3RvbjEQMA4GA1UEBwwHU2VhdHRsZTEiMCAGA1UECgwZQW1hem9uIFdlYiBT\n' +
        'ZXJ2aWNlcywgSW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzEqMCgGA1UEAwwhQW1h\n' +
        'em9uIFJEUyBhcC1ub3J0aGVhc3QtMSAyMDE5IENBMIIBIjANBgkqhkiG9w0BAQEF\n' +
        'AAOCAQ8AMIIBCgKCAQEAndtkldmHtk4TVQAyqhAvtEHSMb6pLhyKrIFved1WO3S7\n' +
        '+I+bWwv9b2W/ljJxLq9kdT43bhvzonNtI4a1LAohS6bqyirmk8sFfsWT3akb+4Sx\n' +
        '1sjc8Ovc9eqIWJCrUiSvv7+cS7ZTA9AgM1PxvHcsqrcUXiK3Jd/Dax9jdZE1e15s\n' +
        'BEhb2OEPE+tClFZ+soj8h8Pl2Clo5OAppEzYI4LmFKtp1X/BOf62k4jviXuCSst3\n' +
        'UnRJzE/CXtjmN6oZySVWSe0rQYuyqRl6//9nK40cfGKyxVnimB8XrrcxUN743Vud\n' +
        'QQVU0Esm8OVTX013mXWQXJHP2c0aKkog8LOga0vobQIDAQABo2YwZDAOBgNVHQ8B\n' +
        'Af8EBAMCAQYwEgYDVR0TAQH/BAgwBgEB/wIBADAdBgNVHQ4EFgQULmoOS1mFSjj+\n' +
        'snUPx4DgS3SkLFYwHwYDVR0jBBgwFoAUc19g2LzLA5j0Kxc0LjZapmD/vB8wDQYJ\n' +
        'KoZIhvcNAQELBQADggEBAAkVL2P1M2/G9GM3DANVAqYOwmX0Xk58YBHQu6iiQg4j\n' +
        'b4Ky/qsZIsgT7YBsZA4AOcPKQFgGTWhe9pvhmXqoN3RYltN8Vn7TbUm/ZVDoMsrM\n' +
        'gwv0+TKxW1/u7s8cXYfHPiTzVSJuOogHx99kBW6b2f99GbP7O1Sv3sLq4j6lVvBX\n' +
        'Fiacf5LAWC925nvlTzLlBgIc3O9xDtFeAGtZcEtxZJ4fnGXiqEnN4539+nqzIyYq\n' +
        'nvlgCzyvcfRAxwltrJHuuRu6Maw5AGcd2Y0saMhqOVq9KYKFKuD/927BTrbd2JVf\n' +
        '2sGWyuPZPCk3gq+5pCjbD0c6DkhcMGI6WwxvM5V/zSM=\n' +
        '-----END CERTIFICATE-----\n',
    '-----BEGIN CERTIFICATE-----\n' +
        'MIIEBzCCAu+gAwIBAgICJDQwDQYJKoZIhvcNAQELBQAwgY8xCzAJBgNVBAYTAlVT\n' +
        'MRAwDgYDVQQHDAdTZWF0dGxlMRMwEQYDVQQIDApXYXNoaW5ndG9uMSIwIAYDVQQK\n' +
        'DBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMuMRMwEQYDVQQLDApBbWF6b24gUkRT\n' +
        'MSAwHgYDVQQDDBdBbWF6b24gUkRTIFJvb3QgMjAxOSBDQTAeFw0xOTA5MTgxNzAz\n' +
        'MTVaFw0yNDA4MjIxNzA4NTBaMIGUMQswCQYDVQQGEwJVUzETMBEGA1UECAwKV2Fz\n' +
        'aGluZ3RvbjEQMA4GA1UEBwwHU2VhdHRsZTEiMCAGA1UECgwZQW1hem9uIFdlYiBT\n' +
        'ZXJ2aWNlcywgSW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzElMCMGA1UEAwwcQW1h\n' +
        'em9uIFJEUyBldS13ZXN0LTMgMjAxOSBDQTCCASIwDQYJKoZIhvcNAQEBBQADggEP\n' +
        'ADCCAQoCggEBAL9bL7KE0n02DLVtlZ2PL+g/BuHpMYFq2JnE2RgompGurDIZdjmh\n' +
        '1pxfL3nT+QIVMubuAOy8InRfkRxfpxyjKYdfLJTPJG+jDVL+wDcPpACFVqoV7Prg\n' +
        'pVYEV0lc5aoYw4bSeYFhdzgim6F8iyjoPnObjll9mo4XsHzSoqJLCd0QC+VG9Fw2\n' +
        'q+GDRZrLRmVM2oNGDRbGpGIFg77aRxRapFZa8SnUgs2AqzuzKiprVH5i0S0M6dWr\n' +
        'i+kk5epmTtkiDHceX+dP/0R1NcnkCPoQ9TglyXyPdUdTPPRfKCq12dftqll+u4mV\n' +
        'ARdN6WFjovxax8EAP2OAUTi1afY+1JFMj+sCAwEAAaNmMGQwDgYDVR0PAQH/BAQD\n' +
        'AgEGMBIGA1UdEwEB/wQIMAYBAf8CAQAwHQYDVR0OBBYEFLfhrbrO5exkCVgxW0x3\n' +
        'Y2mAi8lNMB8GA1UdIwQYMBaAFHNfYNi8ywOY9CsXNC42WqZg/7wfMA0GCSqGSIb3\n' +
        'DQEBCwUAA4IBAQAigQ5VBNGyw+OZFXwxeJEAUYaXVoP/qrhTOJ6mCE2DXUVEoJeV\n' +
        'SxScy/TlFA9tJXqmit8JH8VQ/xDL4ubBfeMFAIAo4WzNWDVoeVMqphVEcDWBHsI1\n' +
        'AETWzfsapRS9yQekOMmxg63d/nV8xewIl8aNVTHdHYXMqhhik47VrmaVEok1UQb3\n' +
        'O971RadLXIEbVd9tjY5bMEHm89JsZDnDEw1hQXBb67Elu64OOxoKaHBgUH8AZn/2\n' +
        'zFsL1ynNUjOhCSAA15pgd1vjwc0YsBbAEBPcHBWYBEyME6NLNarjOzBl4FMtATSF\n' +
        'wWCKRGkvqN8oxYhwR2jf2rR5Mu4DWkK5Q8Ep\n' +
        '-----END CERTIFICATE-----\n',
    '-----BEGIN CERTIFICATE-----\n' +
        'MIIEBzCCAu+gAwIBAgICJVUwDQYJKoZIhvcNAQELBQAwgY8xCzAJBgNVBAYTAlVT\n' +
        'MRAwDgYDVQQHDAdTZWF0dGxlMRMwEQYDVQQIDApXYXNoaW5ndG9uMSIwIAYDVQQK\n' +
        'DBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMuMRMwEQYDVQQLDApBbWF6b24gUkRT\n' +
        'MSAwHgYDVQQDDBdBbWF6b24gUkRTIFJvb3QgMjAxOSBDQTAeFw0xOTA5MTkxODE2\n' +
        'NTNaFw0yNDA4MjIxNzA4NTBaMIGUMQswCQYDVQQGEwJVUzETMBEGA1UECAwKV2Fz\n' +
        'aGluZ3RvbjEQMA4GA1UEBwwHU2VhdHRsZTEiMCAGA1UECgwZQW1hem9uIFdlYiBT\n' +
        'ZXJ2aWNlcywgSW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzElMCMGA1UEAwwcQW1h\n' +
        'em9uIFJEUyB1cy1lYXN0LTEgMjAxOSBDQTCCASIwDQYJKoZIhvcNAQEBBQADggEP\n' +
        'ADCCAQoCggEBAM3i/k2u6cqbMdcISGRvh+m+L0yaSIoOXjtpNEoIftAipTUYoMhL\n' +
        'InXGlQBVA4shkekxp1N7HXe1Y/iMaPEyb3n+16pf3vdjKl7kaSkIhjdUz3oVUEYt\n' +
        'i8Z/XeJJ9H2aEGuiZh3kHixQcZczn8cg3dA9aeeyLSEnTkl/npzLf//669Ammyhs\n' +
        'XcAo58yvT0D4E0D/EEHf2N7HRX7j/TlyWvw/39SW0usiCrHPKDLxByLojxLdHzso\n' +
        'QIp/S04m+eWn6rmD+uUiRteN1hI5ncQiA3wo4G37mHnUEKo6TtTUh+sd/ku6a8HK\n' +
        'glMBcgqudDI90s1OpuIAWmuWpY//8xEG2YECAwEAAaNmMGQwDgYDVR0PAQH/BAQD\n' +
        'AgEGMBIGA1UdEwEB/wQIMAYBAf8CAQAwHQYDVR0OBBYEFPqhoWZcrVY9mU7tuemR\n' +
        'RBnQIj1jMB8GA1UdIwQYMBaAFHNfYNi8ywOY9CsXNC42WqZg/7wfMA0GCSqGSIb3\n' +
        'DQEBCwUAA4IBAQB6zOLZ+YINEs72heHIWlPZ8c6WY8MDU+Be5w1M+BK2kpcVhCUK\n' +
        'PJO4nMXpgamEX8DIiaO7emsunwJzMSvavSPRnxXXTKIc0i/g1EbiDjnYX9d85DkC\n' +
        'E1LaAUCmCZBVi9fIe0H2r9whIh4uLWZA41oMnJx/MOmo3XyMfQoWcqaSFlMqfZM4\n' +
        '0rNoB/tdHLNuV4eIdaw2mlHxdWDtF4oH+HFm+2cVBUVC1jXKrFv/euRVtsTT+A6i\n' +
        'h2XBHKxQ1Y4HgAn0jACP2QSPEmuoQEIa57bEKEcZsBR8SDY6ZdTd2HLRIApcCOSF\n' +
        'MRM8CKLeF658I0XgF8D5EsYoKPsA+74Z+jDH\n' +
        '-----END CERTIFICATE-----\n',
    '-----BEGIN CERTIFICATE-----\n' +
        'MIIEETCCAvmgAwIBAgICEAAwDQYJKoZIhvcNAQELBQAwgZQxCzAJBgNVBAYTAlVT\n' +
        'MRAwDgYDVQQHDAdTZWF0dGxlMRMwEQYDVQQIDApXYXNoaW5ndG9uMSIwIAYDVQQK\n' +
        'DBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMuMRMwEQYDVQQLDApBbWF6b24gUkRT\n' +
        'MSUwIwYDVQQDDBxBbWF6b24gUkRTIEJldGEgUm9vdCAyMDE5IENBMB4XDTE5MDgy\n' +
        'MDE3MTAwN1oXDTI0MDgxOTE3MzgyNlowgZkxCzAJBgNVBAYTAlVTMRMwEQYDVQQI\n' +
        'DApXYXNoaW5ndG9uMRAwDgYDVQQHDAdTZWF0dGxlMSIwIAYDVQQKDBlBbWF6b24g\n' +
        'V2ViIFNlcnZpY2VzLCBJbmMuMRMwEQYDVQQLDApBbWF6b24gUkRTMSowKAYDVQQD\n' +
        'DCFBbWF6b24gUkRTIEJldGEgdXMtZWFzdC0xIDIwMTkgQ0EwggEiMA0GCSqGSIb3\n' +
        'DQEBAQUAA4IBDwAwggEKAoIBAQDTNCOlotQcLP8TP82U2+nk0bExVuuMVOgFeVMx\n' +
        'vbUHZQeIj9ikjk+jm6eTDnnkhoZcmJiJgRy+5Jt69QcRbb3y3SAU7VoHgtraVbxF\n' +
        'QDh7JEHI9tqEEVOA5OvRrDRcyeEYBoTDgh76ROco2lR+/9uCvGtHVrMCtG7BP7ZB\n' +
        'sSVNAr1IIRZZqKLv2skKT/7mzZR2ivcw9UeBBTUf8xsfiYVBvMGoEsXEycjYdf6w\n' +
        'WV+7XS7teNOc9UgsFNN+9AhIBc1jvee5E//72/4F8pAttAg/+mmPUyIKtekNJ4gj\n' +
        'OAR2VAzGx1ybzWPwIgOudZFHXFduxvq4f1hIRPH0KbQ/gkRrAgMBAAGjZjBkMA4G\n' +
        'A1UdDwEB/wQEAwIBBjASBgNVHRMBAf8ECDAGAQH/AgEAMB0GA1UdDgQWBBTkvpCD\n' +
        '6C43rar9TtJoXr7q8dkrrjAfBgNVHSMEGDAWgBStoQwVpbGx87fxB3dEGDqKKnBT\n' +
        '4TANBgkqhkiG9w0BAQsFAAOCAQEAJd9fOSkwB3uVdsS+puj6gCER8jqmhd3g/J5V\n' +
        'Zjk9cKS8H0e8pq/tMxeJ8kpurPAzUk5RkCspGt2l0BSwmf3ahr8aJRviMX6AuW3/\n' +
        'g8aKplTvq/WMNGKLXONa3Sq8591J+ce8gtOX/1rDKmFI4wQ/gUzOSYiT991m7QKS\n' +
        'Fr6HMgFuz7RNJbb3Fy5cnurh8eYWA7mMv7laiLwTNsaro5qsqErD5uXuot6o9beT\n' +
        'a+GiKinEur35tNxAr47ax4IRubuIzyfCrezjfKc5raVV2NURJDyKP0m0CCaffAxE\n' +
        'qn2dNfYc3v1D8ypg3XjHlOzRo32RB04o8ALHMD9LSwsYDLpMag==\n' +
        '-----END CERTIFICATE-----\n',
    '-----BEGIN CERTIFICATE-----\n' +
        'MIIEFzCCAv+gAwIBAgICFSUwDQYJKoZIhvcNAQELBQAwgZcxCzAJBgNVBAYTAlVT\n' +
        'MRAwDgYDVQQHDAdTZWF0dGxlMRMwEQYDVQQIDApXYXNoaW5ndG9uMSIwIAYDVQQK\n' +
        'DBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMuMRMwEQYDVQQLDApBbWF6b24gUkRT\n' +
        'MSgwJgYDVQQDDB9BbWF6b24gUkRTIFByZXZpZXcgUm9vdCAyMDE5IENBMB4XDTE5\n' +
        'MDgyMTIyMzk0N1oXDTI0MDgyMTIyMjk0OVowgZwxCzAJBgNVBAYTAlVTMRMwEQYD\n' +
        'VQQIDApXYXNoaW5ndG9uMRAwDgYDVQQHDAdTZWF0dGxlMSIwIAYDVQQKDBlBbWF6\n' +
        'b24gV2ViIFNlcnZpY2VzLCBJbmMuMRMwEQYDVQQLDApBbWF6b24gUkRTMS0wKwYD\n' +
        'VQQDDCRBbWF6b24gUkRTIFByZXZpZXcgdXMtZWFzdC0yIDIwMTkgQ0EwggEiMA0G\n' +
        'CSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQD0dB/U7qRnSf05wOi7m10Pa2uPMTJv\n' +
        'r6U/3Y17a5prq5Zr4++CnSUYarG51YuIf355dKs+7Lpzs782PIwCmLpzAHKWzix6\n' +
        'pOaTQ+WZ0+vUMTxyqgqWbsBgSCyP7pVBiyqnmLC/L4az9XnscrbAX4pNaoJxsuQe\n' +
        'mzBo6yofjQaAzCX69DuqxFkVTRQnVy7LCFkVaZtjNAftnAHJjVgQw7lIhdGZp9q9\n' +
        'IafRt2gteihYfpn+EAQ/t/E4MnhrYs4CPLfS7BaYXBycEKC5Muj1l4GijNNQ0Efo\n' +
        'xG8LSZz7SNgUvfVwiNTaqfLP3AtEAWiqxyMyh3VO+1HpCjT7uNBFtmF3AgMBAAGj\n' +
        'ZjBkMA4GA1UdDwEB/wQEAwIBBjASBgNVHRMBAf8ECDAGAQH/AgEAMB0GA1UdDgQW\n' +
        'BBQtinkdrj+0B2+qdXngV2tgHnPIujAfBgNVHSMEGDAWgBRp0xqULkNh/w2ZVzEI\n' +
        'o2RIY7O03TANBgkqhkiG9w0BAQsFAAOCAQEAtJdqbCxDeMc8VN1/RzCabw9BIL/z\n' +
        '73Auh8eFTww/sup26yn8NWUkfbckeDYr1BrXa+rPyLfHpg06kwR8rBKyrs5mHwJx\n' +
        'bvOzXD/5WTdgreB+2Fb7mXNvWhenYuji1MF+q1R2DXV3I05zWHteKX6Dajmx+Uuq\n' +
        'Yq78oaCBSV48hMxWlp8fm40ANCL1+gzQ122xweMFN09FmNYFhwuW+Ao+Vv90ZfQG\n' +
        'PYwTvN4n/gegw2TYcifGZC2PNX74q3DH03DXe5fvNgRW5plgz/7f+9mS+YHd5qa9\n' +
        'tYTPUvoRbi169ou6jicsMKUKPORHWhiTpSCWR1FMMIbsAcsyrvtIsuaGCQ==\n' +
        '-----END CERTIFICATE-----\n',
    '-----BEGIN CERTIFICATE-----\n' +
        'MIID/jCCAuagAwIBAgIQdOCSuA9psBpQd8EI368/0DANBgkqhkiG9w0BAQsFADCB\n' +
        'lzELMAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIElu\n' +
        'Yy4xEzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTAwLgYDVQQDDCdB\n' +
        'bWF6b24gUkRTIHNhLWVhc3QtMSBSb290IENBIFJTQTIwNDggRzExEDAOBgNVBAcM\n' +
        'B1NlYXR0bGUwIBcNMjEwNTE5MTgwNjI2WhgPMjA2MTA1MTkxOTA2MjZaMIGXMQsw\n' +
        'CQYDVQQGEwJVUzEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywgSW5jLjET\n' +
        'MBEGA1UECwwKQW1hem9uIFJEUzELMAkGA1UECAwCV0ExMDAuBgNVBAMMJ0FtYXpv\n' +
        'biBSRFMgc2EtZWFzdC0xIFJvb3QgQ0EgUlNBMjA0OCBHMTEQMA4GA1UEBwwHU2Vh\n' +
        'dHRsZTCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBAN6ftL6w8v3dB2yW\n' +
        'LjCxSP1D7ZsOTeLZOSCz1Zv0Gkd0XLhil5MdHOHBvwH/DrXqFU2oGzCRuAy+aZis\n' +
        'DardJU6ChyIQIciXCO37f0K23edhtpXuruTLLwUwzeEPdcnLPCX+sWEn9Y5FPnVm\n' +
        'pCd6J8edH2IfSGoa9LdErkpuESXdidLym/w0tWG/O2By4TabkNSmpdrCL00cqI+c\n' +
        'prA8Bx1jX8/9sY0gpAovtuFaRN+Ivg3PAnWuhqiSYyQ5nC2qDparOWuDiOhpY56E\n' +
        'EgmTvjwqMMjNtExfYx6Rv2Ndu50TriiNKEZBzEtkekwXInTupmYTvc7U83P/959V\n' +
        'UiQ+WSMCAwEAAaNCMEAwDwYDVR0TAQH/BAUwAwEB/zAdBgNVHQ4EFgQU4uYHdH0+\n' +
        'bUeh81Eq2l5/RJbW+vswDgYDVR0PAQH/BAQDAgGGMA0GCSqGSIb3DQEBCwUAA4IB\n' +
        'AQBhxcExJ+w74bvDknrPZDRgTeMLYgbVJjx2ExH7/Ac5FZZWcpUpFwWMIJJxtewI\n' +
        'AnhryzM3tQYYd4CG9O+Iu0+h/VVfW7e4O3joWVkxNMb820kQSEwvZfA78aItGwOY\n' +
        'WSaFNVRyloVicZRNJSyb1UL9EiJ9ldhxm4LTT0ax+4ontI7zTx6n6h8Sr6r/UOvX\n' +
        'd9T5aUUENWeo6M9jGupHNn3BobtL7BZm2oS8wX8IVYj4tl0q5T89zDi2x0MxbsIV\n' +
        '5ZjwqBQ5JWKv7ASGPb+z286RjPA9R2knF4lJVZrYuNV90rHvI/ECyt/JrDqeljGL\n' +
        'BLl1W/UsvZo6ldLIpoMbbrb5\n' +
        '-----END CERTIFICATE-----\n',
    '-----BEGIN CERTIFICATE-----\n' +
        'MIIEBDCCAuygAwIBAgIQUfVbqapkLYpUqcLajpTJWzANBgkqhkiG9w0BAQsFADCB\n' +
        'mjELMAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIElu\n' +
        'Yy4xEzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTMwMQYDVQQDDCpB\n' +
        'bWF6b24gUkRTIG1lLWNlbnRyYWwtMSBSb290IENBIFJTQTIwNDggRzExEDAOBgNV\n' +
        'BAcMB1NlYXR0bGUwIBcNMjIwNTA2MjMyMDA5WhgPMjA2MjA1MDcwMDIwMDlaMIGa\n' +
        'MQswCQYDVQQGEwJVUzEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywgSW5j\n' +
        'LjETMBEGA1UECwwKQW1hem9uIFJEUzELMAkGA1UECAwCV0ExMzAxBgNVBAMMKkFt\n' +
        'YXpvbiBSRFMgbWUtY2VudHJhbC0xIFJvb3QgQ0EgUlNBMjA0OCBHMTEQMA4GA1UE\n' +
        'BwwHU2VhdHRsZTCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBAJIeovu3\n' +
        'ewI9FVitXMQzvkh34aQ6WyI4NO3YepfJaePiv3cnyFGYHN2S1cR3UQcLWgypP5va\n' +
        'j6bfroqwGbCbZZcb+6cyOB4ceKO9Ws1UkcaGHnNDcy5gXR7aCW2OGTUfinUuhd2d\n' +
        '5bOGgV7JsPbpw0bwJ156+MwfOK40OLCWVbzy8B1kITs4RUPNa/ZJnvIbiMu9rdj4\n' +
        '8y7GSFJLnKCjlOFUkNI5LcaYvI1+ybuNgphT3nuu5ZirvTswGakGUT/Q0J3dxP0J\n' +
        'pDfg5Sj/2G4gXiaM0LppVOoU5yEwVewhQ250l0eQAqSrwPqAkdTg9ng360zqCFPE\n' +
        'JPPcgI1tdGUgneECAwEAAaNCMEAwDwYDVR0TAQH/BAUwAwEB/zAdBgNVHQ4EFgQU\n' +
        '/2AJVxWdZxc8eJgdpbwpW7b0f7IwDgYDVR0PAQH/BAQDAgGGMA0GCSqGSIb3DQEB\n' +
        'CwUAA4IBAQBYm63jTu2qYKJ94gKnqc+oUgqmb1mTXmgmp/lXDbxonjszJDOXFbri\n' +
        '3CCO7xB2sg9bd5YWY8sGKHaWmENj3FZpCmoefbUx++8D7Mny95Cz8R32rNcwsPTl\n' +
        'ebpd9A/Oaw5ug6M0x/cNr0qzF8Wk9Dx+nFEimp8RYQdKvLDfNFZHjPa1itnTiD8M\n' +
        'TorAqj+VwnUGHOYBsT/0NY12tnwXdD+ATWfpEHdOXV+kTMqFFwDyhfgRVNpTc+os\n' +
        'ygr8SwhnSCpJPB/EYl2S7r+tgAbJOkuwUvGT4pTqrzDQEhwE7swgepnHC87zhf6l\n' +
        'qN6mVpSnQKQLm6Ob5TeCEFgcyElsF5bH\n' +
        '-----END CERTIFICATE-----\n',
    '-----BEGIN CERTIFICATE-----\n' +
        'MIICrjCCAjSgAwIBAgIRAOxu0I1QuMAhIeszB3fJIlkwCgYIKoZIzj0EAwMwgZYx\n' +
        'CzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMu\n' +
        'MRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTEvMC0GA1UEAwwmQW1h\n' +
        'em9uIFJEUyB1cy13ZXN0LTIgUm9vdCBDQSBFQ0MzODQgRzExEDAOBgNVBAcMB1Nl\n' +
        'YXR0bGUwIBcNMjEwNTI0MjIwNjU5WhgPMjEyMTA1MjQyMzA2NTlaMIGWMQswCQYD\n' +
        'VQQGEwJVUzEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywgSW5jLjETMBEG\n' +
        'A1UECwwKQW1hem9uIFJEUzELMAkGA1UECAwCV0ExLzAtBgNVBAMMJkFtYXpvbiBS\n' +
        'RFMgdXMtd2VzdC0yIFJvb3QgQ0EgRUNDMzg0IEcxMRAwDgYDVQQHDAdTZWF0dGxl\n' +
        'MHYwEAYHKoZIzj0CAQYFK4EEACIDYgAEz4bylRcGqqDWdP7gQIIoTHdBK6FNtKH1\n' +
        '4SkEIXRXkYDmRvL9Bci1MuGrwuvrka5TDj4b7e+csY0llEzHpKfq6nJPFljoYYP9\n' +
        'uqHFkv77nOpJJ633KOr8IxmeHW5RXgrZo0IwQDAPBgNVHRMBAf8EBTADAQH/MB0G\n' +
        'A1UdDgQWBBQQikVz8wmjd9eDFRXzBIU8OseiGzAOBgNVHQ8BAf8EBAMCAYYwCgYI\n' +
        'KoZIzj0EAwMDaAAwZQIwf06Mcrpw1O0EBLBBrp84m37NYtOkE/0Z0O+C7D41wnXi\n' +
        'EQdn6PXUVgdD23Gj82SrAjEAklhKs+liO1PtN15yeZR1Io98nFve+lLptaLakZcH\n' +
        '+hfFuUtCqMbaI8CdvJlKnPqT\n' +
        '-----END CERTIFICATE-----\n',
    '-----BEGIN CERTIFICATE-----\n' +
        'MIIGCTCCA/GgAwIBAgIRALyWMTyCebLZOGcZZQmkmfcwDQYJKoZIhvcNAQEMBQAw\n' +
        'gZwxCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJ\n' +
        'bmMuMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTE1MDMGA1UEAwws\n' +
        'QW1hem9uIFJEUyBhcC1ub3J0aGVhc3QtMyBSb290IENBIFJTQTQwOTYgRzExEDAO\n' +
        'BgNVBAcMB1NlYXR0bGUwIBcNMjEwNTI0MjAyODAzWhgPMjEyMTA1MjQyMTI4MDNa\n' +
        'MIGcMQswCQYDVQQGEwJVUzEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywg\n' +
        'SW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzELMAkGA1UECAwCV0ExNTAzBgNVBAMM\n' +
        'LEFtYXpvbiBSRFMgYXAtbm9ydGhlYXN0LTMgUm9vdCBDQSBSU0E0MDk2IEcxMRAw\n' +
        'DgYDVQQHDAdTZWF0dGxlMIICIjANBgkqhkiG9w0BAQEFAAOCAg8AMIICCgKCAgEA\n' +
        'wGFiyDyCrGqgdn4fXG12cxKAAfVvhMea1mw5h9CVRoavkPqhzQpAitSOuMB9DeiP\n' +
        'wQyqcsiGl/cTEau4L+AUBG8b9v26RlY48exUYBXj8CieYntOT9iNw5WtdYJa3kF/\n' +
        'JxgI+HDMzE9cmHDs5DOO3S0uwZVyra/xE1ymfSlpOeUIOTpHRJv97CBUEpaZMUW5\n' +
        'Sr6GruuOwFVpO5FX3A/jQlcS+UN4GjSRgDUJuqg6RRQldEZGCVCCmodbByvI2fGm\n' +
        'reGpsPJD54KkmAX08nOR8e5hkGoHxq0m2DLD4SrOFmt65vG47qnuwplWJjtk9B3Z\n' +
        '9wDoopwZLBOtlkPIkUllWm1P8EuHC1IKOA+wSP6XdT7cy8S77wgyHzR0ynxv7q/l\n' +
        'vlZtH30wnNqFI0y9FeogD0TGMCHcnGqfBSicJXPy9T4fU6f0r1HwqKwPp2GArwe7\n' +
        'dnqLTj2D7M9MyVtFjEs6gfGWXmu1y5uDrf+CszurE8Cycoma+OfjjuVQgWOCy7Nd\n' +
        'jJswPxAroTzVfpgoxXza4ShUY10woZu0/J+HmNmqK7lh4NS75q1tz75in8uTZDkV\n' +
        'be7GK+SEusTrRgcf3tlgPjSTWG3veNzFDF2Vn1GLJXmuZfhdlVQDBNXW4MNREExS\n' +
        'dG57kJjICpT+r8X+si+5j51gRzkSnMYs7VHulpxfcwECAwEAAaNCMEAwDwYDVR0T\n' +
        'AQH/BAUwAwEB/zAdBgNVHQ4EFgQU4JWOpDBmUBuWKvGPZelw87ezhL8wDgYDVR0P\n' +
        'AQH/BAQDAgGGMA0GCSqGSIb3DQEBDAUAA4ICAQBRNLMql7itvXSEFQRAnyOjivHz\n' +
        'l5IlWVQjAbOUr6ogZcwvK6YpxNAFW5zQr8F+fdkiypLz1kk5irx9TIpff0BWC9hQ\n' +
        '/odMPO8Gxn8+COlSvc+dLsF2Dax3Hvz0zLeKMo+cYisJOzpdR/eKd0/AmFdkvQoM\n' +
        'AOK9n0yYvVJU2IrSgeJBiiCarpKSeAktEVQ4rvyacQGr+QAPkkjRwm+5LHZKK43W\n' +
        'nNnggRli9N/27qYtc5bgr3AaQEhEXMI4RxPRXCLsod0ehMGWyRRK728a+6PMMJAJ\n' +
        'WHOU0x7LCEMPP/bvpLj3BdvSGqNor4ZtyXEbwREry1uzsgODeRRns5acPwTM6ff+\n' +
        'CmxO2NZ0OktIUSYRmf6H/ZFlZrIhV8uWaIwEJDz71qvj7buhQ+RFDZ9CNL64C0X6\n' +
        'mf0zJGEpddjANHaaVky+F4gYMtEy2K2Lcm4JGTdyIzUoIe+atzCnRp0QeIcuWtF+\n' +
        's8AjDYCVFNypcMmqbRmNpITSnOoCHSRuVkY3gutVoYyMLbp8Jm9SJnCIlEWTA6Rm\n' +
        'wADOMGZJVn5/XRTRuetVOB3KlQDjs9OO01XN5NzGSZO2KT9ngAUfh9Eqhf1iRWSP\n' +
        'nZlRbQ2NRCuY/oJ5N59mLGxnNJSE7giEKEBRhTQ/XEPIUYAUPD5fca0arKRJwbol\n' +
        'l9Se1Hsq0ZU5f+OZKQ==\n' +
        '-----END CERTIFICATE-----\n',
    '-----BEGIN CERTIFICATE-----\n' +
        'MIIGATCCA+mgAwIBAgIRAK7vlRrGVEePJpW1VHMXdlIwDQYJKoZIhvcNAQEMBQAw\n' +
        'gZgxCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJ\n' +
        'bmMuMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTExMC8GA1UEAwwo\n' +
        'QW1hem9uIFJEUyBhZi1zb3V0aC0xIFJvb3QgQ0EgUlNBNDA5NiBHMTEQMA4GA1UE\n' +
        'BwwHU2VhdHRsZTAgFw0yMTA1MTkxOTI4NDNaGA8yMTIxMDUxOTIwMjg0M1owgZgx\n' +
        'CzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMu\n' +
        'MRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTExMC8GA1UEAwwoQW1h\n' +
        'em9uIFJEUyBhZi1zb3V0aC0xIFJvb3QgQ0EgUlNBNDA5NiBHMTEQMA4GA1UEBwwH\n' +
        'U2VhdHRsZTCCAiIwDQYJKoZIhvcNAQEBBQADggIPADCCAgoCggIBAMZiHOQC6x4o\n' +
        'eC7vVOMCGiN5EuLqPYHdceFPm4h5k/ZejXTf7kryk6aoKZKsDIYihkaZwXVS7Y/y\n' +
        '7Ig1F1ABi2jD+CYprj7WxXbhpysmN+CKG7YC3uE4jSvfvUnpzionkQbjJsRJcrPO\n' +
        'cZJM4FVaVp3mlHHtvnM+K3T+ni4a38nAd8xrv1na4+B8ZzZwWZXarfg8lJoGskSn\n' +
        'ou+3rbGQ0r+XlUP03zWujHoNlVK85qUIQvDfTB7n3O4s1XNGvkfv3GNBhYRWJYlB\n' +
        '4p8T+PFN8wG+UOByp1gV7BD64RnpuZ8V3dRAlO6YVAmINyG5UGrPzkIbLtErUNHO\n' +
        '4iSp4UqYvztDqJWWHR/rA84ef+I9RVwwZ8FQbjKq96OTnPrsr63A5mXTC9dXKtbw\n' +
        'XNJPQY//FEdyM3K8sqM0IdCzxCA1MXZ8+QapWVjwyTjUwFvL69HYky9H8eAER59K\n' +
        '5I7u/CWWeCy2R1SYUBINc3xxLr0CGGukcWPEZW2aPo5ibW5kepU1P/pzdMTaTfao\n' +
        'F42jSFXbc7gplLcSqUgWwzBnn35HLTbiZOFBPKf6vRRu8aRX9atgHw/EjCebi2xP\n' +
        'xIYr5Ub8u0QVHIqcnF1/hVzO/Xz0chj3E6VF/yTXnsakm+W1aM2QkZbFGpga+LMy\n' +
        'mFCtdPrELjea2CfxgibaJX1Q4rdEpc8DAgMBAAGjQjBAMA8GA1UdEwEB/wQFMAMB\n' +
        'Af8wHQYDVR0OBBYEFDSaycEyuspo/NOuzlzblui8KotFMA4GA1UdDwEB/wQEAwIB\n' +
        'hjANBgkqhkiG9w0BAQwFAAOCAgEAbosemjeTRsL9o4v0KadBUNS3V7gdAH+X4vH2\n' +
        'Ee1Jc91VOGLdd/s1L9UX6bhe37b9WjUD69ur657wDW0RzxMYgQdZ27SUl0tEgGGp\n' +
        'cCmVs1ky3zEN+Hwnhkz+OTmIg1ufq0W2hJgJiluAx2r1ib1GB+YI3Mo3rXSaBYUk\n' +
        'bgQuujYPctf0PA153RkeICE5GI3OaJ7u6j0caYEixBS3PDHt2MJWexITvXGwHWwc\n' +
        'CcrC05RIrTUNOJaetQw8smVKYOfRImEzLLPZ5kf/H3Cbj8BNAFNsa10wgvlPuGOW\n' +
        'XLXqzNXzrG4V3sjQU5YtisDMagwYaN3a6bBf1wFwFIHQoAPIgt8q5zaQ9WI+SBns\n' +
        'Il6rd4zfvjq/BPmt0uI7rVg/cgbaEg/JDL2neuM9CJAzmKxYxLQuHSX2i3Fy4Y1B\n' +
        'cnxnRQETCRZNPGd00ADyxPKVoYBC45/t+yVusArFt+2SVLEGiFBr23eG2CEZu+HS\n' +
        'nDEgIfQ4V3YOTUNa86wvbAss1gbbnT/v1XCnNGClEWCWNCSRjwV2ZmQ/IVTmNHPo\n' +
        '7axTTBBJbKJbKzFndCnuxnDXyytdYRgFU7Ly3sa27WS2KFyFEDebLFRHQEfoYqCu\n' +
        'IupSqBSbXsR3U10OTjc9z6EPo1nuV6bdz+gEDthmxKa1NI+Qb1kvyliXQHL2lfhr\n' +
        '5zT5+Bs=\n' +
        '-----END CERTIFICATE-----\n',
    '-----BEGIN CERTIFICATE-----\n' +
        'MIIF/zCCA+egAwIBAgIRAOLV6zZcL4IV2xmEneN1GwswDQYJKoZIhvcNAQEMBQAw\n' +
        'gZcxCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJ\n' +
        'bmMuMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTEwMC4GA1UEAwwn\n' +
        'QW1hem9uIFJEUyB1cy13ZXN0LTEgUm9vdCBDQSBSU0E0MDk2IEcxMRAwDgYDVQQH\n' +
        'DAdTZWF0dGxlMCAXDTIxMDUxOTE5MDg1OFoYDzIxMjEwNTE5MjAwODU4WjCBlzEL\n' +
        'MAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4x\n' +
        'EzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTAwLgYDVQQDDCdBbWF6\n' +
        'b24gUkRTIHVzLXdlc3QtMSBSb290IENBIFJTQTQwOTYgRzExEDAOBgNVBAcMB1Nl\n' +
        'YXR0bGUwggIiMA0GCSqGSIb3DQEBAQUAA4ICDwAwggIKAoICAQC7koAKGXXlLixN\n' +
        'fVjhuqvz0WxDeTQfhthPK60ekRpftkfE5QtnYGzeovaUAiS58MYVzqnnTACDwcJs\n' +
        'IGTFE6Wd7sB6r8eI/3CwI1pyJfxepubiQNVAQG0zJETOVkoYKe/5KnteKtnEER3X\n' +
        'tCBRdV/rfbxEDG9ZAsYfMl6zzhEWKF88G6xhs2+VZpDqwJNNALvQuzmTx8BNbl5W\n' +
        'RUWGq9CQ9GK9GPF570YPCuURW7kl35skofudE9bhURNz51pNoNtk2Z3aEeRx3ouT\n' +
        'ifFJlzh+xGJRHqBG7nt5NhX8xbg+vw4xHCeq1aAe6aVFJ3Uf9E2HzLB4SfIT9bRp\n' +
        'P7c9c0ySGt+3n+KLSHFf/iQ3E4nft75JdPjeSt0dnyChi1sEKDi0tnWGiXaIg+J+\n' +
        'r1ZtcHiyYpCB7l29QYMAdD0TjfDwwPayLmq//c20cPmnSzw271VwqjUT0jYdrNAm\n' +
        'gV+JfW9t4ixtE3xF2jaUh/NzL3bAmN5v8+9k/aqPXlU1BgE3uPwMCjrfn7V0I7I1\n' +
        'WLpHyd9jF3U/Ysci6H6i8YKgaPiOfySimQiDu1idmPld659qerutUSemQWmPD3bE\n' +
        'dcjZolmzS9U0Ujq/jDF1YayN3G3xvry1qWkTci0qMRMu2dZu30Herugh9vsdTYkf\n' +
        '00EqngPbqtIVLDrDjEQLqPcb8QvWFQIDAQABo0IwQDAPBgNVHRMBAf8EBTADAQH/\n' +
        'MB0GA1UdDgQWBBQBqg8Za/L0YMHURGExHfvPyfLbOTAOBgNVHQ8BAf8EBAMCAYYw\n' +
        'DQYJKoZIhvcNAQEMBQADggIBACAGPMa1QL7P/FIO7jEtMelJ0hQlQepKnGtbKz4r\n' +
        'Xq1bUX1jnLvnAieR9KZmeQVuKi3g3CDU6b0mDgygS+FL1KDDcGRCSPh238Ou8KcG\n' +
        'HIxtt3CMwMHMa9gmdcMlR5fJF9vhR0C56KM2zvyelUY51B/HJqHwGvWuexryXUKa\n' +
        'wq1/iK2/d9mNeOcjDvEIj0RCMI8dFQCJv3PRCTC36XS36Tzr6F47TcTw1c3mgKcs\n' +
        'xpcwt7ezrXMUunzHS4qWAA5OGdzhYlcv+P5GW7iAA7TDNrBF+3W4a/6s9v2nQAnX\n' +
        'UvXd9ul0ob71377UhZbJ6SOMY56+I9cJOOfF5QvaL83Sz29Ij1EKYw/s8TYdVqAq\n' +
        '+dCyQZBkMSnDFLVe3J1KH2SUSfm3O98jdPORQrUlORQVYCHPls19l2F6lCmU7ICK\n' +
        'hRt8EVSpXm4sAIA7zcnR2nU00UH8YmMQLnx5ok9YGhuh3Ehk6QlTQLJux6LYLskd\n' +
        '9YHOLGW/t6knVtV78DgPqDeEx/Wu/5A8R0q7HunpWxr8LCPBK6hksZnOoUhhb8IP\n' +
        'vl46Ve5Tv/FlkyYr1RTVjETmg7lb16a8J0At14iLtpZWmwmuv4agss/1iBVMXfFk\n' +
        '+ZGtx5vytWU5XJmsfKA51KLsMQnhrLxb3X3zC+JRCyJoyc8++F3YEcRi2pkRYE3q\n' +
        'Hing\n' +
        '-----END CERTIFICATE-----\n',
    '-----BEGIN CERTIFICATE-----\n' +
        'MIIECTCCAvGgAwIBAgIRANxgyBbnxgTEOpDul2ZnC0UwDQYJKoZIhvcNAQELBQAw\n' +
        'gZwxCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJ\n' +
        'bmMuMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTE1MDMGA1UEAwws\n' +
        'QW1hem9uIFJEUyBhcC1zb3V0aGVhc3QtMyBSb290IENBIFJTQTIwNDggRzExEDAO\n' +
        'BgNVBAcMB1NlYXR0bGUwIBcNMjEwNjEwMTgxOTA3WhgPMjA2MTA2MTAxOTE5MDda\n' +
        'MIGcMQswCQYDVQQGEwJVUzEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywg\n' +
        'SW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzELMAkGA1UECAwCV0ExNTAzBgNVBAMM\n' +
        'LEFtYXpvbiBSRFMgYXAtc291dGhlYXN0LTMgUm9vdCBDQSBSU0EyMDQ4IEcxMRAw\n' +
        'DgYDVQQHDAdTZWF0dGxlMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA\n' +
        'xnwSDAChrMkfk5TA4Dk8hKzStDlSlONzmd3fTG0Wqr5+x3EmFT6Ksiu/WIwEl9J2\n' +
        'K98UI7vYyuZfCxUKb1iMPeBdVGqk0zb92GpURd+Iz/+K1ps9ZLeGBkzR8mBmAi1S\n' +
        'OfpwKiTBzIv6E8twhEn4IUpHsdcuX/2Y78uESpJyM8O5CpkG0JaV9FNEbDkJeBUQ\n' +
        'Ao2qqNcH4R0Qcr5pyeqA9Zto1RswgL06BQMI9dTpfwSP5VvkvcNUaLl7Zv5WzLQE\n' +
        'JzORWePvdPzzvWEkY/3FPjxBypuYwssKaERW0fkPDmPtykktP9W/oJolKUFI6pXp\n' +
        'y+Y6p6/AVdnQD2zZjW5FhQIDAQABo0IwQDAPBgNVHRMBAf8EBTADAQH/MB0GA1Ud\n' +
        'DgQWBBT+jEKs96LC+/X4BZkUYUkzPfXdqTAOBgNVHQ8BAf8EBAMCAYYwDQYJKoZI\n' +
        'hvcNAQELBQADggEBAIGQqgqcQ6XSGkmNebzR6DhadTbfDmbYeN5N0Vuzv+Tdmufb\n' +
        'tMGjdjnYMg4B+IVnTKQb+Ox3pL9gbX6KglGK8HupobmIRtwKVth+gYYz3m0SL/Nk\n' +
        'haWPYzOm0x3tJm8jSdufJcEob4/ATce9JwseLl76pSWdl5A4lLjnhPPKudUDfH+1\n' +
        'BLNUi3lxpp6GkC8aWUPtupnhZuXddolTLOuA3GwTZySI44NfaFRm+o83N1jp+EwD\n' +
        '6e94M4cTRzjUv6J3MZmSbdtQP/Tk1uz2K4bQZGP0PZC3bVpqiesdE/xr+wbu8uHr\n' +
        'cM1JXH0AmXf1yIkTgyWzmvt0k1/vgcw5ixAqvvE=\n' +
        '-----END CERTIFICATE-----\n',
    '-----BEGIN CERTIFICATE-----\n' +
        'MIIEATCCAumgAwIBAgIRAMhw98EQU18mIji+unM2YH8wDQYJKoZIhvcNAQELBQAw\n' +
        'gZgxCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJ\n' +
        'bmMuMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTExMC8GA1UEAwwo\n' +
        'QW1hem9uIFJEUyBhcC1zb3V0aC0yIFJvb3QgQ0EgUlNBMjA0OCBHMTEQMA4GA1UE\n' +
        'BwwHU2VhdHRsZTAgFw0yMjA2MDYyMTQyMjJaGA8yMDYyMDYwNjIyNDIyMlowgZgx\n' +
        'CzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMu\n' +
        'MRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTExMC8GA1UEAwwoQW1h\n' +
        'em9uIFJEUyBhcC1zb3V0aC0yIFJvb3QgQ0EgUlNBMjA0OCBHMTEQMA4GA1UEBwwH\n' +
        'U2VhdHRsZTCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBAIeeRoLfTm+7\n' +
        'vqm7ZlFSx+1/CGYHyYrOOryM4/Z3dqYVHFMgWTR7V3ziO8RZ6yUanrRcWVX3PZbF\n' +
        'AfX0KFE8OgLsXEZIX8odSrq86+/Th5eZOchB2fDBsUB7GuN2rvFBbM8lTI9ivVOU\n' +
        'lbuTnYyb55nOXN7TpmH2bK+z5c1y9RVC5iQsNAl6IJNvSN8VCqXh31eK5MlKB4DT\n' +
        '+Y3OivCrSGsjM+UR59uZmwuFB1h+icE+U0p9Ct3Mjq3MzSX5tQb6ElTNGlfmyGpW\n' +
        'Kh7GQ5XU1KaKNZXoJ37H53woNSlq56bpVrKI4uv7ATpdpFubOnSLtpsKlpLdR3sy\n' +
        'Ws245200pC8CAwEAAaNCMEAwDwYDVR0TAQH/BAUwAwEB/zAdBgNVHQ4EFgQUp0ki\n' +
        '6+eWvsnBjQhMxwMW5pwn7DgwDgYDVR0PAQH/BAQDAgGGMA0GCSqGSIb3DQEBCwUA\n' +
        'A4IBAQB2V8lv0aqbYQpj/bmVv/83QfE4vOxKCJAHv7DQ35cJsTyBdF+8pBczzi3t\n' +
        '3VNL5IUgW6WkyuUOWnE0eqAFOUVj0yTS1jSAtfl3vOOzGJZmWBbqm9BKEdu1D8O6\n' +
        'sB8bnomwiab2tNDHPmUslpdDqdabbkWwNWzLJ97oGFZ7KNODMEPXWKWNxg33iHfS\n' +
        '/nlmnrTVI3XgaNK9qLZiUrxu9Yz5gxi/1K+sG9/Dajd32ZxjRwDipOLiZbiXQrsd\n' +
        'qzIMY4GcWf3g1gHL5mCTfk7dG22h/rhPyGV0svaDnsb+hOt6sv1McMN6Y3Ou0mtM\n' +
        '/UaAXojREmJmTSCNvs2aBny3/2sy\n' +
        '-----END CERTIFICATE-----\n',
    '-----BEGIN CERTIFICATE-----\n' +
        'MIICrjCCAjSgAwIBAgIRAMnRxsKLYscJV8Qv5pWbL7swCgYIKoZIzj0EAwMwgZYx\n' +
        'CzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMu\n' +
        'MRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTEvMC0GA1UEAwwmQW1h\n' +
        'em9uIFJEUyBzYS1lYXN0LTEgUm9vdCBDQSBFQ0MzODQgRzExEDAOBgNVBAcMB1Nl\n' +
        'YXR0bGUwIBcNMjEwNTE5MTgxNjAxWhgPMjEyMTA1MTkxOTE2MDFaMIGWMQswCQYD\n' +
        'VQQGEwJVUzEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywgSW5jLjETMBEG\n' +
        'A1UECwwKQW1hem9uIFJEUzELMAkGA1UECAwCV0ExLzAtBgNVBAMMJkFtYXpvbiBS\n' +
        'RFMgc2EtZWFzdC0xIFJvb3QgQ0EgRUNDMzg0IEcxMRAwDgYDVQQHDAdTZWF0dGxl\n' +
        'MHYwEAYHKoZIzj0CAQYFK4EEACIDYgAEjFOCZgTNVKxLKhUxffiDEvTLFhrmIqdO\n' +
        'dKqVdgDoELEzIHWDdC+19aDPitbCYtBVHl65ITu/9pn6mMUl5hhUNtfZuc6A+Iw1\n' +
        'sBe0v0qI3y9Q9HdQYrGgeHDh8M5P7E2ho0IwQDAPBgNVHRMBAf8EBTADAQH/MB0G\n' +
        'A1UdDgQWBBS5L7/8M0TzoBZk39Ps7BkfTB4yJTAOBgNVHQ8BAf8EBAMCAYYwCgYI\n' +
        'KoZIzj0EAwMDaAAwZQIwI43O0NtWKTgnVv9z0LO5UMZYgSve7GvGTwqktZYCMObE\n' +
        'rUI4QerXM9D6JwLy09mqAjEAypfkdLyVWtaElVDUyHFkihAS1I1oUxaaDrynLNQK\n' +
        'Ou/Ay+ns+J+GyvyDUjBpVVW1\n' +
        '-----END CERTIFICATE-----\n',
    '-----BEGIN CERTIFICATE-----\n' +
        'MIIF/jCCA+agAwIBAgIQR71Z8lTO5Sj+as2jB7IWXzANBgkqhkiG9w0BAQwFADCB\n' +
        'lzELMAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIElu\n' +
        'Yy4xEzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTAwLgYDVQQDDCdB\n' +
        'bWF6b24gUkRTIHVzLXdlc3QtMiBSb290IENBIFJTQTQwOTYgRzExEDAOBgNVBAcM\n' +
        'B1NlYXR0bGUwIBcNMjEwNTI0MjIwMzIwWhgPMjEyMTA1MjQyMzAzMjBaMIGXMQsw\n' +
        'CQYDVQQGEwJVUzEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywgSW5jLjET\n' +
        'MBEGA1UECwwKQW1hem9uIFJEUzELMAkGA1UECAwCV0ExMDAuBgNVBAMMJ0FtYXpv\n' +
        'biBSRFMgdXMtd2VzdC0yIFJvb3QgQ0EgUlNBNDA5NiBHMTEQMA4GA1UEBwwHU2Vh\n' +
        'dHRsZTCCAiIwDQYJKoZIhvcNAQEBBQADggIPADCCAgoCggIBAM977bHIs1WJijrS\n' +
        'XQMfUOhmlJjr2v0K0UjPl52sE1TJ76H8umo1yR4T7Whkd9IwBHNGKXCJtJmMr9zp\n' +
        'fB38eLTu+5ydUAXdFuZpRMKBWwPVe37AdJRKqn5beS8HQjd3JXAgGKUNNuE92iqF\n' +
        'qi2fIqFMpnJXWo0FIW6s2Dl2zkORd7tH0DygcRi7lgVxCsw1BJQhFJon3y+IV8/F\n' +
        'bnbUXSNSDUnDW2EhvWSD8L+t4eiXYsozhDAzhBvojpxhPH9OB7vqFYw5qxFx+G0t\n' +
        'lSLX5iWi1jzzc3XyGnB6WInZDVbvnvJ4BGZ+dTRpOCvsoMIn9bz4EQTvu243c7aU\n' +
        'HbS/kvnCASNt+zk7C6lbmaq0AGNztwNj85Opn2enFciWZVnnJ/4OeefUWQxD0EPp\n' +
        'SjEd9Cn2IHzkBZrHCg+lWZJQBKbUVS0lLIMSsLQQ6WvR38jY7D2nxM1A93xWxwpt\n' +
        'ZtQnYRCVXH6zt2OwDAFePInWwxUjR5t/wu3XxPgpSfrmTi3WYtr1wFypAJ811e/P\n' +
        'yBtswWUQ6BNJQvy+KnOEeGfOwmtdDFYR+GOCfvCihzrKJrxOtHIieehR5Iw3cbXG\n' +
        'sm4pDzfMUVvDDz6C2M6PRlJhhClbatHCjik9hxFYEsAlqtVVK9pxaz9i8hOqSFQq\n' +
        'kJSQsgWw+oM/B2CyjcSqkSQEu8RLAgMBAAGjQjBAMA8GA1UdEwEB/wQFMAMBAf8w\n' +
        'HQYDVR0OBBYEFPmrdxpRRgu3IcaB5BTqlprcKdTsMA4GA1UdDwEB/wQEAwIBhjAN\n' +
        'BgkqhkiG9w0BAQwFAAOCAgEAVdlxWjPvVKky3kn8ZizeM4D+EsLw9dWLau2UD/ls\n' +
        'zwDCFoT6euagVeCknrn+YEl7g20CRYT9iaonGoMUPuMR/cdtPL1W/Rf40PSrGf9q\n' +
        'QuxavWiHLEXOQTCtCaVZMokkvjuuLNDXyZnstgECuiZECTwhexUF4oiuhyGk9o01\n' +
        'QMaiz4HX4lgk0ozALUvEzaNd9gWEwD2qe+rq9cQMTVq3IArUkvTIftZUaVUMzr0O\n' +
        'ed1+zAsNa9nJhURJ/6anJPJjbQgb5qA1asFcp9UaMT1ku36U3gnR1T/BdgG2jX3X\n' +
        'Um0UcaGNVPrH1ukInWW743pxWQb7/2sumEEMVh+jWbB18SAyLI4WIh4lkurdifzS\n' +
        'IuTFp8TEx+MouISFhz/vJDWZ84tqoLVjkEcP6oDypq9lFoEzHDJv3V1CYcIgOusT\n' +
        'k1jm9P7BXdTG7TYzUaTb9USb6bkqkD9EwJAOSs7DI94aE6rsSws2yAHavjAMfuMZ\n' +
        'sDAZvkqS2Qg2Z2+CI6wUZn7mzkJXbZoqRjDvChDXEB1mIhzVXhiNW/CR5WKVDvlj\n' +
        '9v1sdGByh2pbxcLQtVaq/5coM4ANgphoNz3pOYUPWHS+JUrIivBZ+JobjXcxr3SN\n' +
        '9iDzcu5/FVVNbq7+KN/nvPMngT+gduEN5m+EBjm8GukJymFG0m6BENRA0QSDqZ7k\n' +
        'zDY=\n' +
        '-----END CERTIFICATE-----\n',
    '-----BEGIN CERTIFICATE-----\n' +
        'MIIECTCCAvGgAwIBAgIRAK5EYG3iHserxMqgg+0EFjgwDQYJKoZIhvcNAQELBQAw\n' +
        'gZwxCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJ\n' +
        'bmMuMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTE1MDMGA1UEAwws\n' +
        'QW1hem9uIFJEUyBhcC1ub3J0aGVhc3QtMyBSb290IENBIFJTQTIwNDggRzExEDAO\n' +
        'BgNVBAcMB1NlYXR0bGUwIBcNMjEwNTI0MjAyMzE2WhgPMjA2MTA1MjQyMTIzMTZa\n' +
        'MIGcMQswCQYDVQQGEwJVUzEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywg\n' +
        'SW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzELMAkGA1UECAwCV0ExNTAzBgNVBAMM\n' +
        'LEFtYXpvbiBSRFMgYXAtbm9ydGhlYXN0LTMgUm9vdCBDQSBSU0EyMDQ4IEcxMRAw\n' +
        'DgYDVQQHDAdTZWF0dGxlMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA\n' +
        's1L6TtB84LGraLHVC+rGPhLBW2P0oN/91Rq3AnYwqDOuTom7agANwEjvLq7dSRG/\n' +
        'sIfZsSV/ABTgArZ5sCmLjHFZAo8Kd45yA9byx20RcYtAG8IZl+q1Cri+s0XefzyO\n' +
        'U6mlfXZkVe6lzjlfXBkrlE/+5ifVbJK4dqOS1t9cWIpgKqv5fbE6Qbq4LVT+5/WM\n' +
        'Vd2BOljuBMGMzdZubqFKFq4mzTuIYfnBm7SmHlZfTdfBYPP1ScNuhpjuzw4n3NCR\n' +
        'EdU6dQv04Q6th4r7eiOCwbWI9LkmVbvBe3ylhH63lApC7MiiPYLlB13xBubVHVhV\n' +
        'q1NHoNTi+zA3MN9HWicRxQIDAQABo0IwQDAPBgNVHRMBAf8EBTADAQH/MB0GA1Ud\n' +
        'DgQWBBSuxoqm0/wjNiZLvqv+JlQwsDvTPDAOBgNVHQ8BAf8EBAMCAYYwDQYJKoZI\n' +
        'hvcNAQELBQADggEBAFfTK/j5kv90uIbM8VaFdVbr/6weKTwehafT0pAk1bfLVX+7\n' +
        'uf8oHgYiyKTTl0DFQicXejghXTeyzwoEkWSR8c6XkhD5vYG3oESqmt/RGvvoxz11\n' +
        'rHHy7yHYu7RIUc3VQG60c4qxXv/1mWySGwVwJrnuyNT9KZXPevu3jVaWOVHEILaK\n' +
        'HvzQ2YEcWBPmde/zEseO2QeeGF8FL45Q1d66wqIP4nNUd2pCjeTS5SpB0MMx7yi9\n' +
        'ki1OH1pv8tOuIdimtZ7wkdB8+JSZoaJ81b8sRrydRwJyvB88rftuI3YB4WwGuONT\n' +
        'ZezUPsmaoK69B0RChB0ofDpAaviF9V3xOWvVZfo=\n' +
        '-----END CERTIFICATE-----\n',
    '-----BEGIN CERTIFICATE-----\n' +
        'MIIGDzCCA/egAwIBAgIRAI0sMNG2XhaBMRN3zD7ZyoEwDQYJKoZIhvcNAQEMBQAw\n' +
        'gZ8xCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJ\n' +
        'bmMuMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTE4MDYGA1UEAwwv\n' +
        'QW1hem9uIFJEUyBQcmV2aWV3IHVzLWVhc3QtMiBSb290IENBIFJTQTQwOTYgRzEx\n' +
        'EDAOBgNVBAcMB1NlYXR0bGUwIBcNMjEwNTE4MjA1NzUwWhgPMjEyMTA1MTgyMTU3\n' +
        'NTBaMIGfMQswCQYDVQQGEwJVUzEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNl\n' +
        'cywgSW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzELMAkGA1UECAwCV0ExODA2BgNV\n' +
        'BAMML0FtYXpvbiBSRFMgUHJldmlldyB1cy1lYXN0LTIgUm9vdCBDQSBSU0E0MDk2\n' +
        'IEcxMRAwDgYDVQQHDAdTZWF0dGxlMIICIjANBgkqhkiG9w0BAQEFAAOCAg8AMIIC\n' +
        'CgKCAgEAh/otSiCu4Uw3hu7OJm0PKgLsLRqBmUS6jihcrkxfN2SHmp2zuRflkweU\n' +
        'BhMkebzL+xnNvC8okzbgPWtUxSmDnIRhE8J7bvSKFlqs/tmEdiI/LMqe/YIKcdsI\n' +
        '20UYmvyLIjtDaJIh598SHHlF9P8DB5jD8snJfhxWY+9AZRN+YVTltgQAAgayxkWp\n' +
        'M1BbvxpOnz4CC00rE0eqkguXIUSuobb1vKqdKIenlYBNxm2AmtgvQfpsBIQ0SB+8\n' +
        '8Zip8Ef5rtjSw5J3s2Rq0aYvZPfCVIsKYepIboVwXtD7E9J31UkB5onLBQlaHaA6\n' +
        'XlH4srsMmrew5d2XejQGy/lGZ1nVWNsKO0x/Az2QzY5Kjd6AlXZ8kq6H68hscA5i\n' +
        'OMbNlXzeEQsZH0YkId3+UsEns35AAjZv4qfFoLOu8vDotWhgVNT5DfdbIWZW3ZL8\n' +
        'qbmra3JnCHuaTwXMnc25QeKgVq7/rG00YB69tCIDwcf1P+tFJWxvaGtV0g2NthtB\n' +
        'a+Xo09eC0L53gfZZ3hZw1pa3SIF5dIZ6RFRUQ+lFOux3Q/I3u+rYstYw7Zxc4Zeo\n' +
        'Y8JiedpQXEAnbw2ECHix/L6mVWgiWCiDzBnNLLdbmXjJRnafNSndSfFtHCnY1SiP\n' +
        'aCrNpzwZIJejoV1zDlWAMO+gyS28EqzuIq3WJK/TFE7acHkdKIcCAwEAAaNCMEAw\n' +
        'DwYDVR0TAQH/BAUwAwEB/zAdBgNVHQ4EFgQUrmV1YASnuudfmqAZP4sKGTvScaEw\n' +
        'DgYDVR0PAQH/BAQDAgGGMA0GCSqGSIb3DQEBDAUAA4ICAQBGpEKeQoPvE85tN/25\n' +
        'qHFkys9oHDl93DZ62EnOqAUKLd6v0JpCyEiop4nlrJe+4KrBYVBPyKOJDcIqE2Sp\n' +
        '3cvgJXLhY4i46VM3Qxe8yuYF1ElqBpg3jJVj/sCQnYz9dwoAMWIJFaDWOvmU2E7M\n' +
        'MRaKx+sPXFkIjiDA6Bv0m+VHef7aedSYIY7IDltEQHuXoqNacGrYo3I50R+fZs88\n' +
        '/mB3e/V7967e99D6565yf9Lcjw4oQf2Hy7kl/6P9AuMz0LODnGITwh2TKk/Zo3RU\n' +
        'Vgq25RDrT4xJK6nFHyjUF6+4cOBxVpimmFw/VP1zaXT8DN5r4HyJ9p4YuSK8ha5N\n' +
        '2pJc/exvU8Nv2+vS/efcDZWyuEdZ7eh1IJWQZlOZKIAONfRDRTpeQHJ3zzv3QVYy\n' +
        't78pYp/eWBHyVIfEE8p2lFKD4279WYe+Uvdb8c4Jm4TJwqkSJV8ifID7Ub80Lsir\n' +
        'lPAU3OCVTBeVRFPXT2zpC4PB4W6KBSuj6OOcEu2y/HgWcoi7Cnjvp0vFTUhDFdus\n' +
        'Wz3ucmJjfVsrkEO6avDKu4SwdbVHsk30TVAwPd6srIdi9U6MOeOQSOSE4EsrrS7l\n' +
        'SVmu2QIDUVFpm8QAHYplkyWIyGkupyl3ashH9mokQhixIU/Pzir0byePxHLHrwLu\n' +
        '1axqeKpI0F5SBUPsaVNYY2uNFg==\n' +
        '-----END CERTIFICATE-----\n',
    '-----BEGIN CERTIFICATE-----\n' +
        'MIIECDCCAvCgAwIBAgIQCREfzzVyDTMcNME+gWnTCTANBgkqhkiG9w0BAQsFADCB\n' +
        'nDELMAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIElu\n' +
        'Yy4xEzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTUwMwYDVQQDDCxB\n' +
        'bWF6b24gUkRTIGFwLXNvdXRoZWFzdC0yIFJvb3QgQ0EgUlNBMjA0OCBHMTEQMA4G\n' +
        'A1UEBwwHU2VhdHRsZTAgFw0yMTA1MjQyMDQyMzNaGA8yMDYxMDUyNDIxNDIzM1ow\n' +
        'gZwxCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJ\n' +
        'bmMuMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTE1MDMGA1UEAwws\n' +
        'QW1hem9uIFJEUyBhcC1zb3V0aGVhc3QtMiBSb290IENBIFJTQTIwNDggRzExEDAO\n' +
        'BgNVBAcMB1NlYXR0bGUwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQDL\n' +
        '1MT6br3L/4Pq87DPXtcjlXN3cnbNk2YqRAZHJayStTz8VtsFcGPJOpk14geRVeVk\n' +
        'e9uKFHRbcyr/RM4owrJTj5X4qcEuATYZbo6ou/rW2kYzuWFZpFp7lqm0vasV4Z9F\n' +
        'fChlhwkNks0UbM3G+psCSMNSoF19ERunj7w2c4E62LwujkeYLvKGNepjnaH10TJL\n' +
        '2krpERd+ZQ4jIpObtRcMH++bTrvklc+ei8W9lqrVOJL+89v2piN3Ecdd389uphst\n' +
        'qQdb1BBVXbhUrtuGHgVf7zKqN1SkCoktoWxVuOprVWhSvr7akaWeq0UmlvbEsujU\n' +
        'vADqxGMcJFyCzxx3CkJjAgMBAAGjQjBAMA8GA1UdEwEB/wQFMAMBAf8wHQYDVR0O\n' +
        'BBYEFFk8UJmlhoxFT3PP12PvhvazHjT4MA4GA1UdDwEB/wQEAwIBhjANBgkqhkiG\n' +
        '9w0BAQsFAAOCAQEAfFtr2lGoWVXmWAsIo2NYre7kzL8Xb9Tx7desKxCCz5HOOvIr\n' +
        '8JMB1YK6A7IOvQsLJQ/f1UnKRh3X3mJZjKIywfrMSh0FiDf+rjcEzXxw2dGtUem4\n' +
        'A+WMvIA3jwxnJ90OQj5rQ8bg3iPtE6eojzo9vWQGw/Vu48Dtw1DJo9210Lq/6hze\n' +
        'hPhNkFh8fMXNT7Q1Wz/TJqJElyAQGNOXhyGpHKeb0jHMMhsy5UNoW5hLeMS5ffao\n' +
        'TBFWEJ1gVfxIU9QRxSh+62m46JIg+dwDlWv8Aww14KgepspRbMqDuaM2cinoejv6\n' +
        't3dyOyHHrsOyv3ffZUKtQhQbQr+sUcL89lARsg==\n' +
        '-----END CERTIFICATE-----\n',
    '-----BEGIN CERTIFICATE-----\n' +
        'MIID/zCCAuegAwIBAgIRAIJLTMpzGNxqHZ4t+c1MlCIwDQYJKoZIhvcNAQELBQAw\n' +
        'gZcxCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJ\n' +
        'bmMuMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTEwMC4GA1UEAwwn\n' +
        'QW1hem9uIFJEUyBhcC1lYXN0LTEgUm9vdCBDQSBSU0EyMDQ4IEcxMRAwDgYDVQQH\n' +
        'DAdTZWF0dGxlMCAXDTIxMDUyNTIxMzAzM1oYDzIwNjEwNTI1MjIzMDMzWjCBlzEL\n' +
        'MAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4x\n' +
        'EzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTAwLgYDVQQDDCdBbWF6\n' +
        'b24gUkRTIGFwLWVhc3QtMSBSb290IENBIFJTQTIwNDggRzExEDAOBgNVBAcMB1Nl\n' +
        'YXR0bGUwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQDtdHut0ZhJ9Nn2\n' +
        'MpVafFcwHdoEzx06okmmhjJsNy4l9QYVeh0UUoek0SufRNMRF4d5ibzpgZol0Y92\n' +
        '/qKWNe0jNxhEj6sXyHsHPeYtNBPuDMzThfbvsLK8z7pBP7vVyGPGuppqW/6m4ZBB\n' +
        'lcc9fsf7xpZ689iSgoyjiT6J5wlVgmCx8hFYc/uvcRtfd8jAHvheug7QJ3zZmIye\n' +
        'V4htOW+fRVWnBjf40Q+7uTv790UAqs0Zboj4Yil+hER0ibG62y1g71XcCyvcVpto\n' +
        '2/XW7Y9NCgMNqQ7fGN3wR1gjtSYPd7DO32LTzYhutyvfbpAZjsAHnoObmoljcgXI\n' +
        'QjfBcCFpAgMBAAGjQjBAMA8GA1UdEwEB/wQFMAMBAf8wHQYDVR0OBBYEFJI3aWLg\n' +
        'CS5xqU5WYVaeT5s8lpO0MA4GA1UdDwEB/wQEAwIBhjANBgkqhkiG9w0BAQsFAAOC\n' +
        'AQEAUwATpJOcGVOs3hZAgJwznWOoTzOVJKfrqBum7lvkVH1vBwxBl9CahaKj3ZOt\n' +
        'YYp2qJzhDUWludL164DL4ZjS6eRedLRviyy5cRy0581l1MxPWTThs27z+lCC14RL\n' +
        'PJZNVYYdl7Jy9Q5NsQ0RBINUKYlRY6OqGDySWyuMPgno2GPbE8aynMdKP+f6G/uE\n' +
        'YHOf08gFDqTsbyfa70ztgVEJaRooVf5JJq4UQtpDvVswW2reT96qi6tXPKHN5qp3\n' +
        '3wI0I1Mp4ePmiBKku2dwYzPfrJK/pQlvu0Gu5lKOQ65QdotwLAAoaFqrf9za1yYs\n' +
        'INUkHLWIxDds+4OHNYcerGp5Dw==\n' +
        '-----END CERTIFICATE-----\n',
    '-----BEGIN CERTIFICATE-----\n' +
        'MIIGCTCCA/GgAwIBAgIRAIO6ldra1KZvNWJ0TA1ihXEwDQYJKoZIhvcNAQEMBQAw\n' +
        'gZwxCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJ\n' +
        'bmMuMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTE1MDMGA1UEAwws\n' +
        'QW1hem9uIFJEUyBhcC1zb3V0aGVhc3QtMSBSb290IENBIFJTQTQwOTYgRzExEDAO\n' +
        'BgNVBAcMB1NlYXR0bGUwIBcNMjEwNTIxMjE0NTA1WhgPMjEyMTA1MjEyMjQ1MDVa\n' +
        'MIGcMQswCQYDVQQGEwJVUzEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywg\n' +
        'SW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzELMAkGA1UECAwCV0ExNTAzBgNVBAMM\n' +
        'LEFtYXpvbiBSRFMgYXAtc291dGhlYXN0LTEgUm9vdCBDQSBSU0E0MDk2IEcxMRAw\n' +
        'DgYDVQQHDAdTZWF0dGxlMIICIjANBgkqhkiG9w0BAQEFAAOCAg8AMIICCgKCAgEA\n' +
        'sDN52Si9pFSyZ1ruh3xAN0nVqEs960o2IK5CPu/ZfshFmzAwnx/MM8EHt/jMeZtj\n' +
        'SM58LADAsNDL01ELpFZATjgZQ6xNAyXRXE7RiTRUvNkK7O3o2qAGbLnJq/UqF7Sw\n' +
        'LRnB8V6hYOv+2EjVnohtGCn9SUFGZtYDjWXsLd4ML4Zpxv0a5LK7oEC7AHzbUR7R\n' +
        'jsjkrXqSv7GE7bvhSOhMkmgxgj1F3J0b0jdQdtyyj109aO0ATUmIvf+Bzadg5AI2\n' +
        'A9UA+TUcGeebhpHu8AP1Hf56XIlzPpaQv3ZJ4vzoLaVNUC7XKzAl1dlvCl7Klg/C\n' +
        '84qmbD/tjZ6GHtzpLKgg7kQEV7mRoXq8X4wDX2AFPPQl2fv+Kbe+JODqm5ZjGegm\n' +
        'uskABBi8IFv1hYx9jEulZPxC6uD/09W2+niFm3pirnlWS83BwVDTUBzF+CooUIMT\n' +
        'jhWkIIZGDDgMJTzouBHfoSJtS1KpUZi99m2WyVs21MNKHeWAbs+zmI6TO5iiMC+T\n' +
        'uB8spaOiHFO1573Fmeer4sy3YA6qVoqVl6jjTQqOdy3frAMbCkwH22/crV8YA+08\n' +
        'hLeHXrMK+6XUvU+EtHAM3VzcrLbuYJUI2XJbzTj5g0Eb8I8JWsHvWHR5K7Z7gceR\n' +
        '78AzxQmoGEfV6KABNWKsgoCQnfb1BidDJIe3BsI0A6UCAwEAAaNCMEAwDwYDVR0T\n' +
        'AQH/BAUwAwEB/zAdBgNVHQ4EFgQUABp0MlB14MSHgAcuNSOhs3MOlUcwDgYDVR0P\n' +
        'AQH/BAQDAgGGMA0GCSqGSIb3DQEBDAUAA4ICAQCv4CIOBSQi/QR9NxdRgVAG/pAh\n' +
        'tFJhV7OWb/wqwsNKFDtg6tTxwaahdCfWpGWId15OUe7G9LoPiKiwM9C92n0ZeHRz\n' +
        '4ewbrQVo7Eu1JI1wf0rnZJISL72hVYKmlvaWaacHhWxvsbKLrB7vt6Cknxa+S993\n' +
        'Kf8i2Psw8j5886gaxhiUtzMTBwoDWak8ZaK7m3Y6C6hXQk08+3pnIornVSFJ9dlS\n' +
        'PAqt5UPwWmrEfF+0uIDORlT+cvrAwgSp7nUF1q8iasledycZ/BxFgQqzNwnkBDwQ\n' +
        'Z/aM52ArGsTzfMhkZRz9HIEhz1/0mJw8gZtDVQroD8778h8zsx2SrIz7eWQ6uWsD\n' +
        'QEeSWXpcheiUtEfzkDImjr2DLbwbA23c9LoexUD10nwohhoiQQg77LmvBVxeu7WU\n' +
        'E63JqaYUlOLOzEmNJp85zekIgR8UTkO7Gc+5BD7P4noYscI7pPOL5rP7YLg15ZFi\n' +
        'ega+G53NTckRXz4metsd8XFWloDjZJJq4FfD60VuxgXzoMNT9wpFTNSH42PR2s9L\n' +
        'I1vcl3w8yNccs9se2utM2nLsItZ3J0m/+QSRiw9hbrTYTcM9sXki0DtH2kyIOwYf\n' +
        'lOrGJDiYOIrXSQK36H0gQ+8omlrUTvUj4msvkXuQjlfgx6sgp2duOAfnGxE7uHnc\n' +
        'UhnJzzoe6M+LfGHkVQ==\n' +
        '-----END CERTIFICATE-----\n',
    '-----BEGIN CERTIFICATE-----\n' +
        'MIICuDCCAj2gAwIBAgIQSAG6j2WHtWUUuLGJTPb1nTAKBggqhkjOPQQDAzCBmzEL\n' +
        'MAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4x\n' +
        'EzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTQwMgYDVQQDDCtBbWF6\n' +
        'b24gUkRTIGFwLW5vcnRoZWFzdC0yIFJvb3QgQ0EgRUNDMzg0IEcxMRAwDgYDVQQH\n' +
        'DAdTZWF0dGxlMCAXDTIxMDUyMDE2MzgyNloYDzIxMjEwNTIwMTczODI2WjCBmzEL\n' +
        'MAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4x\n' +
        'EzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTQwMgYDVQQDDCtBbWF6\n' +
        'b24gUkRTIGFwLW5vcnRoZWFzdC0yIFJvb3QgQ0EgRUNDMzg0IEcxMRAwDgYDVQQH\n' +
        'DAdTZWF0dGxlMHYwEAYHKoZIzj0CAQYFK4EEACIDYgAE2eqwU4FOzW8RV1W381Bd\n' +
        'olhDOrqoMqzWli21oDUt7y8OnXM/lmAuOS6sr8Nt61BLVbONdbr+jgCYw75KabrK\n' +
        'ZGg3siqvMOgabIKkKuXO14wtrGyGDt7dnKXg5ERGYOZlo0IwQDAPBgNVHRMBAf8E\n' +
        'BTADAQH/MB0GA1UdDgQWBBS1Acp2WYxOcblv5ikZ3ZIbRCCW+zAOBgNVHQ8BAf8E\n' +
        'BAMCAYYwCgYIKoZIzj0EAwMDaQAwZgIxAJL84J08PBprxmsAKPTotBuVI3MyW1r8\n' +
        'xQ0i8lgCQUf8GcmYjQ0jI4oZyv+TuYJAcwIxAP9Xpzq0Docxb+4N1qVhpiOfWt1O\n' +
        'FnemFiy9m1l+wv6p3riQMPV7mBVpklmijkIv3Q==\n' +
        '-----END CERTIFICATE-----\n',
    '-----BEGIN CERTIFICATE-----\n' +
        'MIIECTCCAvGgAwIBAgIRALZLcqCVIJ25maDPE3sbPCIwDQYJKoZIhvcNAQELBQAw\n' +
        'gZwxCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJ\n' +
        'bmMuMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTE1MDMGA1UEAwws\n' +
        'QW1hem9uIFJEUyBhcC1zb3V0aGVhc3QtMSBSb290IENBIFJTQTIwNDggRzExEDAO\n' +
        'BgNVBAcMB1NlYXR0bGUwIBcNMjEwNTIxMjEzOTM5WhgPMjA2MTA1MjEyMjM5Mzla\n' +
        'MIGcMQswCQYDVQQGEwJVUzEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywg\n' +
        'SW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzELMAkGA1UECAwCV0ExNTAzBgNVBAMM\n' +
        'LEFtYXpvbiBSRFMgYXAtc291dGhlYXN0LTEgUm9vdCBDQSBSU0EyMDQ4IEcxMRAw\n' +
        'DgYDVQQHDAdTZWF0dGxlMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA\n' +
        'ypKc+6FfGx6Gl6fQ78WYS29QoKgQiur58oxR3zltWeg5fqh9Z85K5S3UbRSTqWWu\n' +
        'Xcfnkz0/FS07qHX+nWAGU27JiQb4YYqhjZNOAq8q0+ptFHJ6V7lyOqXBq5xOzO8f\n' +
        '+0DlbJSsy7GEtJp7d7QCM3M5KVY9dENVZUKeJwa8PC5StvwPx4jcLeZRJC2rAVDG\n' +
        'SW7NAInbATvr9ssSh03JqjXb+HDyywiqoQ7EVLtmtXWimX+0b3/2vhqcH5jgcKC9\n' +
        'IGFydrjPbv4kwMrKnm6XlPZ9L0/3FMzanXPGd64LQVy51SI4d5Xymn0Mw2kMX8s6\n' +
        'Nf05OsWcDzJ1n6/Q1qHSxQIDAQABo0IwQDAPBgNVHRMBAf8EBTADAQH/MB0GA1Ud\n' +
        'DgQWBBRmaIc8eNwGP7i6P7AJrNQuK6OpFzAOBgNVHQ8BAf8EBAMCAYYwDQYJKoZI\n' +
        'hvcNAQELBQADggEBAIBeHfGwz3S2zwIUIpqEEI5/sMySDeS+3nJR+woWAHeO0C8i\n' +
        'BJdDh+kzzkP0JkWpr/4NWz84/IdYo1lqASd1Kopz9aT1+iROXaWr43CtbzjXb7/X\n' +
        'Zv7eZZFC8/lS5SROq42pPWl4ekbR0w8XGQElmHYcWS41LBfKeHCUwv83ATF0XQ6I\n' +
        '4t+9YSqZHzj4vvedrvcRInzmwWJaal9s7Z6GuwTGmnMsN3LkhZ+/GD6oW3pU/Pyh\n' +
        'EtWqffjsLhfcdCs3gG8x9BbkcJPH5aPAVkPn4wc8wuXg6xxb9YGsQuY930GWTYRf\n' +
        'schbgjsuqznW4HHakq4WNhs1UdTSTKkRdZz7FUQ=\n' +
        '-----END CERTIFICATE-----\n',
    '-----BEGIN CERTIFICATE-----\n' +
        'MIIEDzCCAvegAwIBAgIRAM2zAbhyckaqRim63b+Tib8wDQYJKoZIhvcNAQELBQAw\n' +
        'gZ8xCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJ\n' +
        'bmMuMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTE4MDYGA1UEAwwv\n' +
        'QW1hem9uIFJEUyBQcmV2aWV3IHVzLWVhc3QtMiBSb290IENBIFJTQTIwNDggRzEx\n' +
        'EDAOBgNVBAcMB1NlYXR0bGUwIBcNMjEwNTE4MjA0OTQ1WhgPMjA2MTA1MTgyMTQ5\n' +
        'NDVaMIGfMQswCQYDVQQGEwJVUzEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNl\n' +
        'cywgSW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzELMAkGA1UECAwCV0ExODA2BgNV\n' +
        'BAMML0FtYXpvbiBSRFMgUHJldmlldyB1cy1lYXN0LTIgUm9vdCBDQSBSU0EyMDQ4\n' +
        'IEcxMRAwDgYDVQQHDAdTZWF0dGxlMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIB\n' +
        'CgKCAQEA1ybjQMH1MkbvfKsWJaCTXeCSN1SG5UYid+Twe+TjuSqaXWonyp4WRR5z\n' +
        'tlkqq+L2MWUeQQAX3S17ivo/t84mpZ3Rla0cx39SJtP3BiA2BwfUKRjhPwOjmk7j\n' +
        '3zrcJjV5k1vSeLNOfFFSlwyDiVyLAE61lO6onBx+cRjelu0egMGq6WyFVidTdCmT\n' +
        'Q9Zw3W6LTrnPvPmEyjHy2yCHzH3E50KSd/5k4MliV4QTujnxYexI2eR8F8YQC4m3\n' +
        'DYjXt/MicbqA366SOoJA50JbgpuVv62+LSBu56FpzY12wubmDZsdn4lsfYKiWxUy\n' +
        'uc83a2fRXsJZ1d3whxrl20VFtLFHFQIDAQABo0IwQDAPBgNVHRMBAf8EBTADAQH/\n' +
        'MB0GA1UdDgQWBBRC0ytKmDYbfz0Bz0Psd4lRQV3aNTAOBgNVHQ8BAf8EBAMCAYYw\n' +
        'DQYJKoZIhvcNAQELBQADggEBAGv8qZu4uaeoF6zsbumauz6ea6tdcWt+hGFuwGrb\n' +
        'tRbI85ucAmVSX06x59DJClsb4MPhL1XmqO3RxVMIVVfRwRHWOsZQPnXm8OYQ2sny\n' +
        'rYuFln1COOz1U/KflZjgJmxbn8x4lYiTPZRLarG0V/OsCmnLkQLPtEl/spMu8Un7\n' +
        'r3K8SkbWN80gg17Q8EV5mnFwycUx9xsTAaFItuG0en9bGsMgMmy+ZsDmTRbL+lcX\n' +
        'Fq8r4LT4QjrFz0shrzCwuuM4GmcYtBSxlacl+HxYEtAs5k10tmzRf6OYlY33tGf6\n' +
        '1tkYvKryxDPF/EDgGp/LiBwx6ixYMBfISoYASt4V/ylAlHA=\n' +
        '-----END CERTIFICATE-----\n',
    '-----BEGIN CERTIFICATE-----\n' +
        'MIICtTCCAjqgAwIBAgIRAK9BSZU6nIe6jqfODmuVctYwCgYIKoZIzj0EAwMwgZkx\n' +
        'CzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMu\n' +
        'MRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTEyMDAGA1UEAwwpQW1h\n' +
        'em9uIFJEUyBjYS1jZW50cmFsLTEgUm9vdCBDQSBFQ0MzODQgRzExEDAOBgNVBAcM\n' +
        'B1NlYXR0bGUwIBcNMjEwNTIxMjIxMzA5WhgPMjEyMTA1MjEyMzEzMDlaMIGZMQsw\n' +
        'CQYDVQQGEwJVUzEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywgSW5jLjET\n' +
        'MBEGA1UECwwKQW1hem9uIFJEUzELMAkGA1UECAwCV0ExMjAwBgNVBAMMKUFtYXpv\n' +
        'biBSRFMgY2EtY2VudHJhbC0xIFJvb3QgQ0EgRUNDMzg0IEcxMRAwDgYDVQQHDAdT\n' +
        'ZWF0dGxlMHYwEAYHKoZIzj0CAQYFK4EEACIDYgAEUkEERcgxneT5H+P+fERcbGmf\n' +
        'bVx+M7rNWtgWUr6w+OBENebQA9ozTkeSg4c4M+qdYSObFqjxITdYxT1z/nHz1gyx\n' +
        'OKAhLjWu+nkbRefqy3RwXaWT680uUaAP6ccnkZOMo0IwQDAPBgNVHRMBAf8EBTAD\n' +
        'AQH/MB0GA1UdDgQWBBSN6fxlg0s5Wny08uRBYZcQ3TUoyzAOBgNVHQ8BAf8EBAMC\n' +
        'AYYwCgYIKoZIzj0EAwMDaQAwZgIxAORaz+MBVoFBTmZ93j2G2vYTwA6T5hWzBWrx\n' +
        'CrI54pKn5g6At56DBrkjrwZF5T1enAIxAJe/LZ9xpDkAdxDgGJFN8gZYLRWc0NRy\n' +
        'Rb4hihy5vj9L+w9uKc9VfEBIFuhT7Z3ljg==\n' +
        '-----END CERTIFICATE-----\n',
    '-----BEGIN CERTIFICATE-----\n' +
        'MIIEADCCAuigAwIBAgIQB/57HSuaqUkLaasdjxUdPjANBgkqhkiG9w0BAQsFADCB\n' +
        'mDELMAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIElu\n' +
        'Yy4xEzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTEwLwYDVQQDDChB\n' +
        'bWF6b24gUkRTIGFwLXNvdXRoLTEgUm9vdCBDQSBSU0EyMDQ4IEcxMRAwDgYDVQQH\n' +
        'DAdTZWF0dGxlMCAXDTIxMDUxOTE3NDAzNFoYDzIwNjEwNTE5MTg0MDM0WjCBmDEL\n' +
        'MAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4x\n' +
        'EzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTEwLwYDVQQDDChBbWF6\n' +
        'b24gUkRTIGFwLXNvdXRoLTEgUm9vdCBDQSBSU0EyMDQ4IEcxMRAwDgYDVQQHDAdT\n' +
        'ZWF0dGxlMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAtbkaoVsUS76o\n' +
        'TgLFmcnaB8cswBk1M3Bf4IVRcwWT3a1HeJSnaJUqWHCJ+u3ip/zGVOYl0gN1MgBb\n' +
        'MuQRIJiB95zGVcIa6HZtx00VezDTr3jgGWRHmRjNVCCHGmxOZWvJjsIE1xavT/1j\n' +
        'QYV/ph4EZEIZ/qPq7e3rHohJaHDe23Z7QM9kbyqp2hANG2JtU/iUhCxqgqUHNozV\n' +
        'Zd0l5K6KnltZQoBhhekKgyiHqdTrH8fWajYl5seD71bs0Axowb+Oh0rwmrws3Db2\n' +
        'Dh+oc2PwREnjHeca9/1C6J2vhY+V0LGaJmnnIuOANrslx2+bgMlyhf9j0Bv8AwSi\n' +
        'dSWsobOhNQIDAQABo0IwQDAPBgNVHRMBAf8EBTADAQH/MB0GA1UdDgQWBBQb7vJT\n' +
        'VciLN72yJGhaRKLn6Krn2TAOBgNVHQ8BAf8EBAMCAYYwDQYJKoZIhvcNAQELBQAD\n' +
        'ggEBAAxEj8N9GslReAQnNOBpGl8SLgCMTejQ6AW/bapQvzxrZrfVOZOYwp/5oV0f\n' +
        '9S1jcGysDM+DrmfUJNzWxq2Y586R94WtpH4UpJDGqZp+FuOVJL313te4609kopzO\n' +
        'lDdmd+8z61+0Au93wB1rMiEfnIMkOEyt7D2eTFJfJRKNmnPrd8RjimRDlFgcLWJA\n' +
        '3E8wca67Lz/G0eAeLhRHIXv429y8RRXDtKNNz0wA2RwURWIxyPjn1fHjA9SPDkeW\n' +
        'E1Bq7gZj+tBnrqz+ra3yjZ2blss6Ds3/uRY6NYqseFTZWmQWT7FolZEnT9vMUitW\n' +
        'I0VynUbShVpGf6946e0vgaaKw20=\n' +
        '-----END CERTIFICATE-----\n',
    '-----BEGIN CERTIFICATE-----\n' +
        'MIID/jCCAuagAwIBAgIQGyUVTaVjYJvWhroVEiHPpDANBgkqhkiG9w0BAQsFADCB\n' +
        'lzELMAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIElu\n' +
        'Yy4xEzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTAwLgYDVQQDDCdB\n' +
        'bWF6b24gUkRTIHVzLXdlc3QtMSBSb290IENBIFJTQTIwNDggRzExEDAOBgNVBAcM\n' +
        'B1NlYXR0bGUwIBcNMjEwNTE5MTkwNDA2WhgPMjA2MTA1MTkyMDA0MDZaMIGXMQsw\n' +
        'CQYDVQQGEwJVUzEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywgSW5jLjET\n' +
        'MBEGA1UECwwKQW1hem9uIFJEUzELMAkGA1UECAwCV0ExMDAuBgNVBAMMJ0FtYXpv\n' +
        'biBSRFMgdXMtd2VzdC0xIFJvb3QgQ0EgUlNBMjA0OCBHMTEQMA4GA1UEBwwHU2Vh\n' +
        'dHRsZTCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBANhyXpJ0t4nigRDZ\n' +
        'EwNtFOem1rM1k8k5XmziHKDvDk831p7QsX9ZOxl/BT59Pu/P+6W6SvasIyKls1sW\n' +
        'FJIjFF+6xRQcpoE5L5evMgN/JXahpKGeQJPOX9UEXVW5B8yi+/dyUitFT7YK5LZA\n' +
        'MqWBN/LtHVPa8UmE88RCDLiKkqiv229tmwZtWT7nlMTTCqiAHMFcryZHx0pf9VPh\n' +
        'x/iPV8p2gBJnuPwcz7z1kRKNmJ8/cWaY+9w4q7AYlAMaq/rzEqDaN2XXevdpsYAK\n' +
        'TMMj2kji4x1oZO50+VPNfBl5ZgJc92qz1ocF95SAwMfOUsP8AIRZkf0CILJYlgzk\n' +
        '/6u6qZECAwEAAaNCMEAwDwYDVR0TAQH/BAUwAwEB/zAdBgNVHQ4EFgQUm5jfcS9o\n' +
        '+LwL517HpB6hG+PmpBswDgYDVR0PAQH/BAQDAgGGMA0GCSqGSIb3DQEBCwUAA4IB\n' +
        'AQAcQ6lsqxi63MtpGk9XK8mCxGRLCad51+MF6gcNz6i6PAqhPOoKCoFqdj4cEQTF\n' +
        'F8dCfa3pvfJhxV6RIh+t5FCk/y6bWT8Ls/fYKVo6FhHj57bcemWsw/Z0XnROdVfK\n' +
        'Yqbc7zvjCPmwPHEqYBhjU34NcY4UF9yPmlLOL8uO1JKXa3CAR0htIoW4Pbmo6sA4\n' +
        '6P0co/clW+3zzsQ92yUCjYmRNeSbdXbPfz3K/RtFfZ8jMtriRGuO7KNxp8MqrUho\n' +
        'HK8O0mlSUxGXBZMNicfo7qY8FD21GIPH9w5fp5oiAl7lqFzt3E3sCLD3IiVJmxbf\n' +
        'fUwpGd1XZBBSdIxysRLM6j48\n' +
        '-----END CERTIFICATE-----\n',
    '-----BEGIN CERTIFICATE-----\n' +
        'MIICrTCCAjOgAwIBAgIQU+PAILXGkpoTcpF200VD/jAKBggqhkjOPQQDAzCBljEL\n' +
        'MAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4x\n' +
        'EzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMS8wLQYDVQQDDCZBbWF6\n' +
        'b24gUkRTIGFwLWVhc3QtMSBSb290IENBIEVDQzM4NCBHMTEQMA4GA1UEBwwHU2Vh\n' +
        'dHRsZTAgFw0yMTA1MjUyMTQ1MTFaGA8yMTIxMDUyNTIyNDUxMVowgZYxCzAJBgNV\n' +
        'BAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMuMRMwEQYD\n' +
        'VQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTEvMC0GA1UEAwwmQW1hem9uIFJE\n' +
        'UyBhcC1lYXN0LTEgUm9vdCBDQSBFQ0MzODQgRzExEDAOBgNVBAcMB1NlYXR0bGUw\n' +
        'djAQBgcqhkjOPQIBBgUrgQQAIgNiAAT3tFKE8Kw1sGQAvNLlLhd8OcGhlc7MiW/s\n' +
        'NXm3pOiCT4vZpawKvHBzD76Kcv+ZZzHRxQEmG1/muDzZGlKR32h8AAj+NNO2Wy3d\n' +
        'CKTtYMiVF6Z2zjtuSkZQdjuQbe4eQ7qjQjBAMA8GA1UdEwEB/wQFMAMBAf8wHQYD\n' +
        'VR0OBBYEFAiSQOp16Vv0Ohpvqcbd2j5RmhYNMA4GA1UdDwEB/wQEAwIBhjAKBggq\n' +
        'hkjOPQQDAwNoADBlAjBVsi+5Ape0kOhMt/WFkANkslD4qXA5uqhrfAtH29Xzz2NV\n' +
        'tR7akiA771OaIGB/6xsCMQCZt2egCtbX7J0WkuZ2KivTh66jecJr5DHvAP4X2xtS\n' +
        'F/5pS+AUhcKTEGjI9jDH3ew=\n' +
        '-----END CERTIFICATE-----\n',
    '-----BEGIN CERTIFICATE-----\n' +
        'MIICuDCCAj2gAwIBAgIQT5mGlavQzFHsB7hV6Mmy6TAKBggqhkjOPQQDAzCBmzEL\n' +
        'MAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4x\n' +
        'EzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTQwMgYDVQQDDCtBbWF6\n' +
        'b24gUkRTIGFwLXNvdXRoZWFzdC0yIFJvb3QgQ0EgRUNDMzg0IEcxMRAwDgYDVQQH\n' +
        'DAdTZWF0dGxlMCAXDTIxMDUyNDIwNTAxNVoYDzIxMjEwNTI0MjE1MDE1WjCBmzEL\n' +
        'MAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4x\n' +
        'EzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTQwMgYDVQQDDCtBbWF6\n' +
        'b24gUkRTIGFwLXNvdXRoZWFzdC0yIFJvb3QgQ0EgRUNDMzg0IEcxMRAwDgYDVQQH\n' +
        'DAdTZWF0dGxlMHYwEAYHKoZIzj0CAQYFK4EEACIDYgAEcm4BBBjYK7clwm0HJRWS\n' +
        'flt3iYwoJbIXiXn9c1y3E+Vb7bmuyKhS4eO8mwO4GefUcXObRfoHY2TZLhMJLVBQ\n' +
        '7MN2xDc0RtZNj07BbGD3VAIFRTDX0mH9UNYd0JQM3t/Oo0IwQDAPBgNVHRMBAf8E\n' +
        'BTADAQH/MB0GA1UdDgQWBBRrd5ITedfAwrGo4FA9UaDaGFK3rjAOBgNVHQ8BAf8E\n' +
        'BAMCAYYwCgYIKoZIzj0EAwMDaQAwZgIxAPBNqmVv1IIA3EZyQ6XuVf4gj79/DMO8\n' +
        'bkicNS1EcBpUqbSuU4Zwt2BYc8c/t7KVOQIxAOHoWkoKZPiKyCxfMtJpCZySUG+n\n' +
        'sXgB/LOyWE5BJcXUfm+T1ckeNoWeUUMOLmnJjg==\n' +
        '-----END CERTIFICATE-----\n',
    '-----BEGIN CERTIFICATE-----\n' +
        'MIIECTCCAvGgAwIBAgIRAJcDeinvdNrDQBeJ8+t38WQwDQYJKoZIhvcNAQELBQAw\n' +
        'gZwxCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJ\n' +
        'bmMuMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTE1MDMGA1UEAwws\n' +
        'QW1hem9uIFJEUyBhcC1zb3V0aGVhc3QtNCBSb290IENBIFJTQTIwNDggRzExEDAO\n' +
        'BgNVBAcMB1NlYXR0bGUwIBcNMjIwNTI1MTY0OTE2WhgPMjA2MjA1MjUxNzQ5MTZa\n' +
        'MIGcMQswCQYDVQQGEwJVUzEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywg\n' +
        'SW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzELMAkGA1UECAwCV0ExNTAzBgNVBAMM\n' +
        'LEFtYXpvbiBSRFMgYXAtc291dGhlYXN0LTQgUm9vdCBDQSBSU0EyMDQ4IEcxMRAw\n' +
        'DgYDVQQHDAdTZWF0dGxlMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA\n' +
        'k8DBNkr9tMoIM0NHoFiO7cQfSX0cOMhEuk/CHt0fFx95IBytx7GHCnNzpM27O5z6\n' +
        'x6iRhfNnx+B6CrGyCzOjxvPizneY+h+9zfvNz9jj7L1I2uYMuiNyOKR6FkHR46CT\n' +
        '1CiArfVLLPaTqgD/rQjS0GL2sLHS/0dmYipzynnZcs613XT0rAWdYDYgxDq7r/Yi\n' +
        'Xge5AkWQFkMUq3nOYDLCyGGfQqWKkwv6lZUHLCDKf+Y0Uvsrj8YGCI1O8mF0qPCQ\n' +
        'lmlfaDvbuBu1AV+aabmkvyFj3b8KRIlNLEtQ4N8KGYR2Jdb82S4YUGIOAt4wuuFt\n' +
        '1B7AUDLk3V/u+HTWiwfoLQIDAQABo0IwQDAPBgNVHRMBAf8EBTADAQH/MB0GA1Ud\n' +
        'DgQWBBSNpcjz6ArWBtAA+Gz6kyyZxrrgdDAOBgNVHQ8BAf8EBAMCAYYwDQYJKoZI\n' +
        'hvcNAQELBQADggEBAGJEd7UgOzHYIcQRSF7nSYyjLROyalaIV9AX4WXW/Cqlul1c\n' +
        'MblP5etDZm7A/thliZIWAuyqv2bNicmS3xKvNy6/QYi1YgxZyy/qwJ3NdFl067W0\n' +
        't8nGo29B+EVK94IPjzFHWShuoktIgp+dmpijB7wkTIk8SmIoe9yuY4+hzgqk+bo4\n' +
        'ms2SOXSN1DoQ75Xv+YmztbnZM8MuWhL1T7hA4AMorzTQLJ9Pof8SpSdMHeDsHp0R\n' +
        '01jogNFkwy25nw7cL62nufSuH2fPYGWXyNDg+y42wKsKWYXLRgUQuDVEJ2OmTFMB\n' +
        'T0Vf7VuNijfIA9hkN2d3K53m/9z5WjGPSdOjGhg=\n' +
        '-----END CERTIFICATE-----\n',
    '-----BEGIN CERTIFICATE-----\n' +
        'MIID/jCCAuagAwIBAgIQRiwspKyrO0xoxDgSkqLZczANBgkqhkiG9w0BAQsFADCB\n' +
        'lzELMAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIElu\n' +
        'Yy4xEzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTAwLgYDVQQDDCdB\n' +
        'bWF6b24gUkRTIHVzLXdlc3QtMiBSb290IENBIFJTQTIwNDggRzExEDAOBgNVBAcM\n' +
        'B1NlYXR0bGUwIBcNMjEwNTI0MjE1OTAwWhgPMjA2MTA1MjQyMjU5MDBaMIGXMQsw\n' +
        'CQYDVQQGEwJVUzEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywgSW5jLjET\n' +
        'MBEGA1UECwwKQW1hem9uIFJEUzELMAkGA1UECAwCV0ExMDAuBgNVBAMMJ0FtYXpv\n' +
        'biBSRFMgdXMtd2VzdC0yIFJvb3QgQ0EgUlNBMjA0OCBHMTEQMA4GA1UEBwwHU2Vh\n' +
        'dHRsZTCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBAL53Jk3GsKiu+4bx\n' +
        'jDfsevWbwPCNJ3H08Zp7GWhvI3Tgi39opfHYv2ku2BKFjK8N2L6RvNPSR8yplv5j\n' +
        'Y0tK0U+XVNl8o0ibhqRDhbTuh6KL8CFINWYzAajuxFS+CF0U6c1Q3tXLBdALxA7l\n' +
        'FlXJ71QrP06W31kRe7kvgrvO7qWU3/OzUf9qYw4LSiR1/VkvvRCTqcVNw09clw/M\n' +
        'Jbw6FSgweN65M9j7zPbjGAXSHkXyxH1Erin2fa+B9PE4ZDgX9cp2C1DHewYJQL/g\n' +
        'SepwwcudVNRN1ibKH7kpMrgPnaNIVNx5sXVsTjk6q2ZqYw3SVHegltJpLy/cZReP\n' +
        'mlivF2kCAwEAAaNCMEAwDwYDVR0TAQH/BAUwAwEB/zAdBgNVHQ4EFgQUmTcQd6o1\n' +
        'CuS65MjBrMwQ9JJjmBwwDgYDVR0PAQH/BAQDAgGGMA0GCSqGSIb3DQEBCwUAA4IB\n' +
        'AQAKSDSIzl956wVddPThf2VAzI8syw9ngSwsEHZvxVGHBvu5gg618rDyguVCYX9L\n' +
        '4Kw/xJrk6S3qxOS2ZDyBcOpsrBskgahDFIunzoRP3a18ARQVq55LVgfwSDQiunch\n' +
        'Bd05cnFGLoiLkR5rrkgYaP2ftn3gRBRaf0y0S3JXZ2XB3sMZxGxavYq9mfiEcwB0\n' +
        'LMTMQ1NYzahIeG6Jm3LqRqR8HkzP/Ztq4dT2AtSLvFebbNMiWqeqT7OcYp94HTYT\n' +
        'zqrtaVdUg9bwyAUCDgy0GV9RHDIdNAOInU/4LEETovrtuBU7Z1q4tcHXvN6Hd1H8\n' +
        'gMb0mCG5I393qW5hFsA/diFb\n' +
        '-----END CERTIFICATE-----\n',
    '-----BEGIN CERTIFICATE-----\n' +
        'MIIECTCCAvGgAwIBAgIRAPQAvihfjBg/JDbj6U64K98wDQYJKoZIhvcNAQELBQAw\n' +
        'gZwxCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJ\n' +
        'bmMuMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTE1MDMGA1UEAwws\n' +
        'QW1hem9uIFJEUyBhcC1ub3J0aGVhc3QtMiBSb290IENBIFJTQTIwNDggRzExEDAO\n' +
        'BgNVBAcMB1NlYXR0bGUwIBcNMjEwNTIwMTYyODQxWhgPMjA2MTA1MjAxNzI4NDFa\n' +
        'MIGcMQswCQYDVQQGEwJVUzEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywg\n' +
        'SW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzELMAkGA1UECAwCV0ExNTAzBgNVBAMM\n' +
        'LEFtYXpvbiBSRFMgYXAtbm9ydGhlYXN0LTIgUm9vdCBDQSBSU0EyMDQ4IEcxMRAw\n' +
        'DgYDVQQHDAdTZWF0dGxlMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA\n' +
        'vJ9lgyksCxkBlY40qOzI1TCj/Q0FVGuPL/Z1Mw2YN0l+41BDv0FHApjTUkIKOeIP\n' +
        'nwDwpXTa3NjYbk3cOZ/fpH2rYJ++Fte6PNDGPgKppVCUh6x3jiVZ1L7wOgnTdK1Q\n' +
        'Trw8440IDS5eLykRHvz8OmwvYDl0iIrt832V0QyOlHTGt6ZJ/aTQKl12Fy3QBLv7\n' +
        'stClPzvHTrgWqVU6uidSYoDtzHbU7Vda7YH0wD9IUoMBf7Tu0rqcE4uH47s2XYkc\n' +
        'SdLEoOg/Ngs7Y9B1y1GCyj3Ux7hnyvCoRTw014QyNB7dTatFMDvYlrRDGG14KeiU\n' +
        'UL7Vo/+EejWI31eXNLw84wIDAQABo0IwQDAPBgNVHRMBAf8EBTADAQH/MB0GA1Ud\n' +
        'DgQWBBQkgTWFsNg6wA3HbbihDQ4vpt1E2zAOBgNVHQ8BAf8EBAMCAYYwDQYJKoZI\n' +
        'hvcNAQELBQADggEBAGz1Asiw7hn5WYUj8RpOCzpE0h/oBZcnxP8wulzZ5Xd0YxWO\n' +
        '0jYUcUk3tTQy1QvoY+Q5aCjg6vFv+oFBAxkib/SmZzp4xLisZIGlzpJQuAgRkwWA\n' +
        '6BVMgRS+AaOMQ6wKPgz1x4v6T0cIELZEPq3piGxvvqkcLZKdCaeC3wCS6sxuafzZ\n' +
        '4qA3zMwWuLOzRftgX2hQto7d/2YkRXga7jSvQl3id/EI+xrYoH6zIWgjdU1AUaNq\n' +
        'NGT7DIo47vVMfnd9HFZNhREsd4GJE83I+JhTqIxiKPNxrKgESzyADmNPt0gXDnHo\n' +
        'tbV1pMZz5HpJtjnP/qVZhEK5oB0tqlKPv9yx074=\n' +
        '-----END CERTIFICATE-----\n',
    '-----BEGIN CERTIFICATE-----\n' +
        'MIICuTCCAj6gAwIBAgIRAKp1Rn3aL/g/6oiHVIXtCq8wCgYIKoZIzj0EAwMwgZsx\n' +
        'CzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMu\n' +
        'MRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTE0MDIGA1UEAwwrQW1h\n' +
        'em9uIFJEUyBhcC1ub3J0aGVhc3QtMyBSb290IENBIEVDQzM4NCBHMTEQMA4GA1UE\n' +
        'BwwHU2VhdHRsZTAgFw0yMTA1MjQyMDMyMTdaGA8yMTIxMDUyNDIxMzIxN1owgZsx\n' +
        'CzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMu\n' +
        'MRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTE0MDIGA1UEAwwrQW1h\n' +
        'em9uIFJEUyBhcC1ub3J0aGVhc3QtMyBSb290IENBIEVDQzM4NCBHMTEQMA4GA1UE\n' +
        'BwwHU2VhdHRsZTB2MBAGByqGSM49AgEGBSuBBAAiA2IABGTYWPILeBJXfcL3Dz4z\n' +
        'EWMUq78xB1HpjBwHoTURYfcMd5r96BTVG6yaUBWnAVCMeeD6yTG9a1eVGNhG14Hk\n' +
        'ZAEjgLiNB7RRbEG5JZ/XV7W/vODh09WCst2y9SLKsdgeAaNCMEAwDwYDVR0TAQH/\n' +
        'BAUwAwEB/zAdBgNVHQ4EFgQUoE0qZHmDCDB+Bnm8GUa/evpfPwgwDgYDVR0PAQH/\n' +
        'BAQDAgGGMAoGCCqGSM49BAMDA2kAMGYCMQCnil5MMwhY3qoXv0xvcKZGxGPaBV15\n' +
        '0CCssCKn0oVtdJQfJQ3Jrf3RSaEyijXIJsoCMQC35iJi4cWoNX3N/qfgnHohW52O\n' +
        'B5dg0DYMqy5cNZ40+UcAanRMyqNQ6P7fy3umGco=\n' +
        '-----END CERTIFICATE-----\n',
    '-----BEGIN CERTIFICATE-----\n' +
        'MIICtzCCAj2gAwIBAgIQPXnDTPegvJrI98qz8WxrMjAKBggqhkjOPQQDAzCBmzEL\n' +
        'MAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4x\n' +
        'EzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTQwMgYDVQQDDCtBbWF6\n' +
        'b24gUkRTIEJldGEgdXMtZWFzdC0xIFJvb3QgQ0EgRUNDMzg0IEcxMRAwDgYDVQQH\n' +
        'DAdTZWF0dGxlMCAXDTIxMDUxODIxNDAxMloYDzIxMjEwNTE4MjI0MDEyWjCBmzEL\n' +
        'MAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4x\n' +
        'EzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTQwMgYDVQQDDCtBbWF6\n' +
        'b24gUkRTIEJldGEgdXMtZWFzdC0xIFJvb3QgQ0EgRUNDMzg0IEcxMRAwDgYDVQQH\n' +
        'DAdTZWF0dGxlMHYwEAYHKoZIzj0CAQYFK4EEACIDYgAEI0sR7gwutK5AB46hM761\n' +
        'gcLTGBIYlURSEoM1jcBwy56CL+3CJKZwLLyJ7qoOKfWbu5GsVLUTWS8MV6Nw33cx\n' +
        '2KQD2svb694wi+Px2f4n9+XHkEFQw8BbiodDD7RZA70fo0IwQDAPBgNVHRMBAf8E\n' +
        'BTADAQH/MB0GA1UdDgQWBBTQSioOvnVLEMXwNSDg+zgln/vAkjAOBgNVHQ8BAf8E\n' +
        'BAMCAYYwCgYIKoZIzj0EAwMDaAAwZQIxAMwu1hqm5Bc98uE/E0B5iMYbBQ4kpMxO\n' +
        'tP8FTfz5UR37HUn26nXE0puj6S/Ffj4oJgIwXI7s2c26tFQeqzq6u3lrNJHp5jC9\n' +
        'Uxlo/hEJOLoDj5jnpxo8dMAtCNoQPaHdfL0P\n' +
        '-----END CERTIFICATE-----\n',
    '-----BEGIN CERTIFICATE-----\n' +
        'MIICrjCCAjWgAwIBAgIQGKVv+5VuzEZEBzJ+bVfx2zAKBggqhkjOPQQDAzCBlzEL\n' +
        'MAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4x\n' +
        'EzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTAwLgYDVQQDDCdBbWF6\n' +
        'b24gUkRTIGFwLXNvdXRoLTEgUm9vdCBDQSBFQ0MzODQgRzExEDAOBgNVBAcMB1Nl\n' +
        'YXR0bGUwIBcNMjEwNTE5MTc1MDU5WhgPMjEyMTA1MTkxODUwNTlaMIGXMQswCQYD\n' +
        'VQQGEwJVUzEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywgSW5jLjETMBEG\n' +
        'A1UECwwKQW1hem9uIFJEUzELMAkGA1UECAwCV0ExMDAuBgNVBAMMJ0FtYXpvbiBS\n' +
        'RFMgYXAtc291dGgtMSBSb290IENBIEVDQzM4NCBHMTEQMA4GA1UEBwwHU2VhdHRs\n' +
        'ZTB2MBAGByqGSM49AgEGBSuBBAAiA2IABMqdLJ0tZF/DGFZTKZDrGRJZID8ivC2I\n' +
        'JRCYTWweZKCKSCAzoiuGGHzJhr5RlLHQf/QgmFcgXsdmO2n3CggzhA4tOD9Ip7Lk\n' +
        'P05eHd2UPInyPCHRgmGjGb0Z+RdQ6zkitKNCMEAwDwYDVR0TAQH/BAUwAwEB/zAd\n' +
        'BgNVHQ4EFgQUC1yhRgVqU5bR8cGzOUCIxRpl4EYwDgYDVR0PAQH/BAQDAgGGMAoG\n' +
        'CCqGSM49BAMDA2cAMGQCMG0c/zLGECRPzGKJvYCkpFTCUvdP4J74YP0v/dPvKojL\n' +
        't/BrR1Tg4xlfhaib7hPc7wIwFvgqHes20CubQnZmswbTKLUrgSUW4/lcKFpouFd2\n' +
        't2/ewfi/0VhkeUW+IiHhOMdU\n' +
        '-----END CERTIFICATE-----\n',
    '-----BEGIN CERTIFICATE-----\n' +
        'MIIGCTCCA/GgAwIBAgIRAOXxJuyXVkbfhZCkS/dOpfEwDQYJKoZIhvcNAQEMBQAw\n' +
        'gZwxCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJ\n' +
        'bmMuMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTE1MDMGA1UEAwws\n' +
        'QW1hem9uIFJEUyBhcC1ub3J0aGVhc3QtMSBSb290IENBIFJTQTQwOTYgRzExEDAO\n' +
        'BgNVBAcMB1NlYXR0bGUwIBcNMjEwNTI1MjE1OTEwWhgPMjEyMTA1MjUyMjU5MTBa\n' +
        'MIGcMQswCQYDVQQGEwJVUzEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywg\n' +
        'SW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzELMAkGA1UECAwCV0ExNTAzBgNVBAMM\n' +
        'LEFtYXpvbiBSRFMgYXAtbm9ydGhlYXN0LTEgUm9vdCBDQSBSU0E0MDk2IEcxMRAw\n' +
        'DgYDVQQHDAdTZWF0dGxlMIICIjANBgkqhkiG9w0BAQEFAAOCAg8AMIICCgKCAgEA\n' +
        'xiP4RDYm4tIS12hGgn1csfO8onQDmK5SZDswUpl0HIKXOUVVWkHNlINkVxbdqpqH\n' +
        'FhbyZmNN6F/EWopotMDKe1B+NLrjNQf4zefv2vyKvPHJXhxoKmfyuTd5Wk8k1F7I\n' +
        'lNwLQzznB+ElhrLIDJl9Ro8t31YBBNFRGAGEnxyACFGcdkjlsa52UwfYrwreEg2l\n' +
        'gW5AzqHgjFfj9QRLydeU/n4bHm0F1adMsV7P3rVwilcUlqsENDwXnWyPEyv3sw6F\n' +
        'wNemLEs1129mB77fwvySb+lLNGsnzr8w4wdioZ74co+T9z2ca+eUiP+EQccVw1Is\n' +
        'D4Fh57IjPa6Wuc4mwiUYKkKY63+38aCfEWb0Qoi+zW+mE9nek6MOQ914cN12u5LX\n' +
        'dBoYopphRO5YmubSN4xcBy405nIdSdbrAVWwxXnVVyjqjknmNeqQsPZaxAhdoKhV\n' +
        'AqxNr8AUAdOAO6Sz3MslmcLlDXFihrEEOeUbpg/m1mSUUHGbu966ajTG1FuEHHwS\n' +
        '7WB52yxoJo/tHvt9nAWnh3uH5BHmS8zn6s6CGweWKbX5yICnZ1QFR1e4pogxX39v\n' +
        'XD6YcNOO+Vn+HY4nXmjgSYVC7l+eeP8eduMg1xJujzjrbmrXU+d+cBObgdTOAlpa\n' +
        'JFHaGwYw1osAwPCo9cZ2f04yitBfj9aPFia8ASKldakCAwEAAaNCMEAwDwYDVR0T\n' +
        'AQH/BAUwAwEB/zAdBgNVHQ4EFgQUqKS+ltlior0SyZKYAkJ/efv55towDgYDVR0P\n' +
        'AQH/BAQDAgGGMA0GCSqGSIb3DQEBDAUAA4ICAQAdElvp8bW4B+Cv+1WSN87dg6TN\n' +
        'wGyIjJ14/QYURgyrZiYpUmZpj+/pJmprSWXu4KNyqHftmaidu7cdjL5nCAvAfnY5\n' +
        '/6eDDbX4j8Gt9fb/6H9y0O0dn3mUPSEKG0crR+JRFAtPhn/2FNvst2P82yguWLv0\n' +
        'pHjHVUVcq+HqDMtUIJsTPYjSh9Iy77Q6TOZKln9dyDOWJpCSkiUWQtMAKbCSlvzd\n' +
        'zTs/ahqpT+zLfGR1SR+T3snZHgQnbnemmz/XtlKl52NxccARwfcEEKaCRQyGq/pR\n' +
        '0PVZasyJS9JY4JfQs4YOdeOt4UMZ8BmW1+BQWGSkkb0QIRl8CszoKofucAlqdPcO\n' +
        'IT/ZaMVhI580LFGWiQIizWFskX6lqbCyHqJB3LDl8gJISB5vNTHOHpvpMOMs5PYt\n' +
        'cRl5Mrksx5MKMqG7y5R734nMlZxQIHjL5FOoOxTBp9KeWIL/Ib89T2QDaLw1SQ+w\n' +
        'ihqWBJ4ZdrIMWYpP3WqM+MXWk7WAem+xsFJdR+MDgOOuobVQTy5dGBlPks/6gpjm\n' +
        'rO9TjfQ36ppJ3b7LdKUPeRfnYmlR5RU4oyYJ//uLbClI443RZAgxaCXX/nyc12lr\n' +
        'eVLUMNF2abLX4/VF63m2/Z9ACgMRfqGshPssn1NN33OonrotQoj4S3N9ZrjvzKt8\n' +
        'iHcaqd60QKpfiH2A3A==\n' +
        '-----END CERTIFICATE-----\n',
    '-----BEGIN CERTIFICATE-----\n' +
        'MIICuDCCAj2gAwIBAgIQPaVGRuu86nh/ylZVCLB0MzAKBggqhkjOPQQDAzCBmzEL\n' +
        'MAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4x\n' +
        'EzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTQwMgYDVQQDDCtBbWF6\n' +
        'b24gUkRTIGFwLW5vcnRoZWFzdC0xIFJvb3QgQ0EgRUNDMzg0IEcxMRAwDgYDVQQH\n' +
        'DAdTZWF0dGxlMCAXDTIxMDUyNTIyMDMxNloYDzIxMjEwNTI1MjMwMzE2WjCBmzEL\n' +
        'MAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4x\n' +
        'EzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTQwMgYDVQQDDCtBbWF6\n' +
        'b24gUkRTIGFwLW5vcnRoZWFzdC0xIFJvb3QgQ0EgRUNDMzg0IEcxMRAwDgYDVQQH\n' +
        'DAdTZWF0dGxlMHYwEAYHKoZIzj0CAQYFK4EEACIDYgAEexNURoB9KE93MEtEAlJG\n' +
        'obz4LS/pD2hc8Gczix1WhVvpJ8bN5zCDXaKdnDMCebetyRQsmQ2LYlfmCwpZwSDu\n' +
        '0zowB11Pt3I5Avu2EEcuKTlKIDMBeZ1WWuOd3Tf7MEAMo0IwQDAPBgNVHRMBAf8E\n' +
        'BTADAQH/MB0GA1UdDgQWBBSaYbZPBvFLikSAjpa8mRJvyArMxzAOBgNVHQ8BAf8E\n' +
        'BAMCAYYwCgYIKoZIzj0EAwMDaQAwZgIxAOEJkuh3Zjb7Ih/zuNRd1RBqmIYcnyw0\n' +
        'nwUZczKXry+9XebYj3VQxSRNadrarPWVqgIxAMg1dyGoDAYjY/L/9YElyMnvHltO\n' +
        'PwpJShmqHvCLc/mXMgjjYb/akK7yGthvW6j/uQ==\n' +
        '-----END CERTIFICATE-----\n',
    '-----BEGIN CERTIFICATE-----\n' +
        'MIIGCDCCA/CgAwIBAgIQChu3v5W1Doil3v6pgRIcVzANBgkqhkiG9w0BAQwFADCB\n' +
        'nDELMAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIElu\n' +
        'Yy4xEzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTUwMwYDVQQDDCxB\n' +
        'bWF6b24gUkRTIEJldGEgdXMtZWFzdC0xIFJvb3QgQ0EgUlNBNDA5NiBHMTEQMA4G\n' +
        'A1UEBwwHU2VhdHRsZTAgFw0yMTA1MTgyMTM0MTVaGA8yMTIxMDUxODIyMzQxNVow\n' +
        'gZwxCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJ\n' +
        'bmMuMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTE1MDMGA1UEAwws\n' +
        'QW1hem9uIFJEUyBCZXRhIHVzLWVhc3QtMSBSb290IENBIFJTQTQwOTYgRzExEDAO\n' +
        'BgNVBAcMB1NlYXR0bGUwggIiMA0GCSqGSIb3DQEBAQUAA4ICDwAwggIKAoICAQC1\n' +
        'FUGQ5tf3OwpDR6hGBxhUcrkwKZhaXP+1St1lSOQvjG8wXT3RkKzRGMvb7Ee0kzqI\n' +
        'mzKKe4ASIhtV3UUWdlNmP0EA3XKnif6N79MismTeGkDj75Yzp5A6tSvqByCgxIjK\n' +
        'JqpJrch3Dszoyn8+XhwDxMZtkUa5nQVdJgPzJ6ltsQ8E4SWLyLtTu0S63jJDkqYY\n' +
        'S7cQblk7y7fel+Vn+LS5dGTdRRhMvSzEnb6mkVBaVzRyVX90FNUED06e8q+gU8Ob\n' +
        'htvQlf9/kRzHwRAdls2YBhH40ZeyhpUC7vdtPwlmIyvW5CZ/QiG0yglixnL6xahL\n' +
        'pbmTuTSA/Oqz4UGQZv2WzHe1lD2gRHhtFX2poQZeNQX8wO9IcUhrH5XurW/G9Xwl\n' +
        'Sat9CMPERQn4KC3HSkat4ir2xaEUrjfg6c4XsGyh2Pk/LZ0gLKum0dyWYpWP4JmM\n' +
        'RQNjrInXPbMhzQObozCyFT7jYegS/3cppdyy+K1K7434wzQGLU1gYXDKFnXwkX8R\n' +
        'bRKgx2pHNbH5lUddjnNt75+e8m83ygSq/ZNBUz2Ur6W2s0pl6aBjwaDES4VfWYlI\n' +
        'jokcmrGvJNDfQWygb1k00eF2bzNeNCHwgWsuo3HSxVgc/WGsbcGrTlDKfz+g3ich\n' +
        'bXUeUidPhRiv5UQIVCLIHpHuin3bj9lQO/0t6p+tAQIDAQABo0IwQDAPBgNVHRMB\n' +
        'Af8EBTADAQH/MB0GA1UdDgQWBBSFmMBgm5IsRv3hLrvDPIhcPweXYTAOBgNVHQ8B\n' +
        'Af8EBAMCAYYwDQYJKoZIhvcNAQEMBQADggIBAAa2EuozymOsQDJlEi7TqnyA2OhT\n' +
        'GXPfYqCyMJVkfrqNgcnsNpCAiNEiZbb+8sIPXnT8Ay8hrwJYEObJ5b7MHXpLuyft\n' +
        'z0Pu1oFLKnQxKjNxrIsCvaB4CRRdYjm1q7EqGhMGv76se9stOxkOqO9it31w/LoU\n' +
        'ENDk7GLsSqsV1OzYLhaH8t+MaNP6rZTSNuPrHwbV3CtBFl2TAZ7iKgKOhdFz1Hh9\n' +
        'Pez0lG+oKi4mHZ7ajov6PD0W7njn5KqzCAkJR6OYmlNVPjir+c/vUtEs0j+owsMl\n' +
        'g7KE5g4ZpTRShyh5BjCFRK2tv0tkqafzNtxrKC5XNpEkqqVTCnLcKG+OplIEadtr\n' +
        'C7UWf4HyhCiR+xIyxFyR05p3uY/QQU/5uza7GlK0J+U1sBUytx7BZ+Fo8KQfPPqV\n' +
        'CqDCaYUksoJcnJE/KeoksyqNQys7sDGJhkd0NeUGDrFLKHSLhIwAMbEWnqGxvhli\n' +
        'E7sP2E5rI/I9Y9zTbLIiI8pfeZlFF8DBdoP/Hzg8pqsiE/yiXSFTKByDwKzGwNqz\n' +
        'F0VoFdIZcIbLdDbzlQitgGpJtvEL7HseB0WH7B2PMMD8KPJlYvPveO3/6OLzCsav\n' +
        '+CAkvk47NQViKMsUTKOA0JDCW+u981YRozxa3K081snhSiSe83zIPBz1ikldXxO9\n' +
        '6YYLNPRrj3mi9T/f\n' +
        '-----END CERTIFICATE-----\n',
    '-----BEGIN CERTIFICATE-----\n' +
        'MIICrjCCAjSgAwIBAgIRAMkvdFnVDb0mWWFiXqnKH68wCgYIKoZIzj0EAwMwgZYx\n' +
        'CzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMu\n' +
        'MRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTEvMC0GA1UEAwwmQW1h\n' +
        'em9uIFJEUyB1cy13ZXN0LTEgUm9vdCBDQSBFQ0MzODQgRzExEDAOBgNVBAcMB1Nl\n' +
        'YXR0bGUwIBcNMjEwNTE5MTkxMzI0WhgPMjEyMTA1MTkyMDEzMjRaMIGWMQswCQYD\n' +
        'VQQGEwJVUzEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywgSW5jLjETMBEG\n' +
        'A1UECwwKQW1hem9uIFJEUzELMAkGA1UECAwCV0ExLzAtBgNVBAMMJkFtYXpvbiBS\n' +
        'RFMgdXMtd2VzdC0xIFJvb3QgQ0EgRUNDMzg0IEcxMRAwDgYDVQQHDAdTZWF0dGxl\n' +
        'MHYwEAYHKoZIzj0CAQYFK4EEACIDYgAEy86DB+9th/0A5VcWqMSWDxIUblWTt/R0\n' +
        'ao6Z2l3vf2YDF2wt1A2NIOGpfQ5+WAOJO/IQmnV9LhYo+kacB8sOnXdQa6biZZkR\n' +
        'IyouUfikVQAKWEJnh1Cuo5YMM4E2sUt5o0IwQDAPBgNVHRMBAf8EBTADAQH/MB0G\n' +
        'A1UdDgQWBBQ8u3OnecANmG8OoT7KLWDuFzZwBTAOBgNVHQ8BAf8EBAMCAYYwCgYI\n' +
        'KoZIzj0EAwMDaAAwZQIwQ817qkb7mWJFnieRAN+m9W3E0FLVKaV3zC5aYJUk2fcZ\n' +
        'TaUx3oLp3jPLGvY5+wgeAjEA6wAicAki4ZiDfxvAIuYiIe1OS/7H5RA++R8BH6qG\n' +
        'iRzUBM/FItFpnkus7u/eTkvo\n' +
        '-----END CERTIFICATE-----\n',
    '-----BEGIN CERTIFICATE-----\n' +
        'MIICrzCCAjWgAwIBAgIQS/+Ryfgb/IOVEa1pWoe8oTAKBggqhkjOPQQDAzCBlzEL\n' +
        'MAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4x\n' +
        'EzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTAwLgYDVQQDDCdBbWF6\n' +
        'b24gUkRTIGFwLXNvdXRoLTIgUm9vdCBDQSBFQ0MzODQgRzExEDAOBgNVBAcMB1Nl\n' +
        'YXR0bGUwIBcNMjIwNjA2MjE1NDQyWhgPMjEyMjA2MDYyMjU0NDJaMIGXMQswCQYD\n' +
        'VQQGEwJVUzEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywgSW5jLjETMBEG\n' +
        'A1UECwwKQW1hem9uIFJEUzELMAkGA1UECAwCV0ExMDAuBgNVBAMMJ0FtYXpvbiBS\n' +
        'RFMgYXAtc291dGgtMiBSb290IENBIEVDQzM4NCBHMTEQMA4GA1UEBwwHU2VhdHRs\n' +
        'ZTB2MBAGByqGSM49AgEGBSuBBAAiA2IABDsX6fhdUWBQpYTdseBD/P3s96Dtw2Iw\n' +
        'OrXKNToCnmX5nMkUGdRn9qKNiz1pw3EPzaPxShbYwQ7LYP09ENK/JN4QQjxMihxC\n' +
        'jLFxS85nhBQQQGRCWikDAe38mD8fSvREQKNCMEAwDwYDVR0TAQH/BAUwAwEB/zAd\n' +
        'BgNVHQ4EFgQUIh1xZiseQYFjPYKJmGbruAgRH+AwDgYDVR0PAQH/BAQDAgGGMAoG\n' +
        'CCqGSM49BAMDA2gAMGUCMFudS4zLy+UUGrtgNLtRMcu/DZ9BUzV4NdHxo0bkG44O\n' +
        'thnjl4+wTKI6VbyAbj2rkgIxAOHps8NMITU5DpyiMnKTxV8ubb/WGHrLl0BjB8Lw\n' +
        'ETVJk5DNuZvsIIcm7ykk6iL4Tw==\n' +
        '-----END CERTIFICATE-----\n',
    '-----BEGIN CERTIFICATE-----\n' +
        'MIIGBDCCA+ygAwIBAgIQDcEmNIAVrDpUw5cH5ynutDANBgkqhkiG9w0BAQwFADCB\n' +
        'mjELMAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIElu\n' +
        'Yy4xEzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTMwMQYDVQQDDCpB\n' +
        'bWF6b24gUkRTIG1lLWNlbnRyYWwtMSBSb290IENBIFJTQTQwOTYgRzExEDAOBgNV\n' +
        'BAcMB1NlYXR0bGUwIBcNMjIwNTA3MDA0MDIzWhgPMjEyMjA1MDcwMTQwMjNaMIGa\n' +
        'MQswCQYDVQQGEwJVUzEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywgSW5j\n' +
        'LjETMBEGA1UECwwKQW1hem9uIFJEUzELMAkGA1UECAwCV0ExMzAxBgNVBAMMKkFt\n' +
        'YXpvbiBSRFMgbWUtY2VudHJhbC0xIFJvb3QgQ0EgUlNBNDA5NiBHMTEQMA4GA1UE\n' +
        'BwwHU2VhdHRsZTCCAiIwDQYJKoZIhvcNAQEBBQADggIPADCCAgoCggIBAKvADk8t\n' +
        'Fl9bFlU5sajLPPDSOUpPAkKs6iPlz+27o1GJC88THcOvf3x0nVAcu9WYe9Qaas+4\n' +
        'j4a0vv51agqyODRD/SNi2HnqW7DbtLPAm6KBHe4twl28ItB/JD5g7u1oPAHFoXMS\n' +
        'cH1CZEAs5RtlZGzJhcBXLFsHNv/7+SCLyZ7+2XFh9OrtgU4wMzkHoRNndhfwV5bu\n' +
        '17bPTwuH+VxH37zXf1mQ/KjhuJos0C9dL0FpjYBAuyZTAWhZKs8dpSe4DI544z4w\n' +
        'gkwUB4bC2nA1TBzsywEAHyNuZ/xRjNpWvx0ToWAA2iFJqC3VO3iKcnBplMvaUuMt\n' +
        'jwzVSNBnKcoabXCZL2XDLt4YTZR8FSwz05IvsmwcPB7uNTBXq3T9sjejW8QQK3vT\n' +
        'tzyfLq4jKmQE7PoS6cqYm+hEPm2hDaC/WP9bp3FdEJxZlPH26fq1b7BWYWhQ9pBA\n' +
        'Nv9zTnzdR1xohTyOJBUFQ81ybEzabqXqVXUIANqIOaNcTB09/sLJ7+zuMhp3mwBu\n' +
        'LtjfJv8PLuT1r63bU3seROhKA98b5KfzjvbvPSg3vws78JQyoYGbqNyDfyjVjg3U\n' +
        'v//AdVuPie6PNtdrW3upZY4Qti5IjP9e3kimaJ+KAtTgMRG56W0WxD3SP7+YGGbG\n' +
        'KhntDOkKsN39hLpn9UOafTIqFu7kIaueEy/NAgMBAAGjQjBAMA8GA1UdEwEB/wQF\n' +
        'MAMBAf8wHQYDVR0OBBYEFHAems86dTwdZbLe8AaPy3kfIUVoMA4GA1UdDwEB/wQE\n' +
        'AwIBhjANBgkqhkiG9w0BAQwFAAOCAgEAOBHpp0ICx81kmeoBcZTrMdJs2gnhcd85\n' +
        'FoSCjXx9H5XE5rmN/lQcxxOgj8hr3uPuLdLHu+i6THAyzjrl2NA1FWiqpfeECGmy\n' +
        '0jm7iZsYORgGQYp/VKnDrwnKNSqlZvOuRr0kfUexwFlr34Y4VmupvEOK/RdGsd3S\n' +
        '+3hiemcHse9ST/sJLHx962AWMkN86UHPscJEe4+eT3f2Wyzg6La8ARwdWZSNS+WH\n' +
        'ZfybrncMmuiXuUdHv9XspPsqhKgtHhcYeXOGUtrwQPLe3+VJZ0LVxhlTWr9951GZ\n' +
        'GfmWwTV/9VsyKVaCFIXeQ6L+gjcKyEzYF8wpMtQlSc7FFqwgC4bKxvMBSaRy88Nr\n' +
        'lV2+tJD/fr8zGUeBK44Emon0HKDBWGX+/Hq1ZIv0Da0S+j6LbA4fusWxtGfuGha+\n' +
        'luhHgVInCpALIOamiBEdGhILkoTtx7JrYppt3/Raqg9gUNCOOYlCvGhqX7DXeEfL\n' +
        'DGabooiY2FNWot6h04JE9nqGj5QqT8D6t/TL1nzxhRPzbcSDIHUd/b5R+a0bAA+7\n' +
        'YTU6JqzEVCWKEIEynYmqikgLMGB/OzWsgyEL6822QW6hJAQ78XpbNeCzrICF4+GC\n' +
        '7KShLnwuWoWpAb26268lvOEvCTFM47VC6jNQl97md+2SA9Ma81C9wflid2M83Wle\n' +
        'cuLMVcQZceE=\n' +
        '-----END CERTIFICATE-----\n',
    '-----BEGIN CERTIFICATE-----\n' +
        'MIIEADCCAuigAwIBAgIQAhAteLRCvizAElaWORFU2zANBgkqhkiG9w0BAQsFADCB\n' +
        'mDELMAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIElu\n' +
        'Yy4xEzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTEwLwYDVQQDDChB\n' +
        'bWF6b24gUkRTIG1lLXNvdXRoLTEgUm9vdCBDQSBSU0EyMDQ4IEcxMRAwDgYDVQQH\n' +
        'DAdTZWF0dGxlMCAXDTIxMDUyMDE3MDkxNloYDzIwNjEwNTIwMTgwOTE2WjCBmDEL\n' +
        'MAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4x\n' +
        'EzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTEwLwYDVQQDDChBbWF6\n' +
        'b24gUkRTIG1lLXNvdXRoLTEgUm9vdCBDQSBSU0EyMDQ4IEcxMRAwDgYDVQQHDAdT\n' +
        'ZWF0dGxlMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA+qg7JAcOVKjh\n' +
        'N83SACnBFZPyB63EusfDr/0V9ZdL8lKcmZX9sv/CqoBo3N0EvBqHQqUUX6JvFb7F\n' +
        'XrMUZ740kr28gSRALfXTFgNODjXeDsCtEkKRTkac/UM8xXHn+hR7UFRPHS3e0GzI\n' +
        'iLiwQWDkr0Op74W8aM0CfaVKvh2bp4BI1jJbdDnQ9OKXpOxNHGUf0ZGb7TkNPkgI\n' +
        'b2CBAc8J5o3H9lfw4uiyvl6Fz5JoP+A+zPELAioYBXDrbE7wJeqQDJrETWqR9VEK\n' +
        'BXURCkVnHeaJy123MpAX2ozf4pqk0V0LOEOZRS29I+USF5DcWr7QIXR/w2I8ws1Q\n' +
        '7ys+qbE+kQIDAQABo0IwQDAPBgNVHRMBAf8EBTADAQH/MB0GA1UdDgQWBBQFJ16n\n' +
        '1EcCMOIhoZs/F9sR+Jy++zAOBgNVHQ8BAf8EBAMCAYYwDQYJKoZIhvcNAQELBQAD\n' +
        'ggEBAOc5nXbT3XTDEZsxX2iD15YrQvmL5m13B3ImZWpx/pqmObsgx3/dg75rF2nQ\n' +
        'qS+Vl+f/HLh516pj2BPP/yWCq12TRYigGav8UH0qdT3CAClYy2o+zAzUJHm84oiB\n' +
        'ud+6pFVGkbqpsY+QMpJUbZWu52KViBpJMYsUEy+9cnPSFRVuRAHjYynSiLk2ZEjb\n' +
        'Wkdc4x0nOZR5tP0FgrX0Ve2KcjFwVQJVZLgOUqmFYQ/G0TIIGTNh9tcmR7yp+xJR\n' +
        'A2tbPV2Z6m9Yxx4E8lLEPNuoeouJ/GR4CkMEmF8cLwM310t174o3lKKUXJ4Vs2HO\n' +
        'Wj2uN6R9oI+jGLMSswTzCNV1vgc=\n' +
        '-----END CERTIFICATE-----\n',
    '-----BEGIN CERTIFICATE-----\n' +
        'MIICuDCCAj6gAwIBAgIRAOocLeZWjYkG/EbHmscuy8gwCgYIKoZIzj0EAwMwgZsx\n' +
        'CzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMu\n' +
        'MRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTE0MDIGA1UEAwwrQW1h\n' +
        'em9uIFJEUyBhcC1zb3V0aGVhc3QtMSBSb290IENBIEVDQzM4NCBHMTEQMA4GA1UE\n' +
        'BwwHU2VhdHRsZTAgFw0yMTA1MjEyMTUwMDFaGA8yMTIxMDUyMTIyNTAwMVowgZsx\n' +
        'CzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMu\n' +
        'MRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTE0MDIGA1UEAwwrQW1h\n' +
        'em9uIFJEUyBhcC1zb3V0aGVhc3QtMSBSb290IENBIEVDQzM4NCBHMTEQMA4GA1UE\n' +
        'BwwHU2VhdHRsZTB2MBAGByqGSM49AgEGBSuBBAAiA2IABCEr3jq1KtRncnZfK5cq\n' +
        'btY0nW6ZG3FMbh7XwBIR6Ca0f8llGZ4vJEC1pXgiM/4Dh045B9ZIzNrR54rYOIfa\n' +
        '2NcYZ7mk06DjIQML64hbAxbQzOAuNzLPx268MrlL2uW2XaNCMEAwDwYDVR0TAQH/\n' +
        'BAUwAwEB/zAdBgNVHQ4EFgQUln75pChychwN4RfHl+tOinMrfVowDgYDVR0PAQH/\n' +
        'BAQDAgGGMAoGCCqGSM49BAMDA2gAMGUCMGiyPINRU1mwZ4Crw01vpuPvxZxb2IOr\n' +
        'yX3RNlOIu4We1H+5dQk5tIvH8KGYFbWEpAIxAO9NZ6/j9osMhLgZ0yj0WVjb+uZx\n' +
        'YlZR9fyFisY/jNfX7QhSk+nrc3SFLRUNtpXrng==\n' +
        '-----END CERTIFICATE-----\n',
    '-----BEGIN CERTIFICATE-----\n' +
        'MIIEBTCCAu2gAwIBAgIRAKiaRZatN8eiz9p0s0lu0rQwDQYJKoZIhvcNAQELBQAw\n' +
        'gZoxCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJ\n' +
        'bmMuMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTEzMDEGA1UEAwwq\n' +
        'QW1hem9uIFJEUyBjYS1jZW50cmFsLTEgUm9vdCBDQSBSU0EyMDQ4IEcxMRAwDgYD\n' +
        'VQQHDAdTZWF0dGxlMCAXDTIxMDUyMTIyMDIzNVoYDzIwNjEwNTIxMjMwMjM1WjCB\n' +
        'mjELMAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIElu\n' +
        'Yy4xEzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTMwMQYDVQQDDCpB\n' +
        'bWF6b24gUkRTIGNhLWNlbnRyYWwtMSBSb290IENBIFJTQTIwNDggRzExEDAOBgNV\n' +
        'BAcMB1NlYXR0bGUwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQCygVMf\n' +
        'qB865IR9qYRBRFHn4eAqGJOCFx+UbraQZmjr/mnRqSkY+nhbM7Pn/DWOrRnxoh+w\n' +
        'q5F9ZxdZ5D5T1v6kljVwxyfFgHItyyyIL0YS7e2h7cRRscCM+75kMedAP7icb4YN\n' +
        'LfWBqfKHbHIOqvvQK8T6+Emu/QlG2B5LvuErrop9K0KinhITekpVIO4HCN61cuOe\n' +
        'CADBKF/5uUJHwS9pWw3uUbpGUwsLBuhJzCY/OpJlDqC8Y9aToi2Ivl5u3/Q/sKjr\n' +
        '6AZb9lx4q3J2z7tJDrm5MHYwV74elGSXoeoG8nODUqjgklIWAPrt6lQ3WJpO2kug\n' +
        '8RhCdSbWkcXHfX95AgMBAAGjQjBAMA8GA1UdEwEB/wQFMAMBAf8wHQYDVR0OBBYE\n' +
        'FOIxhqTPkKVqKBZvMWtKewKWDvDBMA4GA1UdDwEB/wQEAwIBhjANBgkqhkiG9w0B\n' +
        'AQsFAAOCAQEAqoItII89lOl4TKvg0I1EinxafZLXIheLcdGCxpjRxlZ9QMQUN3yb\n' +
        'y/8uFKBL0otbQgJEoGhxm4h0tp54g28M6TN1U0332dwkjYxUNwvzrMaV5Na55I2Z\n' +
        '1hq4GB3NMXW+PvdtsgVOZbEN+zOyOZ5MvJHEQVkT3YRnf6avsdntltcRzHJ16pJc\n' +
        'Y8rR7yWwPXh1lPaPkxddrCtwayyGxNbNmRybjR48uHRhwu7v2WuAMdChL8H8bp89\n' +
        'TQLMrMHgSbZfee9hKhO4Zebelf1/cslRSrhkG0ESq6G5MUINj6lMg2g6F0F7Xz2v\n' +
        'ncD/vuRN5P+vT8th/oZ0Q2Gc68Pun0cn/g==\n' +
        '-----END CERTIFICATE-----\n',
    '-----BEGIN CERTIFICATE-----\n' +
        'MIID/zCCAuegAwIBAgIRAJYlnmkGRj4ju/2jBQsnXJYwDQYJKoZIhvcNAQELBQAw\n' +
        'gZcxCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJ\n' +
        'bmMuMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTEwMC4GA1UEAwwn\n' +
        'QW1hem9uIFJEUyB1cy1lYXN0LTIgUm9vdCBDQSBSU0EyMDQ4IEcxMRAwDgYDVQQH\n' +
        'DAdTZWF0dGxlMCAXDTIxMDUyMTIzMDQ0NFoYDzIwNjEwNTIyMDAwNDQ0WjCBlzEL\n' +
        'MAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4x\n' +
        'EzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTAwLgYDVQQDDCdBbWF6\n' +
        'b24gUkRTIHVzLWVhc3QtMiBSb290IENBIFJTQTIwNDggRzExEDAOBgNVBAcMB1Nl\n' +
        'YXR0bGUwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQC74V3eigv+pCj5\n' +
        'nqDBqplY0Jp16pTeNB06IKbzb4MOTvNde6QjsZxrE1xUmprT8LxQqN9tI3aDYEYk\n' +
        'b9v4F99WtQVgCv3Y34tYKX9NwWQgwS1vQwnIR8zOFBYqsAsHEkeJuSqAB12AYUSd\n' +
        'Zv2RVFjiFmYJho2X30IrSLQfS/IE3KV7fCyMMm154+/K1Z2IJlcissydEAwgsUHw\n' +
        'edrE6CxJVkkJ3EvIgG4ugK/suxd8eEMztaQYJwSdN8TdfT59LFuSPl7zmF3fIBdJ\n' +
        '//WexcQmGabaJ7Xnx+6o2HTfkP8Zzzzaq8fvjAcvA7gyFH5EP26G2ZqMG+0y4pTx\n' +
        'SPVTrQEXAgMBAAGjQjBAMA8GA1UdEwEB/wQFMAMBAf8wHQYDVR0OBBYEFIWWuNEF\n' +
        'sUMOC82XlfJeqazzrkPDMA4GA1UdDwEB/wQEAwIBhjANBgkqhkiG9w0BAQsFAAOC\n' +
        'AQEAgClmxcJaQTGpEZmjElL8G2Zc8lGc+ylGjiNlSIw8X25/bcLRptbDA90nuP+q\n' +
        'zXAMhEf0ccbdpwxG/P5a8JipmHgqQLHfpkvaXx+0CuP++3k+chAJ3Gk5XtY587jX\n' +
        '+MJfrPgjFt7vmMaKmynndf+NaIJAYczjhJj6xjPWmGrjM3MlTa9XesmelMwP3jep\n' +
        'bApIWAvCYVjGndbK9byyMq1nyj0TUzB8oJZQooaR3MMjHTmADuVBylWzkRMxbKPl\n' +
        '4Nlsk4Ef1JvIWBCzsMt+X17nuKfEatRfp3c9tbpGlAE/DSP0W2/Lnayxr4RpE9ds\n' +
        'ICF35uSis/7ZlsftODUe8wtpkQ==\n' +
        '-----END CERTIFICATE-----\n',
    '-----BEGIN CERTIFICATE-----\n' +
        'MIIF/zCCA+egAwIBAgIRAPvvd+MCcp8E36lHziv0xhMwDQYJKoZIhvcNAQEMBQAw\n' +
        'gZcxCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJ\n' +
        'bmMuMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTEwMC4GA1UEAwwn\n' +
        'QW1hem9uIFJEUyB1cy1lYXN0LTIgUm9vdCBDQSBSU0E0MDk2IEcxMRAwDgYDVQQH\n' +
        'DAdTZWF0dGxlMCAXDTIxMDUyMTIzMTEwNloYDzIxMjEwNTIyMDAxMTA2WjCBlzEL\n' +
        'MAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4x\n' +
        'EzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTAwLgYDVQQDDCdBbWF6\n' +
        'b24gUkRTIHVzLWVhc3QtMiBSb290IENBIFJTQTQwOTYgRzExEDAOBgNVBAcMB1Nl\n' +
        'YXR0bGUwggIiMA0GCSqGSIb3DQEBAQUAA4ICDwAwggIKAoICAQDbvwekKIKGcV/s\n' +
        'lDU96a71ZdN2pTYkev1X2e2/ICb765fw/i1jP9MwCzs8/xHBEQBJSxdfO4hPeNx3\n' +
        'ENi0zbM+TrMKliS1kFVe1trTTEaHYjF8BMK9yTY0VgSpWiGxGwg4tshezIA5lpu8\n' +
        'sF6XMRxosCEVCxD/44CFqGZTzZaREIvvFPDTXKJ6yOYnuEkhH3OcoOajHN2GEMMQ\n' +
        'ShuyRFDQvYkqOC/Q5icqFbKg7eGwfl4PmimdV7gOVsxSlw2s/0EeeIILXtHx22z3\n' +
        '8QBhX25Lrq2rMuaGcD3IOMBeBo2d//YuEtd9J+LGXL9AeOXHAwpvInywJKAtXTMq\n' +
        'Wsy3LjhuANFrzMlzjR2YdjkGVzeQVx3dKUzJ2//Qf7IXPSPaEGmcgbxuatxjnvfT\n' +
        'H85oeKr3udKnXm0Kh7CLXeqJB5ITsvxI+Qq2iXtYCc+goHNR01QJwtGDSzuIMj3K\n' +
        'f+YMrqBXZgYBwU2J/kCNTH31nfw96WTbOfNGwLwmVRDgguzFa+QzmQsJW4FTDMwc\n' +
        '7cIjwdElQQVA+Gqa67uWmyDKAnoTkudmgAP+OTBkhnmc6NJuZDcy6f/iWUdl0X0u\n' +
        '/tsfgXXR6ZovnHonM13ANiN7VmEVqFlEMa0VVmc09m+2FYjjlk8F9sC7Rc4wt214\n' +
        '7u5YvCiCsFZwx44baP5viyRZgkJVpQIDAQABo0IwQDAPBgNVHRMBAf8EBTADAQH/\n' +
        'MB0GA1UdDgQWBBQgCZCsc34nVTRbWsniXBPjnUTQ2DAOBgNVHQ8BAf8EBAMCAYYw\n' +
        'DQYJKoZIhvcNAQEMBQADggIBAAQas3x1G6OpsIvQeMS9BbiHG3+kU9P/ba6Rrg+E\n' +
        'lUz8TmL04Bcd+I+R0IyMBww4NznT+K60cFdk+1iSmT8Q55bpqRekyhcdWda1Qu0r\n' +
        'JiTi7zz+3w2v66akofOnGevDpo/ilXGvCUJiLOBnHIF0izUqzvfczaMZGJT6xzKq\n' +
        'PcEVRyAN1IHHf5KnGzUlVFv9SGy47xJ9I1vTk24JU0LWkSLzMMoxiUudVmHSqJtN\n' +
        'u0h+n/x3Q6XguZi1/C1KOntH56ewRh8n5AF7c+9LJJSRM9wunb0Dzl7BEy21Xe9q\n' +
        '03xRYjf5wn8eDELB8FZPa1PrNKXIOLYM9egdctbKEcpSsse060+tkyBrl507+SJT\n' +
        '04lvJ4tcKjZFqxn+bUkDQvXYj0D3WK+iJ7a8kZJPRvz8BDHfIqancY8Tgw+69SUn\n' +
        'WqIb+HNZqFuRs16WFSzlMksqzXv6wcDSyI7aZOmCGGEcYW9NHk8EuOnOQ+1UMT9C\n' +
        'Qb1GJcipjRzry3M4KN/t5vN3hIetB+/PhmgTO4gKhBETTEyPC3HC1QbdVfRndB6e\n' +
        'U/NF2U/t8U2GvD26TTFLK4pScW7gyw4FQyXWs8g8FS8f+R2yWajhtS9++VDJQKom\n' +
        'fAUISoCH+PlPRJpu/nHd1Zrddeiiis53rBaLbXu2J1Q3VqjWOmtj0HjxJJxWnYmz\n' +
        'Pqj2\n' +
        '-----END CERTIFICATE-----\n',
    '-----BEGIN CERTIFICATE-----\n' +
        'MIIGATCCA+mgAwIBAgIRAI/U4z6+GF8/znpHM8Dq8G0wDQYJKoZIhvcNAQEMBQAw\n' +
        'gZgxCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJ\n' +
        'bmMuMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTExMC8GA1UEAwwo\n' +
        'QW1hem9uIFJEUyBhcC1zb3V0aC0yIFJvb3QgQ0EgUlNBNDA5NiBHMTEQMA4GA1UE\n' +
        'BwwHU2VhdHRsZTAgFw0yMjA2MDYyMTQ4MThaGA8yMTIyMDYwNjIyNDgxOFowgZgx\n' +
        'CzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMu\n' +
        'MRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTExMC8GA1UEAwwoQW1h\n' +
        'em9uIFJEUyBhcC1zb3V0aC0yIFJvb3QgQ0EgUlNBNDA5NiBHMTEQMA4GA1UEBwwH\n' +
        'U2VhdHRsZTCCAiIwDQYJKoZIhvcNAQEBBQADggIPADCCAgoCggIBAK5WqMvyq888\n' +
        '3uuOtEj1FcP6iZhqO5kJurdJF59Otp2WCg+zv6I+QwaAspEWHQsKD405XfFsTGKV\n' +
        'SKTCwoMxwBniuChSmyhlagQGKSnRY9+znOWq0v7hgmJRwp6FqclTbubmr+K6lzPy\n' +
        'hs86mEp68O5TcOTYWUlPZDqfKwfNTbtCl5YDRr8Gxb5buHmkp6gUSgDkRsXiZ5VV\n' +
        'b3GBmXRqbnwo5ZRNAzQeM6ylXCn4jKs310lQGUrFbrJqlyxUdfxzqdlaIRn2X+HY\n' +
        'xRSYbHox3LVNPpJxYSBRvpQVFSy9xbX8d1v6OM8+xluB31cbLBtm08KqPFuqx+cO\n' +
        'I2H5F0CYqYzhyOSKJsiOEJT6/uH4ewryskZzncx9ae62SC+bB5n3aJLmOSTkKLFY\n' +
        'YS5IsmDT2m3iMgzsJNUKVoCx2zihAzgBanFFBsG+Xmoq0aKseZUI6vd2qpd5tUST\n' +
        '/wS1sNk0Ph7teWB2ACgbFE6etnJ6stwjHFZOj/iTYhlnR2zDRU8akunFdGb6CB4/\n' +
        'hMxGJxaqXSJeGtHm7FpadlUTf+2ESbYcVW+ui/F8sdBJseQdKZf3VdZZMgM0bcaX\n' +
        'NE47cauDTy72WdU9YJX/YXKYMLDE0iFHTnGpfVGsuWGPYhlwZ3dFIO07mWnCRM6X\n' +
        'u5JXRB1oy5n5HRluMsmpSN/R92MeBxKFAgMBAAGjQjBAMA8GA1UdEwEB/wQFMAMB\n' +
        'Af8wHQYDVR0OBBYEFNtH0F0xfijSLHEyIkRGD9gW6NazMA4GA1UdDwEB/wQEAwIB\n' +
        'hjANBgkqhkiG9w0BAQwFAAOCAgEACo+5jFeY3ygxoDDzL3xpfe5M0U1WxdKk+az4\n' +
        '/OfjZvkoma7WfChi3IIMtwtKLYC2/seKWA4KjlB3rlTsCVNPnK6D+gAnybcfTKk/\n' +
        'IRSPk92zagwQkSUWtAk80HpVfWJzpkSU16ejiajhedzOBRtg6BwsbSqLCDXb8hXr\n' +
        'eXWC1S9ZceGc+LcKRHewGWPu31JDhHE9bNcl9BFSAS0lYVZqxIRWxivZ+45j5uQv\n' +
        'wPrC8ggqsdU3K8quV6dblUQzzA8gKbXJpCzXZihkPrYpQHTH0szvXvgebh+CNUAG\n' +
        'rUxm8+yTS0NFI3U+RLbcLFVzSvjMOnEwCX0SPj5XZRYYXs5ajtQCoZhTUkkwpDV8\n' +
        'RxXk8qGKiXwUxDO8GRvmvM82IOiXz5w2jy/h7b7soyIgdYiUydMq4Ja4ogB/xPZa\n' +
        'gf4y0o+bremO15HFf1MkaU2UxPK5FFVUds05pKvpSIaQWbF5lw4LHHj4ZtVup7zF\n' +
        'CLjPWs4Hs/oUkxLMqQDw0FBwlqa4uot8ItT8uq5BFpz196ZZ+4WXw5PVzfSxZibI\n' +
        'C/nwcj0AS6qharXOs8yPnPFLPSZ7BbmWzFDgo3tpglRqo3LbSPsiZR+sLeivqydr\n' +
        '0w4RK1btRda5Ws88uZMmW7+2aufposMKcbAdrApDEAVzHijbB/nolS5nsnFPHZoA\n' +
        'KDPtFEk=\n' +
        '-----END CERTIFICATE-----\n',
    '-----BEGIN CERTIFICATE-----\n' +
        'MIICtzCCAj2gAwIBAgIQVZ5Y/KqjR4XLou8MCD5pOjAKBggqhkjOPQQDAzCBmzEL\n' +
        'MAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4x\n' +
        'EzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTQwMgYDVQQDDCtBbWF6\n' +
        'b24gUkRTIGFwLXNvdXRoZWFzdC00IFJvb3QgQ0EgRUNDMzg0IEcxMRAwDgYDVQQH\n' +
        'DAdTZWF0dGxlMCAXDTIyMDUyNTE2NTgzM1oYDzIxMjIwNTI1MTc1ODMzWjCBmzEL\n' +
        'MAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4x\n' +
        'EzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTQwMgYDVQQDDCtBbWF6\n' +
        'b24gUkRTIGFwLXNvdXRoZWFzdC00IFJvb3QgQ0EgRUNDMzg0IEcxMRAwDgYDVQQH\n' +
        'DAdTZWF0dGxlMHYwEAYHKoZIzj0CAQYFK4EEACIDYgAEbo473OmpD5vkckdJajXg\n' +
        'brhmNFyoSa0WCY1njuZC2zMFp3zP6rX4I1r3imrYnJd9pFH/aSiV/r6L5ACE5RPx\n' +
        '4qdg5SQ7JJUaZc3DWsTOiOed7BCZSzM+KTYK/2QzDMApo0IwQDAPBgNVHRMBAf8E\n' +
        'BTADAQH/MB0GA1UdDgQWBBTmogc06+1knsej1ltKUOdWFvwgsjAOBgNVHQ8BAf8E\n' +
        'BAMCAYYwCgYIKoZIzj0EAwMDaAAwZQIxAIs7TlLMbGTWNXpGiKf9DxaM07d/iDHe\n' +
        'F/Vv/wyWSTGdobxBL6iArQNVXz0Gr4dvPAIwd0rsoa6R0x5mtvhdRPtM37FYrbHJ\n' +
        'pbV+OMusQqcSLseunLBoCHenvJW0QOCQ8EDY\n' +
        '-----END CERTIFICATE-----\n',
    '-----BEGIN CERTIFICATE-----\n' +
        'MIICvTCCAkOgAwIBAgIQCIY7E/bFvFN2lK9Kckb0dTAKBggqhkjOPQQDAzCBnjEL\n' +
        'MAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4x\n' +
        'EzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTcwNQYDVQQDDC5BbWF6\n' +
        'b24gUkRTIFByZXZpZXcgdXMtZWFzdC0yIFJvb3QgQ0EgRUNDMzg0IEcxMRAwDgYD\n' +
        'VQQHDAdTZWF0dGxlMCAXDTIxMDUxODIxMDUxMFoYDzIxMjEwNTE4MjIwNTEwWjCB\n' +
        'njELMAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIElu\n' +
        'Yy4xEzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTcwNQYDVQQDDC5B\n' +
        'bWF6b24gUkRTIFByZXZpZXcgdXMtZWFzdC0yIFJvb3QgQ0EgRUNDMzg0IEcxMRAw\n' +
        'DgYDVQQHDAdTZWF0dGxlMHYwEAYHKoZIzj0CAQYFK4EEACIDYgAEMI0hzf1JCEOI\n' +
        'Eue4+DmcNnSs2i2UaJxHMrNGGfU7b42a7vwP53F7045ffHPBGP4jb9q02/bStZzd\n' +
        'VHqfcgqkSRI7beBKjD2mfz82hF/wJSITTgCLs+NRpS6zKMFOFHUNo0IwQDAPBgNV\n' +
        'HRMBAf8EBTADAQH/MB0GA1UdDgQWBBS8uF/6hk5mPLH4qaWv9NVZaMmyTjAOBgNV\n' +
        'HQ8BAf8EBAMCAYYwCgYIKoZIzj0EAwMDaAAwZQIxAO7Pu9wzLyM0X7Q08uLIL+vL\n' +
        'qaxe3UFuzFTWjM16MLJHbzLf1i9IDFKz+Q4hXCSiJwIwClMBsqT49BPUxVsJnjGr\n' +
        'EbyEk6aOOVfY1p2yQL649zh3M4h8okLnwf+bYIb1YpeU\n' +
        '-----END CERTIFICATE-----\n',
    '-----BEGIN CERTIFICATE-----\n' +
        'MIIEADCCAuigAwIBAgIQY+JhwFEQTe36qyRlUlF8ozANBgkqhkiG9w0BAQsFADCB\n' +
        'mDELMAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIElu\n' +
        'Yy4xEzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTEwLwYDVQQDDChB\n' +
        'bWF6b24gUkRTIGFmLXNvdXRoLTEgUm9vdCBDQSBSU0EyMDQ4IEcxMRAwDgYDVQQH\n' +
        'DAdTZWF0dGxlMCAXDTIxMDUxOTE5MjQxNloYDzIwNjEwNTE5MjAyNDE2WjCBmDEL\n' +
        'MAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4x\n' +
        'EzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTEwLwYDVQQDDChBbWF6\n' +
        'b24gUkRTIGFmLXNvdXRoLTEgUm9vdCBDQSBSU0EyMDQ4IEcxMRAwDgYDVQQHDAdT\n' +
        'ZWF0dGxlMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAnIye77j6ev40\n' +
        '8wRPyN2OdKFSUfI9jB20Or2RLO+RDoL43+USXdrze0Wv4HMRLqaen9BcmCfaKMp0\n' +
        'E4SFo47bXK/O17r6G8eyq1sqnHE+v288mWtYH9lAlSamNFRF6YwA7zncmE/iKL8J\n' +
        '0vePHMHP/B6svw8LULZCk+nZk3tgxQn2+r0B4FOz+RmpkoVddfqqUPMbKUxhM2wf\n' +
        'fO7F6bJaUXDNMBPhCn/3ayKCjYr49ErmnpYV2ZVs1i34S+LFq39J7kyv6zAgbHv9\n' +
        '+/MtRMoRB1CjpqW0jIOZkHBdYcd1o9p1zFn591Do1wPkmMsWdjIYj+6e7UXcHvOB\n' +
        '2+ScIRAcnwIDAQABo0IwQDAPBgNVHRMBAf8EBTADAQH/MB0GA1UdDgQWBBQGtq2W\n' +
        'YSyMMxpdQ3IZvcGE+nyZqTAOBgNVHQ8BAf8EBAMCAYYwDQYJKoZIhvcNAQELBQAD\n' +
        'ggEBAEgoP3ixJsKSD5FN8dQ01RNHERl/IFbA7TRXfwC+L1yFocKnQh4Mp/msPRSV\n' +
        '+OeHIvemPW/wtZDJzLTOFJ6eTolGekHK1GRTQ6ZqsWiU2fmiOP8ks4oSpI+tQ9Lw\n' +
        'VrfZqTiEcS5wEIqyfUAZZfKDo7W1xp+dQWzfczSBuZJZwI5iaha7+ILM0r8Ckden\n' +
        'TVTapc5pLSoO15v0ziRuQ2bT3V3nwu/U0MRK44z+VWOJdSiKxdnOYDs8hFNnKhfe\n' +
        'klbTZF7kW7WbiNYB43OaAQBJ6BALZsIskEaqfeZT8FD71uN928TcEQyBDXdZpRN+\n' +
        'iGQZDGhht0r0URGMDSs9waJtTfA=\n' +
        '-----END CERTIFICATE-----\n',
    '-----BEGIN CERTIFICATE-----\n' +
        'MIIF/jCCA+agAwIBAgIQXY/dmS+72lZPranO2JM9jjANBgkqhkiG9w0BAQwFADCB\n' +
        'lzELMAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIElu\n' +
        'Yy4xEzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTAwLgYDVQQDDCdB\n' +
        'bWF6b24gUkRTIGFwLWVhc3QtMSBSb290IENBIFJTQTQwOTYgRzExEDAOBgNVBAcM\n' +
        'B1NlYXR0bGUwIBcNMjEwNTI1MjEzNDUxWhgPMjEyMTA1MjUyMjM0NTFaMIGXMQsw\n' +
        'CQYDVQQGEwJVUzEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywgSW5jLjET\n' +
        'MBEGA1UECwwKQW1hem9uIFJEUzELMAkGA1UECAwCV0ExMDAuBgNVBAMMJ0FtYXpv\n' +
        'biBSRFMgYXAtZWFzdC0xIFJvb3QgQ0EgUlNBNDA5NiBHMTEQMA4GA1UEBwwHU2Vh\n' +
        'dHRsZTCCAiIwDQYJKoZIhvcNAQEBBQADggIPADCCAgoCggIBAMyW9kBJjD/hx8e8\n' +
        'b5E1sF42bp8TXsz1htSYE3Tl3T1Aq379DfEhB+xa/ASDZxt7/vwa81BkNo4M6HYq\n' +
        'okYIXeE7cu5SnSgjWXqcERhgPevtAwgmhdE3yREe8oz2DyOi2qKKZqah+1gpPaIQ\n' +
        'fK0uAqoeQlyHosye3KZZKkDHBatjBsQ5kf8lhuf7wVulEZVRHY2bP2X7N98PfbpL\n' +
        'QdH7mWXzDtJJ0LiwFwds47BrkgK1pkHx2p1mTo+HMkfX0P6Fq1atkVC2RHHtbB/X\n' +
        'iYyH7paaHBzviFrhr679zNqwXIOKlbf74w3mS11P76rFn9rS1BAH2Qm6eY5S/Fxe\n' +
        'HEKXm4kjPN63Zy0p3yE5EjPt54yPkvumOnT+RqDGJ2HCI9k8Ehcbve0ogfdRKNqQ\n' +
        'VHWYTy8V33ndQRHZlx/CuU1yN61TH4WSoMly1+q1ihTX9sApmlQ14B2pJi/9DnKW\n' +
        'cwECrPy1jAowC2UJ45RtC8UC05CbP9yrIy/7Noj8gQDiDOepm+6w1g6aNlWoiuQS\n' +
        'kyI6nzz1983GcnOHya73ga7otXo0Qfg9jPghlYiMomrgshlSLDHZG0Ib/3hb8cnR\n' +
        '1OcN9FpzNmVK2Ll1SmTMLrIhuCkyNYX9O/bOknbcf706XeESxGduSkHEjIw/k1+2\n' +
        'Atteoq5dT6cwjnJ9hyhiueVlVkiDAgMBAAGjQjBAMA8GA1UdEwEB/wQFMAMBAf8w\n' +
        'HQYDVR0OBBYEFLUI+DD7RJs+0nRnjcwIVWzzYSsFMA4GA1UdDwEB/wQEAwIBhjAN\n' +
        'BgkqhkiG9w0BAQwFAAOCAgEAb1mcCHv4qMQetLGTBH9IxsB2YUUhr5dda0D2BcHr\n' +
        'UtDbfd0VQs4tux6h/6iKwHPx0Ew8fuuYj99WknG0ffgJfNc5/fMspxR/pc1jpdyU\n' +
        '5zMQ+B9wi0lOZPO9uH7/pr+d2odcNEy8zAwqdv/ihsTwLmGP54is9fVbsgzNW1cm\n' +
        'HKAVL2t/Ope+3QnRiRilKCN1lzhav4HHdLlN401TcWRWKbEuxF/FgxSO2Hmx86pj\n' +
        'e726lweCTMmnq/cTsPOVY0WMjs0or3eHDVlyLgVeV5ldyN+ptg3Oit60T05SRa58\n' +
        'AJPTaVKIcGQ/gKkKZConpu7GDofT67P/ox0YNY57LRbhsx9r5UY4ROgz7WMQ1yoS\n' +
        'Y+19xizm+mBm2PyjMUbfwZUyCxsdKMwVdOq5/UmTmdms+TR8+m1uBHPOTQ2vKR0s\n' +
        'Pd/THSzPuu+d3dbzRyDSLQbHFFneG760CUlD/ZmzFlQjJ89/HmAmz8IyENq+Sjhx\n' +
        'Jgzy+FjVZb8aRUoYLlnffpUpej1n87Ynlr1GrvC4GsRpNpOHlwuf6WD4W0qUTsC/\n' +
        'C9JO+fBzUj/aWlJzNcLEW6pte1SB+EdkR2sZvWH+F88TxemeDrV0jKJw5R89CDf8\n' +
        'ZQNfkxJYjhns+YeV0moYjqQdc7tq4i04uggEQEtVzEhRLU5PE83nlh/K2NZZm8Kj\n' +
        'dIA=\n' +
        '-----END CERTIFICATE-----\n',
    '-----BEGIN CERTIFICATE-----\n' +
        'MIID/zCCAuegAwIBAgIRAPVSMfFitmM5PhmbaOFoGfUwDQYJKoZIhvcNAQELBQAw\n' +
        'gZcxCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJ\n' +
        'bmMuMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTEwMC4GA1UEAwwn\n' +
        'QW1hem9uIFJEUyB1cy1lYXN0LTEgUm9vdCBDQSBSU0EyMDQ4IEcxMRAwDgYDVQQH\n' +
        'DAdTZWF0dGxlMCAXDTIxMDUyNTIyMzQ1N1oYDzIwNjEwNTI1MjMzNDU3WjCBlzEL\n' +
        'MAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4x\n' +
        'EzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTAwLgYDVQQDDCdBbWF6\n' +
        'b24gUkRTIHVzLWVhc3QtMSBSb290IENBIFJTQTIwNDggRzExEDAOBgNVBAcMB1Nl\n' +
        'YXR0bGUwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQDu9H7TBeGoDzMr\n' +
        'dxN6H8COntJX4IR6dbyhnj5qMD4xl/IWvp50lt0VpmMd+z2PNZzx8RazeGC5IniV\n' +
        '5nrLg0AKWRQ2A/lGGXbUrGXCSe09brMQCxWBSIYe1WZZ1iU1IJ/6Bp4D2YEHpXrW\n' +
        'bPkOq5x3YPcsoitgm1Xh8ygz6vb7PsvJvPbvRMnkDg5IqEThapPjmKb8ZJWyEFEE\n' +
        'QRrkCIRueB1EqQtJw0fvP4PKDlCJAKBEs/y049FoOqYpT3pRy0WKqPhWve+hScMd\n' +
        '6obq8kxTFy1IHACjHc51nrGII5Bt76/MpTWhnJIJrCnq1/Uc3Qs8IVeb+sLaFC8K\n' +
        'DI69Sw6bAgMBAAGjQjBAMA8GA1UdEwEB/wQFMAMBAf8wHQYDVR0OBBYEFE7PCopt\n' +
        'lyOgtXX0Y1lObBUxuKaCMA4GA1UdDwEB/wQEAwIBhjANBgkqhkiG9w0BAQsFAAOC\n' +
        'AQEAFj+bX8gLmMNefr5jRJfHjrL3iuZCjf7YEZgn89pS4z8408mjj9z6Q5D1H7yS\n' +
        'jNETVV8QaJip1qyhh5gRzRaArgGAYvi2/r0zPsy+Tgf7v1KGL5Lh8NT8iCEGGXwF\n' +
        'g3Ir+Nl3e+9XUp0eyyzBIjHtjLBm6yy8rGk9p6OtFDQnKF5OxwbAgip42CD75r/q\n' +
        'p421maEDDvvRFR4D+99JZxgAYDBGqRRceUoe16qDzbMvlz0A9paCZFclxeftAxv6\n' +
        'QlR5rItMz/XdzpBJUpYhdzM0gCzAzdQuVO5tjJxmXhkSMcDP+8Q+Uv6FA9k2VpUV\n' +
        'E/O5jgpqUJJ2Hc/5rs9VkAPXeA==\n' +
        '-----END CERTIFICATE-----\n',
    '-----BEGIN CERTIFICATE-----\n' +
        'MIICrzCCAjWgAwIBAgIQW0yuFCle3uj4vWiGU0SaGzAKBggqhkjOPQQDAzCBlzEL\n' +
        'MAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4x\n' +
        'EzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTAwLgYDVQQDDCdBbWF6\n' +
        'b24gUkRTIGFmLXNvdXRoLTEgUm9vdCBDQSBFQ0MzODQgRzExEDAOBgNVBAcMB1Nl\n' +
        'YXR0bGUwIBcNMjEwNTE5MTkzNTE2WhgPMjEyMTA1MTkyMDM1MTZaMIGXMQswCQYD\n' +
        'VQQGEwJVUzEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywgSW5jLjETMBEG\n' +
        'A1UECwwKQW1hem9uIFJEUzELMAkGA1UECAwCV0ExMDAuBgNVBAMMJ0FtYXpvbiBS\n' +
        'RFMgYWYtc291dGgtMSBSb290IENBIEVDQzM4NCBHMTEQMA4GA1UEBwwHU2VhdHRs\n' +
        'ZTB2MBAGByqGSM49AgEGBSuBBAAiA2IABDPiKNZSaXs3Un/J/v+LTsFDANHpi7en\n' +
        'oL2qh0u0DoqNzEBTbBjvO23bLN3k599zh6CY3HKW0r2k1yaIdbWqt4upMCRCcUFi\n' +
        'I4iedAmubgzh56wJdoMZztjXZRwDthTkJKNCMEAwDwYDVR0TAQH/BAUwAwEB/zAd\n' +
        'BgNVHQ4EFgQUWbYkcrvVSnAWPR5PJhIzppcAnZIwDgYDVR0PAQH/BAQDAgGGMAoG\n' +
        'CCqGSM49BAMDA2gAMGUCMCESGqpat93CjrSEjE7z+Hbvz0psZTHwqaxuiH64GKUm\n' +
        'mYynIiwpKHyBrzjKBmeDoQIxANGrjIo6/b8Jl6sdIZQI18V0pAyLfLiZjlHVOnhM\n' +
        'MOTVgr82ZuPoEHTX78MxeMnYlw==\n' +
        '-----END CERTIFICATE-----\n',
    '-----BEGIN CERTIFICATE-----\n' +
        'MIIECTCCAvGgAwIBAgIRAIbsx8XOl0sgTNiCN4O+18QwDQYJKoZIhvcNAQELBQAw\n' +
        'gZwxCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJ\n' +
        'bmMuMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTE1MDMGA1UEAwws\n' +
        'QW1hem9uIFJEUyBhcC1ub3J0aGVhc3QtMSBSb290IENBIFJTQTIwNDggRzExEDAO\n' +
        'BgNVBAcMB1NlYXR0bGUwIBcNMjEwNTI1MjE1NDU4WhgPMjA2MTA1MjUyMjU0NTha\n' +
        'MIGcMQswCQYDVQQGEwJVUzEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywg\n' +
        'SW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzELMAkGA1UECAwCV0ExNTAzBgNVBAMM\n' +
        'LEFtYXpvbiBSRFMgYXAtbm9ydGhlYXN0LTEgUm9vdCBDQSBSU0EyMDQ4IEcxMRAw\n' +
        'DgYDVQQHDAdTZWF0dGxlMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA\n' +
        'tROxwXWCgn5R9gI/2Ivjzaxc0g95ysBjoJsnhPdJEHQb7w3y2kWrVWU3Y9fOitgb\n' +
        'CEsnEC3PrhRnzNVW0fPsK6kbvOeCmjvY30rdbxbc8h+bjXfGmIOgAkmoULEr6Hc7\n' +
        'G1Q/+tvv4lEwIs7bEaf+abSZxRJbZ0MBxhbHn7UHHDiMZYvzK+SV1MGCxx7JVhrm\n' +
        'xWu3GC1zZCsGDhB9YqY9eR6PmjbqA5wy8vqbC57dZZa1QVtWIQn3JaRXn+faIzHx\n' +
        'nLMN5CEWihsdmHBXhnRboXprE/OS4MFv1UrQF/XM/h5RBeCywpHePpC+Oe1T3LNC\n' +
        'iP8KzRFrjC1MX/WXJnmOVQIDAQABo0IwQDAPBgNVHRMBAf8EBTADAQH/MB0GA1Ud\n' +
        'DgQWBBS33XbXAUMs1znyZo4B0+B3D68WFTAOBgNVHQ8BAf8EBAMCAYYwDQYJKoZI\n' +
        'hvcNAQELBQADggEBADuadd2EmlpueY2VlrIIPC30QkoA1EOSoCmZgN6124apkoY1\n' +
        'HiV4r+QNPljN4WP8gmcARnNkS7ZeR4fvWi8xPh5AxQCpiaBMw4gcbTMCuKDV68Pw\n' +
        'P2dZCTMspvR3CDfM35oXCufdtFnxyU6PAyINUqF/wyTHguO3owRFPz64+sk3r2pT\n' +
        'WHmJjG9E7V+KOh0s6REgD17Gqn6C5ijLchSrPUHB0wOIkeLJZndHxN/76h7+zhMt\n' +
        'fFeNxPWHY2MfpcaLjz4UREzZPSB2U9k+y3pW1omCIcl6MQU9itGx/LpQE+H3ZeX2\n' +
        'M2bdYd5L+ow+bdbGtsVKOuN+R9Dm17YpswF+vyQ=\n' +
        '-----END CERTIFICATE-----\n',
    '-----BEGIN CERTIFICATE-----\n' +
        'MIIGATCCA+mgAwIBAgIRAKlQ+3JX9yHXyjP/Ja6kZhkwDQYJKoZIhvcNAQEMBQAw\n' +
        'gZgxCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJ\n' +
        'bmMuMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTExMC8GA1UEAwwo\n' +
        'QW1hem9uIFJEUyBhcC1zb3V0aC0xIFJvb3QgQ0EgUlNBNDA5NiBHMTEQMA4GA1UE\n' +
        'BwwHU2VhdHRsZTAgFw0yMTA1MTkxNzQ1MjBaGA8yMTIxMDUxOTE4NDUyMFowgZgx\n' +
        'CzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMu\n' +
        'MRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTExMC8GA1UEAwwoQW1h\n' +
        'em9uIFJEUyBhcC1zb3V0aC0xIFJvb3QgQ0EgUlNBNDA5NiBHMTEQMA4GA1UEBwwH\n' +
        'U2VhdHRsZTCCAiIwDQYJKoZIhvcNAQEBBQADggIPADCCAgoCggIBAKtahBrpUjQ6\n' +
        'H2mni05BAKU6Z5USPZeSKmBBJN3YgD17rJ93ikJxSgzJ+CupGy5rvYQ0xznJyiV0\n' +
        '91QeQN4P+G2MjGQR0RGeUuZcfcZitJro7iAg3UBvw8WIGkcDUg+MGVpRv/B7ry88\n' +
        '7E4OxKb8CPNoa+a9j6ABjOaaxaI22Bb7j3OJ+JyMICs6CU2bgkJaj3VUV9FCNUOc\n' +
        'h9PxD4jzT9yyGYm/sK9BAT1WOTPG8XQUkpcFqy/IerZDfiQkf1koiSd4s5VhBkUn\n' +
        'aQHOdri/stldT7a+HJFVyz2AXDGPDj+UBMOuLq0K6GAT6ThpkXCb2RIf4mdTy7ox\n' +
        'N5BaJ+ih+Ro3ZwPkok60egnt/RN98jgbm+WstgjJWuLqSNInnMUgkuqjyBWwePqX\n' +
        'Kib+wdpyx/LOzhKPEFpeMIvHQ3A0sjlulIjnh+j+itezD+dp0UNxMERlW4Bn/IlS\n' +
        'sYQVNfYutWkRPRLErXOZXtlxxkI98JWQtLjvGzQr+jywxTiw644FSLWdhKa6DtfU\n' +
        '2JWBHqQPJicMElfZpmfaHZjtXuCZNdZQXWg7onZYohe281ZrdFPOqC4rUq7gYamL\n' +
        'T+ZB+2P+YCPOLJ60bj/XSvcB7mesAdg8P0DNddPhHUFWx2dFqOs1HxIVB4FZVA9U\n' +
        'Ppbv4a484yxjTgG7zFZNqXHKTqze6rBBAgMBAAGjQjBAMA8GA1UdEwEB/wQFMAMB\n' +
        'Af8wHQYDVR0OBBYEFCEAqjighncv/UnWzBjqu1Ka2Yb4MA4GA1UdDwEB/wQEAwIB\n' +
        'hjANBgkqhkiG9w0BAQwFAAOCAgEAYyvumblckIXlohzi3QiShkZhqFzZultbFIu9\n' +
        'GhA5CDar1IFMhJ9vJpO9nUK/camKs1VQRs8ZsBbXa0GFUM2p8y2cgUfLwFULAiC/\n' +
        'sWETyW5lcX/xc4Pyf6dONhqFJt/ovVBxNZtcmMEWv/1D6Tf0nLeEb0P2i/pnSRR4\n' +
        'Oq99LVFjossXtyvtaq06OSiUUZ1zLPvV6AQINg8dWeBOWRcQYhYcEcC2wQ06KShZ\n' +
        '0ahuu7ar5Gym3vuLK6nH+eQrkUievVomN/LpASrYhK32joQ5ypIJej3sICIgJUEP\n' +
        'UoeswJ+Z16f3ECoL1OSnq4A0riiLj1ZGmVHNhM6m/gotKaHNMxsK9zsbqmuU6IT/\n' +
        'P6cR0S+vdigQG8ZNFf5vEyVNXhl8KcaJn6lMD/gMB2rY0qpaeTg4gPfU5wcg8S4Y\n' +
        'C9V//tw3hv0f2n+8kGNmqZrylOQDQWSSo8j8M2SRSXiwOHDoTASd1fyBEIqBAwzn\n' +
        'LvXVg8wQd1WlmM3b0Vrsbzltyh6y4SuKSkmgufYYvC07NknQO5vqvZcNoYbLNea3\n' +
        '76NkFaMHUekSbwVejZgG5HGwbaYBgNdJEdpbWlA3X4yGRVxknQSUyt4dZRnw/HrX\n' +
        'k8x6/wvtw7wht0/DOqz1li7baSsMazqxx+jDdSr1h9xML416Q4loFCLgqQhil8Jq\n' +
        'Em4Hy3A=\n' +
        '-----END CERTIFICATE-----\n',
    '-----BEGIN CERTIFICATE-----\n' +
        'MIIGBTCCA+2gAwIBAgIRAJfKe4Zh4aWNt3bv6ZjQwogwDQYJKoZIhvcNAQEMBQAw\n' +
        'gZoxCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJ\n' +
        'bmMuMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTEzMDEGA1UEAwwq\n' +
        'QW1hem9uIFJEUyBjYS1jZW50cmFsLTEgUm9vdCBDQSBSU0E0MDk2IEcxMRAwDgYD\n' +
        'VQQHDAdTZWF0dGxlMCAXDTIxMDUyMTIyMDg1M1oYDzIxMjEwNTIxMjMwODUzWjCB\n' +
        'mjELMAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIElu\n' +
        'Yy4xEzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTMwMQYDVQQDDCpB\n' +
        'bWF6b24gUkRTIGNhLWNlbnRyYWwtMSBSb290IENBIFJTQTQwOTYgRzExEDAOBgNV\n' +
        'BAcMB1NlYXR0bGUwggIiMA0GCSqGSIb3DQEBAQUAA4ICDwAwggIKAoICAQCpgUH6\n' +
        'Crzd8cOw9prAh2rkQqAOx2vtuI7xX4tmBG4I/um28eBjyVmgwQ1fpq0Zg2nCKS54\n' +
        'Nn0pCmT7f3h6Bvopxn0J45AzXEtajFqXf92NQ3iPth95GVfAJSD7gk2LWMhpmID9\n' +
        'JGQyoGuDPg+hYyr292X6d0madzEktVVGO4mKTF989qEg+tY8+oN0U2fRTrqa2tZp\n' +
        'iYsmg350ynNopvntsJAfpCO/srwpsqHHLNFZ9jvhTU8uW90wgaKO9i31j/mHggCE\n' +
        '+CAOaJCM3g+L8DPl/2QKsb6UkBgaaIwKyRgKSj1IlgrK+OdCBCOgM9jjId4Tqo2j\n' +
        'ZIrrPBGl6fbn1+etZX+2/tf6tegz+yV0HHQRAcKCpaH8AXF44bny9andslBoNjGx\n' +
        'H6R/3ib4FhPrnBMElzZ5i4+eM/cuPC2huZMBXb/jKgRC/QN1Wm3/nah5FWq+yn+N\n' +
        'tiAF10Ga0BYzVhHDEwZzN7gn38bcY5yi/CjDUNpY0OzEe2+dpaBKPlXTaFfn9Nba\n' +
        'CBmXPRF0lLGGtPeTAgjcju+NEcVa82Ht1pqxyu2sDtbu3J5bxp4RKtj+ShwN8nut\n' +
        'Tkf5Ea9rSmHEY13fzgibZlQhXaiFSKA2ASUwgJP19Putm0XKlBCNSGCoECemewxL\n' +
        '+7Y8FszS4Uu4eaIwvXVqUEE2yf+4ex0hqQ1acQIDAQABo0IwQDAPBgNVHRMBAf8E\n' +
        'BTADAQH/MB0GA1UdDgQWBBSeUnXIRxNbYsZLtKomIz4Y1nOZEzAOBgNVHQ8BAf8E\n' +
        'BAMCAYYwDQYJKoZIhvcNAQEMBQADggIBAIpRvxVS0dzoosBh/qw65ghPUGSbP2D4\n' +
        'dm6oYCv5g/zJr4fR7NzEbHOXX5aOQnHbQL4M/7veuOCLNPOW1uXwywMg6gY+dbKe\n' +
        'YtPVA1as8G9sUyadeXyGh2uXGsziMFXyaESwiAXZyiYyKChS3+g26/7jwECFo5vC\n' +
        'XGhWpIO7Hp35Yglp8AnwnEAo/PnuXgyt2nvyTSrxlEYa0jus6GZEZd77pa82U1JH\n' +
        'qFhIgmKPWWdvELA3+ra1nKnvpWM/xX0pnMznMej5B3RT3Y+k61+kWghJE81Ix78T\n' +
        '+tG4jSotgbaL53BhtQWBD1yzbbilqsGE1/DXPXzHVf9yD73fwh2tGWSaVInKYinr\n' +
        'a4tcrB3KDN/PFq0/w5/21lpZjVFyu/eiPj6DmWDuHW73XnRwZpHo/2OFkei5R7cT\n' +
        'rn/YdDD6c1dYtSw5YNnS6hdCQ3sOiB/xbPRN9VWJa6se79uZ9NLz6RMOr73DNnb2\n' +
        'bhIR9Gf7XAA5lYKqQk+A+stoKbIT0F65RnkxrXi/6vSiXfCh/bV6B41cf7MY/6YW\n' +
        'ehserSdjhQamv35rTFdM+foJwUKz1QN9n9KZhPxeRmwqPitAV79PloksOnX25ElN\n' +
        'SlyxdndIoA1wia1HRd26EFm2pqfZ2vtD2EjU3wD42CXX4H8fKVDna30nNFSYF0yn\n' +
        'jGKc3k6UNxpg\n' +
        '-----END CERTIFICATE-----\n',
    '-----BEGIN CERTIFICATE-----\n' +
        'MIIF/jCCA+agAwIBAgIQaRHaEqqacXN20e8zZJtmDDANBgkqhkiG9w0BAQwFADCB\n' +
        'lzELMAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIElu\n' +
        'Yy4xEzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTAwLgYDVQQDDCdB\n' +
        'bWF6b24gUkRTIHVzLWVhc3QtMSBSb290IENBIFJTQTQwOTYgRzExEDAOBgNVBAcM\n' +
        'B1NlYXR0bGUwIBcNMjEwNTI1MjIzODM1WhgPMjEyMTA1MjUyMzM4MzVaMIGXMQsw\n' +
        'CQYDVQQGEwJVUzEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywgSW5jLjET\n' +
        'MBEGA1UECwwKQW1hem9uIFJEUzELMAkGA1UECAwCV0ExMDAuBgNVBAMMJ0FtYXpv\n' +
        'biBSRFMgdXMtZWFzdC0xIFJvb3QgQ0EgUlNBNDA5NiBHMTEQMA4GA1UEBwwHU2Vh\n' +
        'dHRsZTCCAiIwDQYJKoZIhvcNAQEBBQADggIPADCCAgoCggIBAInfBCaHuvj6Rb5c\n' +
        'L5Wmn1jv2PHtEGMHm+7Z8dYosdwouG8VG2A+BCYCZfij9lIGszrTXkY4O7vnXgru\n' +
        'JUNdxh0Q3M83p4X+bg+gODUs3jf+Z3Oeq7nTOk/2UYvQLcxP4FEXILxDInbQFcIx\n' +
        'yen1ESHggGrjEodgn6nbKQNRfIhjhW+TKYaewfsVWH7EF2pfj+cjbJ6njjgZ0/M9\n' +
        'VZifJFBgat6XUTOf3jwHwkCBh7T6rDpgy19A61laImJCQhdTnHKvzTpxcxiLRh69\n' +
        'ZObypR7W04OAUmFS88V7IotlPmCL8xf7kwxG+gQfvx31+A9IDMsiTqJ1Cc4fYEKg\n' +
        'bL+Vo+2Ii4W2esCTGVYmHm73drznfeKwL+kmIC/Bq+DrZ+veTqKFYwSkpHRyJCEe\n' +
        'U4Zym6POqQ/4LBSKwDUhWLJIlq99bjKX+hNTJykB+Lbcx0ScOP4IAZQoxmDxGWxN\n' +
        'S+lQj+Cx2pwU3S/7+OxlRndZAX/FKgk7xSMkg88HykUZaZ/ozIiqJqSnGpgXCtED\n' +
        'oQ4OJw5ozAr+/wudOawaMwUWQl5asD8fuy/hl5S1nv9XxIc842QJOtJFxhyeMIXt\n' +
        'LVECVw/dPekhMjS3Zo3wwRgYbnKG7YXXT5WMxJEnHu8+cYpMiRClzq2BEP6/MtI2\n' +
        'AZQQUFu2yFjRGL2OZA6IYjxnXYiRAgMBAAGjQjBAMA8GA1UdEwEB/wQFMAMBAf8w\n' +
        'HQYDVR0OBBYEFADCcQCPX2HmkqQcmuHfiQ2jjqnrMA4GA1UdDwEB/wQEAwIBhjAN\n' +
        'BgkqhkiG9w0BAQwFAAOCAgEASXkGQ2eUmudIKPeOIF7RBryCoPmMOsqP0+1qxF8l\n' +
        'pGkwmrgNDGpmd9s0ArfIVBTc1jmpgB3oiRW9c6n2OmwBKL4UPuQ8O3KwSP0iD2sZ\n' +
        'KMXoMEyphCEzW1I2GRvYDugL3Z9MWrnHkoaoH2l8YyTYvszTvdgxBPpM2x4pSkp+\n' +
        '76d4/eRpJ5mVuQ93nC+YG0wXCxSq63hX4kyZgPxgCdAA+qgFfKIGyNqUIqWgeyTP\n' +
        'n5OgKaboYk2141Rf2hGMD3/hsGm0rrJh7g3C0ZirPws3eeJfulvAOIy2IZzqHUSY\n' +
        'jkFzraz6LEH3IlArT3jUPvWKqvh2lJWnnp56aqxBR7qHH5voD49UpJWY1K0BjGnS\n' +
        'OHcurpp0Yt/BIs4VZeWdCZwI7JaSeDcPMaMDBvND3Ia5Fga0thgYQTG6dE+N5fgF\n' +
        'z+hRaujXO2nb0LmddVyvE8prYlWRMuYFv+Co8hcMdJ0lEZlfVNu0jbm9/GmwAZ+l\n' +
        '9umeYO9yz/uC7edC8XJBglMAKUmVK9wNtOckUWAcCfnPWYLbYa/PqtXBYcxrso5j\n' +
        'iaS/A7iEW51uteHBGrViCy1afGG+hiUWwFlesli+Rq4dNstX3h6h2baWABaAxEVJ\n' +
        'y1RnTQSz6mROT1VmZSgSVO37rgIyY0Hf0872ogcTS+FfvXgBxCxsNWEbiQ/XXva4\n' +
        '0Ws=\n' +
        '-----END CERTIFICATE-----\n',
    '-----BEGIN CERTIFICATE-----\n' +
        'MIICtDCCAjqgAwIBAgIRAMyaTlVLN0ndGp4ffwKAfoMwCgYIKoZIzj0EAwMwgZkx\n' +
        'CzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMu\n' +
        'MRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTEyMDAGA1UEAwwpQW1h\n' +
        'em9uIFJEUyBtZS1jZW50cmFsLTEgUm9vdCBDQSBFQ0MzODQgRzExEDAOBgNVBAcM\n' +
        'B1NlYXR0bGUwIBcNMjIwNTA3MDA0NDM3WhgPMjEyMjA1MDcwMTQ0MzdaMIGZMQsw\n' +
        'CQYDVQQGEwJVUzEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywgSW5jLjET\n' +
        'MBEGA1UECwwKQW1hem9uIFJEUzELMAkGA1UECAwCV0ExMjAwBgNVBAMMKUFtYXpv\n' +
        'biBSRFMgbWUtY2VudHJhbC0xIFJvb3QgQ0EgRUNDMzg0IEcxMRAwDgYDVQQHDAdT\n' +
        'ZWF0dGxlMHYwEAYHKoZIzj0CAQYFK4EEACIDYgAE19nCV1nsI6CohSor13+B25cr\n' +
        'zg+IHdi9Y3L7ziQnHWI6yjBazvnKD+oC71aRRlR8b5YXsYGUQxWzPLHN7EGPcSGv\n' +
        'bzA9SLG1KQYCJaQ0m9Eg/iGrwKWOgylbhVw0bCxoo0IwQDAPBgNVHRMBAf8EBTAD\n' +
        'AQH/MB0GA1UdDgQWBBS4KsknsJXM9+QPEkBdZxUPaLr11zAOBgNVHQ8BAf8EBAMC\n' +
        'AYYwCgYIKoZIzj0EAwMDaAAwZQIxAJaRgrYIEfXQMZQQDxMTYS0azpyWSseQooXo\n' +
        'L3nYq4OHGBgYyQ9gVjvRYWU85PXbfgIwdi82DtANQFkCu+j+BU0JBY/uRKPEeYzo\n' +
        'JG92igKIcXPqCoxIJ7lJbbzmuf73gQu5\n' +
        '-----END CERTIFICATE-----\n',
    '-----BEGIN CERTIFICATE-----\n' +
        'MIIGATCCA+mgAwIBAgIRAJwCobx0Os8F7ihbJngxrR8wDQYJKoZIhvcNAQEMBQAw\n' +
        'gZgxCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJ\n' +
        'bmMuMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTExMC8GA1UEAwwo\n' +
        'QW1hem9uIFJEUyBtZS1zb3V0aC0xIFJvb3QgQ0EgUlNBNDA5NiBHMTEQMA4GA1UE\n' +
        'BwwHU2VhdHRsZTAgFw0yMTA1MjAxNzE1MzNaGA8yMTIxMDUyMDE4MTUzM1owgZgx\n' +
        'CzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMu\n' +
        'MRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTExMC8GA1UEAwwoQW1h\n' +
        'em9uIFJEUyBtZS1zb3V0aC0xIFJvb3QgQ0EgUlNBNDA5NiBHMTEQMA4GA1UEBwwH\n' +
        'U2VhdHRsZTCCAiIwDQYJKoZIhvcNAQEBBQADggIPADCCAgoCggIBANukKwlm+ZaI\n' +
        'Y5MkWGbEVLApEyLmlrHLEg8PfiiEa9ts7jssQcin3bzEPdTqGr5jo91ONoZ3ccWq\n' +
        'xJgg1W3bLu5CAO2CqIOXTXHRyCO/u0Ch1FGgWB8xETPSi3UHt/Vn1ltdO6DYdbDU\n' +
        'mYgwzYrvLBdRCwxsb9o+BuYQHVFzUYonqk/y9ujz3gotzFq7r55UwDTA1ita3vb4\n' +
        'eDKjIb4b1M4Wr81M23WHonpje+9qkkrAkdQcHrkgvSCV046xsq/6NctzwCUUNsgF\n' +
        '7Q1a8ut5qJEYpz5ta8vI1rqFqAMBqCbFjRYlmAoTTpFPOmzAVxV+YoqTrW5A16su\n' +
        '/2SXlMYfJ/n/ad/QfBNPPAAQMpyOr2RCL/YiL/PFZPs7NxYjnZHNWxMLSPgFyI+/\n' +
        't2klnn5jR76KJK2qimmaXedB90EtFsMRUU1e4NxH9gDuyrihKPJ3aVnZ35mSipvR\n' +
        '/1KB8t8gtFXp/VQaz2sg8+uxPMKB81O37fL4zz6Mg5K8+aq3ejBiyHucpFGnsnVB\n' +
        '3kQWeD36ONkybngmgWoyPceuSWm1hQ0Z7VRAQX+KlxxSaHmSaIk1XxZu9h9riQHx\n' +
        'fMuev6KXjRn/CjCoUTn+7eFrt0dT5GryQEIZP+nA0oq0LKxogigHNZlwAT4flrqb\n' +
        'JUfZJrqgoce5HjZSXl10APbtPjJi0fW9AgMBAAGjQjBAMA8GA1UdEwEB/wQFMAMB\n' +
        'Af8wHQYDVR0OBBYEFEfV+LztI29OVDRm0tqClP3NrmEWMA4GA1UdDwEB/wQEAwIB\n' +
        'hjANBgkqhkiG9w0BAQwFAAOCAgEAvSNe+0wuk53KhWlRlRf2x/97H2Q76X3anzF0\n' +
        '5fOSVm022ldALzXMzqOfdnoKIhAu2oVKiHHKs7mMas+T6TL+Mkphx0CYEVxFE3PG\n' +
        '061q3CqJU+wMm9W9xsB79oB2XG47r1fIEywZZ3GaRsatAbjcNOT8uBaATPQAfJFN\n' +
        'zjFe4XyN+rA4cFrYNvfHTeu5ftrYmvks7JlRaJgEGWsz+qXux7uvaEEVPqEumd2H\n' +
        'uYeaRNOZ2V23R009X5lbgBFx9tq5VDTnKhQiTQ2SeT0rc1W3Dz5ik6SbQQNP3nSR\n' +
        '0Ywy7r/sZ3fcDyfFiqnrVY4Ympfvb4YW2PZ6OsQJbzH6xjdnTG2HtzEU30ngxdp1\n' +
        'WUEF4zt6rjJCp7QBUqXgdlHvJqYu6949qtWjEPiFN9uSsRV2i1YDjJqN52dLjAPn\n' +
        'AipJKo8x1PHTwUzuITqnB9BdP+5TlTl8biJfkEf/+08eWDTLlDHr2VrZLOLompTh\n' +
        'bS5OrhDmqA2Q+O+EWrTIhMflwwlCpR9QYM/Xwvlbad9H0FUHbJsCVNaru3wGOgWo\n' +
        'tt3dNSK9Lqnv/Ej9K9v6CRr36in4ylJKivhJ5B9E7ABHg7EpBJ1xi7O5eNDkNoJG\n' +
        '+pFyphJq3AkBR2U4ni2tUaTAtSW2tks7IaiDV+UMtqZyGabT5ISQfWLLtLHSWn2F\n' +
        'Tspdjbg=\n' +
        '-----END CERTIFICATE-----\n',
    '-----BEGIN CERTIFICATE-----\n' +
        'MIIECTCCAvGgAwIBAgIRAJZFh4s9aZGzKaTMLrSb4acwDQYJKoZIhvcNAQELBQAw\n' +
        'gZwxCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJ\n' +
        'bmMuMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTE1MDMGA1UEAwws\n' +
        'QW1hem9uIFJEUyBCZXRhIHVzLWVhc3QtMSBSb290IENBIFJTQTIwNDggRzExEDAO\n' +
        'BgNVBAcMB1NlYXR0bGUwIBcNMjEwNTE4MjEyODQxWhgPMjA2MTA1MTgyMjI4NDFa\n' +
        'MIGcMQswCQYDVQQGEwJVUzEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywg\n' +
        'SW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzELMAkGA1UECAwCV0ExNTAzBgNVBAMM\n' +
        'LEFtYXpvbiBSRFMgQmV0YSB1cy1lYXN0LTEgUm9vdCBDQSBSU0EyMDQ4IEcxMRAw\n' +
        'DgYDVQQHDAdTZWF0dGxlMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA\n' +
        '17i2yoU6diep+WrqxIn2CrDEO2NdJVwWTSckx4WMZlLpkQDoymSmkNHjq9ADIApD\n' +
        'A31Cx+843apL7wub8QkFZD0Tk7/ThdHWJOzcAM3ov98QBPQfOC1W5zYIIRP2F+vQ\n' +
        'TRETHQnLcW3rLv0NMk5oQvIKpJoC9ett6aeVrzu+4cU4DZVWYlJUoC/ljWzCluau\n' +
        '8blfW0Vwin6OB7s0HCG5/wijQWJBU5SrP/KAIPeQi1GqG5efbqAXDr/ple0Ipwyo\n' +
        'Xjjl73LenGUgqpANlC9EAT4i7FkJcllLPeK3NcOHjuUG0AccLv1lGsHAxZLgjk/x\n' +
        'z9ZcnVV9UFWZiyJTKxeKPwIDAQABo0IwQDAPBgNVHRMBAf8EBTADAQH/MB0GA1Ud\n' +
        'DgQWBBRWyMuZUo4gxCR3Luf9/bd2AqZ7CjAOBgNVHQ8BAf8EBAMCAYYwDQYJKoZI\n' +
        'hvcNAQELBQADggEBAIqN2DlIKlvDFPO0QUZQVFbsi/tLdYM98/vvzBpttlTGVMyD\n' +
        'gJuQeHVz+MnhGIwoCGOlGU3OOUoIlLAut0+WG74qYczn43oA2gbMd7HoD7oL/IGg\n' +
        'njorBwJVcuuLv2G//SqM3nxGcLRtkRnQ+lvqPxMz9+0fKFUn6QcIDuF0QSfthLs2\n' +
        'WSiGEPKO9c9RSXdRQ4pXA7c3hXng8P4A2ZmdciPne5Nu4I4qLDGZYRrRLRkNTrOi\n' +
        'TyS6r2HNGUfgF7eOSeKt3NWL+mNChcYj71/Vycf5edeczpUgfnWy9WbPrK1svKyl\n' +
        'aAs2xg+X6O8qB+Mnj2dNBzm+lZIS3sIlm+nO9sg=\n' +
        '-----END CERTIFICATE-----\n',
    '-----BEGIN CERTIFICATE-----\n' +
        'MIICrjCCAjSgAwIBAgIRAPAlEk8VJPmEzVRRaWvTh2AwCgYIKoZIzj0EAwMwgZYx\n' +
        'CzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMu\n' +
        'MRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTEvMC0GA1UEAwwmQW1h\n' +
        'em9uIFJEUyB1cy1lYXN0LTEgUm9vdCBDQSBFQ0MzODQgRzExEDAOBgNVBAcMB1Nl\n' +
        'YXR0bGUwIBcNMjEwNTI1MjI0MTU1WhgPMjEyMTA1MjUyMzQxNTVaMIGWMQswCQYD\n' +
        'VQQGEwJVUzEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywgSW5jLjETMBEG\n' +
        'A1UECwwKQW1hem9uIFJEUzELMAkGA1UECAwCV0ExLzAtBgNVBAMMJkFtYXpvbiBS\n' +
        'RFMgdXMtZWFzdC0xIFJvb3QgQ0EgRUNDMzg0IEcxMRAwDgYDVQQHDAdTZWF0dGxl\n' +
        'MHYwEAYHKoZIzj0CAQYFK4EEACIDYgAEx5xjrup8II4HOJw15NTnS3H5yMrQGlbj\n' +
        'EDA5MMGnE9DmHp5dACIxmPXPMe/99nO7wNdl7G71OYPCgEvWm0FhdvVUeTb3LVnV\n' +
        'BnaXt32Ek7/oxGk1T+Df03C+W0vmuJ+wo0IwQDAPBgNVHRMBAf8EBTADAQH/MB0G\n' +
        'A1UdDgQWBBTGXmqBWN/1tkSea4pNw0oHrjk2UDAOBgNVHQ8BAf8EBAMCAYYwCgYI\n' +
        'KoZIzj0EAwMDaAAwZQIxAIqqZWCSrIkZ7zsv/FygtAusW6yvlL935YAWYPVXU30m\n' +
        'jkMFLM+/RJ9GMvnO8jHfCgIwB+whlkcItzE9CRQ6CsMo/d5cEHDUu/QW6jSIh9BR\n' +
        'OGh9pTYPVkUbBiKPA7lVVhre\n' +
        '-----END CERTIFICATE-----\n',
    '-----BEGIN CERTIFICATE-----\n' +
        'MIIF/zCCA+egAwIBAgIRAJGY9kZITwfSRaAS/bSBOw8wDQYJKoZIhvcNAQEMBQAw\n' +
        'gZcxCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJ\n' +
        'bmMuMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTEwMC4GA1UEAwwn\n' +
        'QW1hem9uIFJEUyBzYS1lYXN0LTEgUm9vdCBDQSBSU0E0MDk2IEcxMRAwDgYDVQQH\n' +
        'DAdTZWF0dGxlMCAXDTIxMDUxOTE4MTEyMFoYDzIxMjEwNTE5MTkxMTIwWjCBlzEL\n' +
        'MAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4x\n' +
        'EzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTAwLgYDVQQDDCdBbWF6\n' +
        'b24gUkRTIHNhLWVhc3QtMSBSb290IENBIFJTQTQwOTYgRzExEDAOBgNVBAcMB1Nl\n' +
        'YXR0bGUwggIiMA0GCSqGSIb3DQEBAQUAA4ICDwAwggIKAoICAQDe2vlDp6Eo4WQi\n' +
        'Wi32YJOgdXHhxTFrLjB9SRy22DYoMaWfginJIwJcSR8yse8ZDQuoNhERB9LRggAE\n' +
        'eng23mhrfvtL1yQkMlZfBu4vG1nOb22XiPFzk7X2wqz/WigdYNBCqa1kK3jrLqPx\n' +
        'YUy7jk2oZle4GLVRTNGuMfcid6S2hs3UCdXfkJuM2z2wc3WUlvHoVNk37v2/jzR/\n' +
        'hSCHZv5YHAtzL/kLb/e64QkqxKll5QmKhyI6d7vt6Lr1C0zb+DmwxUoJhseAS0hI\n' +
        'dRk5DklMb4Aqpj6KN0ss0HAYqYERGRIQM7KKA4+hxDMUkJmt8KqWKZkAlCZgflzl\n' +
        'm8NZ31o2cvBzf6g+VFHx+6iVrSkohVQydkCxx7NJ743iPKsh8BytSM4qU7xx4OnD\n' +
        'H2yNXcypu+D5bZnVZr4Pywq0w0WqbTM2bpYthG9IC4JeVUvZ2mDc01lqOlbMeyfT\n' +
        'og5BRPLDXdZK8lapo7se2teh64cIfXtCmM2lDSwm1wnH2iSK+AWZVIM3iE45WSGc\n' +
        'vZ+drHfVgjJJ5u1YrMCWNL5C2utFbyF9Obw9ZAwm61MSbPQL9JwznhNlCh7F2ANW\n' +
        'ZHWQPNcOAJqzE4uVcJB1ZeVl28ORYY1668lx+s9yYeMXk3QQdj4xmdnvoBFggqRB\n' +
        'ZR6Z0D7ZohADXe024RzEo1TukrQgKQIDAQABo0IwQDAPBgNVHRMBAf8EBTADAQH/\n' +
        'MB0GA1UdDgQWBBT7Vs4Y5uG/9aXnYGNMEs6ycPUT3jAOBgNVHQ8BAf8EBAMCAYYw\n' +
        'DQYJKoZIhvcNAQEMBQADggIBACN4Htp2PvGcQA0/sAS+qUVWWJoAXSsu8Pgc6Gar\n' +
        '7tKVlNJ/4W/a6pUV2Xo/Tz3msg4yiE8sMESp2k+USosD5n9Alai5s5qpWDQjrqrh\n' +
        '76AGyF2nzve4kIN19GArYhm4Mz/EKEG1QHYvBDGgXi3kNvL/a2Zbybp+3LevG+q7\n' +
        'xtx4Sz9yIyMzuT/6Y7ijtiMZ9XbuxGf5wab8UtwT3Xq1UradJy0KCkzRJAz/Wy/X\n' +
        'HbTkEvKSaYKExH6sLo0jqdIjV/d2Io31gt4e0Ly1ER2wPyFa+pc/swu7HCzrN+iz\n' +
        'A2ZM4+KX9nBvFyfkHLix4rALg+WTYJa/dIsObXkdZ3z8qPf5A9PXlULiaa1mcP4+\n' +
        'rokw74IyLEYooQ8iSOjxumXhnkTS69MAdGzXYE5gnHokABtGD+BB5qLhtLt4fqAp\n' +
        '8AyHpQWMyV42M9SJLzQ+iOz7kAgJOBOaVtJI3FV/iAg/eqWVm3yLuUTWDxSHrKuL\n' +
        'N19+pSjF6TNvUSFXwEa2LJkfDqIOCE32iOuy85QY//3NsgrSQF6UkSPa95eJrSGI\n' +
        '3hTRYYh3Up2GhBGl1KUy7/o0k3KRZTk4s38fylY8bZ3TakUOH5iIGoHyFVVcp361\n' +
        'Pyy25SzFSmNalWoQd9wZVc/Cps2ldxhcttM+WLkFNzprd0VJa8qTz8vYtHP0ouDN\n' +
        'nWS0\n' +
        '-----END CERTIFICATE-----\n',
    '-----BEGIN CERTIFICATE-----\n' +
        'MIIGCTCCA/GgAwIBAgIRAOY7gfcBZgR2tqfBzMbFQCUwDQYJKoZIhvcNAQEMBQAw\n' +
        'gZwxCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJ\n' +
        'bmMuMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTE1MDMGA1UEAwws\n' +
        'QW1hem9uIFJEUyBhcC1zb3V0aGVhc3QtNCBSb290IENBIFJTQTQwOTYgRzExEDAO\n' +
        'BgNVBAcMB1NlYXR0bGUwIBcNMjIwNTI1MTY1NDU5WhgPMjEyMjA1MjUxNzU0NTla\n' +
        'MIGcMQswCQYDVQQGEwJVUzEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywg\n' +
        'SW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzELMAkGA1UECAwCV0ExNTAzBgNVBAMM\n' +
        'LEFtYXpvbiBSRFMgYXAtc291dGhlYXN0LTQgUm9vdCBDQSBSU0E0MDk2IEcxMRAw\n' +
        'DgYDVQQHDAdTZWF0dGxlMIICIjANBgkqhkiG9w0BAQEFAAOCAg8AMIICCgKCAgEA\n' +
        'lfxER43FuLRdL08bddF0YhbCP+XXKj1A/TFMXmd2My8XDei8rPXFYyyjMig9+xZw\n' +
        'uAsIxLwz8uiA26CKA8bCZKg5VG2kTeOJAfvBJaLv1CZefs3Z4Uf1Sjvm6MF2yqEj\n' +
        'GoORfyfL9HiZFTDuF/hcjWoKYCfMuG6M/wO8IbdICrX3n+BiYQJu/pFO660Mg3h/\n' +
        '8YBBWYDbHoCiH/vkqqJugQ5BM3OI5nsElW51P1icEEqti4AZ7JmtSv9t7fIFBVyR\n' +
        'oaEyOgpp0sm193F/cDJQdssvjoOnaubsSYm1ep3awZAUyGN/X8MBrPY95d0hLhfH\n' +
        'Ehc5Icyg+hsosBljlAyksmt4hFQ9iBnWIz/ZTfGMck+6p3HVL9RDgvluez+rWv59\n' +
        '8q7omUGsiPApy5PDdwI/Wt/KtC34/2sjslIJfvgifdAtkRPkhff1WEwER00ADrN9\n' +
        'eGGInaCpJfb1Rq8cV2n00jxg7DcEd65VR3dmIRb0bL+jWK62ni/WdEyomAOMfmGj\n' +
        'aWf78S/4rasHllWJ+QwnaUYY3u6N8Cgio0/ep4i34FxMXqMV3V0/qXdfhyabi/LM\n' +
        'wCxNo1Dwt+s6OtPJbwO92JL+829QAxydfmaMTeHBsgMPkG7RwAekeuatKGHNsc2Z\n' +
        'x2Q4C2wVvOGAhcHwxfM8JfZs3nDSZJndtVVnFlUY0UECAwEAAaNCMEAwDwYDVR0T\n' +
        'AQH/BAUwAwEB/zAdBgNVHQ4EFgQUpnG7mWazy6k97/tb5iduRB3RXgQwDgYDVR0P\n' +
        'AQH/BAQDAgGGMA0GCSqGSIb3DQEBDAUAA4ICAQCDLqq1Wwa9Tkuv7vxBnIeVvvFF\n' +
        'ecTn+P+wJxl9Qa2ortzqTHZsBDyJO62d04AgBwiDXkJ9a+bthgG0H1J7Xee8xqv1\n' +
        'xyX2yKj24ygHjspLotKP4eDMdDi5TYq+gdkbPmm9Q69B1+W6e049JVGXvWG8/7kU\n' +
        'igxeuCYwtCCdUPRLf6D8y+1XMGgVv3/DSOHWvTg3MJ1wJ3n3+eve3rjGdRYWZeJu\n' +
        'k21HLSZYzVrCtUsh2YAeLnUbSxVuT2Xr4JehYe9zW5HEQ8Je/OUfnCy9vzoN/ITw\n' +
        'osAH+EBJQey7RxEDqMwCaRefH0yeHFcnOll0OXg/urnQmwbEYzQ1uutJaBPsjU0J\n' +
        'Qf06sMxI7GiB5nPE+CnI2sM6A9AW9kvwexGXpNJiLxF8dvPQthpOKGcYu6BFvRmt\n' +
        '6ctfXd9b7JJoVqMWuf5cCY6ihpk1e9JTlAqu4Eb/7JNyGiGCR40iSLvV28un9wiE\n' +
        'plrdYxwcNYq851BEu3r3AyYWw/UW1AKJ5tM+/Gtok+AphMC9ywT66o/Kfu44mOWm\n' +
        'L3nSLSWEcgfUVgrikpnyGbUnGtgCmHiMlUtNVexcE7OtCIZoVAlCGKNu7tyuJf10\n' +
        'Qlk8oIIzfSIlcbHpOYoN79FkLoDNc2er4Gd+7w1oPQmdAB0jBJnA6t0OUBPKdDdE\n' +
        'Ufff2jrbfbzECn1ELg==\n' +
        '-----END CERTIFICATE-----\n',
    '-----BEGIN CERTIFICATE-----\n' +
        'MIIGCDCCA/CgAwIBAgIQIuO1A8LOnmc7zZ/vMm3TrDANBgkqhkiG9w0BAQwFADCB\n' +
        'nDELMAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIElu\n' +
        'Yy4xEzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTUwMwYDVQQDDCxB\n' +
        'bWF6b24gUkRTIGFwLXNvdXRoZWFzdC0yIFJvb3QgQ0EgUlNBNDA5NiBHMTEQMA4G\n' +
        'A1UEBwwHU2VhdHRsZTAgFw0yMTA1MjQyMDQ2MThaGA8yMTIxMDUyNDIxNDYxOFow\n' +
        'gZwxCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJ\n' +
        'bmMuMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTE1MDMGA1UEAwws\n' +
        'QW1hem9uIFJEUyBhcC1zb3V0aGVhc3QtMiBSb290IENBIFJTQTQwOTYgRzExEDAO\n' +
        'BgNVBAcMB1NlYXR0bGUwggIiMA0GCSqGSIb3DQEBAQUAA4ICDwAwggIKAoICAQDq\n' +
        'qRHKbG8ZK6/GkGm2cenznEF06yHwI1gD5sdsHjTgekDZ2Dl9RwtDmUH2zFuIQwGj\n' +
        'SeC7E2iKwrJRA5wYzL9/Vk8NOILEKQOP8OIKUHbc7q8rEtjs401KcU6pFBBEdO9G\n' +
        'CTiRhogq+8mhC13AM/UriZJbKhwgM2UaDOzAneGMhQAGjH8z83NsNcPxpYVE7tqM\n' +
        'sch5yLtIJLkJRusrmQQTeHUev16YNqyUa+LuFclFL0FzFCimkcxUhXlbfEKXbssS\n' +
        'yPzjiv8wokGyo7+gA0SueceMO2UjfGfute3HlXZDcNvBbkSY+ver41jPydyRD6Qq\n' +
        'oEkh0tyIbPoa3oU74kwipJtz6KBEA3u3iq61OUR0ENhR2NeP7CSKrC24SnQJZ/92\n' +
        'qxusrbyV/0w+U4m62ug/o4hWNK1lUcc2AqiBOvCSJ7qpdteTFxcEIzDwYfERDx6a\n' +
        'd9+3IPvzMb0ZCxBIIUFMxLTF7yAxI9s6KZBBXSZ6tDcCCYIgEysEPRWMRAcG+ye/\n' +
        'fZVn9Vnzsj4/2wchC2eQrYpb1QvG4eMXA4M5tFHKi+/8cOPiUzJRgwS222J8YuDj\n' +
        'yEBval874OzXk8H8Mj0JXJ/jH66WuxcBbh5K7Rp5oJn7yju9yqX6qubY8gVeMZ1i\n' +
        'u4oXCopefDqa35JplQNUXbWwSebi0qJ4EK0V8F9Q+QIDAQABo0IwQDAPBgNVHRMB\n' +
        'Af8EBTADAQH/MB0GA1UdDgQWBBT4ysqCxaPe7y+g1KUIAenqu8PAgzAOBgNVHQ8B\n' +
        'Af8EBAMCAYYwDQYJKoZIhvcNAQEMBQADggIBALU8WN35KAjPZEX65tobtCDQFkIO\n' +
        'uJjv0alD7qLB0i9eY80C+kD87HKqdMDJv50a5fZdqOta8BrHutgFtDm+xo5F/1M3\n' +
        'u5/Vva5lV4xy5DqPajcF4Mw52czYBmeiLRTnyPJsU93EQIC2Bp4Egvb6LI4cMOgm\n' +
        '4pY2hL8DojOC5PXt4B1/7c1DNcJX3CMzHDm4SMwiv2MAxSuC/cbHXcWMk+qXdrVx\n' +
        '+ayLUSh8acaAOy3KLs1MVExJ6j9iFIGsDVsO4vr4ZNsYQiyHjp+L8ops6YVBO5AT\n' +
        'k/pI+axHIVsO5qiD4cFWvkGqmZ0gsVtgGUchZaacboyFsVmo6QPrl28l6LwxkIEv\n' +
        'GGJYvIBW8sfqtGRspjfX5TlNy5IgW/VOwGBdHHsvg/xpRo31PR3HOFw7uPBi7cAr\n' +
        'FiZRLJut7af98EB2UvovZnOh7uIEGPeecQWeOTQfJeWet2FqTzFYd0NUMgqPuJx1\n' +
        'vLKferP+ajAZLJvVnW1J7Vccx/pm0rMiUJEf0LRb/6XFxx7T2RGjJTi0EzXODTYI\n' +
        'gnLfBBjnolQqw+emf4pJ4pAtly0Gq1KoxTG2QN+wTd4lsCMjnelklFDjejwnl7Uy\n' +
        'vtxzRBAu/hi/AqDkDFf94m6j+edIrjbi9/JDFtQ9EDlyeqPgw0qwi2fwtJyMD45V\n' +
        'fejbXelUSJSzDIdY\n' +
        '-----END CERTIFICATE-----\n',
    '-----BEGIN CERTIFICATE-----\n' +
        'MIIGCTCCA/GgAwIBAgIRAN7Y9G9i4I+ZaslPobE7VL4wDQYJKoZIhvcNAQEMBQAw\n' +
        'gZwxCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJ\n' +
        'bmMuMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTE1MDMGA1UEAwws\n' +
        'QW1hem9uIFJEUyBhcC1ub3J0aGVhc3QtMiBSb290IENBIFJTQTQwOTYgRzExEDAO\n' +
        'BgNVBAcMB1NlYXR0bGUwIBcNMjEwNTIwMTYzMzIzWhgPMjEyMTA1MjAxNzMzMjNa\n' +
        'MIGcMQswCQYDVQQGEwJVUzEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywg\n' +
        'SW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzELMAkGA1UECAwCV0ExNTAzBgNVBAMM\n' +
        'LEFtYXpvbiBSRFMgYXAtbm9ydGhlYXN0LTIgUm9vdCBDQSBSU0E0MDk2IEcxMRAw\n' +
        'DgYDVQQHDAdTZWF0dGxlMIICIjANBgkqhkiG9w0BAQEFAAOCAg8AMIICCgKCAgEA\n' +
        '4BEPCiIfiK66Q/qa8k+eqf1Q3qsa6Xuu/fPkpuStXVBShhtXd3eqrM0iT4Xxs420\n' +
        'Va0vSB3oZ7l86P9zYfa60n6PzRxdYFckYX330aI7L/oFIdaodB/C9szvROI0oLG+\n' +
        '6RwmIF2zcprH0cTby8MiM7G3v9ykpq27g4WhDC1if2j8giOQL3oHpUaByekZNIHF\n' +
        'dIllsI3RkXmR3xmmxoOxJM1B9MZi7e1CvuVtTGOnSGpNCQiqofehTGwxCN2wFSK8\n' +
        'xysaWlw48G0VzZs7cbxoXMH9QbMpb4tpk0d+T8JfAPu6uWO9UwCLWWydf0CkmA/+\n' +
        'D50/xd1t33X9P4FEaPSg5lYbHXzSLWn7oLbrN2UqMLaQrkoEBg/VGvzmfN0mbflw\n' +
        '+T87bJ/VEOVNlG+gepyCTf89qIQVWOjuYMox4sK0PjzZGsYEuYiq1+OUT3vk/e5K\n' +
        'ag1fCcq2Isy4/iwB2xcXrsQ6ljwdk1fc+EmOnjGKrhuOHJY3S+RFv4ToQBsVyYhC\n' +
        'XGaC3EkqIX0xaCpDimxYhFjWhpDXAjG/zJ+hRLDAMCMhl/LPGRk/D1kzSbPmdjpl\n' +
        'lEMK5695PeBvEBTQdBQdOiYgOU3vWU6tzwwHfiM2/wgvess/q0FDAHfJhppbgbb9\n' +
        '3vgsIUcsvoC5o29JvMsUxsDRvsAfEmMSDGkJoA/X6GECAwEAAaNCMEAwDwYDVR0T\n' +
        'AQH/BAUwAwEB/zAdBgNVHQ4EFgQUgEWm1mZCbGD6ytbwk2UU1aLaOUUwDgYDVR0P\n' +
        'AQH/BAQDAgGGMA0GCSqGSIb3DQEBDAUAA4ICAQBb4+ABTGBGwxK1U/q4g8JDqTQM\n' +
        '1Wh8Oz8yAk4XtPJMAmCctxbd81cRnSnePWw/hxViLVtkZ/GsemvXfqAQyOn1coN7\n' +
        'QeYSw+ZOlu0j2jEJVynmgsR7nIRqE7QkCyZAU+d2FTJUfmee+IiBiGyFGgxz9n7A\n' +
        'JhBZ/eahBbiuoOik/APW2JWLh0xp0W0GznfJ8lAlaQTyDa8iDXmVtbJg9P9qzkvl\n' +
        'FgPXQttzEOyooF8Pb2LCZO4kUz+1sbU7tHdr2YE+SXxt6D3SBv+Yf0FlvyWLiqVk\n' +
        'GDEOlPPTDSjAWgKnqST8UJ0RDcZK/v1ixs7ayqQJU0GUQm1I7LGTErWXHMnCuHKe\n' +
        'UKYuiSZwmTcJ06NgdhcCnGZgPq13ryMDqxPeltQc3n5eO7f1cL9ERYLDLOzm6A9P\n' +
        'oQ3MfcVOsbHgGHZWaPSeNrQRN9xefqBXH0ZPasgcH9WJdsLlEjVUXoultaHOKx3b\n' +
        'UCCb+d3EfqF6pRT488ippOL6bk7zNubwhRa/+y4wjZtwe3kAX78ACJVcjPobH9jZ\n' +
        'ErySads5zdQeaoee5wRKdp3TOfvuCe4bwLRdhOLCHWzEcXzY3g/6+ppLvNom8o+h\n' +
        'Bh5X26G6KSfr9tqhQ3O9IcbARjnuPbvtJnoPY0gz3EHHGPhy0RNW8i2gl3nUp0ah\n' +
        'PtjwbKW0hYAhIttT0Q==\n' +
        '-----END CERTIFICATE-----\n',
    '-----BEGIN CERTIFICATE-----\n' +
        'MIICtzCCAj2gAwIBAgIQQRBQTs6Y3H1DDbpHGta3lzAKBggqhkjOPQQDAzCBmzEL\n' +
        'MAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4x\n' +
        'EzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTQwMgYDVQQDDCtBbWF6\n' +
        'b24gUkRTIGFwLXNvdXRoZWFzdC0zIFJvb3QgQ0EgRUNDMzg0IEcxMRAwDgYDVQQH\n' +
        'DAdTZWF0dGxlMCAXDTIxMDYxMTAwMTI0M1oYDzIxMjEwNjExMDExMjQzWjCBmzEL\n' +
        'MAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4x\n' +
        'EzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTQwMgYDVQQDDCtBbWF6\n' +
        'b24gUkRTIGFwLXNvdXRoZWFzdC0zIFJvb3QgQ0EgRUNDMzg0IEcxMRAwDgYDVQQH\n' +
        'DAdTZWF0dGxlMHYwEAYHKoZIzj0CAQYFK4EEACIDYgAEs0942Xj4m/gKA+WA6F5h\n' +
        'AHYuek9eGpzTRoLJddM4rEV1T3eSueytMVKOSlS3Ub9IhyQrH2D8EHsLYk9ktnGR\n' +
        'pATk0kCYTqFbB7onNo070lmMJmGT/Q7NgwC8cySChFxbo0IwQDAPBgNVHRMBAf8E\n' +
        'BTADAQH/MB0GA1UdDgQWBBQ20iKBKiNkcbIZRu0y1uoF1yJTEzAOBgNVHQ8BAf8E\n' +
        'BAMCAYYwCgYIKoZIzj0EAwMDaAAwZQIwYv0wTSrpQTaPaarfLN8Xcqrqu3hzl07n\n' +
        'FrESIoRw6Cx77ZscFi2/MV6AFyjCV/TlAjEAhpwJ3tpzPXpThRML8DMJYZ3YgMh3\n' +
        'CMuLqhPpla3cL0PhybrD27hJWl29C4el6aMO\n' +
        '-----END CERTIFICATE-----\n',
    '-----BEGIN CERTIFICATE-----\n' +
        'MIICrDCCAjOgAwIBAgIQGcztRyV40pyMKbNeSN+vXTAKBggqhkjOPQQDAzCBljEL\n' +
        'MAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4x\n' +
        'EzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMS8wLQYDVQQDDCZBbWF6\n' +
        'b24gUkRTIHVzLWVhc3QtMiBSb290IENBIEVDQzM4NCBHMTEQMA4GA1UEBwwHU2Vh\n' +
        'dHRsZTAgFw0yMTA1MjEyMzE1NTZaGA8yMTIxMDUyMjAwMTU1NlowgZYxCzAJBgNV\n' +
        'BAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMuMRMwEQYD\n' +
        'VQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTEvMC0GA1UEAwwmQW1hem9uIFJE\n' +
        'UyB1cy1lYXN0LTIgUm9vdCBDQSBFQ0MzODQgRzExEDAOBgNVBAcMB1NlYXR0bGUw\n' +
        'djAQBgcqhkjOPQIBBgUrgQQAIgNiAAQfDcv+GGRESD9wT+I5YIPRsD3L+/jsiIis\n' +
        'Tr7t9RSbFl+gYpO7ZbDXvNbV5UGOC5lMJo/SnqFRTC6vL06NF7qOHfig3XO8QnQz\n' +
        '6T5uhhrhnX2RSY3/10d2kTyHq3ZZg3+jQjBAMA8GA1UdEwEB/wQFMAMBAf8wHQYD\n' +
        'VR0OBBYEFLDyD3PRyNXpvKHPYYxjHXWOgfPnMA4GA1UdDwEB/wQEAwIBhjAKBggq\n' +
        'hkjOPQQDAwNnADBkAjB20HQp6YL7CqYD82KaLGzgw305aUKw2aMrdkBR29J183jY\n' +
        '6Ocj9+Wcif9xnRMS+7oCMAvrt03rbh4SU9BohpRUcQ2Pjkh7RoY0jDR4Xq4qzjNr\n' +
        '5UFr3BXpFvACxXF51BksGQ==\n' +
        '-----END CERTIFICATE-----\n',
    '-----BEGIN CERTIFICATE-----\n' +
        'MIICrjCCAjWgAwIBAgIQeKbS5zvtqDvRtwr5H48cAjAKBggqhkjOPQQDAzCBlzEL\n' +
        'MAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4x\n' +
        'EzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTAwLgYDVQQDDCdBbWF6\n' +
        'b24gUkRTIG1lLXNvdXRoLTEgUm9vdCBDQSBFQ0MzODQgRzExEDAOBgNVBAcMB1Nl\n' +
        'YXR0bGUwIBcNMjEwNTIwMTcxOTU1WhgPMjEyMTA1MjAxODE5NTVaMIGXMQswCQYD\n' +
        'VQQGEwJVUzEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywgSW5jLjETMBEG\n' +
        'A1UECwwKQW1hem9uIFJEUzELMAkGA1UECAwCV0ExMDAuBgNVBAMMJ0FtYXpvbiBS\n' +
        'RFMgbWUtc291dGgtMSBSb290IENBIEVDQzM4NCBHMTEQMA4GA1UEBwwHU2VhdHRs\n' +
        'ZTB2MBAGByqGSM49AgEGBSuBBAAiA2IABEKjgUaAPmUlRMEQdBC7BScAGosJ1zRV\n' +
        'LDd38qTBjzgmwBfQJ5ZfGIvyEK5unB09MB4e/3qqK5I/L6Qn5Px/n5g4dq0c7MQZ\n' +
        'u7G9GBYm90U3WRJBf7lQrPStXaRnS4A/O6NCMEAwDwYDVR0TAQH/BAUwAwEB/zAd\n' +
        'BgNVHQ4EFgQUNKcAbGEIn03/vkwd8g6jNyiRdD4wDgYDVR0PAQH/BAQDAgGGMAoG\n' +
        'CCqGSM49BAMDA2cAMGQCMHIeTrjenCSYuGC6txuBt/0ZwnM/ciO9kHGWVCoK8QLs\n' +
        'jGghb5/YSFGZbmQ6qpGlSAIwVOQgdFfTpEfe5i+Vs9frLJ4QKAfc27cTNYzRIM0I\n' +
        'E+AJgK4C4+DiyyMzOpiCfmvq\n' +
        '-----END CERTIFICATE-----\n',
    '-----BEGIN CERTIFICATE-----\n' +
        'MIIGCDCCA/CgAwIBAgIQSFkEUzu9FYgC5dW+5lnTgjANBgkqhkiG9w0BAQwFADCB\n' +
        'nDELMAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIElu\n' +
        'Yy4xEzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTUwMwYDVQQDDCxB\n' +
        'bWF6b24gUkRTIGFwLXNvdXRoZWFzdC0zIFJvb3QgQ0EgUlNBNDA5NiBHMTEQMA4G\n' +
        'A1UEBwwHU2VhdHRsZTAgFw0yMTA2MTEwMDA4MzZaGA8yMTIxMDYxMTAxMDgzNlow\n' +
        'gZwxCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJ\n' +
        'bmMuMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTE1MDMGA1UEAwws\n' +
        'QW1hem9uIFJEUyBhcC1zb3V0aGVhc3QtMyBSb290IENBIFJTQTQwOTYgRzExEDAO\n' +
        'BgNVBAcMB1NlYXR0bGUwggIiMA0GCSqGSIb3DQEBAQUAA4ICDwAwggIKAoICAQDx\n' +
        'my5Qmd8zdwaI/KOKV9Xar9oNbhJP5ED0JCiigkuvCkg5qM36klszE8JhsUj40xpp\n' +
        'vQw9wkYW4y+C8twBpzKGBvakqMnoaVUV7lOCKx0RofrnNwkZCboTBB4X/GCZ3fIl\n' +
        'YTybS7Ehi1UuiaZspIT5A2jidoA8HiBPk+mTg1UUkoWS9h+MEAPa8L4DY6fGf4pO\n' +
        'J1Gk2cdePuNzzIrpm2yPto+I8MRROwZ3ha7ooyymOXKtz2c7jEHHJ314boCXAv9G\n' +
        'cdo27WiebewZkHHH7Zx9iTIVuuk2abyVSzvLVeGv7Nuy4lmSqa5clWYqWsGXxvZ2\n' +
        '0fZC5Gd+BDUMW1eSpW7QDTk3top6x/coNoWuLSfXiC5ZrJkIKimSp9iguULgpK7G\n' +
        'abMMN4PR+O+vhcB8E879hcwmS2yd3IwcPTl3QXxufqeSV58/h2ibkqb/W4Bvggf6\n' +
        '5JMHQPlPHOqMCVFIHP1IffIo+Of7clb30g9FD2j3F4qgV3OLwEDNg/zuO1DiAvH1\n' +
        'L+OnmGHkfbtYz+AVApkAZrxMWwoYrwpauyBusvSzwRE24vLTd2i80ZDH422QBLXG\n' +
        'rN7Zas8rwIiBKacJLYtBYETw8mfsNt8gb72aIQX6cZOsphqp6hUtKaiMTVgGazl7\n' +
        'tBXqbB+sIv3S9X6bM4cZJKkMJOXbnyCCLZFYv8TurwIDAQABo0IwQDAPBgNVHRMB\n' +
        'Af8EBTADAQH/MB0GA1UdDgQWBBTOVtaS1b/lz6yJDvNk65vEastbQTAOBgNVHQ8B\n' +
        'Af8EBAMCAYYwDQYJKoZIhvcNAQEMBQADggIBABEONg+TmMZM/PrYGNAfB4S41zp1\n' +
        '3CVjslZswh/pC4kgXSf8cPJiUOzMwUevuFQj7tCqxQtJEygJM2IFg4ViInIah2kh\n' +
        'xlRakEGGw2dEVlxZAmmLWxlL1s1lN1565t5kgVwM0GVfwYM2xEvUaby6KDVJIkD3\n' +
        'aM6sFDBshvVA70qOggM6kU6mwTbivOROzfoIQDnVaT+LQjHqY/T+ok6IN0YXXCWl\n' +
        'Favai8RDjzLDFwXSRvgIK+1c49vlFFY4W9Efp7Z9tPSZU1TvWUcKdAtV8P2fPHAS\n' +
        'vAZ+g9JuNfeawhEibjXkwg6Z/yFUueQCQOs9TRXYogzp5CMMkfdNJF8byKYqHscs\n' +
        'UosIcETnHwqwban99u35sWcoDZPr6aBIrz7LGKTJrL8Nis8qHqnqQBXu/fsQEN8u\n' +
        'zJ2LBi8sievnzd0qI0kaWmg8GzZmYH1JCt1GXSqOFkI8FMy2bahP7TUQR1LBUKQ3\n' +
        'hrOSqldkhN+cSAOnvbQcFzLr+iEYEk34+NhcMIFVE+51KJ1n6+zISOinr6mI3ckX\n' +
        '6p2tmiCD4Shk2Xx/VTY/KGvQWKFcQApWezBSvDNlGe0yV71LtLf3dr1pr4ofo7cE\n' +
        'rYucCJ40bfxEU/fmzYdBF32xP7AOD9U0FbOR3Mcthc6Z6w20WFC+zru8FGY08gPf\n' +
        'WT1QcNdw7ntUJP/w\n' +
        '-----END CERTIFICATE-----\n',
    '-----BEGIN CERTIFICATE-----\n' +
        'MIICrzCCAjWgAwIBAgIQARky6+5PNFRkFVOp3Ob1CTAKBggqhkjOPQQDAzCBlzEL\n' +
        'MAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4x\n' +
        'EzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTAwLgYDVQQDDCdBbWF6\n' +
        'b24gUkRTIGV1LXNvdXRoLTIgUm9vdCBDQSBFQ0MzODQgRzExEDAOBgNVBAcMB1Nl\n' +
        'YXR0bGUwIBcNMjIwNTIzMTg0MTI4WhgPMjEyMjA1MjMxOTQxMjdaMIGXMQswCQYD\n' +
        'VQQGEwJVUzEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywgSW5jLjETMBEG\n' +
        'A1UECwwKQW1hem9uIFJEUzELMAkGA1UECAwCV0ExMDAuBgNVBAMMJ0FtYXpvbiBS\n' +
        'RFMgZXUtc291dGgtMiBSb290IENBIEVDQzM4NCBHMTEQMA4GA1UEBwwHU2VhdHRs\n' +
        'ZTB2MBAGByqGSM49AgEGBSuBBAAiA2IABNVGL5oF7cfIBxKyWd2PVK/S5yQfaJY3\n' +
        'QFHWvEdt6951n9JhiiPrHzfVHsxZp1CBjILRMzjgRbYWmc8qRoLkgGE7htGdwudJ\n' +
        'Fa/WuKzO574Prv4iZXUnVGTboC7JdvKbh6NCMEAwDwYDVR0TAQH/BAUwAwEB/zAd\n' +
        'BgNVHQ4EFgQUgDeIIEKynwUbNXApdIPnmRWieZwwDgYDVR0PAQH/BAQDAgGGMAoG\n' +
        'CCqGSM49BAMDA2gAMGUCMEOOJfucrST+FxuqJkMZyCM3gWGZaB+/w6+XUAJC6hFM\n' +
        'uSTY0F44/bERkA4XhH+YGAIxAIpJQBakCA1/mXjsTnQ+0El9ty+LODp8ibkn031c\n' +
        '8DKDS7pR9UK7ZYdR6zFg3ZCjQw==\n' +
        '-----END CERTIFICATE-----\n',
    '-----BEGIN CERTIFICATE-----\n' +
        'MIICrjCCAjOgAwIBAgIQJvkWUcYLbnxtuwnyjMmntDAKBggqhkjOPQQDAzCBljEL\n' +
        'MAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4x\n' +
        'EzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMS8wLQYDVQQDDCZBbWF6\n' +
        'b24gUkRTIGV1LXdlc3QtMyBSb290IENBIEVDQzM4NCBHMTEQMA4GA1UEBwwHU2Vh\n' +
        'dHRsZTAgFw0yMTA1MjUyMjI2MTJaGA8yMTIxMDUyNTIzMjYxMlowgZYxCzAJBgNV\n' +
        'BAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMuMRMwEQYD\n' +
        'VQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTEvMC0GA1UEAwwmQW1hem9uIFJE\n' +
        'UyBldS13ZXN0LTMgUm9vdCBDQSBFQ0MzODQgRzExEDAOBgNVBAcMB1NlYXR0bGUw\n' +
        'djAQBgcqhkjOPQIBBgUrgQQAIgNiAARENn8uHCyjn1dFax4OeXxvbV861qsXFD9G\n' +
        'DshumTmFzWWHN/69WN/AOsxy9XN5S7Cgad4gQgeYYYgZ5taw+tFo/jQvCLY//uR5\n' +
        'uihcLuLJ78opvRPvD9kbWZ6oXfBtFkWjQjBAMA8GA1UdEwEB/wQFMAMBAf8wHQYD\n' +
        'VR0OBBYEFKiK3LpoF+gDnqPldGSwChBPCYciMA4GA1UdDwEB/wQEAwIBhjAKBggq\n' +
        'hkjOPQQDAwNpADBmAjEA+7qfvRlnvF1Aosyp9HzxxCbN7VKu+QXXPhLEBWa5oeWW\n' +
        'UOcifunf/IVLC4/FGCsLAjEAte1AYp+iJyOHDB8UYkhBE/1sxnFaTiEPbvQBU0wZ\n' +
        'SuwWVLhu2wWDuSW+K7tTuL8p\n' +
        '-----END CERTIFICATE-----\n',
    '-----BEGIN CERTIFICATE-----\n' +
        'MIID/zCCAuegAwIBAgIRAKeDpqX5WFCGNo94M4v69sUwDQYJKoZIhvcNAQELBQAw\n' +
        'gZcxCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJ\n' +
        'bmMuMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTEwMC4GA1UEAwwn\n' +
        'QW1hem9uIFJEUyBldS13ZXN0LTMgUm9vdCBDQSBSU0EyMDQ4IEcxMRAwDgYDVQQH\n' +
        'DAdTZWF0dGxlMCAXDTIxMDUyNTIyMTgzM1oYDzIwNjEwNTI1MjMxODMzWjCBlzEL\n' +
        'MAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4x\n' +
        'EzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTAwLgYDVQQDDCdBbWF6\n' +
        'b24gUkRTIGV1LXdlc3QtMyBSb290IENBIFJTQTIwNDggRzExEDAOBgNVBAcMB1Nl\n' +
        'YXR0bGUwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQCcKOTEMTfzvs4H\n' +
        'WtJR8gI7GXN6xesulWtZPv21oT+fLGwJ+9Bv8ADCGDDrDxfeH/HxJmzG9hgVAzVn\n' +
        '4g97Bn7q07tGZM5pVi96/aNp11velZT7spOJKfJDZTlGns6DPdHmx48whpdO+dOb\n' +
        '6+eR0VwCIv+Vl1fWXgoACXYCoKjhxJs+R+fwY//0JJ1YG8yjZ+ghLCJmvlkOJmE1\n' +
        'TCPUyIENaEONd6T+FHGLVYRRxC2cPO65Jc4yQjsXvvQypoGgx7FwD5voNJnFMdyY\n' +
        '754JGPOOe/SZdepN7Tz7UEq8kn7NQSbhmCsgA/Hkjkchz96qN/YJ+H/okiQUTNB0\n' +
        'eG9ogiVFAgMBAAGjQjBAMA8GA1UdEwEB/wQFMAMBAf8wHQYDVR0OBBYEFFjayw9Y\n' +
        'MjbxfF14XAhMM2VPl0PfMA4GA1UdDwEB/wQEAwIBhjANBgkqhkiG9w0BAQsFAAOC\n' +
        'AQEAAtmx6d9+9CWlMoU0JCirtp4dSS41bBfb9Oor6GQ8WIr2LdfZLL6uES/ubJPE\n' +
        '1Sh5Vu/Zon5/MbqLMVrfniv3UpQIof37jKXsjZJFE1JVD/qQfRzG8AlBkYgHNEiS\n' +
        'VtD4lFxERmaCkY1tjKB4Dbd5hfhdrDy29618ZjbSP7NwAfnwb96jobCmMKgxVGiH\n' +
        'UqsLSiEBZ33b2hI7PJ6iTJnYBWGuiDnsWzKRmheA4nxwbmcQSfjbrNwa93w3caL2\n' +
        'v/4u54Kcasvcu3yFsUwJygt8z43jsGAemNZsS7GWESxVVlW93MJRn6M+MMakkl9L\n' +
        'tWaXdHZ+KUV7LhfYLb0ajvb40w==\n' +
        '-----END CERTIFICATE-----\n',
    '-----BEGIN CERTIFICATE-----\n' +
        'MIIEBDCCAuygAwIBAgIQJ5oxPEjefCsaESSwrxk68DANBgkqhkiG9w0BAQsFADCB\n' +
        'mjELMAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIElu\n' +
        'Yy4xEzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTMwMQYDVQQDDCpB\n' +
        'bWF6b24gUkRTIGV1LWNlbnRyYWwtMiBSb290IENBIFJTQTIwNDggRzExEDAOBgNV\n' +
        'BAcMB1NlYXR0bGUwIBcNMjIwNjA2MjExNzA1WhgPMjA2MjA2MDYyMjE3MDVaMIGa\n' +
        'MQswCQYDVQQGEwJVUzEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywgSW5j\n' +
        'LjETMBEGA1UECwwKQW1hem9uIFJEUzELMAkGA1UECAwCV0ExMzAxBgNVBAMMKkFt\n' +
        'YXpvbiBSRFMgZXUtY2VudHJhbC0yIFJvb3QgQ0EgUlNBMjA0OCBHMTEQMA4GA1UE\n' +
        'BwwHU2VhdHRsZTCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBALTQt5eX\n' +
        'g+VP3BjO9VBkWJhE0GfLrU/QIk32I6WvrnejayTrlup9H1z4QWlXF7GNJrqScRMY\n' +
        'KhJHlcP05aPsx1lYco6pdFOf42ybXyWHHJdShj4A5glU81GTT+VrXGzHSarLmtua\n' +
        'eozkQgPpDsSlPt0RefyTyel7r3Cq+5K/4vyjCTcIqbfgaGwTU36ffjM1LaPCuE4O\n' +
        'nINMeD6YuImt2hU/mFl20FZ+IZQUIFZZU7pxGLqTRz/PWcH8tDDxnkYg7tNuXOeN\n' +
        'JbTpXrw7St50/E9ZQ0llGS+MxJD8jGRAa/oL4G/cwnV8P2OEPVVkgN9xDDQeieo0\n' +
        '3xkzolkDkmeKOnUCAwEAAaNCMEAwDwYDVR0TAQH/BAUwAwEB/zAdBgNVHQ4EFgQU\n' +
        'bwu8635iQGQMRanekesORM8Hkm4wDgYDVR0PAQH/BAQDAgGGMA0GCSqGSIb3DQEB\n' +
        'CwUAA4IBAQAgN6LE9mUgjsj6xGCX1afYE69fnmCjjb0rC6eEe1mb/QZNcyw4XBIW\n' +
        '6+zTXo4mjZ4ffoxb//R0/+vdTE7IvaLgfAZgFsLKJCtYDDstXZj8ujQnGR9Pig3R\n' +
        'W+LpNacvOOSJSawNQq0Xrlcu55AU4buyD5VjcICnfF1dqBMnGTnh27m/scd/ZMx/\n' +
        'kapHZ/fMoK2mAgSX/NvUKF3UkhT85vSSM2BTtET33DzCPDQTZQYxFBa4rFRmFi4c\n' +
        'BLlmIReiCGyh3eJhuUUuYAbK6wLaRyPsyEcIOLMQmZe1+gAFm1+1/q5Ke9ugBmjf\n' +
        'PbTWjsi/lfZ5CdVAhc5lmZj/l5aKqwaS\n' +
        '-----END CERTIFICATE-----\n',
    '-----BEGIN CERTIFICATE-----\n' +
        'MIICrjCCAjSgAwIBAgIRAKKPTYKln9L4NTx9dpZGUjowCgYIKoZIzj0EAwMwgZYx\n' +
        'CzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMu\n' +
        'MRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTEvMC0GA1UEAwwmQW1h\n' +
        'em9uIFJEUyBldS13ZXN0LTIgUm9vdCBDQSBFQ0MzODQgRzExEDAOBgNVBAcMB1Nl\n' +
        'YXR0bGUwIBcNMjEwNTIxMjI1NTIxWhgPMjEyMTA1MjEyMzU1MjFaMIGWMQswCQYD\n' +
        'VQQGEwJVUzEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywgSW5jLjETMBEG\n' +
        'A1UECwwKQW1hem9uIFJEUzELMAkGA1UECAwCV0ExLzAtBgNVBAMMJkFtYXpvbiBS\n' +
        'RFMgZXUtd2VzdC0yIFJvb3QgQ0EgRUNDMzg0IEcxMRAwDgYDVQQHDAdTZWF0dGxl\n' +
        'MHYwEAYHKoZIzj0CAQYFK4EEACIDYgAE/owTReDvaRqdmbtTzXbyRmEpKCETNj6O\n' +
        'hZMKH0F8oU9Tmn8RU7kQQj6xUKEyjLPrFBN7c+26TvrVO1KmJAvbc8bVliiJZMbc\n' +
        'C0yV5PtJTalvlMZA1NnciZuhxaxrzlK1o0IwQDAPBgNVHRMBAf8EBTADAQH/MB0G\n' +
        'A1UdDgQWBBT4i5HaoHtrs7Mi8auLhMbKM1XevDAOBgNVHQ8BAf8EBAMCAYYwCgYI\n' +
        'KoZIzj0EAwMDaAAwZQIxAK9A+8/lFdX4XJKgfP+ZLy5ySXC2E0Spoy12Gv2GdUEZ\n' +
        'p1G7c1KbWVlyb1d6subzkQIwKyH0Naf/3usWfftkmq8SzagicKz5cGcEUaULq4tO\n' +
        'GzA/AMpr63IDBAqkZbMDTCmH\n' +
        '-----END CERTIFICATE-----\n',
    '-----BEGIN CERTIFICATE-----\n' +
        'MIICrzCCAjWgAwIBAgIQTgIvwTDuNWQo0Oe1sOPQEzAKBggqhkjOPQQDAzCBlzEL\n' +
        'MAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4x\n' +
        'EzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTAwLgYDVQQDDCdBbWF6\n' +
        'b24gUkRTIGV1LW5vcnRoLTEgUm9vdCBDQSBFQ0MzODQgRzExEDAOBgNVBAcMB1Nl\n' +
        'YXR0bGUwIBcNMjEwNTI0MjEwNjM4WhgPMjEyMTA1MjQyMjA2MzhaMIGXMQswCQYD\n' +
        'VQQGEwJVUzEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywgSW5jLjETMBEG\n' +
        'A1UECwwKQW1hem9uIFJEUzELMAkGA1UECAwCV0ExMDAuBgNVBAMMJ0FtYXpvbiBS\n' +
        'RFMgZXUtbm9ydGgtMSBSb290IENBIEVDQzM4NCBHMTEQMA4GA1UEBwwHU2VhdHRs\n' +
        'ZTB2MBAGByqGSM49AgEGBSuBBAAiA2IABJuzXLU8q6WwSKXBvx8BbdIi3mPhb7Xo\n' +
        'rNJBfuMW1XRj5BcKH1ZoGaDGw+BIIwyBJg8qNmCK8kqIb4cH8/Hbo3Y+xBJyoXq/\n' +
        'cuk8aPrxiNoRsKWwiDHCsVxaK9L7GhHHAqNCMEAwDwYDVR0TAQH/BAUwAwEB/zAd\n' +
        'BgNVHQ4EFgQUYgcsdU4fm5xtuqLNppkfTHM2QMYwDgYDVR0PAQH/BAQDAgGGMAoG\n' +
        'CCqGSM49BAMDA2gAMGUCMQDz/Rm89+QJOWJecYAmYcBWCcETASyoK1kbr4vw7Hsg\n' +
        '7Ew3LpLeq4IRmTyuiTMl0gMCMAa0QSjfAnxBKGhAnYxcNJSntUyyMpaXzur43ec0\n' +
        '3D8npJghwC4DuICtKEkQiI5cSg==\n' +
        '-----END CERTIFICATE-----\n',
    '-----BEGIN CERTIFICATE-----\n' +
        'MIIGATCCA+mgAwIBAgIRAORIGqQXLTcbbYT2upIsSnQwDQYJKoZIhvcNAQEMBQAw\n' +
        'gZgxCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJ\n' +
        'bmMuMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTExMC8GA1UEAwwo\n' +
        'QW1hem9uIFJEUyBldS1zb3V0aC0yIFJvb3QgQ0EgUlNBNDA5NiBHMTEQMA4GA1UE\n' +
        'BwwHU2VhdHRsZTAgFw0yMjA1MjMxODM0MjJaGA8yMTIyMDUyMzE5MzQyMlowgZgx\n' +
        'CzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMu\n' +
        'MRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTExMC8GA1UEAwwoQW1h\n' +
        'em9uIFJEUyBldS1zb3V0aC0yIFJvb3QgQ0EgUlNBNDA5NiBHMTEQMA4GA1UEBwwH\n' +
        'U2VhdHRsZTCCAiIwDQYJKoZIhvcNAQEBBQADggIPADCCAgoCggIBAPKukwsW2s/h\n' +
        '1k+Hf65pOP0knVBnOnMQyT1mopp2XHGdXznj9xS49S30jYoUnWccyXgD983A1bzu\n' +
        'w4fuJRHg4MFdz/NWTgXvy+zy0Roe83OPIJjUmXnnzwUHQcBa9vl6XUO65iQ3pbSi\n' +
        'fQfNDFXD8cvuXbkezeADoy+iFAlzhXTzV9MD44GTuo9Z3qAXNGHQCrgRSCL7uRYt\n' +
        't1nfwboCbsVRnElopn2cTigyVXE62HzBUmAw1GTbAZeFAqCn5giBWYAfHwTUldRL\n' +
        '6eEa6atfsS2oPNus4ZENa1iQxXq7ft+pMdNt0qKXTCZiiCZjmLkY0V9kWwHTRRF8\n' +
        'r+75oSL//3di43QnuSCgjwMRIeWNtMud5jf3eQzSBci+9njb6DrrSUbx7blP0srg\n' +
        '94/C/fYOp/0/EHH34w99Th14VVuGWgDgKahT9/COychLOubXUT6vD1As47S9KxTv\n' +
        'yYleVKwJnF9cVjepODN72fNlEf74BwzgSIhUmhksmZSeJBabrjSUj3pdyo/iRZN/\n' +
        'CiYz9YPQ29eXHPQjBZVIUqWbOVfdwsx0/Xu5T1e7yyXByQ3/oDulahtcoKPAFQ3J\n' +
        'ee6NJK655MdS7pM9hJnU2Rzu3qZ/GkM6YK7xTlMXVouPUZov/VbiaCKbqYDs8Dg+\n' +
        'UKdeNXAT6+BMleGQzly1X7vjhgeA8ugVAgMBAAGjQjBAMA8GA1UdEwEB/wQFMAMB\n' +
        'Af8wHQYDVR0OBBYEFJdaPwpCf78UolFTEn6GO85/QwUIMA4GA1UdDwEB/wQEAwIB\n' +
        'hjANBgkqhkiG9w0BAQwFAAOCAgEAWkxHIT3mers5YnZRSVjmpxCLivGj1jMB9VYC\n' +
        'iKqTAeIvD0940L0YaZgivQll5pue8UUcQ6M2uCdVVAsNJdmQ5XHIYiGOknYPtxzO\n' +
        'aO+bnZp7VIZw/vJ49hvH6RreA2bbxYMZO/ossYdcWsWbOKHFrRmAw0AhtK/my51g\n' +
        'obV7eQg+WmlE5Iqc75ycUsoZdc3NimkjBi7LQoNP1HMvlLHlF71UZhQDdq+/WdV7\n' +
        '0zmg+epkki1LjgMmuPyb+xWuYkFKT1/faX+Xs62hIm5BY+aI4if4RuQ+J//0pOSs\n' +
        'UajrjTo+jLGB8A96jAe8HaFQenbwMjlaHRDAF0wvbkYrMr5a6EbneAB37V05QD0Y\n' +
        'Rh4L4RrSs9DX2hbSmS6iLDuPEjanHKzglF5ePEvnItbRvGGkynqDVlwF+Bqfnw8l\n' +
        '0i8Hr1f1/LP1c075UjkvsHlUnGgPbLqA0rDdcxF8Fdlv1BunUjX0pVlz10Ha5M6P\n' +
        'AdyWUOneOfaA5G7jjv7i9qg3r99JNs1/Lmyg/tV++gnWTAsSPFSSEte81kmPhlK3\n' +
        '2UtAO47nOdTtk+q4VIRAwY1MaOR7wTFZPfer1mWs4RhKNu/odp8urEY87iIzbMWT\n' +
        'QYO/4I6BGj9rEWNGncvR5XTowwIthMCj2KWKM3Z/JxvjVFylSf+s+FFfO1bNIm6h\n' +
        'u3UBpZI=\n' +
        '-----END CERTIFICATE-----\n',
    '-----BEGIN CERTIFICATE-----\n' +
        'MIICtDCCAjmgAwIBAgIQenQbcP/Zbj9JxvZ+jXbRnTAKBggqhkjOPQQDAzCBmTEL\n' +
        'MAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4x\n' +
        'EzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTIwMAYDVQQDDClBbWF6\n' +
        'b24gUkRTIGV1LWNlbnRyYWwtMSBSb290IENBIEVDQzM4NCBHMTEQMA4GA1UEBwwH\n' +
        'U2VhdHRsZTAgFw0yMTA1MjEyMjMzMjRaGA8yMTIxMDUyMTIzMzMyNFowgZkxCzAJ\n' +
        'BgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMuMRMw\n' +
        'EQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTEyMDAGA1UEAwwpQW1hem9u\n' +
        'IFJEUyBldS1jZW50cmFsLTEgUm9vdCBDQSBFQ0MzODQgRzExEDAOBgNVBAcMB1Nl\n' +
        'YXR0bGUwdjAQBgcqhkjOPQIBBgUrgQQAIgNiAATlBHiEM9LoEb1Hdnd5j2VpCDOU\n' +
        '5nGuFoBD8ROUCkFLFh5mHrHfPXwBc63heW9WrP3qnDEm+UZEUvW7ROvtWCTPZdLz\n' +
        'Z4XaqgAlSqeE2VfUyZOZzBSgUUJk7OlznXfkCMOjQjBAMA8GA1UdEwEB/wQFMAMB\n' +
        'Af8wHQYDVR0OBBYEFDT/ThjQZl42Nv/4Z/7JYaPNMly2MA4GA1UdDwEB/wQEAwIB\n' +
        'hjAKBggqhkjOPQQDAwNpADBmAjEAnZWmSgpEbmq+oiCa13l5aGmxSlfp9h12Orvw\n' +
        'Dq/W5cENJz891QD0ufOsic5oGq1JAjEAp5kSJj0MxJBTHQze1Aa9gG4sjHBxXn98\n' +
        '4MP1VGsQuhfndNHQb4V0Au7OWnOeiobq\n' +
        '-----END CERTIFICATE-----\n',
    '-----BEGIN CERTIFICATE-----\n' +
        'MIID/zCCAuegAwIBAgIRAMgnyikWz46xY6yRgiYwZ3swDQYJKoZIhvcNAQELBQAw\n' +
        'gZcxCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJ\n' +
        'bmMuMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTEwMC4GA1UEAwwn\n' +
        'QW1hem9uIFJEUyBldS13ZXN0LTEgUm9vdCBDQSBSU0EyMDQ4IEcxMRAwDgYDVQQH\n' +
        'DAdTZWF0dGxlMCAXDTIxMDUyMDE2NDkxMloYDzIwNjEwNTIwMTc0OTEyWjCBlzEL\n' +
        'MAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4x\n' +
        'EzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTAwLgYDVQQDDCdBbWF6\n' +
        'b24gUkRTIGV1LXdlc3QtMSBSb290IENBIFJTQTIwNDggRzExEDAOBgNVBAcMB1Nl\n' +
        'YXR0bGUwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQCi8JYOc9cYSgZH\n' +
        'gYPxLk6Xcc7HqzamvsnjYU98Dcb98y6iDqS46Ra2Ne02MITtU5MDL+qjxb8WGDZV\n' +
        'RUA9ZS69tkTO3gldW8QdiSh3J6hVNJQW81F0M7ZWgV0gB3n76WCmfT4IWos0AXHM\n' +
        '5v7M/M4tqVmCPViQnZb2kdVlM3/Xc9GInfSMCgNfwHPTXl+PXX+xCdNBePaP/A5C\n' +
        '5S0oK3HiXaKGQAy3K7VnaQaYdiv32XUatlM4K2WS4AMKt+2cw3hTCjlmqKRHvYFQ\n' +
        'veWCXAuc+U5PQDJ9SuxB1buFJZhT4VP3JagOuZbh5NWpIbOTxlAJOb5pGEDuJTKi\n' +
        '1gQQQVEFAgMBAAGjQjBAMA8GA1UdEwEB/wQFMAMBAf8wHQYDVR0OBBYEFNXm+N87\n' +
        'OFxK9Af/bjSxDCiulGUzMA4GA1UdDwEB/wQEAwIBhjANBgkqhkiG9w0BAQsFAAOC\n' +
        'AQEAkqIbkgZ45spvrgRQ6n9VKzDLvNg+WciLtmVrqyohwwJbj4pYvWwnKQCkVc7c\n' +
        'hUOSBmlSBa5REAPbH5o8bdt00FPRrD6BdXLXhaECKgjsHe1WW08nsequRKD8xVmc\n' +
        '8bEX6sw/utBeBV3mB+3Zv7ejYAbDFM4vnRsWtO+XqgReOgrl+cwdA6SNQT9oW3e5\n' +
        'rSQ+VaXgJtl9NhkiIysq9BeYigxqS/A13pHQp0COMwS8nz+kBPHhJTsajHCDc8F4\n' +
        'HfLi6cgs9G0gaRhT8FCH66OdGSqn196sE7Y3bPFFFs/3U+vxvmQgoZC6jegQXAg5\n' +
        'Prxd+VNXtNI/azitTysQPumH7A==\n' +
        '-----END CERTIFICATE-----\n',
    '-----BEGIN CERTIFICATE-----\n' +
        'MIIEBTCCAu2gAwIBAgIRAO8bekN7rUReuNPG8pSTKtEwDQYJKoZIhvcNAQELBQAw\n' +
        'gZoxCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJ\n' +
        'bmMuMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTEzMDEGA1UEAwwq\n' +
        'QW1hem9uIFJEUyBldS1jZW50cmFsLTEgUm9vdCBDQSBSU0EyMDQ4IEcxMRAwDgYD\n' +
        'VQQHDAdTZWF0dGxlMCAXDTIxMDUyMTIyMjM0N1oYDzIwNjEwNTIxMjMyMzQ3WjCB\n' +
        'mjELMAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIElu\n' +
        'Yy4xEzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTMwMQYDVQQDDCpB\n' +
        'bWF6b24gUkRTIGV1LWNlbnRyYWwtMSBSb290IENBIFJTQTIwNDggRzExEDAOBgNV\n' +
        'BAcMB1NlYXR0bGUwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQCTTYds\n' +
        'Tray+Q9VA5j5jTh5TunHKFQzn68ZbOzdqaoi/Rq4ohfC0xdLrxCpfqn2TGDHN6Zi\n' +
        '2qGK1tWJZEd1H0trhzd9d1CtGK+3cjabUmz/TjSW/qBar7e9MA67/iJ74Gc+Ww43\n' +
        'A0xPNIWcL4aLrHaLm7sHgAO2UCKsrBUpxErOAACERScVYwPAfu79xeFcX7DmcX+e\n' +
        'lIqY16pQAvK2RIzrekSYfLFxwFq2hnlgKHaVgZ3keKP+nmXcXmRSHQYUUr72oYNZ\n' +
        'HcNYl2+gxCc9ccPEHM7xncVEKmb5cWEWvVoaysgQ+osi5f5aQdzgC2X2g2daKbyA\n' +
        'XL/z5FM9GHpS5BJjAgMBAAGjQjBAMA8GA1UdEwEB/wQFMAMBAf8wHQYDVR0OBBYE\n' +
        'FBDAiJ7Py9/A9etNa/ebOnx5l5MGMA4GA1UdDwEB/wQEAwIBhjANBgkqhkiG9w0B\n' +
        'AQsFAAOCAQEALMh/+81fFPdJV/RrJUeoUvFCGMp8iaANu97NpeJyKitNOv7RoeVP\n' +
        'WjivS0KcCqZaDBs+p6IZ0sLI5ZH098LDzzytcfZg0PsGqUAb8a0MiU/LfgDCI9Ee\n' +
        'jsOiwaFB8k0tfUJK32NPcIoQYApTMT2e26lPzYORSkfuntme2PTHUnuC7ikiQrZk\n' +
        'P+SZjWgRuMcp09JfRXyAYWIuix4Gy0eZ4rpRuaTK6mjAb1/LYoNK/iZ/gTeIqrNt\n' +
        'l70OWRsWW8jEmSyNTIubGK/gGGyfuZGSyqoRX6OKHESkP6SSulbIZHyJ5VZkgtXo\n' +
        '2XvyRyJ7w5pFyoofrL3Wv0UF8yt/GDszmg==\n' +
        '-----END CERTIFICATE-----\n',
    '-----BEGIN CERTIFICATE-----\n' +
        'MIIF/zCCA+egAwIBAgIRAMDk/F+rrhdn42SfE+ghPC8wDQYJKoZIhvcNAQEMBQAw\n' +
        'gZcxCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJ\n' +
        'bmMuMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTEwMC4GA1UEAwwn\n' +
        'QW1hem9uIFJEUyBldS13ZXN0LTIgUm9vdCBDQSBSU0E0MDk2IEcxMRAwDgYDVQQH\n' +
        'DAdTZWF0dGxlMCAXDTIxMDUyMTIyNTEyMloYDzIxMjEwNTIxMjM1MTIyWjCBlzEL\n' +
        'MAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4x\n' +
        'EzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTAwLgYDVQQDDCdBbWF6\n' +
        'b24gUkRTIGV1LXdlc3QtMiBSb290IENBIFJTQTQwOTYgRzExEDAOBgNVBAcMB1Nl\n' +
        'YXR0bGUwggIiMA0GCSqGSIb3DQEBAQUAA4ICDwAwggIKAoICAQC2twMALVg9vRVu\n' +
        'VNqsr6N8thmp3Dy8jEGTsm3GCQ+C5P2YcGlD/T/5icfWW84uF7Sx3ezcGlvsqFMf\n' +
        'Ukj9sQyqtz7qfFFugyy7pa/eH9f48kWFHLbQYm9GEgbYBIrWMp1cy3vyxuMCwQN4\n' +
        'DCncqU+yNpy0CprQJEha3PzY+3yJOjDQtc3zr99lyECCFJTDUucxHzyQvX89eL74\n' +
        'uh8la0lKH3v9wPpnEoftbrwmm5jHNFdzj7uXUHUJ41N7af7z7QUfghIRhlBDiKtx\n' +
        '5lYZemPCXajTc3ryDKUZC/b+B6ViXZmAeMdmQoPE0jwyEp/uaUcdp+FlUQwCfsBk\n' +
        'ayPFEApTWgPiku2isjdeTVmEgL8bJTDUZ6FYFR7ZHcYAsDzcwHgIu3GGEMVRS3Uf\n' +
        'ILmioiyly9vcK4Sa01ondARmsi/I0s7pWpKflaekyv5boJKD/xqwz9lGejmJHelf\n' +
        '8Od2TyqJScMpB7Q8c2ROxBwqwB72jMCEvYigB+Wnbb8RipliqNflIGx938FRCzKL\n' +
        'UQUBmNAznR/yRRL0wHf9UAE/8v9a09uZABeiznzOFAl/frHpgdAbC00LkFlnwwgX\n' +
        'g8YfEFlkp4fLx5B7LtoO6uVNFVimLxtwirpyKoj3G4M/kvSTux8bTw0heBCmWmKR\n' +
        '57MS6k7ODzbv+Kpeht2hqVZCNFMxoQIDAQABo0IwQDAPBgNVHRMBAf8EBTADAQH/\n' +
        'MB0GA1UdDgQWBBRuMnDhJjoj7DcKALj+HbxEqj3r6jAOBgNVHQ8BAf8EBAMCAYYw\n' +
        'DQYJKoZIhvcNAQEMBQADggIBALSnXfx72C3ldhBP5kY4Mo2DDaGQ8FGpTOOiD95d\n' +
        '0rf7I9LrsBGVqu/Nir+kqqP80PB70+Jy9fHFFigXwcPBX3MpKGxK8Cel7kVf8t1B\n' +
        '4YD6A6bqlzP+OUL0uGWfZpdpDxwMDI2Flt4NEldHgXWPjvN1VblEKs0+kPnKowyg\n' +
        'jhRMgBbD/y+8yg0fIcjXUDTAw/+INcp21gWaMukKQr/8HswqC1yoqW9in2ijQkpK\n' +
        '2RB9vcQ0/gXR0oJUbZQx0jn0OH8Agt7yfMAnJAdnHO4M3gjvlJLzIC5/4aGrRXZl\n' +
        'JoZKfJ2fZRnrFMi0nhAYDeInoS+Rwx+QzaBk6fX5VPyCj8foZ0nmqvuYoydzD8W5\n' +
        'mMlycgxFqS+DUmO+liWllQC4/MnVBlHGB1Cu3wTj5kgOvNs/k+FW3GXGzD3+rpv0\n' +
        'QTLuwSbMr+MbEThxrSZRSXTCQzKfehyC+WZejgLb+8ylLJUA10e62o7H9PvCrwj+\n' +
        'ZDVmN7qj6amzvndCP98sZfX7CFZPLfcBd4wVIjHsFjSNEwWHOiFyLPPG7cdolGKA\n' +
        'lOFvonvo4A1uRc13/zFeP0Xi5n5OZ2go8aOOeGYdI2vB2sgH9R2IASH/jHmr0gvY\n' +
        '0dfBCcfXNgrS0toq0LX/y+5KkKOxh52vEYsJLdhqrveuZhQnsFEm/mFwjRXkyO7c\n' +
        '2jpC\n' +
        '-----END CERTIFICATE-----\n',
    '-----BEGIN CERTIFICATE-----\n' +
        'MIIGADCCA+igAwIBAgIQYe0HgSuFFP9ivYM2vONTrTANBgkqhkiG9w0BAQwFADCB\n' +
        'mDELMAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIElu\n' +
        'Yy4xEzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTEwLwYDVQQDDChB\n' +
        'bWF6b24gUkRTIGV1LXNvdXRoLTEgUm9vdCBDQSBSU0E0MDk2IEcxMRAwDgYDVQQH\n' +
        'DAdTZWF0dGxlMCAXDTIxMDUxOTE4MzMyMVoYDzIxMjEwNTE5MTkzMzIxWjCBmDEL\n' +
        'MAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4x\n' +
        'EzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTEwLwYDVQQDDChBbWF6\n' +
        'b24gUkRTIGV1LXNvdXRoLTEgUm9vdCBDQSBSU0E0MDk2IEcxMRAwDgYDVQQHDAdT\n' +
        'ZWF0dGxlMIICIjANBgkqhkiG9w0BAQEFAAOCAg8AMIICCgKCAgEAuO7QPKfPMTo2\n' +
        'POQWvzDLwi5f++X98hGjORI1zkN9kotCYH5pAzSBwBPoMNaIfedgmsIxGHj2fq5G\n' +
        '4oXagNhNuGP79Zl6uKW5H7S74W7aWM8C0s8zuxMOI4GZy5h2IfQk3m/3AzZEX5w8\n' +
        'UtNPkzo2feDVOkerHT+j+vjXgAxZ4wHnuMDcRT+K4r9EXlAH6X9b/RO0JlfEwmNz\n' +
        'xlqqGxocq9qRC66N6W0HF2fNEAKP84n8H80xcZBOBthQORRi8HSmKcPdmrvwCuPz\n' +
        'M+L+j18q6RAVaA0ABbD0jMWcTf0UvjUfBStn5mvu/wGlLjmmRkZsppUTRukfwqXK\n' +
        'yltUsTq0tOIgCIpne5zA4v+MebbR5JBnsvd4gdh5BI01QH470yB7BkUefZ9bobOm\n' +
        'OseAAVXcYFJKe4DAA6uLDrqOfFSxV+CzVvEp3IhLRaik4G5MwI/h2c/jEYDqkg2J\n' +
        'HMflxc2gcSMdk7E5ByLz5f6QrFfSDFk02ZJTs4ssbbUEYohht9znPMQEaWVqATWE\n' +
        '3n0VspqZyoBNkH/agE5GiGZ/k/QyeqzMNj+c9kr43Upu8DpLrz8v2uAp5xNj3YVg\n' +
        'ihaeD6GW8+PQoEjZ3mrCmH7uGLmHxh7Am59LfEyNrDn+8Rq95WvkmbyHSVxZnBmo\n' +
        'h/6O3Jk+0/QhIXZ2hryMflPcYWeRGH0CAwEAAaNCMEAwDwYDVR0TAQH/BAUwAwEB\n' +
        '/zAdBgNVHQ4EFgQU2eFK7+R3x/me8roIBNxBrplkM6EwDgYDVR0PAQH/BAQDAgGG\n' +
        'MA0GCSqGSIb3DQEBDAUAA4ICAQB5gWFe5s7ObQFj1fTO9L6gYgtFhnwdmxU0q8Ke\n' +
        'HWCrdFmyXdC39qdAFOwM5/7fa9zKmiMrZvy9HNvCXEp4Z7z9mHhBmuqPZQx0qPgU\n' +
        'uLdP8wGRuWryzp3g2oqkX9t31Z0JnkbIdp7kfRT6ME4I4VQsaY5Y3mh+hIHOUvcy\n' +
        'p+98i3UuEIcwJnVAV9wTTzrWusZl9iaQ1nSYbmkX9bBssJ2GmtW+T+VS/1hJ/Q4f\n' +
        'AlE3dOQkLFoPPb3YRWBHr2n1LPIqMVwDNAuWavRA2dSfaLl+kzbn/dua7HTQU5D4\n' +
        'b2Fu2vLhGirwRJe+V7zdef+tI7sngXqjgObyOeG5O2BY3s+um6D4fS0Th3QchMO7\n' +
        '0+GwcIgSgcjIjlrt6/xJwJLE8cRkUUieYKq1C4McpZWTF30WnzOPUzRzLHkcNzNA\n' +
        '0A7sKMK6QoYWo5Rmo8zewUxUqzc9oQSrYADP7PEwGncLtFe+dlRFx+PA1a+lcIgo\n' +
        '1ZGfXigYtQ3VKkcknyYlJ+hN4eCMBHtD81xDy9iP2MLE41JhLnoB2rVEtewO5diF\n' +
        '7o95Mwl84VMkLhhHPeGKSKzEbBtYYBifHNct+Bst8dru8UumTltgfX6urH3DN+/8\n' +
        'JF+5h3U8oR2LL5y76cyeb+GWDXXy9zoQe2QvTyTy88LwZq1JzujYi2k8QiLLhFIf\n' +
        'FEv9Bg==\n' +
        '-----END CERTIFICATE-----\n',
    '-----BEGIN CERTIFICATE-----\n' +
        'MIICsDCCAjagAwIBAgIRAMgApnfGYPpK/fD0dbN2U4YwCgYIKoZIzj0EAwMwgZcx\n' +
        'CzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMu\n' +
        'MRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTEwMC4GA1UEAwwnQW1h\n' +
        'em9uIFJEUyBldS1zb3V0aC0xIFJvb3QgQ0EgRUNDMzg0IEcxMRAwDgYDVQQHDAdT\n' +
        'ZWF0dGxlMCAXDTIxMDUxOTE4MzgxMVoYDzIxMjEwNTE5MTkzODExWjCBlzELMAkG\n' +
        'A1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4xEzAR\n' +
        'BgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTAwLgYDVQQDDCdBbWF6b24g\n' +
        'UkRTIGV1LXNvdXRoLTEgUm9vdCBDQSBFQ0MzODQgRzExEDAOBgNVBAcMB1NlYXR0\n' +
        'bGUwdjAQBgcqhkjOPQIBBgUrgQQAIgNiAAQfEWl6d4qSuIoECdZPp+39LaKsfsX7\n' +
        'THs3/RrtT0+h/jl3bjZ7Qc68k16x+HGcHbaayHfqD0LPdzH/kKtNSfQKqemdxDQh\n' +
        'Z4pwkixJu8T1VpXZ5zzCvBXCl75UqgEFS92jQjBAMA8GA1UdEwEB/wQFMAMBAf8w\n' +
        'HQYDVR0OBBYEFFPrSNtWS5JU+Tvi6ABV231XbjbEMA4GA1UdDwEB/wQEAwIBhjAK\n' +
        'BggqhkjOPQQDAwNoADBlAjEA+a7hF1IrNkBd2N/l7IQYAQw8chnRZDzh4wiGsZsC\n' +
        '6A83maaKFWUKIb3qZYXFSi02AjAbp3wxH3myAmF8WekDHhKcC2zDvyOiKLkg9Y6v\n' +
        'ZVmyMR043dscQbcsVoacOYv198c=\n' +
        '-----END CERTIFICATE-----\n',
    '-----BEGIN CERTIFICATE-----\n' +
        'MIICtDCCAjqgAwIBAgIRAPhVkIsQ51JFhD2kjFK5uAkwCgYIKoZIzj0EAwMwgZkx\n' +
        'CzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMu\n' +
        'MRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTEyMDAGA1UEAwwpQW1h\n' +
        'em9uIFJEUyBldS1jZW50cmFsLTIgUm9vdCBDQSBFQ0MzODQgRzExEDAOBgNVBAcM\n' +
        'B1NlYXR0bGUwIBcNMjIwNjA2MjEyOTE3WhgPMjEyMjA2MDYyMjI5MTdaMIGZMQsw\n' +
        'CQYDVQQGEwJVUzEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywgSW5jLjET\n' +
        'MBEGA1UECwwKQW1hem9uIFJEUzELMAkGA1UECAwCV0ExMjAwBgNVBAMMKUFtYXpv\n' +
        'biBSRFMgZXUtY2VudHJhbC0yIFJvb3QgQ0EgRUNDMzg0IEcxMRAwDgYDVQQHDAdT\n' +
        'ZWF0dGxlMHYwEAYHKoZIzj0CAQYFK4EEACIDYgAEA5xnIEBtG5b2nmbj49UEwQza\n' +
        'yX0844fXjccYzZ8xCDUe9dS2XOUi0aZlGblgSe/3lwjg8fMcKXLObGGQfgIx1+5h\n' +
        'AIBjORis/dlyN5q/yH4U5sjS8tcR0GDGVHrsRUZCo0IwQDAPBgNVHRMBAf8EBTAD\n' +
        'AQH/MB0GA1UdDgQWBBRK+lSGutXf4DkTjR3WNfv4+KeNFTAOBgNVHQ8BAf8EBAMC\n' +
        'AYYwCgYIKoZIzj0EAwMDaAAwZQIxAJ4NxQ1Gerqr70ZrnUqc62Vl8NNqTzInamCG\n' +
        'Kce3FTsMWbS9qkgrjZkO9QqOcGIw/gIwSLrwUT+PKr9+H9eHyGvpq9/3AIYSnFkb\n' +
        'Cf3dyWPiLKoAtLFwjzB/CkJlsAS1c8dS\n' +
        '-----END CERTIFICATE-----\n',
    '-----BEGIN CERTIFICATE-----\n' +
        'MIIF/jCCA+agAwIBAgIQGZH12Q7x41qIh9vDu9ikTjANBgkqhkiG9w0BAQwFADCB\n' +
        'lzELMAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIElu\n' +
        'Yy4xEzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTAwLgYDVQQDDCdB\n' +
        'bWF6b24gUkRTIGV1LXdlc3QtMyBSb290IENBIFJTQTQwOTYgRzExEDAOBgNVBAcM\n' +
        'B1NlYXR0bGUwIBcNMjEwNTI1MjIyMjMzWhgPMjEyMTA1MjUyMzIyMzNaMIGXMQsw\n' +
        'CQYDVQQGEwJVUzEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywgSW5jLjET\n' +
        'MBEGA1UECwwKQW1hem9uIFJEUzELMAkGA1UECAwCV0ExMDAuBgNVBAMMJ0FtYXpv\n' +
        'biBSRFMgZXUtd2VzdC0zIFJvb3QgQ0EgUlNBNDA5NiBHMTEQMA4GA1UEBwwHU2Vh\n' +
        'dHRsZTCCAiIwDQYJKoZIhvcNAQEBBQADggIPADCCAgoCggIBAMqE47sHXWzdpuqj\n' +
        'JHb+6jM9tDbQLDFnYjDWpq4VpLPZhb7xPNh9gnYYTPKG4avG421EblAHqzy9D2pN\n' +
        '1z90yKbIfUb/Sy2MhQbmZomsObhONEra06fJ0Dydyjswf1iYRp2kwpx5AgkVoNo7\n' +
        '3dlws73zFjD7ImKvUx2C7B75bhnw2pJWkFnGcswl8fZt9B5Yt95sFOKEz2MSJE91\n' +
        'kZlHtya19OUxZ/cSGci4MlOySzqzbGwUqGxEIDlY8I39VMwXaYQ8uXUN4G780VcL\n' +
        'u46FeyRGxZGz2n3hMc805WAA1V5uir87vuirTvoSVREET97HVRGVVNJJ/FM6GXr1\n' +
        'VKtptybbo81nefYJg9KBysxAa2Ao2x2ry/2ZxwhS6VZ6v1+90bpZA1BIYFEDXXn/\n' +
        'dW07HSCFnYSlgPtSc+Muh15mdr94LspYeDqNIierK9i4tB6ep7llJAnq0BU91fM2\n' +
        'JPeqyoTtc3m06QhLf68ccSxO4l8Hmq9kLSHO7UXgtdjfRVaffngopTNk8qK7bIb7\n' +
        'LrgkqhiQw/PRCZjUdyXL153/fUcsj9nFNe25gM4vcFYwH6c5trd2tUl31NTi1MfG\n' +
        'Mgp3d2dqxQBIYANkEjtBDMy3SqQLIo9EymqmVP8xx2A/gCBgaxvMAsI6FSWRoC7+\n' +
        'hqJ8XH4mFnXSHKtYMe6WPY+/XZgtAgMBAAGjQjBAMA8GA1UdEwEB/wQFMAMBAf8w\n' +
        'HQYDVR0OBBYEFIkXqTnllT/VJnI2NqipA4XV8rh1MA4GA1UdDwEB/wQEAwIBhjAN\n' +
        'BgkqhkiG9w0BAQwFAAOCAgEAKjSle8eenGeHgT8pltWCw/HzWyQruVKhfYIBfKJd\n' +
        'MhV4EnH5BK7LxBIvpXGsFUrb0ThzSw0fn0zoA9jBs3i/Sj6KyeZ9qUF6b8ycDXd+\n' +
        'wHonmJiQ7nk7UuMefaYAfs06vosgl1rI7eBHC0itexIQmKh0aX+821l4GEgEoSMf\n' +
        'loMFTLXv2w36fPHHCsZ67ODldgcZbKNnpCTX0YrCwEYO3Pz/L398btiRcWGrewrK\n' +
        'jdxAAyietra8DRno1Zl87685tfqc6HsL9v8rVw58clAo9XAQvT+fmSOFw/PogRZ7\n' +
        'OMHUat3gu/uQ1M5S64nkLLFsKu7jzudBuoNmcJysPlzIbqJ7vYc82OUGe9ucF3wi\n' +
        '3tbKQ983hdJiTExVRBLX/fYjPsGbG3JtPTv89eg2tjWHlPhCDMMxyRKl6isu2RTq\n' +
        '6VT489Z2zQrC33MYF8ZqO1NKjtyMAMIZwxVu4cGLkVsqFmEV2ScDHa5RadDyD3Ok\n' +
        'm+mqybhvEVm5tPgY6p0ILPMN3yvJsMSPSvuBXhO/X5ppNnpw9gnxpwbjQKNhkFaG\n' +
        'M5pkADZ14uRguOLM4VthSwUSEAr5VQYCFZhEwK+UOyJAGiB/nJz6IxL5XBNUXmRM\n' +
        'Hl8Xvz4riq48LMQbjcVQj0XvH941yPh+P8xOi00SGaQRaWp55Vyr4YKGbV0mEDz1\n' +
        'r1o=\n' +
        '-----END CERTIFICATE-----\n',
    '-----BEGIN CERTIFICATE-----\n' +
        'MIIF/zCCA+egAwIBAgIRAKwYju1QWxUZpn6D1gOtwgQwDQYJKoZIhvcNAQEMBQAw\n' +
        'gZcxCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJ\n' +
        'bmMuMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTEwMC4GA1UEAwwn\n' +
        'QW1hem9uIFJEUyBldS13ZXN0LTEgUm9vdCBDQSBSU0E0MDk2IEcxMRAwDgYDVQQH\n' +
        'DAdTZWF0dGxlMCAXDTIxMDUyMDE2NTM1NFoYDzIxMjEwNTIwMTc1MzU0WjCBlzEL\n' +
        'MAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4x\n' +
        'EzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTAwLgYDVQQDDCdBbWF6\n' +
        'b24gUkRTIGV1LXdlc3QtMSBSb290IENBIFJTQTQwOTYgRzExEDAOBgNVBAcMB1Nl\n' +
        'YXR0bGUwggIiMA0GCSqGSIb3DQEBAQUAA4ICDwAwggIKAoICAQCKdBP1U4lqWWkc\n' +
        'Cb25/BKRTsvNVnISiKocva8GAzJyKfcGRa85gmgu41U+Hz6+39K+XkRfM0YS4BvQ\n' +
        'F1XxWT0bNyypuvwCvmYShSTjN1TY0ltncDddahTajE/4MdSOZb/c98u0yt03cH+G\n' +
        'hVwRyT50h0v/UEol50VfwcVAEZEgcQQYhf1IFUFlIvKpmDOqLuFakOnc7c9akK+i\n' +
        'ivST+JO1tgowbnNkn2iLlSSgUWgb1gjaOsNfysagv1RXdlyPw3EyfwkFifAQvF2P\n' +
        'Q0ayYZfYS640cccv7efM1MSVyFHR9PrrDsF/zr2S2sGPbeHr7R/HwLl+S5J/l9N9\n' +
        'y0rk6IHAWV4dEkOvgpnuJKURwA48iu1Hhi9e4moNS6eqoK2KmY3VFpuiyWcA73nH\n' +
        'GSmyaH+YuMrF7Fnuu7GEHZL/o6+F5cL3mj2SJJhL7sz0ryf5Cs5R4yN9BIEj/f49\n' +
        'wh84pM6nexoI0Q4wiSFCxWiBpjSmOK6h7z6+2utaB5p20XDZHhxAlmlx4vMuWtjh\n' +
        'XckgRFxc+ZpVMU3cAHUpVEoO49e/+qKEpPzp8Xg4cToKw2+AfTk3cmyyXQfGwXMQ\n' +
        'ZUHNZ3w9ILMWihGCM2aGUsLcGDRennvNmnmin/SENsOQ8Ku0/a3teEzwV9cmmdYz\n' +
        '5iYs1YtgPvKFobY6+T2RXXh+A5kprwIDAQABo0IwQDAPBgNVHRMBAf8EBTADAQH/\n' +
        'MB0GA1UdDgQWBBSyUrsQVnKmA8z6/2Ech0rCvqpNmTAOBgNVHQ8BAf8EBAMCAYYw\n' +
        'DQYJKoZIhvcNAQEMBQADggIBAFlj3IFmgiFz5lvTzFTRizhVofhTJsGr14Yfkuc7\n' +
        'UrXPuXOwJomd4uot2d/VIeGJpfnuS84qGdmQyGewGTJ9inatHsGZgHl9NHNWRwKZ\n' +
        'lTKTbBiq7aqgtUSFa06v202wpzU+1kadxJJePrbABxiXVfOmIW/a1a4hPNcT3syH\n' +
        'FIEg1+CGsp71UNjBuwg3JTKWna0sLSKcxLOSOvX1fzxK5djzVpEsvQMB4PSAzXca\n' +
        'vENgg2ErTwgTA+4s6rRtiBF9pAusN1QVuBahYP3ftrY6f3ycS4K65GnqscyfvKt5\n' +
        'YgjtEKO3ZeeX8NpubMbzC+0Z6tVKfPFk/9TXuJtwvVeqow0YMrLLyRiYvK7EzJ97\n' +
        'rrkxoKnHYQSZ+rH2tZ5SE392/rfk1PJL0cdHnkpDkUDO+8cKsFjjYKAQSNC52sKX\n' +
        '74AVh6wMwxYwVZZJf2/2XxkjMWWhKNejsZhUkTISSmiLs+qPe3L67IM7GyKm9/m6\n' +
        'R3r8x6NGjhTsKH64iYJg7AeKeax4b2e4hBb6GXFftyOs7unpEOIVkJJgM6gh3mwn\n' +
        'R7v4gwFbLKADKt1vHuerSZMiTuNTGhSfCeDM53XI/mjZl2HeuCKP1mCDLlaO+gZR\n' +
        'Q/G+E0sBKgEX4xTkAc3kgkuQGfExdGtnN2U2ehF80lBHB8+2y2E+xWWXih/ZyIcW\n' +
        'wOx+\n' +
        '-----END CERTIFICATE-----\n',
    '-----BEGIN CERTIFICATE-----\n' +
        'MIIGBDCCA+ygAwIBAgIQM4C8g5iFRucSWdC8EdqHeDANBgkqhkiG9w0BAQwFADCB\n' +
        'mjELMAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIElu\n' +
        'Yy4xEzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTMwMQYDVQQDDCpB\n' +
        'bWF6b24gUkRTIGV1LWNlbnRyYWwtMSBSb290IENBIFJTQTQwOTYgRzExEDAOBgNV\n' +
        'BAcMB1NlYXR0bGUwIBcNMjEwNTIxMjIyODI2WhgPMjEyMTA1MjEyMzI4MjZaMIGa\n' +
        'MQswCQYDVQQGEwJVUzEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywgSW5j\n' +
        'LjETMBEGA1UECwwKQW1hem9uIFJEUzELMAkGA1UECAwCV0ExMzAxBgNVBAMMKkFt\n' +
        'YXpvbiBSRFMgZXUtY2VudHJhbC0xIFJvb3QgQ0EgUlNBNDA5NiBHMTEQMA4GA1UE\n' +
        'BwwHU2VhdHRsZTCCAiIwDQYJKoZIhvcNAQEBBQADggIPADCCAgoCggIBANeTsD/u\n' +
        '6saPiY4Sg0GlJlMXMBltnrcGAEkwq34OKQ0bCXqcoNJ2rcAMmuFC5x9Ho1Y3YzB7\n' +
        'NO2GpIh6bZaO76GzSv4cnimcv9n/sQSYXsGbPD+bAtnN/RvNW1avt4C0q0/ghgF1\n' +
        'VFS8JihIrgPYIArAmDtGNEdl5PUrdi9y6QGggbRfidMDdxlRdZBe1C18ZdgERSEv\n' +
        'UgSTPRlVczONG5qcQkUGCH83MMqL5MKQiby/Br5ZyPq6rxQMwRnQ7tROuElzyYzL\n' +
        '7d6kke+PNzG1mYy4cbYdjebwANCtZ2qYRSUHAQsOgybRcSoarv2xqcjO9cEsDiRU\n' +
        'l97ToadGYa4VVERuTaNZxQwrld4mvzpyKuirqZltOqg0eoy8VUsaRPL3dc5aChR0\n' +
        'dSrBgRYmSAClcR2/2ZCWpXemikwgt031Dsc0A/+TmVurrsqszwbr0e5xqMow9LzO\n' +
        'MI/JtLd0VFtoOkL/7GG2tN8a+7gnLFxpv+AQ0DH5n4k/BY/IyS+H1erqSJhOTQ11\n' +
        'vDOFTM5YplB9hWV9fp5PRs54ILlHTlZLpWGs3I2BrJwzRtg/rOlvsosqcge9ryai\n' +
        'AKm2j+JBg5wJ19R8oxRy8cfrNTftZePpISaLTyV2B16w/GsSjqixjTQe9LRN2DHk\n' +
        'cC+HPqYyzW2a3pUVyTGHhW6a7YsPBs9yzt6hAgMBAAGjQjBAMA8GA1UdEwEB/wQF\n' +
        'MAMBAf8wHQYDVR0OBBYEFIqA8QkOs2cSirOpCuKuOh9VDfJfMA4GA1UdDwEB/wQE\n' +
        'AwIBhjANBgkqhkiG9w0BAQwFAAOCAgEAOUI90mEIsa+vNJku0iUwdBMnHiO4gm7E\n' +
        '5JloP7JG0xUr7d0hypDorMM3zVDAL+aZRHsq8n934Cywj7qEp1304UF6538ByGdz\n' +
        'tkfacJsUSYfdlNJE9KbA4T+U+7SNhj9jvePpVjdQbhgzxITE9f8CxY/eM40yluJJ\n' +
        'PhbaWvOiRagzo74wttlcDerzLT6Y/JrVpWhnB7IY8HvzK+BwAdaCsBUPC3HF+kth\n' +
        'CIqLq7J3YArTToejWZAp5OOI6DLPM1MEudyoejL02w0jq0CChmZ5i55ElEMnapRX\n' +
        '7GQTARHmjgAOqa95FjbHEZzRPqZ72AtZAWKFcYFNk+grXSeWiDgPFOsq6mDg8DDB\n' +
        '0kfbYwKLFFCC9YFmYzR2YrWw2NxAScccUc2chOWAoSNHiqBbHR8ofrlJSWrtmKqd\n' +
        'YRCXzn8wqXnTS3NNHNccqJ6dN+iMr9NGnytw8zwwSchiev53Fpc1mGrJ7BKTWH0t\n' +
        'ZrA6m32wzpMymtKozlOPYoE5mtZEzrzHEXfa44Rns7XIHxVQSXVWyBHLtIsZOrvW\n' +
        'U5F41rQaFEpEeUQ7sQvqUoISfTUVRNDn6GK6YaccEhCji14APLFIvhRQUDyYMIiM\n' +
        '4vll0F/xgVRHTgDVQ8b8sxdhSYlqB4Wc2Ym41YRz+X2yPqk3typEZBpc4P5Tt1/N\n' +
        '89cEIGdbjsA=\n' +
        '-----END CERTIFICATE-----\n',
    '-----BEGIN CERTIFICATE-----\n' +
        'MIIEADCCAuigAwIBAgIQYjbPSg4+RNRD3zNxO1fuKDANBgkqhkiG9w0BAQsFADCB\n' +
        'mDELMAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIElu\n' +
        'Yy4xEzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTEwLwYDVQQDDChB\n' +
        'bWF6b24gUkRTIGV1LW5vcnRoLTEgUm9vdCBDQSBSU0EyMDQ4IEcxMRAwDgYDVQQH\n' +
        'DAdTZWF0dGxlMCAXDTIxMDUyNDIwNTkyMVoYDzIwNjEwNTI0MjE1OTIxWjCBmDEL\n' +
        'MAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4x\n' +
        'EzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTEwLwYDVQQDDChBbWF6\n' +
        'b24gUkRTIGV1LW5vcnRoLTEgUm9vdCBDQSBSU0EyMDQ4IEcxMRAwDgYDVQQHDAdT\n' +
        'ZWF0dGxlMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA179eQHxcV0YL\n' +
        'XMkqEmhSBazHhnRVd8yICbMq82PitE3BZcnv1Z5Zs/oOgNmMkOKae4tCXO/41JCX\n' +
        'wAgbs/eWWi+nnCfpQ/FqbLPg0h3dqzAgeszQyNl9IzTzX4Nd7JFRBVJXPIIKzlRf\n' +
        '+GmFsAhi3rYgDgO27pz3ciahVSN+CuACIRYnA0K0s9lhYdddmrW/SYeWyoB7jPa2\n' +
        'LmWpAs7bDOgS4LlP2H3eFepBPgNufRytSQUVA8f58lsE5w25vNiUSnrdlvDrIU5n\n' +
        'Qwzc7NIZCx4qJpRbSKWrUtbyJriWfAkGU7i0IoainHLn0eHp9bWkwb9D+C/tMk1X\n' +
        'ERZw2PDGkwIDAQABo0IwQDAPBgNVHRMBAf8EBTADAQH/MB0GA1UdDgQWBBSFmR7s\n' +
        'dAblusFN+xhf1ae0KUqhWTAOBgNVHQ8BAf8EBAMCAYYwDQYJKoZIhvcNAQELBQAD\n' +
        'ggEBAHsXOpjPMyH9lDhPM61zYdja1ebcMVgfUvsDvt+w0xKMKPhBzYDMs/cFOi1N\n' +
        'Q8LV79VNNfI2NuvFmGygcvTIR+4h0pqqZ+wjWl3Kk5jVxCrbHg3RBX02QLumKd/i\n' +
        'kwGcEtTUvTssn3SM8bgM0/1BDXgImZPC567ciLvWDo0s/Fe9dJJC3E0G7d/4s09n\n' +
        'OMdextcxFuWBZrBm/KK3QF0ByA8MG3//VXaGO9OIeeOJCpWn1G1PjT1UklYhkg61\n' +
        'EbsTiZVA2DLd1BGzfU4o4M5mo68l0msse/ndR1nEY6IywwpgIFue7+rEleDh6b9d\n' +
        'PYkG1rHVw2I0XDG4o17aOn5E94I=\n' +
        '-----END CERTIFICATE-----\n',
    '-----BEGIN CERTIFICATE-----\n' +
        'MIIEADCCAuigAwIBAgIQC6W4HFghUkkgyQw14a6JljANBgkqhkiG9w0BAQsFADCB\n' +
        'mDELMAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIElu\n' +
        'Yy4xEzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTEwLwYDVQQDDChB\n' +
        'bWF6b24gUkRTIGV1LXNvdXRoLTIgUm9vdCBDQSBSU0EyMDQ4IEcxMRAwDgYDVQQH\n' +
        'DAdTZWF0dGxlMCAXDTIyMDUyMzE4MTYzMloYDzIwNjIwNTIzMTkxNjMyWjCBmDEL\n' +
        'MAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4x\n' +
        'EzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTEwLwYDVQQDDChBbWF6\n' +
        'b24gUkRTIGV1LXNvdXRoLTIgUm9vdCBDQSBSU0EyMDQ4IEcxMRAwDgYDVQQHDAdT\n' +
        'ZWF0dGxlMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAiM/t4FV2R9Nx\n' +
        'UQG203UY83jInTa/6TMq0SPyg617FqYZxvz2kkx09x3dmxepUg9ttGMlPgjsRZM5\n' +
        'LCFEi1FWk+hxHzt7vAdhHES5tdjwds3aIkgNEillmRDVrUsbrDwufLaa+MMDO2E1\n' +
        'wQ/JYFXw16WBCCi2g1EtyQ2Xp+tZDX5IWOTnvhZpW8vVDptZ2AcJ5rMhfOYO3OsK\n' +
        '5EF0GGA5ldzuezP+BkrBYGJ4wVKGxeaq9+5AT8iVZrypjwRkD7Y5CurywK3+aBwm\n' +
        's9Q5Nd8t45JCOUzYp92rFKsCriD86n/JnEvgDfdP6Hvtm0/DkwXK40Wz2q0Zrd0k\n' +
        'mjP054NRPwIDAQABo0IwQDAPBgNVHRMBAf8EBTADAQH/MB0GA1UdDgQWBBRR7yqd\n' +
        'SfKcX2Q8GzhcVucReIpewTAOBgNVHQ8BAf8EBAMCAYYwDQYJKoZIhvcNAQELBQAD\n' +
        'ggEBAEszBRDwXcZyNm07VcFwI1Im94oKwKccuKYeJEsizTBsVon8VpEiMwDs+yGu\n' +
        '3p8kBhvkLwWybkD/vv6McH7T5b9jDX2DoOudqYnnaYeypsPH/00Vh3LvKagqzQza\n' +
        'orWLx+0tLo8xW4BtU+Wrn3JId8LvAhxyYXTn9bm+EwPcStp8xGLwu53OPD1RXYuy\n' +
        'uu+3ps/2piP7GVfou7H6PRaqbFHNfiGg6Y+WA0HGHiJzn8uLmrRJ5YRdIOOG9/xi\n' +
        'qTmAZloUNM7VNuurcMM2hWF494tQpsQ6ysg2qPjbBqzlGoOt3GfBTOZmqmwmqtam\n' +
        'K7juWM/mdMQAJ3SMlE5wI8nVdx4=\n' +
        '-----END CERTIFICATE-----\n',
    '-----BEGIN CERTIFICATE-----\n' +
        'MIICrjCCAjSgAwIBAgIRAL9SdzVPcpq7GOpvdGoM80IwCgYIKoZIzj0EAwMwgZYx\n' +
        'CzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMu\n' +
        'MRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTEvMC0GA1UEAwwmQW1h\n' +
        'em9uIFJEUyBldS13ZXN0LTEgUm9vdCBDQSBFQ0MzODQgRzExEDAOBgNVBAcMB1Nl\n' +
        'YXR0bGUwIBcNMjEwNTIwMTY1ODA3WhgPMjEyMTA1MjAxNzU4MDdaMIGWMQswCQYD\n' +
        'VQQGEwJVUzEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywgSW5jLjETMBEG\n' +
        'A1UECwwKQW1hem9uIFJEUzELMAkGA1UECAwCV0ExLzAtBgNVBAMMJkFtYXpvbiBS\n' +
        'RFMgZXUtd2VzdC0xIFJvb3QgQ0EgRUNDMzg0IEcxMRAwDgYDVQQHDAdTZWF0dGxl\n' +
        'MHYwEAYHKoZIzj0CAQYFK4EEACIDYgAEJWDgXebvwjR+Ce+hxKOLbnsfN5W5dOlP\n' +
        'Zn8kwWnD+SLkU81Eac/BDJsXGrMk6jFD1vg16PEkoSevsuYWlC8xR6FmT6F6pmeh\n' +
        'fsMGOyJpfK4fyoEPhKeQoT23lFIc5Orjo0IwQDAPBgNVHRMBAf8EBTADAQH/MB0G\n' +
        'A1UdDgQWBBSVNAN1CHAz0eZ77qz2adeqjm31TzAOBgNVHQ8BAf8EBAMCAYYwCgYI\n' +
        'KoZIzj0EAwMDaAAwZQIxAMlQeHbcjor49jqmcJ9gRLWdEWpXG8thIf6zfYQ/OEAg\n' +
        'd7GDh4fR/OUk0VfjsBUN/gIwZB0bGdXvK38s6AAE/9IT051cz/wMe9GIrX1MnL1T\n' +
        '1F5OqnXJdiwfZRRTHsRQ/L00\n' +
        '-----END CERTIFICATE-----\n',
    '-----BEGIN CERTIFICATE-----\n' +
        'MIIGBDCCA+ygAwIBAgIQalr16vDfX4Rsr+gfQ4iVFDANBgkqhkiG9w0BAQwFADCB\n' +
        'mjELMAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIElu\n' +
        'Yy4xEzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTMwMQYDVQQDDCpB\n' +
        'bWF6b24gUkRTIGV1LWNlbnRyYWwtMiBSb290IENBIFJTQTQwOTYgRzExEDAOBgNV\n' +
        'BAcMB1NlYXR0bGUwIBcNMjIwNjA2MjEyNTIzWhgPMjEyMjA2MDYyMjI1MjNaMIGa\n' +
        'MQswCQYDVQQGEwJVUzEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywgSW5j\n' +
        'LjETMBEGA1UECwwKQW1hem9uIFJEUzELMAkGA1UECAwCV0ExMzAxBgNVBAMMKkFt\n' +
        'YXpvbiBSRFMgZXUtY2VudHJhbC0yIFJvb3QgQ0EgUlNBNDA5NiBHMTEQMA4GA1UE\n' +
        'BwwHU2VhdHRsZTCCAiIwDQYJKoZIhvcNAQEBBQADggIPADCCAgoCggIBANbHbFg7\n' +
        '2VhZor1YNtez0VlNFaobS3PwOMcEn45BE3y7HONnElIIWXGQa0811M8V2FnyqnE8\n' +
        'Z5aO1EuvijvWf/3D8DPZkdmAkIfh5hlZYY6Aatr65kEOckwIAm7ZZzrwFogYuaFC\n' +
        'z/q0CW+8gxNK+98H/zeFx+IxiVoPPPX6UlrLvn+R6XYNERyHMLNgoZbbS5gGHk43\n' +
        'KhENVv3AWCCcCc85O4rVd+DGb2vMVt6IzXdTQt6Kih28+RGph+WDwYmf+3txTYr8\n' +
        'xMcCBt1+whyCPlMbC+Yn/ivtCO4LRf0MPZDRQrqTTrFf0h/V0BGEUmMGwuKgmzf5\n' +
        'Kl9ILdWv6S956ioZin2WgAxhcn7+z//sN++zkqLreSf90Vgv+A7xPRqIpTdJ/nWG\n' +
        'JaAOUofBfsDsk4X4SUFE7xJa1FZAiu2lqB/E+y7jnWOvFRalzxVJ2Y+D/ZfUfrnK\n' +
        '4pfKtyD1C6ni1celrZrAwLrJ3PoXPSg4aJKh8+CHex477SRsGj8KP19FG8r0P5AG\n' +
        '8lS1V+enFCNvT5KqEBpDZ/Y5SQAhAYFUX+zH4/n4ql0l/emS+x23kSRrF+yMkB9q\n' +
        'lhC/fMk6Pi3tICBjrDQ8XAxv56hfud9w6+/ljYB2uQ1iUYtlE3JdIiuE+3ws26O8\n' +
        'i7PLMD9zQmo+sVi12pLHfBHQ6RRHtdVRXbXRAgMBAAGjQjBAMA8GA1UdEwEB/wQF\n' +
        'MAMBAf8wHQYDVR0OBBYEFBFot08ipEL9ZUXCG4lagmF53C0/MA4GA1UdDwEB/wQE\n' +
        'AwIBhjANBgkqhkiG9w0BAQwFAAOCAgEAi2mcZi6cpaeqJ10xzMY0F3L2eOKYnlEQ\n' +
        'h6QyhmNKCUF05q5u+cok5KtznzqMwy7TFOZtbVHl8uUX+xvgq/MQCxqFAnuStBXm\n' +
        'gr2dg1h509ZwvTdk7TDxGdftvPCfnPNJBFbMSq4CZtNcOFBg9Rj8c3Yj+Qvwd56V\n' +
        'zWs65BUkDNJrXmxdvhJZjUkMa9vi/oFN+M84xXeZTaC5YDYNZZeW9706QqDbAVES\n' +
        '5ulvKLavB8waLI/lhRBK5/k0YykCMl0A8Togt8D1QsQ0eWWbIM8/HYJMPVFhJ8Wj\n' +
        'vT1p/YVeDA3Bo1iKDOttgC5vILf5Rw1ZEeDxjf/r8A7VS13D3OLjBmc31zxRTs3n\n' +
        'XvHKP9MieQHn9GE44tEYPjK3/yC6BDFzCBlvccYHmqGb+jvDEXEBXKzimdC9mcDl\n' +
        'f4BBQWGJBH5jkbU9p6iti19L/zHhz7qU6UJWbxY40w92L9jS9Utljh4A0LCTjlnR\n' +
        'NQUgjnGC6K+jkw8hj0LTC5Ip87oqoT9w7Av5EJ3VJ4hcnmNMXJJ1DkWYdnytcGpO\n' +
        'DMVITQzzDZRwhbitCVPHagTN2wdi9TEuYE33J0VmFeTc6FSI50wP2aOAZ0Q1/8Aj\n' +
        'bxeM5jS25eaHc2CQAuhrc/7GLnxOcPwdWQb2XWT8eHudhMnoRikVv/KSK3mf6om4\n' +
        '1YfpdH2jp30=\n' +
        '-----END CERTIFICATE-----\n',
    '-----BEGIN CERTIFICATE-----\n' +
        'MIID/jCCAuagAwIBAgIQTDc+UgTRtYO7ZGTQ8UWKDDANBgkqhkiG9w0BAQsFADCB\n' +
        'lzELMAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIElu\n' +
        'Yy4xEzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTAwLgYDVQQDDCdB\n' +
        'bWF6b24gUkRTIGV1LXdlc3QtMiBSb290IENBIFJTQTIwNDggRzExEDAOBgNVBAcM\n' +
        'B1NlYXR0bGUwIBcNMjEwNTIxMjI0NjI0WhgPMjA2MTA1MjEyMzQ2MjRaMIGXMQsw\n' +
        'CQYDVQQGEwJVUzEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywgSW5jLjET\n' +
        'MBEGA1UECwwKQW1hem9uIFJEUzELMAkGA1UECAwCV0ExMDAuBgNVBAMMJ0FtYXpv\n' +
        'biBSRFMgZXUtd2VzdC0yIFJvb3QgQ0EgUlNBMjA0OCBHMTEQMA4GA1UEBwwHU2Vh\n' +
        'dHRsZTCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBAM1oGtthQ1YiVIC2\n' +
        'i4u4swMAGxAjc/BZp0yq0eP5ZQFaxnxs7zFAPabEWsrjeDzrRhdVO0h7zskrertP\n' +
        'gblGhfD20JfjvCHdP1RUhy/nzG+T+hn6Takan/GIgs8grlBMRHMgBYHW7tklhjaH\n' +
        '3F7LujhceAHhhgp6IOrpb6YTaTTaJbF3GTmkqxSJ3l1LtEoWz8Al/nL/Ftzxrtez\n' +
        'Vs6ebpvd7sw37sxmXBWX2OlvUrPCTmladw9OrllGXtCFw4YyLe3zozBlZ3cHzQ0q\n' +
        'lINhpRcajTMfZrsiGCkQtoJT+AqVJPS2sHjqsEH8yiySW9Jbq4zyMbM1yqQ2vnnx\n' +
        'MJgoYMcCAwEAAaNCMEAwDwYDVR0TAQH/BAUwAwEB/zAdBgNVHQ4EFgQUaQG88UnV\n' +
        'JPTI+Pcti1P+q3H7pGYwDgYDVR0PAQH/BAQDAgGGMA0GCSqGSIb3DQEBCwUAA4IB\n' +
        'AQBAkgr75V0sEJimC6QRiTVWEuj2Khy7unjSfudbM6zumhXEU2/sUaVLiYy6cA/x\n' +
        '3v0laDle6T07x9g64j5YastE/4jbzrGgIINFlY0JnaYmR3KZEjgi1s1fkRRf3llL\n' +
        'PJm9u4Q1mbwAMQK/ZjLuuRcL3uRIHJek18nRqT5h43GB26qXyvJqeYYpYfIjL9+/\n' +
        'YiZAbSRRZG+Li23cmPWrbA1CJY121SB+WybCbysbOXzhD3Sl2KSZRwSw4p2HrFtV\n' +
        '1Prk0dOBtZxCG9luf87ultuDZpfS0w6oNBAMXocgswk24ylcADkkFxBWW+7BETn1\n' +
        'EpK+t1Lm37mU4sxtuha00XAi\n' +
        '-----END CERTIFICATE-----\n',
    '-----BEGIN CERTIFICATE-----\n' +
        'MIIEADCCAuigAwIBAgIQcY44/8NUvBwr6LlHfRy7KjANBgkqhkiG9w0BAQsFADCB\n' +
        'mDELMAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIElu\n' +
        'Yy4xEzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTEwLwYDVQQDDChB\n' +
        'bWF6b24gUkRTIGV1LXNvdXRoLTEgUm9vdCBDQSBSU0EyMDQ4IEcxMRAwDgYDVQQH\n' +
        'DAdTZWF0dGxlMCAXDTIxMDUxOTE4MjcxOFoYDzIwNjEwNTE5MTkyNzE4WjCBmDEL\n' +
        'MAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4x\n' +
        'EzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTEwLwYDVQQDDChBbWF6\n' +
        'b24gUkRTIGV1LXNvdXRoLTEgUm9vdCBDQSBSU0EyMDQ4IEcxMRAwDgYDVQQHDAdT\n' +
        'ZWF0dGxlMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA0UaBeC+Usalu\n' +
        'EtXnV7+PnH+gi7/71tI/jkKVGKuhD2JDVvqLVoqbMHRh3+wGMvqKCjbHPcC2XMWv\n' +
        '566fpAj4UZ9CLB5fVzss+QVNTl+FH2XhEzigopp+872ajsNzcZxrMkifxGb4i0U+\n' +
        't0Zi+UrbL5tsfP2JonKR1crOrbS6/DlzHBjIiJazGOQcMsJjNuTOItLbMohLpraA\n' +
        '/nApa3kOvI7Ufool1/34MG0+wL3UUA4YkZ6oBJVxjZvvs6tI7Lzz/SnhK2widGdc\n' +
        'snbLqBpHNIZQSorVoiwcFaRBGYX/uzYkiw44Yfa4cK2V/B5zgu1Fbr0gbI2am4eh\n' +
        'yVYyg4jPawIDAQABo0IwQDAPBgNVHRMBAf8EBTADAQH/MB0GA1UdDgQWBBS9gM1m\n' +
        'IIjyh9O5H/7Vj0R/akI7UzAOBgNVHQ8BAf8EBAMCAYYwDQYJKoZIhvcNAQELBQAD\n' +
        'ggEBAF0Sm9HC2AUyedBVnwgkVXMibnYChOzz7T+0Y+fOLXYAEXex2s8oqGeZdGYX\n' +
        'JHkjBn7JXu7LM+TpTbPbFFDoc1sgMguD/ls+8XsqAl1CssW+amryIL+jfcfbgQ+P\n' +
        'ICwEUD9hGdjBgJ5WcuS+qqxHsEIlFNci3HxcxfBa9VsWs5TjI7Vsl4meL5lf7ZyL\n' +
        'wDV7dHRuU+cImqG1MIvPRIlvPnT7EghrCYi2VCPhP2pM/UvShuwVnkz4MJ29ebIk\n' +
        'WR9kpblFxFdE92D5UUvMCjC2kmtgzNiErvTcwIvOO9YCbBHzRB1fFiWrXUHhJWq9\n' +
        'IkaxR5icb/IpAV0A1lYZEWMVsfQ=\n' +
        '-----END CERTIFICATE-----\n',
    '-----BEGIN CERTIFICATE-----\n' +
        'MIIGATCCA+mgAwIBAgIRAMa0TPL+QgbWfUPpYXQkf8wwDQYJKoZIhvcNAQEMBQAw\n' +
        'gZgxCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJ\n' +
        'bmMuMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTExMC8GA1UEAwwo\n' +
        'QW1hem9uIFJEUyBldS1ub3J0aC0xIFJvb3QgQ0EgUlNBNDA5NiBHMTEQMA4GA1UE\n' +
        'BwwHU2VhdHRsZTAgFw0yMTA1MjQyMTAzMjBaGA8yMTIxMDUyNDIyMDMyMFowgZgx\n' +
        'CzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMu\n' +
        'MRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTExMC8GA1UEAwwoQW1h\n' +
        'em9uIFJEUyBldS1ub3J0aC0xIFJvb3QgQ0EgUlNBNDA5NiBHMTEQMA4GA1UEBwwH\n' +
        'U2VhdHRsZTCCAiIwDQYJKoZIhvcNAQEBBQADggIPADCCAgoCggIBANhS9LJVJyWp\n' +
        '6Rudy9t47y6kzvgnFYDrvJVtgEK0vFn5ifdlHE7xqMz4LZqWBFTnS+3oidwVRqo7\n' +
        'tqsuuElsouStO8m315/YUzKZEPmkw8h5ufWt/lg3NTCoUZNkB4p4skr7TspyMUwE\n' +
        'VdlKQuWTCOLtofwmWT+BnFF3To6xTh3XPlT3ssancw27Gob8kJegD7E0TSMVsecP\n' +
        'B8je65+3b8CGwcD3QB3kCTGLy87tXuS2+07pncHvjMRMBdDQQQqhXWsRSeUNg0IP\n' +
        'xdHTWcuwMldYPWK5zus9M4dCNBDlmZjKdcZZVUOKeBBAm7Uo7CbJCk8r/Fvfr6mw\n' +
        'nXXDtuWhqn/WhJiI/y0QU27M+Hy5CQMxBwFsfAjJkByBpdXmyYxUgTmMpLf43p7H\n' +
        'oWfH1xN0cT0OQEVmAQjMakauow4AQLNkilV+X6uAAu3STQVFRSrpvMen9Xx3EPC3\n' +
        'G9flHueTa71bU65Xe8ZmEmFhGeFYHY0GrNPAFhq9RThPRY0IPyCZe0Th8uGejkek\n' +
        'jQjm0FHPOqs5jc8CD8eJs4jSEFt9lasFLVDcAhx0FkacLKQjGHvKAnnbRwhN/dF3\n' +
        'xt4oL8Z4JGPCLau056gKnYaEyviN7PgO+IFIVOVIdKEBu2ASGE8/+QJB5bcHefNj\n' +
        '04hEkDW0UYJbSfPpVbGAR0gFI/QpycKnAgMBAAGjQjBAMA8GA1UdEwEB/wQFMAMB\n' +
        'Af8wHQYDVR0OBBYEFFMXvvjoaGGUcul8GA3FT05DLbZcMA4GA1UdDwEB/wQEAwIB\n' +
        'hjANBgkqhkiG9w0BAQwFAAOCAgEAQLwFhd2JKn4K/6salLyIA4mP58qbA/9BTB/r\n' +
        'D9l0bEwDlVPSdY7R3gZCe6v7SWLfA9RjE5tdWDrQMi5IU6W2OVrVsZS/yGJfwnwe\n' +
        'a/9iUAYprA5QYKDg37h12XhVsDKlYCekHdC+qa5WwB1SL3YUprDLPWeaIQdg+Uh2\n' +
        '+LxvpZGoxoEbca0fc7flwq9ke/3sXt/3V4wJDyY6AL2YNdjFzC+FtYjHHx8rYxHs\n' +
        'aesP7yunuN17KcfOZBBnSFRrx96k+Xm95VReTEEpwiBqAECqEpMbd+R0mFAayMb1\n' +
        'cE77GaK5yeC2f67NLYGpkpIoPbO9p9rzoXLE5GpSizMjimnz6QCbXPFAFBDfSzim\n' +
        'u6azp40kEUO6kWd7rBhqRwLc43D3TtNWQYxMve5mTRG4Od+eMKwYZmQz89BQCeqm\n' +
        'aZiJP9y9uwJw4p/A5V3lYHTDQqzmbOyhGUk6OdpdE8HXs/1ep1xTT20QDYOx3Ekt\n' +
        'r4mmNYfH/8v9nHNRlYJOqFhmoh1i85IUl5IHhg6OT5ZTTwsGTSxvgQQXrmmHVrgZ\n' +
        'rZIqyBKllCgVeB9sMEsntn4bGLig7CS/N1y2mYdW/745yCLZv2gj0NXhPqgEIdVV\n' +
        'f9DhFD4ohE1C63XP0kOQee+LYg/MY5vH8swpCSWxQgX5icv5jVDz8YTdCKgUc5u8\n' +
        'rM2p0kk=\n' +
        '-----END CERTIFICATE-----\n',
];


/***/ }),

/***/ 48579:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.proxies = void 0;
/**
 * CA Certificates for **Amazon RDS Proxy** (2024)
 *
 * - https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/rds-proxy.howitworks.html#rds-proxy-security.tls
 * - https://www.amazontrust.com/repository/
 */
exports.proxies = [
    '-----BEGIN CERTIFICATE-----\n' +
        'MIIDQTCCAimgAwIBAgITBmyfz5m/jAo54vB4ikPmljZbyjANBgkqhkiG9w0BAQsF\n' +
        'ADA5MQswCQYDVQQGEwJVUzEPMA0GA1UEChMGQW1hem9uMRkwFwYDVQQDExBBbWF6\n' +
        'b24gUm9vdCBDQSAxMB4XDTE1MDUyNjAwMDAwMFoXDTM4MDExNzAwMDAwMFowOTEL\n' +
        'MAkGA1UEBhMCVVMxDzANBgNVBAoTBkFtYXpvbjEZMBcGA1UEAxMQQW1hem9uIFJv\n' +
        'b3QgQ0EgMTCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBALJ4gHHKeNXj\n' +
        'ca9HgFB0fW7Y14h29Jlo91ghYPl0hAEvrAIthtOgQ3pOsqTQNroBvo3bSMgHFzZM\n' +
        '9O6II8c+6zf1tRn4SWiw3te5djgdYZ6k/oI2peVKVuRF4fn9tBb6dNqcmzU5L/qw\n' +
        'IFAGbHrQgLKm+a/sRxmPUDgH3KKHOVj4utWp+UhnMJbulHheb4mjUcAwhmahRWa6\n' +
        'VOujw5H5SNz/0egwLX0tdHA114gk957EWW67c4cX8jJGKLhD+rcdqsq08p8kDi1L\n' +
        '93FcXmn/6pUCyziKrlA4b9v7LWIbxcceVOF34GfID5yHI9Y/QCB/IIDEgEw+OyQm\n' +
        'jgSubJrIqg0CAwEAAaNCMEAwDwYDVR0TAQH/BAUwAwEB/zAOBgNVHQ8BAf8EBAMC\n' +
        'AYYwHQYDVR0OBBYEFIQYzIU07LwMlJQuCFmcx7IQTgoIMA0GCSqGSIb3DQEBCwUA\n' +
        'A4IBAQCY8jdaQZChGsV2USggNiMOruYou6r4lK5IpDB/G/wkjUu0yKGX9rbxenDI\n' +
        'U5PMCCjjmCXPI6T53iHTfIUJrU6adTrCC2qJeHZERxhlbI1Bjjt/msv0tadQ1wUs\n' +
        'N+gDS63pYaACbvXy8MWy7Vu33PqUXHeeE6V/Uq2V8viTO96LXFvKWlJbYK8U90vv\n' +
        'o/ufQJVtMVT8QtPHRh8jrdkPSHCa2XV4cdFyQzR1bldZwgJcJmApzyMZFo6IQ6XU\n' +
        '5MsI+yMRQ+hDKXJioaldXgjUkK642M4UwtBV8ob2xJNDd2ZhwLnoQdeXeGADbkpy\n' +
        'rqXRfboQnoZsG4q5WTP468SQvvG5\n' +
        '-----END CERTIFICATE-----\n',
    '-----BEGIN CERTIFICATE-----\n' +
        'MIIFQTCCAymgAwIBAgITBmyf0pY1hp8KD+WGePhbJruKNzANBgkqhkiG9w0BAQwF\n' +
        'ADA5MQswCQYDVQQGEwJVUzEPMA0GA1UEChMGQW1hem9uMRkwFwYDVQQDExBBbWF6\n' +
        'b24gUm9vdCBDQSAyMB4XDTE1MDUyNjAwMDAwMFoXDTQwMDUyNjAwMDAwMFowOTEL\n' +
        'MAkGA1UEBhMCVVMxDzANBgNVBAoTBkFtYXpvbjEZMBcGA1UEAxMQQW1hem9uIFJv\n' +
        'b3QgQ0EgMjCCAiIwDQYJKoZIhvcNAQEBBQADggIPADCCAgoCggIBAK2Wny2cSkxK\n' +
        'gXlRmeyKy2tgURO8TW0G/LAIjd0ZEGrHJgw12MBvIITplLGbhQPDW9tK6Mj4kHbZ\n' +
        'W0/jTOgGNk3Mmqw9DJArktQGGWCsN0R5hYGCrVo34A3MnaZMUnbqQ523BNFQ9lXg\n' +
        '1dKmSYXpN+nKfq5clU1Imj+uIFptiJXZNLhSGkOQsL9sBbm2eLfq0OQ6PBJTYv9K\n' +
        '8nu+NQWpEjTj82R0Yiw9AElaKP4yRLuH3WUnAnE72kr3H9rN9yFVkE8P7K6C4Z9r\n' +
        '2UXTu/Bfh+08LDmG2j/e7HJV63mjrdvdfLC6HM783k81ds8P+HgfajZRRidhW+me\n' +
        'z/CiVX18JYpvL7TFz4QuK/0NURBs+18bvBt+xa47mAExkv8LV/SasrlX6avvDXbR\n' +
        '8O70zoan4G7ptGmh32n2M8ZpLpcTnqWHsFcQgTfJU7O7f/aS0ZzQGPSSbtqDT6Zj\n' +
        'mUyl+17vIWR6IF9sZIUVyzfpYgwLKhbcAS4y2j5L9Z469hdAlO+ekQiG+r5jqFoz\n' +
        '7Mt0Q5X5bGlSNscpb/xVA1wf+5+9R+vnSUeVC06JIglJ4PVhHvG/LopyboBZ/1c6\n' +
        '+XUyo05f7O0oYtlNc/LMgRdg7c3r3NunysV+Ar3yVAhU/bQtCSwXVEqY0VThUWcI\n' +
        '0u1ufm8/0i2BWSlmy5A5lREedCf+3euvAgMBAAGjQjBAMA8GA1UdEwEB/wQFMAMB\n' +
        'Af8wDgYDVR0PAQH/BAQDAgGGMB0GA1UdDgQWBBSwDPBMMPQFWAJI/TPlUq9LhONm\n' +
        'UjANBgkqhkiG9w0BAQwFAAOCAgEAqqiAjw54o+Ci1M3m9Zh6O+oAA7CXDpO8Wqj2\n' +
        'LIxyh6mx/H9z/WNxeKWHWc8w4Q0QshNabYL1auaAn6AFC2jkR2vHat+2/XcycuUY\n' +
        '+gn0oJMsXdKMdYV2ZZAMA3m3MSNjrXiDCYZohMr/+c8mmpJ5581LxedhpxfL86kS\n' +
        'k5Nrp+gvU5LEYFiwzAJRGFuFjWJZY7attN6a+yb3ACfAXVU3dJnJUH/jWS5E4ywl\n' +
        '7uxMMne0nxrpS10gxdr9HIcWxkPo1LsmmkVwXqkLN1PiRnsn/eBG8om3zEK2yygm\n' +
        'btmlyTrIQRNg91CMFa6ybRoVGld45pIq2WWQgj9sAq+uEjonljYE1x2igGOpm/Hl\n' +
        'urR8FLBOybEfdF849lHqm/osohHUqS0nGkWxr7JOcQ3AWEbWaQbLU8uz/mtBzUF+\n' +
        'fUwPfHJ5elnNXkoOrJupmHN5fLT0zLm4BwyydFy4x2+IoZCn9Kr5v2c69BoVYh63\n' +
        'n749sSmvZ6ES8lgQGVMDMBu4Gon2nL2XA46jCfMdiyHxtN/kHNGfZQIG6lzWE7OE\n' +
        '76KlXIx3KadowGuuQNKotOrN8I1LOJwZmhsoVLiJkO/KdYE+HvJkJMcYr07/R54H\n' +
        '9jVlpNMKVv/1F2Rs76giJUmTtt8AF9pYfl3uxRuw0dFfIRDH+fO6AgonB8Xx1sfT\n' +
        '4PsJYGw=\n' +
        '-----END CERTIFICATE-----\n',
    '-----BEGIN CERTIFICATE-----\n' +
        'MIIBtjCCAVugAwIBAgITBmyf1XSXNmY/Owua2eiedgPySjAKBggqhkjOPQQDAjA5\n' +
        'MQswCQYDVQQGEwJVUzEPMA0GA1UEChMGQW1hem9uMRkwFwYDVQQDExBBbWF6b24g\n' +
        'Um9vdCBDQSAzMB4XDTE1MDUyNjAwMDAwMFoXDTQwMDUyNjAwMDAwMFowOTELMAkG\n' +
        'A1UEBhMCVVMxDzANBgNVBAoTBkFtYXpvbjEZMBcGA1UEAxMQQW1hem9uIFJvb3Qg\n' +
        'Q0EgMzBZMBMGByqGSM49AgEGCCqGSM49AwEHA0IABCmXp8ZBf8ANm+gBG1bG8lKl\n' +
        'ui2yEujSLtf6ycXYqm0fc4E7O5hrOXwzpcVOho6AF2hiRVd9RFgdszflZwjrZt6j\n' +
        'QjBAMA8GA1UdEwEB/wQFMAMBAf8wDgYDVR0PAQH/BAQDAgGGMB0GA1UdDgQWBBSr\n' +
        'ttvXBp43rDCGB5Fwx5zEGbF4wDAKBggqhkjOPQQDAgNJADBGAiEA4IWSoxe3jfkr\n' +
        'BqWTrBqYaGFy+uGh0PsceGCmQ5nFuMQCIQCcAu/xlJyzlvnrxir4tiz+OpAUFteM\n' +
        'YyRIHN8wfdVoOw==\n' +
        '-----END CERTIFICATE-----\n',
    '-----BEGIN CERTIFICATE-----\n' +
        'MIIB8jCCAXigAwIBAgITBmyf18G7EEwpQ+Vxe3ssyBrBDjAKBggqhkjOPQQDAzA5\n' +
        'MQswCQYDVQQGEwJVUzEPMA0GA1UEChMGQW1hem9uMRkwFwYDVQQDExBBbWF6b24g\n' +
        'Um9vdCBDQSA0MB4XDTE1MDUyNjAwMDAwMFoXDTQwMDUyNjAwMDAwMFowOTELMAkG\n' +
        'A1UEBhMCVVMxDzANBgNVBAoTBkFtYXpvbjEZMBcGA1UEAxMQQW1hem9uIFJvb3Qg\n' +
        'Q0EgNDB2MBAGByqGSM49AgEGBSuBBAAiA2IABNKrijdPo1MN/sGKe0uoe0ZLY7Bi\n' +
        '9i0b2whxIdIA6GO9mif78DluXeo9pcmBqqNbIJhFXRbb/egQbeOc4OO9X4Ri83Bk\n' +
        'M6DLJC9wuoihKqB1+IGuYgbEgds5bimwHvouXKNCMEAwDwYDVR0TAQH/BAUwAwEB\n' +
        '/zAOBgNVHQ8BAf8EBAMCAYYwHQYDVR0OBBYEFNPsxzplbszh2naaVvuc84ZtV+WB\n' +
        'MAoGCCqGSM49BAMDA2gAMGUCMDqLIfG9fhGt0O9Yli/W651+kI0rz2ZVwyzjKKlw\n' +
        'CkcO8DdZEv8tmZQoTipPNU0zWgIxAOp1AE47xDqUEpHJWEadIRNyp4iciuRMStuW\n' +
        '1KyLa2tJElMzrdfkviT8tQp21KW8EA==\n' +
        '-----END CERTIFICATE-----\n',
    '-----BEGIN CERTIFICATE-----\n' +
        'MIID7zCCAtegAwIBAgIBADANBgkqhkiG9w0BAQsFADCBmDELMAkGA1UEBhMCVVMx\n' +
        'EDAOBgNVBAgTB0FyaXpvbmExEzARBgNVBAcTClNjb3R0c2RhbGUxJTAjBgNVBAoT\n' +
        'HFN0YXJmaWVsZCBUZWNobm9sb2dpZXMsIEluYy4xOzA5BgNVBAMTMlN0YXJmaWVs\n' +
        'ZCBTZXJ2aWNlcyBSb290IENlcnRpZmljYXRlIEF1dGhvcml0eSAtIEcyMB4XDTA5\n' +
        'MDkwMTAwMDAwMFoXDTM3MTIzMTIzNTk1OVowgZgxCzAJBgNVBAYTAlVTMRAwDgYD\n' +
        'VQQIEwdBcml6b25hMRMwEQYDVQQHEwpTY290dHNkYWxlMSUwIwYDVQQKExxTdGFy\n' +
        'ZmllbGQgVGVjaG5vbG9naWVzLCBJbmMuMTswOQYDVQQDEzJTdGFyZmllbGQgU2Vy\n' +
        'dmljZXMgUm9vdCBDZXJ0aWZpY2F0ZSBBdXRob3JpdHkgLSBHMjCCASIwDQYJKoZI\n' +
        'hvcNAQEBBQADggEPADCCAQoCggEBANUMOsQq+U7i9b4Zl1+OiFOxHz/Lz58gE20p\n' +
        'OsgPfTz3a3Y4Y9k2YKibXlwAgLIvWX/2h/klQ4bnaRtSmpDhcePYLQ1Ob/bISdm2\n' +
        '8xpWriu2dBTrz/sm4xq6HZYuajtYlIlHVv8loJNwU4PahHQUw2eeBGg6345AWh1K\n' +
        'Ts9DkTvnVtYAcMtS7nt9rjrnvDH5RfbCYM8TWQIrgMw0R9+53pBlbQLPLJGmpufe\n' +
        'hRhJfGZOozptqbXuNC66DQO4M99H67FrjSXZm86B0UVGMpZwh94CDklDhbZsc7tk\n' +
        '6mFBrMnUVN+HL8cisibMn1lUaJ/8viovxFUcdUBgF4UCVTmLfwUCAwEAAaNCMEAw\n' +
        'DwYDVR0TAQH/BAUwAwEB/zAOBgNVHQ8BAf8EBAMCAQYwHQYDVR0OBBYEFJxfAN+q\n' +
        'AdcwKziIorhtSpzyEZGDMA0GCSqGSIb3DQEBCwUAA4IBAQBLNqaEd2ndOxmfZyMI\n' +
        'bw5hyf2E3F/YNoHN2BtBLZ9g3ccaaNnRbobhiCPPE95Dz+I0swSdHynVv/heyNXB\n' +
        've6SbzJ08pGCL72CQnqtKrcgfU28elUSwhXqvfdqlS5sdJ/PHLTyxQGjhdByPq1z\n' +
        'qwubdQxtRbeOlKyWN7Wg0I8VRw7j6IPdj/3vQQF3zCepYoUz8jcI73HPdwbeyBkd\n' +
        'iEDPfUYd/x7H4c7/I9vG+o1VTqkC50cRRj70/b17KSa7qWFiNyi2LSr2EIZkyXCn\n' +
        '0q23KXB56jzaYyWf/Wi3MOxw+3WKt21gZ7IeyLnp2KhvAotnDU0mV3HaIPzBSlCN\n' +
        'sSi6\n' +
        '-----END CERTIFICATE-----\n',
];


/***/ }),

/***/ 73546:
/***/ (function(module, __unused_webpack_exports, __nccwpck_require__) {

/* module decorator */ module = __nccwpck_require__.nmd(module);
/*
 Copyright (c) 2012 Nevins Bartolomeo <nevins.bartolomeo@gmail.com>
 Copyright (c) 2012 Shane Girish <shaneGirish@gmail.com>
 Copyright (c) 2014 Daniel Wirtz <dcode@dcode.io>

 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions
 are met:
 1. Redistributions of source code must retain the above copyright
 notice, this list of conditions and the following disclaimer.
 2. Redistributions in binary form must reproduce the above copyright
 notice, this list of conditions and the following disclaimer in the
 documentation and/or other materials provided with the distribution.
 3. The name of the author may not be used to endorse or promote products
 derived from this software without specific prior written permission.

 THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/**
 * @license bcrypt.js (c) 2013 Daniel Wirtz <dcode@dcode.io>
 * Released under the Apache License, Version 2.0
 * see: https://github.com/dcodeIO/bcrypt.js for details
 */
(function(global, factory) {

    /* AMD */ if (typeof define === 'function' && define["amd"])
        define([], factory);
    /* CommonJS */ else if ( true && module && module["exports"])
        module["exports"] = factory();
    /* Global */ else
        (global["dcodeIO"] = global["dcodeIO"] || {})["bcrypt"] = factory();

}(this, function() {
    "use strict";

    /**
     * bcrypt namespace.
     * @type {Object.<string,*>}
     */
    var bcrypt = {};

    /**
     * The random implementation to use as a fallback.
     * @type {?function(number):!Array.<number>}
     * @inner
     */
    var randomFallback = null;

    /**
     * Generates cryptographically secure random bytes.
     * @function
     * @param {number} len Bytes length
     * @returns {!Array.<number>} Random bytes
     * @throws {Error} If no random implementation is available
     * @inner
     */
    function random(len) {
        /* node */ if ( true && module && module['exports'])
            try {
                return (__nccwpck_require__(76982).randomBytes)(len);
            } catch (e) {}
        /* WCA */ try {
            var a; (self['crypto']||self['msCrypto'])['getRandomValues'](a = new Uint32Array(len));
            return Array.prototype.slice.call(a);
        } catch (e) {}
        /* fallback */ if (!randomFallback)
            throw Error("Neither WebCryptoAPI nor a crypto module is available. Use bcrypt.setRandomFallback to set an alternative");
        return randomFallback(len);
    }

    // Test if any secure randomness source is available
    var randomAvailable = false;
    try {
        random(1);
        randomAvailable = true;
    } catch (e) {}

    // Default fallback, if any
    randomFallback = null;
    /**
     * Sets the pseudo random number generator to use as a fallback if neither node's `crypto` module nor the Web Crypto
     *  API is available. Please note: It is highly important that the PRNG used is cryptographically secure and that it
     *  is seeded properly!
     * @param {?function(number):!Array.<number>} random Function taking the number of bytes to generate as its
     *  sole argument, returning the corresponding array of cryptographically secure random byte values.
     * @see http://nodejs.org/api/crypto.html
     * @see http://www.w3.org/TR/WebCryptoAPI/
     */
    bcrypt.setRandomFallback = function(random) {
        randomFallback = random;
    };

    /**
     * Synchronously generates a salt.
     * @param {number=} rounds Number of rounds to use, defaults to 10 if omitted
     * @param {number=} seed_length Not supported.
     * @returns {string} Resulting salt
     * @throws {Error} If a random fallback is required but not set
     * @expose
     */
    bcrypt.genSaltSync = function(rounds, seed_length) {
        rounds = rounds || GENSALT_DEFAULT_LOG2_ROUNDS;
        if (typeof rounds !== 'number')
            throw Error("Illegal arguments: "+(typeof rounds)+", "+(typeof seed_length));
        if (rounds < 4)
            rounds = 4;
        else if (rounds > 31)
            rounds = 31;
        var salt = [];
        salt.push("$2a$");
        if (rounds < 10)
            salt.push("0");
        salt.push(rounds.toString());
        salt.push('$');
        salt.push(base64_encode(random(BCRYPT_SALT_LEN), BCRYPT_SALT_LEN)); // May throw
        return salt.join('');
    };

    /**
     * Asynchronously generates a salt.
     * @param {(number|function(Error, string=))=} rounds Number of rounds to use, defaults to 10 if omitted
     * @param {(number|function(Error, string=))=} seed_length Not supported.
     * @param {function(Error, string=)=} callback Callback receiving the error, if any, and the resulting salt
     * @returns {!Promise} If `callback` has been omitted
     * @throws {Error} If `callback` is present but not a function
     * @expose
     */
    bcrypt.genSalt = function(rounds, seed_length, callback) {
        if (typeof seed_length === 'function')
            callback = seed_length,
            seed_length = undefined; // Not supported.
        if (typeof rounds === 'function')
            callback = rounds,
            rounds = undefined;
        if (typeof rounds === 'undefined')
            rounds = GENSALT_DEFAULT_LOG2_ROUNDS;
        else if (typeof rounds !== 'number')
            throw Error("illegal arguments: "+(typeof rounds));

        function _async(callback) {
            nextTick(function() { // Pretty thin, but salting is fast enough
                try {
                    callback(null, bcrypt.genSaltSync(rounds));
                } catch (err) {
                    callback(err);
                }
            });
        }

        if (callback) {
            if (typeof callback !== 'function')
                throw Error("Illegal callback: "+typeof(callback));
            _async(callback);
        } else
            return new Promise(function(resolve, reject) {
                _async(function(err, res) {
                    if (err) {
                        reject(err);
                        return;
                    }
                    resolve(res);
                });
            });
    };

    /**
     * Synchronously generates a hash for the given string.
     * @param {string} s String to hash
     * @param {(number|string)=} salt Salt length to generate or salt to use, default to 10
     * @returns {string} Resulting hash
     * @expose
     */
    bcrypt.hashSync = function(s, salt) {
        if (typeof salt === 'undefined')
            salt = GENSALT_DEFAULT_LOG2_ROUNDS;
        if (typeof salt === 'number')
            salt = bcrypt.genSaltSync(salt);
        if (typeof s !== 'string' || typeof salt !== 'string')
            throw Error("Illegal arguments: "+(typeof s)+', '+(typeof salt));
        return _hash(s, salt);
    };

    /**
     * Asynchronously generates a hash for the given string.
     * @param {string} s String to hash
     * @param {number|string} salt Salt length to generate or salt to use
     * @param {function(Error, string=)=} callback Callback receiving the error, if any, and the resulting hash
     * @param {function(number)=} progressCallback Callback successively called with the percentage of rounds completed
     *  (0.0 - 1.0), maximally once per `MAX_EXECUTION_TIME = 100` ms.
     * @returns {!Promise} If `callback` has been omitted
     * @throws {Error} If `callback` is present but not a function
     * @expose
     */
    bcrypt.hash = function(s, salt, callback, progressCallback) {

        function _async(callback) {
            if (typeof s === 'string' && typeof salt === 'number')
                bcrypt.genSalt(salt, function(err, salt) {
                    _hash(s, salt, callback, progressCallback);
                });
            else if (typeof s === 'string' && typeof salt === 'string')
                _hash(s, salt, callback, progressCallback);
            else
                nextTick(callback.bind(this, Error("Illegal arguments: "+(typeof s)+', '+(typeof salt))));
        }

        if (callback) {
            if (typeof callback !== 'function')
                throw Error("Illegal callback: "+typeof(callback));
            _async(callback);
        } else
            return new Promise(function(resolve, reject) {
                _async(function(err, res) {
                    if (err) {
                        reject(err);
                        return;
                    }
                    resolve(res);
                });
            });
    };

    /**
     * Compares two strings of the same length in constant time.
     * @param {string} known Must be of the correct length
     * @param {string} unknown Must be the same length as `known`
     * @returns {boolean}
     * @inner
     */
    function safeStringCompare(known, unknown) {
        var right = 0,
            wrong = 0;
        for (var i=0, k=known.length; i<k; ++i) {
            if (known.charCodeAt(i) === unknown.charCodeAt(i))
                ++right;
            else
                ++wrong;
        }
        // Prevent removal of unused variables (never true, actually)
        if (right < 0)
            return false;
        return wrong === 0;
    }

    /**
     * Synchronously tests a string against a hash.
     * @param {string} s String to compare
     * @param {string} hash Hash to test against
     * @returns {boolean} true if matching, otherwise false
     * @throws {Error} If an argument is illegal
     * @expose
     */
    bcrypt.compareSync = function(s, hash) {
        if (typeof s !== "string" || typeof hash !== "string")
            throw Error("Illegal arguments: "+(typeof s)+', '+(typeof hash));
        if (hash.length !== 60)
            return false;
        return safeStringCompare(bcrypt.hashSync(s, hash.substr(0, hash.length-31)), hash);
    };

    /**
     * Asynchronously compares the given data against the given hash.
     * @param {string} s Data to compare
     * @param {string} hash Data to be compared to
     * @param {function(Error, boolean)=} callback Callback receiving the error, if any, otherwise the result
     * @param {function(number)=} progressCallback Callback successively called with the percentage of rounds completed
     *  (0.0 - 1.0), maximally once per `MAX_EXECUTION_TIME = 100` ms.
     * @returns {!Promise} If `callback` has been omitted
     * @throws {Error} If `callback` is present but not a function
     * @expose
     */
    bcrypt.compare = function(s, hash, callback, progressCallback) {

        function _async(callback) {
            if (typeof s !== "string" || typeof hash !== "string") {
                nextTick(callback.bind(this, Error("Illegal arguments: "+(typeof s)+', '+(typeof hash))));
                return;
            }
            if (hash.length !== 60) {
                nextTick(callback.bind(this, null, false));
                return;
            }
            bcrypt.hash(s, hash.substr(0, 29), function(err, comp) {
                if (err)
                    callback(err);
                else
                    callback(null, safeStringCompare(comp, hash));
            }, progressCallback);
        }

        if (callback) {
            if (typeof callback !== 'function')
                throw Error("Illegal callback: "+typeof(callback));
            _async(callback);
        } else
            return new Promise(function(resolve, reject) {
                _async(function(err, res) {
                    if (err) {
                        reject(err);
                        return;
                    }
                    resolve(res);
                });
            });
    };

    /**
     * Gets the number of rounds used to encrypt the specified hash.
     * @param {string} hash Hash to extract the used number of rounds from
     * @returns {number} Number of rounds used
     * @throws {Error} If `hash` is not a string
     * @expose
     */
    bcrypt.getRounds = function(hash) {
        if (typeof hash !== "string")
            throw Error("Illegal arguments: "+(typeof hash));
        return parseInt(hash.split("$")[2], 10);
    };

    /**
     * Gets the salt portion from a hash. Does not validate the hash.
     * @param {string} hash Hash to extract the salt from
     * @returns {string} Extracted salt part
     * @throws {Error} If `hash` is not a string or otherwise invalid
     * @expose
     */
    bcrypt.getSalt = function(hash) {
        if (typeof hash !== 'string')
            throw Error("Illegal arguments: "+(typeof hash));
        if (hash.length !== 60)
            throw Error("Illegal hash length: "+hash.length+" != 60");
        return hash.substring(0, 29);
    };

    /**
     * Continues with the callback on the next tick.
     * @function
     * @param {function(...[*])} callback Callback to execute
     * @inner
     */
    var nextTick = typeof process !== 'undefined' && process && typeof process.nextTick === 'function'
        ? (typeof setImmediate === 'function' ? setImmediate : process.nextTick)
        : setTimeout;

    /**
     * Converts a JavaScript string to UTF8 bytes.
     * @param {string} str String
     * @returns {!Array.<number>} UTF8 bytes
     * @inner
     */
    function stringToBytes(str) {
        var out = [],
            i = 0;
        utfx.encodeUTF16toUTF8(function() {
            if (i >= str.length) return null;
            return str.charCodeAt(i++);
        }, function(b) {
            out.push(b);
        });
        return out;
    }

    // A base64 implementation for the bcrypt algorithm. This is partly non-standard.

    /**
     * bcrypt's own non-standard base64 dictionary.
     * @type {!Array.<string>}
     * @const
     * @inner
     **/
    var BASE64_CODE = "./ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789".split('');

    /**
     * @type {!Array.<number>}
     * @const
     * @inner
     **/
    var BASE64_INDEX = [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0,
        1, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, -1, -1, -1, -1, -1, -1,
        -1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,
        20, 21, 22, 23, 24, 25, 26, 27, -1, -1, -1, -1, -1, -1, 28, 29, 30,
        31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,
        48, 49, 50, 51, 52, 53, -1, -1, -1, -1, -1];

    /**
     * @type {!function(...number):string}
     * @inner
     */
    var stringFromCharCode = String.fromCharCode;

    /**
     * Encodes a byte array to base64 with up to len bytes of input.
     * @param {!Array.<number>} b Byte array
     * @param {number} len Maximum input length
     * @returns {string}
     * @inner
     */
    function base64_encode(b, len) {
        var off = 0,
            rs = [],
            c1, c2;
        if (len <= 0 || len > b.length)
            throw Error("Illegal len: "+len);
        while (off < len) {
            c1 = b[off++] & 0xff;
            rs.push(BASE64_CODE[(c1 >> 2) & 0x3f]);
            c1 = (c1 & 0x03) << 4;
            if (off >= len) {
                rs.push(BASE64_CODE[c1 & 0x3f]);
                break;
            }
            c2 = b[off++] & 0xff;
            c1 |= (c2 >> 4) & 0x0f;
            rs.push(BASE64_CODE[c1 & 0x3f]);
            c1 = (c2 & 0x0f) << 2;
            if (off >= len) {
                rs.push(BASE64_CODE[c1 & 0x3f]);
                break;
            }
            c2 = b[off++] & 0xff;
            c1 |= (c2 >> 6) & 0x03;
            rs.push(BASE64_CODE[c1 & 0x3f]);
            rs.push(BASE64_CODE[c2 & 0x3f]);
        }
        return rs.join('');
    }

    /**
     * Decodes a base64 encoded string to up to len bytes of output.
     * @param {string} s String to decode
     * @param {number} len Maximum output length
     * @returns {!Array.<number>}
     * @inner
     */
    function base64_decode(s, len) {
        var off = 0,
            slen = s.length,
            olen = 0,
            rs = [],
            c1, c2, c3, c4, o, code;
        if (len <= 0)
            throw Error("Illegal len: "+len);
        while (off < slen - 1 && olen < len) {
            code = s.charCodeAt(off++);
            c1 = code < BASE64_INDEX.length ? BASE64_INDEX[code] : -1;
            code = s.charCodeAt(off++);
            c2 = code < BASE64_INDEX.length ? BASE64_INDEX[code] : -1;
            if (c1 == -1 || c2 == -1)
                break;
            o = (c1 << 2) >>> 0;
            o |= (c2 & 0x30) >> 4;
            rs.push(stringFromCharCode(o));
            if (++olen >= len || off >= slen)
                break;
            code = s.charCodeAt(off++);
            c3 = code < BASE64_INDEX.length ? BASE64_INDEX[code] : -1;
            if (c3 == -1)
                break;
            o = ((c2 & 0x0f) << 4) >>> 0;
            o |= (c3 & 0x3c) >> 2;
            rs.push(stringFromCharCode(o));
            if (++olen >= len || off >= slen)
                break;
            code = s.charCodeAt(off++);
            c4 = code < BASE64_INDEX.length ? BASE64_INDEX[code] : -1;
            o = ((c3 & 0x03) << 6) >>> 0;
            o |= c4;
            rs.push(stringFromCharCode(o));
            ++olen;
        }
        var res = [];
        for (off = 0; off<olen; off++)
            res.push(rs[off].charCodeAt(0));
        return res;
    }

    /**
     * utfx-embeddable (c) 2014 Daniel Wirtz <dcode@dcode.io>
     * Released under the Apache License, Version 2.0
     * see: https://github.com/dcodeIO/utfx for details
     */
    var utfx = function() {
        "use strict";

        /**
         * utfx namespace.
         * @inner
         * @type {!Object.<string,*>}
         */
        var utfx = {};

        /**
         * Maximum valid code point.
         * @type {number}
         * @const
         */
        utfx.MAX_CODEPOINT = 0x10FFFF;

        /**
         * Encodes UTF8 code points to UTF8 bytes.
         * @param {(!function():number|null) | number} src Code points source, either as a function returning the next code point
         *  respectively `null` if there are no more code points left or a single numeric code point.
         * @param {!function(number)} dst Bytes destination as a function successively called with the next byte
         */
        utfx.encodeUTF8 = function(src, dst) {
            var cp = null;
            if (typeof src === 'number')
                cp = src,
                src = function() { return null; };
            while (cp !== null || (cp = src()) !== null) {
                if (cp < 0x80)
                    dst(cp&0x7F);
                else if (cp < 0x800)
                    dst(((cp>>6)&0x1F)|0xC0),
                    dst((cp&0x3F)|0x80);
                else if (cp < 0x10000)
                    dst(((cp>>12)&0x0F)|0xE0),
                    dst(((cp>>6)&0x3F)|0x80),
                    dst((cp&0x3F)|0x80);
                else
                    dst(((cp>>18)&0x07)|0xF0),
                    dst(((cp>>12)&0x3F)|0x80),
                    dst(((cp>>6)&0x3F)|0x80),
                    dst((cp&0x3F)|0x80);
                cp = null;
            }
        };

        /**
         * Decodes UTF8 bytes to UTF8 code points.
         * @param {!function():number|null} src Bytes source as a function returning the next byte respectively `null` if there
         *  are no more bytes left.
         * @param {!function(number)} dst Code points destination as a function successively called with each decoded code point.
         * @throws {RangeError} If a starting byte is invalid in UTF8
         * @throws {Error} If the last sequence is truncated. Has an array property `bytes` holding the
         *  remaining bytes.
         */
        utfx.decodeUTF8 = function(src, dst) {
            var a, b, c, d, fail = function(b) {
                b = b.slice(0, b.indexOf(null));
                var err = Error(b.toString());
                err.name = "TruncatedError";
                err['bytes'] = b;
                throw err;
            };
            while ((a = src()) !== null) {
                if ((a&0x80) === 0)
                    dst(a);
                else if ((a&0xE0) === 0xC0)
                    ((b = src()) === null) && fail([a, b]),
                    dst(((a&0x1F)<<6) | (b&0x3F));
                else if ((a&0xF0) === 0xE0)
                    ((b=src()) === null || (c=src()) === null) && fail([a, b, c]),
                    dst(((a&0x0F)<<12) | ((b&0x3F)<<6) | (c&0x3F));
                else if ((a&0xF8) === 0xF0)
                    ((b=src()) === null || (c=src()) === null || (d=src()) === null) && fail([a, b, c ,d]),
                    dst(((a&0x07)<<18) | ((b&0x3F)<<12) | ((c&0x3F)<<6) | (d&0x3F));
                else throw RangeError("Illegal starting byte: "+a);
            }
        };

        /**
         * Converts UTF16 characters to UTF8 code points.
         * @param {!function():number|null} src Characters source as a function returning the next char code respectively
         *  `null` if there are no more characters left.
         * @param {!function(number)} dst Code points destination as a function successively called with each converted code
         *  point.
         */
        utfx.UTF16toUTF8 = function(src, dst) {
            var c1, c2 = null;
            while (true) {
                if ((c1 = c2 !== null ? c2 : src()) === null)
                    break;
                if (c1 >= 0xD800 && c1 <= 0xDFFF) {
                    if ((c2 = src()) !== null) {
                        if (c2 >= 0xDC00 && c2 <= 0xDFFF) {
                            dst((c1-0xD800)*0x400+c2-0xDC00+0x10000);
                            c2 = null; continue;
                        }
                    }
                }
                dst(c1);
            }
            if (c2 !== null) dst(c2);
        };

        /**
         * Converts UTF8 code points to UTF16 characters.
         * @param {(!function():number|null) | number} src Code points source, either as a function returning the next code point
         *  respectively `null` if there are no more code points left or a single numeric code point.
         * @param {!function(number)} dst Characters destination as a function successively called with each converted char code.
         * @throws {RangeError} If a code point is out of range
         */
        utfx.UTF8toUTF16 = function(src, dst) {
            var cp = null;
            if (typeof src === 'number')
                cp = src, src = function() { return null; };
            while (cp !== null || (cp = src()) !== null) {
                if (cp <= 0xFFFF)
                    dst(cp);
                else
                    cp -= 0x10000,
                    dst((cp>>10)+0xD800),
                    dst((cp%0x400)+0xDC00);
                cp = null;
            }
        };

        /**
         * Converts and encodes UTF16 characters to UTF8 bytes.
         * @param {!function():number|null} src Characters source as a function returning the next char code respectively `null`
         *  if there are no more characters left.
         * @param {!function(number)} dst Bytes destination as a function successively called with the next byte.
         */
        utfx.encodeUTF16toUTF8 = function(src, dst) {
            utfx.UTF16toUTF8(src, function(cp) {
                utfx.encodeUTF8(cp, dst);
            });
        };

        /**
         * Decodes and converts UTF8 bytes to UTF16 characters.
         * @param {!function():number|null} src Bytes source as a function returning the next byte respectively `null` if there
         *  are no more bytes left.
         * @param {!function(number)} dst Characters destination as a function successively called with each converted char code.
         * @throws {RangeError} If a starting byte is invalid in UTF8
         * @throws {Error} If the last sequence is truncated. Has an array property `bytes` holding the remaining bytes.
         */
        utfx.decodeUTF8toUTF16 = function(src, dst) {
            utfx.decodeUTF8(src, function(cp) {
                utfx.UTF8toUTF16(cp, dst);
            });
        };

        /**
         * Calculates the byte length of an UTF8 code point.
         * @param {number} cp UTF8 code point
         * @returns {number} Byte length
         */
        utfx.calculateCodePoint = function(cp) {
            return (cp < 0x80) ? 1 : (cp < 0x800) ? 2 : (cp < 0x10000) ? 3 : 4;
        };

        /**
         * Calculates the number of UTF8 bytes required to store UTF8 code points.
         * @param {(!function():number|null)} src Code points source as a function returning the next code point respectively
         *  `null` if there are no more code points left.
         * @returns {number} The number of UTF8 bytes required
         */
        utfx.calculateUTF8 = function(src) {
            var cp, l=0;
            while ((cp = src()) !== null)
                l += utfx.calculateCodePoint(cp);
            return l;
        };

        /**
         * Calculates the number of UTF8 code points respectively UTF8 bytes required to store UTF16 char codes.
         * @param {(!function():number|null)} src Characters source as a function returning the next char code respectively
         *  `null` if there are no more characters left.
         * @returns {!Array.<number>} The number of UTF8 code points at index 0 and the number of UTF8 bytes required at index 1.
         */
        utfx.calculateUTF16asUTF8 = function(src) {
            var n=0, l=0;
            utfx.UTF16toUTF8(src, function(cp) {
                ++n; l += utfx.calculateCodePoint(cp);
            });
            return [n,l];
        };

        return utfx;
    }();

    Date.now = Date.now || function() { return +new Date; };

    /**
     * @type {number}
     * @const
     * @inner
     */
    var BCRYPT_SALT_LEN = 16;

    /**
     * @type {number}
     * @const
     * @inner
     */
    var GENSALT_DEFAULT_LOG2_ROUNDS = 10;

    /**
     * @type {number}
     * @const
     * @inner
     */
    var BLOWFISH_NUM_ROUNDS = 16;

    /**
     * @type {number}
     * @const
     * @inner
     */
    var MAX_EXECUTION_TIME = 100;

    /**
     * @type {Array.<number>}
     * @const
     * @inner
     */
    var P_ORIG = [
        0x243f6a88, 0x85a308d3, 0x13198a2e, 0x03707344, 0xa4093822,
        0x299f31d0, 0x082efa98, 0xec4e6c89, 0x452821e6, 0x38d01377,
        0xbe5466cf, 0x34e90c6c, 0xc0ac29b7, 0xc97c50dd, 0x3f84d5b5,
        0xb5470917, 0x9216d5d9, 0x8979fb1b
    ];

    /**
     * @type {Array.<number>}
     * @const
     * @inner
     */
    var S_ORIG = [
        0xd1310ba6, 0x98dfb5ac, 0x2ffd72db, 0xd01adfb7, 0xb8e1afed,
        0x6a267e96, 0xba7c9045, 0xf12c7f99, 0x24a19947, 0xb3916cf7,
        0x0801f2e2, 0x858efc16, 0x636920d8, 0x71574e69, 0xa458fea3,
        0xf4933d7e, 0x0d95748f, 0x728eb658, 0x718bcd58, 0x82154aee,
        0x7b54a41d, 0xc25a59b5, 0x9c30d539, 0x2af26013, 0xc5d1b023,
        0x286085f0, 0xca417918, 0xb8db38ef, 0x8e79dcb0, 0x603a180e,
        0x6c9e0e8b, 0xb01e8a3e, 0xd71577c1, 0xbd314b27, 0x78af2fda,
        0x55605c60, 0xe65525f3, 0xaa55ab94, 0x57489862, 0x63e81440,
        0x55ca396a, 0x2aab10b6, 0xb4cc5c34, 0x1141e8ce, 0xa15486af,
        0x7c72e993, 0xb3ee1411, 0x636fbc2a, 0x2ba9c55d, 0x741831f6,
        0xce5c3e16, 0x9b87931e, 0xafd6ba33, 0x6c24cf5c, 0x7a325381,
        0x28958677, 0x3b8f4898, 0x6b4bb9af, 0xc4bfe81b, 0x66282193,
        0x61d809cc, 0xfb21a991, 0x487cac60, 0x5dec8032, 0xef845d5d,
        0xe98575b1, 0xdc262302, 0xeb651b88, 0x23893e81, 0xd396acc5,
        0x0f6d6ff3, 0x83f44239, 0x2e0b4482, 0xa4842004, 0x69c8f04a,
        0x9e1f9b5e, 0x21c66842, 0xf6e96c9a, 0x670c9c61, 0xabd388f0,
        0x6a51a0d2, 0xd8542f68, 0x960fa728, 0xab5133a3, 0x6eef0b6c,
        0x137a3be4, 0xba3bf050, 0x7efb2a98, 0xa1f1651d, 0x39af0176,
        0x66ca593e, 0x82430e88, 0x8cee8619, 0x456f9fb4, 0x7d84a5c3,
        0x3b8b5ebe, 0xe06f75d8, 0x85c12073, 0x401a449f, 0x56c16aa6,
        0x4ed3aa62, 0x363f7706, 0x1bfedf72, 0x429b023d, 0x37d0d724,
        0xd00a1248, 0xdb0fead3, 0x49f1c09b, 0x075372c9, 0x80991b7b,
        0x25d479d8, 0xf6e8def7, 0xe3fe501a, 0xb6794c3b, 0x976ce0bd,
        0x04c006ba, 0xc1a94fb6, 0x409f60c4, 0x5e5c9ec2, 0x196a2463,
        0x68fb6faf, 0x3e6c53b5, 0x1339b2eb, 0x3b52ec6f, 0x6dfc511f,
        0x9b30952c, 0xcc814544, 0xaf5ebd09, 0xbee3d004, 0xde334afd,
        0x660f2807, 0x192e4bb3, 0xc0cba857, 0x45c8740f, 0xd20b5f39,
        0xb9d3fbdb, 0x5579c0bd, 0x1a60320a, 0xd6a100c6, 0x402c7279,
        0x679f25fe, 0xfb1fa3cc, 0x8ea5e9f8, 0xdb3222f8, 0x3c7516df,
        0xfd616b15, 0x2f501ec8, 0xad0552ab, 0x323db5fa, 0xfd238760,
        0x53317b48, 0x3e00df82, 0x9e5c57bb, 0xca6f8ca0, 0x1a87562e,
        0xdf1769db, 0xd542a8f6, 0x287effc3, 0xac6732c6, 0x8c4f5573,
        0x695b27b0, 0xbbca58c8, 0xe1ffa35d, 0xb8f011a0, 0x10fa3d98,
        0xfd2183b8, 0x4afcb56c, 0x2dd1d35b, 0x9a53e479, 0xb6f84565,
        0xd28e49bc, 0x4bfb9790, 0xe1ddf2da, 0xa4cb7e33, 0x62fb1341,
        0xcee4c6e8, 0xef20cada, 0x36774c01, 0xd07e9efe, 0x2bf11fb4,
        0x95dbda4d, 0xae909198, 0xeaad8e71, 0x6b93d5a0, 0xd08ed1d0,
        0xafc725e0, 0x8e3c5b2f, 0x8e7594b7, 0x8ff6e2fb, 0xf2122b64,
        0x8888b812, 0x900df01c, 0x4fad5ea0, 0x688fc31c, 0xd1cff191,
        0xb3a8c1ad, 0x2f2f2218, 0xbe0e1777, 0xea752dfe, 0x8b021fa1,
        0xe5a0cc0f, 0xb56f74e8, 0x18acf3d6, 0xce89e299, 0xb4a84fe0,
        0xfd13e0b7, 0x7cc43b81, 0xd2ada8d9, 0x165fa266, 0x80957705,
        0x93cc7314, 0x211a1477, 0xe6ad2065, 0x77b5fa86, 0xc75442f5,
        0xfb9d35cf, 0xebcdaf0c, 0x7b3e89a0, 0xd6411bd3, 0xae1e7e49,
        0x00250e2d, 0x2071b35e, 0x226800bb, 0x57b8e0af, 0x2464369b,
        0xf009b91e, 0x5563911d, 0x59dfa6aa, 0x78c14389, 0xd95a537f,
        0x207d5ba2, 0x02e5b9c5, 0x83260376, 0x6295cfa9, 0x11c81968,
        0x4e734a41, 0xb3472dca, 0x7b14a94a, 0x1b510052, 0x9a532915,
        0xd60f573f, 0xbc9bc6e4, 0x2b60a476, 0x81e67400, 0x08ba6fb5,
        0x571be91f, 0xf296ec6b, 0x2a0dd915, 0xb6636521, 0xe7b9f9b6,
        0xff34052e, 0xc5855664, 0x53b02d5d, 0xa99f8fa1, 0x08ba4799,
        0x6e85076a, 0x4b7a70e9, 0xb5b32944, 0xdb75092e, 0xc4192623,
        0xad6ea6b0, 0x49a7df7d, 0x9cee60b8, 0x8fedb266, 0xecaa8c71,
        0x699a17ff, 0x5664526c, 0xc2b19ee1, 0x193602a5, 0x75094c29,
        0xa0591340, 0xe4183a3e, 0x3f54989a, 0x5b429d65, 0x6b8fe4d6,
        0x99f73fd6, 0xa1d29c07, 0xefe830f5, 0x4d2d38e6, 0xf0255dc1,
        0x4cdd2086, 0x8470eb26, 0x6382e9c6, 0x021ecc5e, 0x09686b3f,
        0x3ebaefc9, 0x3c971814, 0x6b6a70a1, 0x687f3584, 0x52a0e286,
        0xb79c5305, 0xaa500737, 0x3e07841c, 0x7fdeae5c, 0x8e7d44ec,
        0x5716f2b8, 0xb03ada37, 0xf0500c0d, 0xf01c1f04, 0x0200b3ff,
        0xae0cf51a, 0x3cb574b2, 0x25837a58, 0xdc0921bd, 0xd19113f9,
        0x7ca92ff6, 0x94324773, 0x22f54701, 0x3ae5e581, 0x37c2dadc,
        0xc8b57634, 0x9af3dda7, 0xa9446146, 0x0fd0030e, 0xecc8c73e,
        0xa4751e41, 0xe238cd99, 0x3bea0e2f, 0x3280bba1, 0x183eb331,
        0x4e548b38, 0x4f6db908, 0x6f420d03, 0xf60a04bf, 0x2cb81290,
        0x24977c79, 0x5679b072, 0xbcaf89af, 0xde9a771f, 0xd9930810,
        0xb38bae12, 0xdccf3f2e, 0x5512721f, 0x2e6b7124, 0x501adde6,
        0x9f84cd87, 0x7a584718, 0x7408da17, 0xbc9f9abc, 0xe94b7d8c,
        0xec7aec3a, 0xdb851dfa, 0x63094366, 0xc464c3d2, 0xef1c1847,
        0x3215d908, 0xdd433b37, 0x24c2ba16, 0x12a14d43, 0x2a65c451,
        0x50940002, 0x133ae4dd, 0x71dff89e, 0x10314e55, 0x81ac77d6,
        0x5f11199b, 0x043556f1, 0xd7a3c76b, 0x3c11183b, 0x5924a509,
        0xf28fe6ed, 0x97f1fbfa, 0x9ebabf2c, 0x1e153c6e, 0x86e34570,
        0xeae96fb1, 0x860e5e0a, 0x5a3e2ab3, 0x771fe71c, 0x4e3d06fa,
        0x2965dcb9, 0x99e71d0f, 0x803e89d6, 0x5266c825, 0x2e4cc978,
        0x9c10b36a, 0xc6150eba, 0x94e2ea78, 0xa5fc3c53, 0x1e0a2df4,
        0xf2f74ea7, 0x361d2b3d, 0x1939260f, 0x19c27960, 0x5223a708,
        0xf71312b6, 0xebadfe6e, 0xeac31f66, 0xe3bc4595, 0xa67bc883,
        0xb17f37d1, 0x018cff28, 0xc332ddef, 0xbe6c5aa5, 0x65582185,
        0x68ab9802, 0xeecea50f, 0xdb2f953b, 0x2aef7dad, 0x5b6e2f84,
        0x1521b628, 0x29076170, 0xecdd4775, 0x619f1510, 0x13cca830,
        0xeb61bd96, 0x0334fe1e, 0xaa0363cf, 0xb5735c90, 0x4c70a239,
        0xd59e9e0b, 0xcbaade14, 0xeecc86bc, 0x60622ca7, 0x9cab5cab,
        0xb2f3846e, 0x648b1eaf, 0x19bdf0ca, 0xa02369b9, 0x655abb50,
        0x40685a32, 0x3c2ab4b3, 0x319ee9d5, 0xc021b8f7, 0x9b540b19,
        0x875fa099, 0x95f7997e, 0x623d7da8, 0xf837889a, 0x97e32d77,
        0x11ed935f, 0x16681281, 0x0e358829, 0xc7e61fd6, 0x96dedfa1,
        0x7858ba99, 0x57f584a5, 0x1b227263, 0x9b83c3ff, 0x1ac24696,
        0xcdb30aeb, 0x532e3054, 0x8fd948e4, 0x6dbc3128, 0x58ebf2ef,
        0x34c6ffea, 0xfe28ed61, 0xee7c3c73, 0x5d4a14d9, 0xe864b7e3,
        0x42105d14, 0x203e13e0, 0x45eee2b6, 0xa3aaabea, 0xdb6c4f15,
        0xfacb4fd0, 0xc742f442, 0xef6abbb5, 0x654f3b1d, 0x41cd2105,
        0xd81e799e, 0x86854dc7, 0xe44b476a, 0x3d816250, 0xcf62a1f2,
        0x5b8d2646, 0xfc8883a0, 0xc1c7b6a3, 0x7f1524c3, 0x69cb7492,
        0x47848a0b, 0x5692b285, 0x095bbf00, 0xad19489d, 0x1462b174,
        0x23820e00, 0x58428d2a, 0x0c55f5ea, 0x1dadf43e, 0x233f7061,
        0x3372f092, 0x8d937e41, 0xd65fecf1, 0x6c223bdb, 0x7cde3759,
        0xcbee7460, 0x4085f2a7, 0xce77326e, 0xa6078084, 0x19f8509e,
        0xe8efd855, 0x61d99735, 0xa969a7aa, 0xc50c06c2, 0x5a04abfc,
        0x800bcadc, 0x9e447a2e, 0xc3453484, 0xfdd56705, 0x0e1e9ec9,
        0xdb73dbd3, 0x105588cd, 0x675fda79, 0xe3674340, 0xc5c43465,
        0x713e38d8, 0x3d28f89e, 0xf16dff20, 0x153e21e7, 0x8fb03d4a,
        0xe6e39f2b, 0xdb83adf7, 0xe93d5a68, 0x948140f7, 0xf64c261c,
        0x94692934, 0x411520f7, 0x7602d4f7, 0xbcf46b2e, 0xd4a20068,
        0xd4082471, 0x3320f46a, 0x43b7d4b7, 0x500061af, 0x1e39f62e,
        0x97244546, 0x14214f74, 0xbf8b8840, 0x4d95fc1d, 0x96b591af,
        0x70f4ddd3, 0x66a02f45, 0xbfbc09ec, 0x03bd9785, 0x7fac6dd0,
        0x31cb8504, 0x96eb27b3, 0x55fd3941, 0xda2547e6, 0xabca0a9a,
        0x28507825, 0x530429f4, 0x0a2c86da, 0xe9b66dfb, 0x68dc1462,
        0xd7486900, 0x680ec0a4, 0x27a18dee, 0x4f3ffea2, 0xe887ad8c,
        0xb58ce006, 0x7af4d6b6, 0xaace1e7c, 0xd3375fec, 0xce78a399,
        0x406b2a42, 0x20fe9e35, 0xd9f385b9, 0xee39d7ab, 0x3b124e8b,
        0x1dc9faf7, 0x4b6d1856, 0x26a36631, 0xeae397b2, 0x3a6efa74,
        0xdd5b4332, 0x6841e7f7, 0xca7820fb, 0xfb0af54e, 0xd8feb397,
        0x454056ac, 0xba489527, 0x55533a3a, 0x20838d87, 0xfe6ba9b7,
        0xd096954b, 0x55a867bc, 0xa1159a58, 0xcca92963, 0x99e1db33,
        0xa62a4a56, 0x3f3125f9, 0x5ef47e1c, 0x9029317c, 0xfdf8e802,
        0x04272f70, 0x80bb155c, 0x05282ce3, 0x95c11548, 0xe4c66d22,
        0x48c1133f, 0xc70f86dc, 0x07f9c9ee, 0x41041f0f, 0x404779a4,
        0x5d886e17, 0x325f51eb, 0xd59bc0d1, 0xf2bcc18f, 0x41113564,
        0x257b7834, 0x602a9c60, 0xdff8e8a3, 0x1f636c1b, 0x0e12b4c2,
        0x02e1329e, 0xaf664fd1, 0xcad18115, 0x6b2395e0, 0x333e92e1,
        0x3b240b62, 0xeebeb922, 0x85b2a20e, 0xe6ba0d99, 0xde720c8c,
        0x2da2f728, 0xd0127845, 0x95b794fd, 0x647d0862, 0xe7ccf5f0,
        0x5449a36f, 0x877d48fa, 0xc39dfd27, 0xf33e8d1e, 0x0a476341,
        0x992eff74, 0x3a6f6eab, 0xf4f8fd37, 0xa812dc60, 0xa1ebddf8,
        0x991be14c, 0xdb6e6b0d, 0xc67b5510, 0x6d672c37, 0x2765d43b,
        0xdcd0e804, 0xf1290dc7, 0xcc00ffa3, 0xb5390f92, 0x690fed0b,
        0x667b9ffb, 0xcedb7d9c, 0xa091cf0b, 0xd9155ea3, 0xbb132f88,
        0x515bad24, 0x7b9479bf, 0x763bd6eb, 0x37392eb3, 0xcc115979,
        0x8026e297, 0xf42e312d, 0x6842ada7, 0xc66a2b3b, 0x12754ccc,
        0x782ef11c, 0x6a124237, 0xb79251e7, 0x06a1bbe6, 0x4bfb6350,
        0x1a6b1018, 0x11caedfa, 0x3d25bdd8, 0xe2e1c3c9, 0x44421659,
        0x0a121386, 0xd90cec6e, 0xd5abea2a, 0x64af674e, 0xda86a85f,
        0xbebfe988, 0x64e4c3fe, 0x9dbc8057, 0xf0f7c086, 0x60787bf8,
        0x6003604d, 0xd1fd8346, 0xf6381fb0, 0x7745ae04, 0xd736fccc,
        0x83426b33, 0xf01eab71, 0xb0804187, 0x3c005e5f, 0x77a057be,
        0xbde8ae24, 0x55464299, 0xbf582e61, 0x4e58f48f, 0xf2ddfda2,
        0xf474ef38, 0x8789bdc2, 0x5366f9c3, 0xc8b38e74, 0xb475f255,
        0x46fcd9b9, 0x7aeb2661, 0x8b1ddf84, 0x846a0e79, 0x915f95e2,
        0x466e598e, 0x20b45770, 0x8cd55591, 0xc902de4c, 0xb90bace1,
        0xbb8205d0, 0x11a86248, 0x7574a99e, 0xb77f19b6, 0xe0a9dc09,
        0x662d09a1, 0xc4324633, 0xe85a1f02, 0x09f0be8c, 0x4a99a025,
        0x1d6efe10, 0x1ab93d1d, 0x0ba5a4df, 0xa186f20f, 0x2868f169,
        0xdcb7da83, 0x573906fe, 0xa1e2ce9b, 0x4fcd7f52, 0x50115e01,
        0xa70683fa, 0xa002b5c4, 0x0de6d027, 0x9af88c27, 0x773f8641,
        0xc3604c06, 0x61a806b5, 0xf0177a28, 0xc0f586e0, 0x006058aa,
        0x30dc7d62, 0x11e69ed7, 0x2338ea63, 0x53c2dd94, 0xc2c21634,
        0xbbcbee56, 0x90bcb6de, 0xebfc7da1, 0xce591d76, 0x6f05e409,
        0x4b7c0188, 0x39720a3d, 0x7c927c24, 0x86e3725f, 0x724d9db9,
        0x1ac15bb4, 0xd39eb8fc, 0xed545578, 0x08fca5b5, 0xd83d7cd3,
        0x4dad0fc4, 0x1e50ef5e, 0xb161e6f8, 0xa28514d9, 0x6c51133c,
        0x6fd5c7e7, 0x56e14ec4, 0x362abfce, 0xddc6c837, 0xd79a3234,
        0x92638212, 0x670efa8e, 0x406000e0, 0x3a39ce37, 0xd3faf5cf,
        0xabc27737, 0x5ac52d1b, 0x5cb0679e, 0x4fa33742, 0xd3822740,
        0x99bc9bbe, 0xd5118e9d, 0xbf0f7315, 0xd62d1c7e, 0xc700c47b,
        0xb78c1b6b, 0x21a19045, 0xb26eb1be, 0x6a366eb4, 0x5748ab2f,
        0xbc946e79, 0xc6a376d2, 0x6549c2c8, 0x530ff8ee, 0x468dde7d,
        0xd5730a1d, 0x4cd04dc6, 0x2939bbdb, 0xa9ba4650, 0xac9526e8,
        0xbe5ee304, 0xa1fad5f0, 0x6a2d519a, 0x63ef8ce2, 0x9a86ee22,
        0xc089c2b8, 0x43242ef6, 0xa51e03aa, 0x9cf2d0a4, 0x83c061ba,
        0x9be96a4d, 0x8fe51550, 0xba645bd6, 0x2826a2f9, 0xa73a3ae1,
        0x4ba99586, 0xef5562e9, 0xc72fefd3, 0xf752f7da, 0x3f046f69,
        0x77fa0a59, 0x80e4a915, 0x87b08601, 0x9b09e6ad, 0x3b3ee593,
        0xe990fd5a, 0x9e34d797, 0x2cf0b7d9, 0x022b8b51, 0x96d5ac3a,
        0x017da67d, 0xd1cf3ed6, 0x7c7d2d28, 0x1f9f25cf, 0xadf2b89b,
        0x5ad6b472, 0x5a88f54c, 0xe029ac71, 0xe019a5e6, 0x47b0acfd,
        0xed93fa9b, 0xe8d3c48d, 0x283b57cc, 0xf8d56629, 0x79132e28,
        0x785f0191, 0xed756055, 0xf7960e44, 0xe3d35e8c, 0x15056dd4,
        0x88f46dba, 0x03a16125, 0x0564f0bd, 0xc3eb9e15, 0x3c9057a2,
        0x97271aec, 0xa93a072a, 0x1b3f6d9b, 0x1e6321f5, 0xf59c66fb,
        0x26dcf319, 0x7533d928, 0xb155fdf5, 0x03563482, 0x8aba3cbb,
        0x28517711, 0xc20ad9f8, 0xabcc5167, 0xccad925f, 0x4de81751,
        0x3830dc8e, 0x379d5862, 0x9320f991, 0xea7a90c2, 0xfb3e7bce,
        0x5121ce64, 0x774fbe32, 0xa8b6e37e, 0xc3293d46, 0x48de5369,
        0x6413e680, 0xa2ae0810, 0xdd6db224, 0x69852dfd, 0x09072166,
        0xb39a460a, 0x6445c0dd, 0x586cdecf, 0x1c20c8ae, 0x5bbef7dd,
        0x1b588d40, 0xccd2017f, 0x6bb4e3bb, 0xdda26a7e, 0x3a59ff45,
        0x3e350a44, 0xbcb4cdd5, 0x72eacea8, 0xfa6484bb, 0x8d6612ae,
        0xbf3c6f47, 0xd29be463, 0x542f5d9e, 0xaec2771b, 0xf64e6370,
        0x740e0d8d, 0xe75b1357, 0xf8721671, 0xaf537d5d, 0x4040cb08,
        0x4eb4e2cc, 0x34d2466a, 0x0115af84, 0xe1b00428, 0x95983a1d,
        0x06b89fb4, 0xce6ea048, 0x6f3f3b82, 0x3520ab82, 0x011a1d4b,
        0x277227f8, 0x611560b1, 0xe7933fdc, 0xbb3a792b, 0x344525bd,
        0xa08839e1, 0x51ce794b, 0x2f32c9b7, 0xa01fbac9, 0xe01cc87e,
        0xbcc7d1f6, 0xcf0111c3, 0xa1e8aac7, 0x1a908749, 0xd44fbd9a,
        0xd0dadecb, 0xd50ada38, 0x0339c32a, 0xc6913667, 0x8df9317c,
        0xe0b12b4f, 0xf79e59b7, 0x43f5bb3a, 0xf2d519ff, 0x27d9459c,
        0xbf97222c, 0x15e6fc2a, 0x0f91fc71, 0x9b941525, 0xfae59361,
        0xceb69ceb, 0xc2a86459, 0x12baa8d1, 0xb6c1075e, 0xe3056a0c,
        0x10d25065, 0xcb03a442, 0xe0ec6e0e, 0x1698db3b, 0x4c98a0be,
        0x3278e964, 0x9f1f9532, 0xe0d392df, 0xd3a0342b, 0x8971f21e,
        0x1b0a7441, 0x4ba3348c, 0xc5be7120, 0xc37632d8, 0xdf359f8d,
        0x9b992f2e, 0xe60b6f47, 0x0fe3f11d, 0xe54cda54, 0x1edad891,
        0xce6279cf, 0xcd3e7e6f, 0x1618b166, 0xfd2c1d05, 0x848fd2c5,
        0xf6fb2299, 0xf523f357, 0xa6327623, 0x93a83531, 0x56cccd02,
        0xacf08162, 0x5a75ebb5, 0x6e163697, 0x88d273cc, 0xde966292,
        0x81b949d0, 0x4c50901b, 0x71c65614, 0xe6c6c7bd, 0x327a140a,
        0x45e1d006, 0xc3f27b9a, 0xc9aa53fd, 0x62a80f00, 0xbb25bfe2,
        0x35bdd2f6, 0x71126905, 0xb2040222, 0xb6cbcf7c, 0xcd769c2b,
        0x53113ec0, 0x1640e3d3, 0x38abbd60, 0x2547adf0, 0xba38209c,
        0xf746ce76, 0x77afa1c5, 0x20756060, 0x85cbfe4e, 0x8ae88dd8,
        0x7aaaf9b0, 0x4cf9aa7e, 0x1948c25c, 0x02fb8a8c, 0x01c36ae4,
        0xd6ebe1f9, 0x90d4f869, 0xa65cdea0, 0x3f09252d, 0xc208e69f,
        0xb74e6132, 0xce77e25b, 0x578fdfe3, 0x3ac372e6
    ];

    /**
     * @type {Array.<number>}
     * @const
     * @inner
     */
    var C_ORIG = [
        0x4f727068, 0x65616e42, 0x65686f6c, 0x64657253, 0x63727944,
        0x6f756274
    ];

    /**
     * @param {Array.<number>} lr
     * @param {number} off
     * @param {Array.<number>} P
     * @param {Array.<number>} S
     * @returns {Array.<number>}
     * @inner
     */
    function _encipher(lr, off, P, S) { // This is our bottleneck: 1714/1905 ticks / 90% - see profile.txt
        var n,
            l = lr[off],
            r = lr[off + 1];

        l ^= P[0];

        /*
        for (var i=0, k=BLOWFISH_NUM_ROUNDS-2; i<=k;)
            // Feistel substitution on left word
            n  = S[l >>> 24],
            n += S[0x100 | ((l >> 16) & 0xff)],
            n ^= S[0x200 | ((l >> 8) & 0xff)],
            n += S[0x300 | (l & 0xff)],
            r ^= n ^ P[++i],
            // Feistel substitution on right word
            n  = S[r >>> 24],
            n += S[0x100 | ((r >> 16) & 0xff)],
            n ^= S[0x200 | ((r >> 8) & 0xff)],
            n += S[0x300 | (r & 0xff)],
            l ^= n ^ P[++i];
        */

        //The following is an unrolled version of the above loop.
        //Iteration 0
        n  = S[l >>> 24];
        n += S[0x100 | ((l >> 16) & 0xff)];
        n ^= S[0x200 | ((l >> 8) & 0xff)];
        n += S[0x300 | (l & 0xff)];
        r ^= n ^ P[1];
        n  = S[r >>> 24];
        n += S[0x100 | ((r >> 16) & 0xff)];
        n ^= S[0x200 | ((r >> 8) & 0xff)];
        n += S[0x300 | (r & 0xff)];
        l ^= n ^ P[2];
        //Iteration 1
        n  = S[l >>> 24];
        n += S[0x100 | ((l >> 16) & 0xff)];
        n ^= S[0x200 | ((l >> 8) & 0xff)];
        n += S[0x300 | (l & 0xff)];
        r ^= n ^ P[3];
        n  = S[r >>> 24];
        n += S[0x100 | ((r >> 16) & 0xff)];
        n ^= S[0x200 | ((r >> 8) & 0xff)];
        n += S[0x300 | (r & 0xff)];
        l ^= n ^ P[4];
        //Iteration 2
        n  = S[l >>> 24];
        n += S[0x100 | ((l >> 16) & 0xff)];
        n ^= S[0x200 | ((l >> 8) & 0xff)];
        n += S[0x300 | (l & 0xff)];
        r ^= n ^ P[5];
        n  = S[r >>> 24];
        n += S[0x100 | ((r >> 16) & 0xff)];
        n ^= S[0x200 | ((r >> 8) & 0xff)];
        n += S[0x300 | (r & 0xff)];
        l ^= n ^ P[6];
        //Iteration 3
        n  = S[l >>> 24];
        n += S[0x100 | ((l >> 16) & 0xff)];
        n ^= S[0x200 | ((l >> 8) & 0xff)];
        n += S[0x300 | (l & 0xff)];
        r ^= n ^ P[7];
        n  = S[r >>> 24];
        n += S[0x100 | ((r >> 16) & 0xff)];
        n ^= S[0x200 | ((r >> 8) & 0xff)];
        n += S[0x300 | (r & 0xff)];
        l ^= n ^ P[8];
        //Iteration 4
        n  = S[l >>> 24];
        n += S[0x100 | ((l >> 16) & 0xff)];
        n ^= S[0x200 | ((l >> 8) & 0xff)];
        n += S[0x300 | (l & 0xff)];
        r ^= n ^ P[9];
        n  = S[r >>> 24];
        n += S[0x100 | ((r >> 16) & 0xff)];
        n ^= S[0x200 | ((r >> 8) & 0xff)];
        n += S[0x300 | (r & 0xff)];
        l ^= n ^ P[10];
        //Iteration 5
        n  = S[l >>> 24];
        n += S[0x100 | ((l >> 16) & 0xff)];
        n ^= S[0x200 | ((l >> 8) & 0xff)];
        n += S[0x300 | (l & 0xff)];
        r ^= n ^ P[11];
        n  = S[r >>> 24];
        n += S[0x100 | ((r >> 16) & 0xff)];
        n ^= S[0x200 | ((r >> 8) & 0xff)];
        n += S[0x300 | (r & 0xff)];
        l ^= n ^ P[12];
        //Iteration 6
        n  = S[l >>> 24];
        n += S[0x100 | ((l >> 16) & 0xff)];
        n ^= S[0x200 | ((l >> 8) & 0xff)];
        n += S[0x300 | (l & 0xff)];
        r ^= n ^ P[13];
        n  = S[r >>> 24];
        n += S[0x100 | ((r >> 16) & 0xff)];
        n ^= S[0x200 | ((r >> 8) & 0xff)];
        n += S[0x300 | (r & 0xff)];
        l ^= n ^ P[14];
        //Iteration 7
        n  = S[l >>> 24];
        n += S[0x100 | ((l >> 16) & 0xff)];
        n ^= S[0x200 | ((l >> 8) & 0xff)];
        n += S[0x300 | (l & 0xff)];
        r ^= n ^ P[15];
        n  = S[r >>> 24];
        n += S[0x100 | ((r >> 16) & 0xff)];
        n ^= S[0x200 | ((r >> 8) & 0xff)];
        n += S[0x300 | (r & 0xff)];
        l ^= n ^ P[16];

        lr[off] = r ^ P[BLOWFISH_NUM_ROUNDS + 1];
        lr[off + 1] = l;
        return lr;
    }

    /**
     * @param {Array.<number>} data
     * @param {number} offp
     * @returns {{key: number, offp: number}}
     * @inner
     */
    function _streamtoword(data, offp) {
        for (var i = 0, word = 0; i < 4; ++i)
            word = (word << 8) | (data[offp] & 0xff),
            offp = (offp + 1) % data.length;
        return { key: word, offp: offp };
    }

    /**
     * @param {Array.<number>} key
     * @param {Array.<number>} P
     * @param {Array.<number>} S
     * @inner
     */
    function _key(key, P, S) {
        var offset = 0,
            lr = [0, 0],
            plen = P.length,
            slen = S.length,
            sw;
        for (var i = 0; i < plen; i++)
            sw = _streamtoword(key, offset),
            offset = sw.offp,
            P[i] = P[i] ^ sw.key;
        for (i = 0; i < plen; i += 2)
            lr = _encipher(lr, 0, P, S),
            P[i] = lr[0],
            P[i + 1] = lr[1];
        for (i = 0; i < slen; i += 2)
            lr = _encipher(lr, 0, P, S),
            S[i] = lr[0],
            S[i + 1] = lr[1];
    }

    /**
     * Expensive key schedule Blowfish.
     * @param {Array.<number>} data
     * @param {Array.<number>} key
     * @param {Array.<number>} P
     * @param {Array.<number>} S
     * @inner
     */
    function _ekskey(data, key, P, S) {
        var offp = 0,
            lr = [0, 0],
            plen = P.length,
            slen = S.length,
            sw;
        for (var i = 0; i < plen; i++)
            sw = _streamtoword(key, offp),
            offp = sw.offp,
            P[i] = P[i] ^ sw.key;
        offp = 0;
        for (i = 0; i < plen; i += 2)
            sw = _streamtoword(data, offp),
            offp = sw.offp,
            lr[0] ^= sw.key,
            sw = _streamtoword(data, offp),
            offp = sw.offp,
            lr[1] ^= sw.key,
            lr = _encipher(lr, 0, P, S),
            P[i] = lr[0],
            P[i + 1] = lr[1];
        for (i = 0; i < slen; i += 2)
            sw = _streamtoword(data, offp),
            offp = sw.offp,
            lr[0] ^= sw.key,
            sw = _streamtoword(data, offp),
            offp = sw.offp,
            lr[1] ^= sw.key,
            lr = _encipher(lr, 0, P, S),
            S[i] = lr[0],
            S[i + 1] = lr[1];
    }

    /**
     * Internaly crypts a string.
     * @param {Array.<number>} b Bytes to crypt
     * @param {Array.<number>} salt Salt bytes to use
     * @param {number} rounds Number of rounds
     * @param {function(Error, Array.<number>=)=} callback Callback receiving the error, if any, and the resulting bytes. If
     *  omitted, the operation will be performed synchronously.
     *  @param {function(number)=} progressCallback Callback called with the current progress
     * @returns {!Array.<number>|undefined} Resulting bytes if callback has been omitted, otherwise `undefined`
     * @inner
     */
    function _crypt(b, salt, rounds, callback, progressCallback) {
        var cdata = C_ORIG.slice(),
            clen = cdata.length,
            err;

        // Validate
        if (rounds < 4 || rounds > 31) {
            err = Error("Illegal number of rounds (4-31): "+rounds);
            if (callback) {
                nextTick(callback.bind(this, err));
                return;
            } else
                throw err;
        }
        if (salt.length !== BCRYPT_SALT_LEN) {
            err =Error("Illegal salt length: "+salt.length+" != "+BCRYPT_SALT_LEN);
            if (callback) {
                nextTick(callback.bind(this, err));
                return;
            } else
                throw err;
        }
        rounds = (1 << rounds) >>> 0;

        var P, S, i = 0, j;

        //Use typed arrays when available - huge speedup!
        if (Int32Array) {
            P = new Int32Array(P_ORIG);
            S = new Int32Array(S_ORIG);
        } else {
            P = P_ORIG.slice();
            S = S_ORIG.slice();
        }

        _ekskey(salt, b, P, S);

        /**
         * Calcualtes the next round.
         * @returns {Array.<number>|undefined} Resulting array if callback has been omitted, otherwise `undefined`
         * @inner
         */
        function next() {
            if (progressCallback)
                progressCallback(i / rounds);
            if (i < rounds) {
                var start = Date.now();
                for (; i < rounds;) {
                    i = i + 1;
                    _key(b, P, S);
                    _key(salt, P, S);
                    if (Date.now() - start > MAX_EXECUTION_TIME)
                        break;
                }
            } else {
                for (i = 0; i < 64; i++)
                    for (j = 0; j < (clen >> 1); j++)
                        _encipher(cdata, j << 1, P, S);
                var ret = [];
                for (i = 0; i < clen; i++)
                    ret.push(((cdata[i] >> 24) & 0xff) >>> 0),
                    ret.push(((cdata[i] >> 16) & 0xff) >>> 0),
                    ret.push(((cdata[i] >> 8) & 0xff) >>> 0),
                    ret.push((cdata[i] & 0xff) >>> 0);
                if (callback) {
                    callback(null, ret);
                    return;
                } else
                    return ret;
            }
            if (callback)
                nextTick(next);
        }

        // Async
        if (typeof callback !== 'undefined') {
            next();

            // Sync
        } else {
            var res;
            while (true)
                if (typeof(res = next()) !== 'undefined')
                    return res || [];
        }
    }

    /**
     * Internally hashes a string.
     * @param {string} s String to hash
     * @param {?string} salt Salt to use, actually never null
     * @param {function(Error, string=)=} callback Callback receiving the error, if any, and the resulting hash. If omitted,
     *  hashing is perormed synchronously.
     *  @param {function(number)=} progressCallback Callback called with the current progress
     * @returns {string|undefined} Resulting hash if callback has been omitted, otherwise `undefined`
     * @inner
     */
    function _hash(s, salt, callback, progressCallback) {
        var err;
        if (typeof s !== 'string' || typeof salt !== 'string') {
            err = Error("Invalid string / salt: Not a string");
            if (callback) {
                nextTick(callback.bind(this, err));
                return;
            }
            else
                throw err;
        }

        // Validate the salt
        var minor, offset;
        if (salt.charAt(0) !== '$' || salt.charAt(1) !== '2') {
            err = Error("Invalid salt version: "+salt.substring(0,2));
            if (callback) {
                nextTick(callback.bind(this, err));
                return;
            }
            else
                throw err;
        }
        if (salt.charAt(2) === '$')
            minor = String.fromCharCode(0),
            offset = 3;
        else {
            minor = salt.charAt(2);
            if ((minor !== 'a' && minor !== 'b' && minor !== 'y') || salt.charAt(3) !== '$') {
                err = Error("Invalid salt revision: "+salt.substring(2,4));
                if (callback) {
                    nextTick(callback.bind(this, err));
                    return;
                } else
                    throw err;
            }
            offset = 4;
        }

        // Extract number of rounds
        if (salt.charAt(offset + 2) > '$') {
            err = Error("Missing salt rounds");
            if (callback) {
                nextTick(callback.bind(this, err));
                return;
            } else
                throw err;
        }
        var r1 = parseInt(salt.substring(offset, offset + 1), 10) * 10,
            r2 = parseInt(salt.substring(offset + 1, offset + 2), 10),
            rounds = r1 + r2,
            real_salt = salt.substring(offset + 3, offset + 25);
        s += minor >= 'a' ? "\x00" : "";

        var passwordb = stringToBytes(s),
            saltb = base64_decode(real_salt, BCRYPT_SALT_LEN);

        /**
         * Finishes hashing.
         * @param {Array.<number>} bytes Byte array
         * @returns {string}
         * @inner
         */
        function finish(bytes) {
            var res = [];
            res.push("$2");
            if (minor >= 'a')
                res.push(minor);
            res.push("$");
            if (rounds < 10)
                res.push("0");
            res.push(rounds.toString());
            res.push("$");
            res.push(base64_encode(saltb, saltb.length));
            res.push(base64_encode(bytes, C_ORIG.length * 4 - 1));
            return res.join('');
        }

        // Sync
        if (typeof callback == 'undefined')
            return finish(_crypt(passwordb, saltb, rounds));

        // Async
        else {
            _crypt(passwordb, saltb, rounds, function(err, bytes) {
                if (err)
                    callback(err, null);
                else
                    callback(null, finish(bytes));
            }, progressCallback);
        }
    }

    /**
     * Encodes a byte array to base64 with up to len bytes of input, using the custom bcrypt alphabet.
     * @function
     * @param {!Array.<number>} b Byte array
     * @param {number} len Maximum input length
     * @returns {string}
     * @expose
     */
    bcrypt.encodeBase64 = base64_encode;

    /**
     * Decodes a base64 encoded string to up to len bytes of output, using the custom bcrypt alphabet.
     * @function
     * @param {string} s String to decode
     * @param {number} len Maximum output length
     * @returns {!Array.<number>}
     * @expose
     */
    bcrypt.decodeBase64 = base64_decode;

    return bcrypt;
}));


/***/ }),

/***/ 11289:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

/*
 Copyright (c) 2012 Nevins Bartolomeo <nevins.bartolomeo@gmail.com>
 Copyright (c) 2012 Shane Girish <shaneGirish@gmail.com>
 Copyright (c) 2013 Daniel Wirtz <dcode@dcode.io>

 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions
 are met:
 1. Redistributions of source code must retain the above copyright
 notice, this list of conditions and the following disclaimer.
 2. Redistributions in binary form must reproduce the above copyright
 notice, this list of conditions and the following disclaimer in the
 documentation and/or other materials provided with the distribution.
 3. The name of the author may not be used to endorse or promote products
 derived from this software without specific prior written permission.

 THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

module.exports = __nccwpck_require__(73546);


/***/ }),

/***/ 85938:
/***/ ((module, exports, __nccwpck_require__) => {

/**
 * Module dependencies.
 */

var fs = __nccwpck_require__(79896),
  path = __nccwpck_require__(16928),
  fileURLToPath = __nccwpck_require__(29983),
  join = path.join,
  dirname = path.dirname,
  exists =
    (fs.accessSync &&
      function(path) {
        try {
          fs.accessSync(path);
        } catch (e) {
          return false;
        }
        return true;
      }) ||
    fs.existsSync ||
    path.existsSync,
  defaults = {
    arrow: process.env.NODE_BINDINGS_ARROW || ' ‚Üí ',
    compiled: process.env.NODE_BINDINGS_COMPILED_DIR || 'compiled',
    platform: process.platform,
    arch: process.arch,
    nodePreGyp:
      'node-v' +
      process.versions.modules +
      '-' +
      process.platform +
      '-' +
      process.arch,
    version: process.versions.node,
    bindings: 'bindings.node',
    try: [
      // node-gyp's linked version in the "build" dir
      ['module_root', 'build', 'bindings'],
      // node-waf and gyp_addon (a.k.a node-gyp)
      ['module_root', 'build', 'Debug', 'bindings'],
      ['module_root', 'build', 'Release', 'bindings'],
      // Debug files, for development (legacy behavior, remove for node v0.9)
      ['module_root', 'out', 'Debug', 'bindings'],
      ['module_root', 'Debug', 'bindings'],
      // Release files, but manually compiled (legacy behavior, remove for node v0.9)
      ['module_root', 'out', 'Release', 'bindings'],
      ['module_root', 'Release', 'bindings'],
      // Legacy from node-waf, node <= 0.4.x
      ['module_root', 'build', 'default', 'bindings'],
      // Production "Release" buildtype binary (meh...)
      ['module_root', 'compiled', 'version', 'platform', 'arch', 'bindings'],
      // node-qbs builds
      ['module_root', 'addon-build', 'release', 'install-root', 'bindings'],
      ['module_root', 'addon-build', 'debug', 'install-root', 'bindings'],
      ['module_root', 'addon-build', 'default', 'install-root', 'bindings'],
      // node-pre-gyp path ./lib/binding/{node_abi}-{platform}-{arch}
      ['module_root', 'lib', 'binding', 'nodePreGyp', 'bindings']
    ]
  };

/**
 * The main `bindings()` function loads the compiled bindings for a given module.
 * It uses V8's Error API to determine the parent filename that this function is
 * being invoked from, which is then used to find the root directory.
 */

function bindings(opts) {
  // Argument surgery
  if (typeof opts == 'string') {
    opts = { bindings: opts };
  } else if (!opts) {
    opts = {};
  }

  // maps `defaults` onto `opts` object
  Object.keys(defaults).map(function(i) {
    if (!(i in opts)) opts[i] = defaults[i];
  });

  // Get the module root
  if (!opts.module_root) {
    opts.module_root = exports.getRoot(exports.getFileName());
  }

  // Ensure the given bindings name ends with .node
  if (path.extname(opts.bindings) != '.node') {
    opts.bindings += '.node';
  }

  // https://github.com/webpack/webpack/issues/4175#issuecomment-342931035
  var requireFunc =
     true
      ? eval("require")
      : 0;

  var tries = [],
    i = 0,
    l = opts.try.length,
    n,
    b,
    err;

  for (; i < l; i++) {
    n = join.apply(
      null,
      opts.try[i].map(function(p) {
        return opts[p] || p;
      })
    );
    tries.push(n);
    try {
      b = opts.path ? requireFunc.resolve(n) : requireFunc(n);
      if (!opts.path) {
        b.path = n;
      }
      return b;
    } catch (e) {
      if (e.code !== 'MODULE_NOT_FOUND' &&
          e.code !== 'QUALIFIED_PATH_RESOLUTION_FAILED' &&
          !/not find/i.test(e.message)) {
        throw e;
      }
    }
  }

  err = new Error(
    'Could not locate the bindings file. Tried:\n' +
      tries
        .map(function(a) {
          return opts.arrow + a;
        })
        .join('\n')
  );
  err.tries = tries;
  throw err;
}
module.exports = exports = bindings;

/**
 * Gets the filename of the JavaScript file that invokes this function.
 * Used to help find the root directory of a module.
 * Optionally accepts an filename argument to skip when searching for the invoking filename
 */

exports.getFileName = function getFileName(calling_file) {
  var origPST = Error.prepareStackTrace,
    origSTL = Error.stackTraceLimit,
    dummy = {},
    fileName;

  Error.stackTraceLimit = 10;

  Error.prepareStackTrace = function(e, st) {
    for (var i = 0, l = st.length; i < l; i++) {
      fileName = st[i].getFileName();
      if (fileName !== __filename) {
        if (calling_file) {
          if (fileName !== calling_file) {
            return;
          }
        } else {
          return;
        }
      }
    }
  };

  // run the 'prepareStackTrace' function above
  Error.captureStackTrace(dummy);
  dummy.stack;

  // cleanup
  Error.prepareStackTrace = origPST;
  Error.stackTraceLimit = origSTL;

  // handle filename that starts with "file://"
  var fileSchema = 'file://';
  if (fileName.indexOf(fileSchema) === 0) {
    fileName = fileURLToPath(fileName);
  }

  return fileName;
};

/**
 * Gets the root directory of a module, given an arbitrary filename
 * somewhere in the module tree. The "root directory" is the directory
 * containing the `package.json` file.
 *
 *   In:  /home/nate/node-native-module/lib/index.js
 *   Out: /home/nate/node-native-module
 */

exports.getRoot = function getRoot(file) {
  var dir = dirname(file),
    prev;
  while (true) {
    if (dir === '.') {
      // Avoids an infinite loop in rare cases, like the REPL
      dir = process.cwd();
    }
    if (
      exists(join(dir, 'package.json')) ||
      exists(join(dir, 'node_modules'))
    ) {
      // Found the 'package.json' file or 'node_modules' dir; we're done
      return dir;
    }
    if (prev === dir) {
      // Got to the top
      throw new Error(
        'Could not find module root given file: "' +
          file +
          '". Do you have a `package.json` file? '
      );
    }
    // Try the parent dir next
    prev = dir;
    dir = join(dir, '..');
  }
};


/***/ }),

/***/ 6536:
/***/ ((module, exports, __nccwpck_require__) => {

"use strict";
/*!
 * body-parser
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module dependencies.
 * @private
 */

var deprecate = __nccwpck_require__(60095)('body-parser')

/**
 * Cache of loaded parsers.
 * @private
 */

var parsers = Object.create(null)

/**
 * @typedef Parsers
 * @type {function}
 * @property {function} json
 * @property {function} raw
 * @property {function} text
 * @property {function} urlencoded
 */

/**
 * Module exports.
 * @type {Parsers}
 */

exports = module.exports = deprecate.function(bodyParser,
  'bodyParser: use individual json/urlencoded middlewares')

/**
 * JSON parser.
 * @public
 */

Object.defineProperty(exports, "json", ({
  configurable: true,
  enumerable: true,
  get: createParserGetter('json')
}))

/**
 * Raw parser.
 * @public
 */

Object.defineProperty(exports, "raw", ({
  configurable: true,
  enumerable: true,
  get: createParserGetter('raw')
}))

/**
 * Text parser.
 * @public
 */

Object.defineProperty(exports, "text", ({
  configurable: true,
  enumerable: true,
  get: createParserGetter('text')
}))

/**
 * URL-encoded parser.
 * @public
 */

Object.defineProperty(exports, "urlencoded", ({
  configurable: true,
  enumerable: true,
  get: createParserGetter('urlencoded')
}))

/**
 * Create a middleware to parse json and urlencoded bodies.
 *
 * @param {object} [options]
 * @return {function}
 * @deprecated
 * @public
 */

function bodyParser (options) {
  // use default type for parsers
  var opts = Object.create(options || null, {
    type: {
      configurable: true,
      enumerable: true,
      value: undefined,
      writable: true
    }
  })

  var _urlencoded = exports.urlencoded(opts)
  var _json = exports.json(opts)

  return function bodyParser (req, res, next) {
    _json(req, res, function (err) {
      if (err) return next(err)
      _urlencoded(req, res, next)
    })
  }
}

/**
 * Create a getter for loading a parser.
 * @private
 */

function createParserGetter (name) {
  return function get () {
    return loadParser(name)
  }
}

/**
 * Load a parser module.
 * @private
 */

function loadParser (parserName) {
  var parser = parsers[parserName]

  if (parser !== undefined) {
    return parser
  }

  // this uses a switch for static require analysis
  switch (parserName) {
    case 'json':
      parser = __nccwpck_require__(72162)
      break
    case 'raw':
      parser = __nccwpck_require__(8496)
      break
    case 'text':
      parser = __nccwpck_require__(17211)
      break
    case 'urlencoded':
      parser = __nccwpck_require__(17129)
      break
  }

  // store to prevent invoking require()
  return (parsers[parserName] = parser)
}


/***/ }),

/***/ 27946:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";
/*!
 * body-parser
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module dependencies.
 * @private
 */

var createError = __nccwpck_require__(78024)
var destroy = __nccwpck_require__(32194)
var getBody = __nccwpck_require__(60949)
var iconv = __nccwpck_require__(65428)
var onFinished = __nccwpck_require__(5698)
var unpipe = __nccwpck_require__(66367)
var zlib = __nccwpck_require__(43106)

/**
 * Module exports.
 */

module.exports = read

/**
 * Read a request into a buffer and parse.
 *
 * @param {object} req
 * @param {object} res
 * @param {function} next
 * @param {function} parse
 * @param {function} debug
 * @param {object} options
 * @private
 */

function read (req, res, next, parse, debug, options) {
  var length
  var opts = options
  var stream

  // flag as parsed
  req._body = true

  // read options
  var encoding = opts.encoding !== null
    ? opts.encoding
    : null
  var verify = opts.verify

  try {
    // get the content stream
    stream = contentstream(req, debug, opts.inflate)
    length = stream.length
    stream.length = undefined
  } catch (err) {
    return next(err)
  }

  // set raw-body options
  opts.length = length
  opts.encoding = verify
    ? null
    : encoding

  // assert charset is supported
  if (opts.encoding === null && encoding !== null && !iconv.encodingExists(encoding)) {
    return next(createError(415, 'unsupported charset "' + encoding.toUpperCase() + '"', {
      charset: encoding.toLowerCase(),
      type: 'charset.unsupported'
    }))
  }

  // read body
  debug('read body')
  getBody(stream, opts, function (error, body) {
    if (error) {
      var _error

      if (error.type === 'encoding.unsupported') {
        // echo back charset
        _error = createError(415, 'unsupported charset "' + encoding.toUpperCase() + '"', {
          charset: encoding.toLowerCase(),
          type: 'charset.unsupported'
        })
      } else {
        // set status code on error
        _error = createError(400, error)
      }

      // unpipe from stream and destroy
      if (stream !== req) {
        unpipe(req)
        destroy(stream, true)
      }

      // read off entire request
      dump(req, function onfinished () {
        next(createError(400, _error))
      })
      return
    }

    // verify
    if (verify) {
      try {
        debug('verify body')
        verify(req, res, body, encoding)
      } catch (err) {
        next(createError(403, err, {
          body: body,
          type: err.type || 'entity.verify.failed'
        }))
        return
      }
    }

    // parse
    var str = body
    try {
      debug('parse body')
      str = typeof body !== 'string' && encoding !== null
        ? iconv.decode(body, encoding)
        : body
      req.body = parse(str)
    } catch (err) {
      next(createError(400, err, {
        body: str,
        type: err.type || 'entity.parse.failed'
      }))
      return
    }

    next()
  })
}

/**
 * Get the content stream of the request.
 *
 * @param {object} req
 * @param {function} debug
 * @param {boolean} [inflate=true]
 * @return {object}
 * @api private
 */

function contentstream (req, debug, inflate) {
  var encoding = (req.headers['content-encoding'] || 'identity').toLowerCase()
  var length = req.headers['content-length']
  var stream

  debug('content-encoding "%s"', encoding)

  if (inflate === false && encoding !== 'identity') {
    throw createError(415, 'content encoding unsupported', {
      encoding: encoding,
      type: 'encoding.unsupported'
    })
  }

  switch (encoding) {
    case 'deflate':
      stream = zlib.createInflate()
      debug('inflate body')
      req.pipe(stream)
      break
    case 'gzip':
      stream = zlib.createGunzip()
      debug('gunzip body')
      req.pipe(stream)
      break
    case 'identity':
      stream = req
      stream.length = length
      break
    default:
      throw createError(415, 'unsupported content encoding "' + encoding + '"', {
        encoding: encoding,
        type: 'encoding.unsupported'
      })
  }

  return stream
}

/**
 * Dump the contents of a request.
 *
 * @param {object} req
 * @param {function} callback
 * @api private
 */

function dump (req, callback) {
  if (onFinished.isFinished(req)) {
    callback(null)
  } else {
    onFinished(req, callback)
    req.resume()
  }
}


/***/ }),

/***/ 72162:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";
/*!
 * body-parser
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module dependencies.
 * @private
 */

var bytes = __nccwpck_require__(34531)
var contentType = __nccwpck_require__(20756)
var createError = __nccwpck_require__(78024)
var debug = __nccwpck_require__(67646)('body-parser:json')
var read = __nccwpck_require__(27946)
var typeis = __nccwpck_require__(27323)

/**
 * Module exports.
 */

module.exports = json

/**
 * RegExp to match the first non-space in a string.
 *
 * Allowed whitespace is defined in RFC 7159:
 *
 *    ws = *(
 *            %x20 /              ; Space
 *            %x09 /              ; Horizontal tab
 *            %x0A /              ; Line feed or New line
 *            %x0D )              ; Carriage return
 */

var FIRST_CHAR_REGEXP = /^[\x20\x09\x0a\x0d]*([^\x20\x09\x0a\x0d])/ // eslint-disable-line no-control-regex

var JSON_SYNTAX_CHAR = '#'
var JSON_SYNTAX_REGEXP = /#+/g

/**
 * Create a middleware to parse JSON bodies.
 *
 * @param {object} [options]
 * @return {function}
 * @public
 */

function json (options) {
  var opts = options || {}

  var limit = typeof opts.limit !== 'number'
    ? bytes.parse(opts.limit || '100kb')
    : opts.limit
  var inflate = opts.inflate !== false
  var reviver = opts.reviver
  var strict = opts.strict !== false
  var type = opts.type || 'application/json'
  var verify = opts.verify || false

  if (verify !== false && typeof verify !== 'function') {
    throw new TypeError('option verify must be function')
  }

  // create the appropriate type checking function
  var shouldParse = typeof type !== 'function'
    ? typeChecker(type)
    : type

  function parse (body) {
    if (body.length === 0) {
      // special-case empty json body, as it's a common client-side mistake
      // TODO: maybe make this configurable or part of "strict" option
      return {}
    }

    if (strict) {
      var first = firstchar(body)

      if (first !== '{' && first !== '[') {
        debug('strict violation')
        throw createStrictSyntaxError(body, first)
      }
    }

    try {
      debug('parse json')
      return JSON.parse(body, reviver)
    } catch (e) {
      throw normalizeJsonSyntaxError(e, {
        message: e.message,
        stack: e.stack
      })
    }
  }

  return function jsonParser (req, res, next) {
    if (req._body) {
      debug('body already parsed')
      next()
      return
    }

    req.body = req.body || {}

    // skip requests without bodies
    if (!typeis.hasBody(req)) {
      debug('skip empty body')
      next()
      return
    }

    debug('content-type %j', req.headers['content-type'])

    // determine if request should be parsed
    if (!shouldParse(req)) {
      debug('skip parsing')
      next()
      return
    }

    // assert charset per RFC 7159 sec 8.1
    var charset = getCharset(req) || 'utf-8'
    if (charset.slice(0, 4) !== 'utf-') {
      debug('invalid charset')
      next(createError(415, 'unsupported charset "' + charset.toUpperCase() + '"', {
        charset: charset,
        type: 'charset.unsupported'
      }))
      return
    }

    // read
    read(req, res, next, parse, debug, {
      encoding: charset,
      inflate: inflate,
      limit: limit,
      verify: verify
    })
  }
}

/**
 * Create strict violation syntax error matching native error.
 *
 * @param {string} str
 * @param {string} char
 * @return {Error}
 * @private
 */

function createStrictSyntaxError (str, char) {
  var index = str.indexOf(char)
  var partial = ''

  if (index !== -1) {
    partial = str.substring(0, index) + JSON_SYNTAX_CHAR

    for (var i = index + 1; i < str.length; i++) {
      partial += JSON_SYNTAX_CHAR
    }
  }

  try {
    JSON.parse(partial); /* istanbul ignore next */ throw new SyntaxError('strict violation')
  } catch (e) {
    return normalizeJsonSyntaxError(e, {
      message: e.message.replace(JSON_SYNTAX_REGEXP, function (placeholder) {
        return str.substring(index, index + placeholder.length)
      }),
      stack: e.stack
    })
  }
}

/**
 * Get the first non-whitespace character in a string.
 *
 * @param {string} str
 * @return {function}
 * @private
 */

function firstchar (str) {
  var match = FIRST_CHAR_REGEXP.exec(str)

  return match
    ? match[1]
    : undefined
}

/**
 * Get the charset of a request.
 *
 * @param {object} req
 * @api private
 */

function getCharset (req) {
  try {
    return (contentType.parse(req).parameters.charset || '').toLowerCase()
  } catch (e) {
    return undefined
  }
}

/**
 * Normalize a SyntaxError for JSON.parse.
 *
 * @param {SyntaxError} error
 * @param {object} obj
 * @return {SyntaxError}
 */

function normalizeJsonSyntaxError (error, obj) {
  var keys = Object.getOwnPropertyNames(error)

  for (var i = 0; i < keys.length; i++) {
    var key = keys[i]
    if (key !== 'stack' && key !== 'message') {
      delete error[key]
    }
  }

  // replace stack before message for Node.js 0.10 and below
  error.stack = obj.stack.replace(error.message, obj.message)
  error.message = obj.message

  return error
}

/**
 * Get the simple type checker.
 *
 * @param {string} type
 * @return {function}
 */

function typeChecker (type) {
  return function checkType (req) {
    return Boolean(typeis(req, type))
  }
}


/***/ }),

/***/ 8496:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";
/*!
 * body-parser
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module dependencies.
 */

var bytes = __nccwpck_require__(34531)
var debug = __nccwpck_require__(67646)('body-parser:raw')
var read = __nccwpck_require__(27946)
var typeis = __nccwpck_require__(27323)

/**
 * Module exports.
 */

module.exports = raw

/**
 * Create a middleware to parse raw bodies.
 *
 * @param {object} [options]
 * @return {function}
 * @api public
 */

function raw (options) {
  var opts = options || {}

  var inflate = opts.inflate !== false
  var limit = typeof opts.limit !== 'number'
    ? bytes.parse(opts.limit || '100kb')
    : opts.limit
  var type = opts.type || 'application/octet-stream'
  var verify = opts.verify || false

  if (verify !== false && typeof verify !== 'function') {
    throw new TypeError('option verify must be function')
  }

  // create the appropriate type checking function
  var shouldParse = typeof type !== 'function'
    ? typeChecker(type)
    : type

  function parse (buf) {
    return buf
  }

  return function rawParser (req, res, next) {
    if (req._body) {
      debug('body already parsed')
      next()
      return
    }

    req.body = req.body || {}

    // skip requests without bodies
    if (!typeis.hasBody(req)) {
      debug('skip empty body')
      next()
      return
    }

    debug('content-type %j', req.headers['content-type'])

    // determine if request should be parsed
    if (!shouldParse(req)) {
      debug('skip parsing')
      next()
      return
    }

    // read
    read(req, res, next, parse, debug, {
      encoding: null,
      inflate: inflate,
      limit: limit,
      verify: verify
    })
  }
}

/**
 * Get the simple type checker.
 *
 * @param {string} type
 * @return {function}
 */

function typeChecker (type) {
  return function checkType (req) {
    return Boolean(typeis(req, type))
  }
}


/***/ }),

/***/ 17211:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";
/*!
 * body-parser
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module dependencies.
 */

var bytes = __nccwpck_require__(34531)
var contentType = __nccwpck_require__(20756)
var debug = __nccwpck_require__(67646)('body-parser:text')
var read = __nccwpck_require__(27946)
var typeis = __nccwpck_require__(27323)

/**
 * Module exports.
 */

module.exports = text

/**
 * Create a middleware to parse text bodies.
 *
 * @param {object} [options]
 * @return {function}
 * @api public
 */

function text (options) {
  var opts = options || {}

  var defaultCharset = opts.defaultCharset || 'utf-8'
  var inflate = opts.inflate !== false
  var limit = typeof opts.limit !== 'number'
    ? bytes.parse(opts.limit || '100kb')
    : opts.limit
  var type = opts.type || 'text/plain'
  var verify = opts.verify || false

  if (verify !== false && typeof verify !== 'function') {
    throw new TypeError('option verify must be function')
  }

  // create the appropriate type checking function
  var shouldParse = typeof type !== 'function'
    ? typeChecker(type)
    : type

  function parse (buf) {
    return buf
  }

  return function textParser (req, res, next) {
    if (req._body) {
      debug('body already parsed')
      next()
      return
    }

    req.body = req.body || {}

    // skip requests without bodies
    if (!typeis.hasBody(req)) {
      debug('skip empty body')
      next()
      return
    }

    debug('content-type %j', req.headers['content-type'])

    // determine if request should be parsed
    if (!shouldParse(req)) {
      debug('skip parsing')
      next()
      return
    }

    // get charset
    var charset = getCharset(req) || defaultCharset

    // read
    read(req, res, next, parse, debug, {
      encoding: charset,
      inflate: inflate,
      limit: limit,
      verify: verify
    })
  }
}

/**
 * Get the charset of a request.
 *
 * @param {object} req
 * @api private
 */

function getCharset (req) {
  try {
    return (contentType.parse(req).parameters.charset || '').toLowerCase()
  } catch (e) {
    return undefined
  }
}

/**
 * Get the simple type checker.
 *
 * @param {string} type
 * @return {function}
 */

function typeChecker (type) {
  return function checkType (req) {
    return Boolean(typeis(req, type))
  }
}


/***/ }),

/***/ 17129:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";
/*!
 * body-parser
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module dependencies.
 * @private
 */

var bytes = __nccwpck_require__(34531)
var contentType = __nccwpck_require__(20756)
var createError = __nccwpck_require__(78024)
var debug = __nccwpck_require__(67646)('body-parser:urlencoded')
var deprecate = __nccwpck_require__(60095)('body-parser')
var read = __nccwpck_require__(27946)
var typeis = __nccwpck_require__(27323)

/**
 * Module exports.
 */

module.exports = urlencoded

/**
 * Cache of parser modules.
 */

var parsers = Object.create(null)

/**
 * Create a middleware to parse urlencoded bodies.
 *
 * @param {object} [options]
 * @return {function}
 * @public
 */

function urlencoded (options) {
  var opts = options || {}

  // notice because option default will flip in next major
  if (opts.extended === undefined) {
    deprecate('undefined extended: provide extended option')
  }

  var extended = opts.extended !== false
  var inflate = opts.inflate !== false
  var limit = typeof opts.limit !== 'number'
    ? bytes.parse(opts.limit || '100kb')
    : opts.limit
  var type = opts.type || 'application/x-www-form-urlencoded'
  var verify = opts.verify || false
  var depth = typeof opts.depth !== 'number'
    ? Number(opts.depth || 32)
    : opts.depth

  if (verify !== false && typeof verify !== 'function') {
    throw new TypeError('option verify must be function')
  }

  // create the appropriate query parser
  var queryparse = extended
    ? extendedparser(opts)
    : simpleparser(opts)

  // create the appropriate type checking function
  var shouldParse = typeof type !== 'function'
    ? typeChecker(type)
    : type

  function parse (body) {
    return body.length
      ? queryparse(body)
      : {}
  }

  return function urlencodedParser (req, res, next) {
    if (req._body) {
      debug('body already parsed')
      next()
      return
    }

    req.body = req.body || {}

    // skip requests without bodies
    if (!typeis.hasBody(req)) {
      debug('skip empty body')
      next()
      return
    }

    debug('content-type %j', req.headers['content-type'])

    // determine if request should be parsed
    if (!shouldParse(req)) {
      debug('skip parsing')
      next()
      return
    }

    // assert charset
    var charset = getCharset(req) || 'utf-8'
    if (charset !== 'utf-8') {
      debug('invalid charset')
      next(createError(415, 'unsupported charset "' + charset.toUpperCase() + '"', {
        charset: charset,
        type: 'charset.unsupported'
      }))
      return
    }

    // read
    read(req, res, next, parse, debug, {
      debug: debug,
      encoding: charset,
      inflate: inflate,
      limit: limit,
      verify: verify,
      depth: depth
    })
  }
}

/**
 * Get the extended query parser.
 *
 * @param {object} options
 */

function extendedparser (options) {
  var parameterLimit = options.parameterLimit !== undefined
    ? options.parameterLimit
    : 1000

  var depth = typeof options.depth !== 'number'
    ? Number(options.depth || 32)
    : options.depth
  var parse = parser('qs')

  if (isNaN(parameterLimit) || parameterLimit < 1) {
    throw new TypeError('option parameterLimit must be a positive number')
  }

  if (isNaN(depth) || depth < 0) {
    throw new TypeError('option depth must be a zero or a positive number')
  }

  if (isFinite(parameterLimit)) {
    parameterLimit = parameterLimit | 0
  }

  return function queryparse (body) {
    var paramCount = parameterCount(body, parameterLimit)

    if (paramCount === undefined) {
      debug('too many parameters')
      throw createError(413, 'too many parameters', {
        type: 'parameters.too.many'
      })
    }

    var arrayLimit = Math.max(100, paramCount)

    debug('parse extended urlencoding')
    try {
      return parse(body, {
        allowPrototypes: true,
        arrayLimit: arrayLimit,
        depth: depth,
        strictDepth: true,
        parameterLimit: parameterLimit
      })
    } catch (err) {
      if (err instanceof RangeError) {
        throw createError(400, 'The input exceeded the depth', {
          type: 'querystring.parse.rangeError'
        })
      } else {
        throw err
      }
    }
  }
}

/**
 * Get the charset of a request.
 *
 * @param {object} req
 * @api private
 */

function getCharset (req) {
  try {
    return (contentType.parse(req).parameters.charset || '').toLowerCase()
  } catch (e) {
    return undefined
  }
}

/**
 * Count the number of parameters, stopping once limit reached
 *
 * @param {string} body
 * @param {number} limit
 * @api private
 */

function parameterCount (body, limit) {
  var count = 0
  var index = 0

  while ((index = body.indexOf('&', index)) !== -1) {
    count++
    index++

    if (count === limit) {
      return undefined
    }
  }

  return count
}

/**
 * Get parser for module name dynamically.
 *
 * @param {string} name
 * @return {function}
 * @api private
 */

function parser (name) {
  var mod = parsers[name]

  if (mod !== undefined) {
    return mod.parse
  }

  // this uses a switch for static require analysis
  switch (name) {
    case 'qs':
      mod = __nccwpck_require__(40240)
      break
    case 'querystring':
      mod = __nccwpck_require__(83480)
      break
  }

  // store to prevent invoking require()
  parsers[name] = mod

  return mod.parse
}

/**
 * Get the simple query parser.
 *
 * @param {object} options
 */

function simpleparser (options) {
  var parameterLimit = options.parameterLimit !== undefined
    ? options.parameterLimit
    : 1000
  var parse = parser('querystring')

  if (isNaN(parameterLimit) || parameterLimit < 1) {
    throw new TypeError('option parameterLimit must be a positive number')
  }

  if (isFinite(parameterLimit)) {
    parameterLimit = parameterLimit | 0
  }

  return function queryparse (body) {
    var paramCount = parameterCount(body, parameterLimit)

    if (paramCount === undefined) {
      debug('too many parameters')
      throw createError(413, 'too many parameters', {
        type: 'parameters.too.many'
      })
    }

    debug('parse urlencoding')
    return parse(body, undefined, undefined, { maxKeys: parameterLimit })
  }
}

/**
 * Get the simple type checker.
 *
 * @param {string} type
 * @return {function}
 */

function typeChecker (type) {
  return function checkType (req) {
    return Boolean(typeis(req, type))
  }
}


/***/ }),

/***/ 64878:
/***/ ((module, exports, __nccwpck_require__) => {

/**
 * This is the web browser implementation of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = __nccwpck_require__(35769);
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = 'undefined' != typeof chrome
               && 'undefined' != typeof chrome.storage
                  ? chrome.storage.local
                  : localstorage();

/**
 * Colors.
 */

exports.colors = [
  'lightseagreen',
  'forestgreen',
  'goldenrod',
  'dodgerblue',
  'darkorchid',
  'crimson'
];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

function useColors() {
  // NB: In an Electron preload script, document will be defined but not fully
  // initialized. Since we know we're in Chrome, we'll just detect this case
  // explicitly
  if (typeof window !== 'undefined' && window.process && window.process.type === 'renderer') {
    return true;
  }

  // is webkit? http://stackoverflow.com/a/16459606/376773
  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
  return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||
    // is firebug? http://stackoverflow.com/a/398120/376773
    (typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||
    // is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||
    // double check webkit in userAgent just in case we are in a worker
    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/));
}

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

exports.formatters.j = function(v) {
  try {
    return JSON.stringify(v);
  } catch (err) {
    return '[UnexpectedJSONParseError]: ' + err.message;
  }
};


/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs(args) {
  var useColors = this.useColors;

  args[0] = (useColors ? '%c' : '')
    + this.namespace
    + (useColors ? ' %c' : ' ')
    + args[0]
    + (useColors ? '%c ' : ' ')
    + '+' + exports.humanize(this.diff);

  if (!useColors) return;

  var c = 'color: ' + this.color;
  args.splice(1, 0, c, 'color: inherit')

  // the final "%c" is somewhat tricky, because there could be other
  // arguments passed either before or after the %c, so we need to
  // figure out the correct index to insert the CSS into
  var index = 0;
  var lastC = 0;
  args[0].replace(/%[a-zA-Z%]/g, function(match) {
    if ('%%' === match) return;
    index++;
    if ('%c' === match) {
      // we only are interested in the *last* %c
      // (the user may have provided their own)
      lastC = index;
    }
  });

  args.splice(lastC, 0, c);
}

/**
 * Invokes `console.log()` when available.
 * No-op when `console.log` is not a "function".
 *
 * @api public
 */

function log() {
  // this hackery is required for IE8/9, where
  // the `console.log` function doesn't have 'apply'
  return 'object' === typeof console
    && console.log
    && Function.prototype.apply.call(console.log, console, arguments);
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */

function save(namespaces) {
  try {
    if (null == namespaces) {
      exports.storage.removeItem('debug');
    } else {
      exports.storage.debug = namespaces;
    }
  } catch(e) {}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

function load() {
  var r;
  try {
    r = exports.storage.debug;
  } catch(e) {}

  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG
  if (!r && typeof process !== 'undefined' && 'env' in process) {
    r = process.env.DEBUG;
  }

  return r;
}

/**
 * Enable namespaces listed in `localStorage.debug` initially.
 */

exports.enable(load());

/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */

function localstorage() {
  try {
    return window.localStorage;
  } catch (e) {}
}


/***/ }),

/***/ 35769:
/***/ ((module, exports, __nccwpck_require__) => {


/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = createDebug.debug = createDebug['default'] = createDebug;
exports.coerce = coerce;
exports.disable = disable;
exports.enable = enable;
exports.enabled = enabled;
exports.humanize = __nccwpck_require__(2888);

/**
 * The currently active debug mode names, and names to skip.
 */

exports.names = [];
exports.skips = [];

/**
 * Map of special "%n" handling functions, for the debug "format" argument.
 *
 * Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
 */

exports.formatters = {};

/**
 * Previous log timestamp.
 */

var prevTime;

/**
 * Select a color.
 * @param {String} namespace
 * @return {Number}
 * @api private
 */

function selectColor(namespace) {
  var hash = 0, i;

  for (i in namespace) {
    hash  = ((hash << 5) - hash) + namespace.charCodeAt(i);
    hash |= 0; // Convert to 32bit integer
  }

  return exports.colors[Math.abs(hash) % exports.colors.length];
}

/**
 * Create a debugger with the given `namespace`.
 *
 * @param {String} namespace
 * @return {Function}
 * @api public
 */

function createDebug(namespace) {

  function debug() {
    // disabled?
    if (!debug.enabled) return;

    var self = debug;

    // set `diff` timestamp
    var curr = +new Date();
    var ms = curr - (prevTime || curr);
    self.diff = ms;
    self.prev = prevTime;
    self.curr = curr;
    prevTime = curr;

    // turn the `arguments` into a proper Array
    var args = new Array(arguments.length);
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i];
    }

    args[0] = exports.coerce(args[0]);

    if ('string' !== typeof args[0]) {
      // anything else let's inspect with %O
      args.unshift('%O');
    }

    // apply any `formatters` transformations
    var index = 0;
    args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {
      // if we encounter an escaped % then don't increase the array index
      if (match === '%%') return match;
      index++;
      var formatter = exports.formatters[format];
      if ('function' === typeof formatter) {
        var val = args[index];
        match = formatter.call(self, val);

        // now we need to remove `args[index]` since it's inlined in the `format`
        args.splice(index, 1);
        index--;
      }
      return match;
    });

    // apply env-specific formatting (colors, etc.)
    exports.formatArgs.call(self, args);

    var logFn = debug.log || exports.log || console.log.bind(console);
    logFn.apply(self, args);
  }

  debug.namespace = namespace;
  debug.enabled = exports.enabled(namespace);
  debug.useColors = exports.useColors();
  debug.color = selectColor(namespace);

  // env-specific initialization logic for debug instances
  if ('function' === typeof exports.init) {
    exports.init(debug);
  }

  return debug;
}

/**
 * Enables a debug mode by namespaces. This can include modes
 * separated by a colon and wildcards.
 *
 * @param {String} namespaces
 * @api public
 */

function enable(namespaces) {
  exports.save(namespaces);

  exports.names = [];
  exports.skips = [];

  var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
  var len = split.length;

  for (var i = 0; i < len; i++) {
    if (!split[i]) continue; // ignore empty strings
    namespaces = split[i].replace(/\*/g, '.*?');
    if (namespaces[0] === '-') {
      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
    } else {
      exports.names.push(new RegExp('^' + namespaces + '$'));
    }
  }
}

/**
 * Disable debug output.
 *
 * @api public
 */

function disable() {
  exports.enable('');
}

/**
 * Returns true if the given mode name is enabled, false otherwise.
 *
 * @param {String} name
 * @return {Boolean}
 * @api public
 */

function enabled(name) {
  var i, len;
  for (i = 0, len = exports.skips.length; i < len; i++) {
    if (exports.skips[i].test(name)) {
      return false;
    }
  }
  for (i = 0, len = exports.names.length; i < len; i++) {
    if (exports.names[i].test(name)) {
      return true;
    }
  }
  return false;
}

/**
 * Coerce `val`.
 *
 * @param {Mixed} val
 * @return {Mixed}
 * @api private
 */

function coerce(val) {
  if (val instanceof Error) return val.stack || val.message;
  return val;
}


/***/ }),

/***/ 67646:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

/**
 * Detect Electron renderer process, which is node, but we should
 * treat as a browser.
 */

if (typeof process !== 'undefined' && process.type === 'renderer') {
  module.exports = __nccwpck_require__(64878);
} else {
  module.exports = __nccwpck_require__(51796);
}


/***/ }),

/***/ 51796:
/***/ ((module, exports, __nccwpck_require__) => {

/**
 * Module dependencies.
 */

var tty = __nccwpck_require__(52018);
var util = __nccwpck_require__(39023);

/**
 * This is the Node.js implementation of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = __nccwpck_require__(35769);
exports.init = init;
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;

/**
 * Colors.
 */

exports.colors = [6, 2, 3, 4, 5, 1];

/**
 * Build up the default `inspectOpts` object from the environment variables.
 *
 *   $ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js
 */

exports.inspectOpts = Object.keys(process.env).filter(function (key) {
  return /^debug_/i.test(key);
}).reduce(function (obj, key) {
  // camel-case
  var prop = key
    .substring(6)
    .toLowerCase()
    .replace(/_([a-z])/g, function (_, k) { return k.toUpperCase() });

  // coerce string value into JS value
  var val = process.env[key];
  if (/^(yes|on|true|enabled)$/i.test(val)) val = true;
  else if (/^(no|off|false|disabled)$/i.test(val)) val = false;
  else if (val === 'null') val = null;
  else val = Number(val);

  obj[prop] = val;
  return obj;
}, {});

/**
 * The file descriptor to write the `debug()` calls to.
 * Set the `DEBUG_FD` env variable to override with another value. i.e.:
 *
 *   $ DEBUG_FD=3 node script.js 3>debug.log
 */

var fd = parseInt(process.env.DEBUG_FD, 10) || 2;

if (1 !== fd && 2 !== fd) {
  util.deprecate(function(){}, 'except for stderr(2) and stdout(1), any other usage of DEBUG_FD is deprecated. Override debug.log if you want to use a different log function (https://git.io/debug_fd)')()
}

var stream = 1 === fd ? process.stdout :
             2 === fd ? process.stderr :
             createWritableStdioStream(fd);

/**
 * Is stdout a TTY? Colored output is enabled when `true`.
 */

function useColors() {
  return 'colors' in exports.inspectOpts
    ? Boolean(exports.inspectOpts.colors)
    : tty.isatty(fd);
}

/**
 * Map %o to `util.inspect()`, all on a single line.
 */

exports.formatters.o = function(v) {
  this.inspectOpts.colors = this.useColors;
  return util.inspect(v, this.inspectOpts)
    .split('\n').map(function(str) {
      return str.trim()
    }).join(' ');
};

/**
 * Map %o to `util.inspect()`, allowing multiple lines if needed.
 */

exports.formatters.O = function(v) {
  this.inspectOpts.colors = this.useColors;
  return util.inspect(v, this.inspectOpts);
};

/**
 * Adds ANSI color escape codes if enabled.
 *
 * @api public
 */

function formatArgs(args) {
  var name = this.namespace;
  var useColors = this.useColors;

  if (useColors) {
    var c = this.color;
    var prefix = '  \u001b[3' + c + ';1m' + name + ' ' + '\u001b[0m';

    args[0] = prefix + args[0].split('\n').join('\n' + prefix);
    args.push('\u001b[3' + c + 'm+' + exports.humanize(this.diff) + '\u001b[0m');
  } else {
    args[0] = new Date().toUTCString()
      + ' ' + name + ' ' + args[0];
  }
}

/**
 * Invokes `util.format()` with the specified arguments and writes to `stream`.
 */

function log() {
  return stream.write(util.format.apply(util, arguments) + '\n');
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */

function save(namespaces) {
  if (null == namespaces) {
    // If you set a process.env field to null or undefined, it gets cast to the
    // string 'null' or 'undefined'. Just delete instead.
    delete process.env.DEBUG;
  } else {
    process.env.DEBUG = namespaces;
  }
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

function load() {
  return process.env.DEBUG;
}

/**
 * Copied from `node/src/node.js`.
 *
 * XXX: It's lame that node doesn't expose this API out-of-the-box. It also
 * relies on the undocumented `tty_wrap.guessHandleType()` which is also lame.
 */

function createWritableStdioStream (fd) {
  var stream;
  var tty_wrap = process.binding('tty_wrap');

  // Note stream._type is used for test-module-load-list.js

  switch (tty_wrap.guessHandleType(fd)) {
    case 'TTY':
      stream = new tty.WriteStream(fd);
      stream._type = 'tty';

      // Hack to have stream not keep the event loop alive.
      // See https://github.com/joyent/node/issues/1726
      if (stream._handle && stream._handle.unref) {
        stream._handle.unref();
      }
      break;

    case 'FILE':
      var fs = __nccwpck_require__(79896);
      stream = new fs.SyncWriteStream(fd, { autoClose: false });
      stream._type = 'fs';
      break;

    case 'PIPE':
    case 'TCP':
      var net = __nccwpck_require__(69278);
      stream = new net.Socket({
        fd: fd,
        readable: false,
        writable: true
      });

      // FIXME Should probably have an option in net.Socket to create a
      // stream from an existing fd which is writable only. But for now
      // we'll just add this hack and set the `readable` member to false.
      // Test: ./node test/fixtures/echo.js < /etc/passwd
      stream.readable = false;
      stream.read = null;
      stream._type = 'pipe';

      // FIXME Hack to have stream not keep the event loop alive.
      // See https://github.com/joyent/node/issues/1726
      if (stream._handle && stream._handle.unref) {
        stream._handle.unref();
      }
      break;

    default:
      // Probably an error on in uv_guess_handle()
      throw new Error('Implement me. Unknown stream file type!');
  }

  // For supporting legacy API we put the FD here.
  stream.fd = fd;

  stream._isStdio = true;

  return stream;
}

/**
 * Init logic for `debug` instances.
 *
 * Create a new `inspectOpts` object in case `useColors` is set
 * differently for a particular `debug` instance.
 */

function init (debug) {
  debug.inspectOpts = {};

  var keys = Object.keys(exports.inspectOpts);
  for (var i = 0; i < keys.length; i++) {
    debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
  }
}

/**
 * Enable namespaces listed in `process.env.DEBUG` initially.
 */

exports.enable(load());


/***/ }),

/***/ 72794:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

var Buffer = (__nccwpck_require__(12803).Buffer);

// Multibyte codec. In this scheme, a character is represented by 1 or more bytes.
// Our codec supports UTF-16 surrogates, extensions for GB18030 and unicode sequences.
// To save memory and loading time, we read table files only when requested.

exports._dbcs = DBCSCodec;

var UNASSIGNED = -1,
    GB18030_CODE = -2,
    SEQ_START  = -10,
    NODE_START = -1000,
    UNASSIGNED_NODE = new Array(0x100),
    DEF_CHAR = -1;

for (var i = 0; i < 0x100; i++)
    UNASSIGNED_NODE[i] = UNASSIGNED;


// Class DBCSCodec reads and initializes mapping tables.
function DBCSCodec(codecOptions, iconv) {
    this.encodingName = codecOptions.encodingName;
    if (!codecOptions)
        throw new Error("DBCS codec is called without the data.")
    if (!codecOptions.table)
        throw new Error("Encoding '" + this.encodingName + "' has no data.");

    // Load tables.
    var mappingTable = codecOptions.table();


    // Decode tables: MBCS -> Unicode.

    // decodeTables is a trie, encoded as an array of arrays of integers. Internal arrays are trie nodes and all have len = 256.
    // Trie root is decodeTables[0].
    // Values: >=  0 -> unicode character code. can be > 0xFFFF
    //         == UNASSIGNED -> unknown/unassigned sequence.
    //         == GB18030_CODE -> this is the end of a GB18030 4-byte sequence.
    //         <= NODE_START -> index of the next node in our trie to process next byte.
    //         <= SEQ_START  -> index of the start of a character code sequence, in decodeTableSeq.
    this.decodeTables = [];
    this.decodeTables[0] = UNASSIGNED_NODE.slice(0); // Create root node.

    // Sometimes a MBCS char corresponds to a sequence of unicode chars. We store them as arrays of integers here. 
    this.decodeTableSeq = [];

    // Actual mapping tables consist of chunks. Use them to fill up decode tables.
    for (var i = 0; i < mappingTable.length; i++)
        this._addDecodeChunk(mappingTable[i]);

    this.defaultCharUnicode = iconv.defaultCharUnicode;

    
    // Encode tables: Unicode -> DBCS.

    // `encodeTable` is array mapping from unicode char to encoded char. All its values are integers for performance.
    // Because it can be sparse, it is represented as array of buckets by 256 chars each. Bucket can be null.
    // Values: >=  0 -> it is a normal char. Write the value (if <=256 then 1 byte, if <=65536 then 2 bytes, etc.).
    //         == UNASSIGNED -> no conversion found. Output a default char.
    //         <= SEQ_START  -> it's an index in encodeTableSeq, see below. The character starts a sequence.
    this.encodeTable = [];
    
    // `encodeTableSeq` is used when a sequence of unicode characters is encoded as a single code. We use a tree of
    // objects where keys correspond to characters in sequence and leafs are the encoded dbcs values. A special DEF_CHAR key
    // means end of sequence (needed when one sequence is a strict subsequence of another).
    // Objects are kept separately from encodeTable to increase performance.
    this.encodeTableSeq = [];

    // Some chars can be decoded, but need not be encoded.
    var skipEncodeChars = {};
    if (codecOptions.encodeSkipVals)
        for (var i = 0; i < codecOptions.encodeSkipVals.length; i++) {
            var val = codecOptions.encodeSkipVals[i];
            if (typeof val === 'number')
                skipEncodeChars[val] = true;
            else
                for (var j = val.from; j <= val.to; j++)
                    skipEncodeChars[j] = true;
        }
        
    // Use decode trie to recursively fill out encode tables.
    this._fillEncodeTable(0, 0, skipEncodeChars);

    // Add more encoding pairs when needed.
    if (codecOptions.encodeAdd) {
        for (var uChar in codecOptions.encodeAdd)
            if (Object.prototype.hasOwnProperty.call(codecOptions.encodeAdd, uChar))
                this._setEncodeChar(uChar.charCodeAt(0), codecOptions.encodeAdd[uChar]);
    }

    this.defCharSB  = this.encodeTable[0][iconv.defaultCharSingleByte.charCodeAt(0)];
    if (this.defCharSB === UNASSIGNED) this.defCharSB = this.encodeTable[0]['?'];
    if (this.defCharSB === UNASSIGNED) this.defCharSB = "?".charCodeAt(0);


    // Load & create GB18030 tables when needed.
    if (typeof codecOptions.gb18030 === 'function') {
        this.gb18030 = codecOptions.gb18030(); // Load GB18030 ranges.

        // Add GB18030 decode tables.
        var thirdByteNodeIdx = this.decodeTables.length;
        var thirdByteNode = this.decodeTables[thirdByteNodeIdx] = UNASSIGNED_NODE.slice(0);

        var fourthByteNodeIdx = this.decodeTables.length;
        var fourthByteNode = this.decodeTables[fourthByteNodeIdx] = UNASSIGNED_NODE.slice(0);

        for (var i = 0x81; i <= 0xFE; i++) {
            var secondByteNodeIdx = NODE_START - this.decodeTables[0][i];
            var secondByteNode = this.decodeTables[secondByteNodeIdx];
            for (var j = 0x30; j <= 0x39; j++)
                secondByteNode[j] = NODE_START - thirdByteNodeIdx;
        }
        for (var i = 0x81; i <= 0xFE; i++)
            thirdByteNode[i] = NODE_START - fourthByteNodeIdx;
        for (var i = 0x30; i <= 0x39; i++)
            fourthByteNode[i] = GB18030_CODE
    }        
}

DBCSCodec.prototype.encoder = DBCSEncoder;
DBCSCodec.prototype.decoder = DBCSDecoder;

// Decoder helpers
DBCSCodec.prototype._getDecodeTrieNode = function(addr) {
    var bytes = [];
    for (; addr > 0; addr >>= 8)
        bytes.push(addr & 0xFF);
    if (bytes.length == 0)
        bytes.push(0);

    var node = this.decodeTables[0];
    for (var i = bytes.length-1; i > 0; i--) { // Traverse nodes deeper into the trie.
        var val = node[bytes[i]];

        if (val == UNASSIGNED) { // Create new node.
            node[bytes[i]] = NODE_START - this.decodeTables.length;
            this.decodeTables.push(node = UNASSIGNED_NODE.slice(0));
        }
        else if (val <= NODE_START) { // Existing node.
            node = this.decodeTables[NODE_START - val];
        }
        else
            throw new Error("Overwrite byte in " + this.encodingName + ", addr: " + addr.toString(16));
    }
    return node;
}


DBCSCodec.prototype._addDecodeChunk = function(chunk) {
    // First element of chunk is the hex mbcs code where we start.
    var curAddr = parseInt(chunk[0], 16);

    // Choose the decoding node where we'll write our chars.
    var writeTable = this._getDecodeTrieNode(curAddr);
    curAddr = curAddr & 0xFF;

    // Write all other elements of the chunk to the table.
    for (var k = 1; k < chunk.length; k++) {
        var part = chunk[k];
        if (typeof part === "string") { // String, write as-is.
            for (var l = 0; l < part.length;) {
                var code = part.charCodeAt(l++);
                if (0xD800 <= code && code < 0xDC00) { // Decode surrogate
                    var codeTrail = part.charCodeAt(l++);
                    if (0xDC00 <= codeTrail && codeTrail < 0xE000)
                        writeTable[curAddr++] = 0x10000 + (code - 0xD800) * 0x400 + (codeTrail - 0xDC00);
                    else
                        throw new Error("Incorrect surrogate pair in "  + this.encodingName + " at chunk " + chunk[0]);
                }
                else if (0x0FF0 < code && code <= 0x0FFF) { // Character sequence (our own encoding used)
                    var len = 0xFFF - code + 2;
                    var seq = [];
                    for (var m = 0; m < len; m++)
                        seq.push(part.charCodeAt(l++)); // Simple variation: don't support surrogates or subsequences in seq.

                    writeTable[curAddr++] = SEQ_START - this.decodeTableSeq.length;
                    this.decodeTableSeq.push(seq);
                }
                else
                    writeTable[curAddr++] = code; // Basic char
            }
        } 
        else if (typeof part === "number") { // Integer, meaning increasing sequence starting with prev character.
            var charCode = writeTable[curAddr - 1] + 1;
            for (var l = 0; l < part; l++)
                writeTable[curAddr++] = charCode++;
        }
        else
            throw new Error("Incorrect type '" + typeof part + "' given in "  + this.encodingName + " at chunk " + chunk[0]);
    }
    if (curAddr > 0xFF)
        throw new Error("Incorrect chunk in "  + this.encodingName + " at addr " + chunk[0] + ": too long" + curAddr);
}

// Encoder helpers
DBCSCodec.prototype._getEncodeBucket = function(uCode) {
    var high = uCode >> 8; // This could be > 0xFF because of astral characters.
    if (this.encodeTable[high] === undefined)
        this.encodeTable[high] = UNASSIGNED_NODE.slice(0); // Create bucket on demand.
    return this.encodeTable[high];
}

DBCSCodec.prototype._setEncodeChar = function(uCode, dbcsCode) {
    var bucket = this._getEncodeBucket(uCode);
    var low = uCode & 0xFF;
    if (bucket[low] <= SEQ_START)
        this.encodeTableSeq[SEQ_START-bucket[low]][DEF_CHAR] = dbcsCode; // There's already a sequence, set a single-char subsequence of it.
    else if (bucket[low] == UNASSIGNED)
        bucket[low] = dbcsCode;
}

DBCSCodec.prototype._setEncodeSequence = function(seq, dbcsCode) {
    
    // Get the root of character tree according to first character of the sequence.
    var uCode = seq[0];
    var bucket = this._getEncodeBucket(uCode);
    var low = uCode & 0xFF;

    var node;
    if (bucket[low] <= SEQ_START) {
        // There's already a sequence with  - use it.
        node = this.encodeTableSeq[SEQ_START-bucket[low]];
    }
    else {
        // There was no sequence object - allocate a new one.
        node = {};
        if (bucket[low] !== UNASSIGNED) node[DEF_CHAR] = bucket[low]; // If a char was set before - make it a single-char subsequence.
        bucket[low] = SEQ_START - this.encodeTableSeq.length;
        this.encodeTableSeq.push(node);
    }

    // Traverse the character tree, allocating new nodes as needed.
    for (var j = 1; j < seq.length-1; j++) {
        var oldVal = node[uCode];
        if (typeof oldVal === 'object')
            node = oldVal;
        else {
            node = node[uCode] = {}
            if (oldVal !== undefined)
                node[DEF_CHAR] = oldVal
        }
    }

    // Set the leaf to given dbcsCode.
    uCode = seq[seq.length-1];
    node[uCode] = dbcsCode;
}

DBCSCodec.prototype._fillEncodeTable = function(nodeIdx, prefix, skipEncodeChars) {
    var node = this.decodeTables[nodeIdx];
    for (var i = 0; i < 0x100; i++) {
        var uCode = node[i];
        var mbCode = prefix + i;
        if (skipEncodeChars[mbCode])
            continue;

        if (uCode >= 0)
            this._setEncodeChar(uCode, mbCode);
        else if (uCode <= NODE_START)
            this._fillEncodeTable(NODE_START - uCode, mbCode << 8, skipEncodeChars);
        else if (uCode <= SEQ_START)
            this._setEncodeSequence(this.decodeTableSeq[SEQ_START - uCode], mbCode);
    }
}



// == Encoder ==================================================================

function DBCSEncoder(options, codec) {
    // Encoder state
    this.leadSurrogate = -1;
    this.seqObj = undefined;
    
    // Static data
    this.encodeTable = codec.encodeTable;
    this.encodeTableSeq = codec.encodeTableSeq;
    this.defaultCharSingleByte = codec.defCharSB;
    this.gb18030 = codec.gb18030;
}

DBCSEncoder.prototype.write = function(str) {
    var newBuf = Buffer.alloc(str.length * (this.gb18030 ? 4 : 3)),
        leadSurrogate = this.leadSurrogate,
        seqObj = this.seqObj, nextChar = -1,
        i = 0, j = 0;

    while (true) {
        // 0. Get next character.
        if (nextChar === -1) {
            if (i == str.length) break;
            var uCode = str.charCodeAt(i++);
        }
        else {
            var uCode = nextChar;
            nextChar = -1;    
        }

        // 1. Handle surrogates.
        if (0xD800 <= uCode && uCode < 0xE000) { // Char is one of surrogates.
            if (uCode < 0xDC00) { // We've got lead surrogate.
                if (leadSurrogate === -1) {
                    leadSurrogate = uCode;
                    continue;
                } else {
                    leadSurrogate = uCode;
                    // Double lead surrogate found.
                    uCode = UNASSIGNED;
                }
            } else { // We've got trail surrogate.
                if (leadSurrogate !== -1) {
                    uCode = 0x10000 + (leadSurrogate - 0xD800) * 0x400 + (uCode - 0xDC00);
                    leadSurrogate = -1;
                } else {
                    // Incomplete surrogate pair - only trail surrogate found.
                    uCode = UNASSIGNED;
                }
                
            }
        }
        else if (leadSurrogate !== -1) {
            // Incomplete surrogate pair - only lead surrogate found.
            nextChar = uCode; uCode = UNASSIGNED; // Write an error, then current char.
            leadSurrogate = -1;
        }

        // 2. Convert uCode character.
        var dbcsCode = UNASSIGNED;
        if (seqObj !== undefined && uCode != UNASSIGNED) { // We are in the middle of the sequence
            var resCode = seqObj[uCode];
            if (typeof resCode === 'object') { // Sequence continues.
                seqObj = resCode;
                continue;

            } else if (typeof resCode == 'number') { // Sequence finished. Write it.
                dbcsCode = resCode;

            } else if (resCode == undefined) { // Current character is not part of the sequence.

                // Try default character for this sequence
                resCode = seqObj[DEF_CHAR];
                if (resCode !== undefined) {
                    dbcsCode = resCode; // Found. Write it.
                    nextChar = uCode; // Current character will be written too in the next iteration.

                } else {
                    // TODO: What if we have no default? (resCode == undefined)
                    // Then, we should write first char of the sequence as-is and try the rest recursively.
                    // Didn't do it for now because no encoding has this situation yet.
                    // Currently, just skip the sequence and write current char.
                }
            }
            seqObj = undefined;
        }
        else if (uCode >= 0) {  // Regular character
            var subtable = this.encodeTable[uCode >> 8];
            if (subtable !== undefined)
                dbcsCode = subtable[uCode & 0xFF];
            
            if (dbcsCode <= SEQ_START) { // Sequence start
                seqObj = this.encodeTableSeq[SEQ_START-dbcsCode];
                continue;
            }

            if (dbcsCode == UNASSIGNED && this.gb18030) {
                // Use GB18030 algorithm to find character(s) to write.
                var idx = findIdx(this.gb18030.uChars, uCode);
                if (idx != -1) {
                    var dbcsCode = this.gb18030.gbChars[idx] + (uCode - this.gb18030.uChars[idx]);
                    newBuf[j++] = 0x81 + Math.floor(dbcsCode / 12600); dbcsCode = dbcsCode % 12600;
                    newBuf[j++] = 0x30 + Math.floor(dbcsCode / 1260); dbcsCode = dbcsCode % 1260;
                    newBuf[j++] = 0x81 + Math.floor(dbcsCode / 10); dbcsCode = dbcsCode % 10;
                    newBuf[j++] = 0x30 + dbcsCode;
                    continue;
                }
            }
        }

        // 3. Write dbcsCode character.
        if (dbcsCode === UNASSIGNED)
            dbcsCode = this.defaultCharSingleByte;
        
        if (dbcsCode < 0x100) {
            newBuf[j++] = dbcsCode;
        }
        else if (dbcsCode < 0x10000) {
            newBuf[j++] = dbcsCode >> 8;   // high byte
            newBuf[j++] = dbcsCode & 0xFF; // low byte
        }
        else {
            newBuf[j++] = dbcsCode >> 16;
            newBuf[j++] = (dbcsCode >> 8) & 0xFF;
            newBuf[j++] = dbcsCode & 0xFF;
        }
    }

    this.seqObj = seqObj;
    this.leadSurrogate = leadSurrogate;
    return newBuf.slice(0, j);
}

DBCSEncoder.prototype.end = function() {
    if (this.leadSurrogate === -1 && this.seqObj === undefined)
        return; // All clean. Most often case.

    var newBuf = Buffer.alloc(10), j = 0;

    if (this.seqObj) { // We're in the sequence.
        var dbcsCode = this.seqObj[DEF_CHAR];
        if (dbcsCode !== undefined) { // Write beginning of the sequence.
            if (dbcsCode < 0x100) {
                newBuf[j++] = dbcsCode;
            }
            else {
                newBuf[j++] = dbcsCode >> 8;   // high byte
                newBuf[j++] = dbcsCode & 0xFF; // low byte
            }
        } else {
            // See todo above.
        }
        this.seqObj = undefined;
    }

    if (this.leadSurrogate !== -1) {
        // Incomplete surrogate pair - only lead surrogate found.
        newBuf[j++] = this.defaultCharSingleByte;
        this.leadSurrogate = -1;
    }
    
    return newBuf.slice(0, j);
}

// Export for testing
DBCSEncoder.prototype.findIdx = findIdx;


// == Decoder ==================================================================

function DBCSDecoder(options, codec) {
    // Decoder state
    this.nodeIdx = 0;
    this.prevBuf = Buffer.alloc(0);

    // Static data
    this.decodeTables = codec.decodeTables;
    this.decodeTableSeq = codec.decodeTableSeq;
    this.defaultCharUnicode = codec.defaultCharUnicode;
    this.gb18030 = codec.gb18030;
}

DBCSDecoder.prototype.write = function(buf) {
    var newBuf = Buffer.alloc(buf.length*2),
        nodeIdx = this.nodeIdx, 
        prevBuf = this.prevBuf, prevBufOffset = this.prevBuf.length,
        seqStart = -this.prevBuf.length, // idx of the start of current parsed sequence.
        uCode;

    if (prevBufOffset > 0) // Make prev buf overlap a little to make it easier to slice later.
        prevBuf = Buffer.concat([prevBuf, buf.slice(0, 10)]);
    
    for (var i = 0, j = 0; i < buf.length; i++) {
        var curByte = (i >= 0) ? buf[i] : prevBuf[i + prevBufOffset];

        // Lookup in current trie node.
        var uCode = this.decodeTables[nodeIdx][curByte];

        if (uCode >= 0) { 
            // Normal character, just use it.
        }
        else if (uCode === UNASSIGNED) { // Unknown char.
            // TODO: Callback with seq.
            //var curSeq = (seqStart >= 0) ? buf.slice(seqStart, i+1) : prevBuf.slice(seqStart + prevBufOffset, i+1 + prevBufOffset);
            i = seqStart; // Try to parse again, after skipping first byte of the sequence ('i' will be incremented by 'for' cycle).
            uCode = this.defaultCharUnicode.charCodeAt(0);
        }
        else if (uCode === GB18030_CODE) {
            var curSeq = (seqStart >= 0) ? buf.slice(seqStart, i+1) : prevBuf.slice(seqStart + prevBufOffset, i+1 + prevBufOffset);
            var ptr = (curSeq[0]-0x81)*12600 + (curSeq[1]-0x30)*1260 + (curSeq[2]-0x81)*10 + (curSeq[3]-0x30);
            var idx = findIdx(this.gb18030.gbChars, ptr);
            uCode = this.gb18030.uChars[idx] + ptr - this.gb18030.gbChars[idx];
        }
        else if (uCode <= NODE_START) { // Go to next trie node.
            nodeIdx = NODE_START - uCode;
            continue;
        }
        else if (uCode <= SEQ_START) { // Output a sequence of chars.
            var seq = this.decodeTableSeq[SEQ_START - uCode];
            for (var k = 0; k < seq.length - 1; k++) {
                uCode = seq[k];
                newBuf[j++] = uCode & 0xFF;
                newBuf[j++] = uCode >> 8;
            }
            uCode = seq[seq.length-1];
        }
        else
            throw new Error("iconv-lite internal error: invalid decoding table value " + uCode + " at " + nodeIdx + "/" + curByte);

        // Write the character to buffer, handling higher planes using surrogate pair.
        if (uCode > 0xFFFF) { 
            uCode -= 0x10000;
            var uCodeLead = 0xD800 + Math.floor(uCode / 0x400);
            newBuf[j++] = uCodeLead & 0xFF;
            newBuf[j++] = uCodeLead >> 8;

            uCode = 0xDC00 + uCode % 0x400;
        }
        newBuf[j++] = uCode & 0xFF;
        newBuf[j++] = uCode >> 8;

        // Reset trie node.
        nodeIdx = 0; seqStart = i+1;
    }

    this.nodeIdx = nodeIdx;
    this.prevBuf = (seqStart >= 0) ? buf.slice(seqStart) : prevBuf.slice(seqStart + prevBufOffset);
    return newBuf.slice(0, j).toString('ucs2');
}

DBCSDecoder.prototype.end = function() {
    var ret = '';

    // Try to parse all remaining chars.
    while (this.prevBuf.length > 0) {
        // Skip 1 character in the buffer.
        ret += this.defaultCharUnicode;
        var buf = this.prevBuf.slice(1);

        // Parse remaining as usual.
        this.prevBuf = Buffer.alloc(0);
        this.nodeIdx = 0;
        if (buf.length > 0)
            ret += this.write(buf);
    }

    this.nodeIdx = 0;
    return ret;
}

// Binary search for GB18030. Returns largest i such that table[i] <= val.
function findIdx(table, val) {
    if (table[0] > val)
        return -1;

    var l = 0, r = table.length;
    while (l < r-1) { // always table[l] <= val < table[r]
        var mid = l + Math.floor((r-l+1)/2);
        if (table[mid] <= val)
            l = mid;
        else
            r = mid;
    }
    return l;
}



/***/ }),

/***/ 49386:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


// Description of supported double byte encodings and aliases.
// Tables are not require()-d until they are needed to speed up library load.
// require()-s are direct to support Browserify.

module.exports = {
    
    // == Japanese/ShiftJIS ====================================================
    // All japanese encodings are based on JIS X set of standards:
    // JIS X 0201 - Single-byte encoding of ASCII + ¬• + Kana chars at 0xA1-0xDF.
    // JIS X 0208 - Main set of 6879 characters, placed in 94x94 plane, to be encoded by 2 bytes. 
    //              Has several variations in 1978, 1983, 1990 and 1997.
    // JIS X 0212 - Supplementary plane of 6067 chars in 94x94 plane. 1990. Effectively dead.
    // JIS X 0213 - Extension and modern replacement of 0208 and 0212. Total chars: 11233.
    //              2 planes, first is superset of 0208, second - revised 0212.
    //              Introduced in 2000, revised 2004. Some characters are in Unicode Plane 2 (0x2xxxx)

    // Byte encodings are:
    //  * Shift_JIS: Compatible with 0201, uses not defined chars in top half as lead bytes for double-byte
    //               encoding of 0208. Lead byte ranges: 0x81-0x9F, 0xE0-0xEF; Trail byte ranges: 0x40-0x7E, 0x80-0x9E, 0x9F-0xFC.
    //               Windows CP932 is a superset of Shift_JIS. Some companies added more chars, notably KDDI.
    //  * EUC-JP:    Up to 3 bytes per character. Used mostly on *nixes.
    //               0x00-0x7F       - lower part of 0201
    //               0x8E, 0xA1-0xDF - upper part of 0201
    //               (0xA1-0xFE)x2   - 0208 plane (94x94).
    //               0x8F, (0xA1-0xFE)x2 - 0212 plane (94x94).
    //  * JIS X 208: 7-bit, direct encoding of 0208. Byte ranges: 0x21-0x7E (94 values). Uncommon.
    //               Used as-is in ISO2022 family.
    //  * ISO2022-JP: Stateful encoding, with escape sequences to switch between ASCII, 
    //                0201-1976 Roman, 0208-1978, 0208-1983.
    //  * ISO2022-JP-1: Adds esc seq for 0212-1990.
    //  * ISO2022-JP-2: Adds esc seq for GB2313-1980, KSX1001-1992, ISO8859-1, ISO8859-7.
    //  * ISO2022-JP-3: Adds esc seq for 0201-1976 Kana set, 0213-2000 Planes 1, 2.
    //  * ISO2022-JP-2004: Adds 0213-2004 Plane 1.
    //
    // After JIS X 0213 appeared, Shift_JIS-2004, EUC-JISX0213 and ISO2022-JP-2004 followed, with just changing the planes.
    //
    // Overall, it seems that it's a mess :( http://www8.plala.or.jp/tkubota1/unicode-symbols-map2.html

    'shiftjis': {
        type: '_dbcs',
        table: function() { return __nccwpck_require__(98565) },
        encodeAdd: {'\u00a5': 0x5C, '\u203E': 0x7E},
        encodeSkipVals: [{from: 0xED40, to: 0xF940}],
    },
    'csshiftjis': 'shiftjis',
    'mskanji': 'shiftjis',
    'sjis': 'shiftjis',
    'windows31j': 'shiftjis',
    'ms31j': 'shiftjis',
    'xsjis': 'shiftjis',
    'windows932': 'shiftjis',
    'ms932': 'shiftjis',
    '932': 'shiftjis',
    'cp932': 'shiftjis',

    'eucjp': {
        type: '_dbcs',
        table: function() { return __nccwpck_require__(5520) },
        encodeAdd: {'\u00a5': 0x5C, '\u203E': 0x7E},
    },

    // TODO: KDDI extension to Shift_JIS
    // TODO: IBM CCSID 942 = CP932, but F0-F9 custom chars and other char changes.
    // TODO: IBM CCSID 943 = Shift_JIS = CP932 with original Shift_JIS lower 128 chars.


    // == Chinese/GBK ==========================================================
    // http://en.wikipedia.org/wiki/GBK
    // We mostly implement W3C recommendation: https://www.w3.org/TR/encoding/#gbk-encoder

    // Oldest GB2312 (1981, ~7600 chars) is a subset of CP936
    'gb2312': 'cp936',
    'gb231280': 'cp936',
    'gb23121980': 'cp936',
    'csgb2312': 'cp936',
    'csiso58gb231280': 'cp936',
    'euccn': 'cp936',

    // Microsoft's CP936 is a subset and approximation of GBK.
    'windows936': 'cp936',
    'ms936': 'cp936',
    '936': 'cp936',
    'cp936': {
        type: '_dbcs',
        table: function() { return __nccwpck_require__(82030) },
    },

    // GBK (~22000 chars) is an extension of CP936 that added user-mapped chars and some other.
    'gbk': {
        type: '_dbcs',
        table: function() { return (__nccwpck_require__(82030).concat)(__nccwpck_require__(48560)) },
    },
    'xgbk': 'gbk',
    'isoir58': 'gbk',

    // GB18030 is an algorithmic extension of GBK.
    // Main source: https://www.w3.org/TR/encoding/#gbk-encoder
    // http://icu-project.org/docs/papers/gb18030.html
    // http://source.icu-project.org/repos/icu/data/trunk/charset/data/xml/gb-18030-2000.xml
    // http://www.khngai.com/chinese/charmap/tblgbk.php?page=0
    'gb18030': {
        type: '_dbcs',
        table: function() { return (__nccwpck_require__(82030).concat)(__nccwpck_require__(48560)) },
        gb18030: function() { return __nccwpck_require__(52499) },
        encodeSkipVals: [0x80],
        encodeAdd: {'‚Ç¨': 0xA2E3},
    },

    'chinese': 'gb18030',


    // == Korean ===============================================================
    // EUC-KR, KS_C_5601 and KS X 1001 are exactly the same.
    'windows949': 'cp949',
    'ms949': 'cp949',
    '949': 'cp949',
    'cp949': {
        type: '_dbcs',
        table: function() { return __nccwpck_require__(16836) },
    },

    'cseuckr': 'cp949',
    'csksc56011987': 'cp949',
    'euckr': 'cp949',
    'isoir149': 'cp949',
    'korean': 'cp949',
    'ksc56011987': 'cp949',
    'ksc56011989': 'cp949',
    'ksc5601': 'cp949',


    // == Big5/Taiwan/Hong Kong ================================================
    // There are lots of tables for Big5 and cp950. Please see the following links for history:
    // http://moztw.org/docs/big5/  http://www.haible.de/bruno/charsets/conversion-tables/Big5.html
    // Variations, in roughly number of defined chars:
    //  * Windows CP 950: Microsoft variant of Big5. Canonical: http://www.unicode.org/Public/MAPPINGS/VENDORS/MICSFT/WINDOWS/CP950.TXT
    //  * Windows CP 951: Microsoft variant of Big5-HKSCS-2001. Seems to be never public. http://me.abelcheung.org/articles/research/what-is-cp951/
    //  * Big5-2003 (Taiwan standard) almost superset of cp950.
    //  * Unicode-at-on (UAO) / Mozilla 1.8. Falling out of use on the Web. Not supported by other browsers.
    //  * Big5-HKSCS (-2001, -2004, -2008). Hong Kong standard. 
    //    many unicode code points moved from PUA to Supplementary plane (U+2XXXX) over the years.
    //    Plus, it has 4 combining sequences.
    //    Seems that Mozilla refused to support it for 10 yrs. https://bugzilla.mozilla.org/show_bug.cgi?id=162431 https://bugzilla.mozilla.org/show_bug.cgi?id=310299
    //    because big5-hkscs is the only encoding to include astral characters in non-algorithmic way.
    //    Implementations are not consistent within browsers; sometimes labeled as just big5.
    //    MS Internet Explorer switches from big5 to big5-hkscs when a patch applied.
    //    Great discussion & recap of what's going on https://bugzilla.mozilla.org/show_bug.cgi?id=912470#c31
    //    In the encoder, it might make sense to support encoding old PUA mappings to Big5 bytes seq-s.
    //    Official spec: http://www.ogcio.gov.hk/en/business/tech_promotion/ccli/terms/doc/2003cmp_2008.txt
    //                   http://www.ogcio.gov.hk/tc/business/tech_promotion/ccli/terms/doc/hkscs-2008-big5-iso.txt
    // 
    // Current understanding of how to deal with Big5(-HKSCS) is in the Encoding Standard, http://encoding.spec.whatwg.org/#big5-encoder
    // Unicode mapping (http://www.unicode.org/Public/MAPPINGS/OBSOLETE/EASTASIA/OTHER/BIG5.TXT) is said to be wrong.

    'windows950': 'cp950',
    'ms950': 'cp950',
    '950': 'cp950',
    'cp950': {
        type: '_dbcs',
        table: function() { return __nccwpck_require__(15322) },
    },

    // Big5 has many variations and is an extension of cp950. We use Encoding Standard's as a consensus.
    'big5': 'big5hkscs',
    'big5hkscs': {
        type: '_dbcs',
        table: function() { return (__nccwpck_require__(15322).concat)(__nccwpck_require__(18777)) },
        encodeSkipVals: [0xa2cc],
    },

    'cnbig5': 'big5hkscs',
    'csbig5': 'big5hkscs',
    'xxbig5': 'big5hkscs',
};


/***/ }),

/***/ 54225:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


// Update this array if you add/rename/remove files in this directory.
// We support Browserify by skipping automatic module discovery and requiring modules directly.
var modules = [
    __nccwpck_require__(83956),
    __nccwpck_require__(52947),
    __nccwpck_require__(95447),
    __nccwpck_require__(97017),
    __nccwpck_require__(21899),
    __nccwpck_require__(85471),
    __nccwpck_require__(72794),
    __nccwpck_require__(49386),
];

// Put all encoding/alias/codec definitions to single object and export it. 
for (var i = 0; i < modules.length; i++) {
    var module = modules[i];
    for (var enc in module)
        if (Object.prototype.hasOwnProperty.call(module, enc))
            exports[enc] = module[enc];
}


/***/ }),

/***/ 83956:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";

var Buffer = (__nccwpck_require__(12803).Buffer);

// Export Node.js internal encodings.

module.exports = {
    // Encodings
    utf8:   { type: "_internal", bomAware: true},
    cesu8:  { type: "_internal", bomAware: true},
    unicode11utf8: "utf8",

    ucs2:   { type: "_internal", bomAware: true},
    utf16le: "ucs2",

    binary: { type: "_internal" },
    base64: { type: "_internal" },
    hex:    { type: "_internal" },

    // Codec.
    _internal: InternalCodec,
};

//------------------------------------------------------------------------------

function InternalCodec(codecOptions, iconv) {
    this.enc = codecOptions.encodingName;
    this.bomAware = codecOptions.bomAware;

    if (this.enc === "base64")
        this.encoder = InternalEncoderBase64;
    else if (this.enc === "cesu8") {
        this.enc = "utf8"; // Use utf8 for decoding.
        this.encoder = InternalEncoderCesu8;

        // Add decoder for versions of Node not supporting CESU-8
        if (Buffer.from('eda0bdedb2a9', 'hex').toString() !== 'üí©') {
            this.decoder = InternalDecoderCesu8;
            this.defaultCharUnicode = iconv.defaultCharUnicode;
        }
    }
}

InternalCodec.prototype.encoder = InternalEncoder;
InternalCodec.prototype.decoder = InternalDecoder;

//------------------------------------------------------------------------------

// We use node.js internal decoder. Its signature is the same as ours.
var StringDecoder = (__nccwpck_require__(13193).StringDecoder);

if (!StringDecoder.prototype.end) // Node v0.8 doesn't have this method.
    StringDecoder.prototype.end = function() {};


function InternalDecoder(options, codec) {
    StringDecoder.call(this, codec.enc);
}

InternalDecoder.prototype = StringDecoder.prototype;


//------------------------------------------------------------------------------
// Encoder is mostly trivial

function InternalEncoder(options, codec) {
    this.enc = codec.enc;
}

InternalEncoder.prototype.write = function(str) {
    return Buffer.from(str, this.enc);
}

InternalEncoder.prototype.end = function() {
}


//------------------------------------------------------------------------------
// Except base64 encoder, which must keep its state.

function InternalEncoderBase64(options, codec) {
    this.prevStr = '';
}

InternalEncoderBase64.prototype.write = function(str) {
    str = this.prevStr + str;
    var completeQuads = str.length - (str.length % 4);
    this.prevStr = str.slice(completeQuads);
    str = str.slice(0, completeQuads);

    return Buffer.from(str, "base64");
}

InternalEncoderBase64.prototype.end = function() {
    return Buffer.from(this.prevStr, "base64");
}


//------------------------------------------------------------------------------
// CESU-8 encoder is also special.

function InternalEncoderCesu8(options, codec) {
}

InternalEncoderCesu8.prototype.write = function(str) {
    var buf = Buffer.alloc(str.length * 3), bufIdx = 0;
    for (var i = 0; i < str.length; i++) {
        var charCode = str.charCodeAt(i);
        // Naive implementation, but it works because CESU-8 is especially easy
        // to convert from UTF-16 (which all JS strings are encoded in).
        if (charCode < 0x80)
            buf[bufIdx++] = charCode;
        else if (charCode < 0x800) {
            buf[bufIdx++] = 0xC0 + (charCode >>> 6);
            buf[bufIdx++] = 0x80 + (charCode & 0x3f);
        }
        else { // charCode will always be < 0x10000 in javascript.
            buf[bufIdx++] = 0xE0 + (charCode >>> 12);
            buf[bufIdx++] = 0x80 + ((charCode >>> 6) & 0x3f);
            buf[bufIdx++] = 0x80 + (charCode & 0x3f);
        }
    }
    return buf.slice(0, bufIdx);
}

InternalEncoderCesu8.prototype.end = function() {
}

//------------------------------------------------------------------------------
// CESU-8 decoder is not implemented in Node v4.0+

function InternalDecoderCesu8(options, codec) {
    this.acc = 0;
    this.contBytes = 0;
    this.accBytes = 0;
    this.defaultCharUnicode = codec.defaultCharUnicode;
}

InternalDecoderCesu8.prototype.write = function(buf) {
    var acc = this.acc, contBytes = this.contBytes, accBytes = this.accBytes, 
        res = '';
    for (var i = 0; i < buf.length; i++) {
        var curByte = buf[i];
        if ((curByte & 0xC0) !== 0x80) { // Leading byte
            if (contBytes > 0) { // Previous code is invalid
                res += this.defaultCharUnicode;
                contBytes = 0;
            }

            if (curByte < 0x80) { // Single-byte code
                res += String.fromCharCode(curByte);
            } else if (curByte < 0xE0) { // Two-byte code
                acc = curByte & 0x1F;
                contBytes = 1; accBytes = 1;
            } else if (curByte < 0xF0) { // Three-byte code
                acc = curByte & 0x0F;
                contBytes = 2; accBytes = 1;
            } else { // Four or more are not supported for CESU-8.
                res += this.defaultCharUnicode;
            }
        } else { // Continuation byte
            if (contBytes > 0) { // We're waiting for it.
                acc = (acc << 6) | (curByte & 0x3f);
                contBytes--; accBytes++;
                if (contBytes === 0) {
                    // Check for overlong encoding, but support Modified UTF-8 (encoding NULL as C0 80)
                    if (accBytes === 2 && acc < 0x80 && acc > 0)
                        res += this.defaultCharUnicode;
                    else if (accBytes === 3 && acc < 0x800)
                        res += this.defaultCharUnicode;
                    else
                        // Actually add character.
                        res += String.fromCharCode(acc);
                }
            } else { // Unexpected continuation byte
                res += this.defaultCharUnicode;
            }
        }
    }
    this.acc = acc; this.contBytes = contBytes; this.accBytes = accBytes;
    return res;
}

InternalDecoderCesu8.prototype.end = function() {
    var res = 0;
    if (this.contBytes > 0)
        res += this.defaultCharUnicode;
    return res;
}


/***/ }),

/***/ 97017:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

var Buffer = (__nccwpck_require__(12803).Buffer);

// Single-byte codec. Needs a 'chars' string parameter that contains 256 or 128 chars that
// correspond to encoded bytes (if 128 - then lower half is ASCII). 

exports._sbcs = SBCSCodec;
function SBCSCodec(codecOptions, iconv) {
    if (!codecOptions)
        throw new Error("SBCS codec is called without the data.")
    
    // Prepare char buffer for decoding.
    if (!codecOptions.chars || (codecOptions.chars.length !== 128 && codecOptions.chars.length !== 256))
        throw new Error("Encoding '"+codecOptions.type+"' has incorrect 'chars' (must be of len 128 or 256)");
    
    if (codecOptions.chars.length === 128) {
        var asciiString = "";
        for (var i = 0; i < 128; i++)
            asciiString += String.fromCharCode(i);
        codecOptions.chars = asciiString + codecOptions.chars;
    }

    this.decodeBuf = Buffer.from(codecOptions.chars, 'ucs2');
    
    // Encoding buffer.
    var encodeBuf = Buffer.alloc(65536, iconv.defaultCharSingleByte.charCodeAt(0));

    for (var i = 0; i < codecOptions.chars.length; i++)
        encodeBuf[codecOptions.chars.charCodeAt(i)] = i;

    this.encodeBuf = encodeBuf;
}

SBCSCodec.prototype.encoder = SBCSEncoder;
SBCSCodec.prototype.decoder = SBCSDecoder;


function SBCSEncoder(options, codec) {
    this.encodeBuf = codec.encodeBuf;
}

SBCSEncoder.prototype.write = function(str) {
    var buf = Buffer.alloc(str.length);
    for (var i = 0; i < str.length; i++)
        buf[i] = this.encodeBuf[str.charCodeAt(i)];
    
    return buf;
}

SBCSEncoder.prototype.end = function() {
}


function SBCSDecoder(options, codec) {
    this.decodeBuf = codec.decodeBuf;
}

SBCSDecoder.prototype.write = function(buf) {
    // Strings are immutable in JS -> we use ucs2 buffer to speed up computations.
    var decodeBuf = this.decodeBuf;
    var newBuf = Buffer.alloc(buf.length*2);
    var idx1 = 0, idx2 = 0;
    for (var i = 0; i < buf.length; i++) {
        idx1 = buf[i]*2; idx2 = i*2;
        newBuf[idx2] = decodeBuf[idx1];
        newBuf[idx2+1] = decodeBuf[idx1+1];
    }
    return newBuf.toString('ucs2');
}

SBCSDecoder.prototype.end = function() {
}


/***/ }),

/***/ 85471:
/***/ ((module) => {

"use strict";


// Generated data for sbcs codec. Don't edit manually. Regenerate using generation/gen-sbcs.js script.
module.exports = {
  "437": "cp437",
  "737": "cp737",
  "775": "cp775",
  "850": "cp850",
  "852": "cp852",
  "855": "cp855",
  "856": "cp856",
  "857": "cp857",
  "858": "cp858",
  "860": "cp860",
  "861": "cp861",
  "862": "cp862",
  "863": "cp863",
  "864": "cp864",
  "865": "cp865",
  "866": "cp866",
  "869": "cp869",
  "874": "windows874",
  "922": "cp922",
  "1046": "cp1046",
  "1124": "cp1124",
  "1125": "cp1125",
  "1129": "cp1129",
  "1133": "cp1133",
  "1161": "cp1161",
  "1162": "cp1162",
  "1163": "cp1163",
  "1250": "windows1250",
  "1251": "windows1251",
  "1252": "windows1252",
  "1253": "windows1253",
  "1254": "windows1254",
  "1255": "windows1255",
  "1256": "windows1256",
  "1257": "windows1257",
  "1258": "windows1258",
  "28591": "iso88591",
  "28592": "iso88592",
  "28593": "iso88593",
  "28594": "iso88594",
  "28595": "iso88595",
  "28596": "iso88596",
  "28597": "iso88597",
  "28598": "iso88598",
  "28599": "iso88599",
  "28600": "iso885910",
  "28601": "iso885911",
  "28603": "iso885913",
  "28604": "iso885914",
  "28605": "iso885915",
  "28606": "iso885916",
  "windows874": {
    "type": "_sbcs",
    "chars": "‚Ç¨ÔøΩÔøΩÔøΩÔøΩ‚Ä¶ÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩ‚Äò‚Äô‚Äú‚Äù‚Ä¢‚Äì‚ÄîÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩ¬†‡∏Å‡∏Ç‡∏É‡∏Ñ‡∏Ö‡∏Ü‡∏á‡∏à‡∏â‡∏ä‡∏ã‡∏å‡∏ç‡∏é‡∏è‡∏ê‡∏ë‡∏í‡∏ì‡∏î‡∏ï‡∏ñ‡∏ó‡∏ò‡∏ô‡∏ö‡∏õ‡∏ú‡∏ù‡∏û‡∏ü‡∏†‡∏°‡∏¢‡∏£‡∏§‡∏•‡∏¶‡∏ß‡∏®‡∏©‡∏™‡∏´‡∏¨‡∏≠‡∏Æ‡∏Ø‡∏∞‡∏±‡∏≤‡∏≥‡∏¥‡∏µ‡∏∂‡∏∑‡∏∏‡∏π‡∏∫ÔøΩÔøΩÔøΩÔøΩ‡∏ø‡πÄ‡πÅ‡πÇ‡πÉ‡πÑ‡πÖ‡πÜ‡πá‡πà‡πâ‡πä‡πã‡πå‡πç‡πé‡πè‡πê‡πë‡πí‡πì‡πî‡πï‡πñ‡πó‡πò‡πô‡πö‡πõÔøΩÔøΩÔøΩÔøΩ"
  },
  "win874": "windows874",
  "cp874": "windows874",
  "windows1250": {
    "type": "_sbcs",
    "chars": "‚Ç¨ÔøΩ‚ÄöÔøΩ‚Äû‚Ä¶‚Ä†‚Ä°ÔøΩ‚Ä∞≈†‚Äπ≈ö≈§≈Ω≈πÔøΩ‚Äò‚Äô‚Äú‚Äù‚Ä¢‚Äì‚ÄîÔøΩ‚Ñ¢≈°‚Ä∫≈õ≈•≈æ≈∫¬†ÀáÀò≈Å¬§ƒÑ¬¶¬ß¬®¬©≈û¬´¬¨¬≠¬Æ≈ª¬∞¬±Àõ≈Ç¬¥¬µ¬∂¬∑¬∏ƒÖ≈ü¬ªƒΩÀùƒæ≈º≈î√Å√ÇƒÇ√ÑƒπƒÜ√áƒå√âƒò√ãƒö√ç√éƒéƒê≈É≈á√ì√î≈ê√ñ√ó≈ò≈Æ√ö≈∞√ú√ù≈¢√ü≈ï√°√¢ƒÉ√§ƒ∫ƒá√ßƒç√©ƒô√´ƒõ√≠√Æƒèƒë≈Ñ≈à√≥√¥≈ë√∂√∑≈ô≈Ø√∫≈±√º√Ω≈£Àô"
  },
  "win1250": "windows1250",
  "cp1250": "windows1250",
  "windows1251": {
    "type": "_sbcs",
    "chars": "–Ç–É‚Äö—ì‚Äû‚Ä¶‚Ä†‚Ä°‚Ç¨‚Ä∞–â‚Äπ–ä–å–ã–è—í‚Äò‚Äô‚Äú‚Äù‚Ä¢‚Äì‚ÄîÔøΩ‚Ñ¢—ô‚Ä∫—ö—ú—õ—ü¬†–é—û–à¬§“ê¬¶¬ß–Å¬©–Ñ¬´¬¨¬≠¬Æ–á¬∞¬±–Ü—ñ“ë¬µ¬∂¬∑—ë‚Ññ—î¬ª—ò–Ö—ï—ó–ê–ë–í–ì–î–ï–ñ–ó–ò–ô–ö–õ–ú–ù–û–ü–†–°–¢–£–§–•–¶–ß–®–©–™–´–¨–≠–Æ–Ø–∞–±–≤–≥–¥–µ–∂–∑–∏–π–∫–ª–º–Ω–æ–ø—Ä—Å—Ç—É—Ñ—Ö—Ü—á—à—â—ä—ã—å—ç—é—è"
  },
  "win1251": "windows1251",
  "cp1251": "windows1251",
  "windows1252": {
    "type": "_sbcs",
    "chars": "‚Ç¨ÔøΩ‚Äö∆í‚Äû‚Ä¶‚Ä†‚Ä°ÀÜ‚Ä∞≈†‚Äπ≈íÔøΩ≈ΩÔøΩÔøΩ‚Äò‚Äô‚Äú‚Äù‚Ä¢‚Äì‚ÄîÀú‚Ñ¢≈°‚Ä∫≈ìÔøΩ≈æ≈∏¬†¬°¬¢¬£¬§¬•¬¶¬ß¬®¬©¬™¬´¬¨¬≠¬Æ¬Ø¬∞¬±¬≤¬≥¬¥¬µ¬∂¬∑¬∏¬π¬∫¬ª¬º¬Ω¬æ¬ø√Ä√Å√Ç√É√Ñ√Ö√Ü√á√à√â√ä√ã√å√ç√é√è√ê√ë√í√ì√î√ï√ñ√ó√ò√ô√ö√õ√ú√ù√û√ü√†√°√¢√£√§√•√¶√ß√®√©√™√´√¨√≠√Æ√Ø√∞√±√≤√≥√¥√µ√∂√∑√∏√π√∫√ª√º√Ω√æ√ø"
  },
  "win1252": "windows1252",
  "cp1252": "windows1252",
  "windows1253": {
    "type": "_sbcs",
    "chars": "‚Ç¨ÔøΩ‚Äö∆í‚Äû‚Ä¶‚Ä†‚Ä°ÔøΩ‚Ä∞ÔøΩ‚ÄπÔøΩÔøΩÔøΩÔøΩÔøΩ‚Äò‚Äô‚Äú‚Äù‚Ä¢‚Äì‚ÄîÔøΩ‚Ñ¢ÔøΩ‚Ä∫ÔøΩÔøΩÔøΩÔøΩ¬†ŒÖŒÜ¬£¬§¬•¬¶¬ß¬®¬©ÔøΩ¬´¬¨¬≠¬Æ‚Äï¬∞¬±¬≤¬≥ŒÑ¬µ¬∂¬∑ŒàŒâŒä¬ªŒå¬ΩŒéŒèŒêŒëŒíŒìŒîŒïŒñŒóŒòŒôŒöŒõŒúŒùŒûŒüŒ†Œ°ÔøΩŒ£Œ§Œ•Œ¶ŒßŒ®Œ©Œ™Œ´Œ¨Œ≠ŒÆŒØŒ∞Œ±Œ≤Œ≥Œ¥ŒµŒ∂Œ∑Œ∏ŒπŒ∫ŒªŒºŒΩŒæŒøœÄœÅœÇœÉœÑœÖœÜœáœàœâœäœãœåœçœéÔøΩ"
  },
  "win1253": "windows1253",
  "cp1253": "windows1253",
  "windows1254": {
    "type": "_sbcs",
    "chars": "‚Ç¨ÔøΩ‚Äö∆í‚Äû‚Ä¶‚Ä†‚Ä°ÀÜ‚Ä∞≈†‚Äπ≈íÔøΩÔøΩÔøΩÔøΩ‚Äò‚Äô‚Äú‚Äù‚Ä¢‚Äì‚ÄîÀú‚Ñ¢≈°‚Ä∫≈ìÔøΩÔøΩ≈∏¬†¬°¬¢¬£¬§¬•¬¶¬ß¬®¬©¬™¬´¬¨¬≠¬Æ¬Ø¬∞¬±¬≤¬≥¬¥¬µ¬∂¬∑¬∏¬π¬∫¬ª¬º¬Ω¬æ¬ø√Ä√Å√Ç√É√Ñ√Ö√Ü√á√à√â√ä√ã√å√ç√é√èƒû√ë√í√ì√î√ï√ñ√ó√ò√ô√ö√õ√úƒ∞≈û√ü√†√°√¢√£√§√•√¶√ß√®√©√™√´√¨√≠√Æ√Øƒü√±√≤√≥√¥√µ√∂√∑√∏√π√∫√ª√ºƒ±≈ü√ø"
  },
  "win1254": "windows1254",
  "cp1254": "windows1254",
  "windows1255": {
    "type": "_sbcs",
    "chars": "‚Ç¨ÔøΩ‚Äö∆í‚Äû‚Ä¶‚Ä†‚Ä°ÀÜ‚Ä∞ÔøΩ‚ÄπÔøΩÔøΩÔøΩÔøΩÔøΩ‚Äò‚Äô‚Äú‚Äù‚Ä¢‚Äì‚ÄîÀú‚Ñ¢ÔøΩ‚Ä∫ÔøΩÔøΩÔøΩÔøΩ¬†¬°¬¢¬£‚Ç™¬•¬¶¬ß¬®¬©√ó¬´¬¨¬≠¬Æ¬Ø¬∞¬±¬≤¬≥¬¥¬µ¬∂¬∑¬∏¬π√∑¬ª¬º¬Ω¬æ¬ø÷∞÷±÷≤÷≥÷¥÷µ÷∂÷∑÷∏÷π÷∫÷ª÷º÷Ω÷æ÷ø◊Ä◊Å◊Ç◊É◊∞◊±◊≤◊≥◊¥ÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩ◊ê◊ë◊í◊ì◊î◊ï◊ñ◊ó◊ò◊ô◊ö◊õ◊ú◊ù◊û◊ü◊†◊°◊¢◊£◊§◊•◊¶◊ß◊®◊©◊™ÔøΩÔøΩ‚Äé‚ÄèÔøΩ"
  },
  "win1255": "windows1255",
  "cp1255": "windows1255",
  "windows1256": {
    "type": "_sbcs",
    "chars": "‚Ç¨Ÿæ‚Äö∆í‚Äû‚Ä¶‚Ä†‚Ä°ÀÜ‚Ä∞Ÿπ‚Äπ≈í⁄Ü⁄ò⁄à⁄Ø‚Äò‚Äô‚Äú‚Äù‚Ä¢‚Äì‚Äî⁄©‚Ñ¢⁄ë‚Ä∫≈ì‚Äå‚Äç⁄∫¬†ÿå¬¢¬£¬§¬•¬¶¬ß¬®¬©⁄æ¬´¬¨¬≠¬Æ¬Ø¬∞¬±¬≤¬≥¬¥¬µ¬∂¬∑¬∏¬πÿõ¬ª¬º¬Ω¬æÿü€Åÿ°ÿ¢ÿ£ÿ§ÿ•ÿ¶ÿßÿ®ÿ©ÿ™ÿ´ÿ¨ÿ≠ÿÆÿØÿ∞ÿ±ÿ≤ÿ≥ÿ¥ÿµÿ∂√óÿ∑ÿ∏ÿπÿ∫ŸÄŸÅŸÇŸÉ√†ŸÑ√¢ŸÖŸÜŸáŸà√ß√®√©√™√´ŸâŸä√Æ√ØŸãŸåŸçŸé√¥ŸèŸê√∑Ÿë√πŸí√ª√º‚Äé‚Äè€í"
  },
  "win1256": "windows1256",
  "cp1256": "windows1256",
  "windows1257": {
    "type": "_sbcs",
    "chars": "‚Ç¨ÔøΩ‚ÄöÔøΩ‚Äû‚Ä¶‚Ä†‚Ä°ÔøΩ‚Ä∞ÔøΩ‚ÄπÔøΩ¬®Àá¬∏ÔøΩ‚Äò‚Äô‚Äú‚Äù‚Ä¢‚Äì‚ÄîÔøΩ‚Ñ¢ÔøΩ‚Ä∫ÔøΩ¬ØÀõÔøΩ¬†ÔøΩ¬¢¬£¬§ÔøΩ¬¶¬ß√ò¬©≈ñ¬´¬¨¬≠¬Æ√Ü¬∞¬±¬≤¬≥¬¥¬µ¬∂¬∑√∏¬π≈ó¬ª¬º¬Ω¬æ√¶ƒÑƒÆƒÄƒÜ√Ñ√Öƒòƒíƒå√â≈πƒñƒ¢ƒ∂ƒ™ƒª≈†≈É≈Ö√ì≈å√ï√ñ√ó≈≤≈Å≈ö≈™√ú≈ª≈Ω√üƒÖƒØƒÅƒá√§√•ƒôƒìƒç√©≈∫ƒóƒ£ƒ∑ƒ´ƒº≈°≈Ñ≈Ü√≥≈ç√µ√∂√∑≈≥≈Ç≈õ≈´√º≈º≈æÀô"
  },
  "win1257": "windows1257",
  "cp1257": "windows1257",
  "windows1258": {
    "type": "_sbcs",
    "chars": "‚Ç¨ÔøΩ‚Äö∆í‚Äû‚Ä¶‚Ä†‚Ä°ÀÜ‚Ä∞ÔøΩ‚Äπ≈íÔøΩÔøΩÔøΩÔøΩ‚Äò‚Äô‚Äú‚Äù‚Ä¢‚Äì‚ÄîÀú‚Ñ¢ÔøΩ‚Ä∫≈ìÔøΩÔøΩ≈∏¬†¬°¬¢¬£¬§¬•¬¶¬ß¬®¬©¬™¬´¬¨¬≠¬Æ¬Ø¬∞¬±¬≤¬≥¬¥¬µ¬∂¬∑¬∏¬π¬∫¬ª¬º¬Ω¬æ¬ø√Ä√Å√ÇƒÇ√Ñ√Ö√Ü√á√à√â√ä√ãÃÄ√ç√é√èƒê√ëÃâ√ì√î∆†√ñ√ó√ò√ô√ö√õ√ú∆ØÃÉ√ü√†√°√¢ƒÉ√§√•√¶√ß√®√©√™√´ÃÅ√≠√Æ√Øƒë√±Ã£√≥√¥∆°√∂√∑√∏√π√∫√ª√º∆∞‚Ç´√ø"
  },
  "win1258": "windows1258",
  "cp1258": "windows1258",
  "iso88591": {
    "type": "_sbcs",
    "chars": "¬Ä¬Å¬Ç¬É¬Ñ¬Ö¬Ü¬á¬à¬â¬ä¬ã¬å¬ç¬é¬è¬ê¬ë¬í¬ì¬î¬ï¬ñ¬ó¬ò¬ô¬ö¬õ¬ú¬ù¬û¬ü¬†¬°¬¢¬£¬§¬•¬¶¬ß¬®¬©¬™¬´¬¨¬≠¬Æ¬Ø¬∞¬±¬≤¬≥¬¥¬µ¬∂¬∑¬∏¬π¬∫¬ª¬º¬Ω¬æ¬ø√Ä√Å√Ç√É√Ñ√Ö√Ü√á√à√â√ä√ã√å√ç√é√è√ê√ë√í√ì√î√ï√ñ√ó√ò√ô√ö√õ√ú√ù√û√ü√†√°√¢√£√§√•√¶√ß√®√©√™√´√¨√≠√Æ√Ø√∞√±√≤√≥√¥√µ√∂√∑√∏√π√∫√ª√º√Ω√æ√ø"
  },
  "cp28591": "iso88591",
  "iso88592": {
    "type": "_sbcs",
    "chars": "¬Ä¬Å¬Ç¬É¬Ñ¬Ö¬Ü¬á¬à¬â¬ä¬ã¬å¬ç¬é¬è¬ê¬ë¬í¬ì¬î¬ï¬ñ¬ó¬ò¬ô¬ö¬õ¬ú¬ù¬û¬ü¬†ƒÑÀò≈Å¬§ƒΩ≈ö¬ß¬®≈†≈û≈§≈π¬≠≈Ω≈ª¬∞ƒÖÀõ≈Ç¬¥ƒæ≈õÀá¬∏≈°≈ü≈•≈∫Àù≈æ≈º≈î√Å√ÇƒÇ√ÑƒπƒÜ√áƒå√âƒò√ãƒö√ç√éƒéƒê≈É≈á√ì√î≈ê√ñ√ó≈ò≈Æ√ö≈∞√ú√ù≈¢√ü≈ï√°√¢ƒÉ√§ƒ∫ƒá√ßƒç√©ƒô√´ƒõ√≠√Æƒèƒë≈Ñ≈à√≥√¥≈ë√∂√∑≈ô≈Ø√∫≈±√º√Ω≈£Àô"
  },
  "cp28592": "iso88592",
  "iso88593": {
    "type": "_sbcs",
    "chars": "¬Ä¬Å¬Ç¬É¬Ñ¬Ö¬Ü¬á¬à¬â¬ä¬ã¬å¬ç¬é¬è¬ê¬ë¬í¬ì¬î¬ï¬ñ¬ó¬ò¬ô¬ö¬õ¬ú¬ù¬û¬ü¬†ƒ¶Àò¬£¬§ÔøΩƒ§¬ß¬®ƒ∞≈ûƒûƒ¥¬≠ÔøΩ≈ª¬∞ƒß¬≤¬≥¬¥¬µƒ•¬∑¬∏ƒ±≈üƒüƒµ¬ΩÔøΩ≈º√Ä√Å√ÇÔøΩ√Ñƒäƒà√á√à√â√ä√ã√å√ç√é√èÔøΩ√ë√í√ì√îƒ†√ñ√óƒú√ô√ö√õ√ú≈¨≈ú√ü√†√°√¢ÔøΩ√§ƒãƒâ√ß√®√©√™√´√¨√≠√Æ√ØÔøΩ√±√≤√≥√¥ƒ°√∂√∑ƒù√π√∫√ª√º≈≠≈ùÀô"
  },
  "cp28593": "iso88593",
  "iso88594": {
    "type": "_sbcs",
    "chars": "¬Ä¬Å¬Ç¬É¬Ñ¬Ö¬Ü¬á¬à¬â¬ä¬ã¬å¬ç¬é¬è¬ê¬ë¬í¬ì¬î¬ï¬ñ¬ó¬ò¬ô¬ö¬õ¬ú¬ù¬û¬ü¬†ƒÑƒ∏≈ñ¬§ƒ®ƒª¬ß¬®≈†ƒíƒ¢≈¶¬≠≈Ω¬Ø¬∞ƒÖÀõ≈ó¬¥ƒ©ƒºÀá¬∏≈°ƒìƒ£≈ß≈ä≈æ≈ãƒÄ√Å√Ç√É√Ñ√Ö√ÜƒÆƒå√âƒò√ãƒñ√ç√éƒ™ƒê≈Ö≈åƒ∂√î√ï√ñ√ó√ò≈≤√ö√õ√ú≈®≈™√üƒÅ√°√¢√£√§√•√¶ƒØƒç√©ƒô√´ƒó√≠√Æƒ´ƒë≈Ü≈çƒ∑√¥√µ√∂√∑√∏≈≥√∫√ª√º≈©≈´Àô"
  },
  "cp28594": "iso88594",
  "iso88595": {
    "type": "_sbcs",
    "chars": "¬Ä¬Å¬Ç¬É¬Ñ¬Ö¬Ü¬á¬à¬â¬ä¬ã¬å¬ç¬é¬è¬ê¬ë¬í¬ì¬î¬ï¬ñ¬ó¬ò¬ô¬ö¬õ¬ú¬ù¬û¬ü¬†–Å–Ç–É–Ñ–Ö–Ü–á–à–â–ä–ã–å¬≠–é–è–ê–ë–í–ì–î–ï–ñ–ó–ò–ô–ö–õ–ú–ù–û–ü–†–°–¢–£–§–•–¶–ß–®–©–™–´–¨–≠–Æ–Ø–∞–±–≤–≥–¥–µ–∂–∑–∏–π–∫–ª–º–Ω–æ–ø—Ä—Å—Ç—É—Ñ—Ö—Ü—á—à—â—ä—ã—å—ç—é—è‚Ññ—ë—í—ì—î—ï—ñ—ó—ò—ô—ö—õ—ú¬ß—û—ü"
  },
  "cp28595": "iso88595",
  "iso88596": {
    "type": "_sbcs",
    "chars": "¬Ä¬Å¬Ç¬É¬Ñ¬Ö¬Ü¬á¬à¬â¬ä¬ã¬å¬ç¬é¬è¬ê¬ë¬í¬ì¬î¬ï¬ñ¬ó¬ò¬ô¬ö¬õ¬ú¬ù¬û¬ü¬†ÔøΩÔøΩÔøΩ¬§ÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÿå¬≠ÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÿõÔøΩÔøΩÔøΩÿüÔøΩÿ°ÿ¢ÿ£ÿ§ÿ•ÿ¶ÿßÿ®ÿ©ÿ™ÿ´ÿ¨ÿ≠ÿÆÿØÿ∞ÿ±ÿ≤ÿ≥ÿ¥ÿµÿ∂ÿ∑ÿ∏ÿπÿ∫ÔøΩÔøΩÔøΩÔøΩÔøΩŸÄŸÅŸÇŸÉŸÑŸÖŸÜŸáŸàŸâŸäŸãŸåŸçŸéŸèŸêŸëŸíÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩ"
  },
  "cp28596": "iso88596",
  "iso88597": {
    "type": "_sbcs",
    "chars": "¬Ä¬Å¬Ç¬É¬Ñ¬Ö¬Ü¬á¬à¬â¬ä¬ã¬å¬ç¬é¬è¬ê¬ë¬í¬ì¬î¬ï¬ñ¬ó¬ò¬ô¬ö¬õ¬ú¬ù¬û¬ü¬†‚Äò‚Äô¬£‚Ç¨‚ÇØ¬¶¬ß¬®¬©Õ∫¬´¬¨¬≠ÔøΩ‚Äï¬∞¬±¬≤¬≥ŒÑŒÖŒÜ¬∑ŒàŒâŒä¬ªŒå¬ΩŒéŒèŒêŒëŒíŒìŒîŒïŒñŒóŒòŒôŒöŒõŒúŒùŒûŒüŒ†Œ°ÔøΩŒ£Œ§Œ•Œ¶ŒßŒ®Œ©Œ™Œ´Œ¨Œ≠ŒÆŒØŒ∞Œ±Œ≤Œ≥Œ¥ŒµŒ∂Œ∑Œ∏ŒπŒ∫ŒªŒºŒΩŒæŒøœÄœÅœÇœÉœÑœÖœÜœáœàœâœäœãœåœçœéÔøΩ"
  },
  "cp28597": "iso88597",
  "iso88598": {
    "type": "_sbcs",
    "chars": "¬Ä¬Å¬Ç¬É¬Ñ¬Ö¬Ü¬á¬à¬â¬ä¬ã¬å¬ç¬é¬è¬ê¬ë¬í¬ì¬î¬ï¬ñ¬ó¬ò¬ô¬ö¬õ¬ú¬ù¬û¬ü¬†ÔøΩ¬¢¬£¬§¬•¬¶¬ß¬®¬©√ó¬´¬¨¬≠¬Æ¬Ø¬∞¬±¬≤¬≥¬¥¬µ¬∂¬∑¬∏¬π√∑¬ª¬º¬Ω¬æÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩ‚Äó◊ê◊ë◊í◊ì◊î◊ï◊ñ◊ó◊ò◊ô◊ö◊õ◊ú◊ù◊û◊ü◊†◊°◊¢◊£◊§◊•◊¶◊ß◊®◊©◊™ÔøΩÔøΩ‚Äé‚ÄèÔøΩ"
  },
  "cp28598": "iso88598",
  "iso88599": {
    "type": "_sbcs",
    "chars": "¬Ä¬Å¬Ç¬É¬Ñ¬Ö¬Ü¬á¬à¬â¬ä¬ã¬å¬ç¬é¬è¬ê¬ë¬í¬ì¬î¬ï¬ñ¬ó¬ò¬ô¬ö¬õ¬ú¬ù¬û¬ü¬†¬°¬¢¬£¬§¬•¬¶¬ß¬®¬©¬™¬´¬¨¬≠¬Æ¬Ø¬∞¬±¬≤¬≥¬¥¬µ¬∂¬∑¬∏¬π¬∫¬ª¬º¬Ω¬æ¬ø√Ä√Å√Ç√É√Ñ√Ö√Ü√á√à√â√ä√ã√å√ç√é√èƒû√ë√í√ì√î√ï√ñ√ó√ò√ô√ö√õ√úƒ∞≈û√ü√†√°√¢√£√§√•√¶√ß√®√©√™√´√¨√≠√Æ√Øƒü√±√≤√≥√¥√µ√∂√∑√∏√π√∫√ª√ºƒ±≈ü√ø"
  },
  "cp28599": "iso88599",
  "iso885910": {
    "type": "_sbcs",
    "chars": "¬Ä¬Å¬Ç¬É¬Ñ¬Ö¬Ü¬á¬à¬â¬ä¬ã¬å¬ç¬é¬è¬ê¬ë¬í¬ì¬î¬ï¬ñ¬ó¬ò¬ô¬ö¬õ¬ú¬ù¬û¬ü¬†ƒÑƒíƒ¢ƒ™ƒ®ƒ∂¬ßƒªƒê≈†≈¶≈Ω¬≠≈™≈ä¬∞ƒÖƒìƒ£ƒ´ƒ©ƒ∑¬∑ƒºƒë≈°≈ß≈æ‚Äï≈´≈ãƒÄ√Å√Ç√É√Ñ√Ö√ÜƒÆƒå√âƒò√ãƒñ√ç√é√è√ê≈Ö≈å√ì√î√ï√ñ≈®√ò≈≤√ö√õ√ú√ù√û√üƒÅ√°√¢√£√§√•√¶ƒØƒç√©ƒô√´ƒó√≠√Æ√Ø√∞≈Ü≈ç√≥√¥√µ√∂≈©√∏≈≥√∫√ª√º√Ω√æƒ∏"
  },
  "cp28600": "iso885910",
  "iso885911": {
    "type": "_sbcs",
    "chars": "¬Ä¬Å¬Ç¬É¬Ñ¬Ö¬Ü¬á¬à¬â¬ä¬ã¬å¬ç¬é¬è¬ê¬ë¬í¬ì¬î¬ï¬ñ¬ó¬ò¬ô¬ö¬õ¬ú¬ù¬û¬ü¬†‡∏Å‡∏Ç‡∏É‡∏Ñ‡∏Ö‡∏Ü‡∏á‡∏à‡∏â‡∏ä‡∏ã‡∏å‡∏ç‡∏é‡∏è‡∏ê‡∏ë‡∏í‡∏ì‡∏î‡∏ï‡∏ñ‡∏ó‡∏ò‡∏ô‡∏ö‡∏õ‡∏ú‡∏ù‡∏û‡∏ü‡∏†‡∏°‡∏¢‡∏£‡∏§‡∏•‡∏¶‡∏ß‡∏®‡∏©‡∏™‡∏´‡∏¨‡∏≠‡∏Æ‡∏Ø‡∏∞‡∏±‡∏≤‡∏≥‡∏¥‡∏µ‡∏∂‡∏∑‡∏∏‡∏π‡∏∫ÔøΩÔøΩÔøΩÔøΩ‡∏ø‡πÄ‡πÅ‡πÇ‡πÉ‡πÑ‡πÖ‡πÜ‡πá‡πà‡πâ‡πä‡πã‡πå‡πç‡πé‡πè‡πê‡πë‡πí‡πì‡πî‡πï‡πñ‡πó‡πò‡πô‡πö‡πõÔøΩÔøΩÔøΩÔøΩ"
  },
  "cp28601": "iso885911",
  "iso885913": {
    "type": "_sbcs",
    "chars": "¬Ä¬Å¬Ç¬É¬Ñ¬Ö¬Ü¬á¬à¬â¬ä¬ã¬å¬ç¬é¬è¬ê¬ë¬í¬ì¬î¬ï¬ñ¬ó¬ò¬ô¬ö¬õ¬ú¬ù¬û¬ü¬†‚Äù¬¢¬£¬§‚Äû¬¶¬ß√ò¬©≈ñ¬´¬¨¬≠¬Æ√Ü¬∞¬±¬≤¬≥‚Äú¬µ¬∂¬∑√∏¬π≈ó¬ª¬º¬Ω¬æ√¶ƒÑƒÆƒÄƒÜ√Ñ√Öƒòƒíƒå√â≈πƒñƒ¢ƒ∂ƒ™ƒª≈†≈É≈Ö√ì≈å√ï√ñ√ó≈≤≈Å≈ö≈™√ú≈ª≈Ω√üƒÖƒØƒÅƒá√§√•ƒôƒìƒç√©≈∫ƒóƒ£ƒ∑ƒ´ƒº≈°≈Ñ≈Ü√≥≈ç√µ√∂√∑≈≥≈Ç≈õ≈´√º≈º≈æ‚Äô"
  },
  "cp28603": "iso885913",
  "iso885914": {
    "type": "_sbcs",
    "chars": "¬Ä¬Å¬Ç¬É¬Ñ¬Ö¬Ü¬á¬à¬â¬ä¬ã¬å¬ç¬é¬è¬ê¬ë¬í¬ì¬î¬ï¬ñ¬ó¬ò¬ô¬ö¬õ¬ú¬ù¬û¬ü¬†·∏Ç·∏É¬£ƒäƒã·∏ä¬ß·∫Ä¬©·∫Ç·∏ã·ª≤¬≠¬Æ≈∏·∏û·∏üƒ†ƒ°·πÄ·πÅ¬∂·πñ·∫Å·πó·∫É·π†·ª≥·∫Ñ·∫Ö·π°√Ä√Å√Ç√É√Ñ√Ö√Ü√á√à√â√ä√ã√å√ç√é√è≈¥√ë√í√ì√î√ï√ñ·π™√ò√ô√ö√õ√ú√ù≈∂√ü√†√°√¢√£√§√•√¶√ß√®√©√™√´√¨√≠√Æ√Ø≈µ√±√≤√≥√¥√µ√∂·π´√∏√π√∫√ª√º√Ω≈∑√ø"
  },
  "cp28604": "iso885914",
  "iso885915": {
    "type": "_sbcs",
    "chars": "¬Ä¬Å¬Ç¬É¬Ñ¬Ö¬Ü¬á¬à¬â¬ä¬ã¬å¬ç¬é¬è¬ê¬ë¬í¬ì¬î¬ï¬ñ¬ó¬ò¬ô¬ö¬õ¬ú¬ù¬û¬ü¬†¬°¬¢¬£‚Ç¨¬•≈†¬ß≈°¬©¬™¬´¬¨¬≠¬Æ¬Ø¬∞¬±¬≤¬≥≈Ω¬µ¬∂¬∑≈æ¬π¬∫¬ª≈í≈ì≈∏¬ø√Ä√Å√Ç√É√Ñ√Ö√Ü√á√à√â√ä√ã√å√ç√é√è√ê√ë√í√ì√î√ï√ñ√ó√ò√ô√ö√õ√ú√ù√û√ü√†√°√¢√£√§√•√¶√ß√®√©√™√´√¨√≠√Æ√Ø√∞√±√≤√≥√¥√µ√∂√∑√∏√π√∫√ª√º√Ω√æ√ø"
  },
  "cp28605": "iso885915",
  "iso885916": {
    "type": "_sbcs",
    "chars": "¬Ä¬Å¬Ç¬É¬Ñ¬Ö¬Ü¬á¬à¬â¬ä¬ã¬å¬ç¬é¬è¬ê¬ë¬í¬ì¬î¬ï¬ñ¬ó¬ò¬ô¬ö¬õ¬ú¬ù¬û¬ü¬†ƒÑƒÖ≈Å‚Ç¨‚Äû≈†¬ß≈°¬©»ò¬´≈π¬≠≈∫≈ª¬∞¬±ƒå≈Ç≈Ω‚Äù¬∂¬∑≈æƒç»ô¬ª≈í≈ì≈∏≈º√Ä√Å√ÇƒÇ√ÑƒÜ√Ü√á√à√â√ä√ã√å√ç√é√èƒê≈É√í√ì√î≈ê√ñ≈ö≈∞√ô√ö√õ√úƒò»ö√ü√†√°√¢ƒÉ√§ƒá√¶√ß√®√©√™√´√¨√≠√Æ√Øƒë≈Ñ√≤√≥√¥≈ë√∂≈õ≈±√π√∫√ª√ºƒô»õ√ø"
  },
  "cp28606": "iso885916",
  "cp437": {
    "type": "_sbcs",
    "chars": "√á√º√©√¢√§√†√•√ß√™√´√®√Ø√Æ√¨√Ñ√Ö√â√¶√Ü√¥√∂√≤√ª√π√ø√ñ√ú¬¢¬£¬•‚Çß∆í√°√≠√≥√∫√±√ë¬™¬∫¬ø‚åê¬¨¬Ω¬º¬°¬´¬ª‚ñë‚ñí‚ñì‚îÇ‚î§‚ï°‚ï¢‚ïñ‚ïï‚ï£‚ïë‚ïó‚ïù‚ïú‚ïõ‚îê‚îî‚î¥‚î¨‚îú‚îÄ‚îº‚ïû‚ïü‚ïö‚ïî‚ï©‚ï¶‚ï†‚ïê‚ï¨‚ïß‚ï®‚ï§‚ï•‚ïô‚ïò‚ïí‚ïì‚ï´‚ï™‚îò‚îå‚ñà‚ñÑ‚ñå‚ñê‚ñÄŒ±√üŒìœÄŒ£œÉ¬µœÑŒ¶ŒòŒ©Œ¥‚àûœÜŒµ‚à©‚â°¬±‚â•‚â§‚å†‚å°√∑‚âà¬∞‚àô¬∑‚àö‚Åø¬≤‚ñ†¬†"
  },
  "ibm437": "cp437",
  "csibm437": "cp437",
  "cp737": {
    "type": "_sbcs",
    "chars": "ŒëŒíŒìŒîŒïŒñŒóŒòŒôŒöŒõŒúŒùŒûŒüŒ†Œ°Œ£Œ§Œ•Œ¶ŒßŒ®Œ©Œ±Œ≤Œ≥Œ¥ŒµŒ∂Œ∑Œ∏ŒπŒ∫ŒªŒºŒΩŒæŒøœÄœÅœÉœÇœÑœÖœÜœáœà‚ñë‚ñí‚ñì‚îÇ‚î§‚ï°‚ï¢‚ïñ‚ïï‚ï£‚ïë‚ïó‚ïù‚ïú‚ïõ‚îê‚îî‚î¥‚î¨‚îú‚îÄ‚îº‚ïû‚ïü‚ïö‚ïî‚ï©‚ï¶‚ï†‚ïê‚ï¨‚ïß‚ï®‚ï§‚ï•‚ïô‚ïò‚ïí‚ïì‚ï´‚ï™‚îò‚îå‚ñà‚ñÑ‚ñå‚ñê‚ñÄœâŒ¨Œ≠ŒÆœäŒØœåœçœãœéŒÜŒàŒâŒäŒåŒéŒè¬±‚â•‚â§Œ™Œ´√∑‚âà¬∞‚àô¬∑‚àö‚Åø¬≤‚ñ†¬†"
  },
  "ibm737": "cp737",
  "csibm737": "cp737",
  "cp775": {
    "type": "_sbcs",
    "chars": "ƒÜ√º√©ƒÅ√§ƒ£√•ƒá≈Çƒì≈ñ≈óƒ´≈π√Ñ√Ö√â√¶√Ü≈ç√∂ƒ¢¬¢≈ö≈õ√ñ√ú√∏¬£√ò√ó¬§ƒÄƒ™√≥≈ª≈º≈∫‚Äù¬¶¬©¬Æ¬¨¬Ω¬º≈Å¬´¬ª‚ñë‚ñí‚ñì‚îÇ‚î§ƒÑƒåƒòƒñ‚ï£‚ïë‚ïó‚ïùƒÆ≈†‚îê‚îî‚î¥‚î¨‚îú‚îÄ‚îº≈≤≈™‚ïö‚ïî‚ï©‚ï¶‚ï†‚ïê‚ï¨≈ΩƒÖƒçƒôƒóƒØ≈°≈≥≈´≈æ‚îò‚îå‚ñà‚ñÑ‚ñå‚ñê‚ñÄ√ì√ü≈å≈É√µ√ï¬µ≈Ñƒ∂ƒ∑ƒªƒº≈Üƒí≈Ö‚Äô¬≠¬±‚Äú¬æ¬∂¬ß√∑‚Äû¬∞‚àô¬∑¬π¬≥¬≤‚ñ†¬†"
  },
  "ibm775": "cp775",
  "csibm775": "cp775",
  "cp850": {
    "type": "_sbcs",
    "chars": "√á√º√©√¢√§√†√•√ß√™√´√®√Ø√Æ√¨√Ñ√Ö√â√¶√Ü√¥√∂√≤√ª√π√ø√ñ√ú√∏¬£√ò√ó∆í√°√≠√≥√∫√±√ë¬™¬∫¬ø¬Æ¬¨¬Ω¬º¬°¬´¬ª‚ñë‚ñí‚ñì‚îÇ‚î§√Å√Ç√Ä¬©‚ï£‚ïë‚ïó‚ïù¬¢¬•‚îê‚îî‚î¥‚î¨‚îú‚îÄ‚îº√£√É‚ïö‚ïî‚ï©‚ï¶‚ï†‚ïê‚ï¨¬§√∞√ê√ä√ã√àƒ±√ç√é√è‚îò‚îå‚ñà‚ñÑ¬¶√å‚ñÄ√ì√ü√î√í√µ√ï¬µ√æ√û√ö√õ√ô√Ω√ù¬Ø¬¥¬≠¬±‚Äó¬æ¬∂¬ß√∑¬∏¬∞¬®¬∑¬π¬≥¬≤‚ñ†¬†"
  },
  "ibm850": "cp850",
  "csibm850": "cp850",
  "cp852": {
    "type": "_sbcs",
    "chars": "√á√º√©√¢√§≈Øƒá√ß≈Ç√´≈ê≈ë√Æ≈π√ÑƒÜ√âƒπƒ∫√¥√∂ƒΩƒæ≈ö≈õ√ñ√ú≈§≈•≈Å√óƒç√°√≠√≥√∫ƒÑƒÖ≈Ω≈æƒòƒô¬¨≈∫ƒå≈ü¬´¬ª‚ñë‚ñí‚ñì‚îÇ‚î§√Å√Çƒö≈û‚ï£‚ïë‚ïó‚ïù≈ª≈º‚îê‚îî‚î¥‚î¨‚îú‚îÄ‚îºƒÇƒÉ‚ïö‚ïî‚ï©‚ï¶‚ï†‚ïê‚ï¨¬§ƒëƒêƒé√ãƒè≈á√ç√éƒõ‚îò‚îå‚ñà‚ñÑ≈¢≈Æ‚ñÄ√ì√ü√î≈É≈Ñ≈à≈†≈°≈î√ö≈ï≈∞√Ω√ù≈£¬¥¬≠ÀùÀõÀáÀò¬ß√∑¬∏¬∞¬®Àô≈±≈ò≈ô‚ñ†¬†"
  },
  "ibm852": "cp852",
  "csibm852": "cp852",
  "cp855": {
    "type": "_sbcs",
    "chars": "—í–Ç—ì–É—ë–Å—î–Ñ—ï–Ö—ñ–Ü—ó–á—ò–à—ô–â—ö–ä—õ–ã—ú–å—û–é—ü–è—é–Æ—ä–™–∞–ê–±–ë—Ü–¶–¥–î–µ–ï—Ñ–§–≥–ì¬´¬ª‚ñë‚ñí‚ñì‚îÇ‚î§—Ö–•–∏–ò‚ï£‚ïë‚ïó‚ïù–π–ô‚îê‚îî‚î¥‚î¨‚îú‚îÄ‚îº–∫–ö‚ïö‚ïî‚ï©‚ï¶‚ï†‚ïê‚ï¨¬§–ª–õ–º–ú–Ω–ù–æ–û–ø‚îò‚îå‚ñà‚ñÑ–ü—è‚ñÄ–Ø—Ä–†—Å–°—Ç–¢—É–£–∂–ñ–≤–í—å–¨‚Ññ¬≠—ã–´–∑–ó—à–®—ç–≠—â–©—á–ß¬ß‚ñ†¬†"
  },
  "ibm855": "cp855",
  "csibm855": "cp855",
  "cp856": {
    "type": "_sbcs",
    "chars": "◊ê◊ë◊í◊ì◊î◊ï◊ñ◊ó◊ò◊ô◊ö◊õ◊ú◊ù◊û◊ü◊†◊°◊¢◊£◊§◊•◊¶◊ß◊®◊©◊™ÔøΩ¬£ÔøΩ√óÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩ¬Æ¬¨¬Ω¬ºÔøΩ¬´¬ª‚ñë‚ñí‚ñì‚îÇ‚î§ÔøΩÔøΩÔøΩ¬©‚ï£‚ïë‚ïó‚ïù¬¢¬•‚îê‚îî‚î¥‚î¨‚îú‚îÄ‚îºÔøΩÔøΩ‚ïö‚ïî‚ï©‚ï¶‚ï†‚ïê‚ï¨¬§ÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩ‚îò‚îå‚ñà‚ñÑ¬¶ÔøΩ‚ñÄÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩ¬µÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩ¬Ø¬¥¬≠¬±‚Äó¬æ¬∂¬ß√∑¬∏¬∞¬®¬∑¬π¬≥¬≤‚ñ†¬†"
  },
  "ibm856": "cp856",
  "csibm856": "cp856",
  "cp857": {
    "type": "_sbcs",
    "chars": "√á√º√©√¢√§√†√•√ß√™√´√®√Ø√Æƒ±√Ñ√Ö√â√¶√Ü√¥√∂√≤√ª√πƒ∞√ñ√ú√∏¬£√ò≈û≈ü√°√≠√≥√∫√±√ëƒûƒü¬ø¬Æ¬¨¬Ω¬º¬°¬´¬ª‚ñë‚ñí‚ñì‚îÇ‚î§√Å√Ç√Ä¬©‚ï£‚ïë‚ïó‚ïù¬¢¬•‚îê‚îî‚î¥‚î¨‚îú‚îÄ‚îº√£√É‚ïö‚ïî‚ï©‚ï¶‚ï†‚ïê‚ï¨¬§¬∫¬™√ä√ã√àÔøΩ√ç√é√è‚îò‚îå‚ñà‚ñÑ¬¶√å‚ñÄ√ì√ü√î√í√µ√ï¬µÔøΩ√ó√ö√õ√ô√¨√ø¬Ø¬¥¬≠¬±ÔøΩ¬æ¬∂¬ß√∑¬∏¬∞¬®¬∑¬π¬≥¬≤‚ñ†¬†"
  },
  "ibm857": "cp857",
  "csibm857": "cp857",
  "cp858": {
    "type": "_sbcs",
    "chars": "√á√º√©√¢√§√†√•√ß√™√´√®√Ø√Æ√¨√Ñ√Ö√â√¶√Ü√¥√∂√≤√ª√π√ø√ñ√ú√∏¬£√ò√ó∆í√°√≠√≥√∫√±√ë¬™¬∫¬ø¬Æ¬¨¬Ω¬º¬°¬´¬ª‚ñë‚ñí‚ñì‚îÇ‚î§√Å√Ç√Ä¬©‚ï£‚ïë‚ïó‚ïù¬¢¬•‚îê‚îî‚î¥‚î¨‚îú‚îÄ‚îº√£√É‚ïö‚ïî‚ï©‚ï¶‚ï†‚ïê‚ï¨¬§√∞√ê√ä√ã√à‚Ç¨√ç√é√è‚îò‚îå‚ñà‚ñÑ¬¶√å‚ñÄ√ì√ü√î√í√µ√ï¬µ√æ√û√ö√õ√ô√Ω√ù¬Ø¬¥¬≠¬±‚Äó¬æ¬∂¬ß√∑¬∏¬∞¬®¬∑¬π¬≥¬≤‚ñ†¬†"
  },
  "ibm858": "cp858",
  "csibm858": "cp858",
  "cp860": {
    "type": "_sbcs",
    "chars": "√á√º√©√¢√£√†√Å√ß√™√ä√®√ç√î√¨√É√Ç√â√Ä√à√¥√µ√≤√ö√π√å√ï√ú¬¢¬£√ô‚Çß√ì√°√≠√≥√∫√±√ë¬™¬∫¬ø√í¬¨¬Ω¬º¬°¬´¬ª‚ñë‚ñí‚ñì‚îÇ‚î§‚ï°‚ï¢‚ïñ‚ïï‚ï£‚ïë‚ïó‚ïù‚ïú‚ïõ‚îê‚îî‚î¥‚î¨‚îú‚îÄ‚îº‚ïû‚ïü‚ïö‚ïî‚ï©‚ï¶‚ï†‚ïê‚ï¨‚ïß‚ï®‚ï§‚ï•‚ïô‚ïò‚ïí‚ïì‚ï´‚ï™‚îò‚îå‚ñà‚ñÑ‚ñå‚ñê‚ñÄŒ±√üŒìœÄŒ£œÉ¬µœÑŒ¶ŒòŒ©Œ¥‚àûœÜŒµ‚à©‚â°¬±‚â•‚â§‚å†‚å°√∑‚âà¬∞‚àô¬∑‚àö‚Åø¬≤‚ñ†¬†"
  },
  "ibm860": "cp860",
  "csibm860": "cp860",
  "cp861": {
    "type": "_sbcs",
    "chars": "√á√º√©√¢√§√†√•√ß√™√´√®√ê√∞√û√Ñ√Ö√â√¶√Ü√¥√∂√æ√ª√ù√Ω√ñ√ú√∏¬£√ò‚Çß∆í√°√≠√≥√∫√Å√ç√ì√ö¬ø‚åê¬¨¬Ω¬º¬°¬´¬ª‚ñë‚ñí‚ñì‚îÇ‚î§‚ï°‚ï¢‚ïñ‚ïï‚ï£‚ïë‚ïó‚ïù‚ïú‚ïõ‚îê‚îî‚î¥‚î¨‚îú‚îÄ‚îº‚ïû‚ïü‚ïö‚ïî‚ï©‚ï¶‚ï†‚ïê‚ï¨‚ïß‚ï®‚ï§‚ï•‚ïô‚ïò‚ïí‚ïì‚ï´‚ï™‚îò‚îå‚ñà‚ñÑ‚ñå‚ñê‚ñÄŒ±√üŒìœÄŒ£œÉ¬µœÑŒ¶ŒòŒ©Œ¥‚àûœÜŒµ‚à©‚â°¬±‚â•‚â§‚å†‚å°√∑‚âà¬∞‚àô¬∑‚àö‚Åø¬≤‚ñ†¬†"
  },
  "ibm861": "cp861",
  "csibm861": "cp861",
  "cp862": {
    "type": "_sbcs",
    "chars": "◊ê◊ë◊í◊ì◊î◊ï◊ñ◊ó◊ò◊ô◊ö◊õ◊ú◊ù◊û◊ü◊†◊°◊¢◊£◊§◊•◊¶◊ß◊®◊©◊™¬¢¬£¬•‚Çß∆í√°√≠√≥√∫√±√ë¬™¬∫¬ø‚åê¬¨¬Ω¬º¬°¬´¬ª‚ñë‚ñí‚ñì‚îÇ‚î§‚ï°‚ï¢‚ïñ‚ïï‚ï£‚ïë‚ïó‚ïù‚ïú‚ïõ‚îê‚îî‚î¥‚î¨‚îú‚îÄ‚îº‚ïû‚ïü‚ïö‚ïî‚ï©‚ï¶‚ï†‚ïê‚ï¨‚ïß‚ï®‚ï§‚ï•‚ïô‚ïò‚ïí‚ïì‚ï´‚ï™‚îò‚îå‚ñà‚ñÑ‚ñå‚ñê‚ñÄŒ±√üŒìœÄŒ£œÉ¬µœÑŒ¶ŒòŒ©Œ¥‚àûœÜŒµ‚à©‚â°¬±‚â•‚â§‚å†‚å°√∑‚âà¬∞‚àô¬∑‚àö‚Åø¬≤‚ñ†¬†"
  },
  "ibm862": "cp862",
  "csibm862": "cp862",
  "cp863": {
    "type": "_sbcs",
    "chars": "√á√º√©√¢√Ç√†¬∂√ß√™√´√®√Ø√Æ‚Äó√Ä¬ß√â√à√ä√¥√ã√è√ª√π¬§√î√ú¬¢¬£√ô√õ∆í¬¶¬¥√≥√∫¬®¬∏¬≥¬Ø√é‚åê¬¨¬Ω¬º¬æ¬´¬ª‚ñë‚ñí‚ñì‚îÇ‚î§‚ï°‚ï¢‚ïñ‚ïï‚ï£‚ïë‚ïó‚ïù‚ïú‚ïõ‚îê‚îî‚î¥‚î¨‚îú‚îÄ‚îº‚ïû‚ïü‚ïö‚ïî‚ï©‚ï¶‚ï†‚ïê‚ï¨‚ïß‚ï®‚ï§‚ï•‚ïô‚ïò‚ïí‚ïì‚ï´‚ï™‚îò‚îå‚ñà‚ñÑ‚ñå‚ñê‚ñÄŒ±√üŒìœÄŒ£œÉ¬µœÑŒ¶ŒòŒ©Œ¥‚àûœÜŒµ‚à©‚â°¬±‚â•‚â§‚å†‚å°√∑‚âà¬∞‚àô¬∑‚àö‚Åø¬≤‚ñ†¬†"
  },
  "ibm863": "cp863",
  "csibm863": "cp863",
  "cp864": {
    "type": "_sbcs",
    "chars": "\u0000\u0001\u0002\u0003\u0004\u0005\u0006\u0007\b\t\n\u000b\f\r\u000e\u000f\u0010\u0011\u0012\u0013\u0014\u0015\u0016\u0017\u0018\u0019\u001a\u001b\u001c\u001d\u001e\u001f !\"#$Ÿ™&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~¬∞¬∑‚àô‚àö‚ñí‚îÄ‚îÇ‚îº‚î§‚î¨‚îú‚î¥‚îê‚îå‚îî‚îòŒ≤‚àûœÜ¬±¬Ω¬º‚âà¬´¬ªÔª∑Ôª∏ÔøΩÔøΩÔªªÔªºÔøΩ¬†¬≠Ô∫Ç¬£¬§Ô∫ÑÔøΩÔøΩÔ∫éÔ∫èÔ∫ïÔ∫ôÿåÔ∫ùÔ∫°Ô∫•Ÿ†Ÿ°Ÿ¢Ÿ£Ÿ§Ÿ•Ÿ¶ŸßŸ®Ÿ©ÔªëÿõÔ∫±Ô∫µÔ∫πÿü¬¢Ô∫ÄÔ∫ÅÔ∫ÉÔ∫ÖÔªäÔ∫ãÔ∫çÔ∫ëÔ∫ìÔ∫óÔ∫õÔ∫üÔ∫£Ô∫ßÔ∫©Ô∫´Ô∫≠Ô∫ØÔ∫≥Ô∫∑Ô∫ªÔ∫øÔªÅÔªÖÔªãÔªè¬¶¬¨√∑√óÔªâŸÄÔªìÔªóÔªõÔªüÔª£ÔªßÔª´Ôª≠ÔªØÔª≥Ô∫ΩÔªåÔªéÔªçÔª°ÔπΩŸëÔª•Ôª©Ôª¨Ôª∞Ôª≤ÔªêÔªïÔªµÔª∂ÔªùÔªôÔª±‚ñ†ÔøΩ"
  },
  "ibm864": "cp864",
  "csibm864": "cp864",
  "cp865": {
    "type": "_sbcs",
    "chars": "√á√º√©√¢√§√†√•√ß√™√´√®√Ø√Æ√¨√Ñ√Ö√â√¶√Ü√¥√∂√≤√ª√π√ø√ñ√ú√∏¬£√ò‚Çß∆í√°√≠√≥√∫√±√ë¬™¬∫¬ø‚åê¬¨¬Ω¬º¬°¬´¬§‚ñë‚ñí‚ñì‚îÇ‚î§‚ï°‚ï¢‚ïñ‚ïï‚ï£‚ïë‚ïó‚ïù‚ïú‚ïõ‚îê‚îî‚î¥‚î¨‚îú‚îÄ‚îº‚ïû‚ïü‚ïö‚ïî‚ï©‚ï¶‚ï†‚ïê‚ï¨‚ïß‚ï®‚ï§‚ï•‚ïô‚ïò‚ïí‚ïì‚ï´‚ï™‚îò‚îå‚ñà‚ñÑ‚ñå‚ñê‚ñÄŒ±√üŒìœÄŒ£œÉ¬µœÑŒ¶ŒòŒ©Œ¥‚àûœÜŒµ‚à©‚â°¬±‚â•‚â§‚å†‚å°√∑‚âà¬∞‚àô¬∑‚àö‚Åø¬≤‚ñ†¬†"
  },
  "ibm865": "cp865",
  "csibm865": "cp865",
  "cp866": {
    "type": "_sbcs",
    "chars": "–ê–ë–í–ì–î–ï–ñ–ó–ò–ô–ö–õ–ú–ù–û–ü–†–°–¢–£–§–•–¶–ß–®–©–™–´–¨–≠–Æ–Ø–∞–±–≤–≥–¥–µ–∂–∑–∏–π–∫–ª–º–Ω–æ–ø‚ñë‚ñí‚ñì‚îÇ‚î§‚ï°‚ï¢‚ïñ‚ïï‚ï£‚ïë‚ïó‚ïù‚ïú‚ïõ‚îê‚îî‚î¥‚î¨‚îú‚îÄ‚îº‚ïû‚ïü‚ïö‚ïî‚ï©‚ï¶‚ï†‚ïê‚ï¨‚ïß‚ï®‚ï§‚ï•‚ïô‚ïò‚ïí‚ïì‚ï´‚ï™‚îò‚îå‚ñà‚ñÑ‚ñå‚ñê‚ñÄ—Ä—Å—Ç—É—Ñ—Ö—Ü—á—à—â—ä—ã—å—ç—é—è–Å—ë–Ñ—î–á—ó–é—û¬∞‚àô¬∑‚àö‚Ññ¬§‚ñ†¬†"
  },
  "ibm866": "cp866",
  "csibm866": "cp866",
  "cp869": {
    "type": "_sbcs",
    "chars": "ÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩŒÜÔøΩ¬∑¬¨¬¶‚Äò‚ÄôŒà‚ÄïŒâŒäŒ™ŒåÔøΩÔøΩŒéŒ´¬©Œè¬≤¬≥Œ¨¬£Œ≠ŒÆŒØœäŒêœåœçŒëŒíŒìŒîŒïŒñŒó¬ΩŒòŒô¬´¬ª‚ñë‚ñí‚ñì‚îÇ‚î§ŒöŒõŒúŒù‚ï£‚ïë‚ïó‚ïùŒûŒü‚îê‚îî‚î¥‚î¨‚îú‚îÄ‚îºŒ†Œ°‚ïö‚ïî‚ï©‚ï¶‚ï†‚ïê‚ï¨Œ£Œ§Œ•Œ¶ŒßŒ®Œ©Œ±Œ≤Œ≥‚îò‚îå‚ñà‚ñÑŒ¥Œµ‚ñÄŒ∂Œ∑Œ∏ŒπŒ∫ŒªŒºŒΩŒæŒøœÄœÅœÉœÇœÑŒÑ¬≠¬±œÖœÜœá¬ßœàŒÖ¬∞¬®œâœãŒ∞œé‚ñ†¬†"
  },
  "ibm869": "cp869",
  "csibm869": "cp869",
  "cp922": {
    "type": "_sbcs",
    "chars": "¬Ä¬Å¬Ç¬É¬Ñ¬Ö¬Ü¬á¬à¬â¬ä¬ã¬å¬ç¬é¬è¬ê¬ë¬í¬ì¬î¬ï¬ñ¬ó¬ò¬ô¬ö¬õ¬ú¬ù¬û¬ü¬†¬°¬¢¬£¬§¬•¬¶¬ß¬®¬©¬™¬´¬¨¬≠¬Æ‚Äæ¬∞¬±¬≤¬≥¬¥¬µ¬∂¬∑¬∏¬π¬∫¬ª¬º¬Ω¬æ¬ø√Ä√Å√Ç√É√Ñ√Ö√Ü√á√à√â√ä√ã√å√ç√é√è≈†√ë√í√ì√î√ï√ñ√ó√ò√ô√ö√õ√ú√ù≈Ω√ü√†√°√¢√£√§√•√¶√ß√®√©√™√´√¨√≠√Æ√Ø≈°√±√≤√≥√¥√µ√∂√∑√∏√π√∫√ª√º√Ω≈æ√ø"
  },
  "ibm922": "cp922",
  "csibm922": "cp922",
  "cp1046": {
    "type": "_sbcs",
    "chars": "Ô∫à√ó√∑Ô£∂Ô£µÔ£¥Ô£∑Ôπ±¬à‚ñ†‚îÇ‚îÄ‚îê‚îå‚îî‚îòÔππÔπªÔπΩÔπøÔπ∑Ô∫äÔª∞Ôª≥Ôª≤ÔªéÔªèÔªêÔª∂Ôª∏Ôª∫Ôªº¬†Ô£∫Ô£πÔ£∏¬§Ô£ªÔ∫ãÔ∫ëÔ∫óÔ∫õÔ∫üÔ∫£ÿå¬≠Ô∫ßÔ∫≥Ÿ†Ÿ°Ÿ¢Ÿ£Ÿ§Ÿ•Ÿ¶ŸßŸ®Ÿ©Ô∫∑ÿõÔ∫ªÔ∫øÔªäÿüÔªãÿ°ÿ¢ÿ£ÿ§ÿ•ÿ¶ÿßÿ®ÿ©ÿ™ÿ´ÿ¨ÿ≠ÿÆÿØÿ∞ÿ±ÿ≤ÿ≥ÿ¥ÿµÿ∂ÿ∑Ôªáÿπÿ∫ÔªåÔ∫ÇÔ∫ÑÔ∫éÔªìŸÄŸÅŸÇŸÉŸÑŸÖŸÜŸáŸàŸâŸäŸãŸåŸçŸéŸèŸêŸëŸíÔªóÔªõÔªüÔ£ºÔªµÔª∑ÔªπÔªªÔª£ÔªßÔª¨Ôª©ÔøΩ"
  },
  "ibm1046": "cp1046",
  "csibm1046": "cp1046",
  "cp1124": {
    "type": "_sbcs",
    "chars": "¬Ä¬Å¬Ç¬É¬Ñ¬Ö¬Ü¬á¬à¬â¬ä¬ã¬å¬ç¬é¬è¬ê¬ë¬í¬ì¬î¬ï¬ñ¬ó¬ò¬ô¬ö¬õ¬ú¬ù¬û¬ü¬†–Å–Ç“ê–Ñ–Ö–Ü–á–à–â–ä–ã–å¬≠–é–è–ê–ë–í–ì–î–ï–ñ–ó–ò–ô–ö–õ–ú–ù–û–ü–†–°–¢–£–§–•–¶–ß–®–©–™–´–¨–≠–Æ–Ø–∞–±–≤–≥–¥–µ–∂–∑–∏–π–∫–ª–º–Ω–æ–ø—Ä—Å—Ç—É—Ñ—Ö—Ü—á—à—â—ä—ã—å—ç—é—è‚Ññ—ë—í“ë—î—ï—ñ—ó—ò—ô—ö—õ—ú¬ß—û—ü"
  },
  "ibm1124": "cp1124",
  "csibm1124": "cp1124",
  "cp1125": {
    "type": "_sbcs",
    "chars": "–ê–ë–í–ì–î–ï–ñ–ó–ò–ô–ö–õ–ú–ù–û–ü–†–°–¢–£–§–•–¶–ß–®–©–™–´–¨–≠–Æ–Ø–∞–±–≤–≥–¥–µ–∂–∑–∏–π–∫–ª–º–Ω–æ–ø‚ñë‚ñí‚ñì‚îÇ‚î§‚ï°‚ï¢‚ïñ‚ïï‚ï£‚ïë‚ïó‚ïù‚ïú‚ïõ‚îê‚îî‚î¥‚î¨‚îú‚îÄ‚îº‚ïû‚ïü‚ïö‚ïî‚ï©‚ï¶‚ï†‚ïê‚ï¨‚ïß‚ï®‚ï§‚ï•‚ïô‚ïò‚ïí‚ïì‚ï´‚ï™‚îò‚îå‚ñà‚ñÑ‚ñå‚ñê‚ñÄ—Ä—Å—Ç—É—Ñ—Ö—Ü—á—à—â—ä—ã—å—ç—é—è–Å—ë“ê“ë–Ñ—î–Ü—ñ–á—ó¬∑‚àö‚Ññ¬§‚ñ†¬†"
  },
  "ibm1125": "cp1125",
  "csibm1125": "cp1125",
  "cp1129": {
    "type": "_sbcs",
    "chars": "¬Ä¬Å¬Ç¬É¬Ñ¬Ö¬Ü¬á¬à¬â¬ä¬ã¬å¬ç¬é¬è¬ê¬ë¬í¬ì¬î¬ï¬ñ¬ó¬ò¬ô¬ö¬õ¬ú¬ù¬û¬ü¬†¬°¬¢¬£¬§¬•¬¶¬ß≈ì¬©¬™¬´¬¨¬≠¬Æ¬Ø¬∞¬±¬≤¬≥≈∏¬µ¬∂¬∑≈í¬π¬∫¬ª¬º¬Ω¬æ¬ø√Ä√Å√ÇƒÇ√Ñ√Ö√Ü√á√à√â√ä√ãÃÄ√ç√é√èƒê√ëÃâ√ì√î∆†√ñ√ó√ò√ô√ö√õ√ú∆ØÃÉ√ü√†√°√¢ƒÉ√§√•√¶√ß√®√©√™√´ÃÅ√≠√Æ√Øƒë√±Ã£√≥√¥∆°√∂√∑√∏√π√∫√ª√º∆∞‚Ç´√ø"
  },
  "ibm1129": "cp1129",
  "csibm1129": "cp1129",
  "cp1133": {
    "type": "_sbcs",
    "chars": "¬Ä¬Å¬Ç¬É¬Ñ¬Ö¬Ü¬á¬à¬â¬ä¬ã¬å¬ç¬é¬è¬ê¬ë¬í¬ì¬î¬ï¬ñ¬ó¬ò¬ô¬ö¬õ¬ú¬ù¬û¬ü¬†‡∫Å‡∫Ç‡∫Ñ‡∫á‡∫à‡∫™‡∫ä‡∫ç‡∫î‡∫ï‡∫ñ‡∫ó‡∫ô‡∫ö‡∫õ‡∫ú‡∫ù‡∫û‡∫ü‡∫°‡∫¢‡∫£‡∫•‡∫ß‡∫´‡∫≠‡∫ÆÔøΩÔøΩÔøΩ‡∫Ø‡∫∞‡∫≤‡∫≥‡∫¥‡∫µ‡∫∂‡∫∑‡∫∏‡∫π‡∫º‡∫±‡∫ª‡∫ΩÔøΩÔøΩÔøΩ‡ªÄ‡ªÅ‡ªÇ‡ªÉ‡ªÑ‡ªà‡ªâ‡ªä‡ªã‡ªå‡ªç‡ªÜÔøΩ‡ªú‡ªù‚Ç≠ÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩ‡ªê‡ªë‡ªí‡ªì‡ªî‡ªï‡ªñ‡ªó‡ªò‡ªôÔøΩÔøΩ¬¢¬¨¬¶ÔøΩ"
  },
  "ibm1133": "cp1133",
  "csibm1133": "cp1133",
  "cp1161": {
    "type": "_sbcs",
    "chars": "ÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩ‡πà‡∏Å‡∏Ç‡∏É‡∏Ñ‡∏Ö‡∏Ü‡∏á‡∏à‡∏â‡∏ä‡∏ã‡∏å‡∏ç‡∏é‡∏è‡∏ê‡∏ë‡∏í‡∏ì‡∏î‡∏ï‡∏ñ‡∏ó‡∏ò‡∏ô‡∏ö‡∏õ‡∏ú‡∏ù‡∏û‡∏ü‡∏†‡∏°‡∏¢‡∏£‡∏§‡∏•‡∏¶‡∏ß‡∏®‡∏©‡∏™‡∏´‡∏¨‡∏≠‡∏Æ‡∏Ø‡∏∞‡∏±‡∏≤‡∏≥‡∏¥‡∏µ‡∏∂‡∏∑‡∏∏‡∏π‡∏∫‡πâ‡πä‡πã‚Ç¨‡∏ø‡πÄ‡πÅ‡πÇ‡πÉ‡πÑ‡πÖ‡πÜ‡πá‡πà‡πâ‡πä‡πã‡πå‡πç‡πé‡πè‡πê‡πë‡πí‡πì‡πî‡πï‡πñ‡πó‡πò‡πô‡πö‡πõ¬¢¬¨¬¶¬†"
  },
  "ibm1161": "cp1161",
  "csibm1161": "cp1161",
  "cp1162": {
    "type": "_sbcs",
    "chars": "‚Ç¨¬Å¬Ç¬É¬Ñ‚Ä¶¬Ü¬á¬à¬â¬ä¬ã¬å¬ç¬é¬è¬ê‚Äò‚Äô‚Äú‚Äù‚Ä¢‚Äì‚Äî¬ò¬ô¬ö¬õ¬ú¬ù¬û¬ü¬†‡∏Å‡∏Ç‡∏É‡∏Ñ‡∏Ö‡∏Ü‡∏á‡∏à‡∏â‡∏ä‡∏ã‡∏å‡∏ç‡∏é‡∏è‡∏ê‡∏ë‡∏í‡∏ì‡∏î‡∏ï‡∏ñ‡∏ó‡∏ò‡∏ô‡∏ö‡∏õ‡∏ú‡∏ù‡∏û‡∏ü‡∏†‡∏°‡∏¢‡∏£‡∏§‡∏•‡∏¶‡∏ß‡∏®‡∏©‡∏™‡∏´‡∏¨‡∏≠‡∏Æ‡∏Ø‡∏∞‡∏±‡∏≤‡∏≥‡∏¥‡∏µ‡∏∂‡∏∑‡∏∏‡∏π‡∏∫ÔøΩÔøΩÔøΩÔøΩ‡∏ø‡πÄ‡πÅ‡πÇ‡πÉ‡πÑ‡πÖ‡πÜ‡πá‡πà‡πâ‡πä‡πã‡πå‡πç‡πé‡πè‡πê‡πë‡πí‡πì‡πî‡πï‡πñ‡πó‡πò‡πô‡πö‡πõÔøΩÔøΩÔøΩÔøΩ"
  },
  "ibm1162": "cp1162",
  "csibm1162": "cp1162",
  "cp1163": {
    "type": "_sbcs",
    "chars": "¬Ä¬Å¬Ç¬É¬Ñ¬Ö¬Ü¬á¬à¬â¬ä¬ã¬å¬ç¬é¬è¬ê¬ë¬í¬ì¬î¬ï¬ñ¬ó¬ò¬ô¬ö¬õ¬ú¬ù¬û¬ü¬†¬°¬¢¬£‚Ç¨¬•¬¶¬ß≈ì¬©¬™¬´¬¨¬≠¬Æ¬Ø¬∞¬±¬≤¬≥≈∏¬µ¬∂¬∑≈í¬π¬∫¬ª¬º¬Ω¬æ¬ø√Ä√Å√ÇƒÇ√Ñ√Ö√Ü√á√à√â√ä√ãÃÄ√ç√é√èƒê√ëÃâ√ì√î∆†√ñ√ó√ò√ô√ö√õ√ú∆ØÃÉ√ü√†√°√¢ƒÉ√§√•√¶√ß√®√©√™√´ÃÅ√≠√Æ√Øƒë√±Ã£√≥√¥∆°√∂√∑√∏√π√∫√ª√º∆∞‚Ç´√ø"
  },
  "ibm1163": "cp1163",
  "csibm1163": "cp1163",
  "maccroatian": {
    "type": "_sbcs",
    "chars": "√Ñ√Ö√á√â√ë√ñ√ú√°√†√¢√§√£√•√ß√©√®√™√´√≠√¨√Æ√Ø√±√≥√≤√¥√∂√µ√∫√π√ª√º‚Ä†¬∞¬¢¬£¬ß‚Ä¢¬∂√ü¬Æ≈†‚Ñ¢¬¥¬®‚â†≈Ω√ò‚àû¬±‚â§‚â•‚àÜ¬µ‚àÇ‚àë‚àè≈°‚à´¬™¬∫‚Ñ¶≈æ√∏¬ø¬°¬¨‚àö∆í‚âàƒÜ¬´ƒå‚Ä¶¬†√Ä√É√ï≈í≈ìƒê‚Äî‚Äú‚Äù‚Äò‚Äô√∑‚óäÔøΩ¬©‚ÅÑ¬§‚Äπ‚Ä∫√Ü¬ª‚Äì¬∑‚Äö‚Äû‚Ä∞√Çƒá√Åƒç√à√ç√é√è√å√ì√îƒë√í√ö√õ√ôƒ±ÀÜÀú¬ØœÄ√ãÀö¬∏√ä√¶Àá"
  },
  "maccyrillic": {
    "type": "_sbcs",
    "chars": "–ê–ë–í–ì–î–ï–ñ–ó–ò–ô–ö–õ–ú–ù–û–ü–†–°–¢–£–§–•–¶–ß–®–©–™–´–¨–≠–Æ–Ø‚Ä†¬∞¬¢¬£¬ß‚Ä¢¬∂–Ü¬Æ¬©‚Ñ¢–Ç—í‚â†–É—ì‚àû¬±‚â§‚â•—ñ¬µ‚àÇ–à–Ñ—î–á—ó–â—ô–ä—ö—ò–Ö¬¨‚àö∆í‚âà‚àÜ¬´¬ª‚Ä¶¬†–ã—õ–å—ú—ï‚Äì‚Äî‚Äú‚Äù‚Äò‚Äô√∑‚Äû–é—û–è—ü‚Ññ–Å—ë—è–∞–±–≤–≥–¥–µ–∂–∑–∏–π–∫–ª–º–Ω–æ–ø—Ä—Å—Ç—É—Ñ—Ö—Ü—á—à—â—ä—ã—å—ç—é¬§"
  },
  "macgreek": {
    "type": "_sbcs",
    "chars": "√Ñ¬π¬≤√â¬≥√ñ√úŒÖ√†√¢√§ŒÑ¬®√ß√©√®√™√´¬£‚Ñ¢√Æ√Ø‚Ä¢¬Ω‚Ä∞√¥√∂¬¶¬≠√π√ª√º‚Ä†ŒìŒîŒòŒõŒûŒ†√ü¬Æ¬©Œ£Œ™¬ß‚â†¬∞ŒáŒë¬±‚â§‚â•¬•ŒíŒïŒñŒóŒôŒöŒúŒ¶Œ´Œ®Œ©Œ¨Œù¬¨ŒüŒ°‚âàŒ§¬´¬ª‚Ä¶¬†Œ•ŒßŒÜŒà≈ì‚Äì‚Äï‚Äú‚Äù‚Äò‚Äô√∑ŒâŒäŒåŒéŒ≠ŒÆŒØœåŒèœçŒ±Œ≤œàŒ¥ŒµœÜŒ≥Œ∑ŒπŒæŒ∫ŒªŒºŒΩŒøœÄœéœÅœÉœÑŒ∏œâœÇœáœÖŒ∂œäœãŒêŒ∞ÔøΩ"
  },
  "maciceland": {
    "type": "_sbcs",
    "chars": "√Ñ√Ö√á√â√ë√ñ√ú√°√†√¢√§√£√•√ß√©√®√™√´√≠√¨√Æ√Ø√±√≥√≤√¥√∂√µ√∫√π√ª√º√ù¬∞¬¢¬£¬ß‚Ä¢¬∂√ü¬Æ¬©‚Ñ¢¬¥¬®‚â†√Ü√ò‚àû¬±‚â§‚â•¬•¬µ‚àÇ‚àë‚àèœÄ‚à´¬™¬∫‚Ñ¶√¶√∏¬ø¬°¬¨‚àö∆í‚âà‚àÜ¬´¬ª‚Ä¶¬†√Ä√É√ï≈í≈ì‚Äì‚Äî‚Äú‚Äù‚Äò‚Äô√∑‚óä√ø≈∏‚ÅÑ¬§√ê√∞√û√æ√Ω¬∑‚Äö‚Äû‚Ä∞√Ç√ä√Å√ã√à√ç√é√è√å√ì√îÔøΩ√í√ö√õ√ôƒ±ÀÜÀú¬ØÀòÀôÀö¬∏ÀùÀõÀá"
  },
  "macroman": {
    "type": "_sbcs",
    "chars": "√Ñ√Ö√á√â√ë√ñ√ú√°√†√¢√§√£√•√ß√©√®√™√´√≠√¨√Æ√Ø√±√≥√≤√¥√∂√µ√∫√π√ª√º‚Ä†¬∞¬¢¬£¬ß‚Ä¢¬∂√ü¬Æ¬©‚Ñ¢¬¥¬®‚â†√Ü√ò‚àû¬±‚â§‚â•¬•¬µ‚àÇ‚àë‚àèœÄ‚à´¬™¬∫‚Ñ¶√¶√∏¬ø¬°¬¨‚àö∆í‚âà‚àÜ¬´¬ª‚Ä¶¬†√Ä√É√ï≈í≈ì‚Äì‚Äî‚Äú‚Äù‚Äò‚Äô√∑‚óä√ø≈∏‚ÅÑ¬§‚Äπ‚Ä∫Ô¨ÅÔ¨Ç‚Ä°¬∑‚Äö‚Äû‚Ä∞√Ç√ä√Å√ã√à√ç√é√è√å√ì√îÔøΩ√í√ö√õ√ôƒ±ÀÜÀú¬ØÀòÀôÀö¬∏ÀùÀõÀá"
  },
  "macromania": {
    "type": "_sbcs",
    "chars": "√Ñ√Ö√á√â√ë√ñ√ú√°√†√¢√§√£√•√ß√©√®√™√´√≠√¨√Æ√Ø√±√≥√≤√¥√∂√µ√∫√π√ª√º‚Ä†¬∞¬¢¬£¬ß‚Ä¢¬∂√ü¬Æ¬©‚Ñ¢¬¥¬®‚â†ƒÇ≈û‚àû¬±‚â§‚â•¬•¬µ‚àÇ‚àë‚àèœÄ‚à´¬™¬∫‚Ñ¶ƒÉ≈ü¬ø¬°¬¨‚àö∆í‚âà‚àÜ¬´¬ª‚Ä¶¬†√Ä√É√ï≈í≈ì‚Äì‚Äî‚Äú‚Äù‚Äò‚Äô√∑‚óä√ø≈∏‚ÅÑ¬§‚Äπ‚Ä∫≈¢≈£‚Ä°¬∑‚Äö‚Äû‚Ä∞√Ç√ä√Å√ã√à√ç√é√è√å√ì√îÔøΩ√í√ö√õ√ôƒ±ÀÜÀú¬ØÀòÀôÀö¬∏ÀùÀõÀá"
  },
  "macthai": {
    "type": "_sbcs",
    "chars": "¬´¬ª‚Ä¶Ô¢åÔ¢èÔ¢íÔ¢ïÔ¢òÔ¢ãÔ¢éÔ¢ëÔ¢îÔ¢ó‚Äú‚ÄùÔ¢ôÔøΩ‚Ä¢Ô¢ÑÔ¢âÔ¢ÖÔ¢ÜÔ¢áÔ¢àÔ¢äÔ¢çÔ¢êÔ¢ìÔ¢ñ‚Äò‚ÄôÔøΩ¬†‡∏Å‡∏Ç‡∏É‡∏Ñ‡∏Ö‡∏Ü‡∏á‡∏à‡∏â‡∏ä‡∏ã‡∏å‡∏ç‡∏é‡∏è‡∏ê‡∏ë‡∏í‡∏ì‡∏î‡∏ï‡∏ñ‡∏ó‡∏ò‡∏ô‡∏ö‡∏õ‡∏ú‡∏ù‡∏û‡∏ü‡∏†‡∏°‡∏¢‡∏£‡∏§‡∏•‡∏¶‡∏ß‡∏®‡∏©‡∏™‡∏´‡∏¨‡∏≠‡∏Æ‡∏Ø‡∏∞‡∏±‡∏≤‡∏≥‡∏¥‡∏µ‡∏∂‡∏∑‡∏∏‡∏π‡∏∫Ôªø‚Äã‚Äì‚Äî‡∏ø‡πÄ‡πÅ‡πÇ‡πÉ‡πÑ‡πÖ‡πÜ‡πá‡πà‡πâ‡πä‡πã‡πå‡πç‚Ñ¢‡πè‡πê‡πë‡πí‡πì‡πî‡πï‡πñ‡πó‡πò‡πô¬Æ¬©ÔøΩÔøΩÔøΩÔøΩ"
  },
  "macturkish": {
    "type": "_sbcs",
    "chars": "√Ñ√Ö√á√â√ë√ñ√ú√°√†√¢√§√£√•√ß√©√®√™√´√≠√¨√Æ√Ø√±√≥√≤√¥√∂√µ√∫√π√ª√º‚Ä†¬∞¬¢¬£¬ß‚Ä¢¬∂√ü¬Æ¬©‚Ñ¢¬¥¬®‚â†√Ü√ò‚àû¬±‚â§‚â•¬•¬µ‚àÇ‚àë‚àèœÄ‚à´¬™¬∫‚Ñ¶√¶√∏¬ø¬°¬¨‚àö∆í‚âà‚àÜ¬´¬ª‚Ä¶¬†√Ä√É√ï≈í≈ì‚Äì‚Äî‚Äú‚Äù‚Äò‚Äô√∑‚óä√ø≈∏ƒûƒüƒ∞ƒ±≈û≈ü‚Ä°¬∑‚Äö‚Äû‚Ä∞√Ç√ä√Å√ã√à√ç√é√è√å√ì√îÔøΩ√í√ö√õ√ôÔøΩÀÜÀú¬ØÀòÀôÀö¬∏ÀùÀõÀá"
  },
  "macukraine": {
    "type": "_sbcs",
    "chars": "–ê–ë–í–ì–î–ï–ñ–ó–ò–ô–ö–õ–ú–ù–û–ü–†–°–¢–£–§–•–¶–ß–®–©–™–´–¨–≠–Æ–Ø‚Ä†¬∞“ê¬£¬ß‚Ä¢¬∂–Ü¬Æ¬©‚Ñ¢–Ç—í‚â†–É—ì‚àû¬±‚â§‚â•—ñ¬µ“ë–à–Ñ—î–á—ó–â—ô–ä—ö—ò–Ö¬¨‚àö∆í‚âà‚àÜ¬´¬ª‚Ä¶¬†–ã—õ–å—ú—ï‚Äì‚Äî‚Äú‚Äù‚Äò‚Äô√∑‚Äû–é—û–è—ü‚Ññ–Å—ë—è–∞–±–≤–≥–¥–µ–∂–∑–∏–π–∫–ª–º–Ω–æ–ø—Ä—Å—Ç—É—Ñ—Ö—Ü—á—à—â—ä—ã—å—ç—é¬§"
  },
  "koi8r": {
    "type": "_sbcs",
    "chars": "‚îÄ‚îÇ‚îå‚îê‚îî‚îò‚îú‚î§‚î¨‚î¥‚îº‚ñÄ‚ñÑ‚ñà‚ñå‚ñê‚ñë‚ñí‚ñì‚å†‚ñ†‚àô‚àö‚âà‚â§‚â•¬†‚å°¬∞¬≤¬∑√∑‚ïê‚ïë‚ïí—ë‚ïì‚ïî‚ïï‚ïñ‚ïó‚ïò‚ïô‚ïö‚ïõ‚ïú‚ïù‚ïû‚ïü‚ï†‚ï°–Å‚ï¢‚ï£‚ï§‚ï•‚ï¶‚ïß‚ï®‚ï©‚ï™‚ï´‚ï¨¬©—é–∞–±—Ü–¥–µ—Ñ–≥—Ö–∏–π–∫–ª–º–Ω–æ–ø—è—Ä—Å—Ç—É–∂–≤—å—ã–∑—à—ç—â—á—ä–Æ–ê–ë–¶–î–ï–§–ì–•–ò–ô–ö–õ–ú–ù–û–ü–Ø–†–°–¢–£–ñ–í–¨–´–ó–®–≠–©–ß–™"
  },
  "koi8u": {
    "type": "_sbcs",
    "chars": "‚îÄ‚îÇ‚îå‚îê‚îî‚îò‚îú‚î§‚î¨‚î¥‚îº‚ñÄ‚ñÑ‚ñà‚ñå‚ñê‚ñë‚ñí‚ñì‚å†‚ñ†‚àô‚àö‚âà‚â§‚â•¬†‚å°¬∞¬≤¬∑√∑‚ïê‚ïë‚ïí—ë—î‚ïî—ñ—ó‚ïó‚ïò‚ïô‚ïö‚ïõ“ë‚ïù‚ïû‚ïü‚ï†‚ï°–Å–Ñ‚ï£–Ü–á‚ï¶‚ïß‚ï®‚ï©‚ï™“ê‚ï¨¬©—é–∞–±—Ü–¥–µ—Ñ–≥—Ö–∏–π–∫–ª–º–Ω–æ–ø—è—Ä—Å—Ç—É–∂–≤—å—ã–∑—à—ç—â—á—ä–Æ–ê–ë–¶–î–ï–§–ì–•–ò–ô–ö–õ–ú–ù–û–ü–Ø–†–°–¢–£–ñ–í–¨–´–ó–®–≠–©–ß–™"
  },
  "koi8ru": {
    "type": "_sbcs",
    "chars": "‚îÄ‚îÇ‚îå‚îê‚îî‚îò‚îú‚î§‚î¨‚î¥‚îº‚ñÄ‚ñÑ‚ñà‚ñå‚ñê‚ñë‚ñí‚ñì‚å†‚ñ†‚àô‚àö‚âà‚â§‚â•¬†‚å°¬∞¬≤¬∑√∑‚ïê‚ïë‚ïí—ë—î‚ïî—ñ—ó‚ïó‚ïò‚ïô‚ïö‚ïõ“ë—û‚ïû‚ïü‚ï†‚ï°–Å–Ñ‚ï£–Ü–á‚ï¶‚ïß‚ï®‚ï©‚ï™“ê–é¬©—é–∞–±—Ü–¥–µ—Ñ–≥—Ö–∏–π–∫–ª–º–Ω–æ–ø—è—Ä—Å—Ç—É–∂–≤—å—ã–∑—à—ç—â—á—ä–Æ–ê–ë–¶–î–ï–§–ì–•–ò–ô–ö–õ–ú–ù–û–ü–Ø–†–°–¢–£–ñ–í–¨–´–ó–®–≠–©–ß–™"
  },
  "koi8t": {
    "type": "_sbcs",
    "chars": "“õ“ì‚Äö“í‚Äû‚Ä¶‚Ä†‚Ä°ÔøΩ‚Ä∞“≥‚Äπ“≤“∑“∂ÔøΩ“ö‚Äò‚Äô‚Äú‚Äù‚Ä¢‚Äì‚ÄîÔøΩ‚Ñ¢ÔøΩ‚Ä∫ÔøΩÔøΩÔøΩÔøΩÔøΩ”Ø”Æ—ë¬§”£¬¶¬ßÔøΩÔøΩÔøΩ¬´¬¨¬≠¬ÆÔøΩ¬∞¬±¬≤–ÅÔøΩ”¢¬∂¬∑ÔøΩ‚ÑñÔøΩ¬ªÔøΩÔøΩÔøΩ¬©—é–∞–±—Ü–¥–µ—Ñ–≥—Ö–∏–π–∫–ª–º–Ω–æ–ø—è—Ä—Å—Ç—É–∂–≤—å—ã–∑—à—ç—â—á—ä–Æ–ê–ë–¶–î–ï–§–ì–•–ò–ô–ö–õ–ú–ù–û–ü–Ø–†–°–¢–£–ñ–í–¨–´–ó–®–≠–©–ß–™"
  },
  "armscii8": {
    "type": "_sbcs",
    "chars": "¬Ä¬Å¬Ç¬É¬Ñ¬Ö¬Ü¬á¬à¬â¬ä¬ã¬å¬ç¬é¬è¬ê¬ë¬í¬ì¬î¬ï¬ñ¬ó¬ò¬ô¬ö¬õ¬ú¬ù¬û¬ü¬†ÔøΩ÷á÷â)(¬ª¬´‚Äî.’ù,-÷ä‚Ä¶’ú’õ’û‘±’°‘≤’¢‘≥’£‘¥’§‘µ’•‘∂’¶‘∑’ß‘∏’®‘π’©‘∫’™‘ª’´‘º’¨‘Ω’≠‘æ’Æ‘ø’Ø’Ä’∞’Å’±’Ç’≤’É’≥’Ñ’¥’Ö’µ’Ü’∂’á’∑’à’∏’â’π’ä’∫’ã’ª’å’º’ç’Ω’é’æ’è’ø’ê÷Ä’ë÷Å’í÷Ç’ì÷É’î÷Ñ’ï÷Ö’ñ÷Ü’öÔøΩ"
  },
  "rk1048": {
    "type": "_sbcs",
    "chars": "–Ç–É‚Äö—ì‚Äû‚Ä¶‚Ä†‚Ä°‚Ç¨‚Ä∞–â‚Äπ–ä“ö“∫–è—í‚Äò‚Äô‚Äú‚Äù‚Ä¢‚Äì‚ÄîÔøΩ‚Ñ¢—ô‚Ä∫—ö“õ“ª—ü¬†“∞“±”ò¬§”®¬¶¬ß–Å¬©“í¬´¬¨¬≠¬Æ“Æ¬∞¬±–Ü—ñ”©¬µ¬∂¬∑—ë‚Ññ“ì¬ª”ô“¢“£“Ø–ê–ë–í–ì–î–ï–ñ–ó–ò–ô–ö–õ–ú–ù–û–ü–†–°–¢–£–§–•–¶–ß–®–©–™–´–¨–≠–Æ–Ø–∞–±–≤–≥–¥–µ–∂–∑–∏–π–∫–ª–º–Ω–æ–ø—Ä—Å—Ç—É—Ñ—Ö—Ü—á—à—â—ä—ã—å—ç—é—è"
  },
  "tcvn": {
    "type": "_sbcs",
    "chars": "\u0000√ö·ª§\u0003·ª™·ª¨·ªÆ\u0007\b\t\n\u000b\f\r\u000e\u000f\u0010·ª®·ª∞·ª≤·ª∂·ª∏√ù·ª¥\u0018\u0019\u001a\u001b\u001c\u001d\u001e\u001f !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~√Ä·∫¢√É√Å·∫†·∫∂·∫¨√à·∫∫·∫º√â·∫∏·ªÜ√å·ªàƒ®√ç·ªä√í·ªé√ï√ì·ªå·ªò·ªú·ªû·ª†·ªö·ª¢√ô·ª¶≈®¬†ƒÇ√Ç√ä√î∆†∆ØƒêƒÉ√¢√™√¥∆°∆∞ƒë·∫∞ÃÄÃâÃÉÃÅÃ£√†·∫£√£√°·∫°·∫≤·∫±·∫≥·∫µ·∫Ø·∫¥·∫Æ·∫¶·∫®·∫™·∫§·ªÄ·∫∑·∫ß·∫©·∫´·∫•·∫≠√®·ªÇ·∫ª·∫Ω√©·∫π·ªÅ·ªÉ·ªÖ·∫ø·ªá√¨·ªâ·ªÑ·∫æ·ªíƒ©√≠·ªã√≤·ªî·ªè√µ√≥·ªç·ªì·ªï·ªó·ªë·ªô·ªù·ªü·ª°·ªõ·ª£√π·ªñ·ªß≈©√∫·ª•·ª´·ª≠·ªØ·ª©·ª±·ª≥·ª∑·ªπ√Ω·ªµ·ªê"
  },
  "georgianacademy": {
    "type": "_sbcs",
    "chars": "¬Ä¬Å‚Äö∆í‚Äû‚Ä¶‚Ä†‚Ä°ÀÜ‚Ä∞≈†‚Äπ≈í¬ç¬é¬è¬ê‚Äò‚Äô‚Äú‚Äù‚Ä¢‚Äì‚ÄîÀú‚Ñ¢≈°‚Ä∫≈ì¬ù¬û≈∏¬†¬°¬¢¬£¬§¬•¬¶¬ß¬®¬©¬™¬´¬¨¬≠¬Æ¬Ø¬∞¬±¬≤¬≥¬¥¬µ¬∂¬∑¬∏¬π¬∫¬ª¬º¬Ω¬æ¬ø·Éê·Éë·Éí·Éì·Éî·Éï·Éñ·Éó·Éò·Éô·Éö·Éõ·Éú·Éù·Éû·Éü·É†·É°·É¢·É£·É§·É•·É¶·Éß·É®·É©·É™·É´·É¨·É≠·ÉÆ·ÉØ·É∞·É±·É≤·É≥·É¥·Éµ·É∂√ß√®√©√™√´√¨√≠√Æ√Ø√∞√±√≤√≥√¥√µ√∂√∑√∏√π√∫√ª√º√Ω√æ√ø"
  },
  "georgianps": {
    "type": "_sbcs",
    "chars": "¬Ä¬Å‚Äö∆í‚Äû‚Ä¶‚Ä†‚Ä°ÀÜ‚Ä∞≈†‚Äπ≈í¬ç¬é¬è¬ê‚Äò‚Äô‚Äú‚Äù‚Ä¢‚Äì‚ÄîÀú‚Ñ¢≈°‚Ä∫≈ì¬ù¬û≈∏¬†¬°¬¢¬£¬§¬•¬¶¬ß¬®¬©¬™¬´¬¨¬≠¬Æ¬Ø¬∞¬±¬≤¬≥¬¥¬µ¬∂¬∑¬∏¬π¬∫¬ª¬º¬Ω¬æ¬ø·Éê·Éë·Éí·Éì·Éî·Éï·Éñ·É±·Éó·Éò·Éô·Éö·Éõ·Éú·É≤·Éù·Éû·Éü·É†·É°·É¢·É≥·É£·É§·É•·É¶·Éß·É®·É©·É™·É´·É¨·É≠·ÉÆ·É¥·ÉØ·É∞·Éµ√¶√ß√®√©√™√´√¨√≠√Æ√Ø√∞√±√≤√≥√¥√µ√∂√∑√∏√π√∫√ª√º√Ω√æ√ø"
  },
  "pt154": {
    "type": "_sbcs",
    "chars": "“ñ“í”Æ“ì‚Äû‚Ä¶“∂“Æ“≤“Ø“†”¢“¢“ö“∫“∏“ó‚Äò‚Äô‚Äú‚Äù‚Ä¢‚Äì‚Äî“≥“∑“°”£“£“õ“ª“π¬†–é—û–à”®“ò“∞¬ß–Å¬©”ò¬´¬¨”Ø¬Æ“ú¬∞“±–Ü—ñ“ô”©¬∂¬∑—ë‚Ññ”ô¬ª—ò“™“´“ù–ê–ë–í–ì–î–ï–ñ–ó–ò–ô–ö–õ–ú–ù–û–ü–†–°–¢–£–§–•–¶–ß–®–©–™–´–¨–≠–Æ–Ø–∞–±–≤–≥–¥–µ–∂–∑–∏–π–∫–ª–º–Ω–æ–ø—Ä—Å—Ç—É—Ñ—Ö—Ü—á—à—â—ä—ã—å—ç—é—è"
  },
  "viscii": {
    "type": "_sbcs",
    "chars": "\u0000\u0001·∫≤\u0003\u0004·∫¥·∫™\u0007\b\t\n\u000b\f\r\u000e\u000f\u0010\u0011\u0012\u0013·ª∂\u0015\u0016\u0017\u0018·ª∏\u001a\u001b\u001c\u001d·ª¥\u001f !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~·∫†·∫Æ·∫∞·∫∂·∫§·∫¶·∫®·∫¨·∫º·∫∏·∫æ·ªÄ·ªÇ·ªÑ·ªÜ·ªê·ªí·ªî·ªñ·ªò·ª¢·ªö·ªú·ªû·ªä·ªé·ªå·ªà·ª¶≈®·ª§·ª≤√ï·∫Ø·∫±·∫∑·∫•·∫ß·∫©·∫≠·∫Ω·∫π·∫ø·ªÅ·ªÉ·ªÖ·ªá·ªë·ªì·ªï·ªó·ª†∆†·ªô·ªù·ªü·ªã·ª∞·ª®·ª™·ª¨∆°·ªõ∆Ø√Ä√Å√Ç√É·∫¢ƒÇ·∫≥·∫µ√à√â√ä·∫∫√å√çƒ®·ª≥ƒê·ª©√í√ì√î·∫°·ª∑·ª´·ª≠√ô√ö·ªπ·ªµ√ù·ª°∆∞√†√°√¢√£·∫£ƒÉ·ªØ·∫´√®√©√™·∫ª√¨√≠ƒ©·ªâƒë·ª±√≤√≥√¥√µ·ªè·ªç·ª•√π√∫≈©·ªß√Ω·ª£·ªÆ"
  },
  "iso646cn": {
    "type": "_sbcs",
    "chars": "\u0000\u0001\u0002\u0003\u0004\u0005\u0006\u0007\b\t\n\u000b\f\r\u000e\u000f\u0010\u0011\u0012\u0013\u0014\u0015\u0016\u0017\u0018\u0019\u001a\u001b\u001c\u001d\u001e\u001f !\"#¬•%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}‚ÄæÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩ"
  },
  "iso646jp": {
    "type": "_sbcs",
    "chars": "\u0000\u0001\u0002\u0003\u0004\u0005\u0006\u0007\b\t\n\u000b\f\r\u000e\u000f\u0010\u0011\u0012\u0013\u0014\u0015\u0016\u0017\u0018\u0019\u001a\u001b\u001c\u001d\u001e\u001f !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[¬•]^_`abcdefghijklmnopqrstuvwxyz{|}‚ÄæÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩ"
  },
  "hproman8": {
    "type": "_sbcs",
    "chars": "¬Ä¬Å¬Ç¬É¬Ñ¬Ö¬Ü¬á¬à¬â¬ä¬ã¬å¬ç¬é¬è¬ê¬ë¬í¬ì¬î¬ï¬ñ¬ó¬ò¬ô¬ö¬õ¬ú¬ù¬û¬ü¬†√Ä√Ç√à√ä√ã√é√è¬¥ÀãÀÜ¬®Àú√ô√õ‚Ç§¬Ø√ù√Ω¬∞√á√ß√ë√±¬°¬ø¬§¬£¬•¬ß∆í¬¢√¢√™√¥√ª√°√©√≥√∫√†√®√≤√π√§√´√∂√º√Ö√Æ√ò√Ü√•√≠√∏√¶√Ñ√¨√ñ√ú√â√Ø√ü√î√Å√É√£√ê√∞√ç√å√ì√í√ï√µ≈†≈°√ö≈∏√ø√û√æ¬∑¬µ¬∂¬æ‚Äî¬º¬Ω¬™¬∫¬´‚ñ†¬ª¬±ÔøΩ"
  },
  "macintosh": {
    "type": "_sbcs",
    "chars": "√Ñ√Ö√á√â√ë√ñ√ú√°√†√¢√§√£√•√ß√©√®√™√´√≠√¨√Æ√Ø√±√≥√≤√¥√∂√µ√∫√π√ª√º‚Ä†¬∞¬¢¬£¬ß‚Ä¢¬∂√ü¬Æ¬©‚Ñ¢¬¥¬®‚â†√Ü√ò‚àû¬±‚â§‚â•¬•¬µ‚àÇ‚àë‚àèœÄ‚à´¬™¬∫‚Ñ¶√¶√∏¬ø¬°¬¨‚àö∆í‚âà‚àÜ¬´¬ª‚Ä¶¬†√Ä√É√ï≈í≈ì‚Äì‚Äî‚Äú‚Äù‚Äò‚Äô√∑‚óä√ø≈∏‚ÅÑ¬§‚Äπ‚Ä∫Ô¨ÅÔ¨Ç‚Ä°¬∑‚Äö‚Äû‚Ä∞√Ç√ä√Å√ã√à√ç√é√è√å√ì√îÔøΩ√í√ö√õ√ôƒ±ÀÜÀú¬ØÀòÀôÀö¬∏ÀùÀõÀá"
  },
  "ascii": {
    "type": "_sbcs",
    "chars": "ÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩ"
  },
  "tis620": {
    "type": "_sbcs",
    "chars": "ÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩ‡∏Å‡∏Ç‡∏É‡∏Ñ‡∏Ö‡∏Ü‡∏á‡∏à‡∏â‡∏ä‡∏ã‡∏å‡∏ç‡∏é‡∏è‡∏ê‡∏ë‡∏í‡∏ì‡∏î‡∏ï‡∏ñ‡∏ó‡∏ò‡∏ô‡∏ö‡∏õ‡∏ú‡∏ù‡∏û‡∏ü‡∏†‡∏°‡∏¢‡∏£‡∏§‡∏•‡∏¶‡∏ß‡∏®‡∏©‡∏™‡∏´‡∏¨‡∏≠‡∏Æ‡∏Ø‡∏∞‡∏±‡∏≤‡∏≥‡∏¥‡∏µ‡∏∂‡∏∑‡∏∏‡∏π‡∏∫ÔøΩÔøΩÔøΩÔøΩ‡∏ø‡πÄ‡πÅ‡πÇ‡πÉ‡πÑ‡πÖ‡πÜ‡πá‡πà‡πâ‡πä‡πã‡πå‡πç‡πé‡πè‡πê‡πë‡πí‡πì‡πî‡πï‡πñ‡πó‡πò‡πô‡πö‡πõÔøΩÔøΩÔøΩÔøΩ"
  }
}

/***/ }),

/***/ 21899:
/***/ ((module) => {

"use strict";


// Manually added data to be used by sbcs codec in addition to generated one.

module.exports = {
    // Not supported by iconv, not sure why.
    "10029": "maccenteuro",
    "maccenteuro": {
        "type": "_sbcs",
        "chars": "√ÑƒÄƒÅ√âƒÑ√ñ√ú√°ƒÖƒå√§ƒçƒÜƒá√©≈π≈∫ƒé√≠ƒèƒíƒìƒñ√≥ƒó√¥√∂√µ√∫ƒöƒõ√º‚Ä†¬∞ƒò¬£¬ß‚Ä¢¬∂√ü¬Æ¬©‚Ñ¢ƒô¬®‚â†ƒ£ƒÆƒØƒ™‚â§‚â•ƒ´ƒ∂‚àÇ‚àë≈ÇƒªƒºƒΩƒæƒπƒ∫≈Ö≈Ü≈É¬¨‚àö≈Ñ≈á‚àÜ¬´¬ª‚Ä¶¬†≈à≈ê√ï≈ë≈å‚Äì‚Äî‚Äú‚Äù‚Äò‚Äô√∑‚óä≈ç≈î≈ï≈ò‚Äπ‚Ä∫≈ô≈ñ≈ó≈†‚Äö‚Äû≈°≈ö≈õ√Å≈§≈•√ç≈Ω≈æ≈™√ì√î≈´≈Æ√ö≈Ø≈∞≈±≈≤≈≥√ù√Ωƒ∑≈ª≈Å≈ºƒ¢Àá"
    },

    "808": "cp808",
    "ibm808": "cp808",
    "cp808": {
        "type": "_sbcs",
        "chars": "–ê–ë–í–ì–î–ï–ñ–ó–ò–ô–ö–õ–ú–ù–û–ü–†–°–¢–£–§–•–¶–ß–®–©–™–´–¨–≠–Æ–Ø–∞–±–≤–≥–¥–µ–∂–∑–∏–π–∫–ª–º–Ω–æ–ø‚ñë‚ñí‚ñì‚îÇ‚î§‚ï°‚ï¢‚ïñ‚ïï‚ï£‚ïë‚ïó‚ïù‚ïú‚ïõ‚îê‚îî‚î¥‚î¨‚îú‚îÄ‚îº‚ïû‚ïü‚ïö‚ïî‚ï©‚ï¶‚ï†‚ïê‚ï¨‚ïß‚ï®‚ï§‚ï•‚ïô‚ïò‚ïí‚ïì‚ï´‚ï™‚îò‚îå‚ñà‚ñÑ‚ñå‚ñê‚ñÄ—Ä—Å—Ç—É—Ñ—Ö—Ü—á—à—â—ä—ã—å—ç—é—è–Å—ë–Ñ—î–á—ó–é—û¬∞‚àô¬∑‚àö‚Ññ‚Ç¨‚ñ†¬†"
    },

    "mik": {
        "type": "_sbcs",
        "chars": "–ê–ë–í–ì–î–ï–ñ–ó–ò–ô–ö–õ–ú–ù–û–ü–†–°–¢–£–§–•–¶–ß–®–©–™–´–¨–≠–Æ–Ø–∞–±–≤–≥–¥–µ–∂–∑–∏–π–∫–ª–º–Ω–æ–ø—Ä—Å—Ç—É—Ñ—Ö—Ü—á—à—â—ä—ã—å—ç—é—è‚îî‚î¥‚î¨‚îú‚îÄ‚îº‚ï£‚ïë‚ïö‚ïî‚ï©‚ï¶‚ï†‚ïê‚ï¨‚îê‚ñë‚ñí‚ñì‚îÇ‚î§‚Ññ¬ß‚ïó‚ïù‚îò‚îå‚ñà‚ñÑ‚ñå‚ñê‚ñÄŒ±√üŒìœÄŒ£œÉ¬µœÑŒ¶ŒòŒ©Œ¥‚àûœÜŒµ‚à©‚â°¬±‚â•‚â§‚å†‚å°√∑‚âà¬∞‚àô¬∑‚àö‚Åø¬≤‚ñ†¬†"
    },

    // Aliases of generated encodings.
    "ascii8bit": "ascii",
    "usascii": "ascii",
    "ansix34": "ascii",
    "ansix341968": "ascii",
    "ansix341986": "ascii",
    "csascii": "ascii",
    "cp367": "ascii",
    "ibm367": "ascii",
    "isoir6": "ascii",
    "iso646us": "ascii",
    "iso646irv": "ascii",
    "us": "ascii",

    "latin1": "iso88591",
    "latin2": "iso88592",
    "latin3": "iso88593",
    "latin4": "iso88594",
    "latin5": "iso88599",
    "latin6": "iso885910",
    "latin7": "iso885913",
    "latin8": "iso885914",
    "latin9": "iso885915",
    "latin10": "iso885916",

    "csisolatin1": "iso88591",
    "csisolatin2": "iso88592",
    "csisolatin3": "iso88593",
    "csisolatin4": "iso88594",
    "csisolatincyrillic": "iso88595",
    "csisolatinarabic": "iso88596",
    "csisolatingreek" : "iso88597",
    "csisolatinhebrew": "iso88598",
    "csisolatin5": "iso88599",
    "csisolatin6": "iso885910",

    "l1": "iso88591",
    "l2": "iso88592",
    "l3": "iso88593",
    "l4": "iso88594",
    "l5": "iso88599",
    "l6": "iso885910",
    "l7": "iso885913",
    "l8": "iso885914",
    "l9": "iso885915",
    "l10": "iso885916",

    "isoir14": "iso646jp",
    "isoir57": "iso646cn",
    "isoir100": "iso88591",
    "isoir101": "iso88592",
    "isoir109": "iso88593",
    "isoir110": "iso88594",
    "isoir144": "iso88595",
    "isoir127": "iso88596",
    "isoir126": "iso88597",
    "isoir138": "iso88598",
    "isoir148": "iso88599",
    "isoir157": "iso885910",
    "isoir166": "tis620",
    "isoir179": "iso885913",
    "isoir199": "iso885914",
    "isoir203": "iso885915",
    "isoir226": "iso885916",

    "cp819": "iso88591",
    "ibm819": "iso88591",

    "cyrillic": "iso88595",

    "arabic": "iso88596",
    "arabic8": "iso88596",
    "ecma114": "iso88596",
    "asmo708": "iso88596",

    "greek" : "iso88597",
    "greek8" : "iso88597",
    "ecma118" : "iso88597",
    "elot928" : "iso88597",

    "hebrew": "iso88598",
    "hebrew8": "iso88598",

    "turkish": "iso88599",
    "turkish8": "iso88599",

    "thai": "iso885911",
    "thai8": "iso885911",

    "celtic": "iso885914",
    "celtic8": "iso885914",
    "isoceltic": "iso885914",

    "tis6200": "tis620",
    "tis62025291": "tis620",
    "tis62025330": "tis620",

    "10000": "macroman",
    "10006": "macgreek",
    "10007": "maccyrillic",
    "10079": "maciceland",
    "10081": "macturkish",

    "cspc8codepage437": "cp437",
    "cspc775baltic": "cp775",
    "cspc850multilingual": "cp850",
    "cspcp852": "cp852",
    "cspc862latinhebrew": "cp862",
    "cpgr": "cp869",

    "msee": "cp1250",
    "mscyrl": "cp1251",
    "msansi": "cp1252",
    "msgreek": "cp1253",
    "msturk": "cp1254",
    "mshebr": "cp1255",
    "msarab": "cp1256",
    "winbaltrim": "cp1257",

    "cp20866": "koi8r",
    "20866": "koi8r",
    "ibm878": "koi8r",
    "cskoi8r": "koi8r",

    "cp21866": "koi8u",
    "21866": "koi8u",
    "ibm1168": "koi8u",

    "strk10482002": "rk1048",

    "tcvn5712": "tcvn",
    "tcvn57121": "tcvn",

    "gb198880": "iso646cn",
    "cn": "iso646cn",

    "csiso14jisc6220ro": "iso646jp",
    "jisc62201969ro": "iso646jp",
    "jp": "iso646jp",

    "cshproman8": "hproman8",
    "r8": "hproman8",
    "roman8": "hproman8",
    "xroman8": "hproman8",
    "ibm1051": "hproman8",

    "mac": "macintosh",
    "csmacintosh": "macintosh",
};



/***/ }),

/***/ 52947:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

var Buffer = (__nccwpck_require__(12803).Buffer);

// Note: UTF16-LE (or UCS2) codec is Node.js native. See encodings/internal.js

// == UTF16-BE codec. ==========================================================

exports.utf16be = Utf16BECodec;
function Utf16BECodec() {
}

Utf16BECodec.prototype.encoder = Utf16BEEncoder;
Utf16BECodec.prototype.decoder = Utf16BEDecoder;
Utf16BECodec.prototype.bomAware = true;


// -- Encoding

function Utf16BEEncoder() {
}

Utf16BEEncoder.prototype.write = function(str) {
    var buf = Buffer.from(str, 'ucs2');
    for (var i = 0; i < buf.length; i += 2) {
        var tmp = buf[i]; buf[i] = buf[i+1]; buf[i+1] = tmp;
    }
    return buf;
}

Utf16BEEncoder.prototype.end = function() {
}


// -- Decoding

function Utf16BEDecoder() {
    this.overflowByte = -1;
}

Utf16BEDecoder.prototype.write = function(buf) {
    if (buf.length == 0)
        return '';

    var buf2 = Buffer.alloc(buf.length + 1),
        i = 0, j = 0;

    if (this.overflowByte !== -1) {
        buf2[0] = buf[0];
        buf2[1] = this.overflowByte;
        i = 1; j = 2;
    }

    for (; i < buf.length-1; i += 2, j+= 2) {
        buf2[j] = buf[i+1];
        buf2[j+1] = buf[i];
    }

    this.overflowByte = (i == buf.length-1) ? buf[buf.length-1] : -1;

    return buf2.slice(0, j).toString('ucs2');
}

Utf16BEDecoder.prototype.end = function() {
}


// == UTF-16 codec =============================================================
// Decoder chooses automatically from UTF-16LE and UTF-16BE using BOM and space-based heuristic.
// Defaults to UTF-16LE, as it's prevalent and default in Node.
// http://en.wikipedia.org/wiki/UTF-16 and http://encoding.spec.whatwg.org/#utf-16le
// Decoder default can be changed: iconv.decode(buf, 'utf16', {defaultEncoding: 'utf-16be'});

// Encoder uses UTF-16LE and prepends BOM (which can be overridden with addBOM: false).

exports.utf16 = Utf16Codec;
function Utf16Codec(codecOptions, iconv) {
    this.iconv = iconv;
}

Utf16Codec.prototype.encoder = Utf16Encoder;
Utf16Codec.prototype.decoder = Utf16Decoder;


// -- Encoding (pass-through)

function Utf16Encoder(options, codec) {
    options = options || {};
    if (options.addBOM === undefined)
        options.addBOM = true;
    this.encoder = codec.iconv.getEncoder('utf-16le', options);
}

Utf16Encoder.prototype.write = function(str) {
    return this.encoder.write(str);
}

Utf16Encoder.prototype.end = function() {
    return this.encoder.end();
}


// -- Decoding

function Utf16Decoder(options, codec) {
    this.decoder = null;
    this.initialBytes = [];
    this.initialBytesLen = 0;

    this.options = options || {};
    this.iconv = codec.iconv;
}

Utf16Decoder.prototype.write = function(buf) {
    if (!this.decoder) {
        // Codec is not chosen yet. Accumulate initial bytes.
        this.initialBytes.push(buf);
        this.initialBytesLen += buf.length;
        
        if (this.initialBytesLen < 16) // We need more bytes to use space heuristic (see below)
            return '';

        // We have enough bytes -> detect endianness.
        var buf = Buffer.concat(this.initialBytes),
            encoding = detectEncoding(buf, this.options.defaultEncoding);
        this.decoder = this.iconv.getDecoder(encoding, this.options);
        this.initialBytes.length = this.initialBytesLen = 0;
    }

    return this.decoder.write(buf);
}

Utf16Decoder.prototype.end = function() {
    if (!this.decoder) {
        var buf = Buffer.concat(this.initialBytes),
            encoding = detectEncoding(buf, this.options.defaultEncoding);
        this.decoder = this.iconv.getDecoder(encoding, this.options);

        var res = this.decoder.write(buf),
            trail = this.decoder.end();

        return trail ? (res + trail) : res;
    }
    return this.decoder.end();
}

function detectEncoding(buf, defaultEncoding) {
    var enc = defaultEncoding || 'utf-16le';

    if (buf.length >= 2) {
        // Check BOM.
        if (buf[0] == 0xFE && buf[1] == 0xFF) // UTF-16BE BOM
            enc = 'utf-16be';
        else if (buf[0] == 0xFF && buf[1] == 0xFE) // UTF-16LE BOM
            enc = 'utf-16le';
        else {
            // No BOM found. Try to deduce encoding from initial content.
            // Most of the time, the content has ASCII chars (U+00**), but the opposite (U+**00) is uncommon.
            // So, we count ASCII as if it was LE or BE, and decide from that.
            var asciiCharsLE = 0, asciiCharsBE = 0, // Counts of chars in both positions
                _len = Math.min(buf.length - (buf.length % 2), 64); // Len is always even.

            for (var i = 0; i < _len; i += 2) {
                if (buf[i] === 0 && buf[i+1] !== 0) asciiCharsBE++;
                if (buf[i] !== 0 && buf[i+1] === 0) asciiCharsLE++;
            }

            if (asciiCharsBE > asciiCharsLE)
                enc = 'utf-16be';
            else if (asciiCharsBE < asciiCharsLE)
                enc = 'utf-16le';
        }
    }

    return enc;
}




/***/ }),

/***/ 95447:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

var Buffer = (__nccwpck_require__(12803).Buffer);

// UTF-7 codec, according to https://tools.ietf.org/html/rfc2152
// See also below a UTF-7-IMAP codec, according to http://tools.ietf.org/html/rfc3501#section-5.1.3

exports.utf7 = Utf7Codec;
exports.unicode11utf7 = 'utf7'; // Alias UNICODE-1-1-UTF-7
function Utf7Codec(codecOptions, iconv) {
    this.iconv = iconv;
};

Utf7Codec.prototype.encoder = Utf7Encoder;
Utf7Codec.prototype.decoder = Utf7Decoder;
Utf7Codec.prototype.bomAware = true;


// -- Encoding

var nonDirectChars = /[^A-Za-z0-9'\(\),-\.\/:\? \n\r\t]+/g;

function Utf7Encoder(options, codec) {
    this.iconv = codec.iconv;
}

Utf7Encoder.prototype.write = function(str) {
    // Naive implementation.
    // Non-direct chars are encoded as "+<base64>-"; single "+" char is encoded as "+-".
    return Buffer.from(str.replace(nonDirectChars, function(chunk) {
        return "+" + (chunk === '+' ? '' : 
            this.iconv.encode(chunk, 'utf16-be').toString('base64').replace(/=+$/, '')) 
            + "-";
    }.bind(this)));
}

Utf7Encoder.prototype.end = function() {
}


// -- Decoding

function Utf7Decoder(options, codec) {
    this.iconv = codec.iconv;
    this.inBase64 = false;
    this.base64Accum = '';
}

var base64Regex = /[A-Za-z0-9\/+]/;
var base64Chars = [];
for (var i = 0; i < 256; i++)
    base64Chars[i] = base64Regex.test(String.fromCharCode(i));

var plusChar = '+'.charCodeAt(0), 
    minusChar = '-'.charCodeAt(0),
    andChar = '&'.charCodeAt(0);

Utf7Decoder.prototype.write = function(buf) {
    var res = "", lastI = 0,
        inBase64 = this.inBase64,
        base64Accum = this.base64Accum;

    // The decoder is more involved as we must handle chunks in stream.

    for (var i = 0; i < buf.length; i++) {
        if (!inBase64) { // We're in direct mode.
            // Write direct chars until '+'
            if (buf[i] == plusChar) {
                res += this.iconv.decode(buf.slice(lastI, i), "ascii"); // Write direct chars.
                lastI = i+1;
                inBase64 = true;
            }
        } else { // We decode base64.
            if (!base64Chars[buf[i]]) { // Base64 ended.
                if (i == lastI && buf[i] == minusChar) {// "+-" -> "+"
                    res += "+";
                } else {
                    var b64str = base64Accum + buf.slice(lastI, i).toString();
                    res += this.iconv.decode(Buffer.from(b64str, 'base64'), "utf16-be");
                }

                if (buf[i] != minusChar) // Minus is absorbed after base64.
                    i--;

                lastI = i+1;
                inBase64 = false;
                base64Accum = '';
            }
        }
    }

    if (!inBase64) {
        res += this.iconv.decode(buf.slice(lastI), "ascii"); // Write direct chars.
    } else {
        var b64str = base64Accum + buf.slice(lastI).toString();

        var canBeDecoded = b64str.length - (b64str.length % 8); // Minimal chunk: 2 quads -> 2x3 bytes -> 3 chars.
        base64Accum = b64str.slice(canBeDecoded); // The rest will be decoded in future.
        b64str = b64str.slice(0, canBeDecoded);

        res += this.iconv.decode(Buffer.from(b64str, 'base64'), "utf16-be");
    }

    this.inBase64 = inBase64;
    this.base64Accum = base64Accum;

    return res;
}

Utf7Decoder.prototype.end = function() {
    var res = "";
    if (this.inBase64 && this.base64Accum.length > 0)
        res = this.iconv.decode(Buffer.from(this.base64Accum, 'base64'), "utf16-be");

    this.inBase64 = false;
    this.base64Accum = '';
    return res;
}


// UTF-7-IMAP codec.
// RFC3501 Sec. 5.1.3 Modified UTF-7 (http://tools.ietf.org/html/rfc3501#section-5.1.3)
// Differences:
//  * Base64 part is started by "&" instead of "+"
//  * Direct characters are 0x20-0x7E, except "&" (0x26)
//  * In Base64, "," is used instead of "/"
//  * Base64 must not be used to represent direct characters.
//  * No implicit shift back from Base64 (should always end with '-')
//  * String must end in non-shifted position.
//  * "-&" while in base64 is not allowed.


exports.utf7imap = Utf7IMAPCodec;
function Utf7IMAPCodec(codecOptions, iconv) {
    this.iconv = iconv;
};

Utf7IMAPCodec.prototype.encoder = Utf7IMAPEncoder;
Utf7IMAPCodec.prototype.decoder = Utf7IMAPDecoder;
Utf7IMAPCodec.prototype.bomAware = true;


// -- Encoding

function Utf7IMAPEncoder(options, codec) {
    this.iconv = codec.iconv;
    this.inBase64 = false;
    this.base64Accum = Buffer.alloc(6);
    this.base64AccumIdx = 0;
}

Utf7IMAPEncoder.prototype.write = function(str) {
    var inBase64 = this.inBase64,
        base64Accum = this.base64Accum,
        base64AccumIdx = this.base64AccumIdx,
        buf = Buffer.alloc(str.length*5 + 10), bufIdx = 0;

    for (var i = 0; i < str.length; i++) {
        var uChar = str.charCodeAt(i);
        if (0x20 <= uChar && uChar <= 0x7E) { // Direct character or '&'.
            if (inBase64) {
                if (base64AccumIdx > 0) {
                    bufIdx += buf.write(base64Accum.slice(0, base64AccumIdx).toString('base64').replace(/\//g, ',').replace(/=+$/, ''), bufIdx);
                    base64AccumIdx = 0;
                }

                buf[bufIdx++] = minusChar; // Write '-', then go to direct mode.
                inBase64 = false;
            }

            if (!inBase64) {
                buf[bufIdx++] = uChar; // Write direct character

                if (uChar === andChar)  // Ampersand -> '&-'
                    buf[bufIdx++] = minusChar;
            }

        } else { // Non-direct character
            if (!inBase64) {
                buf[bufIdx++] = andChar; // Write '&', then go to base64 mode.
                inBase64 = true;
            }
            if (inBase64) {
                base64Accum[base64AccumIdx++] = uChar >> 8;
                base64Accum[base64AccumIdx++] = uChar & 0xFF;

                if (base64AccumIdx == base64Accum.length) {
                    bufIdx += buf.write(base64Accum.toString('base64').replace(/\//g, ','), bufIdx);
                    base64AccumIdx = 0;
                }
            }
        }
    }

    this.inBase64 = inBase64;
    this.base64AccumIdx = base64AccumIdx;

    return buf.slice(0, bufIdx);
}

Utf7IMAPEncoder.prototype.end = function() {
    var buf = Buffer.alloc(10), bufIdx = 0;
    if (this.inBase64) {
        if (this.base64AccumIdx > 0) {
            bufIdx += buf.write(this.base64Accum.slice(0, this.base64AccumIdx).toString('base64').replace(/\//g, ',').replace(/=+$/, ''), bufIdx);
            this.base64AccumIdx = 0;
        }

        buf[bufIdx++] = minusChar; // Write '-', then go to direct mode.
        this.inBase64 = false;
    }

    return buf.slice(0, bufIdx);
}


// -- Decoding

function Utf7IMAPDecoder(options, codec) {
    this.iconv = codec.iconv;
    this.inBase64 = false;
    this.base64Accum = '';
}

var base64IMAPChars = base64Chars.slice();
base64IMAPChars[','.charCodeAt(0)] = true;

Utf7IMAPDecoder.prototype.write = function(buf) {
    var res = "", lastI = 0,
        inBase64 = this.inBase64,
        base64Accum = this.base64Accum;

    // The decoder is more involved as we must handle chunks in stream.
    // It is forgiving, closer to standard UTF-7 (for example, '-' is optional at the end).

    for (var i = 0; i < buf.length; i++) {
        if (!inBase64) { // We're in direct mode.
            // Write direct chars until '&'
            if (buf[i] == andChar) {
                res += this.iconv.decode(buf.slice(lastI, i), "ascii"); // Write direct chars.
                lastI = i+1;
                inBase64 = true;
            }
        } else { // We decode base64.
            if (!base64IMAPChars[buf[i]]) { // Base64 ended.
                if (i == lastI && buf[i] == minusChar) { // "&-" -> "&"
                    res += "&";
                } else {
                    var b64str = base64Accum + buf.slice(lastI, i).toString().replace(/,/g, '/');
                    res += this.iconv.decode(Buffer.from(b64str, 'base64'), "utf16-be");
                }

                if (buf[i] != minusChar) // Minus may be absorbed after base64.
                    i--;

                lastI = i+1;
                inBase64 = false;
                base64Accum = '';
            }
        }
    }

    if (!inBase64) {
        res += this.iconv.decode(buf.slice(lastI), "ascii"); // Write direct chars.
    } else {
        var b64str = base64Accum + buf.slice(lastI).toString().replace(/,/g, '/');

        var canBeDecoded = b64str.length - (b64str.length % 8); // Minimal chunk: 2 quads -> 2x3 bytes -> 3 chars.
        base64Accum = b64str.slice(canBeDecoded); // The rest will be decoded in future.
        b64str = b64str.slice(0, canBeDecoded);

        res += this.iconv.decode(Buffer.from(b64str, 'base64'), "utf16-be");
    }

    this.inBase64 = inBase64;
    this.base64Accum = base64Accum;

    return res;
}

Utf7IMAPDecoder.prototype.end = function() {
    var res = "";
    if (this.inBase64 && this.base64Accum.length > 0)
        res = this.iconv.decode(Buffer.from(this.base64Accum, 'base64'), "utf16-be");

    this.inBase64 = false;
    this.base64Accum = '';
    return res;
}




/***/ }),

/***/ 20250:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


var BOMChar = '\uFEFF';

exports.PrependBOM = PrependBOMWrapper
function PrependBOMWrapper(encoder, options) {
    this.encoder = encoder;
    this.addBOM = true;
}

PrependBOMWrapper.prototype.write = function(str) {
    if (this.addBOM) {
        str = BOMChar + str;
        this.addBOM = false;
    }

    return this.encoder.write(str);
}

PrependBOMWrapper.prototype.end = function() {
    return this.encoder.end();
}


//------------------------------------------------------------------------------

exports.StripBOM = StripBOMWrapper;
function StripBOMWrapper(decoder, options) {
    this.decoder = decoder;
    this.pass = false;
    this.options = options || {};
}

StripBOMWrapper.prototype.write = function(buf) {
    var res = this.decoder.write(buf);
    if (this.pass || !res)
        return res;

    if (res[0] === BOMChar) {
        res = res.slice(1);
        if (typeof this.options.stripBOM === 'function')
            this.options.stripBOM();
    }

    this.pass = true;
    return res;
}

StripBOMWrapper.prototype.end = function() {
    return this.decoder.end();
}



/***/ }),

/***/ 89547:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";

var Buffer = (__nccwpck_require__(20181).Buffer);
// Note: not polyfilled with safer-buffer on a purpose, as overrides Buffer

// == Extend Node primitives to use iconv-lite =================================

module.exports = function (iconv) {
    var original = undefined; // Place to keep original methods.

    // Node authors rewrote Buffer internals to make it compatible with
    // Uint8Array and we cannot patch key functions since then.
    // Note: this does use older Buffer API on a purpose
    iconv.supportsNodeEncodingsExtension = !(Buffer.from || new Buffer(0) instanceof Uint8Array);

    iconv.extendNodeEncodings = function extendNodeEncodings() {
        if (original) return;
        original = {};

        if (!iconv.supportsNodeEncodingsExtension) {
            console.error("ACTION NEEDED: require('iconv-lite').extendNodeEncodings() is not supported in your version of Node");
            console.error("See more info at https://github.com/ashtuchkin/iconv-lite/wiki/Node-v4-compatibility");
            return;
        }

        var nodeNativeEncodings = {
            'hex': true, 'utf8': true, 'utf-8': true, 'ascii': true, 'binary': true, 
            'base64': true, 'ucs2': true, 'ucs-2': true, 'utf16le': true, 'utf-16le': true,
        };

        Buffer.isNativeEncoding = function(enc) {
            return enc && nodeNativeEncodings[enc.toLowerCase()];
        }

        // -- SlowBuffer -----------------------------------------------------------
        var SlowBuffer = (__nccwpck_require__(20181).SlowBuffer);

        original.SlowBufferToString = SlowBuffer.prototype.toString;
        SlowBuffer.prototype.toString = function(encoding, start, end) {
            encoding = String(encoding || 'utf8').toLowerCase();

            // Use native conversion when possible
            if (Buffer.isNativeEncoding(encoding))
                return original.SlowBufferToString.call(this, encoding, start, end);

            // Otherwise, use our decoding method.
            if (typeof start == 'undefined') start = 0;
            if (typeof end == 'undefined') end = this.length;
            return iconv.decode(this.slice(start, end), encoding);
        }

        original.SlowBufferWrite = SlowBuffer.prototype.write;
        SlowBuffer.prototype.write = function(string, offset, length, encoding) {
            // Support both (string, offset, length, encoding)
            // and the legacy (string, encoding, offset, length)
            if (isFinite(offset)) {
                if (!isFinite(length)) {
                    encoding = length;
                    length = undefined;
                }
            } else {  // legacy
                var swap = encoding;
                encoding = offset;
                offset = length;
                length = swap;
            }

            offset = +offset || 0;
            var remaining = this.length - offset;
            if (!length) {
                length = remaining;
            } else {
                length = +length;
                if (length > remaining) {
                    length = remaining;
                }
            }
            encoding = String(encoding || 'utf8').toLowerCase();

            // Use native conversion when possible
            if (Buffer.isNativeEncoding(encoding))
                return original.SlowBufferWrite.call(this, string, offset, length, encoding);

            if (string.length > 0 && (length < 0 || offset < 0))
                throw new RangeError('attempt to write beyond buffer bounds');

            // Otherwise, use our encoding method.
            var buf = iconv.encode(string, encoding);
            if (buf.length < length) length = buf.length;
            buf.copy(this, offset, 0, length);
            return length;
        }

        // -- Buffer ---------------------------------------------------------------

        original.BufferIsEncoding = Buffer.isEncoding;
        Buffer.isEncoding = function(encoding) {
            return Buffer.isNativeEncoding(encoding) || iconv.encodingExists(encoding);
        }

        original.BufferByteLength = Buffer.byteLength;
        Buffer.byteLength = SlowBuffer.byteLength = function(str, encoding) {
            encoding = String(encoding || 'utf8').toLowerCase();

            // Use native conversion when possible
            if (Buffer.isNativeEncoding(encoding))
                return original.BufferByteLength.call(this, str, encoding);

            // Slow, I know, but we don't have a better way yet.
            return iconv.encode(str, encoding).length;
        }

        original.BufferToString = Buffer.prototype.toString;
        Buffer.prototype.toString = function(encoding, start, end) {
            encoding = String(encoding || 'utf8').toLowerCase();

            // Use native conversion when possible
            if (Buffer.isNativeEncoding(encoding))
                return original.BufferToString.call(this, encoding, start, end);

            // Otherwise, use our decoding method.
            if (typeof start == 'undefined') start = 0;
            if (typeof end == 'undefined') end = this.length;
            return iconv.decode(this.slice(start, end), encoding);
        }

        original.BufferWrite = Buffer.prototype.write;
        Buffer.prototype.write = function(string, offset, length, encoding) {
            var _offset = offset, _length = length, _encoding = encoding;
            // Support both (string, offset, length, encoding)
            // and the legacy (string, encoding, offset, length)
            if (isFinite(offset)) {
                if (!isFinite(length)) {
                    encoding = length;
                    length = undefined;
                }
            } else {  // legacy
                var swap = encoding;
                encoding = offset;
                offset = length;
                length = swap;
            }

            encoding = String(encoding || 'utf8').toLowerCase();

            // Use native conversion when possible
            if (Buffer.isNativeEncoding(encoding))
                return original.BufferWrite.call(this, string, _offset, _length, _encoding);

            offset = +offset || 0;
            var remaining = this.length - offset;
            if (!length) {
                length = remaining;
            } else {
                length = +length;
                if (length > remaining) {
                    length = remaining;
                }
            }

            if (string.length > 0 && (length < 0 || offset < 0))
                throw new RangeError('attempt to write beyond buffer bounds');

            // Otherwise, use our encoding method.
            var buf = iconv.encode(string, encoding);
            if (buf.length < length) length = buf.length;
            buf.copy(this, offset, 0, length);
            return length;

            // TODO: Set _charsWritten.
        }


        // -- Readable -------------------------------------------------------------
        if (iconv.supportsStreams) {
            var Readable = (__nccwpck_require__(2203).Readable);

            original.ReadableSetEncoding = Readable.prototype.setEncoding;
            Readable.prototype.setEncoding = function setEncoding(enc, options) {
                // Use our own decoder, it has the same interface.
                // We cannot use original function as it doesn't handle BOM-s.
                this._readableState.decoder = iconv.getDecoder(enc, options);
                this._readableState.encoding = enc;
            }

            Readable.prototype.collect = iconv._collect;
        }
    }

    // Remove iconv-lite Node primitive extensions.
    iconv.undoExtendNodeEncodings = function undoExtendNodeEncodings() {
        if (!iconv.supportsNodeEncodingsExtension)
            return;
        if (!original)
            throw new Error("require('iconv-lite').undoExtendNodeEncodings(): Nothing to undo; extendNodeEncodings() is not called.")

        delete Buffer.isNativeEncoding;

        var SlowBuffer = (__nccwpck_require__(20181).SlowBuffer);

        SlowBuffer.prototype.toString = original.SlowBufferToString;
        SlowBuffer.prototype.write = original.SlowBufferWrite;

        Buffer.isEncoding = original.BufferIsEncoding;
        Buffer.byteLength = original.BufferByteLength;
        Buffer.prototype.toString = original.BufferToString;
        Buffer.prototype.write = original.BufferWrite;

        if (iconv.supportsStreams) {
            var Readable = (__nccwpck_require__(2203).Readable);

            Readable.prototype.setEncoding = original.ReadableSetEncoding;
            delete Readable.prototype.collect;
        }

        original = undefined;
    }
}


/***/ }),

/***/ 65428:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


// Some environments don't have global Buffer (e.g. React Native).
// Solution would be installing npm modules "buffer" and "stream" explicitly.
var Buffer = (__nccwpck_require__(12803).Buffer);

var bomHandling = __nccwpck_require__(20250),
    iconv = module.exports;

// All codecs and aliases are kept here, keyed by encoding name/alias.
// They are lazy loaded in `iconv.getCodec` from `encodings/index.js`.
iconv.encodings = null;

// Characters emitted in case of error.
iconv.defaultCharUnicode = 'ÔøΩ';
iconv.defaultCharSingleByte = '?';

// Public API.
iconv.encode = function encode(str, encoding, options) {
    str = "" + (str || ""); // Ensure string.

    var encoder = iconv.getEncoder(encoding, options);

    var res = encoder.write(str);
    var trail = encoder.end();
    
    return (trail && trail.length > 0) ? Buffer.concat([res, trail]) : res;
}

iconv.decode = function decode(buf, encoding, options) {
    if (typeof buf === 'string') {
        if (!iconv.skipDecodeWarning) {
            console.error('Iconv-lite warning: decode()-ing strings is deprecated. Refer to https://github.com/ashtuchkin/iconv-lite/wiki/Use-Buffers-when-decoding');
            iconv.skipDecodeWarning = true;
        }

        buf = Buffer.from("" + (buf || ""), "binary"); // Ensure buffer.
    }

    var decoder = iconv.getDecoder(encoding, options);

    var res = decoder.write(buf);
    var trail = decoder.end();

    return trail ? (res + trail) : res;
}

iconv.encodingExists = function encodingExists(enc) {
    try {
        iconv.getCodec(enc);
        return true;
    } catch (e) {
        return false;
    }
}

// Legacy aliases to convert functions
iconv.toEncoding = iconv.encode;
iconv.fromEncoding = iconv.decode;

// Search for a codec in iconv.encodings. Cache codec data in iconv._codecDataCache.
iconv._codecDataCache = {};
iconv.getCodec = function getCodec(encoding) {
    if (!iconv.encodings)
        iconv.encodings = __nccwpck_require__(54225); // Lazy load all encoding definitions.
    
    // Canonicalize encoding name: strip all non-alphanumeric chars and appended year.
    var enc = iconv._canonicalizeEncoding(encoding);

    // Traverse iconv.encodings to find actual codec.
    var codecOptions = {};
    while (true) {
        var codec = iconv._codecDataCache[enc];
        if (codec)
            return codec;

        var codecDef = iconv.encodings[enc];

        switch (typeof codecDef) {
            case "string": // Direct alias to other encoding.
                enc = codecDef;
                break;

            case "object": // Alias with options. Can be layered.
                for (var key in codecDef)
                    codecOptions[key] = codecDef[key];

                if (!codecOptions.encodingName)
                    codecOptions.encodingName = enc;
                
                enc = codecDef.type;
                break;

            case "function": // Codec itself.
                if (!codecOptions.encodingName)
                    codecOptions.encodingName = enc;

                // The codec function must load all tables and return object with .encoder and .decoder methods.
                // It'll be called only once (for each different options object).
                codec = new codecDef(codecOptions, iconv);

                iconv._codecDataCache[codecOptions.encodingName] = codec; // Save it to be reused later.
                return codec;

            default:
                throw new Error("Encoding not recognized: '" + encoding + "' (searched as: '"+enc+"')");
        }
    }
}

iconv._canonicalizeEncoding = function(encoding) {
    // Canonicalize encoding name: strip all non-alphanumeric chars and appended year.
    return (''+encoding).toLowerCase().replace(/:\d{4}$|[^0-9a-z]/g, "");
}

iconv.getEncoder = function getEncoder(encoding, options) {
    var codec = iconv.getCodec(encoding),
        encoder = new codec.encoder(options, codec);

    if (codec.bomAware && options && options.addBOM)
        encoder = new bomHandling.PrependBOM(encoder, options);

    return encoder;
}

iconv.getDecoder = function getDecoder(encoding, options) {
    var codec = iconv.getCodec(encoding),
        decoder = new codec.decoder(options, codec);

    if (codec.bomAware && !(options && options.stripBOM === false))
        decoder = new bomHandling.StripBOM(decoder, options);

    return decoder;
}


// Load extensions in Node. All of them are omitted in Browserify build via 'browser' field in package.json.
var nodeVer = typeof process !== 'undefined' && process.versions && process.versions.node;
if (nodeVer) {

    // Load streaming support in Node v0.10+
    var nodeVerArr = nodeVer.split(".").map(Number);
    if (nodeVerArr[0] > 0 || nodeVerArr[1] >= 10) {
        __nccwpck_require__(40857)(iconv);
    }

    // Load Node primitive extensions.
    __nccwpck_require__(89547)(iconv);
}

if (false) {}


/***/ }),

/***/ 40857:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


var Buffer = (__nccwpck_require__(20181).Buffer),
    Transform = (__nccwpck_require__(2203).Transform);


// == Exports ==================================================================
module.exports = function(iconv) {
    
    // Additional Public API.
    iconv.encodeStream = function encodeStream(encoding, options) {
        return new IconvLiteEncoderStream(iconv.getEncoder(encoding, options), options);
    }

    iconv.decodeStream = function decodeStream(encoding, options) {
        return new IconvLiteDecoderStream(iconv.getDecoder(encoding, options), options);
    }

    iconv.supportsStreams = true;


    // Not published yet.
    iconv.IconvLiteEncoderStream = IconvLiteEncoderStream;
    iconv.IconvLiteDecoderStream = IconvLiteDecoderStream;
    iconv._collect = IconvLiteDecoderStream.prototype.collect;
};


// == Encoder stream =======================================================
function IconvLiteEncoderStream(conv, options) {
    this.conv = conv;
    options = options || {};
    options.decodeStrings = false; // We accept only strings, so we don't need to decode them.
    Transform.call(this, options);
}

IconvLiteEncoderStream.prototype = Object.create(Transform.prototype, {
    constructor: { value: IconvLiteEncoderStream }
});

IconvLiteEncoderStream.prototype._transform = function(chunk, encoding, done) {
    if (typeof chunk != 'string')
        return done(new Error("Iconv encoding stream needs strings as its input."));
    try {
        var res = this.conv.write(chunk);
        if (res && res.length) this.push(res);
        done();
    }
    catch (e) {
        done(e);
    }
}

IconvLiteEncoderStream.prototype._flush = function(done) {
    try {
        var res = this.conv.end();
        if (res && res.length) this.push(res);
        done();
    }
    catch (e) {
        done(e);
    }
}

IconvLiteEncoderStream.prototype.collect = function(cb) {
    var chunks = [];
    this.on('error', cb);
    this.on('data', function(chunk) { chunks.push(chunk); });
    this.on('end', function() {
        cb(null, Buffer.concat(chunks));
    });
    return this;
}


// == Decoder stream =======================================================
function IconvLiteDecoderStream(conv, options) {
    this.conv = conv;
    options = options || {};
    options.encoding = this.encoding = 'utf8'; // We output strings.
    Transform.call(this, options);
}

IconvLiteDecoderStream.prototype = Object.create(Transform.prototype, {
    constructor: { value: IconvLiteDecoderStream }
});

IconvLiteDecoderStream.prototype._transform = function(chunk, encoding, done) {
    if (!Buffer.isBuffer(chunk))
        return done(new Error("Iconv decoding stream needs buffers as its input."));
    try {
        var res = this.conv.write(chunk);
        if (res && res.length) this.push(res, this.encoding);
        done();
    }
    catch (e) {
        done(e);
    }
}

IconvLiteDecoderStream.prototype._flush = function(done) {
    try {
        var res = this.conv.end();
        if (res && res.length) this.push(res, this.encoding);                
        done();
    }
    catch (e) {
        done(e);
    }
}

IconvLiteDecoderStream.prototype.collect = function(cb) {
    var res = '';
    this.on('error', cb);
    this.on('data', function(chunk) { res += chunk; });
    this.on('end', function() {
        cb(null, res);
    });
    return this;
}



/***/ }),

/***/ 2888:
/***/ ((module) => {

/**
 * Helpers.
 */

var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var y = d * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */

module.exports = function(val, options) {
  options = options || {};
  var type = typeof val;
  if (type === 'string' && val.length > 0) {
    return parse(val);
  } else if (type === 'number' && isNaN(val) === false) {
    return options.long ? fmtLong(val) : fmtShort(val);
  }
  throw new Error(
    'val is not a non-empty string or a valid number. val=' +
      JSON.stringify(val)
  );
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  str = String(str);
  if (str.length > 100) {
    return;
  }
  var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(
    str
  );
  if (!match) {
    return;
  }
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;
    case 'days':
    case 'day':
    case 'd':
      return n * d;
    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h;
    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m;
    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s;
    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;
    default:
      return undefined;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtShort(ms) {
  if (ms >= d) {
    return Math.round(ms / d) + 'd';
  }
  if (ms >= h) {
    return Math.round(ms / h) + 'h';
  }
  if (ms >= m) {
    return Math.round(ms / m) + 'm';
  }
  if (ms >= s) {
    return Math.round(ms / s) + 's';
  }
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtLong(ms) {
  return plural(ms, d, 'day') ||
    plural(ms, h, 'hour') ||
    plural(ms, m, 'minute') ||
    plural(ms, s, 'second') ||
    ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural(ms, n, name) {
  if (ms < n) {
    return;
  }
  if (ms < n * 1.5) {
    return Math.floor(ms / n) + ' ' + name;
  }
  return Math.ceil(ms / n) + ' ' + name + 's';
}


/***/ }),

/***/ 52337:
/***/ ((module) => {

/* eslint-disable node/no-deprecated-api */

var toString = Object.prototype.toString

var isModern = (
  typeof Buffer !== 'undefined' &&
  typeof Buffer.alloc === 'function' &&
  typeof Buffer.allocUnsafe === 'function' &&
  typeof Buffer.from === 'function'
)

function isArrayBuffer (input) {
  return toString.call(input).slice(8, -1) === 'ArrayBuffer'
}

function fromArrayBuffer (obj, byteOffset, length) {
  byteOffset >>>= 0

  var maxLength = obj.byteLength - byteOffset

  if (maxLength < 0) {
    throw new RangeError("'offset' is out of bounds")
  }

  if (length === undefined) {
    length = maxLength
  } else {
    length >>>= 0

    if (length > maxLength) {
      throw new RangeError("'length' is out of bounds")
    }
  }

  return isModern
    ? Buffer.from(obj.slice(byteOffset, byteOffset + length))
    : new Buffer(new Uint8Array(obj.slice(byteOffset, byteOffset + length)))
}

function fromString (string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding')
  }

  return isModern
    ? Buffer.from(string, encoding)
    : new Buffer(string, encoding)
}

function bufferFrom (value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number')
  }

  if (isArrayBuffer(value)) {
    return fromArrayBuffer(value, encodingOrOffset, length)
  }

  if (typeof value === 'string') {
    return fromString(value, encodingOrOffset)
  }

  return isModern
    ? Buffer.from(value)
    : new Buffer(value)
}

module.exports = bufferFrom


/***/ }),

/***/ 680:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


const { parseContentType } = __nccwpck_require__(15313);

function getInstance(cfg) {
  const headers = cfg.headers;
  const conType = parseContentType(headers['content-type']);
  if (!conType)
    throw new Error('Malformed content type');

  for (const type of TYPES) {
    const matched = type.detect(conType);
    if (!matched)
      continue;

    const instanceCfg = {
      limits: cfg.limits,
      headers,
      conType,
      highWaterMark: undefined,
      fileHwm: undefined,
      defCharset: undefined,
      defParamCharset: undefined,
      preservePath: false,
    };
    if (cfg.highWaterMark)
      instanceCfg.highWaterMark = cfg.highWaterMark;
    if (cfg.fileHwm)
      instanceCfg.fileHwm = cfg.fileHwm;
    instanceCfg.defCharset = cfg.defCharset;
    instanceCfg.defParamCharset = cfg.defParamCharset;
    instanceCfg.preservePath = cfg.preservePath;
    return new type(instanceCfg);
  }

  throw new Error(`Unsupported content type: ${headers['content-type']}`);
}

// Note: types are explicitly listed here for easier bundling
// See: https://github.com/mscdex/busboy/issues/121
const TYPES = [
  __nccwpck_require__(80894),
  __nccwpck_require__(86261),
].filter(function(typemod) { return typeof typemod.detect === 'function'; });

module.exports = (cfg) => {
  if (typeof cfg !== 'object' || cfg === null)
    cfg = {};

  if (typeof cfg.headers !== 'object'
      || cfg.headers === null
      || typeof cfg.headers['content-type'] !== 'string') {
    throw new Error('Missing Content-Type');
  }

  return getInstance(cfg);
};


/***/ }),

/***/ 80894:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


const { Readable, Writable } = __nccwpck_require__(2203);

const StreamSearch = __nccwpck_require__(59026);

const {
  basename,
  convertToUTF8,
  getDecoder,
  parseContentType,
  parseDisposition,
} = __nccwpck_require__(15313);

const BUF_CRLF = Buffer.from('\r\n');
const BUF_CR = Buffer.from('\r');
const BUF_DASH = Buffer.from('-');

function noop() {}

const MAX_HEADER_PAIRS = 2000; // From node
const MAX_HEADER_SIZE = 16 * 1024; // From node (its default value)

const HPARSER_NAME = 0;
const HPARSER_PRE_OWS = 1;
const HPARSER_VALUE = 2;
class HeaderParser {
  constructor(cb) {
    this.header = Object.create(null);
    this.pairCount = 0;
    this.byteCount = 0;
    this.state = HPARSER_NAME;
    this.name = '';
    this.value = '';
    this.crlf = 0;
    this.cb = cb;
  }

  reset() {
    this.header = Object.create(null);
    this.pairCount = 0;
    this.byteCount = 0;
    this.state = HPARSER_NAME;
    this.name = '';
    this.value = '';
    this.crlf = 0;
  }

  push(chunk, pos, end) {
    let start = pos;
    while (pos < end) {
      switch (this.state) {
        case HPARSER_NAME: {
          let done = false;
          for (; pos < end; ++pos) {
            if (this.byteCount === MAX_HEADER_SIZE)
              return -1;
            ++this.byteCount;
            const code = chunk[pos];
            if (TOKEN[code] !== 1) {
              if (code !== 58/* ':' */)
                return -1;
              this.name += chunk.latin1Slice(start, pos);
              if (this.name.length === 0)
                return -1;
              ++pos;
              done = true;
              this.state = HPARSER_PRE_OWS;
              break;
            }
          }
          if (!done) {
            this.name += chunk.latin1Slice(start, pos);
            break;
          }
          // FALLTHROUGH
        }
        case HPARSER_PRE_OWS: {
          // Skip optional whitespace
          let done = false;
          for (; pos < end; ++pos) {
            if (this.byteCount === MAX_HEADER_SIZE)
              return -1;
            ++this.byteCount;
            const code = chunk[pos];
            if (code !== 32/* ' ' */ && code !== 9/* '\t' */) {
              start = pos;
              done = true;
              this.state = HPARSER_VALUE;
              break;
            }
          }
          if (!done)
            break;
          // FALLTHROUGH
        }
        case HPARSER_VALUE:
          switch (this.crlf) {
            case 0: // Nothing yet
              for (; pos < end; ++pos) {
                if (this.byteCount === MAX_HEADER_SIZE)
                  return -1;
                ++this.byteCount;
                const code = chunk[pos];
                if (FIELD_VCHAR[code] !== 1) {
                  if (code !== 13/* '\r' */)
                    return -1;
                  ++this.crlf;
                  break;
                }
              }
              this.value += chunk.latin1Slice(start, pos++);
              break;
            case 1: // Received CR
              if (this.byteCount === MAX_HEADER_SIZE)
                return -1;
              ++this.byteCount;
              if (chunk[pos++] !== 10/* '\n' */)
                return -1;
              ++this.crlf;
              break;
            case 2: { // Received CR LF
              if (this.byteCount === MAX_HEADER_SIZE)
                return -1;
              ++this.byteCount;
              const code = chunk[pos];
              if (code === 32/* ' ' */ || code === 9/* '\t' */) {
                // Folded value
                start = pos;
                this.crlf = 0;
              } else {
                if (++this.pairCount < MAX_HEADER_PAIRS) {
                  this.name = this.name.toLowerCase();
                  if (this.header[this.name] === undefined)
                    this.header[this.name] = [this.value];
                  else
                    this.header[this.name].push(this.value);
                }
                if (code === 13/* '\r' */) {
                  ++this.crlf;
                  ++pos;
                } else {
                  // Assume start of next header field name
                  start = pos;
                  this.crlf = 0;
                  this.state = HPARSER_NAME;
                  this.name = '';
                  this.value = '';
                }
              }
              break;
            }
            case 3: { // Received CR LF CR
              if (this.byteCount === MAX_HEADER_SIZE)
                return -1;
              ++this.byteCount;
              if (chunk[pos++] !== 10/* '\n' */)
                return -1;
              // End of header
              const header = this.header;
              this.reset();
              this.cb(header);
              return pos;
            }
          }
          break;
      }
    }

    return pos;
  }
}

class FileStream extends Readable {
  constructor(opts, owner) {
    super(opts);
    this.truncated = false;
    this._readcb = null;
    this.once('end', () => {
      // We need to make sure that we call any outstanding _writecb() that is
      // associated with this file so that processing of the rest of the form
      // can continue. This may not happen if the file stream ends right after
      // backpressure kicks in, so we force it here.
      this._read();
      if (--owner._fileEndsLeft === 0 && owner._finalcb) {
        const cb = owner._finalcb;
        owner._finalcb = null;
        // Make sure other 'end' event handlers get a chance to be executed
        // before busboy's 'finish' event is emitted
        process.nextTick(cb);
      }
    });
  }
  _read(n) {
    const cb = this._readcb;
    if (cb) {
      this._readcb = null;
      cb();
    }
  }
}

const ignoreData = {
  push: (chunk, pos) => {},
  destroy: () => {},
};

function callAndUnsetCb(self, err) {
  const cb = self._writecb;
  self._writecb = null;
  if (err)
    self.destroy(err);
  else if (cb)
    cb();
}

function nullDecoder(val, hint) {
  return val;
}

class Multipart extends Writable {
  constructor(cfg) {
    const streamOpts = {
      autoDestroy: true,
      emitClose: true,
      highWaterMark: (typeof cfg.highWaterMark === 'number'
                      ? cfg.highWaterMark
                      : undefined),
    };
    super(streamOpts);

    if (!cfg.conType.params || typeof cfg.conType.params.boundary !== 'string')
      throw new Error('Multipart: Boundary not found');

    const boundary = cfg.conType.params.boundary;
    const paramDecoder = (typeof cfg.defParamCharset === 'string'
                            && cfg.defParamCharset
                          ? getDecoder(cfg.defParamCharset)
                          : nullDecoder);
    const defCharset = (cfg.defCharset || 'utf8');
    const preservePath = cfg.preservePath;
    const fileOpts = {
      autoDestroy: true,
      emitClose: true,
      highWaterMark: (typeof cfg.fileHwm === 'number'
                      ? cfg.fileHwm
                      : undefined),
    };

    const limits = cfg.limits;
    const fieldSizeLimit = (limits && typeof limits.fieldSize === 'number'
                            ? limits.fieldSize
                            : 1 * 1024 * 1024);
    const fileSizeLimit = (limits && typeof limits.fileSize === 'number'
                           ? limits.fileSize
                           : Infinity);
    const filesLimit = (limits && typeof limits.files === 'number'
                        ? limits.files
                        : Infinity);
    const fieldsLimit = (limits && typeof limits.fields === 'number'
                         ? limits.fields
                         : Infinity);
    const partsLimit = (limits && typeof limits.parts === 'number'
                        ? limits.parts
                        : Infinity);

    let parts = -1; // Account for initial boundary
    let fields = 0;
    let files = 0;
    let skipPart = false;

    this._fileEndsLeft = 0;
    this._fileStream = undefined;
    this._complete = false;
    let fileSize = 0;

    let field;
    let fieldSize = 0;
    let partCharset;
    let partEncoding;
    let partType;
    let partName;
    let partTruncated = false;

    let hitFilesLimit = false;
    let hitFieldsLimit = false;

    this._hparser = null;
    const hparser = new HeaderParser((header) => {
      this._hparser = null;
      skipPart = false;

      partType = 'text/plain';
      partCharset = defCharset;
      partEncoding = '7bit';
      partName = undefined;
      partTruncated = false;

      let filename;
      if (!header['content-disposition']) {
        skipPart = true;
        return;
      }

      const disp = parseDisposition(header['content-disposition'][0],
                                    paramDecoder);
      if (!disp || disp.type !== 'form-data') {
        skipPart = true;
        return;
      }

      if (disp.params) {
        if (disp.params.name)
          partName = disp.params.name;

        if (disp.params['filename*'])
          filename = disp.params['filename*'];
        else if (disp.params.filename)
          filename = disp.params.filename;

        if (filename !== undefined && !preservePath)
          filename = basename(filename);
      }

      if (header['content-type']) {
        const conType = parseContentType(header['content-type'][0]);
        if (conType) {
          partType = `${conType.type}/${conType.subtype}`;
          if (conType.params && typeof conType.params.charset === 'string')
            partCharset = conType.params.charset.toLowerCase();
        }
      }

      if (header['content-transfer-encoding'])
        partEncoding = header['content-transfer-encoding'][0].toLowerCase();

      if (partType === 'application/octet-stream' || filename !== undefined) {
        // File

        if (files === filesLimit) {
          if (!hitFilesLimit) {
            hitFilesLimit = true;
            this.emit('filesLimit');
          }
          skipPart = true;
          return;
        }
        ++files;

        if (this.listenerCount('file') === 0) {
          skipPart = true;
          return;
        }

        fileSize = 0;
        this._fileStream = new FileStream(fileOpts, this);
        ++this._fileEndsLeft;
        this.emit(
          'file',
          partName,
          this._fileStream,
          { filename,
            encoding: partEncoding,
            mimeType: partType }
        );
      } else {
        // Non-file

        if (fields === fieldsLimit) {
          if (!hitFieldsLimit) {
            hitFieldsLimit = true;
            this.emit('fieldsLimit');
          }
          skipPart = true;
          return;
        }
        ++fields;

        if (this.listenerCount('field') === 0) {
          skipPart = true;
          return;
        }

        field = [];
        fieldSize = 0;
      }
    });

    let matchPostBoundary = 0;
    const ssCb = (isMatch, data, start, end, isDataSafe) => {
retrydata:
      while (data) {
        if (this._hparser !== null) {
          const ret = this._hparser.push(data, start, end);
          if (ret === -1) {
            this._hparser = null;
            hparser.reset();
            this.emit('error', new Error('Malformed part header'));
            break;
          }
          start = ret;
        }

        if (start === end)
          break;

        if (matchPostBoundary !== 0) {
          if (matchPostBoundary === 1) {
            switch (data[start]) {
              case 45: // '-'
                // Try matching '--' after boundary
                matchPostBoundary = 2;
                ++start;
                break;
              case 13: // '\r'
                // Try matching CR LF before header
                matchPostBoundary = 3;
                ++start;
                break;
              default:
                matchPostBoundary = 0;
            }
            if (start === end)
              return;
          }

          if (matchPostBoundary === 2) {
            matchPostBoundary = 0;
            if (data[start] === 45/* '-' */) {
              // End of multipart data
              this._complete = true;
              this._bparser = ignoreData;
              return;
            }
            // We saw something other than '-', so put the dash we consumed
            // "back"
            const writecb = this._writecb;
            this._writecb = noop;
            ssCb(false, BUF_DASH, 0, 1, false);
            this._writecb = writecb;
          } else if (matchPostBoundary === 3) {
            matchPostBoundary = 0;
            if (data[start] === 10/* '\n' */) {
              ++start;
              if (parts >= partsLimit)
                break;
              // Prepare the header parser
              this._hparser = hparser;
              if (start === end)
                break;
              // Process the remaining data as a header
              continue retrydata;
            } else {
              // We saw something other than LF, so put the CR we consumed
              // "back"
              const writecb = this._writecb;
              this._writecb = noop;
              ssCb(false, BUF_CR, 0, 1, false);
              this._writecb = writecb;
            }
          }
        }

        if (!skipPart) {
          if (this._fileStream) {
            let chunk;
            const actualLen = Math.min(end - start, fileSizeLimit - fileSize);
            if (!isDataSafe) {
              chunk = Buffer.allocUnsafe(actualLen);
              data.copy(chunk, 0, start, start + actualLen);
            } else {
              chunk = data.slice(start, start + actualLen);
            }

            fileSize += chunk.length;
            if (fileSize === fileSizeLimit) {
              if (chunk.length > 0)
                this._fileStream.push(chunk);
              this._fileStream.emit('limit');
              this._fileStream.truncated = true;
              skipPart = true;
            } else if (!this._fileStream.push(chunk)) {
              if (this._writecb)
                this._fileStream._readcb = this._writecb;
              this._writecb = null;
            }
          } else if (field !== undefined) {
            let chunk;
            const actualLen = Math.min(
              end - start,
              fieldSizeLimit - fieldSize
            );
            if (!isDataSafe) {
              chunk = Buffer.allocUnsafe(actualLen);
              data.copy(chunk, 0, start, start + actualLen);
            } else {
              chunk = data.slice(start, start + actualLen);
            }

            fieldSize += actualLen;
            field.push(chunk);
            if (fieldSize === fieldSizeLimit) {
              skipPart = true;
              partTruncated = true;
            }
          }
        }

        break;
      }

      if (isMatch) {
        matchPostBoundary = 1;

        if (this._fileStream) {
          // End the active file stream if the previous part was a file
          this._fileStream.push(null);
          this._fileStream = null;
        } else if (field !== undefined) {
          let data;
          switch (field.length) {
            case 0:
              data = '';
              break;
            case 1:
              data = convertToUTF8(field[0], partCharset, 0);
              break;
            default:
              data = convertToUTF8(
                Buffer.concat(field, fieldSize),
                partCharset,
                0
              );
          }
          field = undefined;
          fieldSize = 0;
          this.emit(
            'field',
            partName,
            data,
            { nameTruncated: false,
              valueTruncated: partTruncated,
              encoding: partEncoding,
              mimeType: partType }
          );
        }

        if (++parts === partsLimit)
          this.emit('partsLimit');
      }
    };
    this._bparser = new StreamSearch(`\r\n--${boundary}`, ssCb);

    this._writecb = null;
    this._finalcb = null;

    // Just in case there is no preamble
    this.write(BUF_CRLF);
  }

  static detect(conType) {
    return (conType.type === 'multipart' && conType.subtype === 'form-data');
  }

  _write(chunk, enc, cb) {
    this._writecb = cb;
    this._bparser.push(chunk, 0);
    if (this._writecb)
      callAndUnsetCb(this);
  }

  _destroy(err, cb) {
    this._hparser = null;
    this._bparser = ignoreData;
    if (!err)
      err = checkEndState(this);
    const fileStream = this._fileStream;
    if (fileStream) {
      this._fileStream = null;
      fileStream.destroy(err);
    }
    cb(err);
  }

  _final(cb) {
    this._bparser.destroy();
    if (!this._complete)
      return cb(new Error('Unexpected end of form'));
    if (this._fileEndsLeft)
      this._finalcb = finalcb.bind(null, this, cb);
    else
      finalcb(this, cb);
  }
}

function finalcb(self, cb, err) {
  if (err)
    return cb(err);
  err = checkEndState(self);
  cb(err);
}

function checkEndState(self) {
  if (self._hparser)
    return new Error('Malformed part header');
  const fileStream = self._fileStream;
  if (fileStream) {
    self._fileStream = null;
    fileStream.destroy(new Error('Unexpected end of file'));
  }
  if (!self._complete)
    return new Error('Unexpected end of form');
}

const TOKEN = [
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
];

const FIELD_VCHAR = [
  0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
];

module.exports = Multipart;


/***/ }),

/***/ 86261:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


const { Writable } = __nccwpck_require__(2203);

const { getDecoder } = __nccwpck_require__(15313);

class URLEncoded extends Writable {
  constructor(cfg) {
    const streamOpts = {
      autoDestroy: true,
      emitClose: true,
      highWaterMark: (typeof cfg.highWaterMark === 'number'
                      ? cfg.highWaterMark
                      : undefined),
    };
    super(streamOpts);

    let charset = (cfg.defCharset || 'utf8');
    if (cfg.conType.params && typeof cfg.conType.params.charset === 'string')
      charset = cfg.conType.params.charset;

    this.charset = charset;

    const limits = cfg.limits;
    this.fieldSizeLimit = (limits && typeof limits.fieldSize === 'number'
                           ? limits.fieldSize
                           : 1 * 1024 * 1024);
    this.fieldsLimit = (limits && typeof limits.fields === 'number'
                        ? limits.fields
                        : Infinity);
    this.fieldNameSizeLimit = (
      limits && typeof limits.fieldNameSize === 'number'
      ? limits.fieldNameSize
      : 100
    );

    this._inKey = true;
    this._keyTrunc = false;
    this._valTrunc = false;
    this._bytesKey = 0;
    this._bytesVal = 0;
    this._fields = 0;
    this._key = '';
    this._val = '';
    this._byte = -2;
    this._lastPos = 0;
    this._encode = 0;
    this._decoder = getDecoder(charset);
  }

  static detect(conType) {
    return (conType.type === 'application'
            && conType.subtype === 'x-www-form-urlencoded');
  }

  _write(chunk, enc, cb) {
    if (this._fields >= this.fieldsLimit)
      return cb();

    let i = 0;
    const len = chunk.length;
    this._lastPos = 0;

    // Check if we last ended mid-percent-encoded byte
    if (this._byte !== -2) {
      i = readPctEnc(this, chunk, i, len);
      if (i === -1)
        return cb(new Error('Malformed urlencoded form'));
      if (i >= len)
        return cb();
      if (this._inKey)
        ++this._bytesKey;
      else
        ++this._bytesVal;
    }

main:
    while (i < len) {
      if (this._inKey) {
        // Parsing key

        i = skipKeyBytes(this, chunk, i, len);

        while (i < len) {
          switch (chunk[i]) {
            case 61: // '='
              if (this._lastPos < i)
                this._key += chunk.latin1Slice(this._lastPos, i);
              this._lastPos = ++i;
              this._key = this._decoder(this._key, this._encode);
              this._encode = 0;
              this._inKey = false;
              continue main;
            case 38: // '&'
              if (this._lastPos < i)
                this._key += chunk.latin1Slice(this._lastPos, i);
              this._lastPos = ++i;
              this._key = this._decoder(this._key, this._encode);
              this._encode = 0;
              if (this._bytesKey > 0) {
                this.emit(
                  'field',
                  this._key,
                  '',
                  { nameTruncated: this._keyTrunc,
                    valueTruncated: false,
                    encoding: this.charset,
                    mimeType: 'text/plain' }
                );
              }
              this._key = '';
              this._val = '';
              this._keyTrunc = false;
              this._valTrunc = false;
              this._bytesKey = 0;
              this._bytesVal = 0;
              if (++this._fields >= this.fieldsLimit) {
                this.emit('fieldsLimit');
                return cb();
              }
              continue;
            case 43: // '+'
              if (this._lastPos < i)
                this._key += chunk.latin1Slice(this._lastPos, i);
              this._key += ' ';
              this._lastPos = i + 1;
              break;
            case 37: // '%'
              if (this._encode === 0)
                this._encode = 1;
              if (this._lastPos < i)
                this._key += chunk.latin1Slice(this._lastPos, i);
              this._lastPos = i + 1;
              this._byte = -1;
              i = readPctEnc(this, chunk, i + 1, len);
              if (i === -1)
                return cb(new Error('Malformed urlencoded form'));
              if (i >= len)
                return cb();
              ++this._bytesKey;
              i = skipKeyBytes(this, chunk, i, len);
              continue;
          }
          ++i;
          ++this._bytesKey;
          i = skipKeyBytes(this, chunk, i, len);
        }
        if (this._lastPos < i)
          this._key += chunk.latin1Slice(this._lastPos, i);
      } else {
        // Parsing value

        i = skipValBytes(this, chunk, i, len);

        while (i < len) {
          switch (chunk[i]) {
            case 38: // '&'
              if (this._lastPos < i)
                this._val += chunk.latin1Slice(this._lastPos, i);
              this._lastPos = ++i;
              this._inKey = true;
              this._val = this._decoder(this._val, this._encode);
              this._encode = 0;
              if (this._bytesKey > 0 || this._bytesVal > 0) {
                this.emit(
                  'field',
                  this._key,
                  this._val,
                  { nameTruncated: this._keyTrunc,
                    valueTruncated: this._valTrunc,
                    encoding: this.charset,
                    mimeType: 'text/plain' }
                );
              }
              this._key = '';
              this._val = '';
              this._keyTrunc = false;
              this._valTrunc = false;
              this._bytesKey = 0;
              this._bytesVal = 0;
              if (++this._fields >= this.fieldsLimit) {
                this.emit('fieldsLimit');
                return cb();
              }
              continue main;
            case 43: // '+'
              if (this._lastPos < i)
                this._val += chunk.latin1Slice(this._lastPos, i);
              this._val += ' ';
              this._lastPos = i + 1;
              break;
            case 37: // '%'
              if (this._encode === 0)
                this._encode = 1;
              if (this._lastPos < i)
                this._val += chunk.latin1Slice(this._lastPos, i);
              this._lastPos = i + 1;
              this._byte = -1;
              i = readPctEnc(this, chunk, i + 1, len);
              if (i === -1)
                return cb(new Error('Malformed urlencoded form'));
              if (i >= len)
                return cb();
              ++this._bytesVal;
              i = skipValBytes(this, chunk, i, len);
              continue;
          }
          ++i;
          ++this._bytesVal;
          i = skipValBytes(this, chunk, i, len);
        }
        if (this._lastPos < i)
          this._val += chunk.latin1Slice(this._lastPos, i);
      }
    }

    cb();
  }

  _final(cb) {
    if (this._byte !== -2)
      return cb(new Error('Malformed urlencoded form'));
    if (!this._inKey || this._bytesKey > 0 || this._bytesVal > 0) {
      if (this._inKey)
        this._key = this._decoder(this._key, this._encode);
      else
        this._val = this._decoder(this._val, this._encode);
      this.emit(
        'field',
        this._key,
        this._val,
        { nameTruncated: this._keyTrunc,
          valueTruncated: this._valTrunc,
          encoding: this.charset,
          mimeType: 'text/plain' }
      );
    }
    cb();
  }
}

function readPctEnc(self, chunk, pos, len) {
  if (pos >= len)
    return len;

  if (self._byte === -1) {
    // We saw a '%' but no hex characters yet
    const hexUpper = HEX_VALUES[chunk[pos++]];
    if (hexUpper === -1)
      return -1;

    if (hexUpper >= 8)
      self._encode = 2; // Indicate high bits detected

    if (pos < len) {
      // Both hex characters are in this chunk
      const hexLower = HEX_VALUES[chunk[pos++]];
      if (hexLower === -1)
        return -1;

      if (self._inKey)
        self._key += String.fromCharCode((hexUpper << 4) + hexLower);
      else
        self._val += String.fromCharCode((hexUpper << 4) + hexLower);

      self._byte = -2;
      self._lastPos = pos;
    } else {
      // Only one hex character was available in this chunk
      self._byte = hexUpper;
    }
  } else {
    // We saw only one hex character so far
    const hexLower = HEX_VALUES[chunk[pos++]];
    if (hexLower === -1)
      return -1;

    if (self._inKey)
      self._key += String.fromCharCode((self._byte << 4) + hexLower);
    else
      self._val += String.fromCharCode((self._byte << 4) + hexLower);

    self._byte = -2;
    self._lastPos = pos;
  }

  return pos;
}

function skipKeyBytes(self, chunk, pos, len) {
  // Skip bytes if we've truncated
  if (self._bytesKey > self.fieldNameSizeLimit) {
    if (!self._keyTrunc) {
      if (self._lastPos < pos)
        self._key += chunk.latin1Slice(self._lastPos, pos - 1);
    }
    self._keyTrunc = true;
    for (; pos < len; ++pos) {
      const code = chunk[pos];
      if (code === 61/* '=' */ || code === 38/* '&' */)
        break;
      ++self._bytesKey;
    }
    self._lastPos = pos;
  }

  return pos;
}

function skipValBytes(self, chunk, pos, len) {
  // Skip bytes if we've truncated
  if (self._bytesVal > self.fieldSizeLimit) {
    if (!self._valTrunc) {
      if (self._lastPos < pos)
        self._val += chunk.latin1Slice(self._lastPos, pos - 1);
    }
    self._valTrunc = true;
    for (; pos < len; ++pos) {
      if (chunk[pos] === 38/* '&' */)
        break;
      ++self._bytesVal;
    }
    self._lastPos = pos;
  }

  return pos;
}

/* eslint-disable no-multi-spaces */
const HEX_VALUES = [
  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
   0,  1,  2,  3,  4,  5,  6,  7,  8,  9, -1, -1, -1, -1, -1, -1,
  -1, 10, 11, 12, 13, 14, 15, -1, -1, -1, -1, -1, -1, -1, -1, -1,
  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
  -1, 10, 11, 12, 13, 14, 15, -1, -1, -1, -1, -1, -1, -1, -1, -1,
  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
];
/* eslint-enable no-multi-spaces */

module.exports = URLEncoded;


/***/ }),

/***/ 15313:
/***/ (function(module) {

"use strict";


function parseContentType(str) {
  if (str.length === 0)
    return;

  const params = Object.create(null);
  let i = 0;

  // Parse type
  for (; i < str.length; ++i) {
    const code = str.charCodeAt(i);
    if (TOKEN[code] !== 1) {
      if (code !== 47/* '/' */ || i === 0)
        return;
      break;
    }
  }
  // Check for type without subtype
  if (i === str.length)
    return;

  const type = str.slice(0, i).toLowerCase();

  // Parse subtype
  const subtypeStart = ++i;
  for (; i < str.length; ++i) {
    const code = str.charCodeAt(i);
    if (TOKEN[code] !== 1) {
      // Make sure we have a subtype
      if (i === subtypeStart)
        return;

      if (parseContentTypeParams(str, i, params) === undefined)
        return;
      break;
    }
  }
  // Make sure we have a subtype
  if (i === subtypeStart)
    return;

  const subtype = str.slice(subtypeStart, i).toLowerCase();

  return { type, subtype, params };
}

function parseContentTypeParams(str, i, params) {
  while (i < str.length) {
    // Consume whitespace
    for (; i < str.length; ++i) {
      const code = str.charCodeAt(i);
      if (code !== 32/* ' ' */ && code !== 9/* '\t' */)
        break;
    }

    // Ended on whitespace
    if (i === str.length)
      break;

    // Check for malformed parameter
    if (str.charCodeAt(i++) !== 59/* ';' */)
      return;

    // Consume whitespace
    for (; i < str.length; ++i) {
      const code = str.charCodeAt(i);
      if (code !== 32/* ' ' */ && code !== 9/* '\t' */)
        break;
    }

    // Ended on whitespace (malformed)
    if (i === str.length)
      return;

    let name;
    const nameStart = i;
    // Parse parameter name
    for (; i < str.length; ++i) {
      const code = str.charCodeAt(i);
      if (TOKEN[code] !== 1) {
        if (code !== 61/* '=' */)
          return;
        break;
      }
    }

    // No value (malformed)
    if (i === str.length)
      return;

    name = str.slice(nameStart, i);
    ++i; // Skip over '='

    // No value (malformed)
    if (i === str.length)
      return;

    let value = '';
    let valueStart;
    if (str.charCodeAt(i) === 34/* '"' */) {
      valueStart = ++i;
      let escaping = false;
      // Parse quoted value
      for (; i < str.length; ++i) {
        const code = str.charCodeAt(i);
        if (code === 92/* '\\' */) {
          if (escaping) {
            valueStart = i;
            escaping = false;
          } else {
            value += str.slice(valueStart, i);
            escaping = true;
          }
          continue;
        }
        if (code === 34/* '"' */) {
          if (escaping) {
            valueStart = i;
            escaping = false;
            continue;
          }
          value += str.slice(valueStart, i);
          break;
        }
        if (escaping) {
          valueStart = i - 1;
          escaping = false;
        }
        // Invalid unescaped quoted character (malformed)
        if (QDTEXT[code] !== 1)
          return;
      }

      // No end quote (malformed)
      if (i === str.length)
        return;

      ++i; // Skip over double quote
    } else {
      valueStart = i;
      // Parse unquoted value
      for (; i < str.length; ++i) {
        const code = str.charCodeAt(i);
        if (TOKEN[code] !== 1) {
          // No value (malformed)
          if (i === valueStart)
            return;
          break;
        }
      }
      value = str.slice(valueStart, i);
    }

    name = name.toLowerCase();
    if (params[name] === undefined)
      params[name] = value;
  }

  return params;
}

function parseDisposition(str, defDecoder) {
  if (str.length === 0)
    return;

  const params = Object.create(null);
  let i = 0;

  for (; i < str.length; ++i) {
    const code = str.charCodeAt(i);
    if (TOKEN[code] !== 1) {
      if (parseDispositionParams(str, i, params, defDecoder) === undefined)
        return;
      break;
    }
  }

  const type = str.slice(0, i).toLowerCase();

  return { type, params };
}

function parseDispositionParams(str, i, params, defDecoder) {
  while (i < str.length) {
    // Consume whitespace
    for (; i < str.length; ++i) {
      const code = str.charCodeAt(i);
      if (code !== 32/* ' ' */ && code !== 9/* '\t' */)
        break;
    }

    // Ended on whitespace
    if (i === str.length)
      break;

    // Check for malformed parameter
    if (str.charCodeAt(i++) !== 59/* ';' */)
      return;

    // Consume whitespace
    for (; i < str.length; ++i) {
      const code = str.charCodeAt(i);
      if (code !== 32/* ' ' */ && code !== 9/* '\t' */)
        break;
    }

    // Ended on whitespace (malformed)
    if (i === str.length)
      return;

    let name;
    const nameStart = i;
    // Parse parameter name
    for (; i < str.length; ++i) {
      const code = str.charCodeAt(i);
      if (TOKEN[code] !== 1) {
        if (code === 61/* '=' */)
          break;
        return;
      }
    }

    // No value (malformed)
    if (i === str.length)
      return;

    let value = '';
    let valueStart;
    let charset;
    //~ let lang;
    name = str.slice(nameStart, i);
    if (name.charCodeAt(name.length - 1) === 42/* '*' */) {
      // Extended value

      const charsetStart = ++i;
      // Parse charset name
      for (; i < str.length; ++i) {
        const code = str.charCodeAt(i);
        if (CHARSET[code] !== 1) {
          if (code !== 39/* '\'' */)
            return;
          break;
        }
      }

      // Incomplete charset (malformed)
      if (i === str.length)
        return;

      charset = str.slice(charsetStart, i);
      ++i; // Skip over the '\''

      //~ const langStart = ++i;
      // Parse language name
      for (; i < str.length; ++i) {
        const code = str.charCodeAt(i);
        if (code === 39/* '\'' */)
          break;
      }

      // Incomplete language (malformed)
      if (i === str.length)
        return;

      //~ lang = str.slice(langStart, i);
      ++i; // Skip over the '\''

      // No value (malformed)
      if (i === str.length)
        return;

      valueStart = i;

      let encode = 0;
      // Parse value
      for (; i < str.length; ++i) {
        const code = str.charCodeAt(i);
        if (EXTENDED_VALUE[code] !== 1) {
          if (code === 37/* '%' */) {
            let hexUpper;
            let hexLower;
            if (i + 2 < str.length
                && (hexUpper = HEX_VALUES[str.charCodeAt(i + 1)]) !== -1
                && (hexLower = HEX_VALUES[str.charCodeAt(i + 2)]) !== -1) {
              const byteVal = (hexUpper << 4) + hexLower;
              value += str.slice(valueStart, i);
              value += String.fromCharCode(byteVal);
              i += 2;
              valueStart = i + 1;
              if (byteVal >= 128)
                encode = 2;
              else if (encode === 0)
                encode = 1;
              continue;
            }
            // '%' disallowed in non-percent encoded contexts (malformed)
            return;
          }
          break;
        }
      }

      value += str.slice(valueStart, i);
      value = convertToUTF8(value, charset, encode);
      if (value === undefined)
        return;
    } else {
      // Non-extended value

      ++i; // Skip over '='

      // No value (malformed)
      if (i === str.length)
        return;

      if (str.charCodeAt(i) === 34/* '"' */) {
        valueStart = ++i;
        let escaping = false;
        // Parse quoted value
        for (; i < str.length; ++i) {
          const code = str.charCodeAt(i);
          if (code === 92/* '\\' */) {
            if (escaping) {
              valueStart = i;
              escaping = false;
            } else {
              value += str.slice(valueStart, i);
              escaping = true;
            }
            continue;
          }
          if (code === 34/* '"' */) {
            if (escaping) {
              valueStart = i;
              escaping = false;
              continue;
            }
            value += str.slice(valueStart, i);
            break;
          }
          if (escaping) {
            valueStart = i - 1;
            escaping = false;
          }
          // Invalid unescaped quoted character (malformed)
          if (QDTEXT[code] !== 1)
            return;
        }

        // No end quote (malformed)
        if (i === str.length)
          return;

        ++i; // Skip over double quote
      } else {
        valueStart = i;
        // Parse unquoted value
        for (; i < str.length; ++i) {
          const code = str.charCodeAt(i);
          if (TOKEN[code] !== 1) {
            // No value (malformed)
            if (i === valueStart)
              return;
            break;
          }
        }
        value = str.slice(valueStart, i);
      }

      value = defDecoder(value, 2);
      if (value === undefined)
        return;
    }

    name = name.toLowerCase();
    if (params[name] === undefined)
      params[name] = value;
  }

  return params;
}

function getDecoder(charset) {
  let lc;
  while (true) {
    switch (charset) {
      case 'utf-8':
      case 'utf8':
        return decoders.utf8;
      case 'latin1':
      case 'ascii': // TODO: Make these a separate, strict decoder?
      case 'us-ascii':
      case 'iso-8859-1':
      case 'iso8859-1':
      case 'iso88591':
      case 'iso_8859-1':
      case 'windows-1252':
      case 'iso_8859-1:1987':
      case 'cp1252':
      case 'x-cp1252':
        return decoders.latin1;
      case 'utf16le':
      case 'utf-16le':
      case 'ucs2':
      case 'ucs-2':
        return decoders.utf16le;
      case 'base64':
        return decoders.base64;
      default:
        if (lc === undefined) {
          lc = true;
          charset = charset.toLowerCase();
          continue;
        }
        return decoders.other.bind(charset);
    }
  }
}

const decoders = {
  utf8: (data, hint) => {
    if (data.length === 0)
      return '';
    if (typeof data === 'string') {
      // If `data` never had any percent-encoded bytes or never had any that
      // were outside of the ASCII range, then we can safely just return the
      // input since UTF-8 is ASCII compatible
      if (hint < 2)
        return data;

      data = Buffer.from(data, 'latin1');
    }
    return data.utf8Slice(0, data.length);
  },

  latin1: (data, hint) => {
    if (data.length === 0)
      return '';
    if (typeof data === 'string')
      return data;
    return data.latin1Slice(0, data.length);
  },

  utf16le: (data, hint) => {
    if (data.length === 0)
      return '';
    if (typeof data === 'string')
      data = Buffer.from(data, 'latin1');
    return data.ucs2Slice(0, data.length);
  },

  base64: (data, hint) => {
    if (data.length === 0)
      return '';
    if (typeof data === 'string')
      data = Buffer.from(data, 'latin1');
    return data.base64Slice(0, data.length);
  },

  other: (data, hint) => {
    if (data.length === 0)
      return '';
    if (typeof data === 'string')
      data = Buffer.from(data, 'latin1');
    try {
      const decoder = new TextDecoder(this);
      return decoder.decode(data);
    } catch {}
  },
};

function convertToUTF8(data, charset, hint) {
  const decode = getDecoder(charset);
  if (decode)
    return decode(data, hint);
}

function basename(path) {
  if (typeof path !== 'string')
    return '';
  for (let i = path.length - 1; i >= 0; --i) {
    switch (path.charCodeAt(i)) {
      case 0x2F: // '/'
      case 0x5C: // '\'
        path = path.slice(i + 1);
        return (path === '..' || path === '.' ? '' : path);
    }
  }
  return (path === '..' || path === '.' ? '' : path);
}

const TOKEN = [
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
];

const QDTEXT = [
  0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
];

const CHARSET = [
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
];

const EXTENDED_VALUE = [
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 1, 0, 1, 1, 0, 1, 0, 0, 0, 0, 1, 0, 1, 1, 0,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
];

/* eslint-disable no-multi-spaces */
const HEX_VALUES = [
  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
   0,  1,  2,  3,  4,  5,  6,  7,  8,  9, -1, -1, -1, -1, -1, -1,
  -1, 10, 11, 12, 13, 14, 15, -1, -1, -1, -1, -1, -1, -1, -1, -1,
  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
  -1, 10, 11, 12, 13, 14, 15, -1, -1, -1, -1, -1, -1, -1, -1, -1,
  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
];
/* eslint-enable no-multi-spaces */

module.exports = {
  basename,
  convertToUTF8,
  getDecoder,
  parseContentType,
  parseDisposition,
};


/***/ }),

/***/ 34531:
/***/ ((module) => {

"use strict";
/*!
 * bytes
 * Copyright(c) 2012-2014 TJ Holowaychuk
 * Copyright(c) 2015 Jed Watson
 * MIT Licensed
 */



/**
 * Module exports.
 * @public
 */

module.exports = bytes;
module.exports.format = format;
module.exports.parse = parse;

/**
 * Module variables.
 * @private
 */

var formatThousandsRegExp = /\B(?=(\d{3})+(?!\d))/g;

var formatDecimalsRegExp = /(?:\.0*|(\.[^0]+)0+)$/;

var map = {
  b:  1,
  kb: 1 << 10,
  mb: 1 << 20,
  gb: 1 << 30,
  tb: Math.pow(1024, 4),
  pb: Math.pow(1024, 5),
};

var parseRegExp = /^((-|\+)?(\d+(?:\.\d+)?)) *(kb|mb|gb|tb|pb)$/i;

/**
 * Convert the given value in bytes into a string or parse to string to an integer in bytes.
 *
 * @param {string|number} value
 * @param {{
 *  case: [string],
 *  decimalPlaces: [number]
 *  fixedDecimals: [boolean]
 *  thousandsSeparator: [string]
 *  unitSeparator: [string]
 *  }} [options] bytes options.
 *
 * @returns {string|number|null}
 */

function bytes(value, options) {
  if (typeof value === 'string') {
    return parse(value);
  }

  if (typeof value === 'number') {
    return format(value, options);
  }

  return null;
}

/**
 * Format the given value in bytes into a string.
 *
 * If the value is negative, it is kept as such. If it is a float,
 * it is rounded.
 *
 * @param {number} value
 * @param {object} [options]
 * @param {number} [options.decimalPlaces=2]
 * @param {number} [options.fixedDecimals=false]
 * @param {string} [options.thousandsSeparator=]
 * @param {string} [options.unit=]
 * @param {string} [options.unitSeparator=]
 *
 * @returns {string|null}
 * @public
 */

function format(value, options) {
  if (!Number.isFinite(value)) {
    return null;
  }

  var mag = Math.abs(value);
  var thousandsSeparator = (options && options.thousandsSeparator) || '';
  var unitSeparator = (options && options.unitSeparator) || '';
  var decimalPlaces = (options && options.decimalPlaces !== undefined) ? options.decimalPlaces : 2;
  var fixedDecimals = Boolean(options && options.fixedDecimals);
  var unit = (options && options.unit) || '';

  if (!unit || !map[unit.toLowerCase()]) {
    if (mag >= map.pb) {
      unit = 'PB';
    } else if (mag >= map.tb) {
      unit = 'TB';
    } else if (mag >= map.gb) {
      unit = 'GB';
    } else if (mag >= map.mb) {
      unit = 'MB';
    } else if (mag >= map.kb) {
      unit = 'KB';
    } else {
      unit = 'B';
    }
  }

  var val = value / map[unit.toLowerCase()];
  var str = val.toFixed(decimalPlaces);

  if (!fixedDecimals) {
    str = str.replace(formatDecimalsRegExp, '$1');
  }

  if (thousandsSeparator) {
    str = str.split('.').map(function (s, i) {
      return i === 0
        ? s.replace(formatThousandsRegExp, thousandsSeparator)
        : s
    }).join('.');
  }

  return str + unitSeparator + unit;
}

/**
 * Parse the string value into an integer in bytes.
 *
 * If no unit is given, it is assumed the value is in bytes.
 *
 * @param {number|string} val
 *
 * @returns {number|null}
 * @public
 */

function parse(val) {
  if (typeof val === 'number' && !isNaN(val)) {
    return val;
  }

  if (typeof val !== 'string') {
    return null;
  }

  // Test if the string passed is valid
  var results = parseRegExp.exec(val);
  var floatValue;
  var unit = 'b';

  if (!results) {
    // Nothing could be extracted from the given string
    floatValue = parseInt(val, 10);
    unit = 'b'
  } else {
    // Retrieve the value and the unit
    floatValue = parseFloat(results[1]);
    unit = results[4].toLowerCase();
  }

  if (isNaN(floatValue)) {
    return null;
  }

  return Math.floor(map[unit] * floatValue);
}


/***/ }),

/***/ 22639:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


var bind = __nccwpck_require__(37564);

var $apply = __nccwpck_require__(33945);
var $call = __nccwpck_require__(88093);
var $reflectApply = __nccwpck_require__(31330);

/** @type {import('./actualApply')} */
module.exports = $reflectApply || bind.call($call, $apply);


/***/ }),

/***/ 33945:
/***/ ((module) => {

"use strict";


/** @type {import('./functionApply')} */
module.exports = Function.prototype.apply;


/***/ }),

/***/ 88093:
/***/ ((module) => {

"use strict";


/** @type {import('./functionCall')} */
module.exports = Function.prototype.call;


/***/ }),

/***/ 88705:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


var bind = __nccwpck_require__(37564);
var $TypeError = __nccwpck_require__(73314);

var $call = __nccwpck_require__(88093);
var $actualApply = __nccwpck_require__(22639);

/** @type {(args: [Function, thisArg?: unknown, ...args: unknown[]]) => Function} TODO FIXME, find a way to use import('.') */
module.exports = function callBindBasic(args) {
	if (args.length < 1 || typeof args[0] !== 'function') {
		throw new $TypeError('a function is required');
	}
	return $actualApply(bind, $call, args);
};


/***/ }),

/***/ 31330:
/***/ ((module) => {

"use strict";


/** @type {import('./reflectApply')} */
module.exports = typeof Reflect !== 'undefined' && Reflect && Reflect.apply;


/***/ }),

/***/ 23105:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


var GetIntrinsic = __nccwpck_require__(60470);

var callBindBasic = __nccwpck_require__(88705);

/** @type {(thisArg: string, searchString: string, position?: number) => number} */
var $indexOf = callBindBasic([GetIntrinsic('%String.prototype.indexOf%')]);

/** @type {import('.')} */
module.exports = function callBoundIntrinsic(name, allowMissing) {
	/* eslint no-extra-parens: 0 */

	var intrinsic = /** @type {(this: unknown, ...args: unknown[]) => unknown} */ (GetIntrinsic(name, !!allowMissing));
	if (typeof intrinsic === 'function' && $indexOf(name, '.prototype.') > -1) {
		return callBindBasic(/** @type {const} */ ([intrinsic]));
	}
	return intrinsic;
};


/***/ }),

/***/ 18015:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var Writable = (__nccwpck_require__(760).Writable)
var inherits = __nccwpck_require__(39598)
var bufferFrom = __nccwpck_require__(52337)

if (typeof Uint8Array === 'undefined') {
  var U8 = (__nccwpck_require__(2317)/* .Uint8Array */ .SE)
} else {
  var U8 = Uint8Array
}

function ConcatStream(opts, cb) {
  if (!(this instanceof ConcatStream)) return new ConcatStream(opts, cb)

  if (typeof opts === 'function') {
    cb = opts
    opts = {}
  }
  if (!opts) opts = {}

  var encoding = opts.encoding
  var shouldInferEncoding = false

  if (!encoding) {
    shouldInferEncoding = true
  } else {
    encoding =  String(encoding).toLowerCase()
    if (encoding === 'u8' || encoding === 'uint8') {
      encoding = 'uint8array'
    }
  }

  Writable.call(this, { objectMode: true })

  this.encoding = encoding
  this.shouldInferEncoding = shouldInferEncoding

  if (cb) this.on('finish', function () { cb(this.getBody()) })
  this.body = []
}

module.exports = ConcatStream
inherits(ConcatStream, Writable)

ConcatStream.prototype._write = function(chunk, enc, next) {
  this.body.push(chunk)
  next()
}

ConcatStream.prototype.inferEncoding = function (buff) {
  var firstBuffer = buff === undefined ? this.body[0] : buff;
  if (Buffer.isBuffer(firstBuffer)) return 'buffer'
  if (typeof Uint8Array !== 'undefined' && firstBuffer instanceof Uint8Array) return 'uint8array'
  if (Array.isArray(firstBuffer)) return 'array'
  if (typeof firstBuffer === 'string') return 'string'
  if (Object.prototype.toString.call(firstBuffer) === "[object Object]") return 'object'
  return 'buffer'
}

ConcatStream.prototype.getBody = function () {
  if (!this.encoding && this.body.length === 0) return []
  if (this.shouldInferEncoding) this.encoding = this.inferEncoding()
  if (this.encoding === 'array') return arrayConcat(this.body)
  if (this.encoding === 'string') return stringConcat(this.body)
  if (this.encoding === 'buffer') return bufferConcat(this.body)
  if (this.encoding === 'uint8array') return u8Concat(this.body)
  return this.body
}

var isArray = Array.isArray || function (arr) {
  return Object.prototype.toString.call(arr) == '[object Array]'
}

function isArrayish (arr) {
  return /Array\]$/.test(Object.prototype.toString.call(arr))
}

function isBufferish (p) {
  return typeof p === 'string' || isArrayish(p) || (p && typeof p.subarray === 'function')
}

function stringConcat (parts) {
  var strings = []
  var needsToString = false
  for (var i = 0; i < parts.length; i++) {
    var p = parts[i]
    if (typeof p === 'string') {
      strings.push(p)
    } else if (Buffer.isBuffer(p)) {
      strings.push(p)
    } else if (isBufferish(p)) {
      strings.push(bufferFrom(p))
    } else {
      strings.push(bufferFrom(String(p)))
    }
  }
  if (Buffer.isBuffer(parts[0])) {
    strings = Buffer.concat(strings)
    strings = strings.toString('utf8')
  } else {
    strings = strings.join('')
  }
  return strings
}

function bufferConcat (parts) {
  var bufs = []
  for (var i = 0; i < parts.length; i++) {
    var p = parts[i]
    if (Buffer.isBuffer(p)) {
      bufs.push(p)
    } else if (isBufferish(p)) {
      bufs.push(bufferFrom(p))
    } else {
      bufs.push(bufferFrom(String(p)))
    }
  }
  return Buffer.concat(bufs)
}

function arrayConcat (parts) {
  var res = []
  for (var i = 0; i < parts.length; i++) {
    res.push.apply(res, parts[i])
  }
  return res
}

function u8Concat (parts) {
  var len = 0
  for (var i = 0; i < parts.length; i++) {
    if (typeof parts[i] === 'string') {
      parts[i] = bufferFrom(parts[i])
    }
    len += parts[i].length
  }
  var u8 = new U8(len)
  for (var i = 0, offset = 0; i < parts.length; i++) {
    var part = parts[i]
    for (var j = 0; j < part.length; j++) {
      u8[offset++] = part[j]
    }
  }
  return u8
}


/***/ }),

/***/ 97424:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.



/*<replacement>*/

var pna = __nccwpck_require__(41564);
/*</replacement>*/

/*<replacement>*/
var objectKeys = Object.keys || function (obj) {
  var keys = [];
  for (var key in obj) {
    keys.push(key);
  }return keys;
};
/*</replacement>*/

module.exports = Duplex;

/*<replacement>*/
var util = Object.create(__nccwpck_require__(45481));
util.inherits = __nccwpck_require__(39598);
/*</replacement>*/

var Readable = __nccwpck_require__(73622);
var Writable = __nccwpck_require__(83866);

util.inherits(Duplex, Readable);

{
  // avoid scope creep, the keys array can then be collected
  var keys = objectKeys(Writable.prototype);
  for (var v = 0; v < keys.length; v++) {
    var method = keys[v];
    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
  }
}

function Duplex(options) {
  if (!(this instanceof Duplex)) return new Duplex(options);

  Readable.call(this, options);
  Writable.call(this, options);

  if (options && options.readable === false) this.readable = false;

  if (options && options.writable === false) this.writable = false;

  this.allowHalfOpen = true;
  if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;

  this.once('end', onend);
}

Object.defineProperty(Duplex.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function () {
    return this._writableState.highWaterMark;
  }
});

// the no-half-open enforcer
function onend() {
  // if we allow half-open state, or if the writable side ended,
  // then we're ok.
  if (this.allowHalfOpen || this._writableState.ended) return;

  // no more data can be written.
  // But allow more writes to happen in this tick.
  pna.nextTick(onEndNT, this);
}

function onEndNT(self) {
  self.end();
}

Object.defineProperty(Duplex.prototype, 'destroyed', {
  get: function () {
    if (this._readableState === undefined || this._writableState === undefined) {
      return false;
    }
    return this._readableState.destroyed && this._writableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (this._readableState === undefined || this._writableState === undefined) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._readableState.destroyed = value;
    this._writableState.destroyed = value;
  }
});

Duplex.prototype._destroy = function (err, cb) {
  this.push(null);
  this.end();

  pna.nextTick(cb, err);
};

/***/ }),

/***/ 7890:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a passthrough stream.
// basically just the most minimal sort of Transform stream.
// Every written chunk gets output as-is.



module.exports = PassThrough;

var Transform = __nccwpck_require__(71424);

/*<replacement>*/
var util = Object.create(__nccwpck_require__(45481));
util.inherits = __nccwpck_require__(39598);
/*</replacement>*/

util.inherits(PassThrough, Transform);

function PassThrough(options) {
  if (!(this instanceof PassThrough)) return new PassThrough(options);

  Transform.call(this, options);
}

PassThrough.prototype._transform = function (chunk, encoding, cb) {
  cb(null, chunk);
};

/***/ }),

/***/ 73622:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



/*<replacement>*/

var pna = __nccwpck_require__(41564);
/*</replacement>*/

module.exports = Readable;

/*<replacement>*/
var isArray = __nccwpck_require__(82513);
/*</replacement>*/

/*<replacement>*/
var Duplex;
/*</replacement>*/

Readable.ReadableState = ReadableState;

/*<replacement>*/
var EE = (__nccwpck_require__(24434).EventEmitter);

var EElistenerCount = function (emitter, type) {
  return emitter.listeners(type).length;
};
/*</replacement>*/

/*<replacement>*/
var Stream = __nccwpck_require__(430);
/*</replacement>*/

/*<replacement>*/

var Buffer = (__nccwpck_require__(13447).Buffer);
var OurUint8Array = (typeof global !== 'undefined' ? global : typeof window !== 'undefined' ? window : typeof self !== 'undefined' ? self : {}).Uint8Array || function () {};
function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}
function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}

/*</replacement>*/

/*<replacement>*/
var util = Object.create(__nccwpck_require__(45481));
util.inherits = __nccwpck_require__(39598);
/*</replacement>*/

/*<replacement>*/
var debugUtil = __nccwpck_require__(39023);
var debug = void 0;
if (debugUtil && debugUtil.debuglog) {
  debug = debugUtil.debuglog('stream');
} else {
  debug = function () {};
}
/*</replacement>*/

var BufferList = __nccwpck_require__(80312);
var destroyImpl = __nccwpck_require__(47998);
var StringDecoder;

util.inherits(Readable, Stream);

var kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];

function prependListener(emitter, event, fn) {
  // Sadly this is not cacheable as some libraries bundle their own
  // event emitter implementation with them.
  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn);

  // This is a hack to make sure that our error handler is attached before any
  // userland ones.  NEVER DO THIS. This is here only because this code needs
  // to continue to work with older versions of Node.js that do not include
  // the prependListener() method. The goal is to eventually remove this hack.
  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];
}

function ReadableState(options, stream) {
  Duplex = Duplex || __nccwpck_require__(97424);

  options = options || {};

  // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream.
  // These options can be provided separately as readableXXX and writableXXX.
  var isDuplex = stream instanceof Duplex;

  // object stream flag. Used to make read(n) ignore n and to
  // make all the buffer merging and length checks go away
  this.objectMode = !!options.objectMode;

  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;

  // the point at which it stops calling _read() to fill the buffer
  // Note: 0 is a valid value, means "don't call _read preemptively ever"
  var hwm = options.highWaterMark;
  var readableHwm = options.readableHighWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;

  if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (readableHwm || readableHwm === 0)) this.highWaterMark = readableHwm;else this.highWaterMark = defaultHwm;

  // cast to ints.
  this.highWaterMark = Math.floor(this.highWaterMark);

  // A linked list is used to store data chunks instead of an array because the
  // linked list can remove elements from the beginning faster than
  // array.shift()
  this.buffer = new BufferList();
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false;

  // a flag to be able to tell if the event 'readable'/'data' is emitted
  // immediately, or on a later tick.  We set this to true at first, because
  // any actions that shouldn't happen until "later" should generally also
  // not happen before the first read call.
  this.sync = true;

  // whenever we return null, then we set a flag to say
  // that we're awaiting a 'readable' event emission.
  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;
  this.resumeScheduled = false;

  // has it been destroyed
  this.destroyed = false;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // the number of writers that are awaiting a drain event in .pipe()s
  this.awaitDrain = 0;

  // if true, a maybeReadMore has been scheduled
  this.readingMore = false;

  this.decoder = null;
  this.encoding = null;
  if (options.encoding) {
    if (!StringDecoder) StringDecoder = (__nccwpck_require__(46771)/* .StringDecoder */ .I);
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}

function Readable(options) {
  Duplex = Duplex || __nccwpck_require__(97424);

  if (!(this instanceof Readable)) return new Readable(options);

  this._readableState = new ReadableState(options, this);

  // legacy
  this.readable = true;

  if (options) {
    if (typeof options.read === 'function') this._read = options.read;

    if (typeof options.destroy === 'function') this._destroy = options.destroy;
  }

  Stream.call(this);
}

Object.defineProperty(Readable.prototype, 'destroyed', {
  get: function () {
    if (this._readableState === undefined) {
      return false;
    }
    return this._readableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._readableState) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._readableState.destroyed = value;
  }
});

Readable.prototype.destroy = destroyImpl.destroy;
Readable.prototype._undestroy = destroyImpl.undestroy;
Readable.prototype._destroy = function (err, cb) {
  this.push(null);
  cb(err);
};

// Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.
Readable.prototype.push = function (chunk, encoding) {
  var state = this._readableState;
  var skipChunkCheck;

  if (!state.objectMode) {
    if (typeof chunk === 'string') {
      encoding = encoding || state.defaultEncoding;
      if (encoding !== state.encoding) {
        chunk = Buffer.from(chunk, encoding);
        encoding = '';
      }
      skipChunkCheck = true;
    }
  } else {
    skipChunkCheck = true;
  }

  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
};

// Unshift should *always* be something directly out of read()
Readable.prototype.unshift = function (chunk) {
  return readableAddChunk(this, chunk, null, true, false);
};

function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
  var state = stream._readableState;
  if (chunk === null) {
    state.reading = false;
    onEofChunk(stream, state);
  } else {
    var er;
    if (!skipChunkCheck) er = chunkInvalid(state, chunk);
    if (er) {
      stream.emit('error', er);
    } else if (state.objectMode || chunk && chunk.length > 0) {
      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {
        chunk = _uint8ArrayToBuffer(chunk);
      }

      if (addToFront) {
        if (state.endEmitted) stream.emit('error', new Error('stream.unshift() after end event'));else addChunk(stream, state, chunk, true);
      } else if (state.ended) {
        stream.emit('error', new Error('stream.push() after EOF'));
      } else {
        state.reading = false;
        if (state.decoder && !encoding) {
          chunk = state.decoder.write(chunk);
          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);
        } else {
          addChunk(stream, state, chunk, false);
        }
      }
    } else if (!addToFront) {
      state.reading = false;
    }
  }

  return needMoreData(state);
}

function addChunk(stream, state, chunk, addToFront) {
  if (state.flowing && state.length === 0 && !state.sync) {
    stream.emit('data', chunk);
    stream.read(0);
  } else {
    // update the buffer info.
    state.length += state.objectMode ? 1 : chunk.length;
    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);

    if (state.needReadable) emitReadable(stream);
  }
  maybeReadMore(stream, state);
}

function chunkInvalid(state, chunk) {
  var er;
  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  return er;
}

// if it's past the high water mark, we can push in some more.
// Also, if we have no data yet, we can stand some
// more bytes.  This is to work around cases where hwm=0,
// such as the repl.  Also, if the push() triggered a
// readable event, and the user called read(largeNumber) such that
// needReadable was set, then we ought to push more, so that another
// 'readable' event will be triggered.
function needMoreData(state) {
  return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
}

Readable.prototype.isPaused = function () {
  return this._readableState.flowing === false;
};

// backwards compatibility.
Readable.prototype.setEncoding = function (enc) {
  if (!StringDecoder) StringDecoder = (__nccwpck_require__(46771)/* .StringDecoder */ .I);
  this._readableState.decoder = new StringDecoder(enc);
  this._readableState.encoding = enc;
  return this;
};

// Don't raise the hwm > 8MB
var MAX_HWM = 0x800000;
function computeNewHighWaterMark(n) {
  if (n >= MAX_HWM) {
    n = MAX_HWM;
  } else {
    // Get the next highest power of 2 to prevent increasing hwm excessively in
    // tiny amounts
    n--;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    n++;
  }
  return n;
}

// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function howMuchToRead(n, state) {
  if (n <= 0 || state.length === 0 && state.ended) return 0;
  if (state.objectMode) return 1;
  if (n !== n) {
    // Only flow one buffer at a time
    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;
  }
  // If we're asking for more than the current hwm, then raise the hwm.
  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
  if (n <= state.length) return n;
  // Don't have enough
  if (!state.ended) {
    state.needReadable = true;
    return 0;
  }
  return state.length;
}

// you can override either this method, or the async _read(n) below.
Readable.prototype.read = function (n) {
  debug('read', n);
  n = parseInt(n, 10);
  var state = this._readableState;
  var nOrig = n;

  if (n !== 0) state.emittedReadable = false;

  // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.
  if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
    debug('read: emitReadable', state.length, state.ended);
    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
    return null;
  }

  n = howMuchToRead(n, state);

  // if we've ended, and we're now clear, then finish it up.
  if (n === 0 && state.ended) {
    if (state.length === 0) endReadable(this);
    return null;
  }

  // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.

  // if we need a readable event, then we need to do some reading.
  var doRead = state.needReadable;
  debug('need readable', doRead);

  // if we currently have less than the highWaterMark, then also read some
  if (state.length === 0 || state.length - n < state.highWaterMark) {
    doRead = true;
    debug('length less than watermark', doRead);
  }

  // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.
  if (state.ended || state.reading) {
    doRead = false;
    debug('reading or ended', doRead);
  } else if (doRead) {
    debug('do read');
    state.reading = true;
    state.sync = true;
    // if the length is currently zero, then we *need* a readable event.
    if (state.length === 0) state.needReadable = true;
    // call internal read method
    this._read(state.highWaterMark);
    state.sync = false;
    // If _read pushed data synchronously, then `reading` will be false,
    // and we need to re-evaluate how much data we can return to the user.
    if (!state.reading) n = howMuchToRead(nOrig, state);
  }

  var ret;
  if (n > 0) ret = fromList(n, state);else ret = null;

  if (ret === null) {
    state.needReadable = true;
    n = 0;
  } else {
    state.length -= n;
  }

  if (state.length === 0) {
    // If we have nothing in the buffer, then we want to know
    // as soon as we *do* get something into the buffer.
    if (!state.ended) state.needReadable = true;

    // If we tried to read() past the EOF, then emit end on the next tick.
    if (nOrig !== n && state.ended) endReadable(this);
  }

  if (ret !== null) this.emit('data', ret);

  return ret;
};

function onEofChunk(stream, state) {
  if (state.ended) return;
  if (state.decoder) {
    var chunk = state.decoder.end();
    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }
  state.ended = true;

  // emit 'readable' now to make sure it gets picked up.
  emitReadable(stream);
}

// Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.
function emitReadable(stream) {
  var state = stream._readableState;
  state.needReadable = false;
  if (!state.emittedReadable) {
    debug('emitReadable', state.flowing);
    state.emittedReadable = true;
    if (state.sync) pna.nextTick(emitReadable_, stream);else emitReadable_(stream);
  }
}

function emitReadable_(stream) {
  debug('emit readable');
  stream.emit('readable');
  flow(stream);
}

// at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.
function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    pna.nextTick(maybeReadMore_, stream, state);
  }
}

function maybeReadMore_(stream, state) {
  var len = state.length;
  while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
    debug('maybeReadMore read 0');
    stream.read(0);
    if (len === state.length)
      // didn't get any data, stop spinning.
      break;else len = state.length;
  }
  state.readingMore = false;
}

// abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.
Readable.prototype._read = function (n) {
  this.emit('error', new Error('_read() is not implemented'));
};

Readable.prototype.pipe = function (dest, pipeOpts) {
  var src = this;
  var state = this._readableState;

  switch (state.pipesCount) {
    case 0:
      state.pipes = dest;
      break;
    case 1:
      state.pipes = [state.pipes, dest];
      break;
    default:
      state.pipes.push(dest);
      break;
  }
  state.pipesCount += 1;
  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);

  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;

  var endFn = doEnd ? onend : unpipe;
  if (state.endEmitted) pna.nextTick(endFn);else src.once('end', endFn);

  dest.on('unpipe', onunpipe);
  function onunpipe(readable, unpipeInfo) {
    debug('onunpipe');
    if (readable === src) {
      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
        unpipeInfo.hasUnpiped = true;
        cleanup();
      }
    }
  }

  function onend() {
    debug('onend');
    dest.end();
  }

  // when the dest drains, it reduces the awaitDrain counter
  // on the source.  This would be more elegant with a .once()
  // handler in flow(), but adding and removing repeatedly is
  // too slow.
  var ondrain = pipeOnDrain(src);
  dest.on('drain', ondrain);

  var cleanedUp = false;
  function cleanup() {
    debug('cleanup');
    // cleanup event handlers once the pipe is broken
    dest.removeListener('close', onclose);
    dest.removeListener('finish', onfinish);
    dest.removeListener('drain', ondrain);
    dest.removeListener('error', onerror);
    dest.removeListener('unpipe', onunpipe);
    src.removeListener('end', onend);
    src.removeListener('end', unpipe);
    src.removeListener('data', ondata);

    cleanedUp = true;

    // if the reader is waiting for a drain event from this
    // specific writer, then it would cause it to never start
    // flowing again.
    // So, if this is awaiting a drain, then we just call it now.
    // If we don't know, then assume that we are waiting for one.
    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
  }

  // If the user pushes more data while we're writing to dest then we'll end up
  // in ondata again. However, we only want to increase awaitDrain once because
  // dest will only emit one 'drain' event for the multiple writes.
  // => Introduce a guard on increasing awaitDrain.
  var increasedAwaitDrain = false;
  src.on('data', ondata);
  function ondata(chunk) {
    debug('ondata');
    increasedAwaitDrain = false;
    var ret = dest.write(chunk);
    if (false === ret && !increasedAwaitDrain) {
      // If the user unpiped during `dest.write()`, it is possible
      // to get stuck in a permanently paused state if that write
      // also returned false.
      // => Check whether `dest` is still a piping destination.
      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
        debug('false write response, pause', state.awaitDrain);
        state.awaitDrain++;
        increasedAwaitDrain = true;
      }
      src.pause();
    }
  }

  // if the dest has an error, then stop piping into it.
  // however, don't suppress the throwing behavior for this.
  function onerror(er) {
    debug('onerror', er);
    unpipe();
    dest.removeListener('error', onerror);
    if (EElistenerCount(dest, 'error') === 0) dest.emit('error', er);
  }

  // Make sure our error handler is attached before userland ones.
  prependListener(dest, 'error', onerror);

  // Both close and finish should trigger unpipe, but only once.
  function onclose() {
    dest.removeListener('finish', onfinish);
    unpipe();
  }
  dest.once('close', onclose);
  function onfinish() {
    debug('onfinish');
    dest.removeListener('close', onclose);
    unpipe();
  }
  dest.once('finish', onfinish);

  function unpipe() {
    debug('unpipe');
    src.unpipe(dest);
  }

  // tell the dest that it's being piped to
  dest.emit('pipe', src);

  // start the flow if it hasn't been started already.
  if (!state.flowing) {
    debug('pipe resume');
    src.resume();
  }

  return dest;
};

function pipeOnDrain(src) {
  return function () {
    var state = src._readableState;
    debug('pipeOnDrain', state.awaitDrain);
    if (state.awaitDrain) state.awaitDrain--;
    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
      state.flowing = true;
      flow(src);
    }
  };
}

Readable.prototype.unpipe = function (dest) {
  var state = this._readableState;
  var unpipeInfo = { hasUnpiped: false };

  // if we're not piping anywhere, then do nothing.
  if (state.pipesCount === 0) return this;

  // just one destination.  most common case.
  if (state.pipesCount === 1) {
    // passed in one, but it's not the right one.
    if (dest && dest !== state.pipes) return this;

    if (!dest) dest = state.pipes;

    // got a match.
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;
    if (dest) dest.emit('unpipe', this, unpipeInfo);
    return this;
  }

  // slow case. multiple pipe destinations.

  if (!dest) {
    // remove all.
    var dests = state.pipes;
    var len = state.pipesCount;
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;

    for (var i = 0; i < len; i++) {
      dests[i].emit('unpipe', this, { hasUnpiped: false });
    }return this;
  }

  // try to find the right one.
  var index = indexOf(state.pipes, dest);
  if (index === -1) return this;

  state.pipes.splice(index, 1);
  state.pipesCount -= 1;
  if (state.pipesCount === 1) state.pipes = state.pipes[0];

  dest.emit('unpipe', this, unpipeInfo);

  return this;
};

// set up data events if they are asked for
// Ensure readable listeners eventually get something
Readable.prototype.on = function (ev, fn) {
  var res = Stream.prototype.on.call(this, ev, fn);

  if (ev === 'data') {
    // Start flowing on next tick if stream isn't explicitly paused
    if (this._readableState.flowing !== false) this.resume();
  } else if (ev === 'readable') {
    var state = this._readableState;
    if (!state.endEmitted && !state.readableListening) {
      state.readableListening = state.needReadable = true;
      state.emittedReadable = false;
      if (!state.reading) {
        pna.nextTick(nReadingNextTick, this);
      } else if (state.length) {
        emitReadable(this);
      }
    }
  }

  return res;
};
Readable.prototype.addListener = Readable.prototype.on;

function nReadingNextTick(self) {
  debug('readable nexttick read 0');
  self.read(0);
}

// pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.
Readable.prototype.resume = function () {
  var state = this._readableState;
  if (!state.flowing) {
    debug('resume');
    state.flowing = true;
    resume(this, state);
  }
  return this;
};

function resume(stream, state) {
  if (!state.resumeScheduled) {
    state.resumeScheduled = true;
    pna.nextTick(resume_, stream, state);
  }
}

function resume_(stream, state) {
  if (!state.reading) {
    debug('resume read 0');
    stream.read(0);
  }

  state.resumeScheduled = false;
  state.awaitDrain = 0;
  stream.emit('resume');
  flow(stream);
  if (state.flowing && !state.reading) stream.read(0);
}

Readable.prototype.pause = function () {
  debug('call pause flowing=%j', this._readableState.flowing);
  if (false !== this._readableState.flowing) {
    debug('pause');
    this._readableState.flowing = false;
    this.emit('pause');
  }
  return this;
};

function flow(stream) {
  var state = stream._readableState;
  debug('flow', state.flowing);
  while (state.flowing && stream.read() !== null) {}
}

// wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.
Readable.prototype.wrap = function (stream) {
  var _this = this;

  var state = this._readableState;
  var paused = false;

  stream.on('end', function () {
    debug('wrapped end');
    if (state.decoder && !state.ended) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length) _this.push(chunk);
    }

    _this.push(null);
  });

  stream.on('data', function (chunk) {
    debug('wrapped data');
    if (state.decoder) chunk = state.decoder.write(chunk);

    // don't skip over falsy values in objectMode
    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;

    var ret = _this.push(chunk);
    if (!ret) {
      paused = true;
      stream.pause();
    }
  });

  // proxy all the other methods.
  // important when wrapping filters and duplexes.
  for (var i in stream) {
    if (this[i] === undefined && typeof stream[i] === 'function') {
      this[i] = function (method) {
        return function () {
          return stream[method].apply(stream, arguments);
        };
      }(i);
    }
  }

  // proxy certain important events.
  for (var n = 0; n < kProxyEvents.length; n++) {
    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
  }

  // when we try to consume some more bytes, simply unpause the
  // underlying stream.
  this._read = function (n) {
    debug('wrapped _read', n);
    if (paused) {
      paused = false;
      stream.resume();
    }
  };

  return this;
};

Object.defineProperty(Readable.prototype, 'readableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function () {
    return this._readableState.highWaterMark;
  }
});

// exposed for testing purposes only.
Readable._fromList = fromList;

// Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function fromList(n, state) {
  // nothing buffered
  if (state.length === 0) return null;

  var ret;
  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {
    // read it all, truncate the list
    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.head.data;else ret = state.buffer.concat(state.length);
    state.buffer.clear();
  } else {
    // read part of list
    ret = fromListPartial(n, state.buffer, state.decoder);
  }

  return ret;
}

// Extracts only enough buffered data to satisfy the amount requested.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function fromListPartial(n, list, hasStrings) {
  var ret;
  if (n < list.head.data.length) {
    // slice is the same for buffers and strings
    ret = list.head.data.slice(0, n);
    list.head.data = list.head.data.slice(n);
  } else if (n === list.head.data.length) {
    // first chunk is a perfect match
    ret = list.shift();
  } else {
    // result spans more than one buffer
    ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
  }
  return ret;
}

// Copies a specified amount of characters from the list of buffered data
// chunks.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function copyFromBufferString(n, list) {
  var p = list.head;
  var c = 1;
  var ret = p.data;
  n -= ret.length;
  while (p = p.next) {
    var str = p.data;
    var nb = n > str.length ? str.length : n;
    if (nb === str.length) ret += str;else ret += str.slice(0, n);
    n -= nb;
    if (n === 0) {
      if (nb === str.length) {
        ++c;
        if (p.next) list.head = p.next;else list.head = list.tail = null;
      } else {
        list.head = p;
        p.data = str.slice(nb);
      }
      break;
    }
    ++c;
  }
  list.length -= c;
  return ret;
}

// Copies a specified amount of bytes from the list of buffered data chunks.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function copyFromBuffer(n, list) {
  var ret = Buffer.allocUnsafe(n);
  var p = list.head;
  var c = 1;
  p.data.copy(ret);
  n -= p.data.length;
  while (p = p.next) {
    var buf = p.data;
    var nb = n > buf.length ? buf.length : n;
    buf.copy(ret, ret.length - n, 0, nb);
    n -= nb;
    if (n === 0) {
      if (nb === buf.length) {
        ++c;
        if (p.next) list.head = p.next;else list.head = list.tail = null;
      } else {
        list.head = p;
        p.data = buf.slice(nb);
      }
      break;
    }
    ++c;
  }
  list.length -= c;
  return ret;
}

function endReadable(stream) {
  var state = stream._readableState;

  // If we get here before consuming all the bytes, then that is a
  // bug in node.  Should never happen.
  if (state.length > 0) throw new Error('"endReadable()" called on non-empty stream');

  if (!state.endEmitted) {
    state.ended = true;
    pna.nextTick(endReadableNT, state, stream);
  }
}

function endReadableNT(state, stream) {
  // Check that we didn't get one last unshift.
  if (!state.endEmitted && state.length === 0) {
    state.endEmitted = true;
    stream.readable = false;
    stream.emit('end');
  }
}

function indexOf(xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x) return i;
  }
  return -1;
}

/***/ }),

/***/ 71424:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.



module.exports = Transform;

var Duplex = __nccwpck_require__(97424);

/*<replacement>*/
var util = Object.create(__nccwpck_require__(45481));
util.inherits = __nccwpck_require__(39598);
/*</replacement>*/

util.inherits(Transform, Duplex);

function afterTransform(er, data) {
  var ts = this._transformState;
  ts.transforming = false;

  var cb = ts.writecb;

  if (!cb) {
    return this.emit('error', new Error('write callback called multiple times'));
  }

  ts.writechunk = null;
  ts.writecb = null;

  if (data != null) // single equals check for both `null` and `undefined`
    this.push(data);

  cb(er);

  var rs = this._readableState;
  rs.reading = false;
  if (rs.needReadable || rs.length < rs.highWaterMark) {
    this._read(rs.highWaterMark);
  }
}

function Transform(options) {
  if (!(this instanceof Transform)) return new Transform(options);

  Duplex.call(this, options);

  this._transformState = {
    afterTransform: afterTransform.bind(this),
    needTransform: false,
    transforming: false,
    writecb: null,
    writechunk: null,
    writeencoding: null
  };

  // start out asking for a readable event once data is transformed.
  this._readableState.needReadable = true;

  // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.
  this._readableState.sync = false;

  if (options) {
    if (typeof options.transform === 'function') this._transform = options.transform;

    if (typeof options.flush === 'function') this._flush = options.flush;
  }

  // When the writable side finishes, then flush out anything remaining.
  this.on('prefinish', prefinish);
}

function prefinish() {
  var _this = this;

  if (typeof this._flush === 'function') {
    this._flush(function (er, data) {
      done(_this, er, data);
    });
  } else {
    done(this, null, null);
  }
}

Transform.prototype.push = function (chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
};

// This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.
Transform.prototype._transform = function (chunk, encoding, cb) {
  throw new Error('_transform() is not implemented');
};

Transform.prototype._write = function (chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;
  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
  }
};

// Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.
Transform.prototype._read = function (n) {
  var ts = this._transformState;

  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
    ts.transforming = true;
    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
  }
};

Transform.prototype._destroy = function (err, cb) {
  var _this2 = this;

  Duplex.prototype._destroy.call(this, err, function (err2) {
    cb(err2);
    _this2.emit('close');
  });
};

function done(stream, er, data) {
  if (er) return stream.emit('error', er);

  if (data != null) // single equals check for both `null` and `undefined`
    stream.push(data);

  // if there's nothing in the write buffer, then that means
  // that nothing more will ever be provided
  if (stream._writableState.length) throw new Error('Calling transform done when ws.length != 0');

  if (stream._transformState.transforming) throw new Error('Calling transform done when still transforming');

  return stream.push(null);
}

/***/ }),

/***/ 83866:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// A bit simpler than readable streams.
// Implement an async ._write(chunk, encoding, cb), and it'll handle all
// the drain event emission and buffering.



/*<replacement>*/

var pna = __nccwpck_require__(41564);
/*</replacement>*/

module.exports = Writable;

/* <replacement> */
function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
  this.next = null;
}

// It seems a linked list but it is not
// there will be only 2 of these for each stream
function CorkedRequest(state) {
  var _this = this;

  this.next = null;
  this.entry = null;
  this.finish = function () {
    onCorkedFinish(_this, state);
  };
}
/* </replacement> */

/*<replacement>*/
var asyncWrite = !process.browser && ['v0.10', 'v0.9.'].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : pna.nextTick;
/*</replacement>*/

/*<replacement>*/
var Duplex;
/*</replacement>*/

Writable.WritableState = WritableState;

/*<replacement>*/
var util = Object.create(__nccwpck_require__(45481));
util.inherits = __nccwpck_require__(39598);
/*</replacement>*/

/*<replacement>*/
var internalUtil = {
  deprecate: __nccwpck_require__(24488)
};
/*</replacement>*/

/*<replacement>*/
var Stream = __nccwpck_require__(430);
/*</replacement>*/

/*<replacement>*/

var Buffer = (__nccwpck_require__(13447).Buffer);
var OurUint8Array = (typeof global !== 'undefined' ? global : typeof window !== 'undefined' ? window : typeof self !== 'undefined' ? self : {}).Uint8Array || function () {};
function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}
function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}

/*</replacement>*/

var destroyImpl = __nccwpck_require__(47998);

util.inherits(Writable, Stream);

function nop() {}

function WritableState(options, stream) {
  Duplex = Duplex || __nccwpck_require__(97424);

  options = options || {};

  // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream.
  // These options can be provided separately as readableXXX and writableXXX.
  var isDuplex = stream instanceof Duplex;

  // object stream flag to indicate whether or not this stream
  // contains buffers or objects.
  this.objectMode = !!options.objectMode;

  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;

  // the point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write()
  var hwm = options.highWaterMark;
  var writableHwm = options.writableHighWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;

  if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (writableHwm || writableHwm === 0)) this.highWaterMark = writableHwm;else this.highWaterMark = defaultHwm;

  // cast to ints.
  this.highWaterMark = Math.floor(this.highWaterMark);

  // if _final has been called
  this.finalCalled = false;

  // drain event flag.
  this.needDrain = false;
  // at the start of calling end()
  this.ending = false;
  // when end() has been called, and returned
  this.ended = false;
  // when 'finish' is emitted
  this.finished = false;

  // has it been destroyed
  this.destroyed = false;

  // should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.
  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.
  this.length = 0;

  // a flag to see when we're in the middle of a write.
  this.writing = false;

  // when true all writes will be buffered until .uncork() call
  this.corked = 0;

  // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.
  this.sync = true;

  // a flag to know if we're processing previously buffered items, which
  // may call the _write() callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.
  this.bufferProcessing = false;

  // the callback that's passed to _write(chunk,cb)
  this.onwrite = function (er) {
    onwrite(stream, er);
  };

  // the callback that the user supplies to write(chunk,encoding,cb)
  this.writecb = null;

  // the amount that is being written when _write is called.
  this.writelen = 0;

  this.bufferedRequest = null;
  this.lastBufferedRequest = null;

  // number of pending user-supplied write callbacks
  // this must be 0 before 'finish' can be emitted
  this.pendingcb = 0;

  // emit prefinish if the only thing we're waiting for is _write cbs
  // This is relevant for synchronous Transform streams
  this.prefinished = false;

  // True if the error was already emitted and should not be thrown again
  this.errorEmitted = false;

  // count buffered requests
  this.bufferedRequestCount = 0;

  // allocate the first CorkedRequest, there is always
  // one allocated and free to use, and we maintain at most two
  this.corkedRequestsFree = new CorkedRequest(this);
}

WritableState.prototype.getBuffer = function getBuffer() {
  var current = this.bufferedRequest;
  var out = [];
  while (current) {
    out.push(current);
    current = current.next;
  }
  return out;
};

(function () {
  try {
    Object.defineProperty(WritableState.prototype, 'buffer', {
      get: internalUtil.deprecate(function () {
        return this.getBuffer();
      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')
    });
  } catch (_) {}
})();

// Test _writableState for inheritance to account for Duplex streams,
// whose prototype chain only points to Readable.
var realHasInstance;
if (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {
  realHasInstance = Function.prototype[Symbol.hasInstance];
  Object.defineProperty(Writable, Symbol.hasInstance, {
    value: function (object) {
      if (realHasInstance.call(this, object)) return true;
      if (this !== Writable) return false;

      return object && object._writableState instanceof WritableState;
    }
  });
} else {
  realHasInstance = function (object) {
    return object instanceof this;
  };
}

function Writable(options) {
  Duplex = Duplex || __nccwpck_require__(97424);

  // Writable ctor is applied to Duplexes, too.
  // `realHasInstance` is necessary because using plain `instanceof`
  // would return false, as no `_writableState` property is attached.

  // Trying to use the custom `instanceof` for Writable here will also break the
  // Node.js LazyTransform implementation, which has a non-trivial getter for
  // `_writableState` that would lead to infinite recursion.
  if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {
    return new Writable(options);
  }

  this._writableState = new WritableState(options, this);

  // legacy.
  this.writable = true;

  if (options) {
    if (typeof options.write === 'function') this._write = options.write;

    if (typeof options.writev === 'function') this._writev = options.writev;

    if (typeof options.destroy === 'function') this._destroy = options.destroy;

    if (typeof options.final === 'function') this._final = options.final;
  }

  Stream.call(this);
}

// Otherwise people can pipe Writable streams, which is just wrong.
Writable.prototype.pipe = function () {
  this.emit('error', new Error('Cannot pipe, not readable'));
};

function writeAfterEnd(stream, cb) {
  var er = new Error('write after end');
  // TODO: defer error events consistently everywhere, not just the cb
  stream.emit('error', er);
  pna.nextTick(cb, er);
}

// Checks that a user-supplied chunk is valid, especially for the particular
// mode the stream is in. Currently this means that `null` is never accepted
// and undefined/non-string values are only allowed in object mode.
function validChunk(stream, state, chunk, cb) {
  var valid = true;
  var er = false;

  if (chunk === null) {
    er = new TypeError('May not write null values to stream');
  } else if (typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  if (er) {
    stream.emit('error', er);
    pna.nextTick(cb, er);
    valid = false;
  }
  return valid;
}

Writable.prototype.write = function (chunk, encoding, cb) {
  var state = this._writableState;
  var ret = false;
  var isBuf = !state.objectMode && _isUint8Array(chunk);

  if (isBuf && !Buffer.isBuffer(chunk)) {
    chunk = _uint8ArrayToBuffer(chunk);
  }

  if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;

  if (typeof cb !== 'function') cb = nop;

  if (state.ended) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {
    state.pendingcb++;
    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
  }

  return ret;
};

Writable.prototype.cork = function () {
  var state = this._writableState;

  state.corked++;
};

Writable.prototype.uncork = function () {
  var state = this._writableState;

  if (state.corked) {
    state.corked--;

    if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
  }
};

Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
  // node::ParseEncoding() requires lower case.
  if (typeof encoding === 'string') encoding = encoding.toLowerCase();
  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new TypeError('Unknown encoding: ' + encoding);
  this._writableState.defaultEncoding = encoding;
  return this;
};

function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
    chunk = Buffer.from(chunk, encoding);
  }
  return chunk;
}

Object.defineProperty(Writable.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function () {
    return this._writableState.highWaterMark;
  }
});

// if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.
function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
  if (!isBuf) {
    var newChunk = decodeChunk(state, chunk, encoding);
    if (chunk !== newChunk) {
      isBuf = true;
      encoding = 'buffer';
      chunk = newChunk;
    }
  }
  var len = state.objectMode ? 1 : chunk.length;

  state.length += len;

  var ret = state.length < state.highWaterMark;
  // we must ensure that previous needDrain will not be reset to false.
  if (!ret) state.needDrain = true;

  if (state.writing || state.corked) {
    var last = state.lastBufferedRequest;
    state.lastBufferedRequest = {
      chunk: chunk,
      encoding: encoding,
      isBuf: isBuf,
      callback: cb,
      next: null
    };
    if (last) {
      last.next = state.lastBufferedRequest;
    } else {
      state.bufferedRequest = state.lastBufferedRequest;
    }
    state.bufferedRequestCount += 1;
  } else {
    doWrite(stream, state, false, len, chunk, encoding, cb);
  }

  return ret;
}

function doWrite(stream, state, writev, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}

function onwriteError(stream, state, sync, er, cb) {
  --state.pendingcb;

  if (sync) {
    // defer the callback if we are being called synchronously
    // to avoid piling up things on the stack
    pna.nextTick(cb, er);
    // this can emit finish, and it will always happen
    // after error
    pna.nextTick(finishMaybe, stream, state);
    stream._writableState.errorEmitted = true;
    stream.emit('error', er);
  } else {
    // the caller expect this to happen before if
    // it is async
    cb(er);
    stream._writableState.errorEmitted = true;
    stream.emit('error', er);
    // this can emit finish, but finish must
    // always follow error
    finishMaybe(stream, state);
  }
}

function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}

function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;

  onwriteStateUpdate(state);

  if (er) onwriteError(stream, state, sync, er, cb);else {
    // Check if we're actually ready to finish, but don't emit yet
    var finished = needFinish(state);

    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
      clearBuffer(stream, state);
    }

    if (sync) {
      /*<replacement>*/
      asyncWrite(afterWrite, stream, state, finished, cb);
      /*</replacement>*/
    } else {
      afterWrite(stream, state, finished, cb);
    }
  }
}

function afterWrite(stream, state, finished, cb) {
  if (!finished) onwriteDrain(stream, state);
  state.pendingcb--;
  cb();
  finishMaybe(stream, state);
}

// Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.
function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit('drain');
  }
}

// if there's something in the buffer waiting, then process it
function clearBuffer(stream, state) {
  state.bufferProcessing = true;
  var entry = state.bufferedRequest;

  if (stream._writev && entry && entry.next) {
    // Fast case, write everything using _writev()
    var l = state.bufferedRequestCount;
    var buffer = new Array(l);
    var holder = state.corkedRequestsFree;
    holder.entry = entry;

    var count = 0;
    var allBuffers = true;
    while (entry) {
      buffer[count] = entry;
      if (!entry.isBuf) allBuffers = false;
      entry = entry.next;
      count += 1;
    }
    buffer.allBuffers = allBuffers;

    doWrite(stream, state, true, state.length, buffer, '', holder.finish);

    // doWrite is almost always async, defer these to save a bit of time
    // as the hot path ends with doWrite
    state.pendingcb++;
    state.lastBufferedRequest = null;
    if (holder.next) {
      state.corkedRequestsFree = holder.next;
      holder.next = null;
    } else {
      state.corkedRequestsFree = new CorkedRequest(state);
    }
    state.bufferedRequestCount = 0;
  } else {
    // Slow case, write chunks one-by-one
    while (entry) {
      var chunk = entry.chunk;
      var encoding = entry.encoding;
      var cb = entry.callback;
      var len = state.objectMode ? 1 : chunk.length;

      doWrite(stream, state, false, len, chunk, encoding, cb);
      entry = entry.next;
      state.bufferedRequestCount--;
      // if we didn't call the onwrite immediately, then
      // it means that we need to wait until it does.
      // also, that means that the chunk and cb are currently
      // being processed, so move the buffer counter past them.
      if (state.writing) {
        break;
      }
    }

    if (entry === null) state.lastBufferedRequest = null;
  }

  state.bufferedRequest = entry;
  state.bufferProcessing = false;
}

Writable.prototype._write = function (chunk, encoding, cb) {
  cb(new Error('_write() is not implemented'));
};

Writable.prototype._writev = null;

Writable.prototype.end = function (chunk, encoding, cb) {
  var state = this._writableState;

  if (typeof chunk === 'function') {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);

  // .end() fully uncorks
  if (state.corked) {
    state.corked = 1;
    this.uncork();
  }

  // ignore unnecessary end() calls.
  if (!state.ending) endWritable(this, state, cb);
};

function needFinish(state) {
  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
}
function callFinal(stream, state) {
  stream._final(function (err) {
    state.pendingcb--;
    if (err) {
      stream.emit('error', err);
    }
    state.prefinished = true;
    stream.emit('prefinish');
    finishMaybe(stream, state);
  });
}
function prefinish(stream, state) {
  if (!state.prefinished && !state.finalCalled) {
    if (typeof stream._final === 'function') {
      state.pendingcb++;
      state.finalCalled = true;
      pna.nextTick(callFinal, stream, state);
    } else {
      state.prefinished = true;
      stream.emit('prefinish');
    }
  }
}

function finishMaybe(stream, state) {
  var need = needFinish(state);
  if (need) {
    prefinish(stream, state);
    if (state.pendingcb === 0) {
      state.finished = true;
      stream.emit('finish');
    }
  }
  return need;
}

function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);
  if (cb) {
    if (state.finished) pna.nextTick(cb);else stream.once('finish', cb);
  }
  state.ended = true;
  stream.writable = false;
}

function onCorkedFinish(corkReq, state, err) {
  var entry = corkReq.entry;
  corkReq.entry = null;
  while (entry) {
    var cb = entry.callback;
    state.pendingcb--;
    cb(err);
    entry = entry.next;
  }

  // reuse the free corkReq.
  state.corkedRequestsFree.next = corkReq;
}

Object.defineProperty(Writable.prototype, 'destroyed', {
  get: function () {
    if (this._writableState === undefined) {
      return false;
    }
    return this._writableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._writableState) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._writableState.destroyed = value;
  }
});

Writable.prototype.destroy = destroyImpl.destroy;
Writable.prototype._undestroy = destroyImpl.undestroy;
Writable.prototype._destroy = function (err, cb) {
  this.end();
  cb(err);
};

/***/ }),

/***/ 80312:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Buffer = (__nccwpck_require__(13447).Buffer);
var util = __nccwpck_require__(39023);

function copyBuffer(src, target, offset) {
  src.copy(target, offset);
}

module.exports = function () {
  function BufferList() {
    _classCallCheck(this, BufferList);

    this.head = null;
    this.tail = null;
    this.length = 0;
  }

  BufferList.prototype.push = function push(v) {
    var entry = { data: v, next: null };
    if (this.length > 0) this.tail.next = entry;else this.head = entry;
    this.tail = entry;
    ++this.length;
  };

  BufferList.prototype.unshift = function unshift(v) {
    var entry = { data: v, next: this.head };
    if (this.length === 0) this.tail = entry;
    this.head = entry;
    ++this.length;
  };

  BufferList.prototype.shift = function shift() {
    if (this.length === 0) return;
    var ret = this.head.data;
    if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;
    --this.length;
    return ret;
  };

  BufferList.prototype.clear = function clear() {
    this.head = this.tail = null;
    this.length = 0;
  };

  BufferList.prototype.join = function join(s) {
    if (this.length === 0) return '';
    var p = this.head;
    var ret = '' + p.data;
    while (p = p.next) {
      ret += s + p.data;
    }return ret;
  };

  BufferList.prototype.concat = function concat(n) {
    if (this.length === 0) return Buffer.alloc(0);
    var ret = Buffer.allocUnsafe(n >>> 0);
    var p = this.head;
    var i = 0;
    while (p) {
      copyBuffer(p.data, ret, i);
      i += p.data.length;
      p = p.next;
    }
    return ret;
  };

  return BufferList;
}();

if (util && util.inspect && util.inspect.custom) {
  module.exports.prototype[util.inspect.custom] = function () {
    var obj = util.inspect({ length: this.length });
    return this.constructor.name + ' ' + obj;
  };
}

/***/ }),

/***/ 47998:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


/*<replacement>*/

var pna = __nccwpck_require__(41564);
/*</replacement>*/

// undocumented cb() API, needed for core, not for public API
function destroy(err, cb) {
  var _this = this;

  var readableDestroyed = this._readableState && this._readableState.destroyed;
  var writableDestroyed = this._writableState && this._writableState.destroyed;

  if (readableDestroyed || writableDestroyed) {
    if (cb) {
      cb(err);
    } else if (err) {
      if (!this._writableState) {
        pna.nextTick(emitErrorNT, this, err);
      } else if (!this._writableState.errorEmitted) {
        this._writableState.errorEmitted = true;
        pna.nextTick(emitErrorNT, this, err);
      }
    }

    return this;
  }

  // we set destroyed to true before firing error callbacks in order
  // to make it re-entrance safe in case destroy() is called within callbacks

  if (this._readableState) {
    this._readableState.destroyed = true;
  }

  // if this is a duplex stream mark the writable part as destroyed as well
  if (this._writableState) {
    this._writableState.destroyed = true;
  }

  this._destroy(err || null, function (err) {
    if (!cb && err) {
      if (!_this._writableState) {
        pna.nextTick(emitErrorNT, _this, err);
      } else if (!_this._writableState.errorEmitted) {
        _this._writableState.errorEmitted = true;
        pna.nextTick(emitErrorNT, _this, err);
      }
    } else if (cb) {
      cb(err);
    }
  });

  return this;
}

function undestroy() {
  if (this._readableState) {
    this._readableState.destroyed = false;
    this._readableState.reading = false;
    this._readableState.ended = false;
    this._readableState.endEmitted = false;
  }

  if (this._writableState) {
    this._writableState.destroyed = false;
    this._writableState.ended = false;
    this._writableState.ending = false;
    this._writableState.finalCalled = false;
    this._writableState.prefinished = false;
    this._writableState.finished = false;
    this._writableState.errorEmitted = false;
  }
}

function emitErrorNT(self, err) {
  self.emit('error', err);
}

module.exports = {
  destroy: destroy,
  undestroy: undestroy
};

/***/ }),

/***/ 430:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

module.exports = __nccwpck_require__(2203);


/***/ }),

/***/ 760:
/***/ ((module, exports, __nccwpck_require__) => {

var Stream = __nccwpck_require__(2203);
if (process.env.READABLE_STREAM === 'disable' && Stream) {
  module.exports = Stream;
  exports = module.exports = Stream.Readable;
  exports.Readable = Stream.Readable;
  exports.Writable = Stream.Writable;
  exports.Duplex = Stream.Duplex;
  exports.Transform = Stream.Transform;
  exports.PassThrough = Stream.PassThrough;
  exports.Stream = Stream;
} else {
  exports = module.exports = __nccwpck_require__(73622);
  exports.Stream = Stream || exports;
  exports.Readable = exports;
  exports.Writable = __nccwpck_require__(83866);
  exports.Duplex = __nccwpck_require__(97424);
  exports.Transform = __nccwpck_require__(71424);
  exports.PassThrough = __nccwpck_require__(7890);
}


/***/ }),

/***/ 13447:
/***/ ((module, exports, __nccwpck_require__) => {

/* eslint-disable node/no-deprecated-api */
var buffer = __nccwpck_require__(20181)
var Buffer = buffer.Buffer

// alternative to using Object.keys for old browsers
function copyProps (src, dst) {
  for (var key in src) {
    dst[key] = src[key]
  }
}
if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
  module.exports = buffer
} else {
  // Copy properties from require('buffer')
  copyProps(buffer, exports)
  exports.Buffer = SafeBuffer
}

function SafeBuffer (arg, encodingOrOffset, length) {
  return Buffer(arg, encodingOrOffset, length)
}

// Copy static methods from Buffer
copyProps(Buffer, SafeBuffer)

SafeBuffer.from = function (arg, encodingOrOffset, length) {
  if (typeof arg === 'number') {
    throw new TypeError('Argument must not be a number')
  }
  return Buffer(arg, encodingOrOffset, length)
}

SafeBuffer.alloc = function (size, fill, encoding) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  var buf = Buffer(size)
  if (fill !== undefined) {
    if (typeof encoding === 'string') {
      buf.fill(fill, encoding)
    } else {
      buf.fill(fill)
    }
  } else {
    buf.fill(0)
  }
  return buf
}

SafeBuffer.allocUnsafe = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return Buffer(size)
}

SafeBuffer.allocUnsafeSlow = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return buffer.SlowBuffer(size)
}


/***/ }),

/***/ 46771:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



/*<replacement>*/

var Buffer = (__nccwpck_require__(13447).Buffer);
/*</replacement>*/

var isEncoding = Buffer.isEncoding || function (encoding) {
  encoding = '' + encoding;
  switch (encoding && encoding.toLowerCase()) {
    case 'hex':case 'utf8':case 'utf-8':case 'ascii':case 'binary':case 'base64':case 'ucs2':case 'ucs-2':case 'utf16le':case 'utf-16le':case 'raw':
      return true;
    default:
      return false;
  }
};

function _normalizeEncoding(enc) {
  if (!enc) return 'utf8';
  var retried;
  while (true) {
    switch (enc) {
      case 'utf8':
      case 'utf-8':
        return 'utf8';
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return 'utf16le';
      case 'latin1':
      case 'binary':
        return 'latin1';
      case 'base64':
      case 'ascii':
      case 'hex':
        return enc;
      default:
        if (retried) return; // undefined
        enc = ('' + enc).toLowerCase();
        retried = true;
    }
  }
};

// Do not cache `Buffer.isEncoding` when checking encoding names as some
// modules monkey-patch it to support additional encodings
function normalizeEncoding(enc) {
  var nenc = _normalizeEncoding(enc);
  if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);
  return nenc || enc;
}

// StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters.
exports.I = StringDecoder;
function StringDecoder(encoding) {
  this.encoding = normalizeEncoding(encoding);
  var nb;
  switch (this.encoding) {
    case 'utf16le':
      this.text = utf16Text;
      this.end = utf16End;
      nb = 4;
      break;
    case 'utf8':
      this.fillLast = utf8FillLast;
      nb = 4;
      break;
    case 'base64':
      this.text = base64Text;
      this.end = base64End;
      nb = 3;
      break;
    default:
      this.write = simpleWrite;
      this.end = simpleEnd;
      return;
  }
  this.lastNeed = 0;
  this.lastTotal = 0;
  this.lastChar = Buffer.allocUnsafe(nb);
}

StringDecoder.prototype.write = function (buf) {
  if (buf.length === 0) return '';
  var r;
  var i;
  if (this.lastNeed) {
    r = this.fillLast(buf);
    if (r === undefined) return '';
    i = this.lastNeed;
    this.lastNeed = 0;
  } else {
    i = 0;
  }
  if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
  return r || '';
};

StringDecoder.prototype.end = utf8End;

// Returns only complete characters in a Buffer
StringDecoder.prototype.text = utf8Text;

// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer
StringDecoder.prototype.fillLast = function (buf) {
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
  this.lastNeed -= buf.length;
};

// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a
// continuation byte. If an invalid byte is detected, -2 is returned.
function utf8CheckByte(byte) {
  if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;
  return byte >> 6 === 0x02 ? -1 : -2;
}

// Checks at most 3 bytes at the end of a Buffer in order to detect an
// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)
// needed to complete the UTF-8 character (if applicable) are returned.
function utf8CheckIncomplete(self, buf, i) {
  var j = buf.length - 1;
  if (j < i) return 0;
  var nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 1;
    return nb;
  }
  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 2;
    return nb;
  }
  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) {
      if (nb === 2) nb = 0;else self.lastNeed = nb - 3;
    }
    return nb;
  }
  return 0;
}

// Validates as many continuation bytes for a multi-byte UTF-8 character as
// needed or are available. If we see a non-continuation byte where we expect
// one, we "replace" the validated continuation bytes we've seen so far with
// a single UTF-8 replacement character ('\ufffd'), to match v8's UTF-8 decoding
// behavior. The continuation byte check is included three times in the case
// where all of the continuation bytes for a character exist in the same buffer.
// It is also done this way as a slight performance increase instead of using a
// loop.
function utf8CheckExtraBytes(self, buf, p) {
  if ((buf[0] & 0xC0) !== 0x80) {
    self.lastNeed = 0;
    return '\ufffd';
  }
  if (self.lastNeed > 1 && buf.length > 1) {
    if ((buf[1] & 0xC0) !== 0x80) {
      self.lastNeed = 1;
      return '\ufffd';
    }
    if (self.lastNeed > 2 && buf.length > 2) {
      if ((buf[2] & 0xC0) !== 0x80) {
        self.lastNeed = 2;
        return '\ufffd';
      }
    }
  }
}

// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.
function utf8FillLast(buf) {
  var p = this.lastTotal - this.lastNeed;
  var r = utf8CheckExtraBytes(this, buf, p);
  if (r !== undefined) return r;
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, p, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, p, 0, buf.length);
  this.lastNeed -= buf.length;
}

// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a
// partial character, the character's bytes are buffered until the required
// number of bytes are available.
function utf8Text(buf, i) {
  var total = utf8CheckIncomplete(this, buf, i);
  if (!this.lastNeed) return buf.toString('utf8', i);
  this.lastTotal = total;
  var end = buf.length - (total - this.lastNeed);
  buf.copy(this.lastChar, 0, end);
  return buf.toString('utf8', i, end);
}

// For UTF-8, a replacement character is added when ending on a partial
// character.
function utf8End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + '\ufffd';
  return r;
}

// UTF-16LE typically needs two bytes per character, but even if we have an even
// number of bytes available, we need to check if we end on a leading/high
// surrogate. In that case, we need to wait for the next two bytes in order to
// decode the last character properly.
function utf16Text(buf, i) {
  if ((buf.length - i) % 2 === 0) {
    var r = buf.toString('utf16le', i);
    if (r) {
      var c = r.charCodeAt(r.length - 1);
      if (c >= 0xD800 && c <= 0xDBFF) {
        this.lastNeed = 2;
        this.lastTotal = 4;
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
        return r.slice(0, -1);
      }
    }
    return r;
  }
  this.lastNeed = 1;
  this.lastTotal = 2;
  this.lastChar[0] = buf[buf.length - 1];
  return buf.toString('utf16le', i, buf.length - 1);
}

// For UTF-16LE we do not explicitly append special replacement characters if we
// end on a partial character, we simply let v8 handle that.
function utf16End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) {
    var end = this.lastTotal - this.lastNeed;
    return r + this.lastChar.toString('utf16le', 0, end);
  }
  return r;
}

function base64Text(buf, i) {
  var n = (buf.length - i) % 3;
  if (n === 0) return buf.toString('base64', i);
  this.lastNeed = 3 - n;
  this.lastTotal = 3;
  if (n === 1) {
    this.lastChar[0] = buf[buf.length - 1];
  } else {
    this.lastChar[0] = buf[buf.length - 2];
    this.lastChar[1] = buf[buf.length - 1];
  }
  return buf.toString('base64', i, buf.length - n);
}

function base64End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);
  return r;
}

// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)
function simpleWrite(buf) {
  return buf.toString(this.encoding);
}

function simpleEnd(buf) {
  return buf && buf.length ? this.write(buf) : '';
}

/***/ }),

/***/ 18111:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";
/*!
 * content-disposition
 * Copyright(c) 2014-2017 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module exports.
 * @public
 */

module.exports = contentDisposition
module.exports.parse = parse

/**
 * Module dependencies.
 * @private
 */

var basename = (__nccwpck_require__(16928).basename)
var Buffer = (__nccwpck_require__(93058).Buffer)

/**
 * RegExp to match non attr-char, *after* encodeURIComponent (i.e. not including "%")
 * @private
 */

var ENCODE_URL_ATTR_CHAR_REGEXP = /[\x00-\x20"'()*,/:;<=>?@[\\\]{}\x7f]/g // eslint-disable-line no-control-regex

/**
 * RegExp to match percent encoding escape.
 * @private
 */

var HEX_ESCAPE_REGEXP = /%[0-9A-Fa-f]{2}/
var HEX_ESCAPE_REPLACE_REGEXP = /%([0-9A-Fa-f]{2})/g

/**
 * RegExp to match non-latin1 characters.
 * @private
 */

var NON_LATIN1_REGEXP = /[^\x20-\x7e\xa0-\xff]/g

/**
 * RegExp to match quoted-pair in RFC 2616
 *
 * quoted-pair = "\" CHAR
 * CHAR        = <any US-ASCII character (octets 0 - 127)>
 * @private
 */

var QESC_REGEXP = /\\([\u0000-\u007f])/g // eslint-disable-line no-control-regex

/**
 * RegExp to match chars that must be quoted-pair in RFC 2616
 * @private
 */

var QUOTE_REGEXP = /([\\"])/g

/**
 * RegExp for various RFC 2616 grammar
 *
 * parameter     = token "=" ( token | quoted-string )
 * token         = 1*<any CHAR except CTLs or separators>
 * separators    = "(" | ")" | "<" | ">" | "@"
 *               | "," | ";" | ":" | "\" | <">
 *               | "/" | "[" | "]" | "?" | "="
 *               | "{" | "}" | SP | HT
 * quoted-string = ( <"> *(qdtext | quoted-pair ) <"> )
 * qdtext        = <any TEXT except <">>
 * quoted-pair   = "\" CHAR
 * CHAR          = <any US-ASCII character (octets 0 - 127)>
 * TEXT          = <any OCTET except CTLs, but including LWS>
 * LWS           = [CRLF] 1*( SP | HT )
 * CRLF          = CR LF
 * CR            = <US-ASCII CR, carriage return (13)>
 * LF            = <US-ASCII LF, linefeed (10)>
 * SP            = <US-ASCII SP, space (32)>
 * HT            = <US-ASCII HT, horizontal-tab (9)>
 * CTL           = <any US-ASCII control character (octets 0 - 31) and DEL (127)>
 * OCTET         = <any 8-bit sequence of data>
 * @private
 */

var PARAM_REGEXP = /;[\x09\x20]*([!#$%&'*+.0-9A-Z^_`a-z|~-]+)[\x09\x20]*=[\x09\x20]*("(?:[\x20!\x23-\x5b\x5d-\x7e\x80-\xff]|\\[\x20-\x7e])*"|[!#$%&'*+.0-9A-Z^_`a-z|~-]+)[\x09\x20]*/g // eslint-disable-line no-control-regex
var TEXT_REGEXP = /^[\x20-\x7e\x80-\xff]+$/
var TOKEN_REGEXP = /^[!#$%&'*+.0-9A-Z^_`a-z|~-]+$/

/**
 * RegExp for various RFC 5987 grammar
 *
 * ext-value     = charset  "'" [ language ] "'" value-chars
 * charset       = "UTF-8" / "ISO-8859-1" / mime-charset
 * mime-charset  = 1*mime-charsetc
 * mime-charsetc = ALPHA / DIGIT
 *               / "!" / "#" / "$" / "%" / "&"
 *               / "+" / "-" / "^" / "_" / "`"
 *               / "{" / "}" / "~"
 * language      = ( 2*3ALPHA [ extlang ] )
 *               / 4ALPHA
 *               / 5*8ALPHA
 * extlang       = *3( "-" 3ALPHA )
 * value-chars   = *( pct-encoded / attr-char )
 * pct-encoded   = "%" HEXDIG HEXDIG
 * attr-char     = ALPHA / DIGIT
 *               / "!" / "#" / "$" / "&" / "+" / "-" / "."
 *               / "^" / "_" / "`" / "|" / "~"
 * @private
 */

var EXT_VALUE_REGEXP = /^([A-Za-z0-9!#$%&+\-^_`{}~]+)'(?:[A-Za-z]{2,3}(?:-[A-Za-z]{3}){0,3}|[A-Za-z]{4,8}|)'((?:%[0-9A-Fa-f]{2}|[A-Za-z0-9!#$&+.^_`|~-])+)$/

/**
 * RegExp for various RFC 6266 grammar
 *
 * disposition-type = "inline" | "attachment" | disp-ext-type
 * disp-ext-type    = token
 * disposition-parm = filename-parm | disp-ext-parm
 * filename-parm    = "filename" "=" value
 *                  | "filename*" "=" ext-value
 * disp-ext-parm    = token "=" value
 *                  | ext-token "=" ext-value
 * ext-token        = <the characters in token, followed by "*">
 * @private
 */

var DISPOSITION_TYPE_REGEXP = /^([!#$%&'*+.0-9A-Z^_`a-z|~-]+)[\x09\x20]*(?:$|;)/ // eslint-disable-line no-control-regex

/**
 * Create an attachment Content-Disposition header.
 *
 * @param {string} [filename]
 * @param {object} [options]
 * @param {string} [options.type=attachment]
 * @param {string|boolean} [options.fallback=true]
 * @return {string}
 * @public
 */

function contentDisposition (filename, options) {
  var opts = options || {}

  // get type
  var type = opts.type || 'attachment'

  // get parameters
  var params = createparams(filename, opts.fallback)

  // format into string
  return format(new ContentDisposition(type, params))
}

/**
 * Create parameters object from filename and fallback.
 *
 * @param {string} [filename]
 * @param {string|boolean} [fallback=true]
 * @return {object}
 * @private
 */

function createparams (filename, fallback) {
  if (filename === undefined) {
    return
  }

  var params = {}

  if (typeof filename !== 'string') {
    throw new TypeError('filename must be a string')
  }

  // fallback defaults to true
  if (fallback === undefined) {
    fallback = true
  }

  if (typeof fallback !== 'string' && typeof fallback !== 'boolean') {
    throw new TypeError('fallback must be a string or boolean')
  }

  if (typeof fallback === 'string' && NON_LATIN1_REGEXP.test(fallback)) {
    throw new TypeError('fallback must be ISO-8859-1 string')
  }

  // restrict to file base name
  var name = basename(filename)

  // determine if name is suitable for quoted string
  var isQuotedString = TEXT_REGEXP.test(name)

  // generate fallback name
  var fallbackName = typeof fallback !== 'string'
    ? fallback && getlatin1(name)
    : basename(fallback)
  var hasFallback = typeof fallbackName === 'string' && fallbackName !== name

  // set extended filename parameter
  if (hasFallback || !isQuotedString || HEX_ESCAPE_REGEXP.test(name)) {
    params['filename*'] = name
  }

  // set filename parameter
  if (isQuotedString || hasFallback) {
    params.filename = hasFallback
      ? fallbackName
      : name
  }

  return params
}

/**
 * Format object to Content-Disposition header.
 *
 * @param {object} obj
 * @param {string} obj.type
 * @param {object} [obj.parameters]
 * @return {string}
 * @private
 */

function format (obj) {
  var parameters = obj.parameters
  var type = obj.type

  if (!type || typeof type !== 'string' || !TOKEN_REGEXP.test(type)) {
    throw new TypeError('invalid type')
  }

  // start with normalized type
  var string = String(type).toLowerCase()

  // append parameters
  if (parameters && typeof parameters === 'object') {
    var param
    var params = Object.keys(parameters).sort()

    for (var i = 0; i < params.length; i++) {
      param = params[i]

      var val = param.substr(-1) === '*'
        ? ustring(parameters[param])
        : qstring(parameters[param])

      string += '; ' + param + '=' + val
    }
  }

  return string
}

/**
 * Decode a RFC 5987 field value (gracefully).
 *
 * @param {string} str
 * @return {string}
 * @private
 */

function decodefield (str) {
  var match = EXT_VALUE_REGEXP.exec(str)

  if (!match) {
    throw new TypeError('invalid extended field value')
  }

  var charset = match[1].toLowerCase()
  var encoded = match[2]
  var value

  // to binary string
  var binary = encoded.replace(HEX_ESCAPE_REPLACE_REGEXP, pdecode)

  switch (charset) {
    case 'iso-8859-1':
      value = getlatin1(binary)
      break
    case 'utf-8':
      value = Buffer.from(binary, 'binary').toString('utf8')
      break
    default:
      throw new TypeError('unsupported charset in extended field')
  }

  return value
}

/**
 * Get ISO-8859-1 version of string.
 *
 * @param {string} val
 * @return {string}
 * @private
 */

function getlatin1 (val) {
  // simple Unicode -> ISO-8859-1 transformation
  return String(val).replace(NON_LATIN1_REGEXP, '?')
}

/**
 * Parse Content-Disposition header string.
 *
 * @param {string} string
 * @return {object}
 * @public
 */

function parse (string) {
  if (!string || typeof string !== 'string') {
    throw new TypeError('argument string is required')
  }

  var match = DISPOSITION_TYPE_REGEXP.exec(string)

  if (!match) {
    throw new TypeError('invalid type format')
  }

  // normalize type
  var index = match[0].length
  var type = match[1].toLowerCase()

  var key
  var names = []
  var params = {}
  var value

  // calculate index to start at
  index = PARAM_REGEXP.lastIndex = match[0].substr(-1) === ';'
    ? index - 1
    : index

  // match parameters
  while ((match = PARAM_REGEXP.exec(string))) {
    if (match.index !== index) {
      throw new TypeError('invalid parameter format')
    }

    index += match[0].length
    key = match[1].toLowerCase()
    value = match[2]

    if (names.indexOf(key) !== -1) {
      throw new TypeError('invalid duplicate parameter')
    }

    names.push(key)

    if (key.indexOf('*') + 1 === key.length) {
      // decode extended value
      key = key.slice(0, -1)
      value = decodefield(value)

      // overwrite existing value
      params[key] = value
      continue
    }

    if (typeof params[key] === 'string') {
      continue
    }

    if (value[0] === '"') {
      // remove quotes and escapes
      value = value
        .substr(1, value.length - 2)
        .replace(QESC_REGEXP, '$1')
    }

    params[key] = value
  }

  if (index !== -1 && index !== string.length) {
    throw new TypeError('invalid parameter format')
  }

  return new ContentDisposition(type, params)
}

/**
 * Percent decode a single character.
 *
 * @param {string} str
 * @param {string} hex
 * @return {string}
 * @private
 */

function pdecode (str, hex) {
  return String.fromCharCode(parseInt(hex, 16))
}

/**
 * Percent encode a single character.
 *
 * @param {string} char
 * @return {string}
 * @private
 */

function pencode (char) {
  return '%' + String(char)
    .charCodeAt(0)
    .toString(16)
    .toUpperCase()
}

/**
 * Quote a string for HTTP.
 *
 * @param {string} val
 * @return {string}
 * @private
 */

function qstring (val) {
  var str = String(val)

  return '"' + str.replace(QUOTE_REGEXP, '\\$1') + '"'
}

/**
 * Encode a Unicode string for HTTP (RFC 5987).
 *
 * @param {string} val
 * @return {string}
 * @private
 */

function ustring (val) {
  var str = String(val)

  // percent encode as UTF-8
  var encoded = encodeURIComponent(str)
    .replace(ENCODE_URL_ATTR_CHAR_REGEXP, pencode)

  return 'UTF-8\'\'' + encoded
}

/**
 * Class for parsed Content-Disposition header for v8 optimization
 *
 * @public
 * @param {string} type
 * @param {object} parameters
 * @constructor
 */

function ContentDisposition (type, parameters) {
  this.type = type
  this.parameters = parameters
}


/***/ }),

/***/ 20756:
/***/ ((__unused_webpack_module, exports) => {

"use strict";
/*!
 * content-type
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * RegExp to match *( ";" parameter ) in RFC 7231 sec 3.1.1.1
 *
 * parameter     = token "=" ( token / quoted-string )
 * token         = 1*tchar
 * tchar         = "!" / "#" / "$" / "%" / "&" / "'" / "*"
 *               / "+" / "-" / "." / "^" / "_" / "`" / "|" / "~"
 *               / DIGIT / ALPHA
 *               ; any VCHAR, except delimiters
 * quoted-string = DQUOTE *( qdtext / quoted-pair ) DQUOTE
 * qdtext        = HTAB / SP / %x21 / %x23-5B / %x5D-7E / obs-text
 * obs-text      = %x80-FF
 * quoted-pair   = "\" ( HTAB / SP / VCHAR / obs-text )
 */
var PARAM_REGEXP = /; *([!#$%&'*+.^_`|~0-9A-Za-z-]+) *= *("(?:[\u000b\u0020\u0021\u0023-\u005b\u005d-\u007e\u0080-\u00ff]|\\[\u000b\u0020-\u00ff])*"|[!#$%&'*+.^_`|~0-9A-Za-z-]+) */g // eslint-disable-line no-control-regex
var TEXT_REGEXP = /^[\u000b\u0020-\u007e\u0080-\u00ff]+$/ // eslint-disable-line no-control-regex
var TOKEN_REGEXP = /^[!#$%&'*+.^_`|~0-9A-Za-z-]+$/

/**
 * RegExp to match quoted-pair in RFC 7230 sec 3.2.6
 *
 * quoted-pair = "\" ( HTAB / SP / VCHAR / obs-text )
 * obs-text    = %x80-FF
 */
var QESC_REGEXP = /\\([\u000b\u0020-\u00ff])/g // eslint-disable-line no-control-regex

/**
 * RegExp to match chars that must be quoted-pair in RFC 7230 sec 3.2.6
 */
var QUOTE_REGEXP = /([\\"])/g

/**
 * RegExp to match type in RFC 7231 sec 3.1.1.1
 *
 * media-type = type "/" subtype
 * type       = token
 * subtype    = token
 */
var TYPE_REGEXP = /^[!#$%&'*+.^_`|~0-9A-Za-z-]+\/[!#$%&'*+.^_`|~0-9A-Za-z-]+$/

/**
 * Module exports.
 * @public
 */

exports.format = format
exports.parse = parse

/**
 * Format object to media type.
 *
 * @param {object} obj
 * @return {string}
 * @public
 */

function format (obj) {
  if (!obj || typeof obj !== 'object') {
    throw new TypeError('argument obj is required')
  }

  var parameters = obj.parameters
  var type = obj.type

  if (!type || !TYPE_REGEXP.test(type)) {
    throw new TypeError('invalid type')
  }

  var string = type

  // append parameters
  if (parameters && typeof parameters === 'object') {
    var param
    var params = Object.keys(parameters).sort()

    for (var i = 0; i < params.length; i++) {
      param = params[i]

      if (!TOKEN_REGEXP.test(param)) {
        throw new TypeError('invalid parameter name')
      }

      string += '; ' + param + '=' + qstring(parameters[param])
    }
  }

  return string
}

/**
 * Parse media type to object.
 *
 * @param {string|object} string
 * @return {Object}
 * @public
 */

function parse (string) {
  if (!string) {
    throw new TypeError('argument string is required')
  }

  // support req/res-like objects as argument
  var header = typeof string === 'object'
    ? getcontenttype(string)
    : string

  if (typeof header !== 'string') {
    throw new TypeError('argument string is required to be a string')
  }

  var index = header.indexOf(';')
  var type = index !== -1
    ? header.slice(0, index).trim()
    : header.trim()

  if (!TYPE_REGEXP.test(type)) {
    throw new TypeError('invalid media type')
  }

  var obj = new ContentType(type.toLowerCase())

  // parse parameters
  if (index !== -1) {
    var key
    var match
    var value

    PARAM_REGEXP.lastIndex = index

    while ((match = PARAM_REGEXP.exec(header))) {
      if (match.index !== index) {
        throw new TypeError('invalid parameter format')
      }

      index += match[0].length
      key = match[1].toLowerCase()
      value = match[2]

      if (value.charCodeAt(0) === 0x22 /* " */) {
        // remove quotes
        value = value.slice(1, -1)

        // remove escapes
        if (value.indexOf('\\') !== -1) {
          value = value.replace(QESC_REGEXP, '$1')
        }
      }

      obj.parameters[key] = value
    }

    if (index !== header.length) {
      throw new TypeError('invalid parameter format')
    }
  }

  return obj
}

/**
 * Get content-type from req/res objects.
 *
 * @param {object}
 * @return {Object}
 * @private
 */

function getcontenttype (obj) {
  var header

  if (typeof obj.getHeader === 'function') {
    // res-like
    header = obj.getHeader('content-type')
  } else if (typeof obj.headers === 'object') {
    // req-like
    header = obj.headers && obj.headers['content-type']
  }

  if (typeof header !== 'string') {
    throw new TypeError('content-type header is missing from object')
  }

  return header
}

/**
 * Quote a string if necessary.
 *
 * @param {string} val
 * @return {string}
 * @private
 */

function qstring (val) {
  var str = String(val)

  // no need to quote tokens
  if (TOKEN_REGEXP.test(str)) {
    return str
  }

  if (str.length > 0 && !TEXT_REGEXP.test(str)) {
    throw new TypeError('invalid parameter value')
  }

  return '"' + str.replace(QUOTE_REGEXP, '\\$1') + '"'
}

/**
 * Class to represent a content type.
 * @private
 */
function ContentType (type) {
  this.parameters = Object.create(null)
  this.type = type
}


/***/ }),

/***/ 34349:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

/**
 * Module dependencies.
 */

var crypto = __nccwpck_require__(76982);

/**
 * Sign the given `val` with `secret`.
 *
 * @param {String} val
 * @param {String} secret
 * @return {String}
 * @api private
 */

exports.sign = function(val, secret){
  if ('string' != typeof val) throw new TypeError("Cookie value must be provided as a string.");
  if ('string' != typeof secret) throw new TypeError("Secret string must be provided.");
  return val + '.' + crypto
    .createHmac('sha256', secret)
    .update(val)
    .digest('base64')
    .replace(/\=+$/, '');
};

/**
 * Unsign and decode the given `val` with `secret`,
 * returning `false` if the signature is invalid.
 *
 * @param {String} val
 * @param {String} secret
 * @return {String|Boolean}
 * @api private
 */

exports.unsign = function(val, secret){
  if ('string' != typeof val) throw new TypeError("Signed cookie string must be provided.");
  if ('string' != typeof secret) throw new TypeError("Secret string must be provided.");
  var str = val.slice(0, val.lastIndexOf('.'))
    , mac = exports.sign(str, secret);
  
  return sha1(mac) == sha1(val) ? str : false;
};

/**
 * Private
 */

function sha1(str){
  return crypto.createHash('sha1').update(str).digest('hex');
}


/***/ }),

/***/ 3814:
/***/ ((__unused_webpack_module, exports) => {

"use strict";
/*!
 * cookie
 * Copyright(c) 2012-2014 Roman Shtylman
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module exports.
 * @public
 */

exports.parse = parse;
exports.serialize = serialize;

/**
 * Module variables.
 * @private
 */

var __toString = Object.prototype.toString

/**
 * RegExp to match cookie-name in RFC 6265 sec 4.1.1
 * This refers out to the obsoleted definition of token in RFC 2616 sec 2.2
 * which has been replaced by the token definition in RFC 7230 appendix B.
 *
 * cookie-name       = token
 * token             = 1*tchar
 * tchar             = "!" / "#" / "$" / "%" / "&" / "'" /
 *                     "*" / "+" / "-" / "." / "^" / "_" /
 *                     "`" / "|" / "~" / DIGIT / ALPHA
 */

var cookieNameRegExp = /^[!#$%&'*+\-.^_`|~0-9A-Za-z]+$/;

/**
 * RegExp to match cookie-value in RFC 6265 sec 4.1.1
 *
 * cookie-value      = *cookie-octet / ( DQUOTE *cookie-octet DQUOTE )
 * cookie-octet      = %x21 / %x23-2B / %x2D-3A / %x3C-5B / %x5D-7E
 *                     ; US-ASCII characters excluding CTLs,
 *                     ; whitespace DQUOTE, comma, semicolon,
 *                     ; and backslash
 */

var cookieValueRegExp = /^("?)[\u0021\u0023-\u002B\u002D-\u003A\u003C-\u005B\u005D-\u007E]*\1$/;

/**
 * RegExp to match domain-value in RFC 6265 sec 4.1.1
 *
 * domain-value      = <subdomain>
 *                     ; defined in [RFC1034], Section 3.5, as
 *                     ; enhanced by [RFC1123], Section 2.1
 * <subdomain>       = <label> | <subdomain> "." <label>
 * <label>           = <let-dig> [ [ <ldh-str> ] <let-dig> ]
 *                     Labels must be 63 characters or less.
 *                     'let-dig' not 'letter' in the first char, per RFC1123
 * <ldh-str>         = <let-dig-hyp> | <let-dig-hyp> <ldh-str>
 * <let-dig-hyp>     = <let-dig> | "-"
 * <let-dig>         = <letter> | <digit>
 * <letter>          = any one of the 52 alphabetic characters A through Z in
 *                     upper case and a through z in lower case
 * <digit>           = any one of the ten digits 0 through 9
 *
 * Keep support for leading dot: https://github.com/jshttp/cookie/issues/173
 *
 * > (Note that a leading %x2E ("."), if present, is ignored even though that
 * character is not permitted, but a trailing %x2E ("."), if present, will
 * cause the user agent to ignore the attribute.)
 */

var domainValueRegExp = /^([.]?[a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)([.][a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)*$/i;

/**
 * RegExp to match path-value in RFC 6265 sec 4.1.1
 *
 * path-value        = <any CHAR except CTLs or ";">
 * CHAR              = %x01-7F
 *                     ; defined in RFC 5234 appendix B.1
 */

var pathValueRegExp = /^[\u0020-\u003A\u003D-\u007E]*$/;

/**
 * Parse a cookie header.
 *
 * Parse the given cookie header string into an object
 * The object has the various cookies as keys(names) => values
 *
 * @param {string} str
 * @param {object} [opt]
 * @return {object}
 * @public
 */

function parse(str, opt) {
  if (typeof str !== 'string') {
    throw new TypeError('argument str must be a string');
  }

  var obj = {};
  var len = str.length;
  // RFC 6265 sec 4.1.1, RFC 2616 2.2 defines a cookie name consists of one char minimum, plus '='.
  if (len < 2) return obj;

  var dec = (opt && opt.decode) || decode;
  var index = 0;
  var eqIdx = 0;
  var endIdx = 0;

  do {
    eqIdx = str.indexOf('=', index);
    if (eqIdx === -1) break; // No more cookie pairs.

    endIdx = str.indexOf(';', index);

    if (endIdx === -1) {
      endIdx = len;
    } else if (eqIdx > endIdx) {
      // backtrack on prior semicolon
      index = str.lastIndexOf(';', eqIdx - 1) + 1;
      continue;
    }

    var keyStartIdx = startIndex(str, index, eqIdx);
    var keyEndIdx = endIndex(str, eqIdx, keyStartIdx);
    var key = str.slice(keyStartIdx, keyEndIdx);

    // only assign once
    if (!obj.hasOwnProperty(key)) {
      var valStartIdx = startIndex(str, eqIdx + 1, endIdx);
      var valEndIdx = endIndex(str, endIdx, valStartIdx);

      if (str.charCodeAt(valStartIdx) === 0x22 /* " */ && str.charCodeAt(valEndIdx - 1) === 0x22 /* " */) {
        valStartIdx++;
        valEndIdx--;
      }

      var val = str.slice(valStartIdx, valEndIdx);
      obj[key] = tryDecode(val, dec);
    }

    index = endIdx + 1
  } while (index < len);

  return obj;
}

function startIndex(str, index, max) {
  do {
    var code = str.charCodeAt(index);
    if (code !== 0x20 /*   */ && code !== 0x09 /* \t */) return index;
  } while (++index < max);
  return max;
}

function endIndex(str, index, min) {
  while (index > min) {
    var code = str.charCodeAt(--index);
    if (code !== 0x20 /*   */ && code !== 0x09 /* \t */) return index + 1;
  }
  return min;
}

/**
 * Serialize data into a cookie header.
 *
 * Serialize a name value pair into a cookie string suitable for
 * http headers. An optional options object specifies cookie parameters.
 *
 * serialize('foo', 'bar', { httpOnly: true })
 *   => "foo=bar; httpOnly"
 *
 * @param {string} name
 * @param {string} val
 * @param {object} [opt]
 * @return {string}
 * @public
 */

function serialize(name, val, opt) {
  var enc = (opt && opt.encode) || encodeURIComponent;

  if (typeof enc !== 'function') {
    throw new TypeError('option encode is invalid');
  }

  if (!cookieNameRegExp.test(name)) {
    throw new TypeError('argument name is invalid');
  }

  var value = enc(val);

  if (!cookieValueRegExp.test(value)) {
    throw new TypeError('argument val is invalid');
  }

  var str = name + '=' + value;
  if (!opt) return str;

  if (null != opt.maxAge) {
    var maxAge = Math.floor(opt.maxAge);

    if (!isFinite(maxAge)) {
      throw new TypeError('option maxAge is invalid')
    }

    str += '; Max-Age=' + maxAge;
  }

  if (opt.domain) {
    if (!domainValueRegExp.test(opt.domain)) {
      throw new TypeError('option domain is invalid');
    }

    str += '; Domain=' + opt.domain;
  }

  if (opt.path) {
    if (!pathValueRegExp.test(opt.path)) {
      throw new TypeError('option path is invalid');
    }

    str += '; Path=' + opt.path;
  }

  if (opt.expires) {
    var expires = opt.expires

    if (!isDate(expires) || isNaN(expires.valueOf())) {
      throw new TypeError('option expires is invalid');
    }

    str += '; Expires=' + expires.toUTCString()
  }

  if (opt.httpOnly) {
    str += '; HttpOnly';
  }

  if (opt.secure) {
    str += '; Secure';
  }

  if (opt.partitioned) {
    str += '; Partitioned'
  }

  if (opt.priority) {
    var priority = typeof opt.priority === 'string'
      ? opt.priority.toLowerCase() : opt.priority;

    switch (priority) {
      case 'low':
        str += '; Priority=Low'
        break
      case 'medium':
        str += '; Priority=Medium'
        break
      case 'high':
        str += '; Priority=High'
        break
      default:
        throw new TypeError('option priority is invalid')
    }
  }

  if (opt.sameSite) {
    var sameSite = typeof opt.sameSite === 'string'
      ? opt.sameSite.toLowerCase() : opt.sameSite;

    switch (sameSite) {
      case true:
        str += '; SameSite=Strict';
        break;
      case 'lax':
        str += '; SameSite=Lax';
        break;
      case 'strict':
        str += '; SameSite=Strict';
        break;
      case 'none':
        str += '; SameSite=None';
        break;
      default:
        throw new TypeError('option sameSite is invalid');
    }
  }

  return str;
}

/**
 * URL-decode string value. Optimized to skip native call when no %.
 *
 * @param {string} str
 * @returns {string}
 */

function decode (str) {
  return str.indexOf('%') !== -1
    ? decodeURIComponent(str)
    : str
}

/**
 * Determine if value is a Date.
 *
 * @param {*} val
 * @private
 */

function isDate (val) {
  return __toString.call(val) === '[object Date]';
}

/**
 * Try decoding a string using a decoding function.
 *
 * @param {string} str
 * @param {function} decode
 * @private
 */

function tryDecode(str, decode) {
  try {
    return decode(str);
  } catch (e) {
    return str;
  }
}


/***/ }),

/***/ 45481:
/***/ ((__unused_webpack_module, exports) => {

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.

function isArray(arg) {
  if (Array.isArray) {
    return Array.isArray(arg);
  }
  return objectToString(arg) === '[object Array]';
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = Buffer.isBuffer;

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


/***/ }),

/***/ 24085:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

(function () {

  'use strict';

  var assign = __nccwpck_require__(56996);
  var vary = __nccwpck_require__(45116);

  var defaults = {
    origin: '*',
    methods: 'GET,HEAD,PUT,PATCH,POST,DELETE',
    preflightContinue: false,
    optionsSuccessStatus: 204
  };

  function isString(s) {
    return typeof s === 'string' || s instanceof String;
  }

  function isOriginAllowed(origin, allowedOrigin) {
    if (Array.isArray(allowedOrigin)) {
      for (var i = 0; i < allowedOrigin.length; ++i) {
        if (isOriginAllowed(origin, allowedOrigin[i])) {
          return true;
        }
      }
      return false;
    } else if (isString(allowedOrigin)) {
      return origin === allowedOrigin;
    } else if (allowedOrigin instanceof RegExp) {
      return allowedOrigin.test(origin);
    } else {
      return !!allowedOrigin;
    }
  }

  function configureOrigin(options, req) {
    var requestOrigin = req.headers.origin,
      headers = [],
      isAllowed;

    if (!options.origin || options.origin === '*') {
      // allow any origin
      headers.push([{
        key: 'Access-Control-Allow-Origin',
        value: '*'
      }]);
    } else if (isString(options.origin)) {
      // fixed origin
      headers.push([{
        key: 'Access-Control-Allow-Origin',
        value: options.origin
      }]);
      headers.push([{
        key: 'Vary',
        value: 'Origin'
      }]);
    } else {
      isAllowed = isOriginAllowed(requestOrigin, options.origin);
      // reflect origin
      headers.push([{
        key: 'Access-Control-Allow-Origin',
        value: isAllowed ? requestOrigin : false
      }]);
      headers.push([{
        key: 'Vary',
        value: 'Origin'
      }]);
    }

    return headers;
  }

  function configureMethods(options) {
    var methods = options.methods;
    if (methods.join) {
      methods = options.methods.join(','); // .methods is an array, so turn it into a string
    }
    return {
      key: 'Access-Control-Allow-Methods',
      value: methods
    };
  }

  function configureCredentials(options) {
    if (options.credentials === true) {
      return {
        key: 'Access-Control-Allow-Credentials',
        value: 'true'
      };
    }
    return null;
  }

  function configureAllowedHeaders(options, req) {
    var allowedHeaders = options.allowedHeaders || options.headers;
    var headers = [];

    if (!allowedHeaders) {
      allowedHeaders = req.headers['access-control-request-headers']; // .headers wasn't specified, so reflect the request headers
      headers.push([{
        key: 'Vary',
        value: 'Access-Control-Request-Headers'
      }]);
    } else if (allowedHeaders.join) {
      allowedHeaders = allowedHeaders.join(','); // .headers is an array, so turn it into a string
    }
    if (allowedHeaders && allowedHeaders.length) {
      headers.push([{
        key: 'Access-Control-Allow-Headers',
        value: allowedHeaders
      }]);
    }

    return headers;
  }

  function configureExposedHeaders(options) {
    var headers = options.exposedHeaders;
    if (!headers) {
      return null;
    } else if (headers.join) {
      headers = headers.join(','); // .headers is an array, so turn it into a string
    }
    if (headers && headers.length) {
      return {
        key: 'Access-Control-Expose-Headers',
        value: headers
      };
    }
    return null;
  }

  function configureMaxAge(options) {
    var maxAge = (typeof options.maxAge === 'number' || options.maxAge) && options.maxAge.toString()
    if (maxAge && maxAge.length) {
      return {
        key: 'Access-Control-Max-Age',
        value: maxAge
      };
    }
    return null;
  }

  function applyHeaders(headers, res) {
    for (var i = 0, n = headers.length; i < n; i++) {
      var header = headers[i];
      if (header) {
        if (Array.isArray(header)) {
          applyHeaders(header, res);
        } else if (header.key === 'Vary' && header.value) {
          vary(res, header.value);
        } else if (header.value) {
          res.setHeader(header.key, header.value);
        }
      }
    }
  }

  function cors(options, req, res, next) {
    var headers = [],
      method = req.method && req.method.toUpperCase && req.method.toUpperCase();

    if (method === 'OPTIONS') {
      // preflight
      headers.push(configureOrigin(options, req));
      headers.push(configureCredentials(options, req));
      headers.push(configureMethods(options, req));
      headers.push(configureAllowedHeaders(options, req));
      headers.push(configureMaxAge(options, req));
      headers.push(configureExposedHeaders(options, req));
      applyHeaders(headers, res);

      if (options.preflightContinue) {
        next();
      } else {
        // Safari (and potentially other browsers) need content-length 0,
        //   for 204 or they just hang waiting for a body
        res.statusCode = options.optionsSuccessStatus;
        res.setHeader('Content-Length', '0');
        res.end();
      }
    } else {
      // actual response
      headers.push(configureOrigin(options, req));
      headers.push(configureCredentials(options, req));
      headers.push(configureExposedHeaders(options, req));
      applyHeaders(headers, res);
      next();
    }
  }

  function middlewareWrapper(o) {
    // if options are static (either via defaults or custom options passed in), wrap in a function
    var optionsCallback = null;
    if (typeof o === 'function') {
      optionsCallback = o;
    } else {
      optionsCallback = function (req, cb) {
        cb(null, o);
      };
    }

    return function corsMiddleware(req, res, next) {
      optionsCallback(req, function (err, options) {
        if (err) {
          next(err);
        } else {
          var corsOptions = assign({}, defaults, options);
          var originCallback = null;
          if (corsOptions.origin && typeof corsOptions.origin === 'function') {
            originCallback = corsOptions.origin;
          } else if (corsOptions.origin) {
            originCallback = function (origin, cb) {
              cb(null, corsOptions.origin);
            };
          }

          if (originCallback) {
            originCallback(req.headers.origin, function (err2, origin) {
              if (err2 || !origin) {
                next(err2);
              } else {
                corsOptions.origin = origin;
                cors(corsOptions, req, res, next);
              }
            });
          } else {
            next();
          }
        }
      });
    };
  }

  // can pass either an options hash, an options delegate, or nothing
  module.exports = middlewareWrapper;

}());


/***/ }),

/***/ 19036:
/***/ ((module) => {

"use strict";


/**
 * Custom implementation of a double ended queue.
 */
function Denque(array, options) {
  var options = options || {};
  this._capacity = options.capacity;

  this._head = 0;
  this._tail = 0;

  if (Array.isArray(array)) {
    this._fromArray(array);
  } else {
    this._capacityMask = 0x3;
    this._list = new Array(4);
  }
}

/**
 * --------------
 *  PUBLIC API
 * -------------
 */

/**
 * Returns the item at the specified index from the list.
 * 0 is the first element, 1 is the second, and so on...
 * Elements at negative values are that many from the end: -1 is one before the end
 * (the last element), -2 is two before the end (one before last), etc.
 * @param index
 * @returns {*}
 */
Denque.prototype.peekAt = function peekAt(index) {
  var i = index;
  // expect a number or return undefined
  if ((i !== (i | 0))) {
    return void 0;
  }
  var len = this.size();
  if (i >= len || i < -len) return undefined;
  if (i < 0) i += len;
  i = (this._head + i) & this._capacityMask;
  return this._list[i];
};

/**
 * Alias for peekAt()
 * @param i
 * @returns {*}
 */
Denque.prototype.get = function get(i) {
  return this.peekAt(i);
};

/**
 * Returns the first item in the list without removing it.
 * @returns {*}
 */
Denque.prototype.peek = function peek() {
  if (this._head === this._tail) return undefined;
  return this._list[this._head];
};

/**
 * Alias for peek()
 * @returns {*}
 */
Denque.prototype.peekFront = function peekFront() {
  return this.peek();
};

/**
 * Returns the item that is at the back of the queue without removing it.
 * Uses peekAt(-1)
 */
Denque.prototype.peekBack = function peekBack() {
  return this.peekAt(-1);
};

/**
 * Returns the current length of the queue
 * @return {Number}
 */
Object.defineProperty(Denque.prototype, 'length', {
  get: function length() {
    return this.size();
  }
});

/**
 * Return the number of items on the list, or 0 if empty.
 * @returns {number}
 */
Denque.prototype.size = function size() {
  if (this._head === this._tail) return 0;
  if (this._head < this._tail) return this._tail - this._head;
  else return this._capacityMask + 1 - (this._head - this._tail);
};

/**
 * Add an item at the beginning of the list.
 * @param item
 */
Denque.prototype.unshift = function unshift(item) {
  if (arguments.length === 0) return this.size();
  var len = this._list.length;
  this._head = (this._head - 1 + len) & this._capacityMask;
  this._list[this._head] = item;
  if (this._tail === this._head) this._growArray();
  if (this._capacity && this.size() > this._capacity) this.pop();
  if (this._head < this._tail) return this._tail - this._head;
  else return this._capacityMask + 1 - (this._head - this._tail);
};

/**
 * Remove and return the first item on the list,
 * Returns undefined if the list is empty.
 * @returns {*}
 */
Denque.prototype.shift = function shift() {
  var head = this._head;
  if (head === this._tail) return undefined;
  var item = this._list[head];
  this._list[head] = undefined;
  this._head = (head + 1) & this._capacityMask;
  if (head < 2 && this._tail > 10000 && this._tail <= this._list.length >>> 2) this._shrinkArray();
  return item;
};

/**
 * Add an item to the bottom of the list.
 * @param item
 */
Denque.prototype.push = function push(item) {
  if (arguments.length === 0) return this.size();
  var tail = this._tail;
  this._list[tail] = item;
  this._tail = (tail + 1) & this._capacityMask;
  if (this._tail === this._head) {
    this._growArray();
  }
  if (this._capacity && this.size() > this._capacity) {
    this.shift();
  }
  if (this._head < this._tail) return this._tail - this._head;
  else return this._capacityMask + 1 - (this._head - this._tail);
};

/**
 * Remove and return the last item on the list.
 * Returns undefined if the list is empty.
 * @returns {*}
 */
Denque.prototype.pop = function pop() {
  var tail = this._tail;
  if (tail === this._head) return undefined;
  var len = this._list.length;
  this._tail = (tail - 1 + len) & this._capacityMask;
  var item = this._list[this._tail];
  this._list[this._tail] = undefined;
  if (this._head < 2 && tail > 10000 && tail <= len >>> 2) this._shrinkArray();
  return item;
};

/**
 * Remove and return the item at the specified index from the list.
 * Returns undefined if the list is empty.
 * @param index
 * @returns {*}
 */
Denque.prototype.removeOne = function removeOne(index) {
  var i = index;
  // expect a number or return undefined
  if ((i !== (i | 0))) {
    return void 0;
  }
  if (this._head === this._tail) return void 0;
  var size = this.size();
  var len = this._list.length;
  if (i >= size || i < -size) return void 0;
  if (i < 0) i += size;
  i = (this._head + i) & this._capacityMask;
  var item = this._list[i];
  var k;
  if (index < size / 2) {
    for (k = index; k > 0; k--) {
      this._list[i] = this._list[i = (i - 1 + len) & this._capacityMask];
    }
    this._list[i] = void 0;
    this._head = (this._head + 1 + len) & this._capacityMask;
  } else {
    for (k = size - 1 - index; k > 0; k--) {
      this._list[i] = this._list[i = (i + 1 + len) & this._capacityMask];
    }
    this._list[i] = void 0;
    this._tail = (this._tail - 1 + len) & this._capacityMask;
  }
  return item;
};

/**
 * Remove number of items from the specified index from the list.
 * Returns array of removed items.
 * Returns undefined if the list is empty.
 * @param index
 * @param count
 * @returns {array}
 */
Denque.prototype.remove = function remove(index, count) {
  var i = index;
  var removed;
  var del_count = count;
  // expect a number or return undefined
  if ((i !== (i | 0))) {
    return void 0;
  }
  if (this._head === this._tail) return void 0;
  var size = this.size();
  var len = this._list.length;
  if (i >= size || i < -size || count < 1) return void 0;
  if (i < 0) i += size;
  if (count === 1 || !count) {
    removed = new Array(1);
    removed[0] = this.removeOne(i);
    return removed;
  }
  if (i === 0 && i + count >= size) {
    removed = this.toArray();
    this.clear();
    return removed;
  }
  if (i + count > size) count = size - i;
  var k;
  removed = new Array(count);
  for (k = 0; k < count; k++) {
    removed[k] = this._list[(this._head + i + k) & this._capacityMask];
  }
  i = (this._head + i) & this._capacityMask;
  if (index + count === size) {
    this._tail = (this._tail - count + len) & this._capacityMask;
    for (k = count; k > 0; k--) {
      this._list[i = (i + 1 + len) & this._capacityMask] = void 0;
    }
    return removed;
  }
  if (index === 0) {
    this._head = (this._head + count + len) & this._capacityMask;
    for (k = count - 1; k > 0; k--) {
      this._list[i = (i + 1 + len) & this._capacityMask] = void 0;
    }
    return removed;
  }
  if (i < size / 2) {
    this._head = (this._head + index + count + len) & this._capacityMask;
    for (k = index; k > 0; k--) {
      this.unshift(this._list[i = (i - 1 + len) & this._capacityMask]);
    }
    i = (this._head - 1 + len) & this._capacityMask;
    while (del_count > 0) {
      this._list[i = (i - 1 + len) & this._capacityMask] = void 0;
      del_count--;
    }
    if (index < 0) this._tail = i;
  } else {
    this._tail = i;
    i = (i + count + len) & this._capacityMask;
    for (k = size - (count + index); k > 0; k--) {
      this.push(this._list[i++]);
    }
    i = this._tail;
    while (del_count > 0) {
      this._list[i = (i + 1 + len) & this._capacityMask] = void 0;
      del_count--;
    }
  }
  if (this._head < 2 && this._tail > 10000 && this._tail <= len >>> 2) this._shrinkArray();
  return removed;
};

/**
 * Native splice implementation.
 * Remove number of items from the specified index from the list and/or add new elements.
 * Returns array of removed items or empty array if count == 0.
 * Returns undefined if the list is empty.
 *
 * @param index
 * @param count
 * @param {...*} [elements]
 * @returns {array}
 */
Denque.prototype.splice = function splice(index, count) {
  var i = index;
  // expect a number or return undefined
  if ((i !== (i | 0))) {
    return void 0;
  }
  var size = this.size();
  if (i < 0) i += size;
  if (i > size) return void 0;
  if (arguments.length > 2) {
    var k;
    var temp;
    var removed;
    var arg_len = arguments.length;
    var len = this._list.length;
    var arguments_index = 2;
    if (!size || i < size / 2) {
      temp = new Array(i);
      for (k = 0; k < i; k++) {
        temp[k] = this._list[(this._head + k) & this._capacityMask];
      }
      if (count === 0) {
        removed = [];
        if (i > 0) {
          this._head = (this._head + i + len) & this._capacityMask;
        }
      } else {
        removed = this.remove(i, count);
        this._head = (this._head + i + len) & this._capacityMask;
      }
      while (arg_len > arguments_index) {
        this.unshift(arguments[--arg_len]);
      }
      for (k = i; k > 0; k--) {
        this.unshift(temp[k - 1]);
      }
    } else {
      temp = new Array(size - (i + count));
      var leng = temp.length;
      for (k = 0; k < leng; k++) {
        temp[k] = this._list[(this._head + i + count + k) & this._capacityMask];
      }
      if (count === 0) {
        removed = [];
        if (i != size) {
          this._tail = (this._head + i + len) & this._capacityMask;
        }
      } else {
        removed = this.remove(i, count);
        this._tail = (this._tail - leng + len) & this._capacityMask;
      }
      while (arguments_index < arg_len) {
        this.push(arguments[arguments_index++]);
      }
      for (k = 0; k < leng; k++) {
        this.push(temp[k]);
      }
    }
    return removed;
  } else {
    return this.remove(i, count);
  }
};

/**
 * Soft clear - does not reset capacity.
 */
Denque.prototype.clear = function clear() {
  this._list = new Array(this._list.length);
  this._head = 0;
  this._tail = 0;
};

/**
 * Returns true or false whether the list is empty.
 * @returns {boolean}
 */
Denque.prototype.isEmpty = function isEmpty() {
  return this._head === this._tail;
};

/**
 * Returns an array of all queue items.
 * @returns {Array}
 */
Denque.prototype.toArray = function toArray() {
  return this._copyArray(false);
};

/**
 * -------------
 *   INTERNALS
 * -------------
 */

/**
 * Fills the queue with items from an array
 * For use in the constructor
 * @param array
 * @private
 */
Denque.prototype._fromArray = function _fromArray(array) {
  var length = array.length;
  var capacity = this._nextPowerOf2(length);

  this._list = new Array(capacity);
  this._capacityMask = capacity - 1;
  this._tail = length;

  for (var i = 0; i < length; i++) this._list[i] = array[i];
};

/**
 *
 * @param fullCopy
 * @param size Initialize the array with a specific size. Will default to the current list size
 * @returns {Array}
 * @private
 */
Denque.prototype._copyArray = function _copyArray(fullCopy, size) {
  var src = this._list;
  var capacity = src.length;
  var length = this.length;
  size = size | length;

  // No prealloc requested and the buffer is contiguous
  if (size == length && this._head < this._tail) {
    // Simply do a fast slice copy
    return this._list.slice(this._head, this._tail);
  }

  var dest = new Array(size);

  var k = 0;
  var i;
  if (fullCopy || this._head > this._tail) {
    for (i = this._head; i < capacity; i++) dest[k++] = src[i];
    for (i = 0; i < this._tail; i++) dest[k++] = src[i];
  } else {
    for (i = this._head; i < this._tail; i++) dest[k++] = src[i];
  }

  return dest;
}

/**
 * Grows the internal list array.
 * @private
 */
Denque.prototype._growArray = function _growArray() {
  if (this._head != 0) {
    // double array size and copy existing data, head to end, then beginning to tail.
    var newList = this._copyArray(true, this._list.length << 1);

    this._tail = this._list.length;
    this._head = 0;

    this._list = newList;
  } else {
    this._tail = this._list.length;
    this._list.length <<= 1;
  }

  this._capacityMask = (this._capacityMask << 1) | 1;
};

/**
 * Shrinks the internal list array.
 * @private
 */
Denque.prototype._shrinkArray = function _shrinkArray() {
  this._list.length >>>= 1;
  this._capacityMask >>>= 1;
};

/**
 * Find the next power of 2, at least 4
 * @private
 * @param {number} num 
 * @returns {number}
 */
Denque.prototype._nextPowerOf2 = function _nextPowerOf2(num) {
  var log2 = Math.log(num) / Math.log(2);
  var nextPow2 = 1 << (log2 + 1);

  return Math.max(nextPow2, 4);
}

module.exports = Denque;


/***/ }),

/***/ 60095:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

/*!
 * depd
 * Copyright(c) 2014-2018 Douglas Christopher Wilson
 * MIT Licensed
 */

/**
 * Module dependencies.
 */

var relative = (__nccwpck_require__(16928).relative)

/**
 * Module exports.
 */

module.exports = depd

/**
 * Get the path to base files on.
 */

var basePath = process.cwd()

/**
 * Determine if namespace is contained in the string.
 */

function containsNamespace (str, namespace) {
  var vals = str.split(/[ ,]+/)
  var ns = String(namespace).toLowerCase()

  for (var i = 0; i < vals.length; i++) {
    var val = vals[i]

    // namespace contained
    if (val && (val === '*' || val.toLowerCase() === ns)) {
      return true
    }
  }

  return false
}

/**
 * Convert a data descriptor to accessor descriptor.
 */

function convertDataDescriptorToAccessor (obj, prop, message) {
  var descriptor = Object.getOwnPropertyDescriptor(obj, prop)
  var value = descriptor.value

  descriptor.get = function getter () { return value }

  if (descriptor.writable) {
    descriptor.set = function setter (val) { return (value = val) }
  }

  delete descriptor.value
  delete descriptor.writable

  Object.defineProperty(obj, prop, descriptor)

  return descriptor
}

/**
 * Create arguments string to keep arity.
 */

function createArgumentsString (arity) {
  var str = ''

  for (var i = 0; i < arity; i++) {
    str += ', arg' + i
  }

  return str.substr(2)
}

/**
 * Create stack string from stack.
 */

function createStackString (stack) {
  var str = this.name + ': ' + this.namespace

  if (this.message) {
    str += ' deprecated ' + this.message
  }

  for (var i = 0; i < stack.length; i++) {
    str += '\n    at ' + stack[i].toString()
  }

  return str
}

/**
 * Create deprecate for namespace in caller.
 */

function depd (namespace) {
  if (!namespace) {
    throw new TypeError('argument namespace is required')
  }

  var stack = getStack()
  var site = callSiteLocation(stack[1])
  var file = site[0]

  function deprecate (message) {
    // call to self as log
    log.call(deprecate, message)
  }

  deprecate._file = file
  deprecate._ignored = isignored(namespace)
  deprecate._namespace = namespace
  deprecate._traced = istraced(namespace)
  deprecate._warned = Object.create(null)

  deprecate.function = wrapfunction
  deprecate.property = wrapproperty

  return deprecate
}

/**
 * Determine if event emitter has listeners of a given type.
 *
 * The way to do this check is done three different ways in Node.js >= 0.8
 * so this consolidates them into a minimal set using instance methods.
 *
 * @param {EventEmitter} emitter
 * @param {string} type
 * @returns {boolean}
 * @private
 */

function eehaslisteners (emitter, type) {
  var count = typeof emitter.listenerCount !== 'function'
    ? emitter.listeners(type).length
    : emitter.listenerCount(type)

  return count > 0
}

/**
 * Determine if namespace is ignored.
 */

function isignored (namespace) {
  if (process.noDeprecation) {
    // --no-deprecation support
    return true
  }

  var str = process.env.NO_DEPRECATION || ''

  // namespace ignored
  return containsNamespace(str, namespace)
}

/**
 * Determine if namespace is traced.
 */

function istraced (namespace) {
  if (process.traceDeprecation) {
    // --trace-deprecation support
    return true
  }

  var str = process.env.TRACE_DEPRECATION || ''

  // namespace traced
  return containsNamespace(str, namespace)
}

/**
 * Display deprecation message.
 */

function log (message, site) {
  var haslisteners = eehaslisteners(process, 'deprecation')

  // abort early if no destination
  if (!haslisteners && this._ignored) {
    return
  }

  var caller
  var callFile
  var callSite
  var depSite
  var i = 0
  var seen = false
  var stack = getStack()
  var file = this._file

  if (site) {
    // provided site
    depSite = site
    callSite = callSiteLocation(stack[1])
    callSite.name = depSite.name
    file = callSite[0]
  } else {
    // get call site
    i = 2
    depSite = callSiteLocation(stack[i])
    callSite = depSite
  }

  // get caller of deprecated thing in relation to file
  for (; i < stack.length; i++) {
    caller = callSiteLocation(stack[i])
    callFile = caller[0]

    if (callFile === file) {
      seen = true
    } else if (callFile === this._file) {
      file = this._file
    } else if (seen) {
      break
    }
  }

  var key = caller
    ? depSite.join(':') + '__' + caller.join(':')
    : undefined

  if (key !== undefined && key in this._warned) {
    // already warned
    return
  }

  this._warned[key] = true

  // generate automatic message from call site
  var msg = message
  if (!msg) {
    msg = callSite === depSite || !callSite.name
      ? defaultMessage(depSite)
      : defaultMessage(callSite)
  }

  // emit deprecation if listeners exist
  if (haslisteners) {
    var err = DeprecationError(this._namespace, msg, stack.slice(i))
    process.emit('deprecation', err)
    return
  }

  // format and write message
  var format = process.stderr.isTTY
    ? formatColor
    : formatPlain
  var output = format.call(this, msg, caller, stack.slice(i))
  process.stderr.write(output + '\n', 'utf8')
}

/**
 * Get call site location as array.
 */

function callSiteLocation (callSite) {
  var file = callSite.getFileName() || '<anonymous>'
  var line = callSite.getLineNumber()
  var colm = callSite.getColumnNumber()

  if (callSite.isEval()) {
    file = callSite.getEvalOrigin() + ', ' + file
  }

  var site = [file, line, colm]

  site.callSite = callSite
  site.name = callSite.getFunctionName()

  return site
}

/**
 * Generate a default message from the site.
 */

function defaultMessage (site) {
  var callSite = site.callSite
  var funcName = site.name

  // make useful anonymous name
  if (!funcName) {
    funcName = '<anonymous@' + formatLocation(site) + '>'
  }

  var context = callSite.getThis()
  var typeName = context && callSite.getTypeName()

  // ignore useless type name
  if (typeName === 'Object') {
    typeName = undefined
  }

  // make useful type name
  if (typeName === 'Function') {
    typeName = context.name || typeName
  }

  return typeName && callSite.getMethodName()
    ? typeName + '.' + funcName
    : funcName
}

/**
 * Format deprecation message without color.
 */

function formatPlain (msg, caller, stack) {
  var timestamp = new Date().toUTCString()

  var formatted = timestamp +
    ' ' + this._namespace +
    ' deprecated ' + msg

  // add stack trace
  if (this._traced) {
    for (var i = 0; i < stack.length; i++) {
      formatted += '\n    at ' + stack[i].toString()
    }

    return formatted
  }

  if (caller) {
    formatted += ' at ' + formatLocation(caller)
  }

  return formatted
}

/**
 * Format deprecation message with color.
 */

function formatColor (msg, caller, stack) {
  var formatted = '\x1b[36;1m' + this._namespace + '\x1b[22;39m' + // bold cyan
    ' \x1b[33;1mdeprecated\x1b[22;39m' + // bold yellow
    ' \x1b[0m' + msg + '\x1b[39m' // reset

  // add stack trace
  if (this._traced) {
    for (var i = 0; i < stack.length; i++) {
      formatted += '\n    \x1b[36mat ' + stack[i].toString() + '\x1b[39m' // cyan
    }

    return formatted
  }

  if (caller) {
    formatted += ' \x1b[36m' + formatLocation(caller) + '\x1b[39m' // cyan
  }

  return formatted
}

/**
 * Format call site location.
 */

function formatLocation (callSite) {
  return relative(basePath, callSite[0]) +
    ':' + callSite[1] +
    ':' + callSite[2]
}

/**
 * Get the stack as array of call sites.
 */

function getStack () {
  var limit = Error.stackTraceLimit
  var obj = {}
  var prep = Error.prepareStackTrace

  Error.prepareStackTrace = prepareObjectStackTrace
  Error.stackTraceLimit = Math.max(10, limit)

  // capture the stack
  Error.captureStackTrace(obj)

  // slice this function off the top
  var stack = obj.stack.slice(1)

  Error.prepareStackTrace = prep
  Error.stackTraceLimit = limit

  return stack
}

/**
 * Capture call site stack from v8.
 */

function prepareObjectStackTrace (obj, stack) {
  return stack
}

/**
 * Return a wrapped function in a deprecation message.
 */

function wrapfunction (fn, message) {
  if (typeof fn !== 'function') {
    throw new TypeError('argument fn must be a function')
  }

  var args = createArgumentsString(fn.length)
  var stack = getStack()
  var site = callSiteLocation(stack[1])

  site.name = fn.name

  // eslint-disable-next-line no-new-func
  var deprecatedfn = new Function('fn', 'log', 'deprecate', 'message', 'site',
    '"use strict"\n' +
    'return function (' + args + ') {' +
    'log.call(deprecate, message, site)\n' +
    'return fn.apply(this, arguments)\n' +
    '}')(fn, log, this, message, site)

  return deprecatedfn
}

/**
 * Wrap property in a deprecation message.
 */

function wrapproperty (obj, prop, message) {
  if (!obj || (typeof obj !== 'object' && typeof obj !== 'function')) {
    throw new TypeError('argument obj must be object')
  }

  var descriptor = Object.getOwnPropertyDescriptor(obj, prop)

  if (!descriptor) {
    throw new TypeError('must call property on owner object')
  }

  if (!descriptor.configurable) {
    throw new TypeError('property must be configurable')
  }

  var deprecate = this
  var stack = getStack()
  var site = callSiteLocation(stack[1])

  // set site name
  site.name = prop

  // convert data descriptor
  if ('value' in descriptor) {
    descriptor = convertDataDescriptorToAccessor(obj, prop, message)
  }

  var get = descriptor.get
  var set = descriptor.set

  // wrap getter
  if (typeof get === 'function') {
    descriptor.get = function getter () {
      log.call(deprecate, message, site)
      return get.apply(this, arguments)
    }
  }

  // wrap setter
  if (typeof set === 'function') {
    descriptor.set = function setter () {
      log.call(deprecate, message, site)
      return set.apply(this, arguments)
    }
  }

  Object.defineProperty(obj, prop, descriptor)
}

/**
 * Create DeprecationError for deprecation
 */

function DeprecationError (namespace, message, stack) {
  var error = new Error()
  var stackString

  Object.defineProperty(error, 'constructor', {
    value: DeprecationError
  })

  Object.defineProperty(error, 'message', {
    configurable: true,
    enumerable: false,
    value: message,
    writable: true
  })

  Object.defineProperty(error, 'name', {
    enumerable: false,
    configurable: true,
    value: 'DeprecationError',
    writable: true
  })

  Object.defineProperty(error, 'namespace', {
    configurable: true,
    enumerable: false,
    value: namespace,
    writable: true
  })

  Object.defineProperty(error, 'stack', {
    configurable: true,
    enumerable: false,
    get: function () {
      if (stackString !== undefined) {
        return stackString
      }

      // prepare stack trace
      return (stackString = createStackString.call(this, stack))
    },
    set: function setter (val) {
      stackString = val
    }
  })

  return error
}


/***/ }),

/***/ 32194:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";
/*!
 * destroy
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015-2022 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module dependencies.
 * @private
 */

var EventEmitter = (__nccwpck_require__(24434).EventEmitter)
var ReadStream = (__nccwpck_require__(79896).ReadStream)
var Stream = __nccwpck_require__(2203)
var Zlib = __nccwpck_require__(43106)

/**
 * Module exports.
 * @public
 */

module.exports = destroy

/**
 * Destroy the given stream, and optionally suppress any future `error` events.
 *
 * @param {object} stream
 * @param {boolean} suppress
 * @public
 */

function destroy (stream, suppress) {
  if (isFsReadStream(stream)) {
    destroyReadStream(stream)
  } else if (isZlibStream(stream)) {
    destroyZlibStream(stream)
  } else if (hasDestroy(stream)) {
    stream.destroy()
  }

  if (isEventEmitter(stream) && suppress) {
    stream.removeAllListeners('error')
    stream.addListener('error', noop)
  }

  return stream
}

/**
 * Destroy a ReadStream.
 *
 * @param {object} stream
 * @private
 */

function destroyReadStream (stream) {
  stream.destroy()

  if (typeof stream.close === 'function') {
    // node.js core bug work-around
    stream.on('open', onOpenClose)
  }
}

/**
 * Close a Zlib stream.
 *
 * Zlib streams below Node.js 4.5.5 have a buggy implementation
 * of .close() when zlib encountered an error.
 *
 * @param {object} stream
 * @private
 */

function closeZlibStream (stream) {
  if (stream._hadError === true) {
    var prop = stream._binding === null
      ? '_binding'
      : '_handle'

    stream[prop] = {
      close: function () { this[prop] = null }
    }
  }

  stream.close()
}

/**
 * Destroy a Zlib stream.
 *
 * Zlib streams don't have a destroy function in Node.js 6. On top of that
 * simply calling destroy on a zlib stream in Node.js 8+ will result in a
 * memory leak. So until that is fixed, we need to call both close AND destroy.
 *
 * PR to fix memory leak: https://github.com/nodejs/node/pull/23734
 *
 * In Node.js 6+8, it's important that destroy is called before close as the
 * stream would otherwise emit the error 'zlib binding closed'.
 *
 * @param {object} stream
 * @private
 */

function destroyZlibStream (stream) {
  if (typeof stream.destroy === 'function') {
    // node.js core bug work-around
    // istanbul ignore if: node.js 0.8
    if (stream._binding) {
      // node.js < 0.10.0
      stream.destroy()
      if (stream._processing) {
        stream._needDrain = true
        stream.once('drain', onDrainClearBinding)
      } else {
        stream._binding.clear()
      }
    } else if (stream._destroy && stream._destroy !== Stream.Transform.prototype._destroy) {
      // node.js >= 12, ^11.1.0, ^10.15.1
      stream.destroy()
    } else if (stream._destroy && typeof stream.close === 'function') {
      // node.js 7, 8
      stream.destroyed = true
      stream.close()
    } else {
      // fallback
      // istanbul ignore next
      stream.destroy()
    }
  } else if (typeof stream.close === 'function') {
    // node.js < 8 fallback
    closeZlibStream(stream)
  }
}

/**
 * Determine if stream has destroy.
 * @private
 */

function hasDestroy (stream) {
  return stream instanceof Stream &&
    typeof stream.destroy === 'function'
}

/**
 * Determine if val is EventEmitter.
 * @private
 */

function isEventEmitter (val) {
  return val instanceof EventEmitter
}

/**
 * Determine if stream is fs.ReadStream stream.
 * @private
 */

function isFsReadStream (stream) {
  return stream instanceof ReadStream
}

/**
 * Determine if stream is Zlib stream.
 * @private
 */

function isZlibStream (stream) {
  return stream instanceof Zlib.Gzip ||
    stream instanceof Zlib.Gunzip ||
    stream instanceof Zlib.Deflate ||
    stream instanceof Zlib.DeflateRaw ||
    stream instanceof Zlib.Inflate ||
    stream instanceof Zlib.InflateRaw ||
    stream instanceof Zlib.Unzip
}

/**
 * No-op function.
 * @private
 */

function noop () {}

/**
 * On drain handler to clear binding.
 * @private
 */

// istanbul ignore next: node.js 0.8
function onDrainClearBinding () {
  this._binding.clear()
}

/**
 * On open handler to close stream.
 * @private
 */

function onOpenClose () {
  if (typeof this.fd === 'number') {
    // actually close down the fd
    this.close()
  }
}


/***/ }),

/***/ 18889:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

const fs = __nccwpck_require__(79896)
const path = __nccwpck_require__(16928)
const os = __nccwpck_require__(70857)
const crypto = __nccwpck_require__(76982)
const packageJson = __nccwpck_require__(80056)

const version = packageJson.version

// Array of tips to display randomly
const TIPS = [
  'üîê encrypt with Dotenvx: https://dotenvx.com',
  'üîê prevent committing .env to code: https://dotenvx.com/precommit',
  'üîê prevent building .env in docker: https://dotenvx.com/prebuild',
  'üì° add observability to secrets: https://dotenvx.com/ops',
  'üë• sync secrets across teammates & machines: https://dotenvx.com/ops',
  'üóÇÔ∏è backup and recover secrets: https://dotenvx.com/ops',
  '‚úÖ audit secrets and track compliance: https://dotenvx.com/ops',
  'üîÑ add secrets lifecycle management: https://dotenvx.com/ops',
  'üîë add access controls to secrets: https://dotenvx.com/ops',
  'üõ†Ô∏è  run anywhere with `dotenvx run -- yourcommand`',
  '‚öôÔ∏è  specify custom .env file path with { path: \'/custom/path/.env\' }',
  '‚öôÔ∏è  enable debug logging with { debug: true }',
  '‚öôÔ∏è  override existing env vars with { override: true }',
  '‚öôÔ∏è  suppress all logs with { quiet: true }',
  '‚öôÔ∏è  write to custom object with { processEnv: myObject }',
  '‚öôÔ∏è  load multiple .env files with { path: [\'.env.local\', \'.env\'] }'
]

// Get a random tip from the tips array
function _getRandomTip () {
  return TIPS[Math.floor(Math.random() * TIPS.length)]
}

function parseBoolean (value) {
  if (typeof value === 'string') {
    return !['false', '0', 'no', 'off', ''].includes(value.toLowerCase())
  }
  return Boolean(value)
}

function supportsAnsi () {
  return process.stdout.isTTY // && process.env.TERM !== 'dumb'
}

function dim (text) {
  return supportsAnsi() ? `\x1b[2m${text}\x1b[0m` : text
}

const LINE = /(?:^|^)\s*(?:export\s+)?([\w.-]+)(?:\s*=\s*?|:\s+?)(\s*'(?:\\'|[^'])*'|\s*"(?:\\"|[^"])*"|\s*`(?:\\`|[^`])*`|[^#\r\n]+)?\s*(?:#.*)?(?:$|$)/mg

// Parse src into an Object
function parse (src) {
  const obj = {}

  // Convert buffer to string
  let lines = src.toString()

  // Convert line breaks to same format
  lines = lines.replace(/\r\n?/mg, '\n')

  let match
  while ((match = LINE.exec(lines)) != null) {
    const key = match[1]

    // Default undefined or null to empty string
    let value = (match[2] || '')

    // Remove whitespace
    value = value.trim()

    // Check if double quoted
    const maybeQuote = value[0]

    // Remove surrounding quotes
    value = value.replace(/^(['"`])([\s\S]*)\1$/mg, '$2')

    // Expand newlines if double quoted
    if (maybeQuote === '"') {
      value = value.replace(/\\n/g, '\n')
      value = value.replace(/\\r/g, '\r')
    }

    // Add to object
    obj[key] = value
  }

  return obj
}

function _parseVault (options) {
  options = options || {}

  const vaultPath = _vaultPath(options)
  options.path = vaultPath // parse .env.vault
  const result = DotenvModule.configDotenv(options)
  if (!result.parsed) {
    const err = new Error(`MISSING_DATA: Cannot parse ${vaultPath} for an unknown reason`)
    err.code = 'MISSING_DATA'
    throw err
  }

  // handle scenario for comma separated keys - for use with key rotation
  // example: DOTENV_KEY="dotenv://:key_1234@dotenvx.com/vault/.env.vault?environment=prod,dotenv://:key_7890@dotenvx.com/vault/.env.vault?environment=prod"
  const keys = _dotenvKey(options).split(',')
  const length = keys.length

  let decrypted
  for (let i = 0; i < length; i++) {
    try {
      // Get full key
      const key = keys[i].trim()

      // Get instructions for decrypt
      const attrs = _instructions(result, key)

      // Decrypt
      decrypted = DotenvModule.decrypt(attrs.ciphertext, attrs.key)

      break
    } catch (error) {
      // last key
      if (i + 1 >= length) {
        throw error
      }
      // try next key
    }
  }

  // Parse decrypted .env string
  return DotenvModule.parse(decrypted)
}

function _warn (message) {
  console.error(`[dotenv@${version}][WARN] ${message}`)
}

function _debug (message) {
  console.log(`[dotenv@${version}][DEBUG] ${message}`)
}

function _log (message) {
  console.log(`[dotenv@${version}] ${message}`)
}

function _dotenvKey (options) {
  // prioritize developer directly setting options.DOTENV_KEY
  if (options && options.DOTENV_KEY && options.DOTENV_KEY.length > 0) {
    return options.DOTENV_KEY
  }

  // secondary infra already contains a DOTENV_KEY environment variable
  if (process.env.DOTENV_KEY && process.env.DOTENV_KEY.length > 0) {
    return process.env.DOTENV_KEY
  }

  // fallback to empty string
  return ''
}

function _instructions (result, dotenvKey) {
  // Parse DOTENV_KEY. Format is a URI
  let uri
  try {
    uri = new URL(dotenvKey)
  } catch (error) {
    if (error.code === 'ERR_INVALID_URL') {
      const err = new Error('INVALID_DOTENV_KEY: Wrong format. Must be in valid uri format like dotenv://:key_1234@dotenvx.com/vault/.env.vault?environment=development')
      err.code = 'INVALID_DOTENV_KEY'
      throw err
    }

    throw error
  }

  // Get decrypt key
  const key = uri.password
  if (!key) {
    const err = new Error('INVALID_DOTENV_KEY: Missing key part')
    err.code = 'INVALID_DOTENV_KEY'
    throw err
  }

  // Get environment
  const environment = uri.searchParams.get('environment')
  if (!environment) {
    const err = new Error('INVALID_DOTENV_KEY: Missing environment part')
    err.code = 'INVALID_DOTENV_KEY'
    throw err
  }

  // Get ciphertext payload
  const environmentKey = `DOTENV_VAULT_${environment.toUpperCase()}`
  const ciphertext = result.parsed[environmentKey] // DOTENV_VAULT_PRODUCTION
  if (!ciphertext) {
    const err = new Error(`NOT_FOUND_DOTENV_ENVIRONMENT: Cannot locate environment ${environmentKey} in your .env.vault file.`)
    err.code = 'NOT_FOUND_DOTENV_ENVIRONMENT'
    throw err
  }

  return { ciphertext, key }
}

function _vaultPath (options) {
  let possibleVaultPath = null

  if (options && options.path && options.path.length > 0) {
    if (Array.isArray(options.path)) {
      for (const filepath of options.path) {
        if (fs.existsSync(filepath)) {
          possibleVaultPath = filepath.endsWith('.vault') ? filepath : `${filepath}.vault`
        }
      }
    } else {
      possibleVaultPath = options.path.endsWith('.vault') ? options.path : `${options.path}.vault`
    }
  } else {
    possibleVaultPath = path.resolve(process.cwd(), '.env.vault')
  }

  if (fs.existsSync(possibleVaultPath)) {
    return possibleVaultPath
  }

  return null
}

function _resolveHome (envPath) {
  return envPath[0] === '~' ? path.join(os.homedir(), envPath.slice(1)) : envPath
}

function _configVault (options) {
  const debug = parseBoolean(process.env.DOTENV_CONFIG_DEBUG || (options && options.debug))
  const quiet = parseBoolean(process.env.DOTENV_CONFIG_QUIET || (options && options.quiet))

  if (debug || !quiet) {
    _log('Loading env from encrypted .env.vault')
  }

  const parsed = DotenvModule._parseVault(options)

  let processEnv = process.env
  if (options && options.processEnv != null) {
    processEnv = options.processEnv
  }

  DotenvModule.populate(processEnv, parsed, options)

  return { parsed }
}

function configDotenv (options) {
  const dotenvPath = path.resolve(process.cwd(), '.env')
  let encoding = 'utf8'
  let processEnv = process.env
  if (options && options.processEnv != null) {
    processEnv = options.processEnv
  }
  let debug = parseBoolean(processEnv.DOTENV_CONFIG_DEBUG || (options && options.debug))
  let quiet = parseBoolean(processEnv.DOTENV_CONFIG_QUIET || (options && options.quiet))

  if (options && options.encoding) {
    encoding = options.encoding
  } else {
    if (debug) {
      _debug('No encoding is specified. UTF-8 is used by default')
    }
  }

  let optionPaths = [dotenvPath] // default, look for .env
  if (options && options.path) {
    if (!Array.isArray(options.path)) {
      optionPaths = [_resolveHome(options.path)]
    } else {
      optionPaths = [] // reset default
      for (const filepath of options.path) {
        optionPaths.push(_resolveHome(filepath))
      }
    }
  }

  // Build the parsed data in a temporary object (because we need to return it).  Once we have the final
  // parsed data, we will combine it with process.env (or options.processEnv if provided).
  let lastError
  const parsedAll = {}
  for (const path of optionPaths) {
    try {
      // Specifying an encoding returns a string instead of a buffer
      const parsed = DotenvModule.parse(fs.readFileSync(path, { encoding }))

      DotenvModule.populate(parsedAll, parsed, options)
    } catch (e) {
      if (debug) {
        _debug(`Failed to load ${path} ${e.message}`)
      }
      lastError = e
    }
  }

  const populated = DotenvModule.populate(processEnv, parsedAll, options)

  // handle user settings DOTENV_CONFIG_ options inside .env file(s)
  debug = parseBoolean(processEnv.DOTENV_CONFIG_DEBUG || debug)
  quiet = parseBoolean(processEnv.DOTENV_CONFIG_QUIET || quiet)

  if (debug || !quiet) {
    const keysCount = Object.keys(populated).length
    const shortPaths = []
    for (const filePath of optionPaths) {
      try {
        const relative = path.relative(process.cwd(), filePath)
        shortPaths.push(relative)
      } catch (e) {
        if (debug) {
          _debug(`Failed to load ${filePath} ${e.message}`)
        }
        lastError = e
      }
    }

    _log(`injecting env (${keysCount}) from ${shortPaths.join(',')} ${dim(`-- tip: ${_getRandomTip()}`)}`)
  }

  if (lastError) {
    return { parsed: parsedAll, error: lastError }
  } else {
    return { parsed: parsedAll }
  }
}

// Populates process.env from .env file
function config (options) {
  // fallback to original dotenv if DOTENV_KEY is not set
  if (_dotenvKey(options).length === 0) {
    return DotenvModule.configDotenv(options)
  }

  const vaultPath = _vaultPath(options)

  // dotenvKey exists but .env.vault file does not exist
  if (!vaultPath) {
    _warn(`You set DOTENV_KEY but you are missing a .env.vault file at ${vaultPath}. Did you forget to build it?`)

    return DotenvModule.configDotenv(options)
  }

  return DotenvModule._configVault(options)
}

function decrypt (encrypted, keyStr) {
  const key = Buffer.from(keyStr.slice(-64), 'hex')
  let ciphertext = Buffer.from(encrypted, 'base64')

  const nonce = ciphertext.subarray(0, 12)
  const authTag = ciphertext.subarray(-16)
  ciphertext = ciphertext.subarray(12, -16)

  try {
    const aesgcm = crypto.createDecipheriv('aes-256-gcm', key, nonce)
    aesgcm.setAuthTag(authTag)
    return `${aesgcm.update(ciphertext)}${aesgcm.final()}`
  } catch (error) {
    const isRange = error instanceof RangeError
    const invalidKeyLength = error.message === 'Invalid key length'
    const decryptionFailed = error.message === 'Unsupported state or unable to authenticate data'

    if (isRange || invalidKeyLength) {
      const err = new Error('INVALID_DOTENV_KEY: It must be 64 characters long (or more)')
      err.code = 'INVALID_DOTENV_KEY'
      throw err
    } else if (decryptionFailed) {
      const err = new Error('DECRYPTION_FAILED: Please check your DOTENV_KEY')
      err.code = 'DECRYPTION_FAILED'
      throw err
    } else {
      throw error
    }
  }
}

// Populate process.env with parsed values
function populate (processEnv, parsed, options = {}) {
  const debug = Boolean(options && options.debug)
  const override = Boolean(options && options.override)
  const populated = {}

  if (typeof parsed !== 'object') {
    const err = new Error('OBJECT_REQUIRED: Please check the processEnv argument being passed to populate')
    err.code = 'OBJECT_REQUIRED'
    throw err
  }

  // Set process.env
  for (const key of Object.keys(parsed)) {
    if (Object.prototype.hasOwnProperty.call(processEnv, key)) {
      if (override === true) {
        processEnv[key] = parsed[key]
        populated[key] = parsed[key]
      }

      if (debug) {
        if (override === true) {
          _debug(`"${key}" is already defined and WAS overwritten`)
        } else {
          _debug(`"${key}" is already defined and was NOT overwritten`)
        }
      }
    } else {
      processEnv[key] = parsed[key]
      populated[key] = parsed[key]
    }
  }

  return populated
}

const DotenvModule = {
  configDotenv,
  _configVault,
  _parseVault,
  config,
  decrypt,
  parse,
  populate
}

module.exports.configDotenv = DotenvModule.configDotenv
module.exports._configVault = DotenvModule._configVault
module.exports._parseVault = DotenvModule._parseVault
module.exports.config = DotenvModule.config
module.exports.decrypt = DotenvModule.decrypt
module.exports.parse = DotenvModule.parse
module.exports.populate = DotenvModule.populate

module.exports = DotenvModule


/***/ }),

/***/ 26669:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


var callBind = __nccwpck_require__(88705);
var gOPD = __nccwpck_require__(33170);

var hasProtoAccessor;
try {
	// eslint-disable-next-line no-extra-parens, no-proto
	hasProtoAccessor = /** @type {{ __proto__?: typeof Array.prototype }} */ ([]).__proto__ === Array.prototype;
} catch (e) {
	if (!e || typeof e !== 'object' || !('code' in e) || e.code !== 'ERR_PROTO_ACCESS') {
		throw e;
	}
}

// eslint-disable-next-line no-extra-parens
var desc = !!hasProtoAccessor && gOPD && gOPD(Object.prototype, /** @type {keyof typeof Object.prototype} */ ('__proto__'));

var $Object = Object;
var $getPrototypeOf = $Object.getPrototypeOf;

/** @type {import('./get')} */
module.exports = desc && typeof desc.get === 'function'
	? callBind([desc.get])
	: typeof $getPrototypeOf === 'function'
		? /** @type {import('./get')} */ function getDunder(value) {
			// eslint-disable-next-line eqeqeq
			return $getPrototypeOf(value == null ? value : $Object(value));
		}
		: false;


/***/ }),

/***/ 25049:
/***/ ((module) => {

"use strict";
/*!
 * ee-first
 * Copyright(c) 2014 Jonathan Ong
 * MIT Licensed
 */



/**
 * Module exports.
 * @public
 */

module.exports = first

/**
 * Get the first event in a set of event emitters and event pairs.
 *
 * @param {array} stuff
 * @param {function} done
 * @public
 */

function first(stuff, done) {
  if (!Array.isArray(stuff))
    throw new TypeError('arg must be an array of [ee, events...] arrays')

  var cleanups = []

  for (var i = 0; i < stuff.length; i++) {
    var arr = stuff[i]

    if (!Array.isArray(arr) || arr.length < 2)
      throw new TypeError('each array member must be [ee, events...]')

    var ee = arr[0]

    for (var j = 1; j < arr.length; j++) {
      var event = arr[j]
      var fn = listener(event, callback)

      // listen to the event
      ee.on(event, fn)
      // push this listener to the list of cleanups
      cleanups.push({
        ee: ee,
        event: event,
        fn: fn,
      })
    }
  }

  function callback() {
    cleanup()
    done.apply(null, arguments)
  }

  function cleanup() {
    var x
    for (var i = 0; i < cleanups.length; i++) {
      x = cleanups[i]
      x.ee.removeListener(x.event, x.fn)
    }
  }

  function thunk(fn) {
    done = fn
  }

  thunk.cancel = cleanup

  return thunk
}

/**
 * Create the event listener.
 * @private
 */

function listener(event, done) {
  return function onevent(arg1) {
    var args = new Array(arguments.length)
    var ee = this
    var err = event === 'error'
      ? arg1
      : null

    // copy args to prevent arguments escaping scope
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i]
    }

    done(err, ee, event, args)
  }
}


/***/ }),

/***/ 85909:
/***/ ((module) => {

"use strict";


/**
 * Checks if a given namespace is allowed by the given variable.
 *
 * @param {String} name namespace that should be included.
 * @param {String} variable Value that needs to be tested.
 * @returns {Boolean} Indication if namespace is enabled.
 * @public
 */
module.exports = function enabled(name, variable) {
  if (!variable) return false;

  var variables = variable.split(/[\s,]+/)
    , i = 0;

  for (; i < variables.length; i++) {
    variable = variables[i].replace('*', '.*?');

    if ('-' === variable.charAt(0)) {
      if ((new RegExp('^'+ variable.substr(1) +'$')).test(name)) {
        return false;
      }

      continue;
    }

    if ((new RegExp('^'+ variable +'$')).test(name)) {
      return true;
    }
  }

  return false;
};


/***/ }),

/***/ 83835:
/***/ ((module) => {

"use strict";
/*!
 * encodeurl
 * Copyright(c) 2016 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module exports.
 * @public
 */

module.exports = encodeUrl

/**
 * RegExp to match non-URL code points, *after* encoding (i.e. not including "%")
 * and including invalid escape sequences.
 * @private
 */

var ENCODE_CHARS_REGEXP = /(?:[^\x21\x23-\x3B\x3D\x3F-\x5F\x61-\x7A\x7C\x7E]|%(?:[^0-9A-Fa-f]|[0-9A-Fa-f][^0-9A-Fa-f]|$))+/g

/**
 * RegExp to match unmatched surrogate pair.
 * @private
 */

var UNMATCHED_SURROGATE_PAIR_REGEXP = /(^|[^\uD800-\uDBFF])[\uDC00-\uDFFF]|[\uD800-\uDBFF]([^\uDC00-\uDFFF]|$)/g

/**
 * String to replace unmatched surrogate pair with.
 * @private
 */

var UNMATCHED_SURROGATE_PAIR_REPLACE = '$1\uFFFD$2'

/**
 * Encode a URL to a percent-encoded form, excluding already-encoded sequences.
 *
 * This function will take an already-encoded URL and encode all the non-URL
 * code points. This function will not encode the "%" character unless it is
 * not part of a valid sequence (`%20` will be left as-is, but `%foo` will
 * be encoded as `%25foo`).
 *
 * This encode is meant to be "safe" and does not throw errors. It will try as
 * hard as it can to properly encode the given URL, including replacing any raw,
 * unpaired surrogate pairs with the Unicode replacement character prior to
 * encoding.
 *
 * @param {string} url
 * @return {string}
 * @public
 */

function encodeUrl (url) {
  return String(url)
    .replace(UNMATCHED_SURROGATE_PAIR_REGEXP, UNMATCHED_SURROGATE_PAIR_REPLACE)
    .replace(ENCODE_CHARS_REGEXP, encodeURI)
}


/***/ }),

/***/ 79094:
/***/ ((module) => {

"use strict";


/** @type {import('.')} */
var $defineProperty = Object.defineProperty || false;
if ($defineProperty) {
	try {
		$defineProperty({}, 'a', { value: 1 });
	} catch (e) {
		// IE 8 has a broken defineProperty
		$defineProperty = false;
	}
}

module.exports = $defineProperty;


/***/ }),

/***/ 33056:
/***/ ((module) => {

"use strict";


/** @type {import('./eval')} */
module.exports = EvalError;


/***/ }),

/***/ 31620:
/***/ ((module) => {

"use strict";


/** @type {import('.')} */
module.exports = Error;


/***/ }),

/***/ 14585:
/***/ ((module) => {

"use strict";


/** @type {import('./range')} */
module.exports = RangeError;


/***/ }),

/***/ 46905:
/***/ ((module) => {

"use strict";


/** @type {import('./ref')} */
module.exports = ReferenceError;


/***/ }),

/***/ 80105:
/***/ ((module) => {

"use strict";


/** @type {import('./syntax')} */
module.exports = SyntaxError;


/***/ }),

/***/ 73314:
/***/ ((module) => {

"use strict";


/** @type {import('./type')} */
module.exports = TypeError;


/***/ }),

/***/ 32578:
/***/ ((module) => {

"use strict";


/** @type {import('./uri')} */
module.exports = URIError;


/***/ }),

/***/ 95399:
/***/ ((module) => {

"use strict";


/** @type {import('.')} */
module.exports = Object;


/***/ }),

/***/ 12759:
/***/ ((module) => {

"use strict";
/*!
 * escape-html
 * Copyright(c) 2012-2013 TJ Holowaychuk
 * Copyright(c) 2015 Andreas Lubbe
 * Copyright(c) 2015 Tiancheng "Timothy" Gu
 * MIT Licensed
 */



/**
 * Module variables.
 * @private
 */

var matchHtmlRegExp = /["'&<>]/;

/**
 * Module exports.
 * @public
 */

module.exports = escapeHtml;

/**
 * Escape special characters in the given string of html.
 *
 * @param  {string} string The string to escape for inserting into HTML
 * @return {string}
 * @public
 */

function escapeHtml(string) {
  var str = '' + string;
  var match = matchHtmlRegExp.exec(str);

  if (!match) {
    return str;
  }

  var escape;
  var html = '';
  var index = 0;
  var lastIndex = 0;

  for (index = match.index; index < str.length; index++) {
    switch (str.charCodeAt(index)) {
      case 34: // "
        escape = '&quot;';
        break;
      case 38: // &
        escape = '&amp;';
        break;
      case 39: // '
        escape = '&#39;';
        break;
      case 60: // <
        escape = '&lt;';
        break;
      case 62: // >
        escape = '&gt;';
        break;
      default:
        continue;
    }

    if (lastIndex !== index) {
      html += str.substring(lastIndex, index);
    }

    lastIndex = index + 1;
    html += escape;
  }

  return lastIndex !== index
    ? html + str.substring(lastIndex, index)
    : html;
}


/***/ }),

/***/ 61825:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";
/*!
 * etag
 * Copyright(c) 2014-2016 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module exports.
 * @public
 */

module.exports = etag

/**
 * Module dependencies.
 * @private
 */

var crypto = __nccwpck_require__(76982)
var Stats = (__nccwpck_require__(79896).Stats)

/**
 * Module variables.
 * @private
 */

var toString = Object.prototype.toString

/**
 * Generate an entity tag.
 *
 * @param {Buffer|string} entity
 * @return {string}
 * @private
 */

function entitytag (entity) {
  if (entity.length === 0) {
    // fast-path empty
    return '"0-2jmj7l5rSw0yVb/vlWAYkK/YBwk"'
  }

  // compute hash of entity
  var hash = crypto
    .createHash('sha1')
    .update(entity, 'utf8')
    .digest('base64')
    .substring(0, 27)

  // compute length of entity
  var len = typeof entity === 'string'
    ? Buffer.byteLength(entity, 'utf8')
    : entity.length

  return '"' + len.toString(16) + '-' + hash + '"'
}

/**
 * Create a simple ETag.
 *
 * @param {string|Buffer|Stats} entity
 * @param {object} [options]
 * @param {boolean} [options.weak]
 * @return {String}
 * @public
 */

function etag (entity, options) {
  if (entity == null) {
    throw new TypeError('argument entity is required')
  }

  // support fs.Stats object
  var isStats = isstats(entity)
  var weak = options && typeof options.weak === 'boolean'
    ? options.weak
    : isStats

  // validate argument
  if (!isStats && typeof entity !== 'string' && !Buffer.isBuffer(entity)) {
    throw new TypeError('argument entity must be string, Buffer, or fs.Stats')
  }

  // generate entity tag
  var tag = isStats
    ? stattag(entity)
    : entitytag(entity)

  return weak
    ? 'W/' + tag
    : tag
}

/**
 * Determine if object is a Stats object.
 *
 * @param {object} obj
 * @return {boolean}
 * @api private
 */

function isstats (obj) {
  // genuine fs.Stats
  if (typeof Stats === 'function' && obj instanceof Stats) {
    return true
  }

  // quack quack
  return obj && typeof obj === 'object' &&
    'ctime' in obj && toString.call(obj.ctime) === '[object Date]' &&
    'mtime' in obj && toString.call(obj.mtime) === '[object Date]' &&
    'ino' in obj && typeof obj.ino === 'number' &&
    'size' in obj && typeof obj.size === 'number'
}

/**
 * Generate a tag for a stat.
 *
 * @param {object} stat
 * @return {string}
 * @private
 */

function stattag (stat) {
  var mtime = stat.mtime.getTime().toString(16)
  var size = stat.size.toString(16)

  return '"' + size + '-' + mtime + '"'
}


/***/ }),

/***/ 85152:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";
/*!
 * express
 * Copyright(c) 2009-2013 TJ Holowaychuk
 * Copyright(c) 2013 Roman Shtylman
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */



module.exports = __nccwpck_require__(99192);


/***/ }),

/***/ 75314:
/***/ ((module, exports, __nccwpck_require__) => {

"use strict";
/*!
 * express
 * Copyright(c) 2009-2013 TJ Holowaychuk
 * Copyright(c) 2013 Roman Shtylman
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module dependencies.
 * @private
 */

var finalhandler = __nccwpck_require__(58864);
var Router = __nccwpck_require__(68240);
var methods = __nccwpck_require__(50806);
var middleware = __nccwpck_require__(90791);
var query = __nccwpck_require__(64321);
var debug = __nccwpck_require__(88854)('express:application');
var View = __nccwpck_require__(79123);
var http = __nccwpck_require__(58611);
var compileETag = (__nccwpck_require__(89253).compileETag);
var compileQueryParser = (__nccwpck_require__(89253).compileQueryParser);
var compileTrust = (__nccwpck_require__(89253).compileTrust);
var deprecate = __nccwpck_require__(60095)('express');
var flatten = __nccwpck_require__(79560);
var merge = __nccwpck_require__(51448);
var resolve = (__nccwpck_require__(16928).resolve);
var setPrototypeOf = __nccwpck_require__(41015)

/**
 * Module variables.
 * @private
 */

var hasOwnProperty = Object.prototype.hasOwnProperty
var slice = Array.prototype.slice;

/**
 * Application prototype.
 */

var app = exports = module.exports = {};

/**
 * Variable for trust proxy inheritance back-compat
 * @private
 */

var trustProxyDefaultSymbol = '@@symbol:trust_proxy_default';

/**
 * Initialize the server.
 *
 *   - setup default configuration
 *   - setup default middleware
 *   - setup route reflection methods
 *
 * @private
 */

app.init = function init() {
  this.cache = {};
  this.engines = {};
  this.settings = {};

  this.defaultConfiguration();
};

/**
 * Initialize application configuration.
 * @private
 */

app.defaultConfiguration = function defaultConfiguration() {
  var env = process.env.NODE_ENV || 'development';

  // default settings
  this.enable('x-powered-by');
  this.set('etag', 'weak');
  this.set('env', env);
  this.set('query parser', 'extended');
  this.set('subdomain offset', 2);
  this.set('trust proxy', false);

  // trust proxy inherit back-compat
  Object.defineProperty(this.settings, trustProxyDefaultSymbol, {
    configurable: true,
    value: true
  });

  debug('booting in %s mode', env);

  this.on('mount', function onmount(parent) {
    // inherit trust proxy
    if (this.settings[trustProxyDefaultSymbol] === true
      && typeof parent.settings['trust proxy fn'] === 'function') {
      delete this.settings['trust proxy'];
      delete this.settings['trust proxy fn'];
    }

    // inherit protos
    setPrototypeOf(this.request, parent.request)
    setPrototypeOf(this.response, parent.response)
    setPrototypeOf(this.engines, parent.engines)
    setPrototypeOf(this.settings, parent.settings)
  });

  // setup locals
  this.locals = Object.create(null);

  // top-most app is mounted at /
  this.mountpath = '/';

  // default locals
  this.locals.settings = this.settings;

  // default configuration
  this.set('view', View);
  this.set('views', resolve('views'));
  this.set('jsonp callback name', 'callback');

  if (env === 'production') {
    this.enable('view cache');
  }

  Object.defineProperty(this, 'router', {
    get: function() {
      throw new Error('\'app.router\' is deprecated!\nPlease see the 3.x to 4.x migration guide for details on how to update your app.');
    }
  });
};

/**
 * lazily adds the base router if it has not yet been added.
 *
 * We cannot add the base router in the defaultConfiguration because
 * it reads app settings which might be set after that has run.
 *
 * @private
 */
app.lazyrouter = function lazyrouter() {
  if (!this._router) {
    this._router = new Router({
      caseSensitive: this.enabled('case sensitive routing'),
      strict: this.enabled('strict routing')
    });

    this._router.use(query(this.get('query parser fn')));
    this._router.use(middleware.init(this));
  }
};

/**
 * Dispatch a req, res pair into the application. Starts pipeline processing.
 *
 * If no callback is provided, then default error handlers will respond
 * in the event of an error bubbling through the stack.
 *
 * @private
 */

app.handle = function handle(req, res, callback) {
  var router = this._router;

  // final handler
  var done = callback || finalhandler(req, res, {
    env: this.get('env'),
    onerror: logerror.bind(this)
  });

  // no routes
  if (!router) {
    debug('no routes defined on app');
    done();
    return;
  }

  router.handle(req, res, done);
};

/**
 * Proxy `Router#use()` to add middleware to the app router.
 * See Router#use() documentation for details.
 *
 * If the _fn_ parameter is an express app, then it will be
 * mounted at the _route_ specified.
 *
 * @public
 */

app.use = function use(fn) {
  var offset = 0;
  var path = '/';

  // default path to '/'
  // disambiguate app.use([fn])
  if (typeof fn !== 'function') {
    var arg = fn;

    while (Array.isArray(arg) && arg.length !== 0) {
      arg = arg[0];
    }

    // first arg is the path
    if (typeof arg !== 'function') {
      offset = 1;
      path = fn;
    }
  }

  var fns = flatten(slice.call(arguments, offset));

  if (fns.length === 0) {
    throw new TypeError('app.use() requires a middleware function')
  }

  // setup router
  this.lazyrouter();
  var router = this._router;

  fns.forEach(function (fn) {
    // non-express app
    if (!fn || !fn.handle || !fn.set) {
      return router.use(path, fn);
    }

    debug('.use app under %s', path);
    fn.mountpath = path;
    fn.parent = this;

    // restore .app property on req and res
    router.use(path, function mounted_app(req, res, next) {
      var orig = req.app;
      fn.handle(req, res, function (err) {
        setPrototypeOf(req, orig.request)
        setPrototypeOf(res, orig.response)
        next(err);
      });
    });

    // mounted an app
    fn.emit('mount', this);
  }, this);

  return this;
};

/**
 * Proxy to the app `Router#route()`
 * Returns a new `Route` instance for the _path_.
 *
 * Routes are isolated middleware stacks for specific paths.
 * See the Route api docs for details.
 *
 * @public
 */

app.route = function route(path) {
  this.lazyrouter();
  return this._router.route(path);
};

/**
 * Register the given template engine callback `fn`
 * as `ext`.
 *
 * By default will `require()` the engine based on the
 * file extension. For example if you try to render
 * a "foo.ejs" file Express will invoke the following internally:
 *
 *     app.engine('ejs', require('ejs').__express);
 *
 * For engines that do not provide `.__express` out of the box,
 * or if you wish to "map" a different extension to the template engine
 * you may use this method. For example mapping the EJS template engine to
 * ".html" files:
 *
 *     app.engine('html', require('ejs').renderFile);
 *
 * In this case EJS provides a `.renderFile()` method with
 * the same signature that Express expects: `(path, options, callback)`,
 * though note that it aliases this method as `ejs.__express` internally
 * so if you're using ".ejs" extensions you don't need to do anything.
 *
 * Some template engines do not follow this convention, the
 * [Consolidate.js](https://github.com/tj/consolidate.js)
 * library was created to map all of node's popular template
 * engines to follow this convention, thus allowing them to
 * work seamlessly within Express.
 *
 * @param {String} ext
 * @param {Function} fn
 * @return {app} for chaining
 * @public
 */

app.engine = function engine(ext, fn) {
  if (typeof fn !== 'function') {
    throw new Error('callback function required');
  }

  // get file extension
  var extension = ext[0] !== '.'
    ? '.' + ext
    : ext;

  // store engine
  this.engines[extension] = fn;

  return this;
};

/**
 * Proxy to `Router#param()` with one added api feature. The _name_ parameter
 * can be an array of names.
 *
 * See the Router#param() docs for more details.
 *
 * @param {String|Array} name
 * @param {Function} fn
 * @return {app} for chaining
 * @public
 */

app.param = function param(name, fn) {
  this.lazyrouter();

  if (Array.isArray(name)) {
    for (var i = 0; i < name.length; i++) {
      this.param(name[i], fn);
    }

    return this;
  }

  this._router.param(name, fn);

  return this;
};

/**
 * Assign `setting` to `val`, or return `setting`'s value.
 *
 *    app.set('foo', 'bar');
 *    app.set('foo');
 *    // => "bar"
 *
 * Mounted servers inherit their parent server's settings.
 *
 * @param {String} setting
 * @param {*} [val]
 * @return {Server} for chaining
 * @public
 */

app.set = function set(setting, val) {
  if (arguments.length === 1) {
    // app.get(setting)
    var settings = this.settings

    while (settings && settings !== Object.prototype) {
      if (hasOwnProperty.call(settings, setting)) {
        return settings[setting]
      }

      settings = Object.getPrototypeOf(settings)
    }

    return undefined
  }

  debug('set "%s" to %o', setting, val);

  // set value
  this.settings[setting] = val;

  // trigger matched settings
  switch (setting) {
    case 'etag':
      this.set('etag fn', compileETag(val));
      break;
    case 'query parser':
      this.set('query parser fn', compileQueryParser(val));
      break;
    case 'trust proxy':
      this.set('trust proxy fn', compileTrust(val));

      // trust proxy inherit back-compat
      Object.defineProperty(this.settings, trustProxyDefaultSymbol, {
        configurable: true,
        value: false
      });

      break;
  }

  return this;
};

/**
 * Return the app's absolute pathname
 * based on the parent(s) that have
 * mounted it.
 *
 * For example if the application was
 * mounted as "/admin", which itself
 * was mounted as "/blog" then the
 * return value would be "/blog/admin".
 *
 * @return {String}
 * @private
 */

app.path = function path() {
  return this.parent
    ? this.parent.path() + this.mountpath
    : '';
};

/**
 * Check if `setting` is enabled (truthy).
 *
 *    app.enabled('foo')
 *    // => false
 *
 *    app.enable('foo')
 *    app.enabled('foo')
 *    // => true
 *
 * @param {String} setting
 * @return {Boolean}
 * @public
 */

app.enabled = function enabled(setting) {
  return Boolean(this.set(setting));
};

/**
 * Check if `setting` is disabled.
 *
 *    app.disabled('foo')
 *    // => true
 *
 *    app.enable('foo')
 *    app.disabled('foo')
 *    // => false
 *
 * @param {String} setting
 * @return {Boolean}
 * @public
 */

app.disabled = function disabled(setting) {
  return !this.set(setting);
};

/**
 * Enable `setting`.
 *
 * @param {String} setting
 * @return {app} for chaining
 * @public
 */

app.enable = function enable(setting) {
  return this.set(setting, true);
};

/**
 * Disable `setting`.
 *
 * @param {String} setting
 * @return {app} for chaining
 * @public
 */

app.disable = function disable(setting) {
  return this.set(setting, false);
};

/**
 * Delegate `.VERB(...)` calls to `router.VERB(...)`.
 */

methods.forEach(function(method){
  app[method] = function(path){
    if (method === 'get' && arguments.length === 1) {
      // app.get(setting)
      return this.set(path);
    }

    this.lazyrouter();

    var route = this._router.route(path);
    route[method].apply(route, slice.call(arguments, 1));
    return this;
  };
});

/**
 * Special-cased "all" method, applying the given route `path`,
 * middleware, and callback to _every_ HTTP method.
 *
 * @param {String} path
 * @param {Function} ...
 * @return {app} for chaining
 * @public
 */

app.all = function all(path) {
  this.lazyrouter();

  var route = this._router.route(path);
  var args = slice.call(arguments, 1);

  for (var i = 0; i < methods.length; i++) {
    route[methods[i]].apply(route, args);
  }

  return this;
};

// del -> delete alias

app.del = deprecate.function(app.delete, 'app.del: Use app.delete instead');

/**
 * Render the given view `name` name with `options`
 * and a callback accepting an error and the
 * rendered template string.
 *
 * Example:
 *
 *    app.render('email', { name: 'Tobi' }, function(err, html){
 *      // ...
 *    })
 *
 * @param {String} name
 * @param {Object|Function} options or fn
 * @param {Function} callback
 * @public
 */

app.render = function render(name, options, callback) {
  var cache = this.cache;
  var done = callback;
  var engines = this.engines;
  var opts = options;
  var renderOptions = {};
  var view;

  // support callback function as second arg
  if (typeof options === 'function') {
    done = options;
    opts = {};
  }

  // merge app.locals
  merge(renderOptions, this.locals);

  // merge options._locals
  if (opts._locals) {
    merge(renderOptions, opts._locals);
  }

  // merge options
  merge(renderOptions, opts);

  // set .cache unless explicitly provided
  if (renderOptions.cache == null) {
    renderOptions.cache = this.enabled('view cache');
  }

  // primed cache
  if (renderOptions.cache) {
    view = cache[name];
  }

  // view
  if (!view) {
    var View = this.get('view');

    view = new View(name, {
      defaultEngine: this.get('view engine'),
      root: this.get('views'),
      engines: engines
    });

    if (!view.path) {
      var dirs = Array.isArray(view.root) && view.root.length > 1
        ? 'directories "' + view.root.slice(0, -1).join('", "') + '" or "' + view.root[view.root.length - 1] + '"'
        : 'directory "' + view.root + '"'
      var err = new Error('Failed to lookup view "' + name + '" in views ' + dirs);
      err.view = view;
      return done(err);
    }

    // prime the cache
    if (renderOptions.cache) {
      cache[name] = view;
    }
  }

  // render
  tryRender(view, renderOptions, done);
};

/**
 * Listen for connections.
 *
 * A node `http.Server` is returned, with this
 * application (which is a `Function`) as its
 * callback. If you wish to create both an HTTP
 * and HTTPS server you may do so with the "http"
 * and "https" modules as shown here:
 *
 *    var http = require('http')
 *      , https = require('https')
 *      , express = require('express')
 *      , app = express();
 *
 *    http.createServer(app).listen(80);
 *    https.createServer({ ... }, app).listen(443);
 *
 * @return {http.Server}
 * @public
 */

app.listen = function listen() {
  var server = http.createServer(this);
  return server.listen.apply(server, arguments);
};

/**
 * Log error using console.error.
 *
 * @param {Error} err
 * @private
 */

function logerror(err) {
  /* istanbul ignore next */
  if (this.get('env') !== 'test') console.error(err.stack || err.toString());
}

/**
 * Try rendering a view.
 * @private
 */

function tryRender(view, options, callback) {
  try {
    view.render(options, callback);
  } catch (err) {
    callback(err);
  }
}


/***/ }),

/***/ 99192:
/***/ ((module, exports, __nccwpck_require__) => {

"use strict";
/*!
 * express
 * Copyright(c) 2009-2013 TJ Holowaychuk
 * Copyright(c) 2013 Roman Shtylman
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module dependencies.
 */

var bodyParser = __nccwpck_require__(6536)
var EventEmitter = (__nccwpck_require__(24434).EventEmitter);
var mixin = __nccwpck_require__(41339);
var proto = __nccwpck_require__(75314);
var Route = __nccwpck_require__(84049);
var Router = __nccwpck_require__(68240);
var req = __nccwpck_require__(30081);
var res = __nccwpck_require__(80917);

/**
 * Expose `createApplication()`.
 */

exports = module.exports = createApplication;

/**
 * Create an express application.
 *
 * @return {Function}
 * @api public
 */

function createApplication() {
  var app = function(req, res, next) {
    app.handle(req, res, next);
  };

  mixin(app, EventEmitter.prototype, false);
  mixin(app, proto, false);

  // expose the prototype that will get set on requests
  app.request = Object.create(req, {
    app: { configurable: true, enumerable: true, writable: true, value: app }
  })

  // expose the prototype that will get set on responses
  app.response = Object.create(res, {
    app: { configurable: true, enumerable: true, writable: true, value: app }
  })

  app.init();
  return app;
}

/**
 * Expose the prototypes.
 */

exports.application = proto;
exports.request = req;
exports.response = res;

/**
 * Expose constructors.
 */

exports.Route = Route;
exports.Router = Router;

/**
 * Expose middleware
 */

exports.json = bodyParser.json
exports.query = __nccwpck_require__(64321);
exports.raw = bodyParser.raw
exports["static"] = __nccwpck_require__(96004);
exports.text = bodyParser.text
exports.urlencoded = bodyParser.urlencoded

/**
 * Replace removed middleware with an appropriate error message.
 */

var removedMiddlewares = [
  'bodyParser',
  'compress',
  'cookieSession',
  'session',
  'logger',
  'cookieParser',
  'favicon',
  'responseTime',
  'errorHandler',
  'timeout',
  'methodOverride',
  'vhost',
  'csrf',
  'directory',
  'limit',
  'multipart',
  'staticCache'
]

removedMiddlewares.forEach(function (name) {
  Object.defineProperty(exports, name, {
    get: function () {
      throw new Error('Most middleware (like ' + name + ') is no longer bundled with Express and must be installed separately. Please see https://github.com/senchalabs/connect#middleware.');
    },
    configurable: true
  });
});


/***/ }),

/***/ 90791:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";
/*!
 * express
 * Copyright(c) 2009-2013 TJ Holowaychuk
 * Copyright(c) 2013 Roman Shtylman
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module dependencies.
 * @private
 */

var setPrototypeOf = __nccwpck_require__(41015)

/**
 * Initialization middleware, exposing the
 * request and response to each other, as well
 * as defaulting the X-Powered-By header field.
 *
 * @param {Function} app
 * @return {Function}
 * @api private
 */

exports.init = function(app){
  return function expressInit(req, res, next){
    if (app.enabled('x-powered-by')) res.setHeader('X-Powered-By', 'Express');
    req.res = res;
    res.req = req;
    req.next = next;

    setPrototypeOf(req, app.request)
    setPrototypeOf(res, app.response)

    res.locals = res.locals || Object.create(null);

    next();
  };
};



/***/ }),

/***/ 64321:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";
/*!
 * express
 * Copyright(c) 2009-2013 TJ Holowaychuk
 * Copyright(c) 2013 Roman Shtylman
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module dependencies.
 */

var merge = __nccwpck_require__(51448)
var parseUrl = __nccwpck_require__(83404);
var qs = __nccwpck_require__(40240);

/**
 * @param {Object} options
 * @return {Function}
 * @api public
 */

module.exports = function query(options) {
  var opts = merge({}, options)
  var queryparse = qs.parse;

  if (typeof options === 'function') {
    queryparse = options;
    opts = undefined;
  }

  if (opts !== undefined && opts.allowPrototypes === undefined) {
    // back-compat for qs module
    opts.allowPrototypes = true;
  }

  return function query(req, res, next){
    if (!req.query) {
      var val = parseUrl(req).query;
      req.query = queryparse(val, opts);
    }

    next();
  };
};


/***/ }),

/***/ 30081:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";
/*!
 * express
 * Copyright(c) 2009-2013 TJ Holowaychuk
 * Copyright(c) 2013 Roman Shtylman
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module dependencies.
 * @private
 */

var accepts = __nccwpck_require__(86661);
var deprecate = __nccwpck_require__(60095)('express');
var isIP = (__nccwpck_require__(69278).isIP);
var typeis = __nccwpck_require__(27323);
var http = __nccwpck_require__(58611);
var fresh = __nccwpck_require__(53136);
var parseRange = __nccwpck_require__(74031);
var parse = __nccwpck_require__(83404);
var proxyaddr = __nccwpck_require__(98916);

/**
 * Request prototype.
 * @public
 */

var req = Object.create(http.IncomingMessage.prototype)

/**
 * Module exports.
 * @public
 */

module.exports = req

/**
 * Return request header.
 *
 * The `Referrer` header field is special-cased,
 * both `Referrer` and `Referer` are interchangeable.
 *
 * Examples:
 *
 *     req.get('Content-Type');
 *     // => "text/plain"
 *
 *     req.get('content-type');
 *     // => "text/plain"
 *
 *     req.get('Something');
 *     // => undefined
 *
 * Aliased as `req.header()`.
 *
 * @param {String} name
 * @return {String}
 * @public
 */

req.get =
req.header = function header(name) {
  if (!name) {
    throw new TypeError('name argument is required to req.get');
  }

  if (typeof name !== 'string') {
    throw new TypeError('name must be a string to req.get');
  }

  var lc = name.toLowerCase();

  switch (lc) {
    case 'referer':
    case 'referrer':
      return this.headers.referrer
        || this.headers.referer;
    default:
      return this.headers[lc];
  }
};

/**
 * To do: update docs.
 *
 * Check if the given `type(s)` is acceptable, returning
 * the best match when true, otherwise `undefined`, in which
 * case you should respond with 406 "Not Acceptable".
 *
 * The `type` value may be a single MIME type string
 * such as "application/json", an extension name
 * such as "json", a comma-delimited list such as "json, html, text/plain",
 * an argument list such as `"json", "html", "text/plain"`,
 * or an array `["json", "html", "text/plain"]`. When a list
 * or array is given, the _best_ match, if any is returned.
 *
 * Examples:
 *
 *     // Accept: text/html
 *     req.accepts('html');
 *     // => "html"
 *
 *     // Accept: text/*, application/json
 *     req.accepts('html');
 *     // => "html"
 *     req.accepts('text/html');
 *     // => "text/html"
 *     req.accepts('json, text');
 *     // => "json"
 *     req.accepts('application/json');
 *     // => "application/json"
 *
 *     // Accept: text/*, application/json
 *     req.accepts('image/png');
 *     req.accepts('png');
 *     // => undefined
 *
 *     // Accept: text/*;q=.5, application/json
 *     req.accepts(['html', 'json']);
 *     req.accepts('html', 'json');
 *     req.accepts('html, json');
 *     // => "json"
 *
 * @param {String|Array} type(s)
 * @return {String|Array|Boolean}
 * @public
 */

req.accepts = function(){
  var accept = accepts(this);
  return accept.types.apply(accept, arguments);
};

/**
 * Check if the given `encoding`s are accepted.
 *
 * @param {String} ...encoding
 * @return {String|Array}
 * @public
 */

req.acceptsEncodings = function(){
  var accept = accepts(this);
  return accept.encodings.apply(accept, arguments);
};

req.acceptsEncoding = deprecate.function(req.acceptsEncodings,
  'req.acceptsEncoding: Use acceptsEncodings instead');

/**
 * Check if the given `charset`s are acceptable,
 * otherwise you should respond with 406 "Not Acceptable".
 *
 * @param {String} ...charset
 * @return {String|Array}
 * @public
 */

req.acceptsCharsets = function(){
  var accept = accepts(this);
  return accept.charsets.apply(accept, arguments);
};

req.acceptsCharset = deprecate.function(req.acceptsCharsets,
  'req.acceptsCharset: Use acceptsCharsets instead');

/**
 * Check if the given `lang`s are acceptable,
 * otherwise you should respond with 406 "Not Acceptable".
 *
 * @param {String} ...lang
 * @return {String|Array}
 * @public
 */

req.acceptsLanguages = function(){
  var accept = accepts(this);
  return accept.languages.apply(accept, arguments);
};

req.acceptsLanguage = deprecate.function(req.acceptsLanguages,
  'req.acceptsLanguage: Use acceptsLanguages instead');

/**
 * Parse Range header field, capping to the given `size`.
 *
 * Unspecified ranges such as "0-" require knowledge of your resource length. In
 * the case of a byte range this is of course the total number of bytes. If the
 * Range header field is not given `undefined` is returned, `-1` when unsatisfiable,
 * and `-2` when syntactically invalid.
 *
 * When ranges are returned, the array has a "type" property which is the type of
 * range that is required (most commonly, "bytes"). Each array element is an object
 * with a "start" and "end" property for the portion of the range.
 *
 * The "combine" option can be set to `true` and overlapping & adjacent ranges
 * will be combined into a single range.
 *
 * NOTE: remember that ranges are inclusive, so for example "Range: users=0-3"
 * should respond with 4 users when available, not 3.
 *
 * @param {number} size
 * @param {object} [options]
 * @param {boolean} [options.combine=false]
 * @return {number|array}
 * @public
 */

req.range = function range(size, options) {
  var range = this.get('Range');
  if (!range) return;
  return parseRange(size, range, options);
};

/**
 * Return the value of param `name` when present or `defaultValue`.
 *
 *  - Checks route placeholders, ex: _/user/:id_
 *  - Checks body params, ex: id=12, {"id":12}
 *  - Checks query string params, ex: ?id=12
 *
 * To utilize request bodies, `req.body`
 * should be an object. This can be done by using
 * the `bodyParser()` middleware.
 *
 * @param {String} name
 * @param {Mixed} [defaultValue]
 * @return {String}
 * @public
 */

req.param = function param(name, defaultValue) {
  var params = this.params || {};
  var body = this.body || {};
  var query = this.query || {};

  var args = arguments.length === 1
    ? 'name'
    : 'name, default';
  deprecate('req.param(' + args + '): Use req.params, req.body, or req.query instead');

  if (null != params[name] && params.hasOwnProperty(name)) return params[name];
  if (null != body[name]) return body[name];
  if (null != query[name]) return query[name];

  return defaultValue;
};

/**
 * Check if the incoming request contains the "Content-Type"
 * header field, and it contains the given mime `type`.
 *
 * Examples:
 *
 *      // With Content-Type: text/html; charset=utf-8
 *      req.is('html');
 *      req.is('text/html');
 *      req.is('text/*');
 *      // => true
 *
 *      // When Content-Type is application/json
 *      req.is('json');
 *      req.is('application/json');
 *      req.is('application/*');
 *      // => true
 *
 *      req.is('html');
 *      // => false
 *
 * @param {String|Array} types...
 * @return {String|false|null}
 * @public
 */

req.is = function is(types) {
  var arr = types;

  // support flattened arguments
  if (!Array.isArray(types)) {
    arr = new Array(arguments.length);
    for (var i = 0; i < arr.length; i++) {
      arr[i] = arguments[i];
    }
  }

  return typeis(this, arr);
};

/**
 * Return the protocol string "http" or "https"
 * when requested with TLS. When the "trust proxy"
 * setting trusts the socket address, the
 * "X-Forwarded-Proto" header field will be trusted
 * and used if present.
 *
 * If you're running behind a reverse proxy that
 * supplies https for you this may be enabled.
 *
 * @return {String}
 * @public
 */

defineGetter(req, 'protocol', function protocol(){
  var proto = this.connection.encrypted
    ? 'https'
    : 'http';
  var trust = this.app.get('trust proxy fn');

  if (!trust(this.connection.remoteAddress, 0)) {
    return proto;
  }

  // Note: X-Forwarded-Proto is normally only ever a
  //       single value, but this is to be safe.
  var header = this.get('X-Forwarded-Proto') || proto
  var index = header.indexOf(',')

  return index !== -1
    ? header.substring(0, index).trim()
    : header.trim()
});

/**
 * Short-hand for:
 *
 *    req.protocol === 'https'
 *
 * @return {Boolean}
 * @public
 */

defineGetter(req, 'secure', function secure(){
  return this.protocol === 'https';
});

/**
 * Return the remote address from the trusted proxy.
 *
 * The is the remote address on the socket unless
 * "trust proxy" is set.
 *
 * @return {String}
 * @public
 */

defineGetter(req, 'ip', function ip(){
  var trust = this.app.get('trust proxy fn');
  return proxyaddr(this, trust);
});

/**
 * When "trust proxy" is set, trusted proxy addresses + client.
 *
 * For example if the value were "client, proxy1, proxy2"
 * you would receive the array `["client", "proxy1", "proxy2"]`
 * where "proxy2" is the furthest down-stream and "proxy1" and
 * "proxy2" were trusted.
 *
 * @return {Array}
 * @public
 */

defineGetter(req, 'ips', function ips() {
  var trust = this.app.get('trust proxy fn');
  var addrs = proxyaddr.all(this, trust);

  // reverse the order (to farthest -> closest)
  // and remove socket address
  addrs.reverse().pop()

  return addrs
});

/**
 * Return subdomains as an array.
 *
 * Subdomains are the dot-separated parts of the host before the main domain of
 * the app. By default, the domain of the app is assumed to be the last two
 * parts of the host. This can be changed by setting "subdomain offset".
 *
 * For example, if the domain is "tobi.ferrets.example.com":
 * If "subdomain offset" is not set, req.subdomains is `["ferrets", "tobi"]`.
 * If "subdomain offset" is 3, req.subdomains is `["tobi"]`.
 *
 * @return {Array}
 * @public
 */

defineGetter(req, 'subdomains', function subdomains() {
  var hostname = this.hostname;

  if (!hostname) return [];

  var offset = this.app.get('subdomain offset');
  var subdomains = !isIP(hostname)
    ? hostname.split('.').reverse()
    : [hostname];

  return subdomains.slice(offset);
});

/**
 * Short-hand for `url.parse(req.url).pathname`.
 *
 * @return {String}
 * @public
 */

defineGetter(req, 'path', function path() {
  return parse(this).pathname;
});

/**
 * Parse the "Host" header field to a hostname.
 *
 * When the "trust proxy" setting trusts the socket
 * address, the "X-Forwarded-Host" header field will
 * be trusted.
 *
 * @return {String}
 * @public
 */

defineGetter(req, 'hostname', function hostname(){
  var trust = this.app.get('trust proxy fn');
  var host = this.get('X-Forwarded-Host');

  if (!host || !trust(this.connection.remoteAddress, 0)) {
    host = this.get('Host');
  } else if (host.indexOf(',') !== -1) {
    // Note: X-Forwarded-Host is normally only ever a
    //       single value, but this is to be safe.
    host = host.substring(0, host.indexOf(',')).trimRight()
  }

  if (!host) return;

  // IPv6 literal support
  var offset = host[0] === '['
    ? host.indexOf(']') + 1
    : 0;
  var index = host.indexOf(':', offset);

  return index !== -1
    ? host.substring(0, index)
    : host;
});

// TODO: change req.host to return host in next major

defineGetter(req, 'host', deprecate.function(function host(){
  return this.hostname;
}, 'req.host: Use req.hostname instead'));

/**
 * Check if the request is fresh, aka
 * Last-Modified and/or the ETag
 * still match.
 *
 * @return {Boolean}
 * @public
 */

defineGetter(req, 'fresh', function(){
  var method = this.method;
  var res = this.res
  var status = res.statusCode

  // GET or HEAD for weak freshness validation only
  if ('GET' !== method && 'HEAD' !== method) return false;

  // 2xx or 304 as per rfc2616 14.26
  if ((status >= 200 && status < 300) || 304 === status) {
    return fresh(this.headers, {
      'etag': res.get('ETag'),
      'last-modified': res.get('Last-Modified')
    })
  }

  return false;
});

/**
 * Check if the request is stale, aka
 * "Last-Modified" and / or the "ETag" for the
 * resource has changed.
 *
 * @return {Boolean}
 * @public
 */

defineGetter(req, 'stale', function stale(){
  return !this.fresh;
});

/**
 * Check if the request was an _XMLHttpRequest_.
 *
 * @return {Boolean}
 * @public
 */

defineGetter(req, 'xhr', function xhr(){
  var val = this.get('X-Requested-With') || '';
  return val.toLowerCase() === 'xmlhttprequest';
});

/**
 * Helper function for creating a getter on an object.
 *
 * @param {Object} obj
 * @param {String} name
 * @param {Function} getter
 * @private
 */
function defineGetter(obj, name, getter) {
  Object.defineProperty(obj, name, {
    configurable: true,
    enumerable: true,
    get: getter
  });
}


/***/ }),

/***/ 80917:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";
/*!
 * express
 * Copyright(c) 2009-2013 TJ Holowaychuk
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module dependencies.
 * @private
 */

var Buffer = (__nccwpck_require__(93058).Buffer)
var contentDisposition = __nccwpck_require__(18111);
var createError = __nccwpck_require__(78024)
var deprecate = __nccwpck_require__(60095)('express');
var encodeUrl = __nccwpck_require__(83835);
var escapeHtml = __nccwpck_require__(12759);
var http = __nccwpck_require__(58611);
var isAbsolute = (__nccwpck_require__(89253).isAbsolute);
var onFinished = __nccwpck_require__(5698);
var path = __nccwpck_require__(16928);
var statuses = __nccwpck_require__(44650)
var merge = __nccwpck_require__(51448);
var sign = (__nccwpck_require__(34349).sign);
var normalizeType = (__nccwpck_require__(89253).normalizeType);
var normalizeTypes = (__nccwpck_require__(89253).normalizeTypes);
var setCharset = (__nccwpck_require__(89253).setCharset);
var cookie = __nccwpck_require__(3814);
var send = __nccwpck_require__(60814);
var extname = path.extname;
var mime = send.mime;
var resolve = path.resolve;
var vary = __nccwpck_require__(45116);

/**
 * Response prototype.
 * @public
 */

var res = Object.create(http.ServerResponse.prototype)

/**
 * Module exports.
 * @public
 */

module.exports = res

/**
 * Module variables.
 * @private
 */

var charsetRegExp = /;\s*charset\s*=/;

/**
 * Set status `code`.
 *
 * @param {Number} code
 * @return {ServerResponse}
 * @public
 */

res.status = function status(code) {
  if ((typeof code === 'string' || Math.floor(code) !== code) && code > 99 && code < 1000) {
    deprecate('res.status(' + JSON.stringify(code) + '): use res.status(' + Math.floor(code) + ') instead')
  }
  this.statusCode = code;
  return this;
};

/**
 * Set Link header field with the given `links`.
 *
 * Examples:
 *
 *    res.links({
 *      next: 'http://api.example.com/users?page=2',
 *      last: 'http://api.example.com/users?page=5'
 *    });
 *
 * @param {Object} links
 * @return {ServerResponse}
 * @public
 */

res.links = function(links){
  var link = this.get('Link') || '';
  if (link) link += ', ';
  return this.set('Link', link + Object.keys(links).map(function(rel){
    return '<' + links[rel] + '>; rel="' + rel + '"';
  }).join(', '));
};

/**
 * Send a response.
 *
 * Examples:
 *
 *     res.send(Buffer.from('wahoo'));
 *     res.send({ some: 'json' });
 *     res.send('<p>some html</p>');
 *
 * @param {string|number|boolean|object|Buffer} body
 * @public
 */

res.send = function send(body) {
  var chunk = body;
  var encoding;
  var req = this.req;
  var type;

  // settings
  var app = this.app;

  // allow status / body
  if (arguments.length === 2) {
    // res.send(body, status) backwards compat
    if (typeof arguments[0] !== 'number' && typeof arguments[1] === 'number') {
      deprecate('res.send(body, status): Use res.status(status).send(body) instead');
      this.statusCode = arguments[1];
    } else {
      deprecate('res.send(status, body): Use res.status(status).send(body) instead');
      this.statusCode = arguments[0];
      chunk = arguments[1];
    }
  }

  // disambiguate res.send(status) and res.send(status, num)
  if (typeof chunk === 'number' && arguments.length === 1) {
    // res.send(status) will set status message as text string
    if (!this.get('Content-Type')) {
      this.type('txt');
    }

    deprecate('res.send(status): Use res.sendStatus(status) instead');
    this.statusCode = chunk;
    chunk = statuses.message[chunk]
  }

  switch (typeof chunk) {
    // string defaulting to html
    case 'string':
      if (!this.get('Content-Type')) {
        this.type('html');
      }
      break;
    case 'boolean':
    case 'number':
    case 'object':
      if (chunk === null) {
        chunk = '';
      } else if (Buffer.isBuffer(chunk)) {
        if (!this.get('Content-Type')) {
          this.type('bin');
        }
      } else {
        return this.json(chunk);
      }
      break;
  }

  // write strings in utf-8
  if (typeof chunk === 'string') {
    encoding = 'utf8';
    type = this.get('Content-Type');

    // reflect this in content-type
    if (typeof type === 'string') {
      this.set('Content-Type', setCharset(type, 'utf-8'));
    }
  }

  // determine if ETag should be generated
  var etagFn = app.get('etag fn')
  var generateETag = !this.get('ETag') && typeof etagFn === 'function'

  // populate Content-Length
  var len
  if (chunk !== undefined) {
    if (Buffer.isBuffer(chunk)) {
      // get length of Buffer
      len = chunk.length
    } else if (!generateETag && chunk.length < 1000) {
      // just calculate length when no ETag + small chunk
      len = Buffer.byteLength(chunk, encoding)
    } else {
      // convert chunk to Buffer and calculate
      chunk = Buffer.from(chunk, encoding)
      encoding = undefined;
      len = chunk.length
    }

    this.set('Content-Length', len);
  }

  // populate ETag
  var etag;
  if (generateETag && len !== undefined) {
    if ((etag = etagFn(chunk, encoding))) {
      this.set('ETag', etag);
    }
  }

  // freshness
  if (req.fresh) this.statusCode = 304;

  // strip irrelevant headers
  if (204 === this.statusCode || 304 === this.statusCode) {
    this.removeHeader('Content-Type');
    this.removeHeader('Content-Length');
    this.removeHeader('Transfer-Encoding');
    chunk = '';
  }

  // alter headers for 205
  if (this.statusCode === 205) {
    this.set('Content-Length', '0')
    this.removeHeader('Transfer-Encoding')
    chunk = ''
  }

  if (req.method === 'HEAD') {
    // skip body for HEAD
    this.end();
  } else {
    // respond
    this.end(chunk, encoding);
  }

  return this;
};

/**
 * Send JSON response.
 *
 * Examples:
 *
 *     res.json(null);
 *     res.json({ user: 'tj' });
 *
 * @param {string|number|boolean|object} obj
 * @public
 */

res.json = function json(obj) {
  var val = obj;

  // allow status / body
  if (arguments.length === 2) {
    // res.json(body, status) backwards compat
    if (typeof arguments[1] === 'number') {
      deprecate('res.json(obj, status): Use res.status(status).json(obj) instead');
      this.statusCode = arguments[1];
    } else {
      deprecate('res.json(status, obj): Use res.status(status).json(obj) instead');
      this.statusCode = arguments[0];
      val = arguments[1];
    }
  }

  // settings
  var app = this.app;
  var escape = app.get('json escape')
  var replacer = app.get('json replacer');
  var spaces = app.get('json spaces');
  var body = stringify(val, replacer, spaces, escape)

  // content-type
  if (!this.get('Content-Type')) {
    this.set('Content-Type', 'application/json');
  }

  return this.send(body);
};

/**
 * Send JSON response with JSONP callback support.
 *
 * Examples:
 *
 *     res.jsonp(null);
 *     res.jsonp({ user: 'tj' });
 *
 * @param {string|number|boolean|object} obj
 * @public
 */

res.jsonp = function jsonp(obj) {
  var val = obj;

  // allow status / body
  if (arguments.length === 2) {
    // res.jsonp(body, status) backwards compat
    if (typeof arguments[1] === 'number') {
      deprecate('res.jsonp(obj, status): Use res.status(status).jsonp(obj) instead');
      this.statusCode = arguments[1];
    } else {
      deprecate('res.jsonp(status, obj): Use res.status(status).jsonp(obj) instead');
      this.statusCode = arguments[0];
      val = arguments[1];
    }
  }

  // settings
  var app = this.app;
  var escape = app.get('json escape')
  var replacer = app.get('json replacer');
  var spaces = app.get('json spaces');
  var body = stringify(val, replacer, spaces, escape)
  var callback = this.req.query[app.get('jsonp callback name')];

  // content-type
  if (!this.get('Content-Type')) {
    this.set('X-Content-Type-Options', 'nosniff');
    this.set('Content-Type', 'application/json');
  }

  // fixup callback
  if (Array.isArray(callback)) {
    callback = callback[0];
  }

  // jsonp
  if (typeof callback === 'string' && callback.length !== 0) {
    this.set('X-Content-Type-Options', 'nosniff');
    this.set('Content-Type', 'text/javascript');

    // restrict callback charset
    callback = callback.replace(/[^\[\]\w$.]/g, '');

    if (body === undefined) {
      // empty argument
      body = ''
    } else if (typeof body === 'string') {
      // replace chars not allowed in JavaScript that are in JSON
      body = body
        .replace(/\u2028/g, '\\u2028')
        .replace(/\u2029/g, '\\u2029')
    }

    // the /**/ is a specific security mitigation for "Rosetta Flash JSONP abuse"
    // the typeof check is just to reduce client error noise
    body = '/**/ typeof ' + callback + ' === \'function\' && ' + callback + '(' + body + ');';
  }

  return this.send(body);
};

/**
 * Send given HTTP status code.
 *
 * Sets the response status to `statusCode` and the body of the
 * response to the standard description from node's http.STATUS_CODES
 * or the statusCode number if no description.
 *
 * Examples:
 *
 *     res.sendStatus(200);
 *
 * @param {number} statusCode
 * @public
 */

res.sendStatus = function sendStatus(statusCode) {
  var body = statuses.message[statusCode] || String(statusCode)

  this.statusCode = statusCode;
  this.type('txt');

  return this.send(body);
};

/**
 * Transfer the file at the given `path`.
 *
 * Automatically sets the _Content-Type_ response header field.
 * The callback `callback(err)` is invoked when the transfer is complete
 * or when an error occurs. Be sure to check `res.headersSent`
 * if you wish to attempt responding, as the header and some data
 * may have already been transferred.
 *
 * Options:
 *
 *   - `maxAge`   defaulting to 0 (can be string converted by `ms`)
 *   - `root`     root directory for relative filenames
 *   - `headers`  object of headers to serve with file
 *   - `dotfiles` serve dotfiles, defaulting to false; can be `"allow"` to send them
 *
 * Other options are passed along to `send`.
 *
 * Examples:
 *
 *  The following example illustrates how `res.sendFile()` may
 *  be used as an alternative for the `static()` middleware for
 *  dynamic situations. The code backing `res.sendFile()` is actually
 *  the same code, so HTTP cache support etc is identical.
 *
 *     app.get('/user/:uid/photos/:file', function(req, res){
 *       var uid = req.params.uid
 *         , file = req.params.file;
 *
 *       req.user.mayViewFilesFrom(uid, function(yes){
 *         if (yes) {
 *           res.sendFile('/uploads/' + uid + '/' + file);
 *         } else {
 *           res.send(403, 'Sorry! you cant see that.');
 *         }
 *       });
 *     });
 *
 * @public
 */

res.sendFile = function sendFile(path, options, callback) {
  var done = callback;
  var req = this.req;
  var res = this;
  var next = req.next;
  var opts = options || {};

  if (!path) {
    throw new TypeError('path argument is required to res.sendFile');
  }

  if (typeof path !== 'string') {
    throw new TypeError('path must be a string to res.sendFile')
  }

  // support function as second arg
  if (typeof options === 'function') {
    done = options;
    opts = {};
  }

  if (!opts.root && !isAbsolute(path)) {
    throw new TypeError('path must be absolute or specify root to res.sendFile');
  }

  // create file stream
  var pathname = encodeURI(path);
  var file = send(req, pathname, opts);

  // transfer
  sendfile(res, file, opts, function (err) {
    if (done) return done(err);
    if (err && err.code === 'EISDIR') return next();

    // next() all but write errors
    if (err && err.code !== 'ECONNABORTED' && err.syscall !== 'write') {
      next(err);
    }
  });
};

/**
 * Transfer the file at the given `path`.
 *
 * Automatically sets the _Content-Type_ response header field.
 * The callback `callback(err)` is invoked when the transfer is complete
 * or when an error occurs. Be sure to check `res.headersSent`
 * if you wish to attempt responding, as the header and some data
 * may have already been transferred.
 *
 * Options:
 *
 *   - `maxAge`   defaulting to 0 (can be string converted by `ms`)
 *   - `root`     root directory for relative filenames
 *   - `headers`  object of headers to serve with file
 *   - `dotfiles` serve dotfiles, defaulting to false; can be `"allow"` to send them
 *
 * Other options are passed along to `send`.
 *
 * Examples:
 *
 *  The following example illustrates how `res.sendfile()` may
 *  be used as an alternative for the `static()` middleware for
 *  dynamic situations. The code backing `res.sendfile()` is actually
 *  the same code, so HTTP cache support etc is identical.
 *
 *     app.get('/user/:uid/photos/:file', function(req, res){
 *       var uid = req.params.uid
 *         , file = req.params.file;
 *
 *       req.user.mayViewFilesFrom(uid, function(yes){
 *         if (yes) {
 *           res.sendfile('/uploads/' + uid + '/' + file);
 *         } else {
 *           res.send(403, 'Sorry! you cant see that.');
 *         }
 *       });
 *     });
 *
 * @public
 */

res.sendfile = function (path, options, callback) {
  var done = callback;
  var req = this.req;
  var res = this;
  var next = req.next;
  var opts = options || {};

  // support function as second arg
  if (typeof options === 'function') {
    done = options;
    opts = {};
  }

  // create file stream
  var file = send(req, path, opts);

  // transfer
  sendfile(res, file, opts, function (err) {
    if (done) return done(err);
    if (err && err.code === 'EISDIR') return next();

    // next() all but write errors
    if (err && err.code !== 'ECONNABORTED' && err.syscall !== 'write') {
      next(err);
    }
  });
};

res.sendfile = deprecate.function(res.sendfile,
  'res.sendfile: Use res.sendFile instead');

/**
 * Transfer the file at the given `path` as an attachment.
 *
 * Optionally providing an alternate attachment `filename`,
 * and optional callback `callback(err)`. The callback is invoked
 * when the data transfer is complete, or when an error has
 * occurred. Be sure to check `res.headersSent` if you plan to respond.
 *
 * Optionally providing an `options` object to use with `res.sendFile()`.
 * This function will set the `Content-Disposition` header, overriding
 * any `Content-Disposition` header passed as header options in order
 * to set the attachment and filename.
 *
 * This method uses `res.sendFile()`.
 *
 * @public
 */

res.download = function download (path, filename, options, callback) {
  var done = callback;
  var name = filename;
  var opts = options || null

  // support function as second or third arg
  if (typeof filename === 'function') {
    done = filename;
    name = null;
    opts = null
  } else if (typeof options === 'function') {
    done = options
    opts = null
  }

  // support optional filename, where options may be in it's place
  if (typeof filename === 'object' &&
    (typeof options === 'function' || options === undefined)) {
    name = null
    opts = filename
  }

  // set Content-Disposition when file is sent
  var headers = {
    'Content-Disposition': contentDisposition(name || path)
  };

  // merge user-provided headers
  if (opts && opts.headers) {
    var keys = Object.keys(opts.headers)
    for (var i = 0; i < keys.length; i++) {
      var key = keys[i]
      if (key.toLowerCase() !== 'content-disposition') {
        headers[key] = opts.headers[key]
      }
    }
  }

  // merge user-provided options
  opts = Object.create(opts)
  opts.headers = headers

  // Resolve the full path for sendFile
  var fullPath = !opts.root
    ? resolve(path)
    : path

  // send file
  return this.sendFile(fullPath, opts, done)
};

/**
 * Set _Content-Type_ response header with `type` through `mime.lookup()`
 * when it does not contain "/", or set the Content-Type to `type` otherwise.
 *
 * Examples:
 *
 *     res.type('.html');
 *     res.type('html');
 *     res.type('json');
 *     res.type('application/json');
 *     res.type('png');
 *
 * @param {String} type
 * @return {ServerResponse} for chaining
 * @public
 */

res.contentType =
res.type = function contentType(type) {
  var ct = type.indexOf('/') === -1
    ? mime.lookup(type)
    : type;

  return this.set('Content-Type', ct);
};

/**
 * Respond to the Acceptable formats using an `obj`
 * of mime-type callbacks.
 *
 * This method uses `req.accepted`, an array of
 * acceptable types ordered by their quality values.
 * When "Accept" is not present the _first_ callback
 * is invoked, otherwise the first match is used. When
 * no match is performed the server responds with
 * 406 "Not Acceptable".
 *
 * Content-Type is set for you, however if you choose
 * you may alter this within the callback using `res.type()`
 * or `res.set('Content-Type', ...)`.
 *
 *    res.format({
 *      'text/plain': function(){
 *        res.send('hey');
 *      },
 *
 *      'text/html': function(){
 *        res.send('<p>hey</p>');
 *      },
 *
 *      'application/json': function () {
 *        res.send({ message: 'hey' });
 *      }
 *    });
 *
 * In addition to canonicalized MIME types you may
 * also use extnames mapped to these types:
 *
 *    res.format({
 *      text: function(){
 *        res.send('hey');
 *      },
 *
 *      html: function(){
 *        res.send('<p>hey</p>');
 *      },
 *
 *      json: function(){
 *        res.send({ message: 'hey' });
 *      }
 *    });
 *
 * By default Express passes an `Error`
 * with a `.status` of 406 to `next(err)`
 * if a match is not made. If you provide
 * a `.default` callback it will be invoked
 * instead.
 *
 * @param {Object} obj
 * @return {ServerResponse} for chaining
 * @public
 */

res.format = function(obj){
  var req = this.req;
  var next = req.next;

  var keys = Object.keys(obj)
    .filter(function (v) { return v !== 'default' })

  var key = keys.length > 0
    ? req.accepts(keys)
    : false;

  this.vary("Accept");

  if (key) {
    this.set('Content-Type', normalizeType(key).value);
    obj[key](req, this, next);
  } else if (obj.default) {
    obj.default(req, this, next)
  } else {
    next(createError(406, {
      types: normalizeTypes(keys).map(function (o) { return o.value })
    }))
  }

  return this;
};

/**
 * Set _Content-Disposition_ header to _attachment_ with optional `filename`.
 *
 * @param {String} filename
 * @return {ServerResponse}
 * @public
 */

res.attachment = function attachment(filename) {
  if (filename) {
    this.type(extname(filename));
  }

  this.set('Content-Disposition', contentDisposition(filename));

  return this;
};

/**
 * Append additional header `field` with value `val`.
 *
 * Example:
 *
 *    res.append('Link', ['<http://localhost/>', '<http://localhost:3000/>']);
 *    res.append('Set-Cookie', 'foo=bar; Path=/; HttpOnly');
 *    res.append('Warning', '199 Miscellaneous warning');
 *
 * @param {String} field
 * @param {String|Array} val
 * @return {ServerResponse} for chaining
 * @public
 */

res.append = function append(field, val) {
  var prev = this.get(field);
  var value = val;

  if (prev) {
    // concat the new and prev vals
    value = Array.isArray(prev) ? prev.concat(val)
      : Array.isArray(val) ? [prev].concat(val)
        : [prev, val]
  }

  return this.set(field, value);
};

/**
 * Set header `field` to `val`, or pass
 * an object of header fields.
 *
 * Examples:
 *
 *    res.set('Foo', ['bar', 'baz']);
 *    res.set('Accept', 'application/json');
 *    res.set({ Accept: 'text/plain', 'X-API-Key': 'tobi' });
 *
 * Aliased as `res.header()`.
 *
 * @param {String|Object} field
 * @param {String|Array} val
 * @return {ServerResponse} for chaining
 * @public
 */

res.set =
res.header = function header(field, val) {
  if (arguments.length === 2) {
    var value = Array.isArray(val)
      ? val.map(String)
      : String(val);

    // add charset to content-type
    if (field.toLowerCase() === 'content-type') {
      if (Array.isArray(value)) {
        throw new TypeError('Content-Type cannot be set to an Array');
      }
      if (!charsetRegExp.test(value)) {
        var charset = mime.charsets.lookup(value.split(';')[0]);
        if (charset) value += '; charset=' + charset.toLowerCase();
      }
    }

    this.setHeader(field, value);
  } else {
    for (var key in field) {
      this.set(key, field[key]);
    }
  }
  return this;
};

/**
 * Get value for header `field`.
 *
 * @param {String} field
 * @return {String}
 * @public
 */

res.get = function(field){
  return this.getHeader(field);
};

/**
 * Clear cookie `name`.
 *
 * @param {String} name
 * @param {Object} [options]
 * @return {ServerResponse} for chaining
 * @public
 */

res.clearCookie = function clearCookie(name, options) {
  if (options) {
    if (options.maxAge) {
      deprecate('res.clearCookie: Passing "options.maxAge" is deprecated. In v5.0.0 of Express, this option will be ignored, as res.clearCookie will automatically set cookies to expire immediately. Please update your code to omit this option.');
    }
    if (options.expires) {
      deprecate('res.clearCookie: Passing "options.expires" is deprecated. In v5.0.0 of Express, this option will be ignored, as res.clearCookie will automatically set cookies to expire immediately. Please update your code to omit this option.');
    }
  }
  var opts = merge({ expires: new Date(1), path: '/' }, options);

  return this.cookie(name, '', opts);
};

/**
 * Set cookie `name` to `value`, with the given `options`.
 *
 * Options:
 *
 *    - `maxAge`   max-age in milliseconds, converted to `expires`
 *    - `signed`   sign the cookie
 *    - `path`     defaults to "/"
 *
 * Examples:
 *
 *    // "Remember Me" for 15 minutes
 *    res.cookie('rememberme', '1', { expires: new Date(Date.now() + 900000), httpOnly: true });
 *
 *    // same as above
 *    res.cookie('rememberme', '1', { maxAge: 900000, httpOnly: true })
 *
 * @param {String} name
 * @param {String|Object} value
 * @param {Object} [options]
 * @return {ServerResponse} for chaining
 * @public
 */

res.cookie = function (name, value, options) {
  var opts = merge({}, options);
  var secret = this.req.secret;
  var signed = opts.signed;

  if (signed && !secret) {
    throw new Error('cookieParser("secret") required for signed cookies');
  }

  var val = typeof value === 'object'
    ? 'j:' + JSON.stringify(value)
    : String(value);

  if (signed) {
    val = 's:' + sign(val, secret);
  }

  if (opts.maxAge != null) {
    var maxAge = opts.maxAge - 0

    if (!isNaN(maxAge)) {
      opts.expires = new Date(Date.now() + maxAge)
      opts.maxAge = Math.floor(maxAge / 1000)
    }
  }

  if (opts.path == null) {
    opts.path = '/';
  }

  this.append('Set-Cookie', cookie.serialize(name, String(val), opts));

  return this;
};

/**
 * Set the location header to `url`.
 *
 * The given `url` can also be "back", which redirects
 * to the _Referrer_ or _Referer_ headers or "/".
 *
 * Examples:
 *
 *    res.location('/foo/bar').;
 *    res.location('http://example.com');
 *    res.location('../login');
 *
 * @param {String} url
 * @return {ServerResponse} for chaining
 * @public
 */

res.location = function location(url) {
  var loc;

  // "back" is an alias for the referrer
  if (url === 'back') {
    deprecate('res.location("back"): use res.location(req.get("Referrer") || "/") and refer to https://dub.sh/security-redirect for best practices');
    loc = this.req.get('Referrer') || '/';
  } else {
    loc = String(url);
  }

  return this.set('Location', encodeUrl(loc));
};

/**
 * Redirect to the given `url` with optional response `status`
 * defaulting to 302.
 *
 * The resulting `url` is determined by `res.location()`, so
 * it will play nicely with mounted apps, relative paths,
 * `"back"` etc.
 *
 * Examples:
 *
 *    res.redirect('/foo/bar');
 *    res.redirect('http://example.com');
 *    res.redirect(301, 'http://example.com');
 *    res.redirect('../login'); // /blog/post/1 -> /blog/login
 *
 * @public
 */

res.redirect = function redirect(url) {
  var address = url;
  var body;
  var status = 302;

  // allow status / url
  if (arguments.length === 2) {
    if (typeof arguments[0] === 'number') {
      status = arguments[0];
      address = arguments[1];
    } else {
      deprecate('res.redirect(url, status): Use res.redirect(status, url) instead');
      status = arguments[1];
    }
  }

  // Set location header
  address = this.location(address).get('Location');

  // Support text/{plain,html} by default
  this.format({
    text: function(){
      body = statuses.message[status] + '. Redirecting to ' + address
    },

    html: function(){
      var u = escapeHtml(address);
      body = '<p>' + statuses.message[status] + '. Redirecting to ' + u + '</p>'
    },

    default: function(){
      body = '';
    }
  });

  // Respond
  this.statusCode = status;
  this.set('Content-Length', Buffer.byteLength(body));

  if (this.req.method === 'HEAD') {
    this.end();
  } else {
    this.end(body);
  }
};

/**
 * Add `field` to Vary. If already present in the Vary set, then
 * this call is simply ignored.
 *
 * @param {Array|String} field
 * @return {ServerResponse} for chaining
 * @public
 */

res.vary = function(field){
  // checks for back-compat
  if (!field || (Array.isArray(field) && !field.length)) {
    deprecate('res.vary(): Provide a field name');
    return this;
  }

  vary(this, field);

  return this;
};

/**
 * Render `view` with the given `options` and optional callback `fn`.
 * When a callback function is given a response will _not_ be made
 * automatically, otherwise a response of _200_ and _text/html_ is given.
 *
 * Options:
 *
 *  - `cache`     boolean hinting to the engine it should cache
 *  - `filename`  filename of the view being rendered
 *
 * @public
 */

res.render = function render(view, options, callback) {
  var app = this.req.app;
  var done = callback;
  var opts = options || {};
  var req = this.req;
  var self = this;

  // support callback function as second arg
  if (typeof options === 'function') {
    done = options;
    opts = {};
  }

  // merge res.locals
  opts._locals = self.locals;

  // default callback to respond
  done = done || function (err, str) {
    if (err) return req.next(err);
    self.send(str);
  };

  // render
  app.render(view, opts, done);
};

// pipe the send file stream
function sendfile(res, file, options, callback) {
  var done = false;
  var streaming;

  // request aborted
  function onaborted() {
    if (done) return;
    done = true;

    var err = new Error('Request aborted');
    err.code = 'ECONNABORTED';
    callback(err);
  }

  // directory
  function ondirectory() {
    if (done) return;
    done = true;

    var err = new Error('EISDIR, read');
    err.code = 'EISDIR';
    callback(err);
  }

  // errors
  function onerror(err) {
    if (done) return;
    done = true;
    callback(err);
  }

  // ended
  function onend() {
    if (done) return;
    done = true;
    callback();
  }

  // file
  function onfile() {
    streaming = false;
  }

  // finished
  function onfinish(err) {
    if (err && err.code === 'ECONNRESET') return onaborted();
    if (err) return onerror(err);
    if (done) return;

    setImmediate(function () {
      if (streaming !== false && !done) {
        onaborted();
        return;
      }

      if (done) return;
      done = true;
      callback();
    });
  }

  // streaming
  function onstream() {
    streaming = true;
  }

  file.on('directory', ondirectory);
  file.on('end', onend);
  file.on('error', onerror);
  file.on('file', onfile);
  file.on('stream', onstream);
  onFinished(res, onfinish);

  if (options.headers) {
    // set headers on successful transfer
    file.on('headers', function headers(res) {
      var obj = options.headers;
      var keys = Object.keys(obj);

      for (var i = 0; i < keys.length; i++) {
        var k = keys[i];
        res.setHeader(k, obj[k]);
      }
    });
  }

  // pipe
  file.pipe(res);
}

/**
 * Stringify JSON, like JSON.stringify, but v8 optimized, with the
 * ability to escape characters that can trigger HTML sniffing.
 *
 * @param {*} value
 * @param {function} replacer
 * @param {number} spaces
 * @param {boolean} escape
 * @returns {string}
 * @private
 */

function stringify (value, replacer, spaces, escape) {
  // v8 checks arguments.length for optimizing simple call
  // https://bugs.chromium.org/p/v8/issues/detail?id=4730
  var json = replacer || spaces
    ? JSON.stringify(value, replacer, spaces)
    : JSON.stringify(value);

  if (escape && typeof json === 'string') {
    json = json.replace(/[<>&]/g, function (c) {
      switch (c.charCodeAt(0)) {
        case 0x3c:
          return '\\u003c'
        case 0x3e:
          return '\\u003e'
        case 0x26:
          return '\\u0026'
        /* istanbul ignore next: unreachable default */
        default:
          return c
      }
    })
  }

  return json
}


/***/ }),

/***/ 68240:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";
/*!
 * express
 * Copyright(c) 2009-2013 TJ Holowaychuk
 * Copyright(c) 2013 Roman Shtylman
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module dependencies.
 * @private
 */

var Route = __nccwpck_require__(84049);
var Layer = __nccwpck_require__(49177);
var methods = __nccwpck_require__(50806);
var mixin = __nccwpck_require__(51448);
var debug = __nccwpck_require__(88854)('express:router');
var deprecate = __nccwpck_require__(60095)('express');
var flatten = __nccwpck_require__(79560);
var parseUrl = __nccwpck_require__(83404);
var setPrototypeOf = __nccwpck_require__(41015)

/**
 * Module variables.
 * @private
 */

var objectRegExp = /^\[object (\S+)\]$/;
var slice = Array.prototype.slice;
var toString = Object.prototype.toString;

/**
 * Initialize a new `Router` with the given `options`.
 *
 * @param {Object} [options]
 * @return {Router} which is a callable function
 * @public
 */

var proto = module.exports = function(options) {
  var opts = options || {};

  function router(req, res, next) {
    router.handle(req, res, next);
  }

  // mixin Router class functions
  setPrototypeOf(router, proto)

  router.params = {};
  router._params = [];
  router.caseSensitive = opts.caseSensitive;
  router.mergeParams = opts.mergeParams;
  router.strict = opts.strict;
  router.stack = [];

  return router;
};

/**
 * Map the given param placeholder `name`(s) to the given callback.
 *
 * Parameter mapping is used to provide pre-conditions to routes
 * which use normalized placeholders. For example a _:user_id_ parameter
 * could automatically load a user's information from the database without
 * any additional code,
 *
 * The callback uses the same signature as middleware, the only difference
 * being that the value of the placeholder is passed, in this case the _id_
 * of the user. Once the `next()` function is invoked, just like middleware
 * it will continue on to execute the route, or subsequent parameter functions.
 *
 * Just like in middleware, you must either respond to the request or call next
 * to avoid stalling the request.
 *
 *  app.param('user_id', function(req, res, next, id){
 *    User.find(id, function(err, user){
 *      if (err) {
 *        return next(err);
 *      } else if (!user) {
 *        return next(new Error('failed to load user'));
 *      }
 *      req.user = user;
 *      next();
 *    });
 *  });
 *
 * @param {String} name
 * @param {Function} fn
 * @return {app} for chaining
 * @public
 */

proto.param = function param(name, fn) {
  // param logic
  if (typeof name === 'function') {
    deprecate('router.param(fn): Refactor to use path params');
    this._params.push(name);
    return;
  }

  // apply param functions
  var params = this._params;
  var len = params.length;
  var ret;

  if (name[0] === ':') {
    deprecate('router.param(' + JSON.stringify(name) + ', fn): Use router.param(' + JSON.stringify(name.slice(1)) + ', fn) instead')
    name = name.slice(1)
  }

  for (var i = 0; i < len; ++i) {
    if (ret = params[i](name, fn)) {
      fn = ret;
    }
  }

  // ensure we end up with a
  // middleware function
  if ('function' !== typeof fn) {
    throw new Error('invalid param() call for ' + name + ', got ' + fn);
  }

  (this.params[name] = this.params[name] || []).push(fn);
  return this;
};

/**
 * Dispatch a req, res into the router.
 * @private
 */

proto.handle = function handle(req, res, out) {
  var self = this;

  debug('dispatching %s %s', req.method, req.url);

  var idx = 0;
  var protohost = getProtohost(req.url) || ''
  var removed = '';
  var slashAdded = false;
  var sync = 0
  var paramcalled = {};

  // store options for OPTIONS request
  // only used if OPTIONS request
  var options = [];

  // middleware and routes
  var stack = self.stack;

  // manage inter-router variables
  var parentParams = req.params;
  var parentUrl = req.baseUrl || '';
  var done = restore(out, req, 'baseUrl', 'next', 'params');

  // setup next layer
  req.next = next;

  // for options requests, respond with a default if nothing else responds
  if (req.method === 'OPTIONS') {
    done = wrap(done, function(old, err) {
      if (err || options.length === 0) return old(err);
      sendOptionsResponse(res, options, old);
    });
  }

  // setup basic req values
  req.baseUrl = parentUrl;
  req.originalUrl = req.originalUrl || req.url;

  next();

  function next(err) {
    var layerError = err === 'route'
      ? null
      : err;

    // remove added slash
    if (slashAdded) {
      req.url = req.url.slice(1)
      slashAdded = false;
    }

    // restore altered req.url
    if (removed.length !== 0) {
      req.baseUrl = parentUrl;
      req.url = protohost + removed + req.url.slice(protohost.length)
      removed = '';
    }

    // signal to exit router
    if (layerError === 'router') {
      setImmediate(done, null)
      return
    }

    // no more matching layers
    if (idx >= stack.length) {
      setImmediate(done, layerError);
      return;
    }

    // max sync stack
    if (++sync > 100) {
      return setImmediate(next, err)
    }

    // get pathname of request
    var path = getPathname(req);

    if (path == null) {
      return done(layerError);
    }

    // find next matching layer
    var layer;
    var match;
    var route;

    while (match !== true && idx < stack.length) {
      layer = stack[idx++];
      match = matchLayer(layer, path);
      route = layer.route;

      if (typeof match !== 'boolean') {
        // hold on to layerError
        layerError = layerError || match;
      }

      if (match !== true) {
        continue;
      }

      if (!route) {
        // process non-route handlers normally
        continue;
      }

      if (layerError) {
        // routes do not match with a pending error
        match = false;
        continue;
      }

      var method = req.method;
      var has_method = route._handles_method(method);

      // build up automatic options response
      if (!has_method && method === 'OPTIONS') {
        appendMethods(options, route._options());
      }

      // don't even bother matching route
      if (!has_method && method !== 'HEAD') {
        match = false;
      }
    }

    // no match
    if (match !== true) {
      return done(layerError);
    }

    // store route for dispatch on change
    if (route) {
      req.route = route;
    }

    // Capture one-time layer values
    req.params = self.mergeParams
      ? mergeParams(layer.params, parentParams)
      : layer.params;
    var layerPath = layer.path;

    // this should be done for the layer
    self.process_params(layer, paramcalled, req, res, function (err) {
      if (err) {
        next(layerError || err)
      } else if (route) {
        layer.handle_request(req, res, next)
      } else {
        trim_prefix(layer, layerError, layerPath, path)
      }

      sync = 0
    });
  }

  function trim_prefix(layer, layerError, layerPath, path) {
    if (layerPath.length !== 0) {
      // Validate path is a prefix match
      if (layerPath !== path.slice(0, layerPath.length)) {
        next(layerError)
        return
      }

      // Validate path breaks on a path separator
      var c = path[layerPath.length]
      if (c && c !== '/' && c !== '.') return next(layerError)

      // Trim off the part of the url that matches the route
      // middleware (.use stuff) needs to have the path stripped
      debug('trim prefix (%s) from url %s', layerPath, req.url);
      removed = layerPath;
      req.url = protohost + req.url.slice(protohost.length + removed.length)

      // Ensure leading slash
      if (!protohost && req.url[0] !== '/') {
        req.url = '/' + req.url;
        slashAdded = true;
      }

      // Setup base URL (no trailing slash)
      req.baseUrl = parentUrl + (removed[removed.length - 1] === '/'
        ? removed.substring(0, removed.length - 1)
        : removed);
    }

    debug('%s %s : %s', layer.name, layerPath, req.originalUrl);

    if (layerError) {
      layer.handle_error(layerError, req, res, next);
    } else {
      layer.handle_request(req, res, next);
    }
  }
};

/**
 * Process any parameters for the layer.
 * @private
 */

proto.process_params = function process_params(layer, called, req, res, done) {
  var params = this.params;

  // captured parameters from the layer, keys and values
  var keys = layer.keys;

  // fast track
  if (!keys || keys.length === 0) {
    return done();
  }

  var i = 0;
  var name;
  var paramIndex = 0;
  var key;
  var paramVal;
  var paramCallbacks;
  var paramCalled;

  // process params in order
  // param callbacks can be async
  function param(err) {
    if (err) {
      return done(err);
    }

    if (i >= keys.length ) {
      return done();
    }

    paramIndex = 0;
    key = keys[i++];
    name = key.name;
    paramVal = req.params[name];
    paramCallbacks = params[name];
    paramCalled = called[name];

    if (paramVal === undefined || !paramCallbacks) {
      return param();
    }

    // param previously called with same value or error occurred
    if (paramCalled && (paramCalled.match === paramVal
      || (paramCalled.error && paramCalled.error !== 'route'))) {
      // restore value
      req.params[name] = paramCalled.value;

      // next param
      return param(paramCalled.error);
    }

    called[name] = paramCalled = {
      error: null,
      match: paramVal,
      value: paramVal
    };

    paramCallback();
  }

  // single param callbacks
  function paramCallback(err) {
    var fn = paramCallbacks[paramIndex++];

    // store updated value
    paramCalled.value = req.params[key.name];

    if (err) {
      // store error
      paramCalled.error = err;
      param(err);
      return;
    }

    if (!fn) return param();

    try {
      fn(req, res, paramCallback, paramVal, key.name);
    } catch (e) {
      paramCallback(e);
    }
  }

  param();
};

/**
 * Use the given middleware function, with optional path, defaulting to "/".
 *
 * Use (like `.all`) will run for any http METHOD, but it will not add
 * handlers for those methods so OPTIONS requests will not consider `.use`
 * functions even if they could respond.
 *
 * The other difference is that _route_ path is stripped and not visible
 * to the handler function. The main effect of this feature is that mounted
 * handlers can operate without any code changes regardless of the "prefix"
 * pathname.
 *
 * @public
 */

proto.use = function use(fn) {
  var offset = 0;
  var path = '/';

  // default path to '/'
  // disambiguate router.use([fn])
  if (typeof fn !== 'function') {
    var arg = fn;

    while (Array.isArray(arg) && arg.length !== 0) {
      arg = arg[0];
    }

    // first arg is the path
    if (typeof arg !== 'function') {
      offset = 1;
      path = fn;
    }
  }

  var callbacks = flatten(slice.call(arguments, offset));

  if (callbacks.length === 0) {
    throw new TypeError('Router.use() requires a middleware function')
  }

  for (var i = 0; i < callbacks.length; i++) {
    var fn = callbacks[i];

    if (typeof fn !== 'function') {
      throw new TypeError('Router.use() requires a middleware function but got a ' + gettype(fn))
    }

    // add the middleware
    debug('use %o %s', path, fn.name || '<anonymous>')

    var layer = new Layer(path, {
      sensitive: this.caseSensitive,
      strict: false,
      end: false
    }, fn);

    layer.route = undefined;

    this.stack.push(layer);
  }

  return this;
};

/**
 * Create a new Route for the given path.
 *
 * Each route contains a separate middleware stack and VERB handlers.
 *
 * See the Route api documentation for details on adding handlers
 * and middleware to routes.
 *
 * @param {String} path
 * @return {Route}
 * @public
 */

proto.route = function route(path) {
  var route = new Route(path);

  var layer = new Layer(path, {
    sensitive: this.caseSensitive,
    strict: this.strict,
    end: true
  }, route.dispatch.bind(route));

  layer.route = route;

  this.stack.push(layer);
  return route;
};

// create Router#VERB functions
methods.concat('all').forEach(function(method){
  proto[method] = function(path){
    var route = this.route(path)
    route[method].apply(route, slice.call(arguments, 1));
    return this;
  };
});

// append methods to a list of methods
function appendMethods(list, addition) {
  for (var i = 0; i < addition.length; i++) {
    var method = addition[i];
    if (list.indexOf(method) === -1) {
      list.push(method);
    }
  }
}

// get pathname of request
function getPathname(req) {
  try {
    return parseUrl(req).pathname;
  } catch (err) {
    return undefined;
  }
}

// Get get protocol + host for a URL
function getProtohost(url) {
  if (typeof url !== 'string' || url.length === 0 || url[0] === '/') {
    return undefined
  }

  var searchIndex = url.indexOf('?')
  var pathLength = searchIndex !== -1
    ? searchIndex
    : url.length
  var fqdnIndex = url.slice(0, pathLength).indexOf('://')

  return fqdnIndex !== -1
    ? url.substring(0, url.indexOf('/', 3 + fqdnIndex))
    : undefined
}

// get type for error message
function gettype(obj) {
  var type = typeof obj;

  if (type !== 'object') {
    return type;
  }

  // inspect [[Class]] for objects
  return toString.call(obj)
    .replace(objectRegExp, '$1');
}

/**
 * Match path to a layer.
 *
 * @param {Layer} layer
 * @param {string} path
 * @private
 */

function matchLayer(layer, path) {
  try {
    return layer.match(path);
  } catch (err) {
    return err;
  }
}

// merge params with parent params
function mergeParams(params, parent) {
  if (typeof parent !== 'object' || !parent) {
    return params;
  }

  // make copy of parent for base
  var obj = mixin({}, parent);

  // simple non-numeric merging
  if (!(0 in params) || !(0 in parent)) {
    return mixin(obj, params);
  }

  var i = 0;
  var o = 0;

  // determine numeric gaps
  while (i in params) {
    i++;
  }

  while (o in parent) {
    o++;
  }

  // offset numeric indices in params before merge
  for (i--; i >= 0; i--) {
    params[i + o] = params[i];

    // create holes for the merge when necessary
    if (i < o) {
      delete params[i];
    }
  }

  return mixin(obj, params);
}

// restore obj props after function
function restore(fn, obj) {
  var props = new Array(arguments.length - 2);
  var vals = new Array(arguments.length - 2);

  for (var i = 0; i < props.length; i++) {
    props[i] = arguments[i + 2];
    vals[i] = obj[props[i]];
  }

  return function () {
    // restore vals
    for (var i = 0; i < props.length; i++) {
      obj[props[i]] = vals[i];
    }

    return fn.apply(this, arguments);
  };
}

// send an OPTIONS response
function sendOptionsResponse(res, options, next) {
  try {
    var body = options.join(',');
    res.set('Allow', body);
    res.send(body);
  } catch (err) {
    next(err);
  }
}

// wrap a function
function wrap(old, fn) {
  return function proxy() {
    var args = new Array(arguments.length + 1);

    args[0] = old;
    for (var i = 0, len = arguments.length; i < len; i++) {
      args[i + 1] = arguments[i];
    }

    fn.apply(this, args);
  };
}


/***/ }),

/***/ 49177:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";
/*!
 * express
 * Copyright(c) 2009-2013 TJ Holowaychuk
 * Copyright(c) 2013 Roman Shtylman
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module dependencies.
 * @private
 */

var pathRegexp = __nccwpck_require__(19455);
var debug = __nccwpck_require__(88854)('express:router:layer');

/**
 * Module variables.
 * @private
 */

var hasOwnProperty = Object.prototype.hasOwnProperty;

/**
 * Module exports.
 * @public
 */

module.exports = Layer;

function Layer(path, options, fn) {
  if (!(this instanceof Layer)) {
    return new Layer(path, options, fn);
  }

  debug('new %o', path)
  var opts = options || {};

  this.handle = fn;
  this.name = fn.name || '<anonymous>';
  this.params = undefined;
  this.path = undefined;
  this.regexp = pathRegexp(path, this.keys = [], opts);

  // set fast path flags
  this.regexp.fast_star = path === '*'
  this.regexp.fast_slash = path === '/' && opts.end === false
}

/**
 * Handle the error for the layer.
 *
 * @param {Error} error
 * @param {Request} req
 * @param {Response} res
 * @param {function} next
 * @api private
 */

Layer.prototype.handle_error = function handle_error(error, req, res, next) {
  var fn = this.handle;

  if (fn.length !== 4) {
    // not a standard error handler
    return next(error);
  }

  try {
    fn(error, req, res, next);
  } catch (err) {
    next(err);
  }
};

/**
 * Handle the request for the layer.
 *
 * @param {Request} req
 * @param {Response} res
 * @param {function} next
 * @api private
 */

Layer.prototype.handle_request = function handle(req, res, next) {
  var fn = this.handle;

  if (fn.length > 3) {
    // not a standard request handler
    return next();
  }

  try {
    fn(req, res, next);
  } catch (err) {
    next(err);
  }
};

/**
 * Check if this route matches `path`, if so
 * populate `.params`.
 *
 * @param {String} path
 * @return {Boolean}
 * @api private
 */

Layer.prototype.match = function match(path) {
  var match

  if (path != null) {
    // fast path non-ending match for / (any path matches)
    if (this.regexp.fast_slash) {
      this.params = {}
      this.path = ''
      return true
    }

    // fast path for * (everything matched in a param)
    if (this.regexp.fast_star) {
      this.params = {'0': decode_param(path)}
      this.path = path
      return true
    }

    // match the path
    match = this.regexp.exec(path)
  }

  if (!match) {
    this.params = undefined;
    this.path = undefined;
    return false;
  }

  // store values
  this.params = {};
  this.path = match[0]

  var keys = this.keys;
  var params = this.params;

  for (var i = 1; i < match.length; i++) {
    var key = keys[i - 1];
    var prop = key.name;
    var val = decode_param(match[i])

    if (val !== undefined || !(hasOwnProperty.call(params, prop))) {
      params[prop] = val;
    }
  }

  return true;
};

/**
 * Decode param value.
 *
 * @param {string} val
 * @return {string}
 * @private
 */

function decode_param(val) {
  if (typeof val !== 'string' || val.length === 0) {
    return val;
  }

  try {
    return decodeURIComponent(val);
  } catch (err) {
    if (err instanceof URIError) {
      err.message = 'Failed to decode param \'' + val + '\'';
      err.status = err.statusCode = 400;
    }

    throw err;
  }
}


/***/ }),

/***/ 84049:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";
/*!
 * express
 * Copyright(c) 2009-2013 TJ Holowaychuk
 * Copyright(c) 2013 Roman Shtylman
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module dependencies.
 * @private
 */

var debug = __nccwpck_require__(88854)('express:router:route');
var flatten = __nccwpck_require__(79560);
var Layer = __nccwpck_require__(49177);
var methods = __nccwpck_require__(50806);

/**
 * Module variables.
 * @private
 */

var slice = Array.prototype.slice;
var toString = Object.prototype.toString;

/**
 * Module exports.
 * @public
 */

module.exports = Route;

/**
 * Initialize `Route` with the given `path`,
 *
 * @param {String} path
 * @public
 */

function Route(path) {
  this.path = path;
  this.stack = [];

  debug('new %o', path)

  // route handlers for various http methods
  this.methods = {};
}

/**
 * Determine if the route handles a given method.
 * @private
 */

Route.prototype._handles_method = function _handles_method(method) {
  if (this.methods._all) {
    return true;
  }

  // normalize name
  var name = typeof method === 'string'
    ? method.toLowerCase()
    : method

  if (name === 'head' && !this.methods['head']) {
    name = 'get';
  }

  return Boolean(this.methods[name]);
};

/**
 * @return {Array} supported HTTP methods
 * @private
 */

Route.prototype._options = function _options() {
  var methods = Object.keys(this.methods);

  // append automatic head
  if (this.methods.get && !this.methods.head) {
    methods.push('head');
  }

  for (var i = 0; i < methods.length; i++) {
    // make upper case
    methods[i] = methods[i].toUpperCase();
  }

  return methods;
};

/**
 * dispatch req, res into this route
 * @private
 */

Route.prototype.dispatch = function dispatch(req, res, done) {
  var idx = 0;
  var stack = this.stack;
  var sync = 0

  if (stack.length === 0) {
    return done();
  }
  var method = typeof req.method === 'string'
    ? req.method.toLowerCase()
    : req.method

  if (method === 'head' && !this.methods['head']) {
    method = 'get';
  }

  req.route = this;

  next();

  function next(err) {
    // signal to exit route
    if (err && err === 'route') {
      return done();
    }

    // signal to exit router
    if (err && err === 'router') {
      return done(err)
    }

    // max sync stack
    if (++sync > 100) {
      return setImmediate(next, err)
    }

    var layer = stack[idx++]

    // end of layers
    if (!layer) {
      return done(err)
    }

    if (layer.method && layer.method !== method) {
      next(err)
    } else if (err) {
      layer.handle_error(err, req, res, next);
    } else {
      layer.handle_request(req, res, next);
    }

    sync = 0
  }
};

/**
 * Add a handler for all HTTP verbs to this route.
 *
 * Behaves just like middleware and can respond or call `next`
 * to continue processing.
 *
 * You can use multiple `.all` call to add multiple handlers.
 *
 *   function check_something(req, res, next){
 *     next();
 *   };
 *
 *   function validate_user(req, res, next){
 *     next();
 *   };
 *
 *   route
 *   .all(validate_user)
 *   .all(check_something)
 *   .get(function(req, res, next){
 *     res.send('hello world');
 *   });
 *
 * @param {function} handler
 * @return {Route} for chaining
 * @api public
 */

Route.prototype.all = function all() {
  var handles = flatten(slice.call(arguments));

  for (var i = 0; i < handles.length; i++) {
    var handle = handles[i];

    if (typeof handle !== 'function') {
      var type = toString.call(handle);
      var msg = 'Route.all() requires a callback function but got a ' + type
      throw new TypeError(msg);
    }

    var layer = Layer('/', {}, handle);
    layer.method = undefined;

    this.methods._all = true;
    this.stack.push(layer);
  }

  return this;
};

methods.forEach(function(method){
  Route.prototype[method] = function(){
    var handles = flatten(slice.call(arguments));

    for (var i = 0; i < handles.length; i++) {
      var handle = handles[i];

      if (typeof handle !== 'function') {
        var type = toString.call(handle);
        var msg = 'Route.' + method + '() requires a callback function but got a ' + type
        throw new Error(msg);
      }

      debug('%s %o', method, this.path)

      var layer = Layer('/', {}, handle);
      layer.method = method;

      this.methods[method] = true;
      this.stack.push(layer);
    }

    return this;
  };
});


/***/ }),

/***/ 89253:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";
/*!
 * express
 * Copyright(c) 2009-2013 TJ Holowaychuk
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module dependencies.
 * @api private
 */

var Buffer = (__nccwpck_require__(93058).Buffer)
var contentDisposition = __nccwpck_require__(18111);
var contentType = __nccwpck_require__(20756);
var deprecate = __nccwpck_require__(60095)('express');
var flatten = __nccwpck_require__(79560);
var mime = (__nccwpck_require__(60814).mime);
var etag = __nccwpck_require__(61825);
var proxyaddr = __nccwpck_require__(98916);
var qs = __nccwpck_require__(40240);
var querystring = __nccwpck_require__(83480);

/**
 * Return strong ETag for `body`.
 *
 * @param {String|Buffer} body
 * @param {String} [encoding]
 * @return {String}
 * @api private
 */

exports.etag = createETagGenerator({ weak: false })

/**
 * Return weak ETag for `body`.
 *
 * @param {String|Buffer} body
 * @param {String} [encoding]
 * @return {String}
 * @api private
 */

exports.wetag = createETagGenerator({ weak: true })

/**
 * Check if `path` looks absolute.
 *
 * @param {String} path
 * @return {Boolean}
 * @api private
 */

exports.isAbsolute = function(path){
  if ('/' === path[0]) return true;
  if (':' === path[1] && ('\\' === path[2] || '/' === path[2])) return true; // Windows device path
  if ('\\\\' === path.substring(0, 2)) return true; // Microsoft Azure absolute path
};

/**
 * Flatten the given `arr`.
 *
 * @param {Array} arr
 * @return {Array}
 * @api private
 */

exports.flatten = deprecate.function(flatten,
  'utils.flatten: use array-flatten npm module instead');

/**
 * Normalize the given `type`, for example "html" becomes "text/html".
 *
 * @param {String} type
 * @return {Object}
 * @api private
 */

exports.normalizeType = function(type){
  return ~type.indexOf('/')
    ? acceptParams(type)
    : { value: mime.lookup(type), params: {} };
};

/**
 * Normalize `types`, for example "html" becomes "text/html".
 *
 * @param {Array} types
 * @return {Array}
 * @api private
 */

exports.normalizeTypes = function(types){
  var ret = [];

  for (var i = 0; i < types.length; ++i) {
    ret.push(exports.normalizeType(types[i]));
  }

  return ret;
};

/**
 * Generate Content-Disposition header appropriate for the filename.
 * non-ascii filenames are urlencoded and a filename* parameter is added
 *
 * @param {String} filename
 * @return {String}
 * @api private
 */

exports.contentDisposition = deprecate.function(contentDisposition,
  'utils.contentDisposition: use content-disposition npm module instead');

/**
 * Parse accept params `str` returning an
 * object with `.value`, `.quality` and `.params`.
 *
 * @param {String} str
 * @return {Object}
 * @api private
 */

function acceptParams (str) {
  var parts = str.split(/ *; */);
  var ret = { value: parts[0], quality: 1, params: {} }

  for (var i = 1; i < parts.length; ++i) {
    var pms = parts[i].split(/ *= */);
    if ('q' === pms[0]) {
      ret.quality = parseFloat(pms[1]);
    } else {
      ret.params[pms[0]] = pms[1];
    }
  }

  return ret;
}

/**
 * Compile "etag" value to function.
 *
 * @param  {Boolean|String|Function} val
 * @return {Function}
 * @api private
 */

exports.compileETag = function(val) {
  var fn;

  if (typeof val === 'function') {
    return val;
  }

  switch (val) {
    case true:
    case 'weak':
      fn = exports.wetag;
      break;
    case false:
      break;
    case 'strong':
      fn = exports.etag;
      break;
    default:
      throw new TypeError('unknown value for etag function: ' + val);
  }

  return fn;
}

/**
 * Compile "query parser" value to function.
 *
 * @param  {String|Function} val
 * @return {Function}
 * @api private
 */

exports.compileQueryParser = function compileQueryParser(val) {
  var fn;

  if (typeof val === 'function') {
    return val;
  }

  switch (val) {
    case true:
    case 'simple':
      fn = querystring.parse;
      break;
    case false:
      fn = newObject;
      break;
    case 'extended':
      fn = parseExtendedQueryString;
      break;
    default:
      throw new TypeError('unknown value for query parser function: ' + val);
  }

  return fn;
}

/**
 * Compile "proxy trust" value to function.
 *
 * @param  {Boolean|String|Number|Array|Function} val
 * @return {Function}
 * @api private
 */

exports.compileTrust = function(val) {
  if (typeof val === 'function') return val;

  if (val === true) {
    // Support plain true/false
    return function(){ return true };
  }

  if (typeof val === 'number') {
    // Support trusting hop count
    return function(a, i){ return i < val };
  }

  if (typeof val === 'string') {
    // Support comma-separated values
    val = val.split(',')
      .map(function (v) { return v.trim() })
  }

  return proxyaddr.compile(val || []);
}

/**
 * Set the charset in a given Content-Type string.
 *
 * @param {String} type
 * @param {String} charset
 * @return {String}
 * @api private
 */

exports.setCharset = function setCharset(type, charset) {
  if (!type || !charset) {
    return type;
  }

  // parse type
  var parsed = contentType.parse(type);

  // set charset
  parsed.parameters.charset = charset;

  // format type
  return contentType.format(parsed);
};

/**
 * Create an ETag generator function, generating ETags with
 * the given options.
 *
 * @param {object} options
 * @return {function}
 * @private
 */

function createETagGenerator (options) {
  return function generateETag (body, encoding) {
    var buf = !Buffer.isBuffer(body)
      ? Buffer.from(body, encoding)
      : body

    return etag(buf, options)
  }
}

/**
 * Parse an extended query string with qs.
 *
 * @param {String} str
 * @return {Object}
 * @private
 */

function parseExtendedQueryString(str) {
  return qs.parse(str, {
    allowPrototypes: true
  });
}

/**
 * Return new empty object.
 *
 * @return {Object}
 * @api private
 */

function newObject() {
  return {};
}


/***/ }),

/***/ 79123:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";
/*!
 * express
 * Copyright(c) 2009-2013 TJ Holowaychuk
 * Copyright(c) 2013 Roman Shtylman
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module dependencies.
 * @private
 */

var debug = __nccwpck_require__(88854)('express:view');
var path = __nccwpck_require__(16928);
var fs = __nccwpck_require__(79896);

/**
 * Module variables.
 * @private
 */

var dirname = path.dirname;
var basename = path.basename;
var extname = path.extname;
var join = path.join;
var resolve = path.resolve;

/**
 * Module exports.
 * @public
 */

module.exports = View;

/**
 * Initialize a new `View` with the given `name`.
 *
 * Options:
 *
 *   - `defaultEngine` the default template engine name
 *   - `engines` template engine require() cache
 *   - `root` root path for view lookup
 *
 * @param {string} name
 * @param {object} options
 * @public
 */

function View(name, options) {
  var opts = options || {};

  this.defaultEngine = opts.defaultEngine;
  this.ext = extname(name);
  this.name = name;
  this.root = opts.root;

  if (!this.ext && !this.defaultEngine) {
    throw new Error('No default engine was specified and no extension was provided.');
  }

  var fileName = name;

  if (!this.ext) {
    // get extension from default engine name
    this.ext = this.defaultEngine[0] !== '.'
      ? '.' + this.defaultEngine
      : this.defaultEngine;

    fileName += this.ext;
  }

  if (!opts.engines[this.ext]) {
    // load engine
    var mod = this.ext.slice(1)
    debug('require "%s"', mod)

    // default engine export
    var fn = require(mod).__express

    if (typeof fn !== 'function') {
      throw new Error('Module "' + mod + '" does not provide a view engine.')
    }

    opts.engines[this.ext] = fn
  }

  // store loaded engine
  this.engine = opts.engines[this.ext];

  // lookup path
  this.path = this.lookup(fileName);
}

/**
 * Lookup view by the given `name`
 *
 * @param {string} name
 * @private
 */

View.prototype.lookup = function lookup(name) {
  var path;
  var roots = [].concat(this.root);

  debug('lookup "%s"', name);

  for (var i = 0; i < roots.length && !path; i++) {
    var root = roots[i];

    // resolve the path
    var loc = resolve(root, name);
    var dir = dirname(loc);
    var file = basename(loc);

    // resolve the file
    path = this.resolve(dir, file);
  }

  return path;
};

/**
 * Render with the given options.
 *
 * @param {object} options
 * @param {function} callback
 * @private
 */

View.prototype.render = function render(options, callback) {
  debug('render "%s"', this.path);
  this.engine(this.path, options, callback);
};

/**
 * Resolve the file within the given directory.
 *
 * @param {string} dir
 * @param {string} file
 * @private
 */

View.prototype.resolve = function resolve(dir, file) {
  var ext = this.ext;

  // <path>.<ext>
  var path = join(dir, file);
  var stat = tryStat(path);

  if (stat && stat.isFile()) {
    return path;
  }

  // <path>/index.<ext>
  path = join(dir, basename(file, ext), 'index' + ext);
  stat = tryStat(path);

  if (stat && stat.isFile()) {
    return path;
  }
};

/**
 * Return a stat, maybe.
 *
 * @param {string} path
 * @return {fs.Stats}
 * @private
 */

function tryStat(path) {
  debug('stat "%s"', path);

  try {
    return fs.statSync(path);
  } catch (e) {
    return undefined;
  }
}


/***/ }),

/***/ 56358:
/***/ ((module, exports, __nccwpck_require__) => {

/**
 * This is the web browser implementation of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = __nccwpck_require__(81633);
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = 'undefined' != typeof chrome
               && 'undefined' != typeof chrome.storage
                  ? chrome.storage.local
                  : localstorage();

/**
 * Colors.
 */

exports.colors = [
  'lightseagreen',
  'forestgreen',
  'goldenrod',
  'dodgerblue',
  'darkorchid',
  'crimson'
];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

function useColors() {
  // NB: In an Electron preload script, document will be defined but not fully
  // initialized. Since we know we're in Chrome, we'll just detect this case
  // explicitly
  if (typeof window !== 'undefined' && window.process && window.process.type === 'renderer') {
    return true;
  }

  // is webkit? http://stackoverflow.com/a/16459606/376773
  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
  return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||
    // is firebug? http://stackoverflow.com/a/398120/376773
    (typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||
    // is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||
    // double check webkit in userAgent just in case we are in a worker
    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/));
}

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

exports.formatters.j = function(v) {
  try {
    return JSON.stringify(v);
  } catch (err) {
    return '[UnexpectedJSONParseError]: ' + err.message;
  }
};


/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs(args) {
  var useColors = this.useColors;

  args[0] = (useColors ? '%c' : '')
    + this.namespace
    + (useColors ? ' %c' : ' ')
    + args[0]
    + (useColors ? '%c ' : ' ')
    + '+' + exports.humanize(this.diff);

  if (!useColors) return;

  var c = 'color: ' + this.color;
  args.splice(1, 0, c, 'color: inherit')

  // the final "%c" is somewhat tricky, because there could be other
  // arguments passed either before or after the %c, so we need to
  // figure out the correct index to insert the CSS into
  var index = 0;
  var lastC = 0;
  args[0].replace(/%[a-zA-Z%]/g, function(match) {
    if ('%%' === match) return;
    index++;
    if ('%c' === match) {
      // we only are interested in the *last* %c
      // (the user may have provided their own)
      lastC = index;
    }
  });

  args.splice(lastC, 0, c);
}

/**
 * Invokes `console.log()` when available.
 * No-op when `console.log` is not a "function".
 *
 * @api public
 */

function log() {
  // this hackery is required for IE8/9, where
  // the `console.log` function doesn't have 'apply'
  return 'object' === typeof console
    && console.log
    && Function.prototype.apply.call(console.log, console, arguments);
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */

function save(namespaces) {
  try {
    if (null == namespaces) {
      exports.storage.removeItem('debug');
    } else {
      exports.storage.debug = namespaces;
    }
  } catch(e) {}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

function load() {
  var r;
  try {
    r = exports.storage.debug;
  } catch(e) {}

  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG
  if (!r && typeof process !== 'undefined' && 'env' in process) {
    r = process.env.DEBUG;
  }

  return r;
}

/**
 * Enable namespaces listed in `localStorage.debug` initially.
 */

exports.enable(load());

/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */

function localstorage() {
  try {
    return window.localStorage;
  } catch (e) {}
}


/***/ }),

/***/ 81633:
/***/ ((module, exports, __nccwpck_require__) => {


/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = createDebug.debug = createDebug['default'] = createDebug;
exports.coerce = coerce;
exports.disable = disable;
exports.enable = enable;
exports.enabled = enabled;
exports.humanize = __nccwpck_require__(22000);

/**
 * The currently active debug mode names, and names to skip.
 */

exports.names = [];
exports.skips = [];

/**
 * Map of special "%n" handling functions, for the debug "format" argument.
 *
 * Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
 */

exports.formatters = {};

/**
 * Previous log timestamp.
 */

var prevTime;

/**
 * Select a color.
 * @param {String} namespace
 * @return {Number}
 * @api private
 */

function selectColor(namespace) {
  var hash = 0, i;

  for (i in namespace) {
    hash  = ((hash << 5) - hash) + namespace.charCodeAt(i);
    hash |= 0; // Convert to 32bit integer
  }

  return exports.colors[Math.abs(hash) % exports.colors.length];
}

/**
 * Create a debugger with the given `namespace`.
 *
 * @param {String} namespace
 * @return {Function}
 * @api public
 */

function createDebug(namespace) {

  function debug() {
    // disabled?
    if (!debug.enabled) return;

    var self = debug;

    // set `diff` timestamp
    var curr = +new Date();
    var ms = curr - (prevTime || curr);
    self.diff = ms;
    self.prev = prevTime;
    self.curr = curr;
    prevTime = curr;

    // turn the `arguments` into a proper Array
    var args = new Array(arguments.length);
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i];
    }

    args[0] = exports.coerce(args[0]);

    if ('string' !== typeof args[0]) {
      // anything else let's inspect with %O
      args.unshift('%O');
    }

    // apply any `formatters` transformations
    var index = 0;
    args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {
      // if we encounter an escaped % then don't increase the array index
      if (match === '%%') return match;
      index++;
      var formatter = exports.formatters[format];
      if ('function' === typeof formatter) {
        var val = args[index];
        match = formatter.call(self, val);

        // now we need to remove `args[index]` since it's inlined in the `format`
        args.splice(index, 1);
        index--;
      }
      return match;
    });

    // apply env-specific formatting (colors, etc.)
    exports.formatArgs.call(self, args);

    var logFn = debug.log || exports.log || console.log.bind(console);
    logFn.apply(self, args);
  }

  debug.namespace = namespace;
  debug.enabled = exports.enabled(namespace);
  debug.useColors = exports.useColors();
  debug.color = selectColor(namespace);

  // env-specific initialization logic for debug instances
  if ('function' === typeof exports.init) {
    exports.init(debug);
  }

  return debug;
}

/**
 * Enables a debug mode by namespaces. This can include modes
 * separated by a colon and wildcards.
 *
 * @param {String} namespaces
 * @api public
 */

function enable(namespaces) {
  exports.save(namespaces);

  exports.names = [];
  exports.skips = [];

  var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
  var len = split.length;

  for (var i = 0; i < len; i++) {
    if (!split[i]) continue; // ignore empty strings
    namespaces = split[i].replace(/\*/g, '.*?');
    if (namespaces[0] === '-') {
      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
    } else {
      exports.names.push(new RegExp('^' + namespaces + '$'));
    }
  }
}

/**
 * Disable debug output.
 *
 * @api public
 */

function disable() {
  exports.enable('');
}

/**
 * Returns true if the given mode name is enabled, false otherwise.
 *
 * @param {String} name
 * @return {Boolean}
 * @api public
 */

function enabled(name) {
  var i, len;
  for (i = 0, len = exports.skips.length; i < len; i++) {
    if (exports.skips[i].test(name)) {
      return false;
    }
  }
  for (i = 0, len = exports.names.length; i < len; i++) {
    if (exports.names[i].test(name)) {
      return true;
    }
  }
  return false;
}

/**
 * Coerce `val`.
 *
 * @param {Mixed} val
 * @return {Mixed}
 * @api private
 */

function coerce(val) {
  if (val instanceof Error) return val.stack || val.message;
  return val;
}


/***/ }),

/***/ 88854:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

/**
 * Detect Electron renderer process, which is node, but we should
 * treat as a browser.
 */

if (typeof process !== 'undefined' && process.type === 'renderer') {
  module.exports = __nccwpck_require__(56358);
} else {
  module.exports = __nccwpck_require__(99148);
}


/***/ }),

/***/ 99148:
/***/ ((module, exports, __nccwpck_require__) => {

/**
 * Module dependencies.
 */

var tty = __nccwpck_require__(52018);
var util = __nccwpck_require__(39023);

/**
 * This is the Node.js implementation of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = __nccwpck_require__(81633);
exports.init = init;
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;

/**
 * Colors.
 */

exports.colors = [6, 2, 3, 4, 5, 1];

/**
 * Build up the default `inspectOpts` object from the environment variables.
 *
 *   $ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js
 */

exports.inspectOpts = Object.keys(process.env).filter(function (key) {
  return /^debug_/i.test(key);
}).reduce(function (obj, key) {
  // camel-case
  var prop = key
    .substring(6)
    .toLowerCase()
    .replace(/_([a-z])/g, function (_, k) { return k.toUpperCase() });

  // coerce string value into JS value
  var val = process.env[key];
  if (/^(yes|on|true|enabled)$/i.test(val)) val = true;
  else if (/^(no|off|false|disabled)$/i.test(val)) val = false;
  else if (val === 'null') val = null;
  else val = Number(val);

  obj[prop] = val;
  return obj;
}, {});

/**
 * The file descriptor to write the `debug()` calls to.
 * Set the `DEBUG_FD` env variable to override with another value. i.e.:
 *
 *   $ DEBUG_FD=3 node script.js 3>debug.log
 */

var fd = parseInt(process.env.DEBUG_FD, 10) || 2;

if (1 !== fd && 2 !== fd) {
  util.deprecate(function(){}, 'except for stderr(2) and stdout(1), any other usage of DEBUG_FD is deprecated. Override debug.log if you want to use a different log function (https://git.io/debug_fd)')()
}

var stream = 1 === fd ? process.stdout :
             2 === fd ? process.stderr :
             createWritableStdioStream(fd);

/**
 * Is stdout a TTY? Colored output is enabled when `true`.
 */

function useColors() {
  return 'colors' in exports.inspectOpts
    ? Boolean(exports.inspectOpts.colors)
    : tty.isatty(fd);
}

/**
 * Map %o to `util.inspect()`, all on a single line.
 */

exports.formatters.o = function(v) {
  this.inspectOpts.colors = this.useColors;
  return util.inspect(v, this.inspectOpts)
    .split('\n').map(function(str) {
      return str.trim()
    }).join(' ');
};

/**
 * Map %o to `util.inspect()`, allowing multiple lines if needed.
 */

exports.formatters.O = function(v) {
  this.inspectOpts.colors = this.useColors;
  return util.inspect(v, this.inspectOpts);
};

/**
 * Adds ANSI color escape codes if enabled.
 *
 * @api public
 */

function formatArgs(args) {
  var name = this.namespace;
  var useColors = this.useColors;

  if (useColors) {
    var c = this.color;
    var prefix = '  \u001b[3' + c + ';1m' + name + ' ' + '\u001b[0m';

    args[0] = prefix + args[0].split('\n').join('\n' + prefix);
    args.push('\u001b[3' + c + 'm+' + exports.humanize(this.diff) + '\u001b[0m');
  } else {
    args[0] = new Date().toUTCString()
      + ' ' + name + ' ' + args[0];
  }
}

/**
 * Invokes `util.format()` with the specified arguments and writes to `stream`.
 */

function log() {
  return stream.write(util.format.apply(util, arguments) + '\n');
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */

function save(namespaces) {
  if (null == namespaces) {
    // If you set a process.env field to null or undefined, it gets cast to the
    // string 'null' or 'undefined'. Just delete instead.
    delete process.env.DEBUG;
  } else {
    process.env.DEBUG = namespaces;
  }
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

function load() {
  return process.env.DEBUG;
}

/**
 * Copied from `node/src/node.js`.
 *
 * XXX: It's lame that node doesn't expose this API out-of-the-box. It also
 * relies on the undocumented `tty_wrap.guessHandleType()` which is also lame.
 */

function createWritableStdioStream (fd) {
  var stream;
  var tty_wrap = process.binding('tty_wrap');

  // Note stream._type is used for test-module-load-list.js

  switch (tty_wrap.guessHandleType(fd)) {
    case 'TTY':
      stream = new tty.WriteStream(fd);
      stream._type = 'tty';

      // Hack to have stream not keep the event loop alive.
      // See https://github.com/joyent/node/issues/1726
      if (stream._handle && stream._handle.unref) {
        stream._handle.unref();
      }
      break;

    case 'FILE':
      var fs = __nccwpck_require__(79896);
      stream = new fs.SyncWriteStream(fd, { autoClose: false });
      stream._type = 'fs';
      break;

    case 'PIPE':
    case 'TCP':
      var net = __nccwpck_require__(69278);
      stream = new net.Socket({
        fd: fd,
        readable: false,
        writable: true
      });

      // FIXME Should probably have an option in net.Socket to create a
      // stream from an existing fd which is writable only. But for now
      // we'll just add this hack and set the `readable` member to false.
      // Test: ./node test/fixtures/echo.js < /etc/passwd
      stream.readable = false;
      stream.read = null;
      stream._type = 'pipe';

      // FIXME Hack to have stream not keep the event loop alive.
      // See https://github.com/joyent/node/issues/1726
      if (stream._handle && stream._handle.unref) {
        stream._handle.unref();
      }
      break;

    default:
      // Probably an error on in uv_guess_handle()
      throw new Error('Implement me. Unknown stream file type!');
  }

  // For supporting legacy API we put the FD here.
  stream.fd = fd;

  stream._isStdio = true;

  return stream;
}

/**
 * Init logic for `debug` instances.
 *
 * Create a new `inspectOpts` object in case `useColors` is set
 * differently for a particular `debug` instance.
 */

function init (debug) {
  debug.inspectOpts = {};

  var keys = Object.keys(exports.inspectOpts);
  for (var i = 0; i < keys.length; i++) {
    debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
  }
}

/**
 * Enable namespaces listed in `process.env.DEBUG` initially.
 */

exports.enable(load());


/***/ }),

/***/ 22000:
/***/ ((module) => {

/**
 * Helpers.
 */

var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var y = d * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */

module.exports = function(val, options) {
  options = options || {};
  var type = typeof val;
  if (type === 'string' && val.length > 0) {
    return parse(val);
  } else if (type === 'number' && isNaN(val) === false) {
    return options.long ? fmtLong(val) : fmtShort(val);
  }
  throw new Error(
    'val is not a non-empty string or a valid number. val=' +
      JSON.stringify(val)
  );
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  str = String(str);
  if (str.length > 100) {
    return;
  }
  var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(
    str
  );
  if (!match) {
    return;
  }
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;
    case 'days':
    case 'day':
    case 'd':
      return n * d;
    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h;
    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m;
    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s;
    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;
    default:
      return undefined;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtShort(ms) {
  if (ms >= d) {
    return Math.round(ms / d) + 'd';
  }
  if (ms >= h) {
    return Math.round(ms / h) + 'h';
  }
  if (ms >= m) {
    return Math.round(ms / m) + 'm';
  }
  if (ms >= s) {
    return Math.round(ms / s) + 's';
  }
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtLong(ms) {
  return plural(ms, d, 'day') ||
    plural(ms, h, 'hour') ||
    plural(ms, m, 'minute') ||
    plural(ms, s, 'second') ||
    ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural(ms, n, name) {
  if (ms < n) {
    return;
  }
  if (ms < n * 1.5) {
    return Math.floor(ms / n) + ' ' + name;
  }
  return Math.ceil(ms / n) + ' ' + name + 's';
}


/***/ }),

/***/ 1972:
/***/ (function(__unused_webpack_module, exports) {

(function (global, factory) {
   true ? factory(exports) :
  0;
}(this, (function (exports) { 'use strict';

  var token = /d{1,4}|M{1,4}|YY(?:YY)?|S{1,3}|Do|ZZ|Z|([HhMsDm])\1?|[aA]|"[^"]*"|'[^']*'/g;
  var twoDigitsOptional = "\\d\\d?";
  var twoDigits = "\\d\\d";
  var threeDigits = "\\d{3}";
  var fourDigits = "\\d{4}";
  var word = "[^\\s]+";
  var literal = /\[([^]*?)\]/gm;
  function shorten(arr, sLen) {
      var newArr = [];
      for (var i = 0, len = arr.length; i < len; i++) {
          newArr.push(arr[i].substr(0, sLen));
      }
      return newArr;
  }
  var monthUpdate = function (arrName) { return function (v, i18n) {
      var lowerCaseArr = i18n[arrName].map(function (v) { return v.toLowerCase(); });
      var index = lowerCaseArr.indexOf(v.toLowerCase());
      if (index > -1) {
          return index;
      }
      return null;
  }; };
  function assign(origObj) {
      var args = [];
      for (var _i = 1; _i < arguments.length; _i++) {
          args[_i - 1] = arguments[_i];
      }
      for (var _a = 0, args_1 = args; _a < args_1.length; _a++) {
          var obj = args_1[_a];
          for (var key in obj) {
              // @ts-ignore ex
              origObj[key] = obj[key];
          }
      }
      return origObj;
  }
  var dayNames = [
      "Sunday",
      "Monday",
      "Tuesday",
      "Wednesday",
      "Thursday",
      "Friday",
      "Saturday"
  ];
  var monthNames = [
      "January",
      "February",
      "March",
      "April",
      "May",
      "June",
      "July",
      "August",
      "September",
      "October",
      "November",
      "December"
  ];
  var monthNamesShort = shorten(monthNames, 3);
  var dayNamesShort = shorten(dayNames, 3);
  var defaultI18n = {
      dayNamesShort: dayNamesShort,
      dayNames: dayNames,
      monthNamesShort: monthNamesShort,
      monthNames: monthNames,
      amPm: ["am", "pm"],
      DoFn: function (dayOfMonth) {
          return (dayOfMonth +
              ["th", "st", "nd", "rd"][dayOfMonth % 10 > 3
                  ? 0
                  : ((dayOfMonth - (dayOfMonth % 10) !== 10 ? 1 : 0) * dayOfMonth) % 10]);
      }
  };
  var globalI18n = assign({}, defaultI18n);
  var setGlobalDateI18n = function (i18n) {
      return (globalI18n = assign(globalI18n, i18n));
  };
  var regexEscape = function (str) {
      return str.replace(/[|\\{()[^$+*?.-]/g, "\\$&");
  };
  var pad = function (val, len) {
      if (len === void 0) { len = 2; }
      val = String(val);
      while (val.length < len) {
          val = "0" + val;
      }
      return val;
  };
  var formatFlags = {
      D: function (dateObj) { return String(dateObj.getDate()); },
      DD: function (dateObj) { return pad(dateObj.getDate()); },
      Do: function (dateObj, i18n) {
          return i18n.DoFn(dateObj.getDate());
      },
      d: function (dateObj) { return String(dateObj.getDay()); },
      dd: function (dateObj) { return pad(dateObj.getDay()); },
      ddd: function (dateObj, i18n) {
          return i18n.dayNamesShort[dateObj.getDay()];
      },
      dddd: function (dateObj, i18n) {
          return i18n.dayNames[dateObj.getDay()];
      },
      M: function (dateObj) { return String(dateObj.getMonth() + 1); },
      MM: function (dateObj) { return pad(dateObj.getMonth() + 1); },
      MMM: function (dateObj, i18n) {
          return i18n.monthNamesShort[dateObj.getMonth()];
      },
      MMMM: function (dateObj, i18n) {
          return i18n.monthNames[dateObj.getMonth()];
      },
      YY: function (dateObj) {
          return pad(String(dateObj.getFullYear()), 4).substr(2);
      },
      YYYY: function (dateObj) { return pad(dateObj.getFullYear(), 4); },
      h: function (dateObj) { return String(dateObj.getHours() % 12 || 12); },
      hh: function (dateObj) { return pad(dateObj.getHours() % 12 || 12); },
      H: function (dateObj) { return String(dateObj.getHours()); },
      HH: function (dateObj) { return pad(dateObj.getHours()); },
      m: function (dateObj) { return String(dateObj.getMinutes()); },
      mm: function (dateObj) { return pad(dateObj.getMinutes()); },
      s: function (dateObj) { return String(dateObj.getSeconds()); },
      ss: function (dateObj) { return pad(dateObj.getSeconds()); },
      S: function (dateObj) {
          return String(Math.round(dateObj.getMilliseconds() / 100));
      },
      SS: function (dateObj) {
          return pad(Math.round(dateObj.getMilliseconds() / 10), 2);
      },
      SSS: function (dateObj) { return pad(dateObj.getMilliseconds(), 3); },
      a: function (dateObj, i18n) {
          return dateObj.getHours() < 12 ? i18n.amPm[0] : i18n.amPm[1];
      },
      A: function (dateObj, i18n) {
          return dateObj.getHours() < 12
              ? i18n.amPm[0].toUpperCase()
              : i18n.amPm[1].toUpperCase();
      },
      ZZ: function (dateObj) {
          var offset = dateObj.getTimezoneOffset();
          return ((offset > 0 ? "-" : "+") +
              pad(Math.floor(Math.abs(offset) / 60) * 100 + (Math.abs(offset) % 60), 4));
      },
      Z: function (dateObj) {
          var offset = dateObj.getTimezoneOffset();
          return ((offset > 0 ? "-" : "+") +
              pad(Math.floor(Math.abs(offset) / 60), 2) +
              ":" +
              pad(Math.abs(offset) % 60, 2));
      }
  };
  var monthParse = function (v) { return +v - 1; };
  var emptyDigits = [null, twoDigitsOptional];
  var emptyWord = [null, word];
  var amPm = [
      "isPm",
      word,
      function (v, i18n) {
          var val = v.toLowerCase();
          if (val === i18n.amPm[0]) {
              return 0;
          }
          else if (val === i18n.amPm[1]) {
              return 1;
          }
          return null;
      }
  ];
  var timezoneOffset = [
      "timezoneOffset",
      "[^\\s]*?[\\+\\-]\\d\\d:?\\d\\d|[^\\s]*?Z?",
      function (v) {
          var parts = (v + "").match(/([+-]|\d\d)/gi);
          if (parts) {
              var minutes = +parts[1] * 60 + parseInt(parts[2], 10);
              return parts[0] === "+" ? minutes : -minutes;
          }
          return 0;
      }
  ];
  var parseFlags = {
      D: ["day", twoDigitsOptional],
      DD: ["day", twoDigits],
      Do: ["day", twoDigitsOptional + word, function (v) { return parseInt(v, 10); }],
      M: ["month", twoDigitsOptional, monthParse],
      MM: ["month", twoDigits, monthParse],
      YY: [
          "year",
          twoDigits,
          function (v) {
              var now = new Date();
              var cent = +("" + now.getFullYear()).substr(0, 2);
              return +("" + (+v > 68 ? cent - 1 : cent) + v);
          }
      ],
      h: ["hour", twoDigitsOptional, undefined, "isPm"],
      hh: ["hour", twoDigits, undefined, "isPm"],
      H: ["hour", twoDigitsOptional],
      HH: ["hour", twoDigits],
      m: ["minute", twoDigitsOptional],
      mm: ["minute", twoDigits],
      s: ["second", twoDigitsOptional],
      ss: ["second", twoDigits],
      YYYY: ["year", fourDigits],
      S: ["millisecond", "\\d", function (v) { return +v * 100; }],
      SS: ["millisecond", twoDigits, function (v) { return +v * 10; }],
      SSS: ["millisecond", threeDigits],
      d: emptyDigits,
      dd: emptyDigits,
      ddd: emptyWord,
      dddd: emptyWord,
      MMM: ["month", word, monthUpdate("monthNamesShort")],
      MMMM: ["month", word, monthUpdate("monthNames")],
      a: amPm,
      A: amPm,
      ZZ: timezoneOffset,
      Z: timezoneOffset
  };
  // Some common format strings
  var globalMasks = {
      default: "ddd MMM DD YYYY HH:mm:ss",
      shortDate: "M/D/YY",
      mediumDate: "MMM D, YYYY",
      longDate: "MMMM D, YYYY",
      fullDate: "dddd, MMMM D, YYYY",
      isoDate: "YYYY-MM-DD",
      isoDateTime: "YYYY-MM-DDTHH:mm:ssZ",
      shortTime: "HH:mm",
      mediumTime: "HH:mm:ss",
      longTime: "HH:mm:ss.SSS"
  };
  var setGlobalDateMasks = function (masks) { return assign(globalMasks, masks); };
  /***
   * Format a date
   * @method format
   * @param {Date|number} dateObj
   * @param {string} mask Format of the date, i.e. 'mm-dd-yy' or 'shortDate'
   * @returns {string} Formatted date string
   */
  var format = function (dateObj, mask, i18n) {
      if (mask === void 0) { mask = globalMasks["default"]; }
      if (i18n === void 0) { i18n = {}; }
      if (typeof dateObj === "number") {
          dateObj = new Date(dateObj);
      }
      if (Object.prototype.toString.call(dateObj) !== "[object Date]" ||
          isNaN(dateObj.getTime())) {
          throw new Error("Invalid Date pass to format");
      }
      mask = globalMasks[mask] || mask;
      var literals = [];
      // Make literals inactive by replacing them with @@@
      mask = mask.replace(literal, function ($0, $1) {
          literals.push($1);
          return "@@@";
      });
      var combinedI18nSettings = assign(assign({}, globalI18n), i18n);
      // Apply formatting rules
      mask = mask.replace(token, function ($0) {
          return formatFlags[$0](dateObj, combinedI18nSettings);
      });
      // Inline literal values back into the formatted value
      return mask.replace(/@@@/g, function () { return literals.shift(); });
  };
  /**
   * Parse a date string into a Javascript Date object /
   * @method parse
   * @param {string} dateStr Date string
   * @param {string} format Date parse format
   * @param {i18n} I18nSettingsOptional Full or subset of I18N settings
   * @returns {Date|null} Returns Date object. Returns null what date string is invalid or doesn't match format
   */
  function parse(dateStr, format, i18n) {
      if (i18n === void 0) { i18n = {}; }
      if (typeof format !== "string") {
          throw new Error("Invalid format in fecha parse");
      }
      // Check to see if the format is actually a mask
      format = globalMasks[format] || format;
      // Avoid regular expression denial of service, fail early for really long strings
      // https://www.owasp.org/index.php/Regular_expression_Denial_of_Service_-_ReDoS
      if (dateStr.length > 1000) {
          return null;
      }
      // Default to the beginning of the year.
      var today = new Date();
      var dateInfo = {
          year: today.getFullYear(),
          month: 0,
          day: 1,
          hour: 0,
          minute: 0,
          second: 0,
          millisecond: 0,
          isPm: null,
          timezoneOffset: null
      };
      var parseInfo = [];
      var literals = [];
      // Replace all the literals with @@@. Hopefully a string that won't exist in the format
      var newFormat = format.replace(literal, function ($0, $1) {
          literals.push(regexEscape($1));
          return "@@@";
      });
      var specifiedFields = {};
      var requiredFields = {};
      // Change every token that we find into the correct regex
      newFormat = regexEscape(newFormat).replace(token, function ($0) {
          var info = parseFlags[$0];
          var field = info[0], regex = info[1], requiredField = info[3];
          // Check if the person has specified the same field twice. This will lead to confusing results.
          if (specifiedFields[field]) {
              throw new Error("Invalid format. " + field + " specified twice in format");
          }
          specifiedFields[field] = true;
          // Check if there are any required fields. For instance, 12 hour time requires AM/PM specified
          if (requiredField) {
              requiredFields[requiredField] = true;
          }
          parseInfo.push(info);
          return "(" + regex + ")";
      });
      // Check all the required fields are present
      Object.keys(requiredFields).forEach(function (field) {
          if (!specifiedFields[field]) {
              throw new Error("Invalid format. " + field + " is required in specified format");
          }
      });
      // Add back all the literals after
      newFormat = newFormat.replace(/@@@/g, function () { return literals.shift(); });
      // Check if the date string matches the format. If it doesn't return null
      var matches = dateStr.match(new RegExp(newFormat, "i"));
      if (!matches) {
          return null;
      }
      var combinedI18nSettings = assign(assign({}, globalI18n), i18n);
      // For each match, call the parser function for that date part
      for (var i = 1; i < matches.length; i++) {
          var _a = parseInfo[i - 1], field = _a[0], parser = _a[2];
          var value = parser
              ? parser(matches[i], combinedI18nSettings)
              : +matches[i];
          // If the parser can't make sense of the value, return null
          if (value == null) {
              return null;
          }
          dateInfo[field] = value;
      }
      if (dateInfo.isPm === 1 && dateInfo.hour != null && +dateInfo.hour !== 12) {
          dateInfo.hour = +dateInfo.hour + 12;
      }
      else if (dateInfo.isPm === 0 && +dateInfo.hour === 12) {
          dateInfo.hour = 0;
      }
      var dateTZ;
      if (dateInfo.timezoneOffset == null) {
          dateTZ = new Date(dateInfo.year, dateInfo.month, dateInfo.day, dateInfo.hour, dateInfo.minute, dateInfo.second, dateInfo.millisecond);
          var validateFields = [
              ["month", "getMonth"],
              ["day", "getDate"],
              ["hour", "getHours"],
              ["minute", "getMinutes"],
              ["second", "getSeconds"]
          ];
          for (var i = 0, len = validateFields.length; i < len; i++) {
              // Check to make sure the date field is within the allowed range. Javascript dates allows values
              // outside the allowed range. If the values don't match the value was invalid
              if (specifiedFields[validateFields[i][0]] &&
                  dateInfo[validateFields[i][0]] !== dateTZ[validateFields[i][1]]()) {
                  return null;
              }
          }
      }
      else {
          dateTZ = new Date(Date.UTC(dateInfo.year, dateInfo.month, dateInfo.day, dateInfo.hour, dateInfo.minute - dateInfo.timezoneOffset, dateInfo.second, dateInfo.millisecond));
          // We can't validate dates in another timezone unfortunately. Do a basic check instead
          if (dateInfo.month > 11 ||
              dateInfo.month < 0 ||
              dateInfo.day > 31 ||
              dateInfo.day < 1 ||
              dateInfo.hour > 23 ||
              dateInfo.hour < 0 ||
              dateInfo.minute > 59 ||
              dateInfo.minute < 0 ||
              dateInfo.second > 59 ||
              dateInfo.second < 0) {
              return null;
          }
      }
      // Don't allow invalid dates
      return dateTZ;
  }
  var fecha = {
      format: format,
      parse: parse,
      defaultI18n: defaultI18n,
      setGlobalDateI18n: setGlobalDateI18n,
      setGlobalDateMasks: setGlobalDateMasks
  };

  exports.assign = assign;
  exports.default = fecha;
  exports.format = format;
  exports.parse = parse;
  exports.defaultI18n = defaultI18n;
  exports.setGlobalDateI18n = setGlobalDateI18n;
  exports.setGlobalDateMasks = setGlobalDateMasks;

  Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=fecha.umd.js.map


/***/ }),

/***/ 29983:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {


/**
 * Module dependencies.
 */

var sep = (__nccwpck_require__(16928).sep) || '/';

/**
 * Module exports.
 */

module.exports = fileUriToPath;

/**
 * File URI to Path function.
 *
 * @param {String} uri
 * @return {String} path
 * @api public
 */

function fileUriToPath (uri) {
  if ('string' != typeof uri ||
      uri.length <= 7 ||
      'file://' != uri.substring(0, 7)) {
    throw new TypeError('must pass in a file:// URI to convert to a file path');
  }

  var rest = decodeURI(uri.substring(7));
  var firstSlash = rest.indexOf('/');
  var host = rest.substring(0, firstSlash);
  var path = rest.substring(firstSlash + 1);

  // 2.  Scheme Definition
  // As a special case, <host> can be the string "localhost" or the empty
  // string; this is interpreted as "the machine from which the URL is
  // being interpreted".
  if ('localhost' == host) host = '';

  if (host) {
    host = sep + sep + host;
  }

  // 3.2  Drives, drive letters, mount points, file system root
  // Drive letters are mapped into the top of a file URI in various ways,
  // depending on the implementation; some applications substitute
  // vertical bar ("|") for the colon after the drive letter, yielding
  // "file:///c|/tmp/test.txt".  In some cases, the colon is left
  // unchanged, as in "file:///c:/tmp/test.txt".  In other cases, the
  // colon is simply omitted, as in "file:///c/tmp/test.txt".
  path = path.replace(/^(.+)\|/, '$1:');

  // for Windows, we need to invert the path separators from what a URI uses
  if (sep == '\\') {
    path = path.replace(/\//g, '\\');
  }

  if (/^.+\:/.test(path)) {
    // has Windows drive at beginning of path
  } else {
    // unix path‚Ä¶
    path = sep + path;
  }

  return host + path;
}


/***/ }),

/***/ 58864:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";
/*!
 * finalhandler
 * Copyright(c) 2014-2022 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module dependencies.
 * @private
 */

var debug = __nccwpck_require__(82118)('finalhandler')
var encodeUrl = __nccwpck_require__(83835)
var escapeHtml = __nccwpck_require__(12759)
var onFinished = __nccwpck_require__(5698)
var parseUrl = __nccwpck_require__(83404)
var statuses = __nccwpck_require__(44650)
var unpipe = __nccwpck_require__(66367)

/**
 * Module variables.
 * @private
 */

var DOUBLE_SPACE_REGEXP = /\x20{2}/g
var NEWLINE_REGEXP = /\n/g

/* istanbul ignore next */
var defer = typeof setImmediate === 'function'
  ? setImmediate
  : function (fn) { process.nextTick(fn.bind.apply(fn, arguments)) }
var isFinished = onFinished.isFinished

/**
 * Create a minimal HTML document.
 *
 * @param {string} message
 * @private
 */

function createHtmlDocument (message) {
  var body = escapeHtml(message)
    .replace(NEWLINE_REGEXP, '<br>')
    .replace(DOUBLE_SPACE_REGEXP, ' &nbsp;')

  return '<!DOCTYPE html>\n' +
    '<html lang="en">\n' +
    '<head>\n' +
    '<meta charset="utf-8">\n' +
    '<title>Error</title>\n' +
    '</head>\n' +
    '<body>\n' +
    '<pre>' + body + '</pre>\n' +
    '</body>\n' +
    '</html>\n'
}

/**
 * Module exports.
 * @public
 */

module.exports = finalhandler

/**
 * Create a function to handle the final response.
 *
 * @param {Request} req
 * @param {Response} res
 * @param {Object} [options]
 * @return {Function}
 * @public
 */

function finalhandler (req, res, options) {
  var opts = options || {}

  // get environment
  var env = opts.env || process.env.NODE_ENV || 'development'

  // get error callback
  var onerror = opts.onerror

  return function (err) {
    var headers
    var msg
    var status

    // ignore 404 on in-flight response
    if (!err && headersSent(res)) {
      debug('cannot 404 after headers sent')
      return
    }

    // unhandled error
    if (err) {
      // respect status code from error
      status = getErrorStatusCode(err)

      if (status === undefined) {
        // fallback to status code on response
        status = getResponseStatusCode(res)
      } else {
        // respect headers from error
        headers = getErrorHeaders(err)
      }

      // get error message
      msg = getErrorMessage(err, status, env)
    } else {
      // not found
      status = 404
      msg = 'Cannot ' + req.method + ' ' + encodeUrl(getResourceName(req))
    }

    debug('default %s', status)

    // schedule onerror callback
    if (err && onerror) {
      defer(onerror, err, req, res)
    }

    // cannot actually respond
    if (headersSent(res)) {
      debug('cannot %d after headers sent', status)
      if (req.socket) {
        req.socket.destroy()
      }
      return
    }

    // send response
    send(req, res, status, headers, msg)
  }
}

/**
 * Get headers from Error object.
 *
 * @param {Error} err
 * @return {object}
 * @private
 */

function getErrorHeaders (err) {
  if (!err.headers || typeof err.headers !== 'object') {
    return undefined
  }

  var headers = Object.create(null)
  var keys = Object.keys(err.headers)

  for (var i = 0; i < keys.length; i++) {
    var key = keys[i]
    headers[key] = err.headers[key]
  }

  return headers
}

/**
 * Get message from Error object, fallback to status message.
 *
 * @param {Error} err
 * @param {number} status
 * @param {string} env
 * @return {string}
 * @private
 */

function getErrorMessage (err, status, env) {
  var msg

  if (env !== 'production') {
    // use err.stack, which typically includes err.message
    msg = err.stack

    // fallback to err.toString() when possible
    if (!msg && typeof err.toString === 'function') {
      msg = err.toString()
    }
  }

  return msg || statuses.message[status]
}

/**
 * Get status code from Error object.
 *
 * @param {Error} err
 * @return {number}
 * @private
 */

function getErrorStatusCode (err) {
  // check err.status
  if (typeof err.status === 'number' && err.status >= 400 && err.status < 600) {
    return err.status
  }

  // check err.statusCode
  if (typeof err.statusCode === 'number' && err.statusCode >= 400 && err.statusCode < 600) {
    return err.statusCode
  }

  return undefined
}

/**
 * Get resource name for the request.
 *
 * This is typically just the original pathname of the request
 * but will fallback to "resource" is that cannot be determined.
 *
 * @param {IncomingMessage} req
 * @return {string}
 * @private
 */

function getResourceName (req) {
  try {
    return parseUrl.original(req).pathname
  } catch (e) {
    return 'resource'
  }
}

/**
 * Get status code from response.
 *
 * @param {OutgoingMessage} res
 * @return {number}
 * @private
 */

function getResponseStatusCode (res) {
  var status = res.statusCode

  // default status code to 500 if outside valid range
  if (typeof status !== 'number' || status < 400 || status > 599) {
    status = 500
  }

  return status
}

/**
 * Determine if the response headers have been sent.
 *
 * @param {object} res
 * @returns {boolean}
 * @private
 */

function headersSent (res) {
  return typeof res.headersSent !== 'boolean'
    ? Boolean(res._header)
    : res.headersSent
}

/**
 * Send response.
 *
 * @param {IncomingMessage} req
 * @param {OutgoingMessage} res
 * @param {number} status
 * @param {object} headers
 * @param {string} message
 * @private
 */

function send (req, res, status, headers, message) {
  function write () {
    // response body
    var body = createHtmlDocument(message)

    // response status
    res.statusCode = status

    if (req.httpVersionMajor < 2) {
      res.statusMessage = statuses.message[status]
    }

    // remove any content headers
    res.removeHeader('Content-Encoding')
    res.removeHeader('Content-Language')
    res.removeHeader('Content-Range')

    // response headers
    setHeaders(res, headers)

    // security headers
    res.setHeader('Content-Security-Policy', "default-src 'none'")
    res.setHeader('X-Content-Type-Options', 'nosniff')

    // standard headers
    res.setHeader('Content-Type', 'text/html; charset=utf-8')
    res.setHeader('Content-Length', Buffer.byteLength(body, 'utf8'))

    if (req.method === 'HEAD') {
      res.end()
      return
    }

    res.end(body, 'utf8')
  }

  if (isFinished(req)) {
    write()
    return
  }

  // unpipe everything from the request
  unpipe(req)

  // flush the request
  onFinished(req, write)
  req.resume()
}

/**
 * Set response headers from an object.
 *
 * @param {OutgoingMessage} res
 * @param {object} headers
 * @private
 */

function setHeaders (res, headers) {
  if (!headers) {
    return
  }

  var keys = Object.keys(headers)
  for (var i = 0; i < keys.length; i++) {
    var key = keys[i]
    res.setHeader(key, headers[key])
  }
}


/***/ }),

/***/ 502:
/***/ ((module, exports, __nccwpck_require__) => {

/**
 * This is the web browser implementation of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = __nccwpck_require__(88433);
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = 'undefined' != typeof chrome
               && 'undefined' != typeof chrome.storage
                  ? chrome.storage.local
                  : localstorage();

/**
 * Colors.
 */

exports.colors = [
  'lightseagreen',
  'forestgreen',
  'goldenrod',
  'dodgerblue',
  'darkorchid',
  'crimson'
];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

function useColors() {
  // NB: In an Electron preload script, document will be defined but not fully
  // initialized. Since we know we're in Chrome, we'll just detect this case
  // explicitly
  if (typeof window !== 'undefined' && window.process && window.process.type === 'renderer') {
    return true;
  }

  // is webkit? http://stackoverflow.com/a/16459606/376773
  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
  return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||
    // is firebug? http://stackoverflow.com/a/398120/376773
    (typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||
    // is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||
    // double check webkit in userAgent just in case we are in a worker
    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/));
}

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

exports.formatters.j = function(v) {
  try {
    return JSON.stringify(v);
  } catch (err) {
    return '[UnexpectedJSONParseError]: ' + err.message;
  }
};


/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs(args) {
  var useColors = this.useColors;

  args[0] = (useColors ? '%c' : '')
    + this.namespace
    + (useColors ? ' %c' : ' ')
    + args[0]
    + (useColors ? '%c ' : ' ')
    + '+' + exports.humanize(this.diff);

  if (!useColors) return;

  var c = 'color: ' + this.color;
  args.splice(1, 0, c, 'color: inherit')

  // the final "%c" is somewhat tricky, because there could be other
  // arguments passed either before or after the %c, so we need to
  // figure out the correct index to insert the CSS into
  var index = 0;
  var lastC = 0;
  args[0].replace(/%[a-zA-Z%]/g, function(match) {
    if ('%%' === match) return;
    index++;
    if ('%c' === match) {
      // we only are interested in the *last* %c
      // (the user may have provided their own)
      lastC = index;
    }
  });

  args.splice(lastC, 0, c);
}

/**
 * Invokes `console.log()` when available.
 * No-op when `console.log` is not a "function".
 *
 * @api public
 */

function log() {
  // this hackery is required for IE8/9, where
  // the `console.log` function doesn't have 'apply'
  return 'object' === typeof console
    && console.log
    && Function.prototype.apply.call(console.log, console, arguments);
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */

function save(namespaces) {
  try {
    if (null == namespaces) {
      exports.storage.removeItem('debug');
    } else {
      exports.storage.debug = namespaces;
    }
  } catch(e) {}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

function load() {
  var r;
  try {
    r = exports.storage.debug;
  } catch(e) {}

  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG
  if (!r && typeof process !== 'undefined' && 'env' in process) {
    r = process.env.DEBUG;
  }

  return r;
}

/**
 * Enable namespaces listed in `localStorage.debug` initially.
 */

exports.enable(load());

/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */

function localstorage() {
  try {
    return window.localStorage;
  } catch (e) {}
}


/***/ }),

/***/ 88433:
/***/ ((module, exports, __nccwpck_require__) => {


/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = createDebug.debug = createDebug['default'] = createDebug;
exports.coerce = coerce;
exports.disable = disable;
exports.enable = enable;
exports.enabled = enabled;
exports.humanize = __nccwpck_require__(3584);

/**
 * The currently active debug mode names, and names to skip.
 */

exports.names = [];
exports.skips = [];

/**
 * Map of special "%n" handling functions, for the debug "format" argument.
 *
 * Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
 */

exports.formatters = {};

/**
 * Previous log timestamp.
 */

var prevTime;

/**
 * Select a color.
 * @param {String} namespace
 * @return {Number}
 * @api private
 */

function selectColor(namespace) {
  var hash = 0, i;

  for (i in namespace) {
    hash  = ((hash << 5) - hash) + namespace.charCodeAt(i);
    hash |= 0; // Convert to 32bit integer
  }

  return exports.colors[Math.abs(hash) % exports.colors.length];
}

/**
 * Create a debugger with the given `namespace`.
 *
 * @param {String} namespace
 * @return {Function}
 * @api public
 */

function createDebug(namespace) {

  function debug() {
    // disabled?
    if (!debug.enabled) return;

    var self = debug;

    // set `diff` timestamp
    var curr = +new Date();
    var ms = curr - (prevTime || curr);
    self.diff = ms;
    self.prev = prevTime;
    self.curr = curr;
    prevTime = curr;

    // turn the `arguments` into a proper Array
    var args = new Array(arguments.length);
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i];
    }

    args[0] = exports.coerce(args[0]);

    if ('string' !== typeof args[0]) {
      // anything else let's inspect with %O
      args.unshift('%O');
    }

    // apply any `formatters` transformations
    var index = 0;
    args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {
      // if we encounter an escaped % then don't increase the array index
      if (match === '%%') return match;
      index++;
      var formatter = exports.formatters[format];
      if ('function' === typeof formatter) {
        var val = args[index];
        match = formatter.call(self, val);

        // now we need to remove `args[index]` since it's inlined in the `format`
        args.splice(index, 1);
        index--;
      }
      return match;
    });

    // apply env-specific formatting (colors, etc.)
    exports.formatArgs.call(self, args);

    var logFn = debug.log || exports.log || console.log.bind(console);
    logFn.apply(self, args);
  }

  debug.namespace = namespace;
  debug.enabled = exports.enabled(namespace);
  debug.useColors = exports.useColors();
  debug.color = selectColor(namespace);

  // env-specific initialization logic for debug instances
  if ('function' === typeof exports.init) {
    exports.init(debug);
  }

  return debug;
}

/**
 * Enables a debug mode by namespaces. This can include modes
 * separated by a colon and wildcards.
 *
 * @param {String} namespaces
 * @api public
 */

function enable(namespaces) {
  exports.save(namespaces);

  exports.names = [];
  exports.skips = [];

  var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
  var len = split.length;

  for (var i = 0; i < len; i++) {
    if (!split[i]) continue; // ignore empty strings
    namespaces = split[i].replace(/\*/g, '.*?');
    if (namespaces[0] === '-') {
      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
    } else {
      exports.names.push(new RegExp('^' + namespaces + '$'));
    }
  }
}

/**
 * Disable debug output.
 *
 * @api public
 */

function disable() {
  exports.enable('');
}

/**
 * Returns true if the given mode name is enabled, false otherwise.
 *
 * @param {String} name
 * @return {Boolean}
 * @api public
 */

function enabled(name) {
  var i, len;
  for (i = 0, len = exports.skips.length; i < len; i++) {
    if (exports.skips[i].test(name)) {
      return false;
    }
  }
  for (i = 0, len = exports.names.length; i < len; i++) {
    if (exports.names[i].test(name)) {
      return true;
    }
  }
  return false;
}

/**
 * Coerce `val`.
 *
 * @param {Mixed} val
 * @return {Mixed}
 * @api private
 */

function coerce(val) {
  if (val instanceof Error) return val.stack || val.message;
  return val;
}


/***/ }),

/***/ 82118:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

/**
 * Detect Electron renderer process, which is node, but we should
 * treat as a browser.
 */

if (typeof process !== 'undefined' && process.type === 'renderer') {
  module.exports = __nccwpck_require__(502);
} else {
  module.exports = __nccwpck_require__(56060);
}


/***/ }),

/***/ 56060:
/***/ ((module, exports, __nccwpck_require__) => {

/**
 * Module dependencies.
 */

var tty = __nccwpck_require__(52018);
var util = __nccwpck_require__(39023);

/**
 * This is the Node.js implementation of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = __nccwpck_require__(88433);
exports.init = init;
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;

/**
 * Colors.
 */

exports.colors = [6, 2, 3, 4, 5, 1];

/**
 * Build up the default `inspectOpts` object from the environment variables.
 *
 *   $ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js
 */

exports.inspectOpts = Object.keys(process.env).filter(function (key) {
  return /^debug_/i.test(key);
}).reduce(function (obj, key) {
  // camel-case
  var prop = key
    .substring(6)
    .toLowerCase()
    .replace(/_([a-z])/g, function (_, k) { return k.toUpperCase() });

  // coerce string value into JS value
  var val = process.env[key];
  if (/^(yes|on|true|enabled)$/i.test(val)) val = true;
  else if (/^(no|off|false|disabled)$/i.test(val)) val = false;
  else if (val === 'null') val = null;
  else val = Number(val);

  obj[prop] = val;
  return obj;
}, {});

/**
 * The file descriptor to write the `debug()` calls to.
 * Set the `DEBUG_FD` env variable to override with another value. i.e.:
 *
 *   $ DEBUG_FD=3 node script.js 3>debug.log
 */

var fd = parseInt(process.env.DEBUG_FD, 10) || 2;

if (1 !== fd && 2 !== fd) {
  util.deprecate(function(){}, 'except for stderr(2) and stdout(1), any other usage of DEBUG_FD is deprecated. Override debug.log if you want to use a different log function (https://git.io/debug_fd)')()
}

var stream = 1 === fd ? process.stdout :
             2 === fd ? process.stderr :
             createWritableStdioStream(fd);

/**
 * Is stdout a TTY? Colored output is enabled when `true`.
 */

function useColors() {
  return 'colors' in exports.inspectOpts
    ? Boolean(exports.inspectOpts.colors)
    : tty.isatty(fd);
}

/**
 * Map %o to `util.inspect()`, all on a single line.
 */

exports.formatters.o = function(v) {
  this.inspectOpts.colors = this.useColors;
  return util.inspect(v, this.inspectOpts)
    .split('\n').map(function(str) {
      return str.trim()
    }).join(' ');
};

/**
 * Map %o to `util.inspect()`, allowing multiple lines if needed.
 */

exports.formatters.O = function(v) {
  this.inspectOpts.colors = this.useColors;
  return util.inspect(v, this.inspectOpts);
};

/**
 * Adds ANSI color escape codes if enabled.
 *
 * @api public
 */

function formatArgs(args) {
  var name = this.namespace;
  var useColors = this.useColors;

  if (useColors) {
    var c = this.color;
    var prefix = '  \u001b[3' + c + ';1m' + name + ' ' + '\u001b[0m';

    args[0] = prefix + args[0].split('\n').join('\n' + prefix);
    args.push('\u001b[3' + c + 'm+' + exports.humanize(this.diff) + '\u001b[0m');
  } else {
    args[0] = new Date().toUTCString()
      + ' ' + name + ' ' + args[0];
  }
}

/**
 * Invokes `util.format()` with the specified arguments and writes to `stream`.
 */

function log() {
  return stream.write(util.format.apply(util, arguments) + '\n');
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */

function save(namespaces) {
  if (null == namespaces) {
    // If you set a process.env field to null or undefined, it gets cast to the
    // string 'null' or 'undefined'. Just delete instead.
    delete process.env.DEBUG;
  } else {
    process.env.DEBUG = namespaces;
  }
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

function load() {
  return process.env.DEBUG;
}

/**
 * Copied from `node/src/node.js`.
 *
 * XXX: It's lame that node doesn't expose this API out-of-the-box. It also
 * relies on the undocumented `tty_wrap.guessHandleType()` which is also lame.
 */

function createWritableStdioStream (fd) {
  var stream;
  var tty_wrap = process.binding('tty_wrap');

  // Note stream._type is used for test-module-load-list.js

  switch (tty_wrap.guessHandleType(fd)) {
    case 'TTY':
      stream = new tty.WriteStream(fd);
      stream._type = 'tty';

      // Hack to have stream not keep the event loop alive.
      // See https://github.com/joyent/node/issues/1726
      if (stream._handle && stream._handle.unref) {
        stream._handle.unref();
      }
      break;

    case 'FILE':
      var fs = __nccwpck_require__(79896);
      stream = new fs.SyncWriteStream(fd, { autoClose: false });
      stream._type = 'fs';
      break;

    case 'PIPE':
    case 'TCP':
      var net = __nccwpck_require__(69278);
      stream = new net.Socket({
        fd: fd,
        readable: false,
        writable: true
      });

      // FIXME Should probably have an option in net.Socket to create a
      // stream from an existing fd which is writable only. But for now
      // we'll just add this hack and set the `readable` member to false.
      // Test: ./node test/fixtures/echo.js < /etc/passwd
      stream.readable = false;
      stream.read = null;
      stream._type = 'pipe';

      // FIXME Hack to have stream not keep the event loop alive.
      // See https://github.com/joyent/node/issues/1726
      if (stream._handle && stream._handle.unref) {
        stream._handle.unref();
      }
      break;

    default:
      // Probably an error on in uv_guess_handle()
      throw new Error('Implement me. Unknown stream file type!');
  }

  // For supporting legacy API we put the FD here.
  stream.fd = fd;

  stream._isStdio = true;

  return stream;
}

/**
 * Init logic for `debug` instances.
 *
 * Create a new `inspectOpts` object in case `useColors` is set
 * differently for a particular `debug` instance.
 */

function init (debug) {
  debug.inspectOpts = {};

  var keys = Object.keys(exports.inspectOpts);
  for (var i = 0; i < keys.length; i++) {
    debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
  }
}

/**
 * Enable namespaces listed in `process.env.DEBUG` initially.
 */

exports.enable(load());


/***/ }),

/***/ 3584:
/***/ ((module) => {

/**
 * Helpers.
 */

var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var y = d * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */

module.exports = function(val, options) {
  options = options || {};
  var type = typeof val;
  if (type === 'string' && val.length > 0) {
    return parse(val);
  } else if (type === 'number' && isNaN(val) === false) {
    return options.long ? fmtLong(val) : fmtShort(val);
  }
  throw new Error(
    'val is not a non-empty string or a valid number. val=' +
      JSON.stringify(val)
  );
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  str = String(str);
  if (str.length > 100) {
    return;
  }
  var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(
    str
  );
  if (!match) {
    return;
  }
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;
    case 'days':
    case 'day':
    case 'd':
      return n * d;
    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h;
    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m;
    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s;
    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;
    default:
      return undefined;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtShort(ms) {
  if (ms >= d) {
    return Math.round(ms / d) + 'd';
  }
  if (ms >= h) {
    return Math.round(ms / h) + 'h';
  }
  if (ms >= m) {
    return Math.round(ms / m) + 'm';
  }
  if (ms >= s) {
    return Math.round(ms / s) + 's';
  }
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtLong(ms) {
  return plural(ms, d, 'day') ||
    plural(ms, h, 'hour') ||
    plural(ms, m, 'minute') ||
    plural(ms, s, 'second') ||
    ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural(ms, n, name) {
  if (ms < n) {
    return;
  }
  if (ms < n * 1.5) {
    return Math.floor(ms / n) + ' ' + name;
  }
  return Math.ceil(ms / n) + ' ' + name + 's';
}


/***/ }),

/***/ 16057:
/***/ ((module) => {

"use strict";


var toString = Object.prototype.toString;

/**
 * Extract names from functions.
 *
 * @param {Function} fn The function who's name we need to extract.
 * @returns {String} The name of the function.
 * @public
 */
module.exports = function name(fn) {
  if ('string' === typeof fn.displayName && fn.constructor.name) {
    return fn.displayName;
  } else if ('string' === typeof fn.name && fn.name) {
    return fn.name;
  }

  //
  // Check to see if the constructor has a name.
  //
  if (
       'object' === typeof fn
    && fn.constructor
    && 'string' === typeof fn.constructor.name
  ) return fn.constructor.name;

  //
  // toString the given function and attempt to parse it out of it, or determine
  // the class.
  //
  var named = fn.toString()
    , type = toString.call(fn).slice(8, -1);

  if ('Function' === type) {
    named = named.substring(named.indexOf('(') + 1, named.indexOf(')'));
  } else {
    named = type;
  }

  return named || 'anonymous';
};


/***/ }),

/***/ 55200:
/***/ ((module) => {

"use strict";
/*!
 * forwarded
 * Copyright(c) 2014-2017 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module exports.
 * @public
 */

module.exports = forwarded

/**
 * Get all addresses in the request, using the `X-Forwarded-For` header.
 *
 * @param {object} req
 * @return {array}
 * @public
 */

function forwarded (req) {
  if (!req) {
    throw new TypeError('argument req is required')
  }

  // simple header parsing
  var proxyAddrs = parse(req.headers['x-forwarded-for'] || '')
  var socketAddr = getSocketAddr(req)
  var addrs = [socketAddr].concat(proxyAddrs)

  // return all addresses
  return addrs
}

/**
 * Get the socket address for a request.
 *
 * @param {object} req
 * @return {string}
 * @private
 */

function getSocketAddr (req) {
  return req.socket
    ? req.socket.remoteAddress
    : req.connection.remoteAddress
}

/**
 * Parse the X-Forwarded-For header.
 *
 * @param {string} header
 * @private
 */

function parse (header) {
  var end = header.length
  var list = []
  var start = header.length

  // gather addresses, backwards
  for (var i = header.length - 1; i >= 0; i--) {
    switch (header.charCodeAt(i)) {
      case 0x20: /*   */
        if (start === end) {
          start = end = i
        }
        break
      case 0x2c: /* , */
        if (start !== end) {
          list.push(header.substring(start, end))
        }
        start = end = i
        break
      default:
        start = i
        break
    }
  }

  // final address
  if (start !== end) {
    list.push(header.substring(start, end))
  }

  return list
}


/***/ }),

/***/ 53136:
/***/ ((module) => {

"use strict";
/*!
 * fresh
 * Copyright(c) 2012 TJ Holowaychuk
 * Copyright(c) 2016-2017 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * RegExp to check for no-cache token in Cache-Control.
 * @private
 */

var CACHE_CONTROL_NO_CACHE_REGEXP = /(?:^|,)\s*?no-cache\s*?(?:,|$)/

/**
 * Module exports.
 * @public
 */

module.exports = fresh

/**
 * Check freshness of the response using request and response headers.
 *
 * @param {Object} reqHeaders
 * @param {Object} resHeaders
 * @return {Boolean}
 * @public
 */

function fresh (reqHeaders, resHeaders) {
  // fields
  var modifiedSince = reqHeaders['if-modified-since']
  var noneMatch = reqHeaders['if-none-match']

  // unconditional request
  if (!modifiedSince && !noneMatch) {
    return false
  }

  // Always return stale when Cache-Control: no-cache
  // to support end-to-end reload requests
  // https://tools.ietf.org/html/rfc2616#section-14.9.4
  var cacheControl = reqHeaders['cache-control']
  if (cacheControl && CACHE_CONTROL_NO_CACHE_REGEXP.test(cacheControl)) {
    return false
  }

  // if-none-match
  if (noneMatch && noneMatch !== '*') {
    var etag = resHeaders['etag']

    if (!etag) {
      return false
    }

    var etagStale = true
    var matches = parseTokenList(noneMatch)
    for (var i = 0; i < matches.length; i++) {
      var match = matches[i]
      if (match === etag || match === 'W/' + etag || 'W/' + match === etag) {
        etagStale = false
        break
      }
    }

    if (etagStale) {
      return false
    }
  }

  // if-modified-since
  if (modifiedSince) {
    var lastModified = resHeaders['last-modified']
    var modifiedStale = !lastModified || !(parseHttpDate(lastModified) <= parseHttpDate(modifiedSince))

    if (modifiedStale) {
      return false
    }
  }

  return true
}

/**
 * Parse an HTTP Date into a number.
 *
 * @param {string} date
 * @private
 */

function parseHttpDate (date) {
  var timestamp = date && Date.parse(date)

  // istanbul ignore next: guard against date.js Date.parse patching
  return typeof timestamp === 'number'
    ? timestamp
    : NaN
}

/**
 * Parse a HTTP token list.
 *
 * @param {string} str
 * @private
 */

function parseTokenList (str) {
  var end = 0
  var list = []
  var start = 0

  // gather tokens
  for (var i = 0, len = str.length; i < len; i++) {
    switch (str.charCodeAt(i)) {
      case 0x20: /*   */
        if (start === end) {
          start = end = i + 1
        }
        break
      case 0x2c: /* , */
        list.push(str.substring(start, end))
        start = end = i + 1
        break
      default:
        end = i + 1
        break
    }
  }

  // final token
  list.push(str.substring(start, end))

  return list
}


/***/ }),

/***/ 99808:
/***/ ((module) => {

"use strict";


/* eslint no-invalid-this: 1 */

var ERROR_MESSAGE = 'Function.prototype.bind called on incompatible ';
var toStr = Object.prototype.toString;
var max = Math.max;
var funcType = '[object Function]';

var concatty = function concatty(a, b) {
    var arr = [];

    for (var i = 0; i < a.length; i += 1) {
        arr[i] = a[i];
    }
    for (var j = 0; j < b.length; j += 1) {
        arr[j + a.length] = b[j];
    }

    return arr;
};

var slicy = function slicy(arrLike, offset) {
    var arr = [];
    for (var i = offset || 0, j = 0; i < arrLike.length; i += 1, j += 1) {
        arr[j] = arrLike[i];
    }
    return arr;
};

var joiny = function (arr, joiner) {
    var str = '';
    for (var i = 0; i < arr.length; i += 1) {
        str += arr[i];
        if (i + 1 < arr.length) {
            str += joiner;
        }
    }
    return str;
};

module.exports = function bind(that) {
    var target = this;
    if (typeof target !== 'function' || toStr.apply(target) !== funcType) {
        throw new TypeError(ERROR_MESSAGE + target);
    }
    var args = slicy(arguments, 1);

    var bound;
    var binder = function () {
        if (this instanceof bound) {
            var result = target.apply(
                this,
                concatty(args, arguments)
            );
            if (Object(result) === result) {
                return result;
            }
            return this;
        }
        return target.apply(
            that,
            concatty(args, arguments)
        );

    };

    var boundLength = max(0, target.length - args.length);
    var boundArgs = [];
    for (var i = 0; i < boundLength; i++) {
        boundArgs[i] = '$' + i;
    }

    bound = Function('binder', 'return function (' + joiny(boundArgs, ',') + '){ return binder.apply(this,arguments); }')(binder);

    if (target.prototype) {
        var Empty = function Empty() {};
        Empty.prototype = target.prototype;
        bound.prototype = new Empty();
        Empty.prototype = null;
    }

    return bound;
};


/***/ }),

/***/ 37564:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


var implementation = __nccwpck_require__(99808);

module.exports = Function.prototype.bind || implementation;


/***/ }),

/***/ 44498:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var util = __nccwpck_require__(39023)
var isProperty = __nccwpck_require__(716)

var INDENT_START = /[\{\[]/
var INDENT_END = /[\}\]]/

// from https://mathiasbynens.be/notes/reserved-keywords
var RESERVED = [
  'do',
  'if',
  'in',
  'for',
  'let',
  'new',
  'try',
  'var',
  'case',
  'else',
  'enum',
  'eval',
  'null',
  'this',
  'true',
  'void',
  'with',
  'await',
  'break',
  'catch',
  'class',
  'const',
  'false',
  'super',
  'throw',
  'while',
  'yield',
  'delete',
  'export',
  'import',
  'public',
  'return',
  'static',
  'switch',
  'typeof',
  'default',
  'extends',
  'finally',
  'package',
  'private',
  'continue',
  'debugger',
  'function',
  'arguments',
  'interface',
  'protected',
  'implements',
  'instanceof',
  'NaN',
  'undefined'
]

var RESERVED_MAP = {}

for (var i = 0; i < RESERVED.length; i++) {
  RESERVED_MAP[RESERVED[i]] = true
}

var isVariable = function (name) {
  return isProperty(name) && !RESERVED_MAP.hasOwnProperty(name)
}

var formats = {
  s: function(s) {
    return '' + s
  },
  d: function(d) {
    return '' + Number(d)
  },
  o: function(o) {
    return JSON.stringify(o)
  }
}

var genfun = function() {
  var lines = []
  var indent = 0
  var vars = {}

  var push = function(str) {
    var spaces = ''
    while (spaces.length < indent*2) spaces += '  '
    lines.push(spaces+str)
  }

  var pushLine = function(line) {
    if (INDENT_END.test(line.trim()[0]) && INDENT_START.test(line[line.length-1])) {
      indent--
      push(line)
      indent++
      return
    }
    if (INDENT_START.test(line[line.length-1])) {
      push(line)
      indent++
      return
    }
    if (INDENT_END.test(line.trim()[0])) {
      indent--
      push(line)
      return
    }

    push(line)
  }

  var line = function(fmt) {
    if (!fmt) return line

    if (arguments.length === 1 && fmt.indexOf('\n') > -1) {
      var lines = fmt.trim().split('\n')
      for (var i = 0; i < lines.length; i++) {
        pushLine(lines[i].trim())
      }
    } else {
      pushLine(util.format.apply(util, arguments))
    }

    return line
  }

  line.scope = {}
  line.formats = formats

  line.sym = function(name) {
    if (!name || !isVariable(name)) name = 'tmp'
    if (!vars[name]) vars[name] = 0
    return name + (vars[name]++ || '')
  }

  line.property = function(obj, name) {
    if (arguments.length === 1) {
      name = obj
      obj = ''
    }

    name = name + ''

    if (isProperty(name)) return (obj ? obj + '.' + name : name)
    return obj ? obj + '[' + JSON.stringify(name) + ']' : JSON.stringify(name)
  }

  line.toString = function() {
    return lines.join('\n')
  }

  line.toFunction = function(scope) {
    if (!scope) scope = {}

    var src = 'return ('+line.toString()+')'

    Object.keys(line.scope).forEach(function (key) {
      if (!scope[key]) scope[key] = line.scope[key]
    })

    var keys = Object.keys(scope).map(function(key) {
      return key
    })

    var vals = keys.map(function(key) {
      return scope[key]
    })

    return Function.apply(null, keys.concat(src)).apply(null, vals)
  }

  if (arguments.length) line.apply(null, arguments)

  return line
}

genfun.formats = formats
module.exports = genfun


/***/ }),

/***/ 60470:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


var undefined;

var $Object = __nccwpck_require__(95399);

var $Error = __nccwpck_require__(31620);
var $EvalError = __nccwpck_require__(33056);
var $RangeError = __nccwpck_require__(14585);
var $ReferenceError = __nccwpck_require__(46905);
var $SyntaxError = __nccwpck_require__(80105);
var $TypeError = __nccwpck_require__(73314);
var $URIError = __nccwpck_require__(32578);

var abs = __nccwpck_require__(55641);
var floor = __nccwpck_require__(96171);
var max = __nccwpck_require__(57147);
var min = __nccwpck_require__(41017);
var pow = __nccwpck_require__(56947);
var round = __nccwpck_require__(42621);
var sign = __nccwpck_require__(30156);

var $Function = Function;

// eslint-disable-next-line consistent-return
var getEvalledConstructor = function (expressionSyntax) {
	try {
		return $Function('"use strict"; return (' + expressionSyntax + ').constructor;')();
	} catch (e) {}
};

var $gOPD = __nccwpck_require__(33170);
var $defineProperty = __nccwpck_require__(79094);

var throwTypeError = function () {
	throw new $TypeError();
};
var ThrowTypeError = $gOPD
	? (function () {
		try {
			// eslint-disable-next-line no-unused-expressions, no-caller, no-restricted-properties
			arguments.callee; // IE 8 does not throw here
			return throwTypeError;
		} catch (calleeThrows) {
			try {
				// IE 8 throws on Object.getOwnPropertyDescriptor(arguments, '')
				return $gOPD(arguments, 'callee').get;
			} catch (gOPDthrows) {
				return throwTypeError;
			}
		}
	}())
	: throwTypeError;

var hasSymbols = __nccwpck_require__(23336)();

var getProto = __nccwpck_require__(81967);
var $ObjectGPO = __nccwpck_require__(91311);
var $ReflectGPO = __nccwpck_require__(48681);

var $apply = __nccwpck_require__(33945);
var $call = __nccwpck_require__(88093);

var needsEval = {};

var TypedArray = typeof Uint8Array === 'undefined' || !getProto ? undefined : getProto(Uint8Array);

var INTRINSICS = {
	__proto__: null,
	'%AggregateError%': typeof AggregateError === 'undefined' ? undefined : AggregateError,
	'%Array%': Array,
	'%ArrayBuffer%': typeof ArrayBuffer === 'undefined' ? undefined : ArrayBuffer,
	'%ArrayIteratorPrototype%': hasSymbols && getProto ? getProto([][Symbol.iterator]()) : undefined,
	'%AsyncFromSyncIteratorPrototype%': undefined,
	'%AsyncFunction%': needsEval,
	'%AsyncGenerator%': needsEval,
	'%AsyncGeneratorFunction%': needsEval,
	'%AsyncIteratorPrototype%': needsEval,
	'%Atomics%': typeof Atomics === 'undefined' ? undefined : Atomics,
	'%BigInt%': typeof BigInt === 'undefined' ? undefined : BigInt,
	'%BigInt64Array%': typeof BigInt64Array === 'undefined' ? undefined : BigInt64Array,
	'%BigUint64Array%': typeof BigUint64Array === 'undefined' ? undefined : BigUint64Array,
	'%Boolean%': Boolean,
	'%DataView%': typeof DataView === 'undefined' ? undefined : DataView,
	'%Date%': Date,
	'%decodeURI%': decodeURI,
	'%decodeURIComponent%': decodeURIComponent,
	'%encodeURI%': encodeURI,
	'%encodeURIComponent%': encodeURIComponent,
	'%Error%': $Error,
	'%eval%': eval, // eslint-disable-line no-eval
	'%EvalError%': $EvalError,
	'%Float16Array%': typeof Float16Array === 'undefined' ? undefined : Float16Array,
	'%Float32Array%': typeof Float32Array === 'undefined' ? undefined : Float32Array,
	'%Float64Array%': typeof Float64Array === 'undefined' ? undefined : Float64Array,
	'%FinalizationRegistry%': typeof FinalizationRegistry === 'undefined' ? undefined : FinalizationRegistry,
	'%Function%': $Function,
	'%GeneratorFunction%': needsEval,
	'%Int8Array%': typeof Int8Array === 'undefined' ? undefined : Int8Array,
	'%Int16Array%': typeof Int16Array === 'undefined' ? undefined : Int16Array,
	'%Int32Array%': typeof Int32Array === 'undefined' ? undefined : Int32Array,
	'%isFinite%': isFinite,
	'%isNaN%': isNaN,
	'%IteratorPrototype%': hasSymbols && getProto ? getProto(getProto([][Symbol.iterator]())) : undefined,
	'%JSON%': typeof JSON === 'object' ? JSON : undefined,
	'%Map%': typeof Map === 'undefined' ? undefined : Map,
	'%MapIteratorPrototype%': typeof Map === 'undefined' || !hasSymbols || !getProto ? undefined : getProto(new Map()[Symbol.iterator]()),
	'%Math%': Math,
	'%Number%': Number,
	'%Object%': $Object,
	'%Object.getOwnPropertyDescriptor%': $gOPD,
	'%parseFloat%': parseFloat,
	'%parseInt%': parseInt,
	'%Promise%': typeof Promise === 'undefined' ? undefined : Promise,
	'%Proxy%': typeof Proxy === 'undefined' ? undefined : Proxy,
	'%RangeError%': $RangeError,
	'%ReferenceError%': $ReferenceError,
	'%Reflect%': typeof Reflect === 'undefined' ? undefined : Reflect,
	'%RegExp%': RegExp,
	'%Set%': typeof Set === 'undefined' ? undefined : Set,
	'%SetIteratorPrototype%': typeof Set === 'undefined' || !hasSymbols || !getProto ? undefined : getProto(new Set()[Symbol.iterator]()),
	'%SharedArrayBuffer%': typeof SharedArrayBuffer === 'undefined' ? undefined : SharedArrayBuffer,
	'%String%': String,
	'%StringIteratorPrototype%': hasSymbols && getProto ? getProto(''[Symbol.iterator]()) : undefined,
	'%Symbol%': hasSymbols ? Symbol : undefined,
	'%SyntaxError%': $SyntaxError,
	'%ThrowTypeError%': ThrowTypeError,
	'%TypedArray%': TypedArray,
	'%TypeError%': $TypeError,
	'%Uint8Array%': typeof Uint8Array === 'undefined' ? undefined : Uint8Array,
	'%Uint8ClampedArray%': typeof Uint8ClampedArray === 'undefined' ? undefined : Uint8ClampedArray,
	'%Uint16Array%': typeof Uint16Array === 'undefined' ? undefined : Uint16Array,
	'%Uint32Array%': typeof Uint32Array === 'undefined' ? undefined : Uint32Array,
	'%URIError%': $URIError,
	'%WeakMap%': typeof WeakMap === 'undefined' ? undefined : WeakMap,
	'%WeakRef%': typeof WeakRef === 'undefined' ? undefined : WeakRef,
	'%WeakSet%': typeof WeakSet === 'undefined' ? undefined : WeakSet,

	'%Function.prototype.call%': $call,
	'%Function.prototype.apply%': $apply,
	'%Object.defineProperty%': $defineProperty,
	'%Object.getPrototypeOf%': $ObjectGPO,
	'%Math.abs%': abs,
	'%Math.floor%': floor,
	'%Math.max%': max,
	'%Math.min%': min,
	'%Math.pow%': pow,
	'%Math.round%': round,
	'%Math.sign%': sign,
	'%Reflect.getPrototypeOf%': $ReflectGPO
};

if (getProto) {
	try {
		null.error; // eslint-disable-line no-unused-expressions
	} catch (e) {
		// https://github.com/tc39/proposal-shadowrealm/pull/384#issuecomment-1364264229
		var errorProto = getProto(getProto(e));
		INTRINSICS['%Error.prototype%'] = errorProto;
	}
}

var doEval = function doEval(name) {
	var value;
	if (name === '%AsyncFunction%') {
		value = getEvalledConstructor('async function () {}');
	} else if (name === '%GeneratorFunction%') {
		value = getEvalledConstructor('function* () {}');
	} else if (name === '%AsyncGeneratorFunction%') {
		value = getEvalledConstructor('async function* () {}');
	} else if (name === '%AsyncGenerator%') {
		var fn = doEval('%AsyncGeneratorFunction%');
		if (fn) {
			value = fn.prototype;
		}
	} else if (name === '%AsyncIteratorPrototype%') {
		var gen = doEval('%AsyncGenerator%');
		if (gen && getProto) {
			value = getProto(gen.prototype);
		}
	}

	INTRINSICS[name] = value;

	return value;
};

var LEGACY_ALIASES = {
	__proto__: null,
	'%ArrayBufferPrototype%': ['ArrayBuffer', 'prototype'],
	'%ArrayPrototype%': ['Array', 'prototype'],
	'%ArrayProto_entries%': ['Array', 'prototype', 'entries'],
	'%ArrayProto_forEach%': ['Array', 'prototype', 'forEach'],
	'%ArrayProto_keys%': ['Array', 'prototype', 'keys'],
	'%ArrayProto_values%': ['Array', 'prototype', 'values'],
	'%AsyncFunctionPrototype%': ['AsyncFunction', 'prototype'],
	'%AsyncGenerator%': ['AsyncGeneratorFunction', 'prototype'],
	'%AsyncGeneratorPrototype%': ['AsyncGeneratorFunction', 'prototype', 'prototype'],
	'%BooleanPrototype%': ['Boolean', 'prototype'],
	'%DataViewPrototype%': ['DataView', 'prototype'],
	'%DatePrototype%': ['Date', 'prototype'],
	'%ErrorPrototype%': ['Error', 'prototype'],
	'%EvalErrorPrototype%': ['EvalError', 'prototype'],
	'%Float32ArrayPrototype%': ['Float32Array', 'prototype'],
	'%Float64ArrayPrototype%': ['Float64Array', 'prototype'],
	'%FunctionPrototype%': ['Function', 'prototype'],
	'%Generator%': ['GeneratorFunction', 'prototype'],
	'%GeneratorPrototype%': ['GeneratorFunction', 'prototype', 'prototype'],
	'%Int8ArrayPrototype%': ['Int8Array', 'prototype'],
	'%Int16ArrayPrototype%': ['Int16Array', 'prototype'],
	'%Int32ArrayPrototype%': ['Int32Array', 'prototype'],
	'%JSONParse%': ['JSON', 'parse'],
	'%JSONStringify%': ['JSON', 'stringify'],
	'%MapPrototype%': ['Map', 'prototype'],
	'%NumberPrototype%': ['Number', 'prototype'],
	'%ObjectPrototype%': ['Object', 'prototype'],
	'%ObjProto_toString%': ['Object', 'prototype', 'toString'],
	'%ObjProto_valueOf%': ['Object', 'prototype', 'valueOf'],
	'%PromisePrototype%': ['Promise', 'prototype'],
	'%PromiseProto_then%': ['Promise', 'prototype', 'then'],
	'%Promise_all%': ['Promise', 'all'],
	'%Promise_reject%': ['Promise', 'reject'],
	'%Promise_resolve%': ['Promise', 'resolve'],
	'%RangeErrorPrototype%': ['RangeError', 'prototype'],
	'%ReferenceErrorPrototype%': ['ReferenceError', 'prototype'],
	'%RegExpPrototype%': ['RegExp', 'prototype'],
	'%SetPrototype%': ['Set', 'prototype'],
	'%SharedArrayBufferPrototype%': ['SharedArrayBuffer', 'prototype'],
	'%StringPrototype%': ['String', 'prototype'],
	'%SymbolPrototype%': ['Symbol', 'prototype'],
	'%SyntaxErrorPrototype%': ['SyntaxError', 'prototype'],
	'%TypedArrayPrototype%': ['TypedArray', 'prototype'],
	'%TypeErrorPrototype%': ['TypeError', 'prototype'],
	'%Uint8ArrayPrototype%': ['Uint8Array', 'prototype'],
	'%Uint8ClampedArrayPrototype%': ['Uint8ClampedArray', 'prototype'],
	'%Uint16ArrayPrototype%': ['Uint16Array', 'prototype'],
	'%Uint32ArrayPrototype%': ['Uint32Array', 'prototype'],
	'%URIErrorPrototype%': ['URIError', 'prototype'],
	'%WeakMapPrototype%': ['WeakMap', 'prototype'],
	'%WeakSetPrototype%': ['WeakSet', 'prototype']
};

var bind = __nccwpck_require__(37564);
var hasOwn = __nccwpck_require__(54076);
var $concat = bind.call($call, Array.prototype.concat);
var $spliceApply = bind.call($apply, Array.prototype.splice);
var $replace = bind.call($call, String.prototype.replace);
var $strSlice = bind.call($call, String.prototype.slice);
var $exec = bind.call($call, RegExp.prototype.exec);

/* adapted from https://github.com/lodash/lodash/blob/4.17.15/dist/lodash.js#L6735-L6744 */
var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
var reEscapeChar = /\\(\\)?/g; /** Used to match backslashes in property paths. */
var stringToPath = function stringToPath(string) {
	var first = $strSlice(string, 0, 1);
	var last = $strSlice(string, -1);
	if (first === '%' && last !== '%') {
		throw new $SyntaxError('invalid intrinsic syntax, expected closing `%`');
	} else if (last === '%' && first !== '%') {
		throw new $SyntaxError('invalid intrinsic syntax, expected opening `%`');
	}
	var result = [];
	$replace(string, rePropName, function (match, number, quote, subString) {
		result[result.length] = quote ? $replace(subString, reEscapeChar, '$1') : number || match;
	});
	return result;
};
/* end adaptation */

var getBaseIntrinsic = function getBaseIntrinsic(name, allowMissing) {
	var intrinsicName = name;
	var alias;
	if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
		alias = LEGACY_ALIASES[intrinsicName];
		intrinsicName = '%' + alias[0] + '%';
	}

	if (hasOwn(INTRINSICS, intrinsicName)) {
		var value = INTRINSICS[intrinsicName];
		if (value === needsEval) {
			value = doEval(intrinsicName);
		}
		if (typeof value === 'undefined' && !allowMissing) {
			throw new $TypeError('intrinsic ' + name + ' exists, but is not available. Please file an issue!');
		}

		return {
			alias: alias,
			name: intrinsicName,
			value: value
		};
	}

	throw new $SyntaxError('intrinsic ' + name + ' does not exist!');
};

module.exports = function GetIntrinsic(name, allowMissing) {
	if (typeof name !== 'string' || name.length === 0) {
		throw new $TypeError('intrinsic name must be a non-empty string');
	}
	if (arguments.length > 1 && typeof allowMissing !== 'boolean') {
		throw new $TypeError('"allowMissing" argument must be a boolean');
	}

	if ($exec(/^%?[^%]*%?$/, name) === null) {
		throw new $SyntaxError('`%` may not be present anywhere but at the beginning and end of the intrinsic name');
	}
	var parts = stringToPath(name);
	var intrinsicBaseName = parts.length > 0 ? parts[0] : '';

	var intrinsic = getBaseIntrinsic('%' + intrinsicBaseName + '%', allowMissing);
	var intrinsicRealName = intrinsic.name;
	var value = intrinsic.value;
	var skipFurtherCaching = false;

	var alias = intrinsic.alias;
	if (alias) {
		intrinsicBaseName = alias[0];
		$spliceApply(parts, $concat([0, 1], alias));
	}

	for (var i = 1, isOwn = true; i < parts.length; i += 1) {
		var part = parts[i];
		var first = $strSlice(part, 0, 1);
		var last = $strSlice(part, -1);
		if (
			(
				(first === '"' || first === "'" || first === '`')
				|| (last === '"' || last === "'" || last === '`')
			)
			&& first !== last
		) {
			throw new $SyntaxError('property names with quotes must have matching quotes');
		}
		if (part === 'constructor' || !isOwn) {
			skipFurtherCaching = true;
		}

		intrinsicBaseName += '.' + part;
		intrinsicRealName = '%' + intrinsicBaseName + '%';

		if (hasOwn(INTRINSICS, intrinsicRealName)) {
			value = INTRINSICS[intrinsicRealName];
		} else if (value != null) {
			if (!(part in value)) {
				if (!allowMissing) {
					throw new $TypeError('base intrinsic for ' + name + ' exists, but the property is not available.');
				}
				return void undefined;
			}
			if ($gOPD && (i + 1) >= parts.length) {
				var desc = $gOPD(value, part);
				isOwn = !!desc;

				// By convention, when a data property is converted to an accessor
				// property to emulate a data property that does not suffer from
				// the override mistake, that accessor's getter is marked with
				// an `originalValue` property. Here, when we detect this, we
				// uphold the illusion by pretending to see that original data
				// property, i.e., returning the value rather than the getter
				// itself.
				if (isOwn && 'get' in desc && !('originalValue' in desc.get)) {
					value = desc.get;
				} else {
					value = value[part];
				}
			} else {
				isOwn = hasOwn(value, part);
				value = value[part];
			}

			if (isOwn && !skipFurtherCaching) {
				INTRINSICS[intrinsicRealName] = value;
			}
		}
	}
	return value;
};


/***/ }),

/***/ 91311:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


var $Object = __nccwpck_require__(95399);

/** @type {import('./Object.getPrototypeOf')} */
module.exports = $Object.getPrototypeOf || null;


/***/ }),

/***/ 48681:
/***/ ((module) => {

"use strict";


/** @type {import('./Reflect.getPrototypeOf')} */
module.exports = (typeof Reflect !== 'undefined' && Reflect.getPrototypeOf) || null;


/***/ }),

/***/ 81967:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


var reflectGetProto = __nccwpck_require__(48681);
var originalGetProto = __nccwpck_require__(91311);

var getDunderProto = __nccwpck_require__(26669);

/** @type {import('.')} */
module.exports = reflectGetProto
	? function getProto(O) {
		// @ts-expect-error TS can't narrow inside a closure, for some reason
		return reflectGetProto(O);
	}
	: originalGetProto
		? function getProto(O) {
			if (!O || (typeof O !== 'object' && typeof O !== 'function')) {
				throw new TypeError('getProto: not an object');
			}
			// @ts-expect-error TS can't narrow inside a closure, for some reason
			return originalGetProto(O);
		}
		: getDunderProto
			? function getProto(O) {
				// @ts-expect-error TS can't narrow inside a closure, for some reason
				return getDunderProto(O);
			}
			: null;


/***/ }),

/***/ 1174:
/***/ ((module) => {

"use strict";


/** @type {import('./gOPD')} */
module.exports = Object.getOwnPropertyDescriptor;


/***/ }),

/***/ 33170:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


/** @type {import('.')} */
var $gOPD = __nccwpck_require__(1174);

if ($gOPD) {
	try {
		$gOPD([], 'length');
	} catch (e) {
		// IE 8 has a broken gOPD
		$gOPD = null;
	}
}

module.exports = $gOPD;


/***/ }),

/***/ 23336:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


var origSymbol = typeof Symbol !== 'undefined' && Symbol;
var hasSymbolSham = __nccwpck_require__(61114);

/** @type {import('.')} */
module.exports = function hasNativeSymbols() {
	if (typeof origSymbol !== 'function') { return false; }
	if (typeof Symbol !== 'function') { return false; }
	if (typeof origSymbol('foo') !== 'symbol') { return false; }
	if (typeof Symbol('bar') !== 'symbol') { return false; }

	return hasSymbolSham();
};


/***/ }),

/***/ 61114:
/***/ ((module) => {

"use strict";


/** @type {import('./shams')} */
/* eslint complexity: [2, 18], max-statements: [2, 33] */
module.exports = function hasSymbols() {
	if (typeof Symbol !== 'function' || typeof Object.getOwnPropertySymbols !== 'function') { return false; }
	if (typeof Symbol.iterator === 'symbol') { return true; }

	/** @type {{ [k in symbol]?: unknown }} */
	var obj = {};
	var sym = Symbol('test');
	var symObj = Object(sym);
	if (typeof sym === 'string') { return false; }

	if (Object.prototype.toString.call(sym) !== '[object Symbol]') { return false; }
	if (Object.prototype.toString.call(symObj) !== '[object Symbol]') { return false; }

	// temp disabled per https://github.com/ljharb/object.assign/issues/17
	// if (sym instanceof Symbol) { return false; }
	// temp disabled per https://github.com/WebReflection/get-own-property-symbols/issues/4
	// if (!(symObj instanceof Symbol)) { return false; }

	// if (typeof Symbol.prototype.toString !== 'function') { return false; }
	// if (String(sym) !== Symbol.prototype.toString.call(sym)) { return false; }

	var symVal = 42;
	obj[sym] = symVal;
	for (var _ in obj) { return false; } // eslint-disable-line no-restricted-syntax, no-unreachable-loop
	if (typeof Object.keys === 'function' && Object.keys(obj).length !== 0) { return false; }

	if (typeof Object.getOwnPropertyNames === 'function' && Object.getOwnPropertyNames(obj).length !== 0) { return false; }

	var syms = Object.getOwnPropertySymbols(obj);
	if (syms.length !== 1 || syms[0] !== sym) { return false; }

	if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) { return false; }

	if (typeof Object.getOwnPropertyDescriptor === 'function') {
		// eslint-disable-next-line no-extra-parens
		var descriptor = /** @type {PropertyDescriptor} */ (Object.getOwnPropertyDescriptor(obj, sym));
		if (descriptor.value !== symVal || descriptor.enumerable !== true) { return false; }
	}

	return true;
};


/***/ }),

/***/ 54076:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


var call = Function.prototype.call;
var $hasOwn = Object.prototype.hasOwnProperty;
var bind = __nccwpck_require__(37564);

/** @type {import('.')} */
module.exports = bind.call(call, $hasOwn);


/***/ }),

/***/ 78024:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";
/*!
 * http-errors
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2016 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module dependencies.
 * @private
 */

var deprecate = __nccwpck_require__(60095)('http-errors')
var setPrototypeOf = __nccwpck_require__(41015)
var statuses = __nccwpck_require__(44650)
var inherits = __nccwpck_require__(39598)
var toIdentifier = __nccwpck_require__(52794)

/**
 * Module exports.
 * @public
 */

module.exports = createError
module.exports.HttpError = createHttpErrorConstructor()
module.exports.isHttpError = createIsHttpErrorFunction(module.exports.HttpError)

// Populate exports for all constructors
populateConstructorExports(module.exports, statuses.codes, module.exports.HttpError)

/**
 * Get the code class of a status code.
 * @private
 */

function codeClass (status) {
  return Number(String(status).charAt(0) + '00')
}

/**
 * Create a new HTTP Error.
 *
 * @returns {Error}
 * @public
 */

function createError () {
  // so much arity going on ~_~
  var err
  var msg
  var status = 500
  var props = {}
  for (var i = 0; i < arguments.length; i++) {
    var arg = arguments[i]
    var type = typeof arg
    if (type === 'object' && arg instanceof Error) {
      err = arg
      status = err.status || err.statusCode || status
    } else if (type === 'number' && i === 0) {
      status = arg
    } else if (type === 'string') {
      msg = arg
    } else if (type === 'object') {
      props = arg
    } else {
      throw new TypeError('argument #' + (i + 1) + ' unsupported type ' + type)
    }
  }

  if (typeof status === 'number' && (status < 400 || status >= 600)) {
    deprecate('non-error status code; use only 4xx or 5xx status codes')
  }

  if (typeof status !== 'number' ||
    (!statuses.message[status] && (status < 400 || status >= 600))) {
    status = 500
  }

  // constructor
  var HttpError = createError[status] || createError[codeClass(status)]

  if (!err) {
    // create error
    err = HttpError
      ? new HttpError(msg)
      : new Error(msg || statuses.message[status])
    Error.captureStackTrace(err, createError)
  }

  if (!HttpError || !(err instanceof HttpError) || err.status !== status) {
    // add properties to generic error
    err.expose = status < 500
    err.status = err.statusCode = status
  }

  for (var key in props) {
    if (key !== 'status' && key !== 'statusCode') {
      err[key] = props[key]
    }
  }

  return err
}

/**
 * Create HTTP error abstract base class.
 * @private
 */

function createHttpErrorConstructor () {
  function HttpError () {
    throw new TypeError('cannot construct abstract class')
  }

  inherits(HttpError, Error)

  return HttpError
}

/**
 * Create a constructor for a client error.
 * @private
 */

function createClientErrorConstructor (HttpError, name, code) {
  var className = toClassName(name)

  function ClientError (message) {
    // create the error object
    var msg = message != null ? message : statuses.message[code]
    var err = new Error(msg)

    // capture a stack trace to the construction point
    Error.captureStackTrace(err, ClientError)

    // adjust the [[Prototype]]
    setPrototypeOf(err, ClientError.prototype)

    // redefine the error message
    Object.defineProperty(err, 'message', {
      enumerable: true,
      configurable: true,
      value: msg,
      writable: true
    })

    // redefine the error name
    Object.defineProperty(err, 'name', {
      enumerable: false,
      configurable: true,
      value: className,
      writable: true
    })

    return err
  }

  inherits(ClientError, HttpError)
  nameFunc(ClientError, className)

  ClientError.prototype.status = code
  ClientError.prototype.statusCode = code
  ClientError.prototype.expose = true

  return ClientError
}

/**
 * Create function to test is a value is a HttpError.
 * @private
 */

function createIsHttpErrorFunction (HttpError) {
  return function isHttpError (val) {
    if (!val || typeof val !== 'object') {
      return false
    }

    if (val instanceof HttpError) {
      return true
    }

    return val instanceof Error &&
      typeof val.expose === 'boolean' &&
      typeof val.statusCode === 'number' && val.status === val.statusCode
  }
}

/**
 * Create a constructor for a server error.
 * @private
 */

function createServerErrorConstructor (HttpError, name, code) {
  var className = toClassName(name)

  function ServerError (message) {
    // create the error object
    var msg = message != null ? message : statuses.message[code]
    var err = new Error(msg)

    // capture a stack trace to the construction point
    Error.captureStackTrace(err, ServerError)

    // adjust the [[Prototype]]
    setPrototypeOf(err, ServerError.prototype)

    // redefine the error message
    Object.defineProperty(err, 'message', {
      enumerable: true,
      configurable: true,
      value: msg,
      writable: true
    })

    // redefine the error name
    Object.defineProperty(err, 'name', {
      enumerable: false,
      configurable: true,
      value: className,
      writable: true
    })

    return err
  }

  inherits(ServerError, HttpError)
  nameFunc(ServerError, className)

  ServerError.prototype.status = code
  ServerError.prototype.statusCode = code
  ServerError.prototype.expose = false

  return ServerError
}

/**
 * Set the name of a function, if possible.
 * @private
 */

function nameFunc (func, name) {
  var desc = Object.getOwnPropertyDescriptor(func, 'name')

  if (desc && desc.configurable) {
    desc.value = name
    Object.defineProperty(func, 'name', desc)
  }
}

/**
 * Populate the exports object with constructors for every error class.
 * @private
 */

function populateConstructorExports (exports, codes, HttpError) {
  codes.forEach(function forEachCode (code) {
    var CodeError
    var name = toIdentifier(statuses.message[code])

    switch (codeClass(code)) {
      case 400:
        CodeError = createClientErrorConstructor(HttpError, name, code)
        break
      case 500:
        CodeError = createServerErrorConstructor(HttpError, name, code)
        break
    }

    if (CodeError) {
      // export the constructor
      exports[code] = CodeError
      exports[name] = CodeError
    }
  })
}

/**
 * Get a class name from a name identifier.
 * @private
 */

function toClassName (name) {
  return name.substr(-5) !== 'Error'
    ? name + 'Error'
    : name
}


/***/ }),

/***/ 39598:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

try {
  var util = __nccwpck_require__(39023);
  /* istanbul ignore next */
  if (typeof util.inherits !== 'function') throw '';
  module.exports = util.inherits;
} catch (e) {
  /* istanbul ignore next */
  module.exports = __nccwpck_require__(26589);
}


/***/ }),

/***/ 26589:
/***/ ((module) => {

if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
          value: ctor,
          enumerable: false,
          writable: true,
          configurable: true
        }
      })
    }
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      var TempCtor = function () {}
      TempCtor.prototype = superCtor.prototype
      ctor.prototype = new TempCtor()
      ctor.prototype.constructor = ctor
    }
  }
}


/***/ }),

/***/ 60461:
/***/ (function(module, __unused_webpack_exports, __nccwpck_require__) {

/* module decorator */ module = __nccwpck_require__.nmd(module);
(function() {
  var expandIPv6, ipaddr, ipv4Part, ipv4Regexes, ipv6Part, ipv6Regexes, matchCIDR, root, zoneIndex;

  ipaddr = {};

  root = this;

  if (( true && module !== null) && module.exports) {
    module.exports = ipaddr;
  } else {
    root['ipaddr'] = ipaddr;
  }

  matchCIDR = function(first, second, partSize, cidrBits) {
    var part, shift;
    if (first.length !== second.length) {
      throw new Error("ipaddr: cannot match CIDR for objects with different lengths");
    }
    part = 0;
    while (cidrBits > 0) {
      shift = partSize - cidrBits;
      if (shift < 0) {
        shift = 0;
      }
      if (first[part] >> shift !== second[part] >> shift) {
        return false;
      }
      cidrBits -= partSize;
      part += 1;
    }
    return true;
  };

  ipaddr.subnetMatch = function(address, rangeList, defaultName) {
    var k, len, rangeName, rangeSubnets, subnet;
    if (defaultName == null) {
      defaultName = 'unicast';
    }
    for (rangeName in rangeList) {
      rangeSubnets = rangeList[rangeName];
      if (rangeSubnets[0] && !(rangeSubnets[0] instanceof Array)) {
        rangeSubnets = [rangeSubnets];
      }
      for (k = 0, len = rangeSubnets.length; k < len; k++) {
        subnet = rangeSubnets[k];
        if (address.kind() === subnet[0].kind()) {
          if (address.match.apply(address, subnet)) {
            return rangeName;
          }
        }
      }
    }
    return defaultName;
  };

  ipaddr.IPv4 = (function() {
    function IPv4(octets) {
      var k, len, octet;
      if (octets.length !== 4) {
        throw new Error("ipaddr: ipv4 octet count should be 4");
      }
      for (k = 0, len = octets.length; k < len; k++) {
        octet = octets[k];
        if (!((0 <= octet && octet <= 255))) {
          throw new Error("ipaddr: ipv4 octet should fit in 8 bits");
        }
      }
      this.octets = octets;
    }

    IPv4.prototype.kind = function() {
      return 'ipv4';
    };

    IPv4.prototype.toString = function() {
      return this.octets.join(".");
    };

    IPv4.prototype.toNormalizedString = function() {
      return this.toString();
    };

    IPv4.prototype.toByteArray = function() {
      return this.octets.slice(0);
    };

    IPv4.prototype.match = function(other, cidrRange) {
      var ref;
      if (cidrRange === void 0) {
        ref = other, other = ref[0], cidrRange = ref[1];
      }
      if (other.kind() !== 'ipv4') {
        throw new Error("ipaddr: cannot match ipv4 address with non-ipv4 one");
      }
      return matchCIDR(this.octets, other.octets, 8, cidrRange);
    };

    IPv4.prototype.SpecialRanges = {
      unspecified: [[new IPv4([0, 0, 0, 0]), 8]],
      broadcast: [[new IPv4([255, 255, 255, 255]), 32]],
      multicast: [[new IPv4([224, 0, 0, 0]), 4]],
      linkLocal: [[new IPv4([169, 254, 0, 0]), 16]],
      loopback: [[new IPv4([127, 0, 0, 0]), 8]],
      carrierGradeNat: [[new IPv4([100, 64, 0, 0]), 10]],
      "private": [[new IPv4([10, 0, 0, 0]), 8], [new IPv4([172, 16, 0, 0]), 12], [new IPv4([192, 168, 0, 0]), 16]],
      reserved: [[new IPv4([192, 0, 0, 0]), 24], [new IPv4([192, 0, 2, 0]), 24], [new IPv4([192, 88, 99, 0]), 24], [new IPv4([198, 51, 100, 0]), 24], [new IPv4([203, 0, 113, 0]), 24], [new IPv4([240, 0, 0, 0]), 4]]
    };

    IPv4.prototype.range = function() {
      return ipaddr.subnetMatch(this, this.SpecialRanges);
    };

    IPv4.prototype.toIPv4MappedAddress = function() {
      return ipaddr.IPv6.parse("::ffff:" + (this.toString()));
    };

    IPv4.prototype.prefixLengthFromSubnetMask = function() {
      var cidr, i, k, octet, stop, zeros, zerotable;
      zerotable = {
        0: 8,
        128: 7,
        192: 6,
        224: 5,
        240: 4,
        248: 3,
        252: 2,
        254: 1,
        255: 0
      };
      cidr = 0;
      stop = false;
      for (i = k = 3; k >= 0; i = k += -1) {
        octet = this.octets[i];
        if (octet in zerotable) {
          zeros = zerotable[octet];
          if (stop && zeros !== 0) {
            return null;
          }
          if (zeros !== 8) {
            stop = true;
          }
          cidr += zeros;
        } else {
          return null;
        }
      }
      return 32 - cidr;
    };

    return IPv4;

  })();

  ipv4Part = "(0?\\d+|0x[a-f0-9]+)";

  ipv4Regexes = {
    fourOctet: new RegExp("^" + ipv4Part + "\\." + ipv4Part + "\\." + ipv4Part + "\\." + ipv4Part + "$", 'i'),
    longValue: new RegExp("^" + ipv4Part + "$", 'i')
  };

  ipaddr.IPv4.parser = function(string) {
    var match, parseIntAuto, part, shift, value;
    parseIntAuto = function(string) {
      if (string[0] === "0" && string[1] !== "x") {
        return parseInt(string, 8);
      } else {
        return parseInt(string);
      }
    };
    if (match = string.match(ipv4Regexes.fourOctet)) {
      return (function() {
        var k, len, ref, results;
        ref = match.slice(1, 6);
        results = [];
        for (k = 0, len = ref.length; k < len; k++) {
          part = ref[k];
          results.push(parseIntAuto(part));
        }
        return results;
      })();
    } else if (match = string.match(ipv4Regexes.longValue)) {
      value = parseIntAuto(match[1]);
      if (value > 0xffffffff || value < 0) {
        throw new Error("ipaddr: address outside defined range");
      }
      return ((function() {
        var k, results;
        results = [];
        for (shift = k = 0; k <= 24; shift = k += 8) {
          results.push((value >> shift) & 0xff);
        }
        return results;
      })()).reverse();
    } else {
      return null;
    }
  };

  ipaddr.IPv6 = (function() {
    function IPv6(parts, zoneId) {
      var i, k, l, len, part, ref;
      if (parts.length === 16) {
        this.parts = [];
        for (i = k = 0; k <= 14; i = k += 2) {
          this.parts.push((parts[i] << 8) | parts[i + 1]);
        }
      } else if (parts.length === 8) {
        this.parts = parts;
      } else {
        throw new Error("ipaddr: ipv6 part count should be 8 or 16");
      }
      ref = this.parts;
      for (l = 0, len = ref.length; l < len; l++) {
        part = ref[l];
        if (!((0 <= part && part <= 0xffff))) {
          throw new Error("ipaddr: ipv6 part should fit in 16 bits");
        }
      }
      if (zoneId) {
        this.zoneId = zoneId;
      }
    }

    IPv6.prototype.kind = function() {
      return 'ipv6';
    };

    IPv6.prototype.toString = function() {
      return this.toNormalizedString().replace(/((^|:)(0(:|$))+)/, '::');
    };

    IPv6.prototype.toRFC5952String = function() {
      var bestMatchIndex, bestMatchLength, match, regex, string;
      regex = /((^|:)(0(:|$)){2,})/g;
      string = this.toNormalizedString();
      bestMatchIndex = 0;
      bestMatchLength = -1;
      while ((match = regex.exec(string))) {
        if (match[0].length > bestMatchLength) {
          bestMatchIndex = match.index;
          bestMatchLength = match[0].length;
        }
      }
      if (bestMatchLength < 0) {
        return string;
      }
      return string.substring(0, bestMatchIndex) + '::' + string.substring(bestMatchIndex + bestMatchLength);
    };

    IPv6.prototype.toByteArray = function() {
      var bytes, k, len, part, ref;
      bytes = [];
      ref = this.parts;
      for (k = 0, len = ref.length; k < len; k++) {
        part = ref[k];
        bytes.push(part >> 8);
        bytes.push(part & 0xff);
      }
      return bytes;
    };

    IPv6.prototype.toNormalizedString = function() {
      var addr, part, suffix;
      addr = ((function() {
        var k, len, ref, results;
        ref = this.parts;
        results = [];
        for (k = 0, len = ref.length; k < len; k++) {
          part = ref[k];
          results.push(part.toString(16));
        }
        return results;
      }).call(this)).join(":");
      suffix = '';
      if (this.zoneId) {
        suffix = '%' + this.zoneId;
      }
      return addr + suffix;
    };

    IPv6.prototype.toFixedLengthString = function() {
      var addr, part, suffix;
      addr = ((function() {
        var k, len, ref, results;
        ref = this.parts;
        results = [];
        for (k = 0, len = ref.length; k < len; k++) {
          part = ref[k];
          results.push(part.toString(16).padStart(4, '0'));
        }
        return results;
      }).call(this)).join(":");
      suffix = '';
      if (this.zoneId) {
        suffix = '%' + this.zoneId;
      }
      return addr + suffix;
    };

    IPv6.prototype.match = function(other, cidrRange) {
      var ref;
      if (cidrRange === void 0) {
        ref = other, other = ref[0], cidrRange = ref[1];
      }
      if (other.kind() !== 'ipv6') {
        throw new Error("ipaddr: cannot match ipv6 address with non-ipv6 one");
      }
      return matchCIDR(this.parts, other.parts, 16, cidrRange);
    };

    IPv6.prototype.SpecialRanges = {
      unspecified: [new IPv6([0, 0, 0, 0, 0, 0, 0, 0]), 128],
      linkLocal: [new IPv6([0xfe80, 0, 0, 0, 0, 0, 0, 0]), 10],
      multicast: [new IPv6([0xff00, 0, 0, 0, 0, 0, 0, 0]), 8],
      loopback: [new IPv6([0, 0, 0, 0, 0, 0, 0, 1]), 128],
      uniqueLocal: [new IPv6([0xfc00, 0, 0, 0, 0, 0, 0, 0]), 7],
      ipv4Mapped: [new IPv6([0, 0, 0, 0, 0, 0xffff, 0, 0]), 96],
      rfc6145: [new IPv6([0, 0, 0, 0, 0xffff, 0, 0, 0]), 96],
      rfc6052: [new IPv6([0x64, 0xff9b, 0, 0, 0, 0, 0, 0]), 96],
      '6to4': [new IPv6([0x2002, 0, 0, 0, 0, 0, 0, 0]), 16],
      teredo: [new IPv6([0x2001, 0, 0, 0, 0, 0, 0, 0]), 32],
      reserved: [[new IPv6([0x2001, 0xdb8, 0, 0, 0, 0, 0, 0]), 32]]
    };

    IPv6.prototype.range = function() {
      return ipaddr.subnetMatch(this, this.SpecialRanges);
    };

    IPv6.prototype.isIPv4MappedAddress = function() {
      return this.range() === 'ipv4Mapped';
    };

    IPv6.prototype.toIPv4Address = function() {
      var high, low, ref;
      if (!this.isIPv4MappedAddress()) {
        throw new Error("ipaddr: trying to convert a generic ipv6 address to ipv4");
      }
      ref = this.parts.slice(-2), high = ref[0], low = ref[1];
      return new ipaddr.IPv4([high >> 8, high & 0xff, low >> 8, low & 0xff]);
    };

    IPv6.prototype.prefixLengthFromSubnetMask = function() {
      var cidr, i, k, part, stop, zeros, zerotable;
      zerotable = {
        0: 16,
        32768: 15,
        49152: 14,
        57344: 13,
        61440: 12,
        63488: 11,
        64512: 10,
        65024: 9,
        65280: 8,
        65408: 7,
        65472: 6,
        65504: 5,
        65520: 4,
        65528: 3,
        65532: 2,
        65534: 1,
        65535: 0
      };
      cidr = 0;
      stop = false;
      for (i = k = 7; k >= 0; i = k += -1) {
        part = this.parts[i];
        if (part in zerotable) {
          zeros = zerotable[part];
          if (stop && zeros !== 0) {
            return null;
          }
          if (zeros !== 16) {
            stop = true;
          }
          cidr += zeros;
        } else {
          return null;
        }
      }
      return 128 - cidr;
    };

    return IPv6;

  })();

  ipv6Part = "(?:[0-9a-f]+::?)+";

  zoneIndex = "%[0-9a-z]{1,}";

  ipv6Regexes = {
    zoneIndex: new RegExp(zoneIndex, 'i'),
    "native": new RegExp("^(::)?(" + ipv6Part + ")?([0-9a-f]+)?(::)?(" + zoneIndex + ")?$", 'i'),
    transitional: new RegExp(("^((?:" + ipv6Part + ")|(?:::)(?:" + ipv6Part + ")?)") + (ipv4Part + "\\." + ipv4Part + "\\." + ipv4Part + "\\." + ipv4Part) + ("(" + zoneIndex + ")?$"), 'i')
  };

  expandIPv6 = function(string, parts) {
    var colonCount, lastColon, part, replacement, replacementCount, zoneId;
    if (string.indexOf('::') !== string.lastIndexOf('::')) {
      return null;
    }
    zoneId = (string.match(ipv6Regexes['zoneIndex']) || [])[0];
    if (zoneId) {
      zoneId = zoneId.substring(1);
      string = string.replace(/%.+$/, '');
    }
    colonCount = 0;
    lastColon = -1;
    while ((lastColon = string.indexOf(':', lastColon + 1)) >= 0) {
      colonCount++;
    }
    if (string.substr(0, 2) === '::') {
      colonCount--;
    }
    if (string.substr(-2, 2) === '::') {
      colonCount--;
    }
    if (colonCount > parts) {
      return null;
    }
    replacementCount = parts - colonCount;
    replacement = ':';
    while (replacementCount--) {
      replacement += '0:';
    }
    string = string.replace('::', replacement);
    if (string[0] === ':') {
      string = string.slice(1);
    }
    if (string[string.length - 1] === ':') {
      string = string.slice(0, -1);
    }
    parts = (function() {
      var k, len, ref, results;
      ref = string.split(":");
      results = [];
      for (k = 0, len = ref.length; k < len; k++) {
        part = ref[k];
        results.push(parseInt(part, 16));
      }
      return results;
    })();
    return {
      parts: parts,
      zoneId: zoneId
    };
  };

  ipaddr.IPv6.parser = function(string) {
    var addr, k, len, match, octet, octets, zoneId;
    if (ipv6Regexes['native'].test(string)) {
      return expandIPv6(string, 8);
    } else if (match = string.match(ipv6Regexes['transitional'])) {
      zoneId = match[6] || '';
      addr = expandIPv6(match[1].slice(0, -1) + zoneId, 6);
      if (addr.parts) {
        octets = [parseInt(match[2]), parseInt(match[3]), parseInt(match[4]), parseInt(match[5])];
        for (k = 0, len = octets.length; k < len; k++) {
          octet = octets[k];
          if (!((0 <= octet && octet <= 255))) {
            return null;
          }
        }
        addr.parts.push(octets[0] << 8 | octets[1]);
        addr.parts.push(octets[2] << 8 | octets[3]);
        return {
          parts: addr.parts,
          zoneId: addr.zoneId
        };
      }
    }
    return null;
  };

  ipaddr.IPv4.isIPv4 = ipaddr.IPv6.isIPv6 = function(string) {
    return this.parser(string) !== null;
  };

  ipaddr.IPv4.isValid = function(string) {
    var e;
    try {
      new this(this.parser(string));
      return true;
    } catch (error1) {
      e = error1;
      return false;
    }
  };

  ipaddr.IPv4.isValidFourPartDecimal = function(string) {
    if (ipaddr.IPv4.isValid(string) && string.match(/^(0|[1-9]\d*)(\.(0|[1-9]\d*)){3}$/)) {
      return true;
    } else {
      return false;
    }
  };

  ipaddr.IPv6.isValid = function(string) {
    var addr, e;
    if (typeof string === "string" && string.indexOf(":") === -1) {
      return false;
    }
    try {
      addr = this.parser(string);
      new this(addr.parts, addr.zoneId);
      return true;
    } catch (error1) {
      e = error1;
      return false;
    }
  };

  ipaddr.IPv4.parse = function(string) {
    var parts;
    parts = this.parser(string);
    if (parts === null) {
      throw new Error("ipaddr: string is not formatted like ip address");
    }
    return new this(parts);
  };

  ipaddr.IPv6.parse = function(string) {
    var addr;
    addr = this.parser(string);
    if (addr.parts === null) {
      throw new Error("ipaddr: string is not formatted like ip address");
    }
    return new this(addr.parts, addr.zoneId);
  };

  ipaddr.IPv4.parseCIDR = function(string) {
    var maskLength, match, parsed;
    if (match = string.match(/^(.+)\/(\d+)$/)) {
      maskLength = parseInt(match[2]);
      if (maskLength >= 0 && maskLength <= 32) {
        parsed = [this.parse(match[1]), maskLength];
        Object.defineProperty(parsed, 'toString', {
          value: function() {
            return this.join('/');
          }
        });
        return parsed;
      }
    }
    throw new Error("ipaddr: string is not formatted like an IPv4 CIDR range");
  };

  ipaddr.IPv4.subnetMaskFromPrefixLength = function(prefix) {
    var filledOctetCount, j, octets;
    prefix = parseInt(prefix);
    if (prefix < 0 || prefix > 32) {
      throw new Error('ipaddr: invalid IPv4 prefix length');
    }
    octets = [0, 0, 0, 0];
    j = 0;
    filledOctetCount = Math.floor(prefix / 8);
    while (j < filledOctetCount) {
      octets[j] = 255;
      j++;
    }
    if (filledOctetCount < 4) {
      octets[filledOctetCount] = Math.pow(2, prefix % 8) - 1 << 8 - (prefix % 8);
    }
    return new this(octets);
  };

  ipaddr.IPv4.broadcastAddressFromCIDR = function(string) {
    var cidr, error, i, ipInterfaceOctets, octets, subnetMaskOctets;
    try {
      cidr = this.parseCIDR(string);
      ipInterfaceOctets = cidr[0].toByteArray();
      subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();
      octets = [];
      i = 0;
      while (i < 4) {
        octets.push(parseInt(ipInterfaceOctets[i], 10) | parseInt(subnetMaskOctets[i], 10) ^ 255);
        i++;
      }
      return new this(octets);
    } catch (error1) {
      error = error1;
      throw new Error('ipaddr: the address does not have IPv4 CIDR format');
    }
  };

  ipaddr.IPv4.networkAddressFromCIDR = function(string) {
    var cidr, error, i, ipInterfaceOctets, octets, subnetMaskOctets;
    try {
      cidr = this.parseCIDR(string);
      ipInterfaceOctets = cidr[0].toByteArray();
      subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();
      octets = [];
      i = 0;
      while (i < 4) {
        octets.push(parseInt(ipInterfaceOctets[i], 10) & parseInt(subnetMaskOctets[i], 10));
        i++;
      }
      return new this(octets);
    } catch (error1) {
      error = error1;
      throw new Error('ipaddr: the address does not have IPv4 CIDR format');
    }
  };

  ipaddr.IPv6.parseCIDR = function(string) {
    var maskLength, match, parsed;
    if (match = string.match(/^(.+)\/(\d+)$/)) {
      maskLength = parseInt(match[2]);
      if (maskLength >= 0 && maskLength <= 128) {
        parsed = [this.parse(match[1]), maskLength];
        Object.defineProperty(parsed, 'toString', {
          value: function() {
            return this.join('/');
          }
        });
        return parsed;
      }
    }
    throw new Error("ipaddr: string is not formatted like an IPv6 CIDR range");
  };

  ipaddr.isValid = function(string) {
    return ipaddr.IPv6.isValid(string) || ipaddr.IPv4.isValid(string);
  };

  ipaddr.parse = function(string) {
    if (ipaddr.IPv6.isValid(string)) {
      return ipaddr.IPv6.parse(string);
    } else if (ipaddr.IPv4.isValid(string)) {
      return ipaddr.IPv4.parse(string);
    } else {
      throw new Error("ipaddr: the address has neither IPv6 nor IPv4 format");
    }
  };

  ipaddr.parseCIDR = function(string) {
    var e;
    try {
      return ipaddr.IPv6.parseCIDR(string);
    } catch (error1) {
      e = error1;
      try {
        return ipaddr.IPv4.parseCIDR(string);
      } catch (error1) {
        e = error1;
        throw new Error("ipaddr: the address has neither IPv6 nor IPv4 CIDR format");
      }
    }
  };

  ipaddr.fromByteArray = function(bytes) {
    var length;
    length = bytes.length;
    if (length === 4) {
      return new ipaddr.IPv4(bytes);
    } else if (length === 16) {
      return new ipaddr.IPv6(bytes);
    } else {
      throw new Error("ipaddr: the binary input is neither an IPv6 nor IPv4 address");
    }
  };

  ipaddr.process = function(string) {
    var addr;
    addr = this.parse(string);
    if (addr.kind() === 'ipv6' && addr.isIPv4MappedAddress()) {
      return addr.toIPv4Address();
    } else {
      return addr;
    }
  };

}).call(this);


/***/ }),

/***/ 716:
/***/ ((module) => {

"use strict";

function isProperty(str) {
  return /^[$A-Z\_a-z\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376\u0377\u037a-\u037d\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u0527\u0531-\u0556\u0559\u0561-\u0587\u05d0-\u05ea\u05f0-\u05f2\u0620-\u064a\u066e\u066f\u0671-\u06d3\u06d5\u06e5\u06e6\u06ee\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u08a0\u08a2-\u08ac\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0977\u0979-\u097f\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc\u09dd\u09df-\u09e1\u09f0\u09f1\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0\u0ae1\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3d\u0b5c\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c33\u0c35-\u0c39\u0c3d\u0c58\u0c59\u0c60\u0c61\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cde\u0ce0\u0ce1\u0cf1\u0cf2\u0d05-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d60\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32\u0e33\u0e40-\u0e46\u0e81\u0e82\u0e84\u0e87\u0e88\u0e8a\u0e8d\u0e94-\u0e97\u0e99-\u0e9f\u0ea1-\u0ea3\u0ea5\u0ea7\u0eaa\u0eab\u0ead-\u0eb0\u0eb2\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f4\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f0\u1700-\u170c\u170e-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1877\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191c\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19c1-\u19c7\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4b\u1b83-\u1ba0\u1bae\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1ce9-\u1cec\u1cee-\u1cf1\u1cf5\u1cf6\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2119-\u211d\u2124\u2126\u2128\u212a-\u212d\u212f-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cee\u2cf2\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u2e2f\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309d-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312d\u3131-\u318e\u31a0-\u31ba\u31f0-\u31ff\u3400-\u4db5\u4e00-\u9fcc\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a\ua62b\ua640-\ua66e\ua67f-\ua697\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua78e\ua790-\ua793\ua7a0-\ua7aa\ua7f8-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa80-\uaaaf\uaab1\uaab5\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uabc0-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc][$A-Z\_a-z\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376\u0377\u037a-\u037d\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u0527\u0531-\u0556\u0559\u0561-\u0587\u05d0-\u05ea\u05f0-\u05f2\u0620-\u064a\u066e\u066f\u0671-\u06d3\u06d5\u06e5\u06e6\u06ee\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u08a0\u08a2-\u08ac\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0977\u0979-\u097f\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc\u09dd\u09df-\u09e1\u09f0\u09f1\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0\u0ae1\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3d\u0b5c\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c33\u0c35-\u0c39\u0c3d\u0c58\u0c59\u0c60\u0c61\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cde\u0ce0\u0ce1\u0cf1\u0cf2\u0d05-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d60\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32\u0e33\u0e40-\u0e46\u0e81\u0e82\u0e84\u0e87\u0e88\u0e8a\u0e8d\u0e94-\u0e97\u0e99-\u0e9f\u0ea1-\u0ea3\u0ea5\u0ea7\u0eaa\u0eab\u0ead-\u0eb0\u0eb2\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f4\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f0\u1700-\u170c\u170e-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1877\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191c\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19c1-\u19c7\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4b\u1b83-\u1ba0\u1bae\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1ce9-\u1cec\u1cee-\u1cf1\u1cf5\u1cf6\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2119-\u211d\u2124\u2126\u2128\u212a-\u212d\u212f-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cee\u2cf2\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u2e2f\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309d-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312d\u3131-\u318e\u31a0-\u31ba\u31f0-\u31ff\u3400-\u4db5\u4e00-\u9fcc\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a\ua62b\ua640-\ua66e\ua67f-\ua697\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua78e\ua790-\ua793\ua7a0-\ua7aa\ua7f8-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa80-\uaaaf\uaab1\uaab5\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uabc0-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc0-9\u0300-\u036f\u0483-\u0487\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u0669\u0670\u06d6-\u06dc\u06df-\u06e4\u06e7\u06e8\u06ea-\u06ed\u06f0-\u06f9\u0711\u0730-\u074a\u07a6-\u07b0\u07c0-\u07c9\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0859-\u085b\u08e4-\u08fe\u0900-\u0903\u093a-\u093c\u093e-\u094f\u0951-\u0957\u0962\u0963\u0966-\u096f\u0981-\u0983\u09bc\u09be-\u09c4\u09c7\u09c8\u09cb-\u09cd\u09d7\u09e2\u09e3\u09e6-\u09ef\u0a01-\u0a03\u0a3c\u0a3e-\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a66-\u0a71\u0a75\u0a81-\u0a83\u0abc\u0abe-\u0ac5\u0ac7-\u0ac9\u0acb-\u0acd\u0ae2\u0ae3\u0ae6-\u0aef\u0b01-\u0b03\u0b3c\u0b3e-\u0b44\u0b47\u0b48\u0b4b-\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b66-\u0b6f\u0b82\u0bbe-\u0bc2\u0bc6-\u0bc8\u0bca-\u0bcd\u0bd7\u0be6-\u0bef\u0c01-\u0c03\u0c3e-\u0c44\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0c66-\u0c6f\u0c82\u0c83\u0cbc\u0cbe-\u0cc4\u0cc6-\u0cc8\u0cca-\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0ce6-\u0cef\u0d02\u0d03\u0d3e-\u0d44\u0d46-\u0d48\u0d4a-\u0d4d\u0d57\u0d62\u0d63\u0d66-\u0d6f\u0d82\u0d83\u0dca\u0dcf-\u0dd4\u0dd6\u0dd8-\u0ddf\u0df2\u0df3\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0e50-\u0e59\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0ed0-\u0ed9\u0f18\u0f19\u0f20-\u0f29\u0f35\u0f37\u0f39\u0f3e\u0f3f\u0f71-\u0f84\u0f86\u0f87\u0f8d-\u0f97\u0f99-\u0fbc\u0fc6\u102b-\u103e\u1040-\u1049\u1056-\u1059\u105e-\u1060\u1062-\u1064\u1067-\u106d\u1071-\u1074\u1082-\u108d\u108f-\u109d\u135d-\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b4-\u17d3\u17dd\u17e0-\u17e9\u180b-\u180d\u1810-\u1819\u18a9\u1920-\u192b\u1930-\u193b\u1946-\u194f\u19b0-\u19c0\u19c8\u19c9\u19d0-\u19d9\u1a17-\u1a1b\u1a55-\u1a5e\u1a60-\u1a7c\u1a7f-\u1a89\u1a90-\u1a99\u1b00-\u1b04\u1b34-\u1b44\u1b50-\u1b59\u1b6b-\u1b73\u1b80-\u1b82\u1ba1-\u1bad\u1bb0-\u1bb9\u1be6-\u1bf3\u1c24-\u1c37\u1c40-\u1c49\u1c50-\u1c59\u1cd0-\u1cd2\u1cd4-\u1ce8\u1ced\u1cf2-\u1cf4\u1dc0-\u1de6\u1dfc-\u1dff\u200c\u200d\u203f\u2040\u2054\u20d0-\u20dc\u20e1\u20e5-\u20f0\u2cef-\u2cf1\u2d7f\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua620-\ua629\ua66f\ua674-\ua67d\ua69f\ua6f0\ua6f1\ua802\ua806\ua80b\ua823-\ua827\ua880\ua881\ua8b4-\ua8c4\ua8d0-\ua8d9\ua8e0-\ua8f1\ua900-\ua909\ua926-\ua92d\ua947-\ua953\ua980-\ua983\ua9b3-\ua9c0\ua9d0-\ua9d9\uaa29-\uaa36\uaa43\uaa4c\uaa4d\uaa50-\uaa59\uaa7b\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uaaeb-\uaaef\uaaf5\uaaf6\uabe3-\uabea\uabec\uabed\uabf0-\uabf9\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\ufe33\ufe34\ufe4d-\ufe4f\uff10-\uff19\uff3f]*$/.test(str)
}
module.exports = isProperty

/***/ }),

/***/ 96543:
/***/ ((module) => {

"use strict";


const isStream = stream =>
	stream !== null &&
	typeof stream === 'object' &&
	typeof stream.pipe === 'function';

isStream.writable = stream =>
	isStream(stream) &&
	stream.writable !== false &&
	typeof stream._write === 'function' &&
	typeof stream._writableState === 'object';

isStream.readable = stream =>
	isStream(stream) &&
	stream.readable !== false &&
	typeof stream._read === 'function' &&
	typeof stream._readableState === 'object';

isStream.duplex = stream =>
	isStream.writable(stream) &&
	isStream.readable(stream);

isStream.transform = stream =>
	isStream.duplex(stream) &&
	typeof stream._transform === 'function';

module.exports = isStream;


/***/ }),

/***/ 82513:
/***/ ((module) => {

var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};


/***/ }),

/***/ 53080:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


const { clone } = __nccwpck_require__(91884);

const Common = __nccwpck_require__(84205);


const internals = {
    annotations: Symbol('annotations')
};


exports.error = function (stripColorCodes) {

    if (!this._original ||
        typeof this._original !== 'object') {

        return this.details[0].message;
    }

    const redFgEscape = stripColorCodes ? '' : '\u001b[31m';
    const redBgEscape = stripColorCodes ? '' : '\u001b[41m';
    const endColor = stripColorCodes ? '' : '\u001b[0m';

    const obj = clone(this._original);

    for (let i = this.details.length - 1; i >= 0; --i) {        // Reverse order to process deepest child first
        const pos = i + 1;
        const error = this.details[i];
        const path = error.path;
        let node = obj;
        for (let j = 0; ; ++j) {
            const seg = path[j];

            if (Common.isSchema(node)) {
                node = node.clone();                              // joi schemas are not cloned by hoek, we have to take this extra step
            }

            if (j + 1 < path.length &&
                typeof node[seg] !== 'string') {

                node = node[seg];
            }
            else {
                const refAnnotations = node[internals.annotations] || { errors: {}, missing: {} };
                node[internals.annotations] = refAnnotations;

                const cacheKey = seg || error.context.key;

                if (node[seg] !== undefined) {
                    refAnnotations.errors[cacheKey] = refAnnotations.errors[cacheKey] || [];
                    refAnnotations.errors[cacheKey].push(pos);
                }
                else {
                    refAnnotations.missing[cacheKey] = pos;
                }

                break;
            }
        }
    }

    const replacers = {
        key: /_\$key\$_([, \d]+)_\$end\$_"/g,
        missing: /"_\$miss\$_([^|]+)\|(\d+)_\$end\$_": "__missing__"/g,
        arrayIndex: /\s*"_\$idx\$_([, \d]+)_\$end\$_",?\n(.*)/g,
        specials: /"\[(NaN|Symbol.*|-?Infinity|function.*|\(.*)]"/g
    };

    let message = internals.safeStringify(obj, 2)
        .replace(replacers.key, ($0, $1) => `" ${redFgEscape}[${$1}]${endColor}`)
        .replace(replacers.missing, ($0, $1, $2) => `${redBgEscape}"${$1}"${endColor}${redFgEscape} [${$2}]: -- missing --${endColor}`)
        .replace(replacers.arrayIndex, ($0, $1, $2) => `\n${$2} ${redFgEscape}[${$1}]${endColor}`)
        .replace(replacers.specials, ($0, $1) => $1);

    message = `${message}\n${redFgEscape}`;

    for (let i = 0; i < this.details.length; ++i) {
        const pos = i + 1;
        message = `${message}\n[${pos}] ${this.details[i].message}`;
    }

    message = message + endColor;

    return message;
};


// Inspired by json-stringify-safe

internals.safeStringify = function (obj, spaces) {

    return JSON.stringify(obj, internals.serializer(), spaces);
};


internals.serializer = function () {

    const keys = [];
    const stack = [];

    const cycleReplacer = (key, value) => {

        if (stack[0] === value) {
            return '[Circular ~]';
        }

        return '[Circular ~.' + keys.slice(0, stack.indexOf(value)).join('.') + ']';
    };

    return function (key, value) {

        if (stack.length > 0) {
            const thisPos = stack.indexOf(this);
            if (~thisPos) {
                stack.length = thisPos + 1;
                keys.length = thisPos + 1;
                keys[thisPos] = key;
            }
            else {
                stack.push(this);
                keys.push(key);
            }

            if (~stack.indexOf(value)) {
                value = cycleReplacer.call(this, key, value);
            }
        }
        else {
            stack.push(value);
        }

        if (value) {
            const annotations = value[internals.annotations];
            if (annotations) {
                if (Array.isArray(value)) {
                    const annotated = [];

                    for (let i = 0; i < value.length; ++i) {
                        if (annotations.errors[i]) {
                            annotated.push(`_$idx$_${annotations.errors[i].sort().join(', ')}_$end$_`);
                        }

                        annotated.push(value[i]);
                    }

                    value = annotated;
                }
                else {
                    for (const errorKey in annotations.errors) {
                        value[`${errorKey}_$key$_${annotations.errors[errorKey].sort().join(', ')}_$end$_`] = value[errorKey];
                        value[errorKey] = undefined;
                    }

                    for (const missingKey in annotations.missing) {
                        value[`_$miss$_${missingKey}|${annotations.missing[missingKey]}_$end$_`] = '__missing__';
                    }
                }

                return value;
            }
        }

        if (value === Infinity ||
            value === -Infinity ||
            Number.isNaN(value) ||
            typeof value === 'function' ||
            typeof value === 'symbol') {

            return '[' + value.toString() + ']';
        }

        return value;
    };
};


/***/ }),

/***/ 87041:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


const { assert, clone, deepEqual, merge } = __nccwpck_require__(91884);

const Cache = __nccwpck_require__(12644);
const Common = __nccwpck_require__(84205);
const Compile = __nccwpck_require__(14743);
const Errors = __nccwpck_require__(11543);
const Extend = __nccwpck_require__(74376);
const Manifest = __nccwpck_require__(25705);
const Messages = __nccwpck_require__(31088);
const Modify = __nccwpck_require__(89730);
const Ref = __nccwpck_require__(51579);
const Trace = __nccwpck_require__(23327);
const Validator = __nccwpck_require__(64852);
const Values = __nccwpck_require__(31906);


const internals = {};


internals.Base = class {

    constructor(type) {

        // Naming: public, _private, $_extension, $_mutate{action}

        this.type = type;

        this.$_root = null;
        this._definition = {};
        this._reset();
    }

    _reset() {

        this._ids = new Modify.Ids();
        this._preferences = null;
        this._refs = new Ref.Manager();
        this._cache = null;

        this._valids = null;
        this._invalids = null;

        this._flags = {};
        this._rules = [];
        this._singleRules = new Map();              // The rule options passed for non-multi rules

        this.$_terms = {};                          // Hash of arrays of immutable objects (extended by other types)

        this.$_temp = {                             // Runtime state (not cloned)
            ruleset: null,                          // null: use last, false: error, number: start position
            whens: {}                               // Runtime cache of generated whens
        };
    }

    // Manifest

    describe() {

        assert(typeof Manifest.describe === 'function', 'Manifest functionality disabled');
        return Manifest.describe(this);
    }

    // Rules

    allow(...values) {

        Common.verifyFlat(values, 'allow');
        return this._values(values, '_valids');
    }

    alter(targets) {

        assert(targets && typeof targets === 'object' && !Array.isArray(targets), 'Invalid targets argument');
        assert(!this._inRuleset(), 'Cannot set alterations inside a ruleset');

        const obj = this.clone();
        obj.$_terms.alterations = obj.$_terms.alterations || [];
        for (const target in targets) {
            const adjuster = targets[target];
            assert(typeof adjuster === 'function', 'Alteration adjuster for', target, 'must be a function');
            obj.$_terms.alterations.push({ target, adjuster });
        }

        obj.$_temp.ruleset = false;
        return obj;
    }

    artifact(id) {

        assert(id !== undefined, 'Artifact cannot be undefined');
        assert(!this._cache, 'Cannot set an artifact with a rule cache');

        return this.$_setFlag('artifact', id);
    }

    cast(to) {

        assert(to === false || typeof to === 'string', 'Invalid to value');
        assert(to === false || this._definition.cast[to], 'Type', this.type, 'does not support casting to', to);

        return this.$_setFlag('cast', to === false ? undefined : to);
    }

    default(value, options) {

        return this._default('default', value, options);
    }

    description(desc) {

        assert(desc && typeof desc === 'string', 'Description must be a non-empty string');

        return this.$_setFlag('description', desc);
    }

    empty(schema) {

        const obj = this.clone();

        if (schema !== undefined) {
            schema = obj.$_compile(schema, { override: false });
        }

        return obj.$_setFlag('empty', schema, { clone: false });
    }

    error(err) {

        assert(err, 'Missing error');
        assert(err instanceof Error || typeof err === 'function', 'Must provide a valid Error object or a function');

        return this.$_setFlag('error', err);
    }

    example(example, options = {}) {

        assert(example !== undefined, 'Missing example');
        Common.assertOptions(options, ['override']);

        return this._inner('examples', example, { single: true, override: options.override });
    }

    external(method, description) {

        if (typeof method === 'object') {
            assert(!description, 'Cannot combine options with description');
            description = method.description;
            method = method.method;
        }

        assert(typeof method === 'function', 'Method must be a function');
        assert(description === undefined || description && typeof description === 'string', 'Description must be a non-empty string');

        return this._inner('externals', { method, description }, { single: true });
    }

    failover(value, options) {

        return this._default('failover', value, options);
    }

    forbidden() {

        return this.presence('forbidden');
    }

    id(id) {

        if (!id) {
            return this.$_setFlag('id', undefined);
        }

        assert(typeof id === 'string', 'id must be a non-empty string');
        assert(/^[^\.]+$/.test(id), 'id cannot contain period character');

        return this.$_setFlag('id', id);
    }

    invalid(...values) {

        return this._values(values, '_invalids');
    }

    label(name) {

        assert(name && typeof name === 'string', 'Label name must be a non-empty string');

        return this.$_setFlag('label', name);
    }

    meta(meta) {

        assert(meta !== undefined, 'Meta cannot be undefined');

        return this._inner('metas', meta, { single: true });
    }

    note(...notes) {

        assert(notes.length, 'Missing notes');
        for (const note of notes) {
            assert(note && typeof note === 'string', 'Notes must be non-empty strings');
        }

        return this._inner('notes', notes);
    }

    only(mode = true) {

        assert(typeof mode === 'boolean', 'Invalid mode:', mode);

        return this.$_setFlag('only', mode);
    }

    optional() {

        return this.presence('optional');
    }

    prefs(prefs) {

        assert(prefs, 'Missing preferences');
        assert(prefs.context === undefined, 'Cannot override context');
        assert(prefs.externals === undefined, 'Cannot override externals');
        assert(prefs.warnings === undefined, 'Cannot override warnings');
        assert(prefs.debug === undefined, 'Cannot override debug');

        Common.checkPreferences(prefs);

        const obj = this.clone();
        obj._preferences = Common.preferences(obj._preferences, prefs);
        return obj;
    }

    presence(mode) {

        assert(['optional', 'required', 'forbidden'].includes(mode), 'Unknown presence mode', mode);

        return this.$_setFlag('presence', mode);
    }

    raw(enabled = true) {

        return this.$_setFlag('result', enabled ? 'raw' : undefined);
    }

    result(mode) {

        assert(['raw', 'strip'].includes(mode), 'Unknown result mode', mode);

        return this.$_setFlag('result', mode);
    }

    required() {

        return this.presence('required');
    }

    strict(enabled) {

        const obj = this.clone();

        const convert = enabled === undefined ? false : !enabled;
        obj._preferences = Common.preferences(obj._preferences, { convert });
        return obj;
    }

    strip(enabled = true) {

        return this.$_setFlag('result', enabled ? 'strip' : undefined);
    }

    tag(...tags) {

        assert(tags.length, 'Missing tags');
        for (const tag of tags) {
            assert(tag && typeof tag === 'string', 'Tags must be non-empty strings');
        }

        return this._inner('tags', tags);
    }

    unit(name) {

        assert(name && typeof name === 'string', 'Unit name must be a non-empty string');

        return this.$_setFlag('unit', name);
    }

    valid(...values) {

        Common.verifyFlat(values, 'valid');

        const obj = this.allow(...values);
        obj.$_setFlag('only', !!obj._valids, { clone: false });
        return obj;
    }

    when(condition, options) {

        const obj = this.clone();

        if (!obj.$_terms.whens) {
            obj.$_terms.whens = [];
        }

        const when = Compile.when(obj, condition, options);
        if (!['any', 'link'].includes(obj.type)) {
            const conditions = when.is ? [when] : when.switch;
            for (const item of conditions) {
                assert(!item.then || item.then.type === 'any' || item.then.type === obj.type, 'Cannot combine', obj.type, 'with', item.then && item.then.type);
                assert(!item.otherwise || item.otherwise.type === 'any' || item.otherwise.type === obj.type, 'Cannot combine', obj.type, 'with', item.otherwise && item.otherwise.type);

            }
        }

        obj.$_terms.whens.push(when);
        return obj.$_mutateRebuild();
    }

    // Helpers

    cache(cache) {

        assert(!this._inRuleset(), 'Cannot set caching inside a ruleset');
        assert(!this._cache, 'Cannot override schema cache');
        assert(this._flags.artifact === undefined, 'Cannot cache a rule with an artifact');

        const obj = this.clone();
        obj._cache = cache || Cache.provider.provision();
        obj.$_temp.ruleset = false;
        return obj;
    }

    clone() {

        const obj = Object.create(Object.getPrototypeOf(this));
        return this._assign(obj);
    }

    concat(source) {

        assert(Common.isSchema(source), 'Invalid schema object');
        assert(this.type === 'any' || source.type === 'any' || source.type === this.type, 'Cannot merge type', this.type, 'with another type:', source.type);
        assert(!this._inRuleset(), 'Cannot concatenate onto a schema with open ruleset');
        assert(!source._inRuleset(), 'Cannot concatenate a schema with open ruleset');

        let obj = this.clone();

        if (this.type === 'any' &&
            source.type !== 'any') {

            // Change obj to match source type

            const tmpObj = source.clone();
            for (const key of Object.keys(obj)) {
                if (key !== 'type') {
                    tmpObj[key] = obj[key];
                }
            }

            obj = tmpObj;
        }

        obj._ids.concat(source._ids);
        obj._refs.register(source, Ref.toSibling);

        obj._preferences = obj._preferences ? Common.preferences(obj._preferences, source._preferences) : source._preferences;
        obj._valids = Values.merge(obj._valids, source._valids, source._invalids);
        obj._invalids = Values.merge(obj._invalids, source._invalids, source._valids);

        // Remove unique rules present in source

        for (const name of source._singleRules.keys()) {
            if (obj._singleRules.has(name)) {
                obj._rules = obj._rules.filter((target) => target.keep || target.name !== name);
                obj._singleRules.delete(name);
            }
        }

        // Rules

        for (const test of source._rules) {
            if (!source._definition.rules[test.method].multi) {
                obj._singleRules.set(test.name, test);
            }

            obj._rules.push(test);
        }

        // Flags

        if (obj._flags.empty &&
            source._flags.empty) {

            obj._flags.empty = obj._flags.empty.concat(source._flags.empty);
            const flags = Object.assign({}, source._flags);
            delete flags.empty;
            merge(obj._flags, flags);
        }
        else if (source._flags.empty) {
            obj._flags.empty = source._flags.empty;
            const flags = Object.assign({}, source._flags);
            delete flags.empty;
            merge(obj._flags, flags);
        }
        else {
            merge(obj._flags, source._flags);
        }

        // Terms

        for (const key in source.$_terms) {
            const terms = source.$_terms[key];
            if (!terms) {
                if (!obj.$_terms[key]) {
                    obj.$_terms[key] = terms;
                }

                continue;
            }

            if (!obj.$_terms[key]) {
                obj.$_terms[key] = terms.slice();
                continue;
            }

            obj.$_terms[key] = obj.$_terms[key].concat(terms);
        }

        // Tracing

        if (this.$_root._tracer) {
            this.$_root._tracer._combine(obj, [this, source]);
        }

        // Rebuild

        return obj.$_mutateRebuild();
    }

    extend(options) {

        assert(!options.base, 'Cannot extend type with another base');

        return Extend.type(this, options);
    }

    extract(path) {

        path = Array.isArray(path) ? path : path.split('.');
        return this._ids.reach(path);
    }

    fork(paths, adjuster) {

        assert(!this._inRuleset(), 'Cannot fork inside a ruleset');

        let obj = this;                                             // eslint-disable-line consistent-this
        for (let path of [].concat(paths)) {
            path = Array.isArray(path) ? path : path.split('.');
            obj = obj._ids.fork(path, adjuster, obj);
        }

        obj.$_temp.ruleset = false;
        return obj;
    }

    isAsync() {

        if (Boolean(this.$_terms.externals?.length)) {
            return true;
        }

        if (this.$_terms.whens) {
            for (const when of this.$_terms.whens) {
                if (when.then?.isAsync()) {
                    return true;
                }

                if (when.otherwise?.isAsync()) {
                    return true;
                }

                if (when.switch) {
                    for (const item of when.switch) {
                        if (item.then?.isAsync()) {
                            return true;
                        }

                        if (item.otherwise?.isAsync()) {
                            return true;
                        }
                    }
                }
            }
        }

        return false;
    }

    rule(options) {

        const def = this._definition;
        Common.assertOptions(options, Object.keys(def.modifiers));

        assert(this.$_temp.ruleset !== false, 'Cannot apply rules to empty ruleset or the last rule added does not support rule properties');
        const start = this.$_temp.ruleset === null ? this._rules.length - 1 : this.$_temp.ruleset;
        assert(start >= 0 && start < this._rules.length, 'Cannot apply rules to empty ruleset');

        const obj = this.clone();

        for (let i = start; i < obj._rules.length; ++i) {
            const original = obj._rules[i];
            const rule = clone(original);

            for (const name in options) {
                def.modifiers[name](rule, options[name]);
                assert(rule.name === original.name, 'Cannot change rule name');
            }

            obj._rules[i] = rule;

            if (obj._singleRules.get(rule.name) === original) {
                obj._singleRules.set(rule.name, rule);
            }
        }

        obj.$_temp.ruleset = false;
        return obj.$_mutateRebuild();
    }

    get ruleset() {

        assert(!this._inRuleset(), 'Cannot start a new ruleset without closing the previous one');

        const obj = this.clone();
        obj.$_temp.ruleset = obj._rules.length;
        return obj;
    }

    get $() {

        return this.ruleset;
    }

    tailor(targets) {

        targets = [].concat(targets);

        assert(!this._inRuleset(), 'Cannot tailor inside a ruleset');

        let obj = this;                                                     // eslint-disable-line consistent-this

        if (this.$_terms.alterations) {
            for (const { target, adjuster } of this.$_terms.alterations) {
                if (targets.includes(target)) {
                    obj = adjuster(obj);
                    assert(Common.isSchema(obj), 'Alteration adjuster for', target, 'failed to return a schema object');
                }
            }
        }

        obj = obj.$_modify({ each: (item) => item.tailor(targets), ref: false });
        obj.$_temp.ruleset = false;
        return obj.$_mutateRebuild();
    }

    tracer() {

        return Trace.location ? Trace.location(this) : this;                // $lab:coverage:ignore$
    }

    validate(value, options) {

        return Validator.entry(value, this, options);
    }

    validateAsync(value, options) {

        return Validator.entryAsync(value, this, options);
    }

    // Extensions

    $_addRule(options) {

        // Normalize rule

        if (typeof options === 'string') {
            options = { name: options };
        }

        assert(options && typeof options === 'object', 'Invalid options');
        assert(options.name && typeof options.name === 'string', 'Invalid rule name');

        for (const key in options) {
            assert(key[0] !== '_', 'Cannot set private rule properties');
        }

        const rule = Object.assign({}, options);        // Shallow cloned
        rule._resolve = [];
        rule.method = rule.method || rule.name;

        const definition = this._definition.rules[rule.method];
        const args = rule.args;

        assert(definition, 'Unknown rule', rule.method);

        // Args

        const obj = this.clone();

        if (args) {
            assert(Object.keys(args).length === 1 || Object.keys(args).length === this._definition.rules[rule.name].args.length, 'Invalid rule definition for', this.type, rule.name);

            for (const key in args) {
                let arg = args[key];

                if (definition.argsByName) {
                    const resolver = definition.argsByName.get(key);

                    if (resolver.ref &&
                        Common.isResolvable(arg)) {

                        rule._resolve.push(key);
                        obj.$_mutateRegister(arg);
                    }
                    else {
                        if (resolver.normalize) {
                            arg = resolver.normalize(arg);
                            args[key] = arg;
                        }

                        if (resolver.assert) {
                            const error = Common.validateArg(arg, key, resolver);
                            assert(!error, error, 'or reference');
                        }
                    }
                }

                if (arg === undefined) {
                    delete args[key];
                    continue;
                }

                args[key] = arg;
            }
        }

        // Unique rules

        if (!definition.multi) {
            obj._ruleRemove(rule.name, { clone: false });
            obj._singleRules.set(rule.name, rule);
        }

        if (obj.$_temp.ruleset === false) {
            obj.$_temp.ruleset = null;
        }

        if (definition.priority) {
            obj._rules.unshift(rule);
        }
        else {
            obj._rules.push(rule);
        }

        return obj;
    }

    $_compile(schema, options) {

        return Compile.schema(this.$_root, schema, options);
    }

    $_createError(code, value, local, state, prefs, options = {}) {

        const flags = options.flags !== false ? this._flags : {};
        const messages = options.messages ? Messages.merge(this._definition.messages, options.messages) : this._definition.messages;
        return new Errors.Report(code, value, local, flags, messages, state, prefs);
    }

    $_getFlag(name) {

        return this._flags[name];
    }

    $_getRule(name) {

        return this._singleRules.get(name);
    }

    $_mapLabels(path) {

        path = Array.isArray(path) ? path : path.split('.');
        return this._ids.labels(path);
    }

    $_match(value, state, prefs, overrides) {

        prefs = Object.assign({}, prefs);       // Shallow cloned
        prefs.abortEarly = true;
        prefs._externals = false;

        state.snapshot();
        const result = !Validator.validate(value, this, state, prefs, overrides).errors;
        state.restore();

        return result;
    }

    $_modify(options) {

        Common.assertOptions(options, ['each', 'once', 'ref', 'schema']);
        return Modify.schema(this, options) || this;
    }

    $_mutateRebuild() {

        assert(!this._inRuleset(), 'Cannot add this rule inside a ruleset');

        this._refs.reset();
        this._ids.reset();

        const each = (item, { source, name, path, key }) => {

            const family = this._definition[source][name] && this._definition[source][name].register;
            if (family !== false) {
                this.$_mutateRegister(item, { family, key });
            }
        };

        this.$_modify({ each });

        if (this._definition.rebuild) {
            this._definition.rebuild(this);
        }

        this.$_temp.ruleset = false;
        return this;
    }

    $_mutateRegister(schema, { family, key } = {}) {

        this._refs.register(schema, family);
        this._ids.register(schema, { key });
    }

    $_property(name) {

        return this._definition.properties[name];
    }

    $_reach(path) {

        return this._ids.reach(path);
    }

    $_rootReferences() {

        return this._refs.roots();
    }

    $_setFlag(name, value, options = {}) {

        assert(name[0] === '_' || !this._inRuleset(), 'Cannot set flag inside a ruleset');

        const flag = this._definition.flags[name] || {};
        if (deepEqual(value, flag.default)) {
            value = undefined;
        }

        if (deepEqual(value, this._flags[name])) {
            return this;
        }

        const obj = options.clone !== false ? this.clone() : this;

        if (value !== undefined) {
            obj._flags[name] = value;
            obj.$_mutateRegister(value);
        }
        else {
            delete obj._flags[name];
        }

        if (name[0] !== '_') {
            obj.$_temp.ruleset = false;
        }

        return obj;
    }

    $_parent(method, ...args) {

        return this[method][Common.symbols.parent].call(this, ...args);
    }

    $_validate(value, state, prefs) {

        return Validator.validate(value, this, state, prefs);
    }

    // Internals

    _assign(target) {

        target.type = this.type;

        target.$_root = this.$_root;

        target.$_temp = Object.assign({}, this.$_temp);
        target.$_temp.whens = {};

        target._ids = this._ids.clone();
        target._preferences = this._preferences;
        target._valids = this._valids && this._valids.clone();
        target._invalids = this._invalids && this._invalids.clone();
        target._rules = this._rules.slice();
        target._singleRules = clone(this._singleRules, { shallow: true });
        target._refs = this._refs.clone();
        target._flags = Object.assign({}, this._flags);
        target._cache = null;

        target.$_terms = {};
        for (const key in this.$_terms) {
            target.$_terms[key] = this.$_terms[key] ? this.$_terms[key].slice() : null;
        }

        // Backwards compatibility

        target.$_super = {};
        for (const override in this.$_super) {
            target.$_super[override] = this._super[override].bind(target);
        }

        return target;
    }

    _bare() {

        const obj = this.clone();
        obj._reset();

        const terms = obj._definition.terms;
        for (const name in terms) {
            const term = terms[name];
            obj.$_terms[name] = term.init;
        }

        return obj.$_mutateRebuild();
    }

    _default(flag, value, options = {}) {

        Common.assertOptions(options, 'literal');

        assert(value !== undefined, 'Missing', flag, 'value');
        assert(typeof value === 'function' || !options.literal, 'Only function value supports literal option');

        if (typeof value === 'function' &&
            options.literal) {

            value = {
                [Common.symbols.literal]: true,
                literal: value
            };
        }

        const obj = this.$_setFlag(flag, value);
        return obj;
    }

    _generate(value, state, prefs) {

        if (!this.$_terms.whens) {
            return { schema: this };
        }

        // Collect matching whens

        const whens = [];
        const ids = [];
        for (let i = 0; i < this.$_terms.whens.length; ++i) {
            const when = this.$_terms.whens[i];

            if (when.concat) {
                whens.push(when.concat);
                ids.push(`${i}.concat`);
                continue;
            }

            const input = when.ref ? when.ref.resolve(value, state, prefs) : value;
            const tests = when.is ? [when] : when.switch;
            const before = ids.length;

            for (let j = 0; j < tests.length; ++j) {
                const { is, then, otherwise } = tests[j];

                const baseId = `${i}${when.switch ? '.' + j : ''}`;
                if (is.$_match(input, state.nest(is, `${baseId}.is`), prefs)) {
                    if (then) {
                        const localState = state.localize([...state.path, `${baseId}.then`], state.ancestors, state.schemas);
                        const { schema: generated, id } = then._generate(value, localState, prefs);
                        whens.push(generated);
                        ids.push(`${baseId}.then${id ? `(${id})` : ''}`);
                        break;
                    }
                }
                else if (otherwise) {
                    const localState = state.localize([...state.path, `${baseId}.otherwise`], state.ancestors, state.schemas);
                    const { schema: generated, id } = otherwise._generate(value, localState, prefs);
                    whens.push(generated);
                    ids.push(`${baseId}.otherwise${id ? `(${id})` : ''}`);
                    break;
                }
            }

            if (when.break &&
                ids.length > before) {          // Something matched

                break;
            }
        }

        // Check cache

        const id = ids.join(', ');
        state.mainstay.tracer.debug(state, 'rule', 'when', id);

        if (!id) {
            return { schema: this };
        }

        if (!state.mainstay.tracer.active &&
            this.$_temp.whens[id]) {

            return { schema: this.$_temp.whens[id], id };
        }

        // Generate dynamic schema

        let obj = this;                                             // eslint-disable-line consistent-this
        if (this._definition.generate) {
            obj = this._definition.generate(this, value, state, prefs);
        }

        // Apply whens

        for (const when of whens) {
            obj = obj.concat(when);
        }

        // Tracing

        if (this.$_root._tracer) {
            this.$_root._tracer._combine(obj, [this, ...whens]);
        }

        // Cache result

        this.$_temp.whens[id] = obj;
        return { schema: obj, id };
    }

    _inner(type, values, options = {}) {

        assert(!this._inRuleset(), `Cannot set ${type} inside a ruleset`);

        const obj = this.clone();
        if (!obj.$_terms[type] ||
            options.override) {

            obj.$_terms[type] = [];
        }

        if (options.single) {
            obj.$_terms[type].push(values);
        }
        else {
            obj.$_terms[type].push(...values);
        }

        obj.$_temp.ruleset = false;
        return obj;
    }

    _inRuleset() {

        return this.$_temp.ruleset !== null && this.$_temp.ruleset !== false;
    }

    _ruleRemove(name, options = {}) {

        if (!this._singleRules.has(name)) {
            return this;
        }

        const obj = options.clone !== false ? this.clone() : this;

        obj._singleRules.delete(name);

        const filtered = [];
        for (let i = 0; i < obj._rules.length; ++i) {
            const test = obj._rules[i];
            if (test.name === name &&
                !test.keep) {

                if (obj._inRuleset() &&
                    i < obj.$_temp.ruleset) {

                    --obj.$_temp.ruleset;
                }

                continue;
            }

            filtered.push(test);
        }

        obj._rules = filtered;
        return obj;
    }

    _values(values, key) {

        Common.verifyFlat(values, key.slice(1, -1));

        const obj = this.clone();

        const override = values[0] === Common.symbols.override;
        if (override) {
            values = values.slice(1);
        }

        if (!obj[key] &&
            values.length) {

            obj[key] = new Values();
        }
        else if (override) {
            obj[key] = values.length ? new Values() : null;
            obj.$_mutateRebuild();
        }

        if (!obj[key]) {
            return obj;
        }

        if (override) {
            obj[key].override();
        }

        for (const value of values) {
            assert(value !== undefined, 'Cannot call allow/valid/invalid with undefined');
            assert(value !== Common.symbols.override, 'Override must be the first value');

            const other = key === '_invalids' ? '_valids' : '_invalids';
            if (obj[other]) {
                obj[other].remove(value);
                if (!obj[other].length) {
                    assert(key === '_valids' || !obj._flags.only, 'Setting invalid value', value, 'leaves schema rejecting all values due to previous valid rule');
                    obj[other] = null;
                }
            }

            obj[key].add(value, obj._refs);
        }

        return obj;
    }

    // Standard Schema

    get '~standard'() {

        const mapToStandardError = (error) => {

            let issues;
            if (Errors.ValidationError.isError(error)) {
                issues = error.details.map(({ message, path }) => ({
                    message,
                    path
                }));
            }
            else {
                issues = [{
                    message: error.message
                }];
            }

            return {
                issues
            };
        };

        const mapToStandardValue = (value) => ({ value });

        return {
            version: 1,
            vendor: 'joi',
            validate: (value) => {

                const result = Validator.standard(value, this);

                if (result instanceof Promise) {
                    return result
                        .then(mapToStandardValue, mapToStandardError);
                }

                if (!result.error) {
                    return mapToStandardValue(result.value);
                }

                return mapToStandardError(result.error);
            }
        };
    }
};


internals.Base.prototype[Common.symbols.any] = {
    version: Common.version,
    compile: Compile.compile,
    root: '$_root'
};


internals.Base.prototype.isImmutable = true;                // Prevents Hoek from deep cloning schema objects (must be on prototype)


// Aliases

internals.Base.prototype.deny = internals.Base.prototype.invalid;
internals.Base.prototype.disallow = internals.Base.prototype.invalid;
internals.Base.prototype.equal = internals.Base.prototype.valid;
internals.Base.prototype.exist = internals.Base.prototype.required;
internals.Base.prototype.not = internals.Base.prototype.invalid;
internals.Base.prototype.options = internals.Base.prototype.prefs;
internals.Base.prototype.preferences = internals.Base.prototype.prefs;


module.exports = new internals.Base();


/***/ }),

/***/ 12644:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


const { assert, clone } = __nccwpck_require__(91884);

const Common = __nccwpck_require__(84205);


const internals = {
    max: 1000,
    supported: new Set(['undefined', 'boolean', 'number', 'string'])
};


exports.provider = {

    provision(options) {

        return new internals.Cache(options);
    }
};


// Least Recently Used (LRU) Cache

internals.Cache = class {

    constructor(options = {}) {

        Common.assertOptions(options, ['max']);
        assert(options.max === undefined || options.max && options.max > 0 && isFinite(options.max), 'Invalid max cache size');

        this._max = options.max || internals.max;

        this._map = new Map();                          // Map of nodes by key
        this._list = new internals.List();              // List of nodes (most recently used in head)
    }

    get length() {

        return this._map.size;
    }

    set(key, value) {

        if (key !== null &&
            !internals.supported.has(typeof key)) {

            return;
        }

        let node = this._map.get(key);
        if (node) {
            node.value = value;
            this._list.first(node);
            return;
        }

        node = this._list.unshift({ key, value });
        this._map.set(key, node);
        this._compact();
    }

    get(key) {

        const node = this._map.get(key);
        if (node) {
            this._list.first(node);
            return clone(node.value);
        }
    }

    _compact() {

        if (this._map.size > this._max) {
            const node = this._list.pop();
            this._map.delete(node.key);
        }
    }
};


internals.List = class {

    constructor() {

        this.tail = null;
        this.head = null;
    }

    unshift(node) {

        node.next = null;
        node.prev = this.head;

        if (this.head) {
            this.head.next = node;
        }

        this.head = node;

        if (!this.tail) {
            this.tail = node;
        }

        return node;
    }

    first(node) {

        if (node === this.head) {
            return;
        }

        this._remove(node);
        this.unshift(node);
    }

    pop() {

        return this._remove(this.tail);
    }

    _remove(node) {

        const { next, prev } = node;

        next.prev = prev;

        if (prev) {
            prev.next = next;
        }

        if (node === this.tail) {
            this.tail = next;
        }

        node.prev = null;
        node.next = null;

        return node;
    }
};


/***/ }),

/***/ 84205:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


const { assert: Assert, AssertError } = __nccwpck_require__(91884);

const Pkg = __nccwpck_require__(10570);

let Messages;
let Schemas;


const internals = {
    isoDate: /^(?:[-+]\d{2})?(?:\d{4}(?!\d{2}\b))(?:(-?)(?:(?:0[1-9]|1[0-2])(?:\1(?:[12]\d|0[1-9]|3[01]))?|W(?:[0-4]\d|5[0-2])(?:-?[1-7])?|(?:00[1-9]|0[1-9]\d|[12]\d{2}|3(?:[0-5]\d|6[1-6])))(?![T]$|[T][\d]+Z$)(?:[T\s](?:(?:(?:[01]\d|2[0-3])(?:(:?)[0-5]\d)?|24\:?00)(?:[.,]\d+(?!:))?)(?:\2[0-5]\d(?:[.,]\d+)?)?(?:[Z]|(?:[+-])(?:[01]\d|2[0-3])(?::?[0-5]\d)?)?)?)?$/
};


exports.version = Pkg.version;


exports.defaults = {
    abortEarly: true,
    allowUnknown: false,
    artifacts: false,
    cache: true,
    context: null,
    convert: true,
    dateFormat: 'iso',
    errors: {
        escapeHtml: false,
        label: 'path',
        language: null,
        render: true,
        stack: false,
        wrap: {
            label: '"',
            array: '[]'
        }
    },
    externals: true,
    messages: {},
    nonEnumerables: false,
    noDefaults: false,
    presence: 'optional',
    skipFunctions: false,
    stripUnknown: false,
    warnings: false
};


exports.symbols = {
    any: Symbol.for('@hapi/joi/schema'),            // Used to internally identify any-based types (shared with other joi versions)
    arraySingle: Symbol('arraySingle'),
    deepDefault: Symbol('deepDefault'),
    errors: Symbol('errors'),
    literal: Symbol('literal'),
    override: Symbol('override'),
    parent: Symbol('parent'),
    prefs: Symbol('prefs'),
    ref: Symbol('ref'),
    template: Symbol('template'),
    values: Symbol('values')
};


exports.assertOptions = function (options, keys, name = 'Options') {

    Assert(options && typeof options === 'object' && !Array.isArray(options), 'Options must be of type object');
    const unknownKeys = Object.keys(options).filter((k) => !keys.includes(k));
    Assert(unknownKeys.length === 0, `${name} contain unknown keys: ${unknownKeys}`);
};


exports.checkPreferences = function (prefs) {

    Schemas = Schemas || __nccwpck_require__(29918);

    const result = Schemas.preferences.validate(prefs);

    if (result.error) {
        throw new AssertError([result.error.details[0].message]);
    }
};


exports.compare = function (a, b, operator) {

    switch (operator) {
        case '=': return a === b;
        case '>': return a > b;
        case '<': return a < b;
        case '>=': return a >= b;
        case '<=': return a <= b;
    }
};


exports["default"] = function (value, defaultValue) {

    return value === undefined ? defaultValue : value;
};


exports.isIsoDate = function (date) {

    return internals.isoDate.test(date);
};


exports.isNumber = function (value) {

    return typeof value === 'number' && !isNaN(value);
};


exports.isResolvable = function (obj) {

    if (!obj) {
        return false;
    }

    return obj[exports.symbols.ref] || obj[exports.symbols.template];
};


exports.isSchema = function (schema, options = {}) {

    const any = schema && schema[exports.symbols.any];
    if (!any) {
        return false;
    }

    Assert(options.legacy || any.version === exports.version, 'Cannot mix different versions of joi schemas');
    return true;
};


exports.isValues = function (obj) {

    return obj[exports.symbols.values];
};


exports.limit = function (value) {

    return Number.isSafeInteger(value) && value >= 0;
};


exports.preferences = function (target, source) {

    Messages = Messages || __nccwpck_require__(31088);

    target = target || {};
    source = source || {};

    const merged = Object.assign({}, target, source);
    if (source.errors &&
        target.errors) {

        merged.errors = Object.assign({}, target.errors, source.errors);
        merged.errors.wrap = Object.assign({}, target.errors.wrap, source.errors.wrap);
    }

    if (source.messages) {
        merged.messages = Messages.compile(source.messages, target.messages);
    }

    delete merged[exports.symbols.prefs];
    return merged;
};


exports.tryWithPath = function (fn, key, options = {}) {

    try {
        return fn();
    }
    catch (err) {
        if (err.path !== undefined) {
            err.path = key + '.' + err.path;
        }
        else {
            err.path = key;
        }

        if (options.append) {
            err.message = `${err.message} (${err.path})`;
        }

        throw err;
    }
};


exports.validateArg = function (value, label, { assert, message }) {

    if (exports.isSchema(assert)) {
        const result = assert.validate(value);
        if (!result.error) {
            return;
        }

        return result.error.message;
    }
    else if (!assert(value)) {
        return label ? `${label} ${message}` : message;
    }
};


exports.verifyFlat = function (args, method) {

    for (const arg of args) {
        Assert(!Array.isArray(arg), 'Method no longer accepts array arguments:', method);
    }
};


/***/ }),

/***/ 14743:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


const { assert } = __nccwpck_require__(91884);

const Common = __nccwpck_require__(84205);
const Ref = __nccwpck_require__(51579);


const internals = {};


exports.schema = function (Joi, config, options = {}) {

    Common.assertOptions(options, ['appendPath', 'override']);

    try {
        return internals.schema(Joi, config, options);
    }
    catch (err) {
        if (options.appendPath &&
            err.path !== undefined) {

            err.message = `${err.message} (${err.path})`;
        }

        throw err;
    }
};


internals.schema = function (Joi, config, options) {

    assert(config !== undefined, 'Invalid undefined schema');

    if (Array.isArray(config)) {
        assert(config.length, 'Invalid empty array schema');

        if (config.length === 1) {
            config = config[0];
        }
    }

    const valid = (base, ...values) => {

        if (options.override !== false) {
            return base.valid(Joi.override, ...values);
        }

        return base.valid(...values);
    };

    if (internals.simple(config)) {
        return valid(Joi, config);
    }

    if (typeof config === 'function') {
        return Joi.custom(config);
    }

    assert(typeof config === 'object', 'Invalid schema content:', typeof config);

    if (Common.isResolvable(config)) {
        return valid(Joi, config);
    }

    if (Common.isSchema(config)) {
        return config;
    }

    if (Array.isArray(config)) {
        for (const item of config) {
            if (!internals.simple(item)) {
                return Joi.alternatives().try(...config);
            }
        }

        return valid(Joi, ...config);
    }

    if (config instanceof RegExp) {
        return Joi.string().regex(config);
    }

    if (config instanceof Date) {
        return valid(Joi.date(), config);
    }

    assert(Object.getPrototypeOf(config) === Object.getPrototypeOf({}), 'Schema can only contain plain objects');

    return Joi.object().keys(config);
};


exports.ref = function (id, options) {

    return Ref.isRef(id) ? id : Ref.create(id, options);
};


exports.compile = function (root, schema, options = {}) {

    Common.assertOptions(options, ['legacy']);

    // Compiled by any supported version

    const any = schema && schema[Common.symbols.any];
    if (any) {
        assert(options.legacy || any.version === Common.version, 'Cannot mix different versions of joi schemas:', any.version, Common.version);
        return schema;
    }

    // Uncompiled root

    if (typeof schema !== 'object' ||
        !options.legacy) {

        return exports.schema(root, schema, { appendPath: true });          // Will error if schema contains other versions
    }

    // Scan schema for compiled parts

    const compiler = internals.walk(schema);
    if (!compiler) {
        return exports.schema(root, schema, { appendPath: true });
    }

    return compiler.compile(compiler.root, schema);
};


internals.walk = function (schema) {

    if (typeof schema !== 'object') {
        return null;
    }

    if (Array.isArray(schema)) {
        for (const item of schema) {
            const compiler = internals.walk(item);
            if (compiler) {
                return compiler;
            }
        }

        return null;
    }

    const any = schema[Common.symbols.any];
    if (any) {
        return { root: schema[any.root], compile: any.compile };
    }

    assert(Object.getPrototypeOf(schema) === Object.getPrototypeOf({}), 'Schema can only contain plain objects');

    for (const key in schema) {
        const compiler = internals.walk(schema[key]);
        if (compiler) {
            return compiler;
        }
    }

    return null;
};


internals.simple = function (value) {

    return value === null || ['boolean', 'string', 'number'].includes(typeof value);
};


exports.when = function (schema, condition, options) {

    if (options === undefined) {
        assert(condition && typeof condition === 'object', 'Missing options');

        options = condition;
        condition = Ref.create('.');
    }

    if (Array.isArray(options)) {
        options = { switch: options };
    }

    Common.assertOptions(options, ['is', 'not', 'then', 'otherwise', 'switch', 'break']);

    // Schema condition

    if (Common.isSchema(condition)) {
        assert(options.is === undefined, '"is" can not be used with a schema condition');
        assert(options.not === undefined, '"not" can not be used with a schema condition');
        assert(options.switch === undefined, '"switch" can not be used with a schema condition');

        return internals.condition(schema, { is: condition, then: options.then, otherwise: options.otherwise, break: options.break });
    }

    // Single condition

    assert(Ref.isRef(condition) || typeof condition === 'string', 'Invalid condition:', condition);
    assert(options.not === undefined || options.is === undefined, 'Cannot combine "is" with "not"');

    if (options.switch === undefined) {
        let rule = options;
        if (options.not !== undefined) {
            rule = { is: options.not, then: options.otherwise, otherwise: options.then, break: options.break };
        }

        let is = rule.is !== undefined ? schema.$_compile(rule.is) : schema.$_root.invalid(null, false, 0, '').required();
        assert(rule.then !== undefined || rule.otherwise !== undefined, 'options must have at least one of "then", "otherwise", or "switch"');
        assert(rule.break === undefined || rule.then === undefined || rule.otherwise === undefined, 'Cannot specify then, otherwise, and break all together');

        if (options.is !== undefined &&
            !Ref.isRef(options.is) &&
            !Common.isSchema(options.is)) {

            is = is.required();                     // Only apply required if this wasn't already a schema or a ref
        }

        return internals.condition(schema, { ref: exports.ref(condition), is, then: rule.then, otherwise: rule.otherwise, break: rule.break });
    }

    // Switch statement

    assert(Array.isArray(options.switch), '"switch" must be an array');
    assert(options.is === undefined, 'Cannot combine "switch" with "is"');
    assert(options.not === undefined, 'Cannot combine "switch" with "not"');
    assert(options.then === undefined, 'Cannot combine "switch" with "then"');

    const rule = {
        ref: exports.ref(condition),
        switch: [],
        break: options.break
    };

    for (let i = 0; i < options.switch.length; ++i) {
        const test = options.switch[i];
        const last = i === options.switch.length - 1;

        Common.assertOptions(test, last ? ['is', 'then', 'otherwise'] : ['is', 'then']);

        assert(test.is !== undefined, 'Switch statement missing "is"');
        assert(test.then !== undefined, 'Switch statement missing "then"');

        const item = {
            is: schema.$_compile(test.is),
            then: schema.$_compile(test.then)
        };

        if (!Ref.isRef(test.is) &&
            !Common.isSchema(test.is)) {

            item.is = item.is.required();           // Only apply required if this wasn't already a schema or a ref
        }

        if (last) {
            assert(options.otherwise === undefined || test.otherwise === undefined, 'Cannot specify "otherwise" inside and outside a "switch"');
            const otherwise = options.otherwise !== undefined ? options.otherwise : test.otherwise;
            if (otherwise !== undefined) {
                assert(rule.break === undefined, 'Cannot specify both otherwise and break');
                item.otherwise = schema.$_compile(otherwise);
            }
        }

        rule.switch.push(item);
    }

    return rule;
};


internals.condition = function (schema, condition) {

    for (const key of ['then', 'otherwise']) {
        if (condition[key] === undefined) {
            delete condition[key];
        }
        else {
            condition[key] = schema.$_compile(condition[key]);
        }
    }

    return condition;
};


/***/ }),

/***/ 11543:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


const Annotate = __nccwpck_require__(53080);
const Common = __nccwpck_require__(84205);
const Template = __nccwpck_require__(75706);


const internals = {};


exports.Report = class {

    constructor(code, value, local, flags, messages, state, prefs) {

        this.code = code;
        this.flags = flags;
        this.messages = messages;
        this.path = state.path;
        this.prefs = prefs;
        this.state = state;
        this.value = value;

        this.message = null;
        this.template = null;

        this.local = local || {};
        this.local.label = exports.label(this.flags, this.state, this.prefs, this.messages);

        if (this.value !== undefined &&
            !this.local.hasOwnProperty('value')) {

            this.local.value = this.value;
        }

        if (this.path.length) {
            const key = this.path[this.path.length - 1];
            if (typeof key !== 'object') {
                this.local.key = key;
            }
        }
    }

    _setTemplate(template) {

        this.template = template;

        if (!this.flags.label &&
            this.path.length === 0) {

            const localized = this._template(this.template, 'root');
            if (localized) {
                this.local.label = localized;
            }
        }
    }

    toString() {

        if (this.message) {
            return this.message;
        }

        const code = this.code;

        if (!this.prefs.errors.render) {
            return this.code;
        }

        const template = this._template(this.template) ||
            this._template(this.prefs.messages) ||
            this._template(this.messages);

        if (template === undefined) {
            return `Error code "${code}" is not defined, your custom type is missing the correct messages definition`;
        }

        // Render and cache result

        this.message = template.render(this.value, this.state, this.prefs, this.local, { errors: this.prefs.errors, messages: [this.prefs.messages, this.messages] });
        if (!this.prefs.errors.label) {
            this.message = this.message.replace(/^"" /, '').trim();
        }

        return this.message;
    }

    _template(messages, code) {

        return exports.template(this.value, messages, code || this.code, this.state, this.prefs);
    }
};


exports.path = function (path) {

    let label = '';
    for (const segment of path) {
        if (typeof segment === 'object') {          // Exclude array single path segment
            continue;
        }

        if (typeof segment === 'string') {
            if (label) {
                label += '.';
            }

            label += segment;
        }
        else {
            label += `[${segment}]`;
        }
    }

    return label;
};


exports.template = function (value, messages, code, state, prefs) {

    if (!messages) {
        return;
    }

    if (Template.isTemplate(messages)) {
        return code !== 'root' ? messages : null;
    }

    let lang = prefs.errors.language;
    if (Common.isResolvable(lang)) {
        lang = lang.resolve(value, state, prefs);
    }

    if (lang &&
        messages[lang]) {

        if (messages[lang][code] !== undefined) {
            return messages[lang][code];
        }

        if (messages[lang]['*'] !== undefined) {
            return messages[lang]['*'];
        }
    }

    if (!messages[code]) {
        return messages['*'];
    }

    return messages[code];
};


exports.label = function (flags, state, prefs, messages) {

    if (!prefs.errors.label) {
        return '';
    }

    if (flags.label) {
        return flags.label;
    }

    let path = state.path;
    if (prefs.errors.label === 'key' &&
        state.path.length > 1) {

        path = state.path.slice(-1);
    }

    const normalized = exports.path(path);
    if (normalized) {
        return normalized;
    }

    return exports.template(null, prefs.messages, 'root', state, prefs) ||
        messages && exports.template(null, messages, 'root', state, prefs) ||
        'value';
};


exports.process = function (errors, original, prefs) {

    if (!errors) {
        return null;
    }

    const { override, message, details } = exports.details(errors);
    if (override) {
        return override;
    }

    if (prefs.errors.stack) {
        return new exports.ValidationError(message, details, original);
    }

    const limit = Error.stackTraceLimit;
    Error.stackTraceLimit = 0;
    const validationError = new exports.ValidationError(message, details, original);
    Error.stackTraceLimit = limit;
    return validationError;
};


exports.details = function (errors, options = {}) {

    let messages = [];
    const details = [];

    for (const item of errors) {

        // Override

        if (item instanceof Error) {
            if (options.override !== false) {
                return { override: item };
            }

            const message = item.toString();
            messages.push(message);

            details.push({
                message,
                type: 'override',
                context: { error: item }
            });

            continue;
        }

        // Report

        const message = item.toString();
        messages.push(message);

        details.push({
            message,
            path: item.path.filter((v) => typeof v !== 'object'),
            type: item.code,
            context: item.local
        });
    }

    if (messages.length > 1) {
        messages = [...new Set(messages)];
    }

    return { message: messages.join('. '), details };
};


exports.ValidationError = class extends Error {

    constructor(message, details, original) {

        super(message);
        this._original = original;
        this.details = details;
    }

    static isError(err) {

        return err instanceof exports.ValidationError;
    }
};


exports.ValidationError.prototype.isJoi = true;

exports.ValidationError.prototype.name = 'ValidationError';

exports.ValidationError.prototype.annotate = Annotate.error;


/***/ }),

/***/ 74376:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


const { assert, clone } = __nccwpck_require__(91884);

const Common = __nccwpck_require__(84205);
const Messages = __nccwpck_require__(31088);


const internals = {};


exports.type = function (from, options) {

    const base = Object.getPrototypeOf(from);
    const prototype = clone(base);
    const schema = from._assign(Object.create(prototype));
    const def = Object.assign({}, options);                                 // Shallow cloned
    delete def.base;

    prototype._definition = def;

    const parent = base._definition || {};
    def.messages = Messages.merge(parent.messages, def.messages);
    def.properties = Object.assign({}, parent.properties, def.properties);

    // Type

    schema.type = def.type;

    // Flags

    def.flags = Object.assign({}, parent.flags, def.flags);

    // Terms

    const terms = Object.assign({}, parent.terms);
    if (def.terms) {
        for (const name in def.terms) {                                     // Only apply own terms
            const term = def.terms[name];
            assert(schema.$_terms[name] === undefined, 'Invalid term override for', def.type, name);
            schema.$_terms[name] = term.init;
            terms[name] = term;
        }
    }

    def.terms = terms;

    // Constructor arguments

    if (!def.args) {
        def.args = parent.args;
    }

    // Prepare

    def.prepare = internals.prepare(def.prepare, parent.prepare);

    // Coerce

    if (def.coerce) {
        if (typeof def.coerce === 'function') {
            def.coerce = { method: def.coerce };
        }

        if (def.coerce.from &&
            !Array.isArray(def.coerce.from)) {

            def.coerce = { method: def.coerce.method, from: [].concat(def.coerce.from) };
        }
    }

    def.coerce = internals.coerce(def.coerce, parent.coerce);

    // Validate

    def.validate = internals.validate(def.validate, parent.validate);

    // Rules

    const rules = Object.assign({}, parent.rules);
    if (def.rules) {
        for (const name in def.rules) {
            const rule = def.rules[name];
            assert(typeof rule === 'object', 'Invalid rule definition for', def.type, name);

            let method = rule.method;
            if (method === undefined) {
                method = function () {

                    return this.$_addRule(name);
                };
            }

            if (method) {
                assert(!prototype[name], 'Rule conflict in', def.type, name);
                prototype[name] = method;
            }

            assert(!rules[name], 'Rule conflict in', def.type, name);
            rules[name] = rule;

            if (rule.alias) {
                const aliases = [].concat(rule.alias);
                for (const alias of aliases) {
                    prototype[alias] = rule.method;
                }
            }

            if (rule.args) {
                rule.argsByName = new Map();
                rule.args = rule.args.map((arg) => {

                    if (typeof arg === 'string') {
                        arg = { name: arg };
                    }

                    assert(!rule.argsByName.has(arg.name), 'Duplicated argument name', arg.name);

                    if (Common.isSchema(arg.assert)) {
                        arg.assert = arg.assert.strict().label(arg.name);
                    }

                    rule.argsByName.set(arg.name, arg);
                    return arg;
                });
            }
        }
    }

    def.rules = rules;

    // Modifiers

    const modifiers = Object.assign({}, parent.modifiers);
    if (def.modifiers) {
        for (const name in def.modifiers) {
            assert(!prototype[name], 'Rule conflict in', def.type, name);

            const modifier = def.modifiers[name];
            assert(typeof modifier === 'function', 'Invalid modifier definition for', def.type, name);

            const method = function (arg) {

                return this.rule({ [name]: arg });
            };

            prototype[name] = method;
            modifiers[name] = modifier;
        }
    }

    def.modifiers = modifiers;

    // Overrides

    if (def.overrides) {
        prototype._super = base;
        schema.$_super = {};                                                            // Backwards compatibility
        for (const override in def.overrides) {
            assert(base[override], 'Cannot override missing', override);
            def.overrides[override][Common.symbols.parent] = base[override];
            schema.$_super[override] = base[override].bind(schema);                     // Backwards compatibility
        }

        Object.assign(prototype, def.overrides);
    }

    // Casts

    def.cast = Object.assign({}, parent.cast, def.cast);

    // Manifest

    const manifest = Object.assign({}, parent.manifest, def.manifest);
    manifest.build = internals.build(def.manifest && def.manifest.build, parent.manifest && parent.manifest.build);
    def.manifest = manifest;

    // Rebuild

    def.rebuild = internals.rebuild(def.rebuild, parent.rebuild);

    return schema;
};


// Helpers

internals.build = function (child, parent) {

    if (!child ||
        !parent) {

        return child || parent;
    }

    return function (obj, desc) {

        return parent(child(obj, desc), desc);
    };
};


internals.coerce = function (child, parent) {

    if (!child ||
        !parent) {

        return child || parent;
    }

    return {
        from: child.from && parent.from ? [...new Set([...child.from, ...parent.from])] : null,
        method(value, helpers) {

            let coerced;
            if (!parent.from ||
                parent.from.includes(typeof value)) {

                coerced = parent.method(value, helpers);
                if (coerced) {
                    if (coerced.errors ||
                        coerced.value === undefined) {

                        return coerced;
                    }

                    value = coerced.value;
                }
            }

            if (!child.from ||
                child.from.includes(typeof value)) {

                const own = child.method(value, helpers);
                if (own) {
                    return own;
                }
            }

            return coerced;
        }
    };
};


internals.prepare = function (child, parent) {

    if (!child ||
        !parent) {

        return child || parent;
    }

    return function (value, helpers) {

        const prepared = child(value, helpers);
        if (prepared) {
            if (prepared.errors ||
                prepared.value === undefined) {

                return prepared;
            }

            value = prepared.value;
        }

        return parent(value, helpers) || prepared;
    };
};


internals.rebuild = function (child, parent) {

    if (!child ||
        !parent) {

        return child || parent;
    }

    return function (schema) {

        parent(schema);
        child(schema);
    };
};


internals.validate = function (child, parent) {

    if (!child ||
        !parent) {

        return child || parent;
    }

    return function (value, helpers) {

        const result = parent(value, helpers);
        if (result) {
            if (result.errors &&
                (!Array.isArray(result.errors) || result.errors.length)) {

                return result;
            }

            value = result.value;
        }

        return child(value, helpers) || result;
    };
};


/***/ }),

/***/ 81154:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


const { assert, clone } = __nccwpck_require__(91884);

const Cache = __nccwpck_require__(12644);
const Common = __nccwpck_require__(84205);
const Compile = __nccwpck_require__(14743);
const Errors = __nccwpck_require__(11543);
const Extend = __nccwpck_require__(74376);
const Manifest = __nccwpck_require__(25705);
const Ref = __nccwpck_require__(51579);
const Template = __nccwpck_require__(75706);
const Trace = __nccwpck_require__(23327);

let Schemas;


const internals = {
    types: {
        alternatives: __nccwpck_require__(52346),
        any: __nccwpck_require__(49046),
        array: __nccwpck_require__(62801),
        boolean: __nccwpck_require__(44228),
        date: __nccwpck_require__(9922),
        function: __nccwpck_require__(47210),
        link: __nccwpck_require__(30810),
        number: __nccwpck_require__(84599),
        object: __nccwpck_require__(85869),
        string: __nccwpck_require__(72423),
        symbol: __nccwpck_require__(24602)
    },
    aliases: {
        alt: 'alternatives',
        bool: 'boolean',
        func: 'function'
    }
};


if (Buffer) {                                                           // $lab:coverage:ignore$
    internals.types.binary = __nccwpck_require__(68499);
}


internals.root = function () {

    const root = {
        _types: new Set(Object.keys(internals.types))
    };

    // Types

    for (const type of root._types) {
        root[type] = function (...args) {

            assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');
            return internals.generate(this, internals.types[type], args);
        };
    }

    // Shortcuts

    for (const method of ['allow', 'custom', 'disallow', 'equal', 'exist', 'forbidden', 'invalid', 'not', 'only', 'optional', 'options', 'prefs', 'preferences', 'required', 'strip', 'valid', 'when']) {
        root[method] = function (...args) {

            return this.any()[method](...args);
        };
    }

    // Methods

    Object.assign(root, internals.methods);

    // Aliases

    for (const alias in internals.aliases) {
        const target = internals.aliases[alias];
        root[alias] = root[target];
    }

    root.x = root.expression;

    // Trace

    if (Trace.setup) {                                          // $lab:coverage:ignore$
        Trace.setup(root);
    }

    return root;
};


internals.methods = {

    ValidationError: Errors.ValidationError,
    version: Common.version,
    cache: Cache.provider,

    assert(value, schema, ...args /* [message], [options] */) {

        internals.assert(value, schema, true, args);
    },

    attempt(value, schema, ...args /* [message], [options] */) {

        return internals.assert(value, schema, false, args);
    },

    build(desc) {

        assert(typeof Manifest.build === 'function', 'Manifest functionality disabled');
        return Manifest.build(this, desc);
    },

    checkPreferences(prefs) {

        Common.checkPreferences(prefs);
    },

    compile(schema, options) {

        return Compile.compile(this, schema, options);
    },

    defaults(modifier) {

        assert(typeof modifier === 'function', 'modifier must be a function');

        const joi = Object.assign({}, this);
        for (const type of joi._types) {
            const schema = modifier(joi[type]());
            assert(Common.isSchema(schema), 'modifier must return a valid schema object');

            joi[type] = function (...args) {

                return internals.generate(this, schema, args);
            };
        }

        return joi;
    },

    expression(...args) {

        return new Template(...args);
    },

    extend(...extensions) {

        Common.verifyFlat(extensions, 'extend');

        Schemas = Schemas || __nccwpck_require__(29918);

        assert(extensions.length, 'You need to provide at least one extension');
        this.assert(extensions, Schemas.extensions);

        const joi = Object.assign({}, this);
        joi._types = new Set(joi._types);

        for (let extension of extensions) {
            if (typeof extension === 'function') {
                extension = extension(joi);
            }

            this.assert(extension, Schemas.extension);

            const expanded = internals.expandExtension(extension, joi);
            for (const item of expanded) {
                assert(joi[item.type] === undefined || joi._types.has(item.type), 'Cannot override name', item.type);

                const base = item.base || this.any();
                const schema = Extend.type(base, item);

                joi._types.add(item.type);
                joi[item.type] = function (...args) {

                    return internals.generate(this, schema, args);
                };
            }
        }

        return joi;
    },

    isError: Errors.ValidationError.isError,
    isExpression: Template.isTemplate,
    isRef: Ref.isRef,
    isSchema: Common.isSchema,

    in(...args) {

        return Ref.in(...args);
    },

    override: Common.symbols.override,

    ref(...args) {

        return Ref.create(...args);
    },

    types() {

        const types = {};
        for (const type of this._types) {
            types[type] = this[type]();
        }

        for (const target in internals.aliases) {
            types[target] = this[target]();
        }

        return types;
    }
};


// Helpers

internals.assert = function (value, schema, annotate, args /* [message], [options] */) {

    const message = args[0] instanceof Error || typeof args[0] === 'string' ? args[0] : null;
    const options = message !== null ? args[1] : args[0];
    const result = schema.validate(value, Common.preferences({ errors: { stack: true } }, options || {}));

    let error = result.error;
    if (!error) {
        return result.value;
    }

    if (message instanceof Error) {
        throw message;
    }

    const display = annotate && typeof error.annotate === 'function' ? error.annotate() : error.message;

    if (error instanceof Errors.ValidationError === false) {
        error = clone(error);
    }

    error.message = message ? `${message} ${display}` : display;
    throw error;
};


internals.generate = function (root, schema, args) {

    assert(root, 'Must be invoked on a Joi instance.');

    schema.$_root = root;

    if (!schema._definition.args ||
        !args.length) {

        return schema;
    }

    return schema._definition.args(schema, ...args);
};


internals.expandExtension = function (extension, joi) {

    if (typeof extension.type === 'string') {
        return [extension];
    }

    const extended = [];
    for (const type of joi._types) {
        if (extension.type.test(type)) {
            const item = Object.assign({}, extension);
            item.type = type;
            item.base = joi[type]();
            extended.push(item);
        }
    }

    return extended;
};


module.exports = internals.root();


/***/ }),

/***/ 25705:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


const { assert, clone } = __nccwpck_require__(91884);

const Common = __nccwpck_require__(84205);
const Messages = __nccwpck_require__(31088);
const Ref = __nccwpck_require__(51579);
const Template = __nccwpck_require__(75706);

let Schemas;


const internals = {};


exports.describe = function (schema) {

    const def = schema._definition;

    // Type

    const desc = {
        type: schema.type,
        flags: {},
        rules: []
    };

    // Flags

    for (const flag in schema._flags) {
        if (flag[0] !== '_') {
            desc.flags[flag] = internals.describe(schema._flags[flag]);
        }
    }

    if (!Object.keys(desc.flags).length) {
        delete desc.flags;
    }

    // Preferences

    if (schema._preferences) {
        desc.preferences = clone(schema._preferences, { shallow: ['messages'] });
        delete desc.preferences[Common.symbols.prefs];
        if (desc.preferences.messages) {
            desc.preferences.messages = Messages.decompile(desc.preferences.messages);
        }
    }

    // Allow / Invalid

    if (schema._valids) {
        desc.allow = schema._valids.describe();
    }

    if (schema._invalids) {
        desc.invalid = schema._invalids.describe();
    }

    // Rules

    for (const rule of schema._rules) {
        const ruleDef = def.rules[rule.name];
        if (ruleDef.manifest === false) {                           // Defaults to true
            continue;
        }

        const item = { name: rule.name };

        for (const custom in def.modifiers) {
            if (rule[custom] !== undefined) {
                item[custom] = internals.describe(rule[custom]);
            }
        }

        if (rule.args) {
            item.args = {};
            for (const key in rule.args) {
                const arg = rule.args[key];
                if (key === 'options' &&
                    !Object.keys(arg).length) {

                    continue;
                }

                item.args[key] = internals.describe(arg, { assign: key });
            }

            if (!Object.keys(item.args).length) {
                delete item.args;
            }
        }

        desc.rules.push(item);
    }

    if (!desc.rules.length) {
        delete desc.rules;
    }

    // Terms (must be last to verify no name conflicts)

    for (const term in schema.$_terms) {
        if (term[0] === '_') {
            continue;
        }

        assert(!desc[term], 'Cannot describe schema due to internal name conflict with', term);

        const items = schema.$_terms[term];
        if (!items) {
            continue;
        }

        if (items instanceof Map) {
            if (items.size) {
                desc[term] = [...items.entries()];
            }

            continue;
        }

        if (Common.isValues(items)) {
            desc[term] = items.describe();
            continue;
        }

        assert(def.terms[term], 'Term', term, 'missing configuration');
        const manifest = def.terms[term].manifest;
        const mapped = typeof manifest === 'object';
        if (!items.length &&
            !mapped) {

            continue;
        }

        const normalized = [];
        for (const item of items) {
            normalized.push(internals.describe(item));
        }

        // Mapped

        if (mapped) {
            const { from, to } = manifest.mapped;
            desc[term] = {};
            for (const item of normalized) {
                desc[term][item[to]] = item[from];
            }

            continue;
        }

        // Single

        if (manifest === 'single') {
            assert(normalized.length === 1, 'Term', term, 'contains more than one item');
            desc[term] = normalized[0];
            continue;
        }

        // Array

        desc[term] = normalized;
    }

    internals.validate(schema.$_root, desc);
    return desc;
};


internals.describe = function (item, options = {}) {

    if (Array.isArray(item)) {
        return item.map(internals.describe);
    }

    if (item === Common.symbols.deepDefault) {
        return { special: 'deep' };
    }

    if (typeof item !== 'object' ||
        item === null) {

        return item;
    }

    if (options.assign === 'options') {
        return clone(item);
    }

    if (Buffer && Buffer.isBuffer(item)) {                          // $lab:coverage:ignore$
        return { buffer: item.toString('binary') };
    }

    if (item instanceof Date) {
        return item.toISOString();
    }

    if (item instanceof Error) {
        return item;
    }

    if (item instanceof RegExp) {
        if (options.assign === 'regex') {
            return item.toString();
        }

        return { regex: item.toString() };
    }

    if (item[Common.symbols.literal]) {
        return { function: item.literal };
    }

    if (typeof item.describe === 'function') {
        if (options.assign === 'ref') {
            return item.describe().ref;
        }

        return item.describe();
    }

    const normalized = {};
    for (const key in item) {
        const value = item[key];
        if (value === undefined) {
            continue;
        }

        normalized[key] = internals.describe(value, { assign: key });
    }

    return normalized;
};


exports.build = function (joi, desc) {

    const builder = new internals.Builder(joi);
    return builder.parse(desc);
};


internals.Builder = class {

    constructor(joi) {

        this.joi = joi;
    }

    parse(desc) {

        internals.validate(this.joi, desc);

        // Type

        let schema = this.joi[desc.type]()._bare();
        const def = schema._definition;

        // Flags

        if (desc.flags) {
            for (const flag in desc.flags) {
                const setter = def.flags[flag] && def.flags[flag].setter || flag;
                assert(typeof schema[setter] === 'function', 'Invalid flag', flag, 'for type', desc.type);
                schema = schema[setter](this.build(desc.flags[flag]));
            }
        }

        // Preferences

        if (desc.preferences) {
            schema = schema.preferences(this.build(desc.preferences));
        }

        // Allow / Invalid

        if (desc.allow) {
            schema = schema.allow(...this.build(desc.allow));
        }

        if (desc.invalid) {
            schema = schema.invalid(...this.build(desc.invalid));
        }

        // Rules

        if (desc.rules) {
            for (const rule of desc.rules) {
                assert(typeof schema[rule.name] === 'function', 'Invalid rule', rule.name, 'for type', desc.type);

                const args = [];
                if (rule.args) {
                    const built = {};
                    for (const key in rule.args) {
                        built[key] = this.build(rule.args[key], { assign: key });
                    }

                    const keys = Object.keys(built);
                    const definition = def.rules[rule.name].args;
                    if (definition) {
                        assert(keys.length <= definition.length, 'Invalid number of arguments for', desc.type, rule.name, '(expected up to', definition.length, ', found', keys.length, ')');
                        for (const { name } of definition) {
                            args.push(built[name]);
                        }
                    }
                    else {
                        assert(keys.length === 1, 'Invalid number of arguments for', desc.type, rule.name, '(expected up to 1, found', keys.length, ')');
                        args.push(built[keys[0]]);
                    }
                }

                // Apply

                schema = schema[rule.name](...args);

                // Ruleset

                const options = {};
                for (const custom in def.modifiers) {
                    if (rule[custom] !== undefined) {
                        options[custom] = this.build(rule[custom]);
                    }
                }

                if (Object.keys(options).length) {
                    schema = schema.rule(options);
                }
            }
        }

        // Terms

        const terms = {};
        for (const key in desc) {
            if (['allow', 'flags', 'invalid', 'whens', 'preferences', 'rules', 'type'].includes(key)) {
                continue;
            }

            assert(def.terms[key], 'Term', key, 'missing configuration');
            const manifest = def.terms[key].manifest;

            if (manifest === 'schema') {
                terms[key] = desc[key].map((item) => this.parse(item));
                continue;
            }

            if (manifest === 'values') {
                terms[key] = desc[key].map((item) => this.build(item));
                continue;
            }

            if (manifest === 'single') {
                terms[key] = this.build(desc[key]);
                continue;
            }

            if (typeof manifest === 'object') {
                terms[key] = {};
                for (const name in desc[key]) {
                    const value = desc[key][name];
                    terms[key][name] = this.parse(value);
                }

                continue;
            }

            terms[key] = this.build(desc[key]);
        }

        if (desc.whens) {
            terms.whens = desc.whens.map((when) => this.build(when));
        }

        schema = def.manifest.build(schema, terms);
        schema.$_temp.ruleset = false;
        return schema;
    }

    build(desc, options = {}) {

        if (desc === null) {
            return null;
        }

        if (Array.isArray(desc)) {
            return desc.map((item) => this.build(item));
        }

        if (desc instanceof Error) {
            return desc;
        }

        if (options.assign === 'options') {
            return clone(desc);
        }

        if (options.assign === 'regex') {
            return internals.regex(desc);
        }

        if (options.assign === 'ref') {
            return Ref.build(desc);
        }

        if (typeof desc !== 'object') {
            return desc;
        }

        if (Object.keys(desc).length === 1) {
            if (desc.buffer) {
                assert(Buffer, 'Buffers are not supported');
                return Buffer && Buffer.from(desc.buffer, 'binary');                    // $lab:coverage:ignore$
            }

            if (desc.function) {
                return { [Common.symbols.literal]: true, literal: desc.function };
            }

            if (desc.override) {
                return Common.symbols.override;
            }

            if (desc.ref) {
                return Ref.build(desc.ref);
            }

            if (desc.regex) {
                return internals.regex(desc.regex);
            }

            if (desc.special) {
                assert(['deep'].includes(desc.special), 'Unknown special value', desc.special);
                return Common.symbols.deepDefault;
            }

            if (desc.value) {
                return clone(desc.value);
            }
        }

        if (desc.type) {
            return this.parse(desc);
        }

        if (desc.template) {
            return Template.build(desc);
        }

        const normalized = {};
        for (const key in desc) {
            normalized[key] = this.build(desc[key], { assign: key });
        }

        return normalized;
    }
};


internals.regex = function (string) {

    const end = string.lastIndexOf('/');
    const exp = string.slice(1, end);
    const flags = string.slice(end + 1);
    return new RegExp(exp, flags);
};


internals.validate = function (joi, desc) {

    Schemas = Schemas || __nccwpck_require__(29918);

    joi.assert(desc, Schemas.description);
};


/***/ }),

/***/ 31088:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


const { assert, clone } = __nccwpck_require__(91884);

const Template = __nccwpck_require__(75706);


const internals = {};


exports.compile = function (messages, target) {

    // Single value string ('plain error message', 'template {error} message')

    if (typeof messages === 'string') {
        assert(!target, 'Cannot set single message string');
        return new Template(messages);
    }

    // Single value template

    if (Template.isTemplate(messages)) {
        assert(!target, 'Cannot set single message template');
        return messages;
    }

    // By error code { 'number.min': <string | template> }

    assert(typeof messages === 'object' && !Array.isArray(messages), 'Invalid message options');

    target = target ? clone(target) : {};

    for (let code in messages) {
        const message = messages[code];

        if (code === 'root' ||
            Template.isTemplate(message)) {

            target[code] = message;
            continue;
        }

        if (typeof message === 'string') {
            target[code] = new Template(message);
            continue;
        }

        // By language { english: { 'number.min': <string | template> } }

        assert(typeof message === 'object' && !Array.isArray(message), 'Invalid message for', code);

        const language = code;
        target[language] = target[language] || {};

        for (code in message) {
            const localized = message[code];

            if (code === 'root' ||
                Template.isTemplate(localized)) {

                target[language][code] = localized;
                continue;
            }

            assert(typeof localized === 'string', 'Invalid message for', code, 'in', language);
            target[language][code] = new Template(localized);
        }
    }

    return target;
};


exports.decompile = function (messages) {

    // By error code { 'number.min': <string | template> }

    const target = {};
    for (let code in messages) {
        const message = messages[code];

        if (code === 'root') {
            target.root = message;
            continue;
        }

        if (Template.isTemplate(message)) {
            target[code] = message.describe({ compact: true });
            continue;
        }

        // By language { english: { 'number.min': <string | template> } }

        const language = code;
        target[language] = {};

        for (code in message) {
            const localized = message[code];

            if (code === 'root') {
                target[language].root = localized;
                continue;
            }

            target[language][code] = localized.describe({ compact: true });
        }
    }

    return target;
};


exports.merge = function (base, extended) {

    if (!base) {
        return exports.compile(extended);
    }

    if (!extended) {
        return base;
    }

    // Single value string

    if (typeof extended === 'string') {
        return new Template(extended);
    }

    // Single value template

    if (Template.isTemplate(extended)) {
        return extended;
    }

    // By error code { 'number.min': <string | template> }

    const target = clone(base);

    for (let code in extended) {
        const message = extended[code];

        if (code === 'root' ||
            Template.isTemplate(message)) {

            target[code] = message;
            continue;
        }

        if (typeof message === 'string') {
            target[code] = new Template(message);
            continue;
        }

        // By language { english: { 'number.min': <string | template> } }

        assert(typeof message === 'object' && !Array.isArray(message), 'Invalid message for', code);

        const language = code;
        target[language] = target[language] || {};

        for (code in message) {
            const localized = message[code];

            if (code === 'root' ||
                Template.isTemplate(localized)) {

                target[language][code] = localized;
                continue;
            }

            assert(typeof localized === 'string', 'Invalid message for', code, 'in', language);
            target[language][code] = new Template(localized);
        }
    }

    return target;
};


/***/ }),

/***/ 89730:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


const { assert } = __nccwpck_require__(91884);

const Common = __nccwpck_require__(84205);
const Ref = __nccwpck_require__(51579);


const internals = {};



exports.Ids = internals.Ids = class {

    constructor() {

        this._byId = new Map();
        this._byKey = new Map();
        this._schemaChain = false;
    }

    clone() {

        const clone = new internals.Ids();
        clone._byId = new Map(this._byId);
        clone._byKey = new Map(this._byKey);
        clone._schemaChain = this._schemaChain;
        return clone;
    }

    concat(source) {

        if (source._schemaChain) {
            this._schemaChain = true;
        }

        for (const [id, value] of source._byId.entries()) {
            assert(!this._byKey.has(id), 'Schema id conflicts with existing key:', id);
            this._byId.set(id, value);
        }

        for (const [key, value] of source._byKey.entries()) {
            assert(!this._byId.has(key), 'Schema key conflicts with existing id:', key);
            this._byKey.set(key, value);
        }
    }

    fork(path, adjuster, root) {

        const chain = this._collect(path);
        chain.push({ schema: root });
        const tail = chain.shift();
        let adjusted = { id: tail.id, schema: adjuster(tail.schema) };

        assert(Common.isSchema(adjusted.schema), 'adjuster function failed to return a joi schema type');

        for (const node of chain) {
            adjusted = { id: node.id, schema: internals.fork(node.schema, adjusted.id, adjusted.schema) };
        }

        return adjusted.schema;
    }

    labels(path, behind = []) {

        const current = path[0];
        const node = this._get(current);
        if (!node) {
            return [...behind, ...path].join('.');
        }

        const forward = path.slice(1);
        behind = [...behind, node.schema._flags.label || current];
        if (!forward.length) {
            return behind.join('.');
        }

        return node.schema._ids.labels(forward, behind);
    }

    reach(path, behind = []) {

        const current = path[0];
        const node = this._get(current);
        assert(node, 'Schema does not contain path', [...behind, ...path].join('.'));

        const forward = path.slice(1);
        if (!forward.length) {
            return node.schema;
        }

        return node.schema._ids.reach(forward, [...behind, current]);
    }

    register(schema, { key } = {}) {

        if (!schema ||
            !Common.isSchema(schema)) {

            return;
        }

        if (schema.$_property('schemaChain') ||
            schema._ids._schemaChain) {

            this._schemaChain = true;
        }

        const id = schema._flags.id;
        if (id) {
            const existing = this._byId.get(id);
            assert(!existing || existing.schema === schema, 'Cannot add different schemas with the same id:', id);
            assert(!this._byKey.has(id), 'Schema id conflicts with existing key:', id);

            this._byId.set(id, { schema, id });
        }

        if (key) {
            assert(!this._byKey.has(key), 'Schema already contains key:', key);
            assert(!this._byId.has(key), 'Schema key conflicts with existing id:', key);

            this._byKey.set(key, { schema, id: key });
        }
    }

    reset() {

        this._byId = new Map();
        this._byKey = new Map();
        this._schemaChain = false;
    }

    _collect(path, behind = [], nodes = []) {

        const current = path[0];
        const node = this._get(current);
        assert(node, 'Schema does not contain path', [...behind, ...path].join('.'));

        nodes = [node, ...nodes];

        const forward = path.slice(1);
        if (!forward.length) {
            return nodes;
        }

        return node.schema._ids._collect(forward, [...behind, current], nodes);
    }

    _get(id) {

        return this._byId.get(id) || this._byKey.get(id);
    }
};


internals.fork = function (schema, id, replacement) {

    const each = (item, { key }) => {

        if (id === (item._flags.id || key)) {
            return replacement;
        }
    };

    const obj = exports.schema(schema, { each, ref: false });
    return obj ? obj.$_mutateRebuild() : schema;
};


exports.schema = function (schema, options) {

    let obj;

    for (const name in schema._flags) {
        if (name[0] === '_') {
            continue;
        }

        const result = internals.scan(schema._flags[name], { source: 'flags', name }, options);
        if (result !== undefined) {
            obj = obj || schema.clone();
            obj._flags[name] = result;
        }
    }

    for (let i = 0; i < schema._rules.length; ++i) {
        const rule = schema._rules[i];
        const result = internals.scan(rule.args, { source: 'rules', name: rule.name }, options);
        if (result !== undefined) {
            obj = obj || schema.clone();
            const clone = Object.assign({}, rule);
            clone.args = result;
            obj._rules[i] = clone;

            const existingUnique = obj._singleRules.get(rule.name);
            if (existingUnique === rule) {
                obj._singleRules.set(rule.name, clone);
            }
        }
    }

    for (const name in schema.$_terms) {
        if (name[0] === '_') {
            continue;
        }

        const result = internals.scan(schema.$_terms[name], { source: 'terms', name }, options);
        if (result !== undefined) {
            obj = obj || schema.clone();
            obj.$_terms[name] = result;
        }
    }

    return obj;
};


internals.scan = function (item, source, options, _path, _key) {

    const path = _path || [];

    if (item === null ||
        typeof item !== 'object') {

        return;
    }

    let clone;

    if (Array.isArray(item)) {
        for (let i = 0; i < item.length; ++i) {
            const key = source.source === 'terms' && source.name === 'keys' && item[i].key;
            const result = internals.scan(item[i], source, options, [i, ...path], key);
            if (result !== undefined) {
                clone = clone || item.slice();
                clone[i] = result;
            }
        }

        return clone;
    }

    if (options.schema !== false && Common.isSchema(item) ||
        options.ref !== false && Ref.isRef(item)) {

        const result = options.each(item, { ...source, path, key: _key });
        if (result === item) {
            return;
        }

        return result;
    }

    for (const key in item) {
        if (key[0] === '_') {
            continue;
        }

        const result = internals.scan(item[key], source, options, [key, ...path], _key);
        if (result !== undefined) {
            clone = clone || Object.assign({}, item);
            clone[key] = result;
        }
    }

    return clone;
};


/***/ }),

/***/ 51579:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


const { assert, clone, reach } = __nccwpck_require__(91884);

const Common = __nccwpck_require__(84205);

let Template;


const internals = {
    symbol: Symbol('ref'),      // Used to internally identify references (shared with other joi versions)
    defaults: {
        adjust: null,
        in: false,
        iterables: null,
        map: null,
        separator: '.',
        type: 'value'
    }
};


exports.create = function (key, options = {}) {

    assert(typeof key === 'string', 'Invalid reference key:', key);
    Common.assertOptions(options, ['adjust', 'ancestor', 'in', 'iterables', 'map', 'prefix', 'render', 'separator']);
    assert(!options.prefix || typeof options.prefix === 'object', 'options.prefix must be of type object');

    const ref = Object.assign({}, internals.defaults, options);
    delete ref.prefix;

    const separator = ref.separator;
    const context = internals.context(key, separator, options.prefix);
    ref.type = context.type;
    key = context.key;

    if (ref.type === 'value') {
        if (context.root) {
            assert(!separator || key[0] !== separator, 'Cannot specify relative path with root prefix');
            ref.ancestor = 'root';
            if (!key) {
                key = null;
            }
        }

        if (separator &&
            separator === key) {

            key = null;
            ref.ancestor = 0;
        }
        else {
            if (ref.ancestor !== undefined) {
                assert(!separator || !key || key[0] !== separator, 'Cannot combine prefix with ancestor option');
            }
            else {
                const [ancestor, slice] = internals.ancestor(key, separator);
                if (slice) {
                    key = key.slice(slice);
                    if (key === '') {
                        key = null;
                    }
                }

                ref.ancestor = ancestor;
            }
        }
    }

    ref.path = separator ? (key === null ? [] : key.split(separator)) : [key];

    return new internals.Ref(ref);
};


exports["in"] = function (key, options = {}) {

    return exports.create(key, { ...options, in: true });
};


exports.isRef = function (ref) {

    return ref ? !!ref[Common.symbols.ref] : false;
};


internals.Ref = class {

    constructor(options) {

        assert(typeof options === 'object', 'Invalid reference construction');
        Common.assertOptions(options, [
            'adjust', 'ancestor', 'in', 'iterables', 'map', 'path', 'render', 'separator', 'type',  // Copied
            'depth', 'key', 'root', 'display'                                                       // Overridden
        ]);

        assert([false, undefined].includes(options.separator) || typeof options.separator === 'string' && options.separator.length === 1, 'Invalid separator');
        assert(!options.adjust || typeof options.adjust === 'function', 'options.adjust must be a function');
        assert(!options.map || Array.isArray(options.map), 'options.map must be an array');
        assert(!options.map || !options.adjust, 'Cannot set both map and adjust options');

        Object.assign(this, internals.defaults, options);

        assert(this.type === 'value' || this.ancestor === undefined, 'Non-value references cannot reference ancestors');

        if (Array.isArray(this.map)) {
            this.map = new Map(this.map);
        }

        this.depth = this.path.length;
        this.key = this.path.length ? this.path.join(this.separator) : null;
        this.root = this.path[0];

        this.updateDisplay();
    }

    resolve(value, state, prefs, local, options = {}) {

        assert(!this.in || options.in, 'Invalid in() reference usage');

        if (this.type === 'global') {
            return this._resolve(prefs.context, state, options);
        }

        if (this.type === 'local') {
            return this._resolve(local, state, options);
        }

        if (!this.ancestor) {
            return this._resolve(value, state, options);
        }

        if (this.ancestor === 'root') {
            return this._resolve(state.ancestors[state.ancestors.length - 1], state, options);
        }

        assert(this.ancestor <= state.ancestors.length, 'Invalid reference exceeds the schema root:', this.display);
        return this._resolve(state.ancestors[this.ancestor - 1], state, options);
    }

    _resolve(target, state, options) {

        let resolved;

        if (this.type === 'value' &&
            state.mainstay.shadow &&
            options.shadow !== false) {

            resolved = state.mainstay.shadow.get(this.absolute(state));
        }

        if (resolved === undefined) {
            resolved = reach(target, this.path, { iterables: this.iterables, functions: true });
        }

        if (this.adjust) {
            resolved = this.adjust(resolved);
        }

        if (this.map) {
            const mapped = this.map.get(resolved);
            if (mapped !== undefined) {
                resolved = mapped;
            }
        }

        if (state.mainstay) {
            state.mainstay.tracer.resolve(state, this, resolved);
        }

        return resolved;
    }

    toString() {

        return this.display;
    }

    absolute(state) {

        return [...state.path.slice(0, -this.ancestor), ...this.path];
    }

    clone() {

        return new internals.Ref(this);
    }

    describe() {

        const ref = { path: this.path };

        if (this.type !== 'value') {
            ref.type = this.type;
        }

        if (this.separator !== '.') {
            ref.separator = this.separator;
        }

        if (this.type === 'value' &&
            this.ancestor !== 1) {

            ref.ancestor = this.ancestor;
        }

        if (this.map) {
            ref.map = [...this.map];
        }

        for (const key of ['adjust', 'iterables', 'render']) {
            if (this[key] !== null &&
                this[key] !== undefined) {

                ref[key] = this[key];
            }
        }

        if (this.in !== false) {
            ref.in = true;
        }

        return { ref };
    }

    updateDisplay() {

        const key = this.key !== null ? this.key : '';
        if (this.type !== 'value') {
            this.display = `ref:${this.type}:${key}`;
            return;
        }

        if (!this.separator) {
            this.display = `ref:${key}`;
            return;
        }

        if (!this.ancestor) {
            this.display = `ref:${this.separator}${key}`;
            return;
        }

        if (this.ancestor === 'root') {
            this.display = `ref:root:${key}`;
            return;
        }

        if (this.ancestor === 1) {
            this.display = `ref:${key || '..'}`;
            return;
        }

        const lead = new Array(this.ancestor + 1).fill(this.separator).join('');
        this.display = `ref:${lead}${key || ''}`;
    }
};


internals.Ref.prototype[Common.symbols.ref] = true;


exports.build = function (desc) {

    desc = Object.assign({}, internals.defaults, desc);
    if (desc.type === 'value' &&
        desc.ancestor === undefined) {

        desc.ancestor = 1;
    }

    return new internals.Ref(desc);
};


internals.context = function (key, separator, prefix = {}) {

    key = key.trim();

    if (prefix) {
        const globalp = prefix.global === undefined ? '$' : prefix.global;
        if (globalp !== separator &&
            key.startsWith(globalp)) {

            return { key: key.slice(globalp.length), type: 'global' };
        }

        const local = prefix.local === undefined ? '#' : prefix.local;
        if (local !== separator &&
            key.startsWith(local)) {

            return { key: key.slice(local.length), type: 'local' };
        }

        const root = prefix.root === undefined ? '/' : prefix.root;
        if (root !== separator &&
            key.startsWith(root)) {

            return { key: key.slice(root.length), type: 'value', root: true };
        }
    }

    return { key, type: 'value' };
};


internals.ancestor = function (key, separator) {

    if (!separator) {
        return [1, 0];              // 'a_b' -> 1 (parent)
    }

    if (key[0] !== separator) {     // 'a.b' -> 1 (parent)
        return [1, 0];
    }

    if (key[1] !== separator) {     // '.a.b' -> 0 (self)
        return [0, 1];
    }

    let i = 2;
    while (key[i] === separator) {
        ++i;
    }

    return [i - 1, i];              // '...a.b.' -> 2 (grandparent)
};


exports.toSibling = 0;

exports.toParent = 1;


exports.Manager = class {

    constructor() {

        this.refs = [];                     // 0: [self refs], 1: [parent refs], 2: [grandparent refs], ...
    }

    register(source, target) {

        if (!source) {
            return;
        }

        target = target === undefined ? exports.toParent : target;

        // Array

        if (Array.isArray(source)) {
            for (const ref of source) {
                this.register(ref, target);
            }

            return;
        }

        // Schema

        if (Common.isSchema(source)) {
            for (const item of source._refs.refs) {
                if (item.ancestor - target >= 0) {
                    this.refs.push({ ancestor: item.ancestor - target, root: item.root });
                }
            }

            return;
        }

        // Reference

        if (exports.isRef(source) &&
            source.type === 'value' &&
            source.ancestor - target >= 0) {

            this.refs.push({ ancestor: source.ancestor - target, root: source.root });
        }

        // Template

        Template = Template || __nccwpck_require__(75706);

        if (Template.isTemplate(source)) {
            this.register(source.refs(), target);
        }
    }

    get length() {

        return this.refs.length;
    }

    clone() {

        const copy = new exports.Manager();
        copy.refs = clone(this.refs);
        return copy;
    }

    reset() {

        this.refs = [];
    }

    roots() {

        return this.refs.filter((ref) => !ref.ancestor).map((ref) => ref.root);
    }
};


/***/ }),

/***/ 29918:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


const Joi = __nccwpck_require__(81154);


const internals = {};


// Preferences

internals.wrap = Joi.string()
    .min(1)
    .max(2)
    .allow(false);


exports.preferences = Joi.object({
    allowUnknown: Joi.boolean(),
    abortEarly: Joi.boolean(),
    artifacts: Joi.boolean(),
    cache: Joi.boolean(),
    context: Joi.object(),
    convert: Joi.boolean(),
    dateFormat: Joi.valid('date', 'iso', 'string', 'time', 'utc'),
    debug: Joi.boolean(),
    errors: {
        escapeHtml: Joi.boolean(),
        label: Joi.valid('path', 'key', false),
        language: [
            Joi.string(),
            Joi.object().ref()
        ],
        render: Joi.boolean(),
        stack: Joi.boolean(),
        wrap: {
            label: internals.wrap,
            array: internals.wrap,
            string: internals.wrap
        }
    },
    externals: Joi.boolean(),
    messages: Joi.object(),
    noDefaults: Joi.boolean(),
    nonEnumerables: Joi.boolean(),
    presence: Joi.valid('required', 'optional', 'forbidden'),
    skipFunctions: Joi.boolean(),
    stripUnknown: Joi.object({
        arrays: Joi.boolean(),
        objects: Joi.boolean()
    })
        .or('arrays', 'objects')
        .allow(true, false),
    warnings: Joi.boolean()
})
    .strict();


// Extensions

internals.nameRx = /^[a-zA-Z0-9]\w*$/;


internals.rule = Joi.object({
    alias: Joi.array().items(Joi.string().pattern(internals.nameRx)).single(),
    args: Joi.array().items(
        Joi.string(),
        Joi.object({
            name: Joi.string().pattern(internals.nameRx).required(),
            ref: Joi.boolean(),
            assert: Joi.alternatives([
                Joi.function(),
                Joi.object().schema()
            ])
                .conditional('ref', { is: true, then: Joi.required() }),
            normalize: Joi.function(),
            message: Joi.string().when('assert', { is: Joi.function(), then: Joi.required() })
        })
    ),
    convert: Joi.boolean(),
    manifest: Joi.boolean(),
    method: Joi.function().allow(false),
    multi: Joi.boolean(),
    validate: Joi.function()
});


exports.extension = Joi.object({
    type: Joi.alternatives([
        Joi.string(),
        Joi.object().regex()
    ])
        .required(),
    args: Joi.function(),
    cast: Joi.object().pattern(internals.nameRx, Joi.object({
        from: Joi.function().maxArity(1).required(),
        to: Joi.function().minArity(1).maxArity(2).required()
    })),
    base: Joi.object().schema()
        .when('type', { is: Joi.object().regex(), then: Joi.forbidden() }),
    coerce: [
        Joi.function().maxArity(3),
        Joi.object({ method: Joi.function().maxArity(3).required(), from: Joi.array().items(Joi.string()).single() })
    ],
    flags: Joi.object().pattern(internals.nameRx, Joi.object({
        setter: Joi.string(),
        default: Joi.any()
    })),
    manifest: {
        build: Joi.function().arity(2)
    },
    messages: [Joi.object(), Joi.string()],
    modifiers: Joi.object().pattern(internals.nameRx, Joi.function().minArity(1).maxArity(2)),
    overrides: Joi.object().pattern(internals.nameRx, Joi.function()),
    prepare: Joi.function().maxArity(3),
    rebuild: Joi.function().arity(1),
    rules: Joi.object().pattern(internals.nameRx, internals.rule),
    terms: Joi.object().pattern(internals.nameRx, Joi.object({
        init: Joi.array().allow(null).required(),
        manifest: Joi.object().pattern(/.+/, [
            Joi.valid('schema', 'single'),
            Joi.object({
                mapped: Joi.object({
                    from: Joi.string().required(),
                    to: Joi.string().required()
                })
                    .required()
            })
        ])
    })),
    validate: Joi.function().maxArity(3)
})
    .strict();


exports.extensions = Joi.array().items(Joi.object(), Joi.function().arity(1)).strict();


// Manifest

internals.desc = {

    buffer: Joi.object({
        buffer: Joi.string()
    }),

    func: Joi.object({
        function: Joi.function().required(),
        options: {
            literal: true
        }
    }),

    override: Joi.object({
        override: true
    }),

    ref: Joi.object({
        ref: Joi.object({
            type: Joi.valid('value', 'global', 'local'),
            path: Joi.array().required(),
            separator: Joi.string().length(1).allow(false),
            ancestor: Joi.number().min(0).integer().allow('root'),
            map: Joi.array().items(Joi.array().length(2)).min(1),
            adjust: Joi.function(),
            iterables: Joi.boolean(),
            in: Joi.boolean(),
            render: Joi.boolean()
        })
            .required()
    }),

    regex: Joi.object({
        regex: Joi.string().min(3)
    }),

    special: Joi.object({
        special: Joi.valid('deep').required()
    }),

    template: Joi.object({
        template: Joi.string().required(),
        options: Joi.object()
    }),

    value: Joi.object({
        value: Joi.alternatives([Joi.object(), Joi.array()]).required()
    })
};


internals.desc.entity = Joi.alternatives([
    Joi.array().items(Joi.link('...')),
    Joi.boolean(),
    Joi.function(),
    Joi.number(),
    Joi.string(),
    internals.desc.buffer,
    internals.desc.func,
    internals.desc.ref,
    internals.desc.regex,
    internals.desc.special,
    internals.desc.template,
    internals.desc.value,
    Joi.link('/')
]);


internals.desc.values = Joi.array()
    .items(
        null,
        Joi.boolean(),
        Joi.function(),
        Joi.number().allow(Infinity, -Infinity),
        Joi.string().allow(''),
        Joi.symbol(),
        internals.desc.buffer,
        internals.desc.func,
        internals.desc.override,
        internals.desc.ref,
        internals.desc.regex,
        internals.desc.template,
        internals.desc.value
    );


internals.desc.messages = Joi.object()
    .pattern(/.+/, [
        Joi.string(),
        internals.desc.template,
        Joi.object().pattern(/.+/, [Joi.string(), internals.desc.template])
    ]);


exports.description = Joi.object({
    type: Joi.string().required(),
    flags: Joi.object({
        cast: Joi.string(),
        default: Joi.any(),
        description: Joi.string(),
        empty: Joi.link('/'),
        failover: internals.desc.entity,
        id: Joi.string(),
        label: Joi.string(),
        only: true,
        presence: ['optional', 'required', 'forbidden'],
        result: ['raw', 'strip'],
        strip: Joi.boolean(),
        unit: Joi.string()
    })
        .unknown(),
    preferences: {
        allowUnknown: Joi.boolean(),
        abortEarly: Joi.boolean(),
        artifacts: Joi.boolean(),
        cache: Joi.boolean(),
        convert: Joi.boolean(),
        dateFormat: ['date', 'iso', 'string', 'time', 'utc'],
        errors: {
            escapeHtml: Joi.boolean(),
            label: ['path', 'key'],
            language: [
                Joi.string(),
                internals.desc.ref
            ],
            wrap: {
                label: internals.wrap,
                array: internals.wrap
            }
        },
        externals: Joi.boolean(),
        messages: internals.desc.messages,
        noDefaults: Joi.boolean(),
        nonEnumerables: Joi.boolean(),
        presence: ['required', 'optional', 'forbidden'],
        skipFunctions: Joi.boolean(),
        stripUnknown: Joi.object({
            arrays: Joi.boolean(),
            objects: Joi.boolean()
        })
            .or('arrays', 'objects')
            .allow(true, false),
        warnings: Joi.boolean()
    },
    allow: internals.desc.values,
    invalid: internals.desc.values,
    rules: Joi.array().min(1).items({
        name: Joi.string().required(),
        args: Joi.object().min(1),
        keep: Joi.boolean(),
        message: [
            Joi.string(),
            internals.desc.messages
        ],
        warn: Joi.boolean()
    }),

    // Terms

    keys: Joi.object().pattern(/.*/, Joi.link('/')),
    link: internals.desc.ref
})
    .pattern(/^[a-z]\w*$/, Joi.any());


/***/ }),

/***/ 86139:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


const { clone, reach } = __nccwpck_require__(91884);

const Common = __nccwpck_require__(84205);


const internals = {
    value: Symbol('value')
};


module.exports = internals.State = class {

    constructor(path, ancestors, state) {

        this.path = path;
        this.ancestors = ancestors;                 // [parent, ..., root]

        this.mainstay = state.mainstay;
        this.schemas = state.schemas;               // [current, ..., root]
        this.debug = null;
    }

    localize(path, ancestors = null, schema = null) {

        const state = new internals.State(path, ancestors, this);

        if (schema &&
            state.schemas) {

            state.schemas = [internals.schemas(schema), ...state.schemas];
        }

        return state;
    }

    nest(schema, debug) {

        const state = new internals.State(this.path, this.ancestors, this);
        state.schemas = state.schemas && [internals.schemas(schema), ...state.schemas];
        state.debug = debug;
        return state;
    }

    shadow(value, reason) {

        this.mainstay.shadow = this.mainstay.shadow || new internals.Shadow();
        this.mainstay.shadow.set(this.path, value, reason);
    }

    snapshot() {

        if (this.mainstay.shadow) {
            this._snapshot = clone(this.mainstay.shadow.node(this.path));
        }

        this.mainstay.snapshot();
    }

    restore() {

        if (this.mainstay.shadow) {
            this.mainstay.shadow.override(this.path, this._snapshot);
            this._snapshot = undefined;
        }

        this.mainstay.restore();
    }

    commit() {

        if (this.mainstay.shadow) {
            this.mainstay.shadow.override(this.path, this._snapshot);
            this._snapshot = undefined;
        }

        this.mainstay.commit();
    }
};


internals.schemas = function (schema) {

    if (Common.isSchema(schema)) {
        return { schema };
    }

    return schema;
};


internals.Shadow = class {

    constructor() {

        this._values = null;
    }

    set(path, value, reason) {

        if (!path.length) {                                     // No need to store root value
            return;
        }

        if (reason === 'strip' &&
            typeof path[path.length - 1] === 'number') {        // Cannot store stripped array values (due to shift)

            return;
        }

        this._values = this._values || new Map();

        let node = this._values;
        for (let i = 0; i < path.length; ++i) {
            const segment = path[i];
            let next = node.get(segment);
            if (!next) {
                next = new Map();
                node.set(segment, next);
            }

            node = next;
        }

        node[internals.value] = value;
    }

    get(path) {

        const node = this.node(path);
        if (node) {
            return node[internals.value];
        }
    }

    node(path) {

        if (!this._values) {
            return;
        }

        return reach(this._values, path, { iterables: true });
    }

    override(path, node) {

        if (!this._values) {
            return;
        }

        const parents = path.slice(0, -1);
        const own = path[path.length - 1];
        const parent = reach(this._values, parents, { iterables: true });

        if (node) {
            parent.set(own, node);
            return;
        }

        if (parent) {
            parent.delete(own);
        }
    }
};


/***/ }),

/***/ 75706:
/***/ ((module, exports, __nccwpck_require__) => {

"use strict";


const { assert, clone, escapeHtml } = __nccwpck_require__(91884);
const Formula = __nccwpck_require__(41041);

const Common = __nccwpck_require__(84205);
const Errors = __nccwpck_require__(11543);
const Ref = __nccwpck_require__(51579);


const internals = {
    symbol: Symbol('template'),

    opens: new Array(1000).join('\u0000'),
    closes: new Array(1000).join('\u0001'),

    dateFormat: {
        date: Date.prototype.toDateString,
        iso: Date.prototype.toISOString,
        string: Date.prototype.toString,
        time: Date.prototype.toTimeString,
        utc: Date.prototype.toUTCString
    }
};


module.exports = exports = internals.Template = class {

    constructor(source, options) {

        assert(typeof source === 'string', 'Template source must be a string');
        assert(!source.includes('\u0000') && !source.includes('\u0001'), 'Template source cannot contain reserved control characters');

        this.source = source;
        this.rendered = source;

        this._template = null;

        if (options) {
            const { functions, ...opts } = options;
            this._settings = Object.keys(opts).length ? clone(opts) : undefined;
            this._functions = functions;
            if (this._functions) {
                assert(Object.keys(this._functions).every((key) => typeof key === 'string'), 'Functions keys must be strings');
                assert(Object.values(this._functions).every((key) => typeof key === 'function'), 'Functions values must be functions');
            }
        }
        else {
            this._settings = undefined;
            this._functions = undefined;
        }

        this._parse();
    }

    _parse() {

        // 'text {raw} {{ref}} \\{{ignore}} {{ignore\\}} {{ignore {{ignore}'

        if (!this.source.includes('{')) {
            return;
        }

        // Encode escaped \\{{{{{

        const encoded = internals.encode(this.source);

        // Split on first { in each set

        const parts = internals.split(encoded);

        // Process parts

        let refs = false;
        const processed = [];
        const head = parts.shift();
        if (head) {
            processed.push(head);
        }

        for (const part of parts) {
            const raw = part[0] !== '{';
            const ender = raw ? '}' : '}}';
            const end = part.indexOf(ender);
            if (end === -1 ||                               // Ignore non-matching closing
                part[1] === '{') {                          // Ignore more than two {

                processed.push(`{${internals.decode(part)}`);
                continue;
            }

            let variable = part.slice(raw ? 0 : 1, end);
            const wrapped = variable[0] === ':';
            if (wrapped) {
                variable = variable.slice(1);
            }

            const dynamic = this._ref(internals.decode(variable), { raw, wrapped });
            processed.push(dynamic);
            if (typeof dynamic !== 'string') {
                refs = true;
            }

            const rest = part.slice(end + ender.length);
            if (rest) {
                processed.push(internals.decode(rest));
            }
        }

        if (!refs) {
            this.rendered = processed.join('');
            return;
        }

        this._template = processed;
    }

    static date(date, prefs) {

        return internals.dateFormat[prefs.dateFormat].call(date);
    }

    describe(options = {}) {

        if (!this._settings &&
            options.compact) {

            return this.source;
        }

        const desc = { template: this.source };
        if (this._settings) {
            desc.options = this._settings;
        }

        if (this._functions) {
            desc.functions = this._functions;
        }

        return desc;
    }

    static build(desc) {

        return new internals.Template(desc.template, desc.options || desc.functions ? { ...desc.options, functions: desc.functions } : undefined);
    }

    isDynamic() {

        return !!this._template;
    }

    static isTemplate(template) {

        return template ? !!template[Common.symbols.template] : false;
    }

    refs() {

        if (!this._template) {
            return;
        }

        const refs = [];
        for (const part of this._template) {
            if (typeof part !== 'string') {
                refs.push(...part.refs);
            }
        }

        return refs;
    }

    resolve(value, state, prefs, local) {

        if (this._template &&
            this._template.length === 1) {

            return this._part(this._template[0], /* context -> [*/ value, state, prefs, local, {} /*] */);
        }

        return this.render(value, state, prefs, local);
    }

    _part(part, ...args) {

        if (part.ref) {
            return part.ref.resolve(...args);
        }

        return part.formula.evaluate(args);
    }

    render(value, state, prefs, local, options = {}) {

        if (!this.isDynamic()) {
            return this.rendered;
        }

        const parts = [];
        for (const part of this._template) {
            if (typeof part === 'string') {
                parts.push(part);
            }
            else {
                const rendered = this._part(part, /* context -> [*/ value, state, prefs, local, options /*] */);
                const string = internals.stringify(rendered, value, state, prefs, local, options);
                if (string !== undefined) {
                    const result = part.raw || (options.errors && options.errors.escapeHtml) === false ? string : escapeHtml(string);
                    parts.push(internals.wrap(result, part.wrapped && prefs.errors.wrap.label));
                }
            }
        }

        return parts.join('');
    }

    _ref(content, { raw, wrapped }) {

        const refs = [];
        const reference = (variable) => {

            const ref = Ref.create(variable, this._settings);
            refs.push(ref);
            return (context) => {

                const resolved = ref.resolve(...context);
                return resolved !== undefined ? resolved : null;
            };
        };

        try {
            const functions = this._functions ? { ...internals.functions, ...this._functions } : internals.functions;
            var formula = new Formula.Parser(content, { reference, functions, constants: internals.constants });
        }
        catch (err) {
            err.message = `Invalid template variable "${content}" fails due to: ${err.message}`;
            throw err;
        }

        if (formula.single) {
            if (formula.single.type === 'reference') {
                const ref = refs[0];
                return { ref, raw, refs, wrapped: wrapped || ref.type === 'local' && ref.key === 'label' };
            }

            return internals.stringify(formula.single.value);
        }

        return { formula, raw, refs };
    }

    toString() {

        return this.source;
    }
};


internals.Template.prototype[Common.symbols.template] = true;
internals.Template.prototype.isImmutable = true;                // Prevents Hoek from deep cloning schema objects


internals.encode = function (string) {

    return string
        .replace(/\\(\{+)/g, ($0, $1) => {

            return internals.opens.slice(0, $1.length);
        })
        .replace(/\\(\}+)/g, ($0, $1) => {

            return internals.closes.slice(0, $1.length);
        });
};


internals.decode = function (string) {

    return string
        .replace(/\u0000/g, '{')
        .replace(/\u0001/g, '}');
};


internals.split = function (string) {

    const parts = [];
    let current = '';

    for (let i = 0; i < string.length; ++i) {
        const char = string[i];

        if (char === '{') {
            let next = '';
            while (i + 1 < string.length &&
                string[i + 1] === '{') {

                next += '{';
                ++i;
            }

            parts.push(current);
            current = next;
        }
        else {
            current += char;
        }
    }

    parts.push(current);
    return parts;
};


internals.wrap = function (value, ends) {

    if (!ends) {
        return value;
    }

    if (ends.length === 1) {
        return `${ends}${value}${ends}`;
    }

    return `${ends[0]}${value}${ends[1]}`;
};


internals.stringify = function (value, original, state, prefs, local, options = {}) {

    const type = typeof value;
    const wrap = prefs && prefs.errors && prefs.errors.wrap || {};

    let skipWrap = false;
    if (Ref.isRef(value) &&
        value.render) {

        skipWrap = value.in;
        value = value.resolve(original, state, prefs, local, { in: value.in, ...options });
    }

    if (value === null) {
        return 'null';
    }

    if (type === 'string') {
        return internals.wrap(value, options.arrayItems && wrap.string);
    }

    if (type === 'number' ||
        type === 'function' ||
        type === 'symbol') {

        return value.toString();
    }

    if (type !== 'object') {
        return JSON.stringify(value);
    }

    if (value instanceof Date) {
        return internals.Template.date(value, prefs);
    }

    if (value instanceof Map) {
        const pairs = [];
        for (const [key, sym] of value.entries()) {
            pairs.push(`${key.toString()} -> ${sym.toString()}`);
        }

        value = pairs;
    }

    if (!Array.isArray(value)) {
        return value.toString();
    }

    const values = [];
    for (const item of value) {
        values.push(internals.stringify(item, original, state, prefs, local, { arrayItems: true, ...options }));
    }

    return internals.wrap(values.join(', '), !skipWrap && wrap.array);
};


internals.constants = {

    true: true,
    false: false,
    null: null,

    second: 1000,
    minute: 60 * 1000,
    hour: 60 * 60 * 1000,
    day: 24 * 60 * 60 * 1000
};


internals.functions = {

    if(condition, then, otherwise) {

        return condition ? then : otherwise;
    },

    length(item) {

        if (typeof item === 'string') {
            return item.length;
        }

        if (!item || typeof item !== 'object') {
            return null;
        }

        if (Array.isArray(item)) {
            return item.length;
        }

        return Object.keys(item).length;
    },

    msg(code) {

        const [value, state, prefs, local, options] = this;
        const messages = options.messages;
        if (!messages) {
            return '';
        }

        const template = Errors.template(value, messages[0], code, state, prefs) || Errors.template(value, messages[1], code, state, prefs);
        if (!template) {
            return '';
        }

        return template.render(value, state, prefs, local, options);
    },

    number(value) {

        if (typeof value === 'number') {
            return value;
        }

        if (typeof value === 'string') {
            return parseFloat(value);
        }

        if (typeof value === 'boolean') {
            return value ? 1 : 0;
        }

        if (value instanceof Date) {
            return value.getTime();
        }

        return null;
    }
};


/***/ }),

/***/ 23327:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


const { deepEqual } = __nccwpck_require__(91884);
const Pinpoint = __nccwpck_require__(16422);

const Errors = __nccwpck_require__(11543);


const internals = {
    codes: {
        error: 1,
        pass: 2,
        full: 3
    },
    labels: {
        0: 'never used',
        1: 'always error',
        2: 'always pass'
    }
};


exports.setup = function (root) {

    const trace = function () {

        root._tracer = root._tracer || new internals.Tracer();
        return root._tracer;
    };

    root.trace = trace;
    root[Symbol.for('@hapi/lab/coverage/initialize')] = trace;

    root.untrace = () => {

        root._tracer = null;
    };
};


exports.location = function (schema) {

    return schema.$_setFlag('_tracerLocation', Pinpoint.location(2));                       // base.tracer(), caller
};


internals.Tracer = class {

    constructor() {

        this.name = 'Joi';
        this._schemas = new Map();
    }

    _register(schema) {

        const existing = this._schemas.get(schema);
        if (existing) {
            return existing.store;
        }

        const store = new internals.Store(schema);
        const { filename, line } = schema._flags._tracerLocation || Pinpoint.location(5);   // internals.tracer(), internals.entry(), exports.entry(), validate(), caller
        this._schemas.set(schema, { filename, line, store });
        return store;
    }

    _combine(merged, sources) {

        for (const { store } of this._schemas.values()) {
            store._combine(merged, sources);
        }
    }

    report(file) {

        const coverage = [];

        // Process each registered schema

        for (const { filename, line, store } of this._schemas.values()) {
            if (file &&
                file !== filename) {

                continue;
            }

            // Process sub schemas of the registered root

            const missing = [];
            const skipped = [];

            for (const [schema, log] of store._sources.entries()) {

                // Check if sub schema parent skipped

                if (internals.sub(log.paths, skipped)) {
                    continue;
                }

                // Check if sub schema reached

                if (!log.entry) {
                    missing.push({
                        status: 'never reached',
                        paths: [...log.paths]
                    });

                    skipped.push(...log.paths);
                    continue;
                }

                // Check values

                for (const type of ['valid', 'invalid']) {
                    const set = schema[`_${type}s`];
                    if (!set) {
                        continue;
                    }

                    const values = new Set(set._values);
                    const refs = new Set(set._refs);
                    for (const { value, ref } of log[type]) {
                        values.delete(value);
                        refs.delete(ref);
                    }

                    if (values.size ||
                        refs.size) {

                        missing.push({
                            status: [...values, ...[...refs].map((ref) => ref.display)],
                            rule: `${type}s`
                        });
                    }
                }

                // Check rules status

                const rules = schema._rules.map((rule) => rule.name);
                for (const type of ['default', 'failover']) {
                    if (schema._flags[type] !== undefined) {
                        rules.push(type);
                    }
                }

                for (const name of rules) {
                    const status = internals.labels[log.rule[name] || 0];
                    if (status) {
                        const report = { rule: name, status };
                        if (log.paths.size) {
                            report.paths = [...log.paths];
                        }

                        missing.push(report);
                    }
                }
            }

            if (missing.length) {
                coverage.push({
                    filename,
                    line,
                    missing,
                    severity: 'error',
                    message: `Schema missing tests for ${missing.map(internals.message).join(', ')}`
                });
            }
        }

        return coverage.length ? coverage : null;
    }
};


internals.Store = class {

    constructor(schema) {

        this.active = true;
        this._sources = new Map();          // schema -> { paths, entry, rule, valid, invalid }
        this._combos = new Map();           // merged -> [sources]
        this._scan(schema);
    }

    debug(state, source, name, result) {

        state.mainstay.debug && state.mainstay.debug.push({ type: source, name, result, path: state.path });
    }

    entry(schema, state) {

        internals.debug(state, { type: 'entry' });

        this._record(schema, (log) => {

            log.entry = true;
        });
    }

    filter(schema, state, source, value) {

        internals.debug(state, { type: source, ...value });

        this._record(schema, (log) => {

            log[source].add(value);
        });
    }

    log(schema, state, source, name, result) {

        internals.debug(state, { type: source, name, result: result === 'full' ? 'pass' : result });

        this._record(schema, (log) => {

            log[source][name] = log[source][name] || 0;
            log[source][name] |= internals.codes[result];
        });
    }

    resolve(state, ref, to) {

        if (!state.mainstay.debug) {
            return;
        }

        const log = { type: 'resolve', ref: ref.display, to, path: state.path };
        state.mainstay.debug.push(log);
    }

    value(state, by, from, to, name) {

        if (!state.mainstay.debug ||
            deepEqual(from, to)) {

            return;
        }

        const log = { type: 'value', by, from, to, path: state.path };
        if (name) {
            log.name = name;
        }

        state.mainstay.debug.push(log);
    }

    _record(schema, each) {

        const log = this._sources.get(schema);
        if (log) {
            each(log);
            return;
        }

        const sources = this._combos.get(schema);
        for (const source of sources) {
            this._record(source, each);
        }
    }

    _scan(schema, _path) {

        const path = _path || [];

        let log = this._sources.get(schema);
        if (!log) {
            log = {
                paths: new Set(),
                entry: false,
                rule: {},
                valid: new Set(),
                invalid: new Set()
            };

            this._sources.set(schema, log);
        }

        if (path.length) {
            log.paths.add(path);
        }

        const each = (sub, source) => {

            const subId = internals.id(sub, source);
            this._scan(sub, path.concat(subId));
        };

        schema.$_modify({ each, ref: false });
    }

    _combine(merged, sources) {

        this._combos.set(merged, sources);
    }
};


internals.message = function (item) {

    const path = item.paths ? Errors.path(item.paths[0]) + (item.rule ? ':' : '') : '';
    return `${path}${item.rule || ''} (${item.status})`;
};


internals.id = function (schema, { source, name, path, key }) {

    if (schema._flags.id) {
        return schema._flags.id;
    }

    if (key) {
        return key;
    }

    name = `@${name}`;

    if (source === 'terms') {
        return [name, path[Math.min(path.length - 1, 1)]];
    }

    return name;
};


internals.sub = function (paths, skipped) {

    for (const path of paths) {
        for (const skip of skipped) {
            if (deepEqual(path.slice(0, skip.length), skip)) {
                return true;
            }
        }
    }

    return false;
};


internals.debug = function (state, event) {

    if (state.mainstay.debug) {
        event.path = state.debug ? [...state.path, state.debug] : state.path;
        state.mainstay.debug.push(event);
    }
};


/***/ }),

/***/ 52346:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


const { assert, merge } = __nccwpck_require__(91884);

const Any = __nccwpck_require__(49046);
const Common = __nccwpck_require__(84205);
const Compile = __nccwpck_require__(14743);
const Errors = __nccwpck_require__(11543);
const Ref = __nccwpck_require__(51579);


const internals = {};


module.exports = Any.extend({

    type: 'alternatives',

    flags: {

        match: { default: 'any' }                 // 'any', 'one', 'all'
    },

    terms: {

        matches: { init: [], register: Ref.toSibling }
    },

    args(schema, ...schemas) {

        if (schemas.length === 1) {
            if (Array.isArray(schemas[0])) {
                return schema.try(...schemas[0]);
            }
        }

        return schema.try(...schemas);
    },

    validate(value, helpers) {

        const { schema, error, state, prefs } = helpers;

        // Match all or one

        if (schema._flags.match) {
            const matched = [];
            const failed = [];

            for (let i = 0; i < schema.$_terms.matches.length; ++i) {
                const item = schema.$_terms.matches[i];
                const localState = state.nest(item.schema, `match.${i}`);
                localState.snapshot();

                const result = item.schema.$_validate(value, localState, prefs);
                if (!result.errors) {
                    matched.push(result.value);
                    localState.commit();
                }
                else {
                    failed.push(result.errors);
                    localState.restore();
                }
            }

            if (matched.length === 0) {
                const context = {
                    details: failed.map((f) => Errors.details(f, { override: false }))
                };

                return { errors: error('alternatives.any', context) };
            }

            // Match one

            if (schema._flags.match === 'one') {
                return matched.length === 1 ? { value: matched[0] } : { errors: error('alternatives.one') };
            }

            // Match all

            if (matched.length !== schema.$_terms.matches.length) {
                const context = {
                    details: failed.map((f) => Errors.details(f, { override: false }))
                };

                return { errors: error('alternatives.all', context) };
            }

            const isAnyObj = (alternative) => {

                return alternative.$_terms.matches.some((v) => {

                    return v.schema.type === 'object' ||
                        (v.schema.type === 'alternatives' && isAnyObj(v.schema));
                });
            };

            return isAnyObj(schema) ? { value: matched.reduce((acc, v) => merge(acc, v, { mergeArrays: false })) } : { value: matched[matched.length - 1] };
        }

        // Match any

        const errors = [];
        for (let i = 0; i < schema.$_terms.matches.length; ++i) {
            const item = schema.$_terms.matches[i];

            // Try

            if (item.schema) {
                const localState = state.nest(item.schema, `match.${i}`);
                localState.snapshot();

                const result = item.schema.$_validate(value, localState, prefs);
                if (!result.errors) {
                    localState.commit();
                    return result;
                }

                localState.restore();
                errors.push({ schema: item.schema, reports: result.errors });
                continue;
            }

            // Conditional

            const input = item.ref ? item.ref.resolve(value, state, prefs) : value;
            const tests = item.is ? [item] : item.switch;

            for (let j = 0; j < tests.length; ++j) {
                const test = tests[j];
                const { is, then, otherwise } = test;

                const id = `match.${i}${item.switch ? '.' + j : ''}`;
                if (!is.$_match(input, state.nest(is, `${id}.is`), prefs)) {
                    if (otherwise) {
                        return otherwise.$_validate(value, state.nest(otherwise, `${id}.otherwise`), prefs);
                    }
                }
                else if (then) {
                    return then.$_validate(value, state.nest(then, `${id}.then`), prefs);
                }
            }
        }

        return internals.errors(errors, helpers);
    },

    rules: {

        conditional: {
            method(condition, options) {

                assert(!this._flags._endedSwitch, 'Unreachable condition');
                assert(!this._flags.match, 'Cannot combine match mode', this._flags.match, 'with conditional rule');
                assert(options.break === undefined, 'Cannot use break option with alternatives conditional');

                const obj = this.clone();

                const match = Compile.when(obj, condition, options);
                const conditions = match.is ? [match] : match.switch;
                for (const item of conditions) {
                    if (item.then &&
                        item.otherwise) {

                        obj.$_setFlag('_endedSwitch', true, { clone: false });
                        break;
                    }
                }

                obj.$_terms.matches.push(match);
                return obj.$_mutateRebuild();
            }
        },

        match: {
            method(mode) {

                assert(['any', 'one', 'all'].includes(mode), 'Invalid alternatives match mode', mode);

                if (mode !== 'any') {
                    for (const match of this.$_terms.matches) {
                        assert(match.schema, 'Cannot combine match mode', mode, 'with conditional rules');
                    }
                }

                return this.$_setFlag('match', mode);
            }
        },

        try: {
            method(...schemas) {

                assert(schemas.length, 'Missing alternative schemas');
                Common.verifyFlat(schemas, 'try');

                assert(!this._flags._endedSwitch, 'Unreachable condition');

                const obj = this.clone();
                for (const schema of schemas) {
                    obj.$_terms.matches.push({ schema: obj.$_compile(schema) });
                }

                return obj.$_mutateRebuild();
            }
        }
    },

    overrides: {

        label(name) {

            const obj = this.$_parent('label', name);
            const each = (item, source) => {

                return source.path[0] !== 'is' && typeof item._flags.label !== 'string' ? item.label(name) : undefined;
            };

            return obj.$_modify({ each, ref: false });
        },

        isAsync() {

            if (this.$_terms.externals?.length) {
                return true;
            }

            for (const match of this.$_terms.matches) {

                if (match.schema?.isAsync()) {
                    return true;
                }

                if (match.then?.isAsync()) {
                    return true;
                }

                if (match.otherwise?.isAsync()) {
                    return true;
                }
            }

            return false;
        }
    },

    rebuild(schema) {

        // Flag when an alternative type is an array

        const each = (item) => {

            if (Common.isSchema(item) &&
                item.type === 'array') {

                schema.$_setFlag('_arrayItems', true, { clone: false });
            }
        };

        schema.$_modify({ each });
    },

    manifest: {

        build(obj, desc) {

            if (desc.matches) {
                for (const match of desc.matches) {
                    const { schema, ref, is, not, then, otherwise } = match;
                    if (schema) {
                        obj = obj.try(schema);
                    }
                    else if (ref) {
                        obj = obj.conditional(ref, { is, then, not, otherwise, switch: match.switch });
                    }
                    else {
                        obj = obj.conditional(is, { then, otherwise });
                    }
                }
            }

            return obj;
        }
    },

    messages: {
        'alternatives.all': '{{#label}} does not match all of the required types',
        'alternatives.any': '{{#label}} does not match any of the allowed types',
        'alternatives.match': '{{#label}} does not match any of the allowed types',
        'alternatives.one': '{{#label}} matches more than one allowed type',
        'alternatives.types': '{{#label}} must be one of {{#types}}'
    }
});


// Helpers

internals.errors = function (failures, { error, state }) {

    // Nothing matched due to type criteria rules

    if (!failures.length) {
        return { errors: error('alternatives.any') };
    }

    // Single error

    if (failures.length === 1) {
        return { errors: failures[0].reports };
    }

    // Analyze reasons

    const valids = new Set();
    const complex = [];

    for (const { reports, schema } of failures) {

        // Multiple errors (!abortEarly)

        if (reports.length > 1) {
            return internals.unmatched(failures, error);
        }

        // Custom error

        const report = reports[0];
        if (report instanceof Errors.Report === false) {
            return internals.unmatched(failures, error);
        }

        // Internal object or array error

        if (report.state.path.length !== state.path.length) {
            complex.push({ type: schema.type, report });
            continue;
        }

        // Valids

        if (report.code === 'any.only') {
            for (const valid of report.local.valids) {
                valids.add(valid);
            }

            continue;
        }

        // Base type

        const [type, code] = report.code.split('.');
        if (code !== 'base') {
            complex.push({ type: schema.type, report });
        }
        else if (report.code === 'object.base') {
            valids.add(report.local.type);
        }
        else {
            valids.add(type);
        }
    }

    // All errors are base types or valids

    if (!complex.length) {
        return { errors: error('alternatives.types', { types: [...valids] }) };
    }

    // Single complex error

    if (complex.length === 1) {
        return { errors: complex[0].report };
    }

    return internals.unmatched(failures, error);
};


internals.unmatched = function (failures, error) {

    const errors = [];
    for (const failure of failures) {
        errors.push(...failure.reports);
    }

    return { errors: error('alternatives.match', Errors.details(errors, { override: false })) };
};


/***/ }),

/***/ 49046:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


const { assert } = __nccwpck_require__(91884);

const Base = __nccwpck_require__(87041);
const Common = __nccwpck_require__(84205);
const Messages = __nccwpck_require__(31088);


const internals = {};


module.exports = Base.extend({

    type: 'any',

    flags: {

        only: { default: false }
    },

    terms: {

        alterations: { init: null },
        examples: { init: null },
        externals: { init: null },
        metas: { init: [] },
        notes: { init: [] },
        shared: { init: null },
        tags: { init: [] },
        whens: { init: null }
    },

    rules: {

        custom: {
            method(method, description) {

                assert(typeof method === 'function', 'Method must be a function');
                assert(description === undefined || description && typeof description === 'string', 'Description must be a non-empty string');

                return this.$_addRule({ name: 'custom', args: { method, description } });
            },
            validate(value, helpers, { method }) {

                try {
                    return method(value, helpers);
                }
                catch (err) {
                    return helpers.error('any.custom', { error: err });
                }
            },
            args: ['method', 'description'],
            multi: true
        },

        messages: {
            method(messages) {

                return this.prefs({ messages });
            }
        },

        shared: {
            method(schema) {

                assert(Common.isSchema(schema) && schema._flags.id, 'Schema must be a schema with an id');

                const obj = this.clone();
                obj.$_terms.shared = obj.$_terms.shared || [];
                obj.$_terms.shared.push(schema);
                obj.$_mutateRegister(schema);
                return obj;
            }
        },

        warning: {
            method(code, local) {

                assert(code && typeof code === 'string', 'Invalid warning code');

                return this.$_addRule({ name: 'warning', args: { code, local }, warn: true });
            },
            validate(value, helpers, { code, local }) {

                return helpers.error(code, local);
            },
            args: ['code', 'local'],
            multi: true
        }
    },

    modifiers: {

        keep(rule, enabled = true) {

            rule.keep = enabled;
        },

        message(rule, message) {

            rule.message = Messages.compile(message);
        },

        warn(rule, enabled = true) {

            rule.warn = enabled;
        }
    },

    manifest: {

        build(obj, desc) {

            for (const key in desc) {
                const values = desc[key];

                if (['examples', 'externals', 'metas', 'notes', 'tags'].includes(key)) {
                    for (const value of values) {
                        obj = obj[key.slice(0, -1)](value);
                    }

                    continue;
                }

                if (key === 'alterations') {
                    const alter = {};
                    for (const { target, adjuster } of values) {
                        alter[target] = adjuster;
                    }

                    obj = obj.alter(alter);
                    continue;
                }

                if (key === 'whens') {
                    for (const value of values) {
                        const { ref, is, not, then, otherwise, concat } = value;
                        if (concat) {
                            obj = obj.concat(concat);
                        }
                        else if (ref) {
                            obj = obj.when(ref, { is, not, then, otherwise, switch: value.switch, break: value.break });
                        }
                        else {
                            obj = obj.when(is, { then, otherwise, break: value.break });
                        }
                    }

                    continue;
                }

                if (key === 'shared') {
                    for (const value of values) {
                        obj = obj.shared(value);
                    }
                }
            }

            return obj;
        }
    },

    messages: {
        'any.custom': '{{#label}} failed custom validation because {{#error.message}}',
        'any.default': '{{#label}} threw an error when running default method',
        'any.failover': '{{#label}} threw an error when running failover method',
        'any.invalid': '{{#label}} contains an invalid value',
        'any.only': '{{#label}} must be {if(#valids.length == 1, "", "one of ")}{{#valids}}',
        'any.ref': '{{#label}} {{#arg}} references {{:#ref}} which {{#reason}}',
        'any.required': '{{#label}} is required',
        'any.unknown': '{{#label}} is not allowed'
    }
});


/***/ }),

/***/ 62801:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


const { assert, deepEqual, reach } = __nccwpck_require__(91884);

const Any = __nccwpck_require__(49046);
const Common = __nccwpck_require__(84205);
const Compile = __nccwpck_require__(14743);


const internals = {};


module.exports = Any.extend({

    type: 'array',

    flags: {

        single: { default: false },
        sparse: { default: false }
    },

    terms: {

        items: { init: [], manifest: 'schema' },
        ordered: { init: [], manifest: 'schema' },

        _exclusions: { init: [] },
        _inclusions: { init: [] },
        _requireds: { init: [] }
    },

    coerce: {
        from: 'object',
        method(value, { schema, state, prefs }) {

            if (!Array.isArray(value)) {
                return;
            }

            const sort = schema.$_getRule('sort');
            if (!sort) {
                return;
            }

            return internals.sort(schema, value, sort.args.options, state, prefs);
        }
    },

    validate(value, { schema, error }) {

        if (!Array.isArray(value)) {
            if (schema._flags.single) {
                const single = [value];
                single[Common.symbols.arraySingle] = true;
                return { value: single };
            }

            return { errors: error('array.base') };
        }

        if (!schema.$_getRule('items') &&
            !schema.$_terms.externals) {

            return;
        }

        return { value: value.slice() };        // Clone the array so that we don't modify the original
    },

    rules: {

        has: {
            method(schema) {

                schema = this.$_compile(schema, { appendPath: true });
                const obj = this.$_addRule({ name: 'has', args: { schema } });
                obj.$_mutateRegister(schema);
                return obj;
            },
            validate(value, { state, prefs, error }, { schema: has }) {

                const ancestors = [value, ...state.ancestors];
                for (let i = 0; i < value.length; ++i) {
                    const localState = state.localize([...state.path, i], ancestors, has);
                    if (has.$_match(value[i], localState, prefs)) {
                        return value;
                    }
                }

                const patternLabel = has._flags.label;
                if (patternLabel) {
                    return error('array.hasKnown', { patternLabel });
                }

                return error('array.hasUnknown', null);
            },
            multi: true
        },

        items: {
            method(...schemas) {

                Common.verifyFlat(schemas, 'items');

                const obj = this.$_addRule('items');

                for (let i = 0; i < schemas.length; ++i) {
                    const type = Common.tryWithPath(() => this.$_compile(schemas[i]), i, { append: true });
                    obj.$_terms.items.push(type);
                }

                return obj.$_mutateRebuild();
            },
            validate(value, { schema, error, state, prefs, errorsArray }) {

                const requireds = schema.$_terms._requireds.slice();
                const ordereds = schema.$_terms.ordered.slice();
                const inclusions = [...schema.$_terms._inclusions, ...requireds];

                const wasArray = !value[Common.symbols.arraySingle];
                delete value[Common.symbols.arraySingle];

                const errors = errorsArray();

                let il = value.length;
                for (let i = 0; i < il; ++i) {
                    const item = value[i];

                    let errored = false;
                    let isValid = false;

                    const key = wasArray ? i : new Number(i);       // eslint-disable-line no-new-wrappers
                    const path = [...state.path, key];

                    // Sparse

                    if (!schema._flags.sparse &&
                        item === undefined) {

                        errors.push(error('array.sparse', { key, path, pos: i, value: undefined }, state.localize(path)));
                        if (prefs.abortEarly) {
                            return errors;
                        }

                        ordereds.shift();
                        continue;
                    }

                    // Exclusions

                    const ancestors = [value, ...state.ancestors];

                    for (const exclusion of schema.$_terms._exclusions) {
                        if (!exclusion.$_match(item, state.localize(path, ancestors, exclusion), prefs, { presence: 'ignore' })) {
                            continue;
                        }

                        errors.push(error('array.excludes', { pos: i, value: item }, state.localize(path)));
                        if (prefs.abortEarly) {
                            return errors;
                        }

                        errored = true;
                        ordereds.shift();
                        break;
                    }

                    if (errored) {
                        continue;
                    }

                    // Ordered

                    if (schema.$_terms.ordered.length) {
                        if (ordereds.length) {
                            const ordered = ordereds.shift();
                            const res = ordered.$_validate(item, state.localize(path, ancestors, ordered), prefs);
                            if (!res.errors) {
                                if (ordered._flags.result === 'strip') {
                                    internals.fastSplice(value, i);
                                    --i;
                                    --il;
                                }
                                else if (!schema._flags.sparse && res.value === undefined) {
                                    errors.push(error('array.sparse', { key, path, pos: i, value: undefined }, state.localize(path)));
                                    if (prefs.abortEarly) {
                                        return errors;
                                    }

                                    continue;
                                }
                                else {
                                    value[i] = res.value;
                                }
                            }
                            else {
                                errors.push(...res.errors);
                                if (prefs.abortEarly) {
                                    return errors;
                                }
                            }

                            continue;
                        }
                        else if (!schema.$_terms.items.length) {
                            errors.push(error('array.orderedLength', { pos: i, limit: schema.$_terms.ordered.length }));
                            if (prefs.abortEarly) {
                                return errors;
                            }

                            break;      // No reason to continue since there are no other rules to validate other than array.orderedLength
                        }
                    }

                    // Requireds

                    const requiredChecks = [];
                    let jl = requireds.length;
                    for (let j = 0; j < jl; ++j) {
                        const localState = state.localize(path, ancestors, requireds[j]);
                        localState.snapshot();

                        const res = requireds[j].$_validate(item, localState, prefs);
                        requiredChecks[j] = res;

                        if (!res.errors) {
                            localState.commit();
                            value[i] = res.value;
                            isValid = true;
                            internals.fastSplice(requireds, j);
                            --j;
                            --jl;

                            if (!schema._flags.sparse &&
                                res.value === undefined) {

                                errors.push(error('array.sparse', { key, path, pos: i, value: undefined }, state.localize(path)));
                                if (prefs.abortEarly) {
                                    return errors;
                                }
                            }

                            break;
                        }

                        localState.restore();
                    }

                    if (isValid) {
                        continue;
                    }

                    // Inclusions

                    const stripUnknown = prefs.stripUnknown && !!prefs.stripUnknown.arrays || false;

                    jl = inclusions.length;
                    for (const inclusion of inclusions) {

                        // Avoid re-running requireds that already didn't match in the previous loop

                        let res;
                        const previousCheck = requireds.indexOf(inclusion);
                        if (previousCheck !== -1) {
                            res = requiredChecks[previousCheck];
                        }
                        else {
                            const localState = state.localize(path, ancestors, inclusion);
                            localState.snapshot();

                            res = inclusion.$_validate(item, localState, prefs);
                            if (!res.errors) {
                                localState.commit();
                                if (inclusion._flags.result === 'strip') {
                                    internals.fastSplice(value, i);
                                    --i;
                                    --il;
                                }
                                else if (!schema._flags.sparse &&
                                    res.value === undefined) {

                                    errors.push(error('array.sparse', { key, path, pos: i, value: undefined }, state.localize(path)));
                                    errored = true;
                                }
                                else {
                                    value[i] = res.value;
                                }

                                isValid = true;
                                break;
                            }

                            localState.restore();
                        }

                        // Return the actual error if only one inclusion defined

                        if (jl === 1) {
                            if (stripUnknown) {
                                internals.fastSplice(value, i);
                                --i;
                                --il;
                                isValid = true;
                                break;
                            }

                            errors.push(...res.errors);
                            if (prefs.abortEarly) {
                                return errors;
                            }

                            errored = true;
                            break;
                        }
                    }

                    if (errored) {
                        continue;
                    }

                    if ((schema.$_terms._inclusions.length || schema.$_terms._requireds.length) &&
                        !isValid) {

                        if (stripUnknown) {
                            internals.fastSplice(value, i);
                            --i;
                            --il;
                            continue;
                        }

                        errors.push(error('array.includes', { pos: i, value: item }, state.localize(path)));
                        if (prefs.abortEarly) {
                            return errors;
                        }
                    }
                }

                if (requireds.length) {
                    internals.fillMissedErrors(schema, errors, requireds, value, state, prefs);
                }

                if (ordereds.length) {
                    internals.fillOrderedErrors(schema, errors, ordereds, value, state, prefs);

                    if (!errors.length) {
                        internals.fillDefault(ordereds, value, state, prefs);
                    }
                }

                return errors.length ? errors : value;
            },

            priority: true,
            manifest: false
        },

        length: {
            method(limit) {

                return this.$_addRule({ name: 'length', args: { limit }, operator: '=' });
            },
            validate(value, helpers, { limit }, { name, operator, args }) {

                if (Common.compare(value.length, limit, operator)) {
                    return value;
                }

                return helpers.error('array.' + name, { limit: args.limit, value });
            },
            args: [
                {
                    name: 'limit',
                    ref: true,
                    assert: Common.limit,
                    message: 'must be a positive integer'
                }
            ]
        },

        max: {
            method(limit) {

                return this.$_addRule({ name: 'max', method: 'length', args: { limit }, operator: '<=' });
            }
        },

        min: {
            method(limit) {

                return this.$_addRule({ name: 'min', method: 'length', args: { limit }, operator: '>=' });
            }
        },

        ordered: {
            method(...schemas) {

                Common.verifyFlat(schemas, 'ordered');

                const obj = this.$_addRule('items');

                for (let i = 0; i < schemas.length; ++i) {
                    const type = Common.tryWithPath(() => this.$_compile(schemas[i]), i, { append: true });
                    internals.validateSingle(type, obj);

                    obj.$_mutateRegister(type);
                    obj.$_terms.ordered.push(type);
                }

                return obj.$_mutateRebuild();
            }
        },

        single: {
            method(enabled) {

                const value = enabled === undefined ? true : !!enabled;
                assert(!value || !this._flags._arrayItems, 'Cannot specify single rule when array has array items');

                return this.$_setFlag('single', value);
            }
        },

        sort: {
            method(options = {}) {

                Common.assertOptions(options, ['by', 'order']);

                const settings = {
                    order: options.order || 'ascending'
                };

                if (options.by) {
                    settings.by = Compile.ref(options.by, { ancestor: 0 });
                    assert(!settings.by.ancestor, 'Cannot sort by ancestor');
                }

                return this.$_addRule({ name: 'sort', args: { options: settings } });
            },
            validate(value, { error, state, prefs, schema }, { options }) {

                const { value: sorted, errors } = internals.sort(schema, value, options, state, prefs);
                if (errors) {
                    return errors;
                }

                for (let i = 0; i < value.length; ++i) {
                    if (value[i] !== sorted[i]) {
                        return error('array.sort', { order: options.order, by: options.by ? options.by.key : 'value' });
                    }
                }

                return value;
            },
            convert: true
        },

        sparse: {
            method(enabled) {

                const value = enabled === undefined ? true : !!enabled;

                if (this._flags.sparse === value) {
                    return this;
                }

                const obj = value ? this.clone() : this.$_addRule('items');
                return obj.$_setFlag('sparse', value, { clone: false });
            }
        },

        unique: {
            method(comparator, options = {}) {

                assert(!comparator || typeof comparator === 'function' || typeof comparator === 'string', 'comparator must be a function or a string');
                Common.assertOptions(options, ['ignoreUndefined', 'separator']);

                const rule = { name: 'unique', args: { options, comparator } };

                if (comparator) {
                    if (typeof comparator === 'string') {
                        const separator = Common.default(options.separator, '.');
                        rule.path = separator ? comparator.split(separator) : [comparator];
                    }
                    else {
                        rule.comparator = comparator;
                    }
                }

                return this.$_addRule(rule);
            },
            validate(value, { state, error, schema }, { comparator: raw, options }, { comparator, path }) {

                const found = {
                    string: Object.create(null),
                    number: Object.create(null),
                    undefined: Object.create(null),
                    boolean: Object.create(null),
                    bigint: Object.create(null),
                    object: new Map(),
                    function: new Map(),
                    custom: new Map()
                };

                const compare = comparator || deepEqual;
                const ignoreUndefined = options.ignoreUndefined;

                for (let i = 0; i < value.length; ++i) {
                    const item = path ? reach(value[i], path) : value[i];
                    const records = comparator ? found.custom : found[typeof item];
                    assert(records, 'Failed to find unique map container for type', typeof item);

                    if (records instanceof Map) {
                        const entries = records.entries();
                        let current;
                        while (!(current = entries.next()).done) {
                            if (compare(current.value[0], item)) {
                                const localState = state.localize([...state.path, i], [value, ...state.ancestors]);
                                const context = {
                                    pos: i,
                                    value: value[i],
                                    dupePos: current.value[1],
                                    dupeValue: value[current.value[1]]
                                };

                                if (path) {
                                    context.path = raw;
                                }

                                return error('array.unique', context, localState);
                            }
                        }

                        records.set(item, i);
                    }
                    else {
                        if ((!ignoreUndefined || item !== undefined) &&
                            records[item] !== undefined) {

                            const context = {
                                pos: i,
                                value: value[i],
                                dupePos: records[item],
                                dupeValue: value[records[item]]
                            };

                            if (path) {
                                context.path = raw;
                            }

                            const localState = state.localize([...state.path, i], [value, ...state.ancestors]);
                            return error('array.unique', context, localState);
                        }

                        records[item] = i;
                    }
                }

                return value;
            },
            args: ['comparator', 'options'],
            multi: true
        }
    },

    overrides: {

        isAsync() {

            if (this.$_terms.externals?.length) {
                return true;
            }

            for (const item of this.$_terms.items) {
                if (item.isAsync()) {
                    return true;
                }
            }

            for (const item of this.$_terms.ordered) {
                if (item.isAsync()) {
                    return true;
                }
            }

            return false;
        }
    },

    cast: {
        set: {
            from: Array.isArray,
            to(value, helpers) {

                return new Set(value);
            }
        }
    },

    rebuild(schema) {

        schema.$_terms._inclusions = [];
        schema.$_terms._exclusions = [];
        schema.$_terms._requireds = [];

        for (const type of schema.$_terms.items) {
            internals.validateSingle(type, schema);

            if (type._flags.presence === 'required') {
                schema.$_terms._requireds.push(type);
            }
            else if (type._flags.presence === 'forbidden') {
                schema.$_terms._exclusions.push(type);
            }
            else {
                schema.$_terms._inclusions.push(type);
            }
        }

        for (const type of schema.$_terms.ordered) {
            internals.validateSingle(type, schema);
        }
    },

    manifest: {

        build(obj, desc) {

            if (desc.items) {
                obj = obj.items(...desc.items);
            }

            if (desc.ordered) {
                obj = obj.ordered(...desc.ordered);
            }

            return obj;
        }
    },

    messages: {
        'array.base': '{{#label}} must be an array',
        'array.excludes': '{{#label}} contains an excluded value',
        'array.hasKnown': '{{#label}} does not contain at least one required match for type {:#patternLabel}',
        'array.hasUnknown': '{{#label}} does not contain at least one required match',
        'array.includes': '{{#label}} does not match any of the allowed types',
        'array.includesRequiredBoth': '{{#label}} does not contain {{#knownMisses}} and {{#unknownMisses}} other required value(s)',
        'array.includesRequiredKnowns': '{{#label}} does not contain {{#knownMisses}}',
        'array.includesRequiredUnknowns': '{{#label}} does not contain {{#unknownMisses}} required value(s)',
        'array.length': '{{#label}} must contain {{#limit}} items',
        'array.max': '{{#label}} must contain less than or equal to {{#limit}} items',
        'array.min': '{{#label}} must contain at least {{#limit}} items',
        'array.orderedLength': '{{#label}} must contain at most {{#limit}} items',
        'array.sort': '{{#label}} must be sorted in {#order} order by {{#by}}',
        'array.sort.mismatching': '{{#label}} cannot be sorted due to mismatching types',
        'array.sort.unsupported': '{{#label}} cannot be sorted due to unsupported type {#type}',
        'array.sparse': '{{#label}} must not be a sparse array item',
        'array.unique': '{{#label}} contains a duplicate value'
    }
});


// Helpers

internals.fillMissedErrors = function (schema, errors, requireds, value, state, prefs) {

    const knownMisses = [];
    let unknownMisses = 0;
    for (const required of requireds) {
        const label = required._flags.label;
        if (label) {
            knownMisses.push(label);
        }
        else {
            ++unknownMisses;
        }
    }

    if (knownMisses.length) {
        if (unknownMisses) {
            errors.push(schema.$_createError('array.includesRequiredBoth', value, { knownMisses, unknownMisses }, state, prefs));
        }
        else {
            errors.push(schema.$_createError('array.includesRequiredKnowns', value, { knownMisses }, state, prefs));
        }
    }
    else {
        errors.push(schema.$_createError('array.includesRequiredUnknowns', value, { unknownMisses }, state, prefs));
    }
};


internals.fillOrderedErrors = function (schema, errors, ordereds, value, state, prefs) {

    const requiredOrdereds = [];

    for (const ordered of ordereds) {
        if (ordered._flags.presence === 'required') {
            requiredOrdereds.push(ordered);
        }
    }

    if (requiredOrdereds.length) {
        internals.fillMissedErrors(schema, errors, requiredOrdereds, value, state, prefs);
    }
};


internals.fillDefault = function (ordereds, value, state, prefs) {

    const overrides = [];
    let trailingUndefined = true;

    for (let i = ordereds.length - 1; i >= 0; --i) {
        const ordered = ordereds[i];
        const ancestors = [value, ...state.ancestors];
        const override = ordered.$_validate(undefined, state.localize(state.path, ancestors, ordered), prefs).value;

        if (trailingUndefined) {
            if (override === undefined) {
                continue;
            }

            trailingUndefined = false;
        }

        overrides.unshift(override);
    }

    if (overrides.length) {
        value.push(...overrides);
    }
};


internals.fastSplice = function (arr, i) {

    let pos = i;
    while (pos < arr.length) {
        arr[pos++] = arr[pos];
    }

    --arr.length;
};


internals.validateSingle = function (type, obj) {

    if (type.type === 'array' ||
        type._flags._arrayItems) {

        assert(!obj._flags.single, 'Cannot specify array item with single rule enabled');
        obj.$_setFlag('_arrayItems', true, { clone: false });
    }
};


internals.sort = function (schema, value, settings, state, prefs) {

    const order = settings.order === 'ascending' ? 1 : -1;
    const aFirst = -1 * order;
    const bFirst = order;

    const sort = (a, b) => {

        let compare = internals.compare(a, b, aFirst, bFirst);
        if (compare !== null) {
            return compare;
        }

        if (settings.by) {
            a = settings.by.resolve(a, state, prefs);
            b = settings.by.resolve(b, state, prefs);
        }

        compare = internals.compare(a, b, aFirst, bFirst);
        if (compare !== null) {
            return compare;
        }

        const type = typeof a;
        if (type !== typeof b) {
            throw schema.$_createError('array.sort.mismatching', value, null, state, prefs);
        }

        if (type !== 'number' &&
            type !== 'string') {

            throw schema.$_createError('array.sort.unsupported', value, { type }, state, prefs);
        }

        if (type === 'number') {
            return (a - b) * order;
        }

        return a < b ? aFirst : bFirst;
    };

    try {
        return { value: value.slice().sort(sort) };
    }
    catch (err) {
        return { errors: err };
    }
};


internals.compare = function (a, b, aFirst, bFirst) {

    if (a === b) {
        return 0;
    }

    if (a === undefined) {
        return 1;           // Always last regardless of sort order
    }

    if (b === undefined) {
        return -1;           // Always last regardless of sort order
    }

    if (a === null) {
        return bFirst;
    }

    if (b === null) {
        return aFirst;
    }

    return null;
};


/***/ }),

/***/ 68499:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


const { assert } = __nccwpck_require__(91884);

const Any = __nccwpck_require__(49046);
const Common = __nccwpck_require__(84205);


const internals = {};


module.exports = Any.extend({

    type: 'binary',

    coerce: {
        from: ['string', 'object'],
        method(value, { schema }) {

            if (typeof value === 'string' || (value !== null && value.type === 'Buffer')) {
                try {
                    return { value: Buffer.from(value, schema._flags.encoding) };
                }
                catch { }
            }
        }
    },

    validate(value, { error }) {

        if (!Buffer.isBuffer(value)) {
            return { value, errors: error('binary.base') };
        }
    },

    rules: {
        encoding: {
            method(encoding) {

                assert(Buffer.isEncoding(encoding), 'Invalid encoding:', encoding);

                return this.$_setFlag('encoding', encoding);
            }
        },

        length: {
            method(limit) {

                return this.$_addRule({ name: 'length', method: 'length', args: { limit }, operator: '=' });
            },
            validate(value, helpers, { limit }, { name, operator, args }) {

                if (Common.compare(value.length, limit, operator)) {
                    return value;
                }

                return helpers.error('binary.' + name, { limit: args.limit, value });
            },
            args: [
                {
                    name: 'limit',
                    ref: true,
                    assert: Common.limit,
                    message: 'must be a positive integer'
                }
            ]
        },

        max: {
            method(limit) {

                return this.$_addRule({ name: 'max', method: 'length', args: { limit }, operator: '<=' });
            }
        },

        min: {
            method(limit) {

                return this.$_addRule({ name: 'min', method: 'length', args: { limit }, operator: '>=' });
            }
        }
    },

    cast: {
        string: {
            from: (value) => Buffer.isBuffer(value),
            to(value, helpers) {

                return value.toString();
            }
        }
    },

    messages: {
        'binary.base': '{{#label}} must be a buffer or a string',
        'binary.length': '{{#label}} must be {{#limit}} bytes',
        'binary.max': '{{#label}} must be less than or equal to {{#limit}} bytes',
        'binary.min': '{{#label}} must be at least {{#limit}} bytes'
    }
});


/***/ }),

/***/ 44228:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


const { assert } = __nccwpck_require__(91884);

const Any = __nccwpck_require__(49046);
const Common = __nccwpck_require__(84205);
const Values = __nccwpck_require__(31906);


const internals = {};


internals.isBool = function (value) {

    return typeof value === 'boolean';
};


module.exports = Any.extend({

    type: 'boolean',

    flags: {

        sensitive: { default: false }
    },

    terms: {

        falsy: {
            init: null,
            manifest: 'values'
        },

        truthy: {
            init: null,
            manifest: 'values'
        }
    },

    coerce(value, { schema }) {

        if (typeof value === 'boolean') {
            return;
        }

        if (typeof value === 'string') {
            const trimmedValue = value.trim();
            const normalized = schema._flags.sensitive ? trimmedValue : trimmedValue.toLowerCase();
            value = normalized === 'true' ? true : (normalized === 'false' ? false : value);
        }

        if (typeof value !== 'boolean') {
            value = schema.$_terms.truthy && schema.$_terms.truthy.has(value, null, null, !schema._flags.sensitive) ||
                (schema.$_terms.falsy && schema.$_terms.falsy.has(value, null, null, !schema._flags.sensitive) ? false : value);
        }

        return { value };
    },

    validate(value, { error }) {

        if (typeof value !== 'boolean') {
            return { value, errors: error('boolean.base') };
        }
    },

    rules: {
        truthy: {
            method(...values) {

                Common.verifyFlat(values, 'truthy');

                const obj = this.clone();
                obj.$_terms.truthy = obj.$_terms.truthy || new Values();

                for (let i = 0; i < values.length; ++i) {
                    const value = values[i];

                    assert(value !== undefined, 'Cannot call truthy with undefined');
                    obj.$_terms.truthy.add(value);
                }

                return obj;
            }
        },

        falsy: {
            method(...values) {

                Common.verifyFlat(values, 'falsy');

                const obj = this.clone();
                obj.$_terms.falsy = obj.$_terms.falsy || new Values();

                for (let i = 0; i < values.length; ++i) {
                    const value = values[i];

                    assert(value !== undefined, 'Cannot call falsy with undefined');
                    obj.$_terms.falsy.add(value);
                }

                return obj;
            }
        },

        sensitive: {
            method(enabled = true) {

                return this.$_setFlag('sensitive', enabled);
            }
        }
    },

    cast: {
        number: {
            from: internals.isBool,
            to(value, helpers) {

                return value ? 1 : 0;
            }
        },
        string: {
            from: internals.isBool,
            to(value, helpers) {

                return value ? 'true' : 'false';
            }
        }
    },

    manifest: {

        build(obj, desc) {

            if (desc.truthy) {
                obj = obj.truthy(...desc.truthy);
            }

            if (desc.falsy) {
                obj = obj.falsy(...desc.falsy);
            }

            return obj;
        }
    },

    messages: {
        'boolean.base': '{{#label}} must be a boolean'
    }
});


/***/ }),

/***/ 9922:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


const { assert } = __nccwpck_require__(91884);

const Any = __nccwpck_require__(49046);
const Common = __nccwpck_require__(84205);
const Template = __nccwpck_require__(75706);


const internals = {};


internals.isDate = function (value) {

    return value instanceof Date;
};


module.exports = Any.extend({

    type: 'date',

    coerce: {
        from: ['number', 'string'],
        method(value, { schema }) {

            return { value: internals.parse(value, schema._flags.format) || value };
        }
    },

    validate(value, { schema, error, prefs }) {

        if (value instanceof Date &&
            !isNaN(value.getTime())) {

            return;
        }

        const format = schema._flags.format;

        if (!prefs.convert ||
            !format ||
            typeof value !== 'string') {

            return { value, errors: error('date.base') };
        }

        return { value, errors: error('date.format', { format }) };
    },

    rules: {

        compare: {
            method: false,
            validate(value, helpers, { date }, { name, operator, args }) {

                const to = date === 'now' ? Date.now() : date.getTime();
                if (Common.compare(value.getTime(), to, operator)) {
                    return value;
                }

                return helpers.error('date.' + name, { limit: args.date, value });
            },
            args: [
                {
                    name: 'date',
                    ref: true,
                    normalize: (date) => {

                        return date === 'now' ? date : internals.parse(date);
                    },
                    assert: (date) => date !== null,
                    message: 'must have a valid date format'
                }
            ]
        },

        format: {
            method(format) {

                assert(['iso', 'javascript', 'unix'].includes(format), 'Unknown date format', format);

                return this.$_setFlag('format', format);
            }
        },

        greater: {
            method(date) {

                return this.$_addRule({ name: 'greater', method: 'compare', args: { date }, operator: '>' });
            }
        },

        iso: {
            method() {

                return this.format('iso');
            }
        },

        less: {
            method(date) {

                return this.$_addRule({ name: 'less', method: 'compare', args: { date }, operator: '<' });
            }
        },

        max: {
            method(date) {

                return this.$_addRule({ name: 'max', method: 'compare', args: { date }, operator: '<=' });
            }
        },

        min: {
            method(date) {

                return this.$_addRule({ name: 'min', method: 'compare', args: { date }, operator: '>=' });
            }
        },

        timestamp: {
            method(type = 'javascript') {

                assert(['javascript', 'unix'].includes(type), '"type" must be one of "javascript, unix"');

                return this.format(type);
            }
        }
    },

    cast: {
        number: {
            from: internals.isDate,
            to(value, helpers) {

                return value.getTime();
            }
        },
        string: {
            from: internals.isDate,
            to(value, { prefs }) {

                return Template.date(value, prefs);
            }
        }
    },

    messages: {
        'date.base': '{{#label}} must be a valid date',
        'date.format': '{{#label}} must be in {msg("date.format." + #format) || #format} format',
        'date.greater': '{{#label}} must be greater than {{:#limit}}',
        'date.less': '{{#label}} must be less than {{:#limit}}',
        'date.max': '{{#label}} must be less than or equal to {{:#limit}}',
        'date.min': '{{#label}} must be greater than or equal to {{:#limit}}',

        // Messages used in date.format

        'date.format.iso': 'ISO 8601 date',
        'date.format.javascript': 'timestamp or number of milliseconds',
        'date.format.unix': 'timestamp or number of seconds'
    }
});


// Helpers

internals.parse = function (value, format) {

    if (value instanceof Date) {
        return value;
    }

    if (typeof value !== 'string' &&
        (isNaN(value) || !isFinite(value))) {

        return null;
    }

    if (/^\s*$/.test(value)) {
        return null;
    }

    // ISO

    if (format === 'iso') {
        if (!Common.isIsoDate(value)) {
            return null;
        }

        return internals.date(value.toString());
    }

    // Normalize number string

    const original = value;
    if (typeof value === 'string' &&
        /^[+-]?\d+(\.\d+)?$/.test(value)) {

        value = parseFloat(value);
    }

    // Timestamp

    if (format) {
        if (format === 'javascript') {
            return internals.date(1 * value);        // Casting to number
        }

        if (format === 'unix') {
            return internals.date(1000 * value);
        }

        if (typeof original === 'string') {
            return null;
        }
    }

    // Plain

    return internals.date(value);
};


internals.date = function (value) {

    const date = new Date(value);
    if (!isNaN(date.getTime())) {
        return date;
    }

    return null;
};


/***/ }),

/***/ 47210:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


const { assert } = __nccwpck_require__(91884);

const Keys = __nccwpck_require__(14462);


const internals = {};


module.exports = Keys.extend({

    type: 'function',

    properties: {
        typeof: 'function'
    },

    rules: {
        arity: {
            method(n) {

                assert(Number.isSafeInteger(n) && n >= 0, 'n must be a positive integer');

                return this.$_addRule({ name: 'arity', args: { n } });
            },
            validate(value, helpers, { n }) {

                if (value.length === n) {
                    return value;
                }

                return helpers.error('function.arity', { n });
            }
        },

        class: {
            method() {

                return this.$_addRule('class');
            },
            validate(value, helpers) {

                if ((/^\s*class\s/).test(value.toString())) {
                    return value;
                }

                return helpers.error('function.class', { value });
            }
        },

        minArity: {
            method(n) {

                assert(Number.isSafeInteger(n) && n > 0, 'n must be a strict positive integer');

                return this.$_addRule({ name: 'minArity', args: { n } });
            },
            validate(value, helpers, { n }) {

                if (value.length >= n) {
                    return value;
                }

                return helpers.error('function.minArity', { n });
            }
        },

        maxArity: {
            method(n) {

                assert(Number.isSafeInteger(n) && n >= 0, 'n must be a positive integer');

                return this.$_addRule({ name: 'maxArity', args: { n } });
            },
            validate(value, helpers, { n }) {

                if (value.length <= n) {
                    return value;
                }

                return helpers.error('function.maxArity', { n });
            }
        }
    },

    messages: {
        'function.arity': '{{#label}} must have an arity of {{#n}}',
        'function.class': '{{#label}} must be a class',
        'function.maxArity': '{{#label}} must have an arity lesser or equal to {{#n}}',
        'function.minArity': '{{#label}} must have an arity greater or equal to {{#n}}'
    }
});


/***/ }),

/***/ 14462:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


const { applyToDefaults, assert, clone: Clone } = __nccwpck_require__(91884);
const Topo = __nccwpck_require__(97541);

const Any = __nccwpck_require__(49046);
const Common = __nccwpck_require__(84205);
const Compile = __nccwpck_require__(14743);
const Errors = __nccwpck_require__(11543);
const Ref = __nccwpck_require__(51579);
const Template = __nccwpck_require__(75706);


const internals = {
    renameDefaults: {
        alias: false,                   // Keep old value in place
        multiple: false,                // Allow renaming multiple keys into the same target
        override: false                 // Overrides an existing key
    }
};


module.exports = Any.extend({

    type: '_keys',

    properties: {

        typeof: 'object'
    },

    flags: {

        unknown: { default: undefined }
    },

    terms: {

        dependencies: { init: null },
        keys: { init: null, manifest: { mapped: { from: 'schema', to: 'key' } } },
        patterns: { init: null },
        renames: { init: null }
    },

    args(schema, keys) {

        return schema.keys(keys);
    },

    validate(value, { schema, error, state, prefs }) {

        if (!value ||
            typeof value !== schema.$_property('typeof') ||
            Array.isArray(value)) {

            return { value, errors: error('object.base', { type: schema.$_property('typeof') }) };
        }

        // Skip if there are no other rules to test

        if (!schema.$_terms.renames &&
            !schema.$_terms.dependencies &&
            !schema.$_terms.keys &&                       // null allows any keys
            !schema.$_terms.patterns &&
            !schema.$_terms.externals) {

            return;
        }

        // Shallow clone value

        value = internals.clone(value, prefs);
        const errors = [];

        // Rename keys

        if (schema.$_terms.renames &&
            !internals.rename(schema, value, state, prefs, errors)) {

            return { value, errors };
        }

        // Anything allowed

        if (!schema.$_terms.keys &&                       // null allows any keys
            !schema.$_terms.patterns &&
            !schema.$_terms.dependencies) {

            return { value, errors };
        }

        // Defined keys

        const unprocessed = new Set(Object.keys(value));

        if (schema.$_terms.keys) {
            const ancestors = [value, ...state.ancestors];

            for (const child of schema.$_terms.keys) {
                const key = child.key;
                const item = value[key];

                unprocessed.delete(key);

                const localState = state.localize([...state.path, key], ancestors, child);
                const result = child.schema.$_validate(item, localState, prefs);

                if (result.errors) {
                    if (prefs.abortEarly) {
                        return { value, errors: result.errors };
                    }

                    if (result.value !== undefined) {
                        value[key] = result.value;
                    }

                    errors.push(...result.errors);
                }
                else if (child.schema._flags.result === 'strip' ||
                    result.value === undefined && item !== undefined) {

                    delete value[key];
                }
                else if (result.value !== undefined) {
                    value[key] = result.value;
                }
            }
        }

        // Unknown keys

        if (unprocessed.size ||
            schema._flags._hasPatternMatch) {

            const early = internals.unknown(schema, value, unprocessed, errors, state, prefs);
            if (early) {
                return early;
            }
        }

        // Validate dependencies

        if (schema.$_terms.dependencies) {
            for (const dep of schema.$_terms.dependencies) {
                if (
                    dep.key !== null &&
                    internals.isPresent(dep.options)(dep.key.resolve(value, state, prefs, null, { shadow: false })) === false
                ) {

                    continue;
                }

                const failed = internals.dependencies[dep.rel](schema, dep, value, state, prefs);
                if (failed) {
                    const report = schema.$_createError(failed.code, value, failed.context, state, prefs);
                    if (prefs.abortEarly) {
                        return { value, errors: report };
                    }

                    errors.push(report);
                }
            }
        }

        return { value, errors };
    },

    rules: {

        and: {
            method(...peers /*, [options] */) {

                Common.verifyFlat(peers, 'and');

                return internals.dependency(this, 'and', null, peers);
            }
        },

        append: {
            method(schema) {

                if (schema === null ||
                    schema === undefined ||
                    Object.keys(schema).length === 0) {

                    return this;
                }

                return this.keys(schema);
            }
        },

        assert: {
            method(subject, schema, message) {

                if (!Template.isTemplate(subject)) {
                    subject = Compile.ref(subject);
                }

                assert(message === undefined || typeof message === 'string', 'Message must be a string');

                schema = this.$_compile(schema, { appendPath: true });

                const obj = this.$_addRule({ name: 'assert', args: { subject, schema, message } });
                obj.$_mutateRegister(subject);
                obj.$_mutateRegister(schema);
                return obj;
            },
            validate(value, { error, prefs, state }, { subject, schema, message }) {

                const about = subject.resolve(value, state, prefs);
                const path = Ref.isRef(subject) ? subject.absolute(state) : [];
                if (schema.$_match(about, state.localize(path, [value, ...state.ancestors], schema), prefs)) {
                    return value;
                }

                return error('object.assert', { subject, message });
            },
            args: ['subject', 'schema', 'message'],
            multi: true
        },

        instance: {
            method(constructor, name) {

                assert(typeof constructor === 'function', 'constructor must be a function');

                name = name || constructor.name;

                return this.$_addRule({ name: 'instance', args: { constructor, name } });
            },
            validate(value, helpers, { constructor, name }) {

                if (value instanceof constructor) {
                    return value;
                }

                return helpers.error('object.instance', { type: name, value });
            },
            args: ['constructor', 'name']
        },

        keys: {
            method(schema) {

                assert(schema === undefined || typeof schema === 'object', 'Object schema must be a valid object');
                assert(!Common.isSchema(schema), 'Object schema cannot be a joi schema');

                const obj = this.clone();

                if (!schema) {                                      // Allow all
                    obj.$_terms.keys = null;
                }
                else if (!Object.keys(schema).length) {             // Allow none
                    obj.$_terms.keys = new internals.Keys();
                }
                else {
                    obj.$_terms.keys = obj.$_terms.keys ? obj.$_terms.keys.filter((child) => !schema.hasOwnProperty(child.key)) : new internals.Keys();
                    for (const key in schema) {
                        Common.tryWithPath(() => obj.$_terms.keys.push({ key, schema: this.$_compile(schema[key]) }), key);
                    }
                }

                return obj.$_mutateRebuild();
            }
        },

        length: {
            method(limit) {

                return this.$_addRule({ name: 'length', args: { limit }, operator: '=' });
            },
            validate(value, helpers, { limit }, { name, operator, args }) {

                if (Common.compare(Object.keys(value).length, limit, operator)) {
                    return value;
                }

                return helpers.error('object.' + name, { limit: args.limit, value });
            },
            args: [
                {
                    name: 'limit',
                    ref: true,
                    assert: Common.limit,
                    message: 'must be a positive integer'
                }
            ]
        },

        max: {
            method(limit) {

                return this.$_addRule({ name: 'max', method: 'length', args: { limit }, operator: '<=' });
            }
        },

        min: {
            method(limit) {

                return this.$_addRule({ name: 'min', method: 'length', args: { limit }, operator: '>=' });
            }
        },

        nand: {
            method(...peers /*, [options] */) {

                Common.verifyFlat(peers, 'nand');

                return internals.dependency(this, 'nand', null, peers);
            }
        },

        or: {
            method(...peers /*, [options] */) {

                Common.verifyFlat(peers, 'or');

                return internals.dependency(this, 'or', null, peers);
            }
        },

        oxor: {
            method(...peers /*, [options] */) {

                return internals.dependency(this, 'oxor', null, peers);
            }
        },

        pattern: {
            method(pattern, schema, options = {}) {

                const isRegExp = pattern instanceof RegExp;
                if (!isRegExp) {
                    pattern = this.$_compile(pattern, { appendPath: true });
                }

                assert(schema !== undefined, 'Invalid rule');
                Common.assertOptions(options, ['fallthrough', 'matches']);

                if (isRegExp) {
                    assert(!pattern.flags.includes('g') && !pattern.flags.includes('y'), 'pattern should not use global or sticky mode');
                }

                schema = this.$_compile(schema, { appendPath: true });

                const obj = this.clone();
                obj.$_terms.patterns = obj.$_terms.patterns || [];
                const config = { [isRegExp ? 'regex' : 'schema']: pattern, rule: schema };
                if (options.matches) {
                    config.matches = this.$_compile(options.matches);
                    if (config.matches.type !== 'array') {
                        config.matches = config.matches.$_root.array().items(config.matches);
                    }

                    obj.$_mutateRegister(config.matches);
                    obj.$_setFlag('_hasPatternMatch', true, { clone: false });
                }

                if (options.fallthrough) {
                    config.fallthrough = true;
                }

                obj.$_terms.patterns.push(config);
                obj.$_mutateRegister(schema);
                return obj;
            }
        },

        ref: {
            method() {

                return this.$_addRule('ref');
            },
            validate(value, helpers) {

                if (Ref.isRef(value)) {
                    return value;
                }

                return helpers.error('object.refType', { value });
            }
        },

        regex: {
            method() {

                return this.$_addRule('regex');
            },
            validate(value, helpers) {

                if (value instanceof RegExp) {
                    return value;
                }

                return helpers.error('object.regex', { value });
            }
        },

        rename: {
            method(from, to, options = {}) {

                assert(typeof from === 'string' || from instanceof RegExp, 'Rename missing the from argument');
                assert(typeof to === 'string' || to instanceof Template, 'Invalid rename to argument');
                assert(to !== from, 'Cannot rename key to same name:', from);

                Common.assertOptions(options, ['alias', 'ignoreUndefined', 'override', 'multiple']);

                const obj = this.clone();

                obj.$_terms.renames = obj.$_terms.renames || [];
                for (const rename of obj.$_terms.renames) {
                    assert(rename.from !== from, 'Cannot rename the same key multiple times');
                }

                if (to instanceof Template) {
                    obj.$_mutateRegister(to);
                }

                obj.$_terms.renames.push({
                    from,
                    to,
                    options: applyToDefaults(internals.renameDefaults, options)
                });

                return obj;
            }
        },

        schema: {
            method(type = 'any') {

                return this.$_addRule({ name: 'schema', args: { type } });
            },
            validate(value, helpers, { type }) {

                if (Common.isSchema(value) &&
                    (type === 'any' || value.type === type)) {

                    return value;
                }

                return helpers.error('object.schema', { type });
            }
        },

        unknown: {
            method(allow) {

                return this.$_setFlag('unknown', allow !== false);
            }
        },

        with: {
            method(key, peers, options = {}) {

                return internals.dependency(this, 'with', key, peers, options);
            }
        },

        without: {
            method(key, peers, options = {}) {

                return internals.dependency(this, 'without', key, peers, options);
            }
        },

        xor: {
            method(...peers /*, [options] */) {

                Common.verifyFlat(peers, 'xor');

                return internals.dependency(this, 'xor', null, peers);
            }
        }
    },

    overrides: {

        default(value, options) {

            if (value === undefined) {
                value = Common.symbols.deepDefault;
            }

            return this.$_parent('default', value, options);
        },

        isAsync() {

            if (this.$_terms.externals?.length) {
                return true;
            }

            if (this.$_terms.keys?.length) {
                for (const key of this.$_terms.keys) {
                    if (key.schema.isAsync()) {
                        return true;
                    }
                }
            }

            if (this.$_terms.patterns?.length) {
                for (const pattern of this.$_terms.patterns) {
                    if (pattern.rule.isAsync()) {
                        return true;
                    }
                }
            }

            return false;
        }
    },

    rebuild(schema) {

        if (schema.$_terms.keys) {
            const topo = new Topo.Sorter();
            for (const child of schema.$_terms.keys) {
                Common.tryWithPath(() => topo.add(child, { after: child.schema.$_rootReferences(), group: child.key }), child.key);
            }

            schema.$_terms.keys = new internals.Keys(...topo.nodes);
        }
    },

    manifest: {

        build(obj, desc) {

            if (desc.keys) {
                obj = obj.keys(desc.keys);
            }

            if (desc.dependencies) {
                for (const { rel, key = null, peers, options } of desc.dependencies) {
                    obj = internals.dependency(obj, rel, key, peers, options);
                }
            }

            if (desc.patterns) {
                for (const { regex, schema, rule, fallthrough, matches } of desc.patterns) {
                    obj = obj.pattern(regex || schema, rule, { fallthrough, matches });
                }
            }

            if (desc.renames) {
                for (const { from, to, options } of desc.renames) {
                    obj = obj.rename(from, to, options);
                }
            }

            return obj;
        }
    },

    messages: {
        'object.and': '{{#label}} contains {{#presentWithLabels}} without its required peers {{#missingWithLabels}}',
        'object.assert': '{{#label}} is invalid because {if(#subject.key, `"` + #subject.key + `" failed to ` + (#message || "pass the assertion test"), #message || "the assertion failed")}',
        'object.base': '{{#label}} must be of type {{#type}}',
        'object.instance': '{{#label}} must be an instance of {{:#type}}',
        'object.length': '{{#label}} must have {{#limit}} key{if(#limit == 1, "", "s")}',
        'object.max': '{{#label}} must have less than or equal to {{#limit}} key{if(#limit == 1, "", "s")}',
        'object.min': '{{#label}} must have at least {{#limit}} key{if(#limit == 1, "", "s")}',
        'object.missing': '{{#label}} must contain at least one of {{#peersWithLabels}}',
        'object.nand': '{{:#mainWithLabel}} must not exist simultaneously with {{#peersWithLabels}}',
        'object.oxor': '{{#label}} contains a conflict between optional exclusive peers {{#peersWithLabels}}',
        'object.pattern.match': '{{#label}} keys failed to match pattern requirements',
        'object.refType': '{{#label}} must be a Joi reference',
        'object.regex': '{{#label}} must be a RegExp object',
        'object.rename.multiple': '{{#label}} cannot rename {{:#from}} because multiple renames are disabled and another key was already renamed to {{:#to}}',
        'object.rename.override': '{{#label}} cannot rename {{:#from}} because override is disabled and target {{:#to}} exists',
        'object.schema': '{{#label}} must be a Joi schema of {{#type}} type',
        'object.unknown': '{{#label}} is not allowed',
        'object.with': '{{:#mainWithLabel}} missing required peer {{:#peerWithLabel}}',
        'object.without': '{{:#mainWithLabel}} conflict with forbidden peer {{:#peerWithLabel}}',
        'object.xor': '{{#label}} contains a conflict between exclusive peers {{#peersWithLabels}}'
    }
});


// Helpers

internals.clone = function (value, prefs) {

    // Object

    if (typeof value === 'object') {
        if (prefs.nonEnumerables) {
            return Clone(value, { shallow: true });
        }

        const clone = Object.create(Object.getPrototypeOf(value));
        Object.assign(clone, value);
        return clone;
    }

    // Function

    const clone = function (...args) {

        return value.apply(this, args);
    };

    clone.prototype = Clone(value.prototype);
    Object.defineProperty(clone, 'name', { value: value.name, writable: false });
    Object.defineProperty(clone, 'length', { value: value.length, writable: false });
    Object.assign(clone, value);
    return clone;
};


internals.dependency = function (schema, rel, key, peers, options) {

    assert(key === null || typeof key === 'string', rel, 'key must be a strings');

    // Extract options from peers array

    if (!options) {
        options = peers.length > 1 && typeof peers[peers.length - 1] === 'object' ? peers.pop() : {};
    }

    Common.assertOptions(options, ['separator', 'isPresent']);

    peers = [].concat(peers);

    // Cast peer paths

    const separator = Common.default(options.separator, '.');
    const paths = [];
    for (const peer of peers) {
        assert(typeof peer === 'string', rel, 'peers must be strings');
        paths.push(Compile.ref(peer, { separator, ancestor: 0, prefix: false }));
    }

    // Cast key

    if (key !== null) {
        key = Compile.ref(key, { separator, ancestor: 0, prefix: false });
    }

    // Add rule

    const obj = schema.clone();
    obj.$_terms.dependencies = obj.$_terms.dependencies || [];
    obj.$_terms.dependencies.push(new internals.Dependency(rel, key, paths, peers, options));
    return obj;
};


internals.dependencies = {

    and(schema, dep, value, state, prefs) {

        const missing = [];
        const present = [];
        const count = dep.peers.length;
        const isPresent = internals.isPresent(dep.options);
        for (const peer of dep.peers) {
            if (isPresent(peer.resolve(value, state, prefs, null, { shadow: false })) === false) {
                missing.push(peer.key);
            }
            else {
                present.push(peer.key);
            }
        }

        if (missing.length !== count &&
            present.length !== count) {

            return {
                code: 'object.and',
                context: {
                    present,
                    presentWithLabels: internals.keysToLabels(schema, present),
                    missing,
                    missingWithLabels: internals.keysToLabels(schema, missing)
                }
            };
        }
    },

    nand(schema, dep, value, state, prefs) {

        const present = [];
        const isPresent = internals.isPresent(dep.options);
        for (const peer of dep.peers) {
            if (isPresent(peer.resolve(value, state, prefs, null, { shadow: false }))) {
                present.push(peer.key);
            }
        }

        if (present.length !== dep.peers.length) {
            return;
        }

        const main = dep.paths[0];
        const values = dep.paths.slice(1);
        return {
            code: 'object.nand',
            context: {
                main,
                mainWithLabel: internals.keysToLabels(schema, main),
                peers: values,
                peersWithLabels: internals.keysToLabels(schema, values)
            }
        };
    },

    or(schema, dep, value, state, prefs) {

        const isPresent = internals.isPresent(dep.options);
        for (const peer of dep.peers) {
            if (isPresent(peer.resolve(value, state, prefs, null, { shadow: false }))) {
                return;
            }
        }

        return {
            code: 'object.missing',
            context: {
                peers: dep.paths,
                peersWithLabels: internals.keysToLabels(schema, dep.paths)
            }
        };
    },

    oxor(schema, dep, value, state, prefs) {

        const present = [];
        const isPresent = internals.isPresent(dep.options);
        for (const peer of dep.peers) {
            if (isPresent(peer.resolve(value, state, prefs, null, { shadow: false }))) {
                present.push(peer.key);
            }
        }

        if (!present.length ||
            present.length === 1) {

            return;
        }

        const context = { peers: dep.paths, peersWithLabels: internals.keysToLabels(schema, dep.paths) };
        context.present = present;
        context.presentWithLabels = internals.keysToLabels(schema, present);
        return { code: 'object.oxor', context };
    },

    with(schema, dep, value, state, prefs) {

        const isPresent = internals.isPresent(dep.options);
        for (const peer of dep.peers) {
            if (isPresent(peer.resolve(value, state, prefs, null, { shadow: false })) === false) {
                return {
                    code: 'object.with',
                    context: {
                        main: dep.key.key,
                        mainWithLabel: internals.keysToLabels(schema, dep.key.key),
                        peer: peer.key,
                        peerWithLabel: internals.keysToLabels(schema, peer.key)
                    }
                };
            }
        }
    },

    without(schema, dep, value, state, prefs) {

        const isPresent = internals.isPresent(dep.options);
        for (const peer of dep.peers) {
            if (isPresent(peer.resolve(value, state, prefs, null, { shadow: false }))) {
                return {
                    code: 'object.without',
                    context: {
                        main: dep.key.key,
                        mainWithLabel: internals.keysToLabels(schema, dep.key.key),
                        peer: peer.key,
                        peerWithLabel: internals.keysToLabels(schema, peer.key)
                    }
                };
            }
        }
    },

    xor(schema, dep, value, state, prefs) {

        const present = [];
        const isPresent = internals.isPresent(dep.options);
        for (const peer of dep.peers) {
            if (isPresent(peer.resolve(value, state, prefs, null, { shadow: false }))) {
                present.push(peer.key);
            }
        }

        if (present.length === 1) {
            return;
        }

        const context = { peers: dep.paths, peersWithLabels: internals.keysToLabels(schema, dep.paths) };
        if (present.length === 0) {
            return { code: 'object.missing', context };
        }

        context.present = present;
        context.presentWithLabels = internals.keysToLabels(schema, present);
        return { code: 'object.xor', context };
    }
};


internals.keysToLabels = function (schema, keys) {

    if (Array.isArray(keys)) {
        return keys.map((key) => schema.$_mapLabels(key));
    }

    return schema.$_mapLabels(keys);
};


internals.isPresent = function (options) {

    return typeof options.isPresent === 'function' ? options.isPresent : (resolved) => resolved !== undefined;
};


internals.rename = function (schema, value, state, prefs, errors) {

    const renamed = {};
    for (const rename of schema.$_terms.renames) {
        const matches = [];
        const pattern = typeof rename.from !== 'string';

        if (!pattern) {
            if (Object.prototype.hasOwnProperty.call(value, rename.from) &&
                (value[rename.from] !== undefined || !rename.options.ignoreUndefined)) {

                matches.push(rename);
            }
        }
        else {
            for (const from in value) {
                if (value[from] === undefined &&
                    rename.options.ignoreUndefined) {

                    continue;
                }

                if (from === rename.to) {
                    continue;
                }

                const match = rename.from.exec(from);
                if (!match) {
                    continue;
                }

                matches.push({ from, to: rename.to, match });
            }
        }

        for (const match of matches) {
            const from = match.from;
            let to = match.to;
            if (to instanceof Template) {
                to = to.render(value, state, prefs, match.match);
            }

            if (from === to) {
                continue;
            }

            if (!rename.options.multiple &&
                renamed[to]) {

                errors.push(schema.$_createError('object.rename.multiple', value, { from, to, pattern }, state, prefs));
                if (prefs.abortEarly) {
                    return false;
                }
            }

            if (Object.prototype.hasOwnProperty.call(value, to) &&
                !rename.options.override &&
                !renamed[to]) {

                errors.push(schema.$_createError('object.rename.override', value, { from, to, pattern }, state, prefs));
                if (prefs.abortEarly) {
                    return false;
                }
            }

            if (value[from] === undefined) {
                delete value[to];
            }
            else {
                value[to] = value[from];
            }

            renamed[to] = true;

            if (!rename.options.alias) {
                delete value[from];
            }
        }
    }

    return true;
};


internals.unknown = function (schema, value, unprocessed, errors, state, prefs) {

    if (schema.$_terms.patterns) {
        let hasMatches = false;
        const matches = schema.$_terms.patterns.map((pattern) => {

            if (pattern.matches) {
                hasMatches = true;
                return [];
            }
        });

        const ancestors = [value, ...state.ancestors];

        for (const key of unprocessed) {
            const item = value[key];
            const path = [...state.path, key];

            for (let i = 0; i < schema.$_terms.patterns.length; ++i) {
                const pattern = schema.$_terms.patterns[i];
                if (pattern.regex) {
                    const match = pattern.regex.test(key);
                    state.mainstay.tracer.debug(state, 'rule', `pattern.${i}`, match ? 'pass' : 'error');
                    if (!match) {
                        continue;
                    }
                }
                else {
                    if (!pattern.schema.$_match(key, state.nest(pattern.schema, `pattern.${i}`), prefs)) {
                        continue;
                    }
                }

                unprocessed.delete(key);

                const localState = state.localize(path, ancestors, { schema: pattern.rule, key });
                const result = pattern.rule.$_validate(item, localState, prefs);
                if (result.errors) {
                    if (prefs.abortEarly) {
                        return { value, errors: result.errors };
                    }

                    errors.push(...result.errors);
                }

                if (pattern.matches) {
                    matches[i].push(key);
                }

                value[key] = result.value;
                if (!pattern.fallthrough) {
                    break;
                }
            }
        }

        // Validate pattern matches rules

        if (hasMatches) {
            for (let i = 0; i < matches.length; ++i) {
                const match = matches[i];
                if (!match) {
                    continue;
                }

                const stpm = schema.$_terms.patterns[i].matches;
                const localState = state.localize(state.path, ancestors, stpm);
                const result = stpm.$_validate(match, localState, prefs);
                if (result.errors) {
                    const details = Errors.details(result.errors, { override: false });
                    details.matches = match;
                    const report = schema.$_createError('object.pattern.match', value, details, state, prefs);
                    if (prefs.abortEarly) {
                        return { value, errors: report };
                    }

                    errors.push(report);
                }
            }
        }
    }

    if (!unprocessed.size ||
        !schema.$_terms.keys && !schema.$_terms.patterns) {     // If no keys or patterns specified, unknown keys allowed

        return;
    }

    if (prefs.stripUnknown && typeof schema._flags.unknown === 'undefined' ||
        prefs.skipFunctions) {

        const stripUnknown = prefs.stripUnknown ? (prefs.stripUnknown === true ? true : !!prefs.stripUnknown.objects) : false;

        for (const key of unprocessed) {
            if (stripUnknown) {
                delete value[key];
                unprocessed.delete(key);
            }
            else if (typeof value[key] === 'function') {
                unprocessed.delete(key);
            }
        }
    }

    const forbidUnknown = !Common.default(schema._flags.unknown, prefs.allowUnknown);
    if (forbidUnknown) {
        for (const unprocessedKey of unprocessed) {
            const localState = state.localize([...state.path, unprocessedKey], []);
            const report = schema.$_createError('object.unknown', value[unprocessedKey], { child: unprocessedKey }, localState, prefs, { flags: false });
            if (prefs.abortEarly) {
                return { value, errors: report };
            }

            errors.push(report);
        }
    }
};


internals.Dependency = class {

    constructor(rel, key, peers, paths, options) {

        this.rel = rel;
        this.key = key;
        this.peers = peers;
        this.paths = paths;
        this.options = options;
    }

    describe() {

        const desc = {
            rel: this.rel,
            peers: this.paths
        };

        if (this.key !== null) {
            desc.key = this.key.key;
        }

        if (this.peers[0].separator !== '.') {
            desc.options = { ...desc.options, separator: this.peers[0].separator };
        }

        if (this.options.isPresent) {
            desc.options = { ...desc.options, isPresent: this.options.isPresent };
        }

        return desc;
    }
};


internals.Keys = class extends Array {

    concat(source) {

        const result = this.slice();

        const keys = new Map();
        for (let i = 0; i < result.length; ++i) {
            keys.set(result[i].key, i);
        }

        for (const item of source) {
            const key = item.key;
            const pos = keys.get(key);
            if (pos !== undefined) {
                result[pos] = { key, schema: result[pos].schema.concat(item.schema) };
            }
            else {
                result.push(item);
            }
        }

        return result;
    }
};


/***/ }),

/***/ 30810:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


const { assert } = __nccwpck_require__(91884);

const Any = __nccwpck_require__(49046);
const Common = __nccwpck_require__(84205);
const Compile = __nccwpck_require__(14743);
const Errors = __nccwpck_require__(11543);


const internals = {};


module.exports = Any.extend({

    type: 'link',

    properties: {
        schemaChain: true
    },

    terms: {

        link: { init: null, manifest: 'single', register: false }
    },

    args(schema, ref) {

        return schema.ref(ref);
    },

    validate(value, { schema, state, prefs }) {

        assert(schema.$_terms.link, 'Uninitialized link schema');

        const linked = internals.generate(schema, value, state, prefs);
        const ref = schema.$_terms.link[0].ref;
        return linked.$_validate(value, state.nest(linked, `link:${ref.display}:${linked.type}`), prefs);
    },

    generate(schema, value, state, prefs) {

        return internals.generate(schema, value, state, prefs);
    },

    rules: {

        ref: {
            method(ref) {

                assert(!this.$_terms.link, 'Cannot reinitialize schema');

                ref = Compile.ref(ref);

                assert(ref.type === 'value' || ref.type === 'local', 'Invalid reference type:', ref.type);
                assert(ref.type === 'local' || ref.ancestor === 'root' || ref.ancestor > 0, 'Link cannot reference itself');

                const obj = this.clone();
                obj.$_terms.link = [{ ref }];
                return obj;
            }
        },

        relative: {
            method(enabled = true) {

                return this.$_setFlag('relative', enabled);
            }
        }
    },

    overrides: {

        concat(source) {

            assert(this.$_terms.link, 'Uninitialized link schema');
            assert(Common.isSchema(source), 'Invalid schema object');
            assert(source.type !== 'link', 'Cannot merge type link with another link');

            const obj = this.clone();

            if (!obj.$_terms.whens) {
                obj.$_terms.whens = [];
            }

            obj.$_terms.whens.push({ concat: source });
            return obj.$_mutateRebuild();
        }
    },

    manifest: {

        build(obj, desc) {

            assert(desc.link, 'Invalid link description missing link');
            return obj.ref(desc.link);
        }
    }
});


// Helpers

internals.generate = function (schema, value, state, prefs) {

    let linked = state.mainstay.links.get(schema);
    if (linked) {
        return linked._generate(value, state, prefs).schema;
    }

    const ref = schema.$_terms.link[0].ref;
    const { perspective, path } = internals.perspective(ref, state);
    internals.assert(perspective, 'which is outside of schema boundaries', ref, schema, state, prefs);

    try {
        linked = path.length ? perspective.$_reach(path) : perspective;
    }
    catch {
        internals.assert(false, 'to non-existing schema', ref, schema, state, prefs);
    }

    internals.assert(linked.type !== 'link', 'which is another link', ref, schema, state, prefs);

    if (!schema._flags.relative) {
        state.mainstay.links.set(schema, linked);
    }

    return linked._generate(value, state, prefs).schema;
};


internals.perspective = function (ref, state) {

    if (ref.type === 'local') {
        for (const { schema, key } of state.schemas) {                              // From parent to root
            const id = schema._flags.id || key;
            if (id === ref.path[0]) {
                return { perspective: schema, path: ref.path.slice(1) };
            }

            if (schema.$_terms.shared) {
                for (const shared of schema.$_terms.shared) {
                    if (shared._flags.id === ref.path[0]) {
                        return { perspective: shared, path: ref.path.slice(1) };
                    }
                }
            }
        }

        return { perspective: null, path: null };
    }

    if (ref.ancestor === 'root') {
        return { perspective: state.schemas[state.schemas.length - 1].schema, path: ref.path };
    }

    return { perspective: state.schemas[ref.ancestor] && state.schemas[ref.ancestor].schema, path: ref.path };
};


internals.assert = function (condition, message, ref, schema, state, prefs) {

    if (condition) {                // Manual check to avoid generating error message on success
        return;
    }

    assert(false, `"${Errors.label(schema._flags, state, prefs)}" contains link reference "${ref.display}" ${message}`);
};


/***/ }),

/***/ 84599:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


const { assert } = __nccwpck_require__(91884);

const Any = __nccwpck_require__(49046);
const Common = __nccwpck_require__(84205);


const internals = {
    numberRx: /^\s*[+-]?(?:(?:\d+(?:\.\d*)?)|(?:\.\d+))(?:e([+-]?\d+))?\s*$/i,
    precisionRx: /(?:\.(\d+))?(?:[eE]([+-]?\d+))?$/,
    exponentialPartRegex: /[eE][+-]?\d+$/,
    leadingSignAndZerosRegex: /^[+-]?(0*)?/,
    dotRegex: /\./,
    trailingZerosRegex: /0+$/,
    decimalPlaces(value) {

        const str = value.toString();
        const dindex = str.indexOf('.');
        const eindex = str.indexOf('e');
        return (
            (dindex < 0 ? 0 : (eindex < 0 ? str.length : eindex) - dindex - 1) +
            (eindex < 0 ? 0 : Math.max(0, -parseInt(str.slice(eindex + 1))))
        );
    }
};


module.exports = Any.extend({

    type: 'number',

    flags: {

        unsafe: { default: false }
    },

    coerce: {
        from: 'string',
        method(value, { schema, error }) {

            const matches = value.match(internals.numberRx);
            if (!matches) {
                return;
            }

            value = value.trim();
            const result = { value: parseFloat(value) };

            if (result.value === 0) {
                result.value = 0;           // -0
            }

            if (!schema._flags.unsafe) {
                if (value.match(/e/i)) {
                    if (internals.extractSignificantDigits(value) !== internals.extractSignificantDigits(String(result.value))) {
                        result.errors = error('number.unsafe');
                        return result;
                    }
                }
                else {
                    const string = result.value.toString();
                    if (string.match(/e/i)) {
                        return result;
                    }

                    if (string !== internals.normalizeDecimal(value)) {
                        result.errors = error('number.unsafe');
                        return result;
                    }
                }
            }

            return result;
        }
    },

    validate(value, { schema, error, prefs }) {

        if (value === Infinity ||
            value === -Infinity) {

            return { value, errors: error('number.infinity') };
        }

        if (!Common.isNumber(value)) {
            return { value, errors: error('number.base') };
        }

        const result = { value };

        if (prefs.convert) {
            const rule = schema.$_getRule('precision');
            if (rule) {
                const precision = Math.pow(10, rule.args.limit);                    // This is conceptually equivalent to using toFixed but it should be much faster
                result.value = Math.round(result.value * precision) / precision;
            }
        }

        if (result.value === 0) {
            result.value = 0;           // -0
        }

        if (!schema._flags.unsafe &&
            (value > Number.MAX_SAFE_INTEGER || value < Number.MIN_SAFE_INTEGER)) {

            result.errors = error('number.unsafe');
        }

        return result;
    },

    rules: {

        compare: {
            method: false,
            validate(value, helpers, { limit }, { name, operator, args }) {

                if (Common.compare(value, limit, operator)) {
                    return value;
                }

                return helpers.error('number.' + name, { limit: args.limit, value });
            },
            args: [
                {
                    name: 'limit',
                    ref: true,
                    assert: Common.isNumber,
                    message: 'must be a number'
                }
            ]
        },

        greater: {
            method(limit) {

                return this.$_addRule({ name: 'greater', method: 'compare', args: { limit }, operator: '>' });
            }
        },

        integer: {
            method() {

                return this.$_addRule('integer');
            },
            validate(value, helpers) {

                if (Math.trunc(value) - value === 0) {
                    return value;
                }

                return helpers.error('number.integer');
            }
        },

        less: {
            method(limit) {

                return this.$_addRule({ name: 'less', method: 'compare', args: { limit }, operator: '<' });
            }
        },

        max: {
            method(limit) {

                return this.$_addRule({ name: 'max', method: 'compare', args: { limit }, operator: '<=' });
            }
        },

        min: {
            method(limit) {

                return this.$_addRule({ name: 'min', method: 'compare', args: { limit }, operator: '>=' });
            }
        },

        multiple: {
            method(base) {

                const baseDecimalPlace = typeof base === 'number' ? internals.decimalPlaces(base) : null;
                const pfactor = Math.pow(10, baseDecimalPlace);

                return this.$_addRule({
                    name: 'multiple',
                    args: {
                        base,
                        baseDecimalPlace,
                        pfactor
                    }
                });
            },
            validate(value, helpers, { base, baseDecimalPlace, pfactor }, options) {

                const valueDecimalPlace = internals.decimalPlaces(value);

                if (valueDecimalPlace > baseDecimalPlace) {
                    // Value with higher precision than base can never be a multiple
                    return helpers.error('number.multiple', { multiple: options.args.base, value });
                }

                return Math.round(pfactor * value) % Math.round(pfactor * base) === 0 ?
                    value :
                    helpers.error('number.multiple', { multiple: options.args.base, value });
            },
            args: [
                {
                    name: 'base',
                    ref: true,
                    assert: (value) => typeof value === 'number' && isFinite(value) && value > 0,
                    message: 'must be a positive number'
                },
                'baseDecimalPlace',
                'pfactor'
            ],
            multi: true
        },

        negative: {
            method() {

                return this.sign('negative');
            }
        },

        port: {
            method() {

                return this.$_addRule('port');
            },
            validate(value, helpers) {

                if (Number.isSafeInteger(value) &&
                    value >= 0 &&
                    value <= 65535) {

                    return value;
                }

                return helpers.error('number.port');
            }
        },

        positive: {
            method() {

                return this.sign('positive');
            }
        },

        precision: {
            method(limit) {

                assert(Number.isSafeInteger(limit), 'limit must be an integer');

                return this.$_addRule({ name: 'precision', args: { limit } });
            },
            validate(value, helpers, { limit }) {

                const places = value.toString().match(internals.precisionRx);
                const decimals = Math.max((places[1] ? places[1].length : 0) - (places[2] ? parseInt(places[2], 10) : 0), 0);
                if (decimals <= limit) {
                    return value;
                }

                return helpers.error('number.precision', { limit, value });
            },
            convert: true
        },

        sign: {
            method(sign) {

                assert(['negative', 'positive'].includes(sign), 'Invalid sign', sign);

                return this.$_addRule({ name: 'sign', args: { sign } });
            },
            validate(value, helpers, { sign }) {

                if (sign === 'negative' && value < 0 ||
                    sign === 'positive' && value > 0) {

                    return value;
                }

                return helpers.error(`number.${sign}`);
            }
        },

        unsafe: {
            method(enabled = true) {

                assert(typeof enabled === 'boolean', 'enabled must be a boolean');

                return this.$_setFlag('unsafe', enabled);
            }
        }
    },

    cast: {
        string: {
            from: (value) => typeof value === 'number',
            to(value, helpers) {

                return value.toString();
            }
        }
    },

    messages: {
        'number.base': '{{#label}} must be a number',
        'number.greater': '{{#label}} must be greater than {{#limit}}',
        'number.infinity': '{{#label}} cannot be infinity',
        'number.integer': '{{#label}} must be an integer',
        'number.less': '{{#label}} must be less than {{#limit}}',
        'number.max': '{{#label}} must be less than or equal to {{#limit}}',
        'number.min': '{{#label}} must be greater than or equal to {{#limit}}',
        'number.multiple': '{{#label}} must be a multiple of {{#multiple}}',
        'number.negative': '{{#label}} must be a negative number',
        'number.port': '{{#label}} must be a valid port',
        'number.positive': '{{#label}} must be a positive number',
        'number.precision': '{{#label}} must have no more than {{#limit}} decimal places',
        'number.unsafe': '{{#label}} must be a safe number'
    }
});


// Helpers

internals.extractSignificantDigits = function (value) {

    return value
        .replace(internals.exponentialPartRegex, '')
        .replace(internals.dotRegex, '')
        .replace(internals.trailingZerosRegex, '')
        .replace(internals.leadingSignAndZerosRegex, '');
};


internals.normalizeDecimal = function (str) {

    str = str
        // Remove leading plus signs
        .replace(/^\+/, '')
        // Remove trailing zeros if there is a decimal point and unecessary decimal points
        .replace(/\.0*$/, '')
        // Add a integer 0 if the numbers starts with a decimal point
        .replace(/^(-?)\.([^\.]*)$/, '$10.$2')
        // Remove leading zeros
        .replace(/^(-?)0+([0-9])/, '$1$2');

    if (str.includes('.') &&
        str.endsWith('0')) {

        str = str.replace(/0+$/, '');
    }

    if (str === '-0') {
        return '0';
    }

    return str;
};


/***/ }),

/***/ 85869:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


const Keys = __nccwpck_require__(14462);


const internals = {};


module.exports = Keys.extend({

    type: 'object',

    cast: {
        map: {
            from: (value) => value && typeof value === 'object',
            to(value, helpers) {

                return new Map(Object.entries(value));
            }
        }
    }
});


/***/ }),

/***/ 72423:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


const { assert, escapeRegex } = __nccwpck_require__(91884);
const { isDomainValid, isEmailValid, ipRegex, uriRegex } = __nccwpck_require__(12336);
const Tlds = __nccwpck_require__(33397);

const Any = __nccwpck_require__(49046);
const Common = __nccwpck_require__(84205);


const internals = {
    tlds: Tlds.tlds instanceof Set ? { tlds: { allow: Tlds.tlds, deny: null } } : false,              // $lab:coverage:ignore$
    base64Regex: {
        // paddingRequired
        true: {
            // urlSafe
            true: /^(?:[\w\-]{2}[\w\-]{2})*(?:[\w\-]{2}==|[\w\-]{3}=)?$/,
            false: /^(?:[A-Za-z0-9+\/]{2}[A-Za-z0-9+\/]{2})*(?:[A-Za-z0-9+\/]{2}==|[A-Za-z0-9+\/]{3}=)?$/
        },
        false: {
            true: /^(?:[\w\-]{2}[\w\-]{2})*(?:[\w\-]{2}(==)?|[\w\-]{3}=?)?$/,
            false: /^(?:[A-Za-z0-9+\/]{2}[A-Za-z0-9+\/]{2})*(?:[A-Za-z0-9+\/]{2}(==)?|[A-Za-z0-9+\/]{3}=?)?$/
        }
    },
    dataUriRegex: /^data:[\w+.-]+\/[\w+.-]+;((charset=[\w-]+|base64),)?(.*)$/,
    hexRegex: {
        withPrefix: /^0x[0-9a-f]+$/i,
        withOptionalPrefix: /^(?:0x)?[0-9a-f]+$/i,
        withoutPrefix: /^[0-9a-f]+$/i
    },
    ipRegex: ipRegex({ cidr: 'forbidden' }).regex,
    isoDurationRegex: /^P(?!$)(\d+Y)?(\d+M)?(\d+W)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+S)?)?$/,

    guidBrackets: {
        '{': '}', '[': ']', '(': ')', '': ''
    },
    guidVersions: {
        uuidv1: '1',
        uuidv2: '2',
        uuidv3: '3',
        uuidv4: '4',
        uuidv5: '5',
        uuidv6: '6',
        uuidv7: '7',
        uuidv8: '8'
    },
    guidSeparators: new Set([undefined, true, false, '-', ':']),

    normalizationForms: ['NFC', 'NFD', 'NFKC', 'NFKD']
};


module.exports = Any.extend({

    type: 'string',

    flags: {

        insensitive: { default: false },
        truncate: { default: false }
    },

    terms: {

        replacements: { init: null }
    },

    coerce: {
        from: 'string',
        method(value, { schema, state, prefs }) {

            const normalize = schema.$_getRule('normalize');
            if (normalize) {
                value = value.normalize(normalize.args.form);
            }

            const casing = schema.$_getRule('case');
            if (casing) {
                value = casing.args.direction === 'upper' ? value.toLocaleUpperCase() : value.toLocaleLowerCase();
            }

            const trim = schema.$_getRule('trim');
            if (trim &&
                trim.args.enabled) {

                value = value.trim();
            }

            if (schema.$_terms.replacements) {
                for (const replacement of schema.$_terms.replacements) {
                    value = value.replace(replacement.pattern, replacement.replacement);
                }
            }

            const hex = schema.$_getRule('hex');
            if (hex &&
                hex.args.options.byteAligned &&
                value.length % 2 !== 0) {

                value = `0${value}`;
            }

            if (schema.$_getRule('isoDate')) {
                const iso = internals.isoDate(value);
                if (iso) {
                    value = iso;
                }
            }

            if (schema._flags.truncate) {
                const rule = schema.$_getRule('max');
                if (rule) {
                    let limit = rule.args.limit;
                    if (Common.isResolvable(limit)) {
                        limit = limit.resolve(value, state, prefs);
                        if (!Common.limit(limit)) {
                            return { value, errors: schema.$_createError('any.ref', limit, { ref: rule.args.limit, arg: 'limit', reason: 'must be a positive integer' }, state, prefs) };
                        }
                    }

                    value = value.slice(0, limit);
                }
            }

            return { value };
        }
    },

    validate(value, { schema, error }) {

        if (typeof value !== 'string') {
            return { value, errors: error('string.base') };
        }

        if (value === '') {
            const min = schema.$_getRule('min');
            if (min &&
                min.args.limit === 0) {

                return;
            }

            return { value, errors: error('string.empty') };
        }
    },

    rules: {

        alphanum: {
            method() {

                return this.$_addRule('alphanum');
            },
            validate(value, helpers) {

                if (/^[a-zA-Z0-9]+$/.test(value)) {
                    return value;
                }

                return helpers.error('string.alphanum');
            }
        },

        base64: {
            method(options = {}) {

                Common.assertOptions(options, ['paddingRequired', 'urlSafe']);

                options = { urlSafe: false, paddingRequired: true, ...options };
                assert(typeof options.paddingRequired === 'boolean', 'paddingRequired must be boolean');
                assert(typeof options.urlSafe === 'boolean', 'urlSafe must be boolean');

                return this.$_addRule({ name: 'base64', args: { options } });
            },
            validate(value, helpers, { options }) {

                const regex = internals.base64Regex[options.paddingRequired][options.urlSafe];
                if (regex.test(value)) {
                    return value;
                }

                return helpers.error('string.base64');
            }
        },

        case: {
            method(direction) {

                assert(['lower', 'upper'].includes(direction), 'Invalid case:', direction);

                return this.$_addRule({ name: 'case', args: { direction } });
            },
            validate(value, helpers, { direction }) {

                if (direction === 'lower' && value === value.toLocaleLowerCase() ||
                    direction === 'upper' && value === value.toLocaleUpperCase()) {

                    return value;
                }

                return helpers.error(`string.${direction}case`);
            },
            convert: true
        },

        creditCard: {
            method() {

                return this.$_addRule('creditCard');
            },
            validate(value, helpers) {

                let i = value.length;
                let sum = 0;
                let mul = 1;

                while (i--) {
                    const char = value.charAt(i) * mul;
                    sum = sum + (char - (char > 9) * 9);
                    mul = mul ^ 3;
                }

                if (sum > 0 &&
                    sum % 10 === 0) {

                    return value;
                }

                return helpers.error('string.creditCard');
            }
        },

        dataUri: {
            method(options = {}) {

                Common.assertOptions(options, ['paddingRequired']);

                options = { paddingRequired: true, ...options };
                assert(typeof options.paddingRequired === 'boolean', 'paddingRequired must be boolean');

                return this.$_addRule({ name: 'dataUri', args: { options } });
            },
            validate(value, helpers, { options }) {

                const matches = value.match(internals.dataUriRegex);

                if (matches) {
                    if (!matches[2]) {
                        return value;
                    }

                    if (matches[2] !== 'base64') {
                        return value;
                    }

                    const base64regex = internals.base64Regex[options.paddingRequired].false;
                    if (base64regex.test(matches[3])) {
                        return value;
                    }
                }

                return helpers.error('string.dataUri');
            }
        },

        domain: {
            method(options) {

                if (options) {
                    Common.assertOptions(options, ['allowFullyQualified', 'allowUnicode', 'allowUnderscore', 'maxDomainSegments', 'minDomainSegments', 'tlds']);
                }

                const address = internals.addressOptions(options);
                return this.$_addRule({ name: 'domain', args: { options }, address });
            },
            validate(value, helpers, args, { address }) {

                if (isDomainValid(value, address)) {
                    return value;
                }

                return helpers.error('string.domain');
            }
        },

        email: {
            method(options = {}) {

                Common.assertOptions(options, ['allowFullyQualified', 'allowUnicode', 'ignoreLength', 'maxDomainSegments', 'minDomainSegments', 'multiple', 'separator', 'tlds']);
                assert(options.multiple === undefined || typeof options.multiple === 'boolean', 'multiple option must be an boolean');

                const address = internals.addressOptions(options);
                const regex = new RegExp(`\\s*[${options.separator ? escapeRegex(options.separator) : ','}]\\s*`);

                return this.$_addRule({ name: 'email', args: { options }, regex, address });
            },
            validate(value, helpers, { options }, { regex, address }) {

                const emails = options.multiple ? value.split(regex) : [value];
                const invalids = [];
                for (const email of emails) {
                    if (!isEmailValid(email, address)) {
                        invalids.push(email);
                    }
                }

                if (!invalids.length) {
                    return value;
                }

                return helpers.error('string.email', { value, invalids });
            }
        },

        guid: {
            alias: 'uuid',
            method(options = {}) {

                Common.assertOptions(options, ['version', 'separator', 'wrapper']);

                assert(
                    options.wrapper === undefined ||
                    typeof options.wrapper === 'boolean' ||
                    (typeof options.wrapper === 'string' && typeof internals.guidBrackets[options.wrapper] === 'string'),
                    `"wrapper" must be true, false, or one of "${Object.keys(internals.guidBrackets).filter(Boolean).join('", "')}"`
                );

                let versionNumbers = '';

                if (options.version) {
                    const versions = [].concat(options.version);

                    assert(versions.length >= 1, 'version must have at least 1 valid version specified');
                    const set = new Set();

                    for (let i = 0; i < versions.length; ++i) {
                        const version = versions[i];
                        assert(typeof version === 'string', 'version at position ' + i + ' must be a string');
                        const versionNumber = internals.guidVersions[version.toLowerCase()];
                        assert(versionNumber, 'version at position ' + i + ' must be one of ' + Object.keys(internals.guidVersions).join(', '));
                        assert(!set.has(versionNumber), 'version at position ' + i + ' must not be a duplicate');

                        versionNumbers += versionNumber;
                        set.add(versionNumber);
                    }
                }

                assert(internals.guidSeparators.has(options.separator), 'separator must be one of true, false, "-", or ":"');
                const separator = options.separator === undefined ? '[:-]?' :
                    options.separator === true ? '[:-]' :
                        options.separator === false ? '[]?' : `\\${options.separator}`;

                let wrapperStart;
                let wrapperEnd;

                if (options.wrapper === undefined) {
                    wrapperStart = '[\\[{\\(]?';
                    wrapperEnd = '[\\]}\\)]?';
                }
                else if (options.wrapper === true) {
                    wrapperStart = '[\\[{\\(]';
                    wrapperEnd = '[\\]}\\)]';
                }
                else if (options.wrapper === false) {
                    wrapperStart = '';
                    wrapperEnd = '';
                }
                else {
                    wrapperStart = escapeRegex(options.wrapper);
                    wrapperEnd = escapeRegex(internals.guidBrackets[options.wrapper]);
                }

                const regex = new RegExp(
                    `^(${wrapperStart})[0-9A-F]{8}(${separator})[0-9A-F]{4}\\2?[${
                        versionNumbers || '0-9A-F'
                    }][0-9A-F]{3}\\2?[${
                        versionNumbers ? '89AB' : '0-9A-F'
                    }][0-9A-F]{3}\\2?[0-9A-F]{12}(${wrapperEnd})$`,
                    'i'
                );

                return this.$_addRule({ name: 'guid', args: { options }, regex });
            },

            validate(value, helpers, args, { regex }) {

                const results = regex.exec(value);

                if (!results) {
                    return helpers.error('string.guid');
                }

                const open = results[1];
                const close = results[results.length - 1];

                if ((open || close) && internals.guidBrackets[open] !== close) {
                    return helpers.error('string.guid');
                }

                return value;
            }
        },

        hex: {
            method(options = {}) {

                Common.assertOptions(options, ['byteAligned', 'prefix']);

                options = { byteAligned: false, prefix: false, ...options };
                assert(typeof options.byteAligned === 'boolean', 'byteAligned must be boolean');
                assert(typeof options.prefix === 'boolean' || options.prefix === 'optional', 'prefix must be boolean or "optional"');

                return this.$_addRule({ name: 'hex', args: { options } });
            },
            validate(value, helpers, { options }) {

                const re = options.prefix === 'optional' ?
                    internals.hexRegex.withOptionalPrefix :
                    options.prefix === true ?
                        internals.hexRegex.withPrefix :
                        internals.hexRegex.withoutPrefix;
                if (!re.test(value)) {
                    return helpers.error('string.hex');
                }

                if (options.byteAligned &&
                    value.length % 2 !== 0) {

                    return helpers.error('string.hexAlign');
                }

                return value;
            }
        },

        hostname: {
            method() {

                return this.$_addRule('hostname');
            },
            validate(value, helpers) {

                if (isDomainValid(value, { minDomainSegments: 1 }) ||
                    internals.ipRegex.test(value)) {

                    return value;
                }

                return helpers.error('string.hostname');
            }
        },

        insensitive: {
            method() {

                return this.$_setFlag('insensitive', true);
            }
        },

        ip: {
            method(options = {}) {

                Common.assertOptions(options, ['cidr', 'version']);

                const { cidr, versions, regex } = ipRegex(options);
                const version = options.version ? versions : undefined;
                return this.$_addRule({ name: 'ip', args: { options: { cidr, version } }, regex });
            },
            validate(value, helpers, { options }, { regex }) {

                if (regex.test(value)) {
                    return value;
                }

                if (options.version) {
                    return helpers.error('string.ipVersion', { value, cidr: options.cidr, version: options.version });
                }

                return helpers.error('string.ip', { value, cidr: options.cidr });
            }
        },

        isoDate: {
            method() {

                return this.$_addRule('isoDate');
            },
            validate(value, { error }) {

                if (internals.isoDate(value)) {
                    return value;
                }

                return error('string.isoDate');
            }
        },

        isoDuration: {
            method() {

                return this.$_addRule('isoDuration');
            },
            validate(value, helpers) {

                if (internals.isoDurationRegex.test(value)) {
                    return value;
                }

                return helpers.error('string.isoDuration');
            }
        },

        length: {
            method(limit, encoding) {

                return internals.length(this, 'length', limit, '=', encoding);
            },
            validate(value, helpers, { limit, encoding }, { name, operator, args }) {

                const length = encoding ? Buffer && Buffer.byteLength(value, encoding) : value.length;      // $lab:coverage:ignore$
                if (Common.compare(length, limit, operator)) {
                    return value;
                }

                return helpers.error('string.' + name, { limit: args.limit, value, encoding });
            },
            args: [
                {
                    name: 'limit',
                    ref: true,
                    assert: Common.limit,
                    message: 'must be a positive integer'
                },
                'encoding'
            ]
        },

        lowercase: {
            method() {

                return this.case('lower');
            }
        },

        max: {
            method(limit, encoding) {

                return internals.length(this, 'max', limit, '<=', encoding);
            },
            args: ['limit', 'encoding']
        },

        min: {
            method(limit, encoding) {

                return internals.length(this, 'min', limit, '>=', encoding);
            },
            args: ['limit', 'encoding']
        },

        normalize: {
            method(form = 'NFC') {

                assert(internals.normalizationForms.includes(form), 'normalization form must be one of ' + internals.normalizationForms.join(', '));

                return this.$_addRule({ name: 'normalize', args: { form } });
            },
            validate(value, { error }, { form }) {

                if (value === value.normalize(form)) {
                    return value;
                }

                return error('string.normalize', { value, form });
            },
            convert: true
        },

        pattern: {
            alias: 'regex',
            method(regex, options = {}) {

                assert(regex instanceof RegExp, 'regex must be a RegExp');
                assert(!regex.flags.includes('g') && !regex.flags.includes('y'), 'regex should not use global or sticky mode');

                if (typeof options === 'string') {
                    options = { name: options };
                }

                Common.assertOptions(options, ['invert', 'name']);

                const errorCode = ['string.pattern', options.invert ? '.invert' : '', options.name ? '.name' : '.base'].join('');
                return this.$_addRule({ name: 'pattern', args: { regex, options }, errorCode });
            },
            validate(value, helpers, { regex, options }, { errorCode }) {

                const patternMatch = regex.test(value);

                if (patternMatch ^ options.invert) {
                    return value;
                }

                return helpers.error(errorCode, { name: options.name, regex, value });
            },
            args: ['regex', 'options'],
            multi: true
        },

        replace: {
            method(pattern, replacement) {

                if (typeof pattern === 'string') {
                    pattern = new RegExp(escapeRegex(pattern), 'g');
                }

                assert(pattern instanceof RegExp, 'pattern must be a RegExp');
                assert(typeof replacement === 'string', 'replacement must be a String');

                const obj = this.clone();

                if (!obj.$_terms.replacements) {
                    obj.$_terms.replacements = [];
                }

                obj.$_terms.replacements.push({ pattern, replacement });
                return obj;
            }
        },

        token: {
            method() {

                return this.$_addRule('token');
            },
            validate(value, helpers) {

                if (/^\w+$/.test(value)) {
                    return value;
                }

                return helpers.error('string.token');
            }
        },

        trim: {
            method(enabled = true) {

                assert(typeof enabled === 'boolean', 'enabled must be a boolean');

                return this.$_addRule({ name: 'trim', args: { enabled } });
            },
            validate(value, helpers, { enabled }) {

                if (!enabled ||
                    value === value.trim()) {

                    return value;
                }

                return helpers.error('string.trim');
            },
            convert: true
        },

        truncate: {
            method(enabled = true) {

                assert(typeof enabled === 'boolean', 'enabled must be a boolean');

                return this.$_setFlag('truncate', enabled);
            }
        },

        uppercase: {
            method() {

                return this.case('upper');
            }
        },

        uri: {
            method(options = {}) {

                Common.assertOptions(options, ['allowRelative', 'allowQuerySquareBrackets', 'domain', 'relativeOnly', 'scheme', 'encodeUri']);

                if (options.domain) {
                    Common.assertOptions(options.domain, ['allowFullyQualified', 'allowUnicode', 'maxDomainSegments', 'minDomainSegments', 'tlds']);
                }

                const { regex, scheme } = uriRegex(options);
                const domain = options.domain ? internals.addressOptions(options.domain) : null;
                return this.$_addRule({ name: 'uri', args: { options }, regex, domain, scheme });
            },
            validate(value, helpers, { options }, { regex, domain, scheme }) {

                if (['http:/', 'https:/'].includes(value)) {            // scheme:/ is technically valid but makes no sense
                    return helpers.error('string.uri');
                }

                let match = regex.exec(value);

                if (!match && helpers.prefs.convert && options.encodeUri) {
                    const encoded = encodeURI(value);
                    match = regex.exec(encoded);
                    if (match) {
                        value = encoded;
                    }
                }

                if (match) {
                    const matched = match[1] || match[2];
                    if (domain &&
                        (!options.allowRelative || matched) &&
                        !isDomainValid(matched, domain)) {

                        return helpers.error('string.domain', { value: matched });
                    }

                    return value;
                }

                if (options.relativeOnly) {
                    return helpers.error('string.uriRelativeOnly');
                }

                if (options.scheme) {
                    return helpers.error('string.uriCustomScheme', { scheme, value });
                }

                return helpers.error('string.uri');
            }
        }
    },

    manifest: {

        build(obj, desc) {

            if (desc.replacements) {
                for (const { pattern, replacement } of desc.replacements) {
                    obj = obj.replace(pattern, replacement);
                }
            }

            return obj;
        }
    },

    messages: {
        'string.alphanum': '{{#label}} must only contain alpha-numeric characters',
        'string.base': '{{#label}} must be a string',
        'string.base64': '{{#label}} must be a valid base64 string',
        'string.creditCard': '{{#label}} must be a credit card',
        'string.dataUri': '{{#label}} must be a valid dataUri string',
        'string.domain': '{{#label}} must contain a valid domain name',
        'string.email': '{{#label}} must be a valid email',
        'string.empty': '{{#label}} is not allowed to be empty',
        'string.guid': '{{#label}} must be a valid GUID',
        'string.hex': '{{#label}} must only contain hexadecimal characters',
        'string.hexAlign': '{{#label}} hex decoded representation must be byte aligned',
        'string.hostname': '{{#label}} must be a valid hostname',
        'string.ip': '{{#label}} must be a valid ip address with a {{#cidr}} CIDR',
        'string.ipVersion': '{{#label}} must be a valid ip address of one of the following versions {{#version}} with a {{#cidr}} CIDR',
        'string.isoDate': '{{#label}} must be in iso format',
        'string.isoDuration': '{{#label}} must be a valid ISO 8601 duration',
        'string.length': '{{#label}} length must be {{#limit}} characters long',
        'string.lowercase': '{{#label}} must only contain lowercase characters',
        'string.max': '{{#label}} length must be less than or equal to {{#limit}} characters long',
        'string.min': '{{#label}} length must be at least {{#limit}} characters long',
        'string.normalize': '{{#label}} must be unicode normalized in the {{#form}} form',
        'string.token': '{{#label}} must only contain alpha-numeric and underscore characters',
        'string.pattern.base': '{{#label}} with value {:[.]} fails to match the required pattern: {{#regex}}',
        'string.pattern.name': '{{#label}} with value {:[.]} fails to match the {{#name}} pattern',
        'string.pattern.invert.base': '{{#label}} with value {:[.]} matches the inverted pattern: {{#regex}}',
        'string.pattern.invert.name': '{{#label}} with value {:[.]} matches the inverted {{#name}} pattern',
        'string.trim': '{{#label}} must not have leading or trailing whitespace',
        'string.uri': '{{#label}} must be a valid uri',
        'string.uriCustomScheme': '{{#label}} must be a valid uri with a scheme matching the {{#scheme}} pattern',
        'string.uriRelativeOnly': '{{#label}} must be a valid relative uri',
        'string.uppercase': '{{#label}} must only contain uppercase characters'
    }
});


// Helpers

internals.addressOptions = function (options) {

    if (!options) {
        return internals.tlds || options;      // $lab:coverage:ignore$
    }

    // minDomainSegments

    assert(options.minDomainSegments === undefined ||
        Number.isSafeInteger(options.minDomainSegments) && options.minDomainSegments > 0, 'minDomainSegments must be a positive integer');

    // maxDomainSegments

    assert(options.maxDomainSegments === undefined ||
        Number.isSafeInteger(options.maxDomainSegments) && options.maxDomainSegments > 0, 'maxDomainSegments must be a positive integer');

    // tlds

    if (options.tlds === false) {
        return options;
    }

    if (options.tlds === true ||
        options.tlds === undefined) {

        assert(internals.tlds, 'Built-in TLD list disabled');
        return Object.assign({}, options, internals.tlds);
    }

    assert(typeof options.tlds === 'object', 'tlds must be true, false, or an object');

    const deny = options.tlds.deny;
    if (deny) {
        if (Array.isArray(deny)) {
            options = Object.assign({}, options, { tlds: { deny: new Set(deny) } });
        }

        assert(options.tlds.deny instanceof Set, 'tlds.deny must be an array, Set, or boolean');
        assert(!options.tlds.allow, 'Cannot specify both tlds.allow and tlds.deny lists');
        internals.validateTlds(options.tlds.deny, 'tlds.deny');
        return options;
    }

    const allow = options.tlds.allow;
    if (!allow) {
        return { ...options, tlds: false };
    }

    if (allow === true) {
        assert(internals.tlds, 'Built-in TLD list disabled');
        return Object.assign({}, options, internals.tlds);
    }

    if (Array.isArray(allow)) {
        options = Object.assign({}, options, { tlds: { allow: new Set(allow) } });
    }

    assert(options.tlds.allow instanceof Set, 'tlds.allow must be an array, Set, or boolean');
    internals.validateTlds(options.tlds.allow, 'tlds.allow');
    return options;
};


internals.validateTlds = function (set, source) {

    for (const tld of set) {
        assert(isDomainValid(tld, { minDomainSegments: 1, maxDomainSegments: 1 }), `${source} must contain valid top level domain names`);
    }
};


internals.isoDate = function (value) {

    if (!Common.isIsoDate(value)) {
        return null;
    }

    if (/.*T.*[+-]\d\d$/.test(value)) {             // Add missing trailing zeros to timeshift
        value += '00';
    }

    const date = new Date(value);
    if (isNaN(date.getTime())) {
        return null;
    }

    return date.toISOString();
};


internals.length = function (schema, name, limit, operator, encoding) {

    assert(!encoding || Buffer && Buffer.isEncoding(encoding), 'Invalid encoding:', encoding);      // $lab:coverage:ignore$

    return schema.$_addRule({ name, method: 'length', args: { limit, encoding }, operator });
};


/***/ }),

/***/ 24602:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


const { assert } = __nccwpck_require__(91884);

const Any = __nccwpck_require__(49046);


const internals = {};


internals.Map = class extends Map {

    slice() {

        return new internals.Map(this);
    }
};


module.exports = Any.extend({

    type: 'symbol',

    terms: {

        map: { init: new internals.Map() }
    },

    coerce: {
        method(value, { schema, error }) {

            const lookup = schema.$_terms.map.get(value);
            if (lookup) {
                value = lookup;
            }

            if (!schema._flags.only ||
                typeof value === 'symbol') {

                return { value };
            }

            return { value, errors: error('symbol.map', { map: schema.$_terms.map }) };
        }
    },

    validate(value, { error }) {

        if (typeof value !== 'symbol') {
            return { value, errors: error('symbol.base') };
        }
    },

    rules: {
        map: {
            method(iterable) {

                if (iterable &&
                    !iterable[Symbol.iterator] &&
                    typeof iterable === 'object') {

                    iterable = Object.entries(iterable);
                }

                assert(iterable && iterable[Symbol.iterator], 'Iterable must be an iterable or object');

                const obj = this.clone();

                const symbols = [];
                for (const entry of iterable) {
                    assert(entry && entry[Symbol.iterator], 'Entry must be an iterable');
                    const [key, value] = entry;

                    assert(typeof key !== 'object' && typeof key !== 'function' && typeof key !== 'symbol', 'Key must not be of type object, function, or Symbol');
                    assert(typeof value === 'symbol', 'Value must be a Symbol');

                    obj.$_terms.map.set(key, value);
                    symbols.push(value);
                }

                return obj.valid(...symbols);
            }
        }
    },

    manifest: {

        build(obj, desc) {

            if (desc.map) {
                obj = obj.map(desc.map);
            }

            return obj;
        }
    },

    messages: {
        'symbol.base': '{{#label}} must be a symbol',
        'symbol.map': '{{#label}} must be one of {{#map}}'
    }
});


/***/ }),

/***/ 64852:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


const { assert, clone, ignore, reach } = __nccwpck_require__(91884);

const Common = __nccwpck_require__(84205);
const Errors = __nccwpck_require__(11543);
const State = __nccwpck_require__(86139);


const internals = {
    result: Symbol('result')
};


exports.entry = function (value, schema, prefs) {

    let settings = Common.defaults;
    if (prefs) {
        assert(prefs.warnings === undefined, 'Cannot override warnings preference in synchronous validation');
        assert(prefs.artifacts === undefined, 'Cannot override artifacts preference in synchronous validation');
        settings = Common.preferences(Common.defaults, prefs);
    }

    const result = internals.entry(value, schema, settings);
    assert(!result.mainstay.externals.length, 'Schema with external rules must use validateAsync()');
    const outcome = { value: result.value };

    if (result.error) {
        outcome.error = result.error;
    }

    if (result.mainstay.warnings.length) {
        outcome.warning = Errors.details(result.mainstay.warnings);
    }

    if (result.mainstay.debug) {
        outcome.debug = result.mainstay.debug;
    }

    if (result.mainstay.artifacts) {
        outcome.artifacts = result.mainstay.artifacts;
    }

    return outcome;
};


exports.entryAsync = async function (value, schema, prefs) {

    let settings = Common.defaults;
    if (prefs) {
        settings = Common.preferences(Common.defaults, prefs);
    }

    const result = internals.entry(value, schema, settings);
    const mainstay = result.mainstay;
    if (result.error) {
        if (mainstay.debug) {
            result.error.debug = mainstay.debug;
        }

        throw result.error;
    }

    if (mainstay.externals.length) {
        let root = result.value;
        const errors = [];
        for (const external of mainstay.externals) {
            const path = external.state.path;
            const linked = external.schema.type === 'link' ? mainstay.links.get(external.schema) : null;
            let node = root;
            let key;
            let parent;

            const ancestors = path.length ? [root] : [];
            const original = path.length ? reach(value, path) : value;

            if (path.length) {
                key = path[path.length - 1];

                let current = root;
                for (const segment of path.slice(0, -1)) {
                    current = current[segment];
                    ancestors.unshift(current);
                }

                parent = ancestors[0];
                node = parent[key];
            }

            try {
                const createError = (code, local) => (linked || external.schema).$_createError(code, node, local, external.state, settings);
                const output = await external.method(node, {
                    schema: external.schema,
                    linked,
                    state: external.state,
                    prefs,
                    original,
                    error: createError,
                    errorsArray: internals.errorsArray,
                    warn: (code, local) => mainstay.warnings.push((linked || external.schema).$_createError(code, node, local, external.state, settings)),
                    message: (messages, local) => (linked || external.schema).$_createError('external', node, local, external.state, settings, { messages })
                });

                if (output === undefined ||
                    output === node) {

                    continue;
                }

                if (output instanceof Errors.Report) {
                    mainstay.tracer.log(external.schema, external.state, 'rule', 'external', 'error');
                    errors.push(output);

                    if (settings.abortEarly) {
                        break;
                    }

                    continue;
                }

                if (Array.isArray(output) &&
                    output[Common.symbols.errors]) {
                    mainstay.tracer.log(external.schema, external.state, 'rule', 'external', 'error');
                    errors.push(...output);

                    if (settings.abortEarly) {
                        break;
                    }

                    continue;
                }

                if (parent) {
                    mainstay.tracer.value(external.state, 'rule', node, output, 'external');
                    parent[key] = output;
                }
                else {
                    mainstay.tracer.value(external.state, 'rule', root, output, 'external');
                    root = output;
                }
            }
            catch (err) {
                if (settings.errors.label) {
                    err.message += ` (${(external.label)})`;       // Change message to include path
                }

                throw err;
            }
        }

        result.value = root;

        if (errors.length) {
            result.error = Errors.process(errors, value, settings);

            if (mainstay.debug) {
                result.error.debug = mainstay.debug;
            }

            throw result.error;
        }
    }

    if (!settings.warnings &&
        !settings.debug &&
        !settings.artifacts) {

        return result.value;
    }

    const outcome = { value: result.value };
    if (mainstay.warnings.length) {
        outcome.warning = Errors.details(mainstay.warnings);
    }

    if (mainstay.debug) {
        outcome.debug = mainstay.debug;
    }

    if (mainstay.artifacts) {
        outcome.artifacts = mainstay.artifacts;
    }

    return outcome;
};


exports.standard = function (value, schema) {


    if (schema.isAsync()) {
        return exports.entryAsync(value, schema);
    }

    return exports.entry(value, schema);
};


internals.Mainstay = class {

    constructor(tracer, debug, links) {

        this.externals = [];
        this.warnings = [];
        this.tracer = tracer;
        this.debug = debug;
        this.links = links;
        this.shadow = null;
        this.artifacts = null;

        this._snapshots = [];
    }

    snapshot() {

        this._snapshots.push({
            externals: this.externals.slice(),
            warnings: this.warnings.slice()
        });
    }

    restore() {

        const snapshot = this._snapshots.pop();
        this.externals = snapshot.externals;
        this.warnings = snapshot.warnings;
    }

    commit() {

        this._snapshots.pop();
    }
};


internals.entry = function (value, schema, prefs) {

    // Prepare state

    const { tracer, cleanup } = internals.tracer(schema, prefs);
    const debug = prefs.debug ? [] : null;
    const links = schema._ids._schemaChain ? new Map() : null;
    const mainstay = new internals.Mainstay(tracer, debug, links);
    const schemas = schema._ids._schemaChain ? [{ schema }] : null;
    const state = new State([], [], { mainstay, schemas });

    // Validate value

    const result = exports.validate(value, schema, state, prefs);

    // Process value and errors

    if (cleanup) {
        schema.$_root.untrace();
    }

    const error = Errors.process(result.errors, value, prefs);
    return { value: result.value, error, mainstay };
};


internals.tracer = function (schema, prefs) {

    if (schema.$_root._tracer) {
        return { tracer: schema.$_root._tracer._register(schema) };
    }

    if (prefs.debug) {
        assert(schema.$_root.trace, 'Debug mode not supported');
        return { tracer: schema.$_root.trace()._register(schema), cleanup: true };
    }

    return { tracer: internals.ignore };
};


exports.validate = function (value, schema, state, prefs, overrides = {}) {

    if (schema.$_terms.whens) {
        schema = schema._generate(value, state, prefs).schema;
    }

    // Setup state and settings

    if (schema._preferences) {
        prefs = internals.prefs(schema, prefs);
    }

    // Cache

    if (schema._cache &&
        prefs.cache) {

        const result = schema._cache.get(value);
        state.mainstay.tracer.debug(state, 'validate', 'cached', !!result);
        if (result) {
            return result;
        }
    }

    // Helpers

    const createError = (code, local, localState) => schema.$_createError(code, value, local, localState || state, prefs);
    const helpers = {
        original: value,
        prefs,
        schema,
        state,
        error: createError,
        errorsArray: internals.errorsArray,
        warn: (code, local, localState) => state.mainstay.warnings.push(createError(code, local, localState)),
        message: (messages, local) => schema.$_createError('custom', value, local, state, prefs, { messages })
    };

    // Prepare

    state.mainstay.tracer.entry(schema, state);

    const def = schema._definition;
    if (def.prepare &&
        value !== undefined &&
        prefs.convert) {

        const prepared = def.prepare(value, helpers);
        if (prepared) {
            state.mainstay.tracer.value(state, 'prepare', value, prepared.value);
            if (prepared.errors) {
                return internals.finalize(prepared.value, [].concat(prepared.errors), helpers);         // Prepare error always aborts early
            }

            value = prepared.value;
        }
    }

    // Type coercion

    if (def.coerce &&
        value !== undefined &&
        prefs.convert &&
        (!def.coerce.from || def.coerce.from.includes(typeof value))) {

        const coerced = def.coerce.method(value, helpers);
        if (coerced) {
            state.mainstay.tracer.value(state, 'coerced', value, coerced.value);
            if (coerced.errors) {
                return internals.finalize(coerced.value, [].concat(coerced.errors), helpers);           // Coerce error always aborts early
            }

            value = coerced.value;
        }
    }

    // Empty value

    const empty = schema._flags.empty;
    if (empty &&
        empty.$_match(internals.trim(value, schema), state.nest(empty), Common.defaults)) {

        state.mainstay.tracer.value(state, 'empty', value, undefined);
        value = undefined;
    }

    // Presence requirements (required, optional, forbidden)

    const presence = overrides.presence || schema._flags.presence || (schema._flags._endedSwitch ? null : prefs.presence);
    if (value === undefined) {
        if (presence === 'forbidden') {
            return internals.finalize(value, null, helpers);
        }

        if (presence === 'required') {
            return internals.finalize(value, [schema.$_createError('any.required', value, null, state, prefs)], helpers);
        }

        if (presence === 'optional') {
            if (schema._flags.default !== Common.symbols.deepDefault) {
                return internals.finalize(value, null, helpers);
            }

            state.mainstay.tracer.value(state, 'default', value, {});
            value = {};
        }
    }
    else if (presence === 'forbidden') {
        return internals.finalize(value, [schema.$_createError('any.unknown', value, null, state, prefs)], helpers);
    }

    // Allowed values

    const errors = [];

    if (schema._valids) {
        const match = schema._valids.get(value, state, prefs, schema._flags.insensitive);
        if (match) {
            if (prefs.convert) {
                state.mainstay.tracer.value(state, 'valids', value, match.value);
                value = match.value;
            }

            state.mainstay.tracer.filter(schema, state, 'valid', match);
            return internals.finalize(value, null, helpers);
        }

        if (schema._flags.only) {
            const report = schema.$_createError('any.only', value, { valids: schema._valids.values({ display: true }) }, state, prefs);
            if (prefs.abortEarly) {
                return internals.finalize(value, [report], helpers);
            }

            errors.push(report);
        }
    }

    // Denied values

    if (schema._invalids) {
        const match = schema._invalids.get(value, state, prefs, schema._flags.insensitive);
        if (match) {
            state.mainstay.tracer.filter(schema, state, 'invalid', match);
            const report = schema.$_createError('any.invalid', value, { invalids: schema._invalids.values({ display: true }) }, state, prefs);
            if (prefs.abortEarly) {
                return internals.finalize(value, [report], helpers);
            }

            errors.push(report);
        }
    }

    // Base type

    if (def.validate) {
        const base = def.validate(value, helpers);
        if (base) {
            state.mainstay.tracer.value(state, 'base', value, base.value);
            value = base.value;

            if (base.errors) {
                if (!Array.isArray(base.errors)) {
                    errors.push(base.errors);
                    return internals.finalize(value, errors, helpers);          // Base error always aborts early
                }

                if (base.errors.length) {
                    errors.push(...base.errors);
                    return internals.finalize(value, errors, helpers);          // Base error always aborts early
                }
            }
        }
    }

    // Validate tests

    if (!schema._rules.length) {
        return internals.finalize(value, errors, helpers);
    }

    return internals.rules(value, errors, helpers);
};


internals.rules = function (value, errors, helpers) {

    const { schema, state, prefs } = helpers;

    for (const rule of schema._rules) {
        const definition = schema._definition.rules[rule.method];

        // Skip rules that are also applied in coerce step

        if (definition.convert &&
            prefs.convert) {

            state.mainstay.tracer.log(schema, state, 'rule', rule.name, 'full');
            continue;
        }

        // Resolve references

        let ret;
        let args = rule.args;
        if (rule._resolve.length) {
            args = Object.assign({}, args);                                     // Shallow copy
            for (const key of rule._resolve) {
                const resolver = definition.argsByName.get(key);

                const resolved = args[key].resolve(value, state, prefs);
                const normalized = resolver.normalize ? resolver.normalize(resolved) : resolved;

                const invalid = Common.validateArg(normalized, null, resolver);
                if (invalid) {
                    ret = schema.$_createError('any.ref', resolved, { arg: key, ref: args[key], reason: invalid }, state, prefs);
                    break;
                }

                args[key] = normalized;
            }
        }

        // Test rule

        ret = ret || definition.validate(value, helpers, args, rule);           // Use ret if already set to reference error

        const result = internals.rule(ret, rule);
        if (result.errors) {
            state.mainstay.tracer.log(schema, state, 'rule', rule.name, 'error');

            if (rule.warn) {
                state.mainstay.warnings.push(...result.errors);
                continue;
            }

            if (prefs.abortEarly) {
                return internals.finalize(value, result.errors, helpers);
            }

            errors.push(...result.errors);
        }
        else {
            state.mainstay.tracer.log(schema, state, 'rule', rule.name, 'pass');
            state.mainstay.tracer.value(state, 'rule', value, result.value, rule.name);
            value = result.value;
        }
    }

    return internals.finalize(value, errors, helpers);
};


internals.rule = function (ret, rule) {

    if (ret instanceof Errors.Report) {
        internals.error(ret, rule);
        return { errors: [ret], value: null };
    }

    if (Array.isArray(ret) &&
        ret[Common.symbols.errors]) {

        ret.forEach((report) => internals.error(report, rule));
        return { errors: ret, value: null };
    }

    return { errors: null, value: ret };
};


internals.error = function (report, rule) {

    if (rule.message) {
        report._setTemplate(rule.message);
    }

    return report;
};


internals.finalize = function (value, errors, helpers) {

    errors = errors || [];
    const { schema, state, prefs } = helpers;

    // Failover value

    if (errors.length) {
        const failover = internals.default('failover', undefined, errors, helpers);
        if (failover !== undefined) {
            state.mainstay.tracer.value(state, 'failover', value, failover);
            value = failover;
            errors = [];
        }
    }

    // Error override

    if (errors.length &&
        schema._flags.error) {

        if (typeof schema._flags.error === 'function') {
            errors = schema._flags.error(errors);
            if (!Array.isArray(errors)) {
                errors = [errors];
            }

            for (const error of errors) {
                assert(error instanceof Error || error instanceof Errors.Report, 'error() must return an Error object');
            }
        }
        else {
            errors = [schema._flags.error];
        }
    }

    // Default

    if (value === undefined) {
        const defaulted = internals.default('default', value, errors, helpers);
        state.mainstay.tracer.value(state, 'default', value, defaulted);
        value = defaulted;
    }

    // Cast

    if (schema._flags.cast &&
        value !== undefined) {

        const caster = schema._definition.cast[schema._flags.cast];
        if (caster.from(value)) {
            const casted = caster.to(value, helpers);
            state.mainstay.tracer.value(state, 'cast', value, casted, schema._flags.cast);
            value = casted;
        }
    }

    // Externals

    if (schema.$_terms.externals &&
        prefs.externals &&
        prefs._externals !== false) {                       // Disabled for matching

        for (const { method } of schema.$_terms.externals) {
            state.mainstay.externals.push({ method, schema, state, label: Errors.label(schema._flags, state, prefs) });
        }
    }

    // Result

    const result = { value, errors: errors.length ? errors : null };

    if (schema._flags.result) {
        result.value = schema._flags.result === 'strip' ? undefined : /* raw */ helpers.original;
        state.mainstay.tracer.value(state, schema._flags.result, value, result.value);
        state.shadow(value, schema._flags.result);
    }

    // Cache

    if (schema._cache &&
        prefs.cache !== false &&
        !schema._refs.length) {

        schema._cache.set(helpers.original, result);
    }

    // Artifacts

    if (value !== undefined &&
        !result.errors &&
        schema._flags.artifact !== undefined) {

        state.mainstay.artifacts = state.mainstay.artifacts || new Map();
        if (!state.mainstay.artifacts.has(schema._flags.artifact)) {
            state.mainstay.artifacts.set(schema._flags.artifact, []);
        }

        state.mainstay.artifacts.get(schema._flags.artifact).push(state.path);
    }

    return result;
};


internals.prefs = function (schema, prefs) {

    const isDefaultOptions = prefs === Common.defaults;
    if (isDefaultOptions &&
        schema._preferences[Common.symbols.prefs]) {

        return schema._preferences[Common.symbols.prefs];
    }

    prefs = Common.preferences(prefs, schema._preferences);
    if (isDefaultOptions) {
        schema._preferences[Common.symbols.prefs] = prefs;
    }

    return prefs;
};


internals.default = function (flag, value, errors, helpers) {

    const { schema, state, prefs } = helpers;
    const source = schema._flags[flag];
    if (prefs.noDefaults ||
        source === undefined) {

        return value;
    }

    state.mainstay.tracer.log(schema, state, 'rule', flag, 'full');

    if (!source) {
        return source;
    }

    if (typeof source === 'function') {
        const args = source.length ? [clone(state.ancestors[0]), helpers] : [];

        try {
            return source(...args);
        }
        catch (err) {
            errors.push(schema.$_createError(`any.${flag}`, null, { error: err }, state, prefs));
            return;
        }
    }

    if (typeof source !== 'object') {
        return source;
    }

    if (source[Common.symbols.literal]) {
        return source.literal;
    }

    if (Common.isResolvable(source)) {
        return source.resolve(value, state, prefs);
    }

    return clone(source);
};


internals.trim = function (value, schema) {

    if (typeof value !== 'string') {
        return value;
    }

    const trim = schema.$_getRule('trim');
    if (!trim ||
        !trim.args.enabled) {

        return value;
    }

    return value.trim();
};


internals.ignore = {
    active: false,
    debug: ignore,
    entry: ignore,
    filter: ignore,
    log: ignore,
    resolve: ignore,
    value: ignore
};


internals.errorsArray = function () {

    const errors = [];
    errors[Common.symbols.errors] = true;
    return errors;
};


/***/ }),

/***/ 31906:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


const { assert, deepEqual } = __nccwpck_require__(91884);

const Common = __nccwpck_require__(84205);


const internals = {};


module.exports = internals.Values = class {

    constructor(values, refs) {

        this._values = new Set(values);
        this._refs = new Set(refs);
        this._lowercase = internals.lowercases(values);

        this._override = false;
    }

    get length() {

        return this._values.size + this._refs.size;
    }

    add(value, refs) {

        // Reference

        if (Common.isResolvable(value)) {
            if (!this._refs.has(value)) {
                this._refs.add(value);

                if (refs) {                     // Skipped in a merge
                    refs.register(value);
                }
            }

            return;
        }

        // Value

        if (!this.has(value, null, null, false)) {
            this._values.add(value);

            if (typeof value === 'string') {
                this._lowercase.set(value.toLowerCase(), value);
            }
        }
    }

    static merge(target, source, remove) {

        target = target || new internals.Values();

        if (source) {
            if (source._override) {
                return source.clone();
            }

            for (const item of [...source._values, ...source._refs]) {
                target.add(item);
            }
        }

        if (remove) {
            for (const item of [...remove._values, ...remove._refs]) {
                target.remove(item);
            }
        }

        return target.length ? target : null;
    }

    remove(value) {

        // Reference

        if (Common.isResolvable(value)) {
            this._refs.delete(value);
            return;
        }

        // Value

        this._values.delete(value);

        if (typeof value === 'string') {
            this._lowercase.delete(value.toLowerCase());
        }
    }

    has(value, state, prefs, insensitive) {

        return !!this.get(value, state, prefs, insensitive);
    }

    get(value, state, prefs, insensitive) {

        if (!this.length) {
            return false;
        }

        // Simple match

        if (this._values.has(value)) {
            return { value };
        }

        // Case insensitive string match

        if (typeof value === 'string' &&
            value &&
            insensitive) {

            const found = this._lowercase.get(value.toLowerCase());
            if (found) {
                return { value: found };
            }
        }

        if (!this._refs.size &&
            typeof value !== 'object') {

            return false;
        }

        // Objects

        if (typeof value === 'object') {
            for (const item of this._values) {
                if (deepEqual(item, value)) {
                    return { value: item };
                }
            }
        }

        // References

        if (state) {
            for (const ref of this._refs) {
                const resolved = ref.resolve(value, state, prefs, null, { in: true });
                if (resolved === undefined) {
                    continue;
                }

                const items = !ref.in || typeof resolved !== 'object'
                    ? [resolved]
                    : Array.isArray(resolved) ? resolved : Object.keys(resolved);

                for (const item of items) {
                    if (typeof item !== typeof value) {
                        continue;
                    }

                    if (insensitive &&
                        value &&
                        typeof value === 'string') {

                        if (item.toLowerCase() === value.toLowerCase()) {
                            return { value: item, ref };
                        }
                    }
                    else {
                        if (deepEqual(item, value)) {
                            return { value: item, ref };
                        }
                    }
                }
            }
        }

        return false;
    }

    override() {

        this._override = true;
    }

    values(options) {

        if (options &&
            options.display) {

            const values = [];

            for (const item of [...this._values, ...this._refs]) {
                if (item !== undefined) {
                    values.push(item);
                }
            }

            return values;
        }

        return Array.from([...this._values, ...this._refs]);
    }

    clone() {

        const set = new internals.Values(this._values, this._refs);
        set._override = this._override;
        return set;
    }

    concat(source) {

        assert(!source._override, 'Cannot concat override set of values');

        const set = new internals.Values([...this._values, ...source._values], [...this._refs, ...source._refs]);
        set._override = this._override;
        return set;
    }

    describe() {

        const normalized = [];

        if (this._override) {
            normalized.push({ override: true });
        }

        for (const value of this._values.values()) {
            normalized.push(value && typeof value === 'object' ? { value } : value);
        }

        for (const value of this._refs.values()) {
            normalized.push(value.describe());
        }

        return normalized;
    }
};


internals.Values.prototype[Common.symbols.values] = true;


// Aliases

internals.Values.prototype.slice = internals.Values.prototype.clone;


// Helpers

internals.lowercases = function (from) {

    const map = new Map();

    if (from) {
        for (const value of from) {
            if (typeof value === 'string') {
                map.set(value.toLowerCase(), value);
            }
        }
    }

    return map;
};


/***/ }),

/***/ 19703:
/***/ ((module) => {

"use strict";


/**
 * Kuler: Color text using CSS colors
 *
 * @constructor
 * @param {String} text The text that needs to be styled
 * @param {String} color Optional color for alternate API.
 * @api public
 */
function Kuler(text, color) {
  if (color) return (new Kuler(text)).style(color);
  if (!(this instanceof Kuler)) return new Kuler(text);

  this.text = text;
}

/**
 * ANSI color codes.
 *
 * @type {String}
 * @private
 */
Kuler.prototype.prefix = '\x1b[';
Kuler.prototype.suffix = 'm';

/**
 * Parse a hex color string and parse it to it's RGB equiv.
 *
 * @param {String} color
 * @returns {Array}
 * @api private
 */
Kuler.prototype.hex = function hex(color) {
  color = color[0] === '#' ? color.substring(1) : color;

  //
  // Pre-parse for shorthand hex colors.
  //
  if (color.length === 3) {
    color = color.split('');

    color[5] = color[2]; // F60##0
    color[4] = color[2]; // F60#00
    color[3] = color[1]; // F60600
    color[2] = color[1]; // F66600
    color[1] = color[0]; // FF6600

    color = color.join('');
  }

  var r = color.substring(0, 2)
    , g = color.substring(2, 4)
    , b = color.substring(4, 6);

  return [ parseInt(r, 16), parseInt(g, 16), parseInt(b, 16) ];
};

/**
 * Transform a 255 RGB value to an RGV code.
 *
 * @param {Number} r Red color channel.
 * @param {Number} g Green color channel.
 * @param {Number} b Blue color channel.
 * @returns {String}
 * @api public
 */
Kuler.prototype.rgb = function rgb(r, g, b) {
  var red = r / 255 * 5
    , green = g / 255 * 5
    , blue = b / 255 * 5;

  return this.ansi(red, green, blue);
};

/**
 * Turns RGB 0-5 values into a single ANSI code.
 *
 * @param {Number} r Red color channel.
 * @param {Number} g Green color channel.
 * @param {Number} b Blue color channel.
 * @returns {String}
 * @api public
 */
Kuler.prototype.ansi = function ansi(r, g, b) {
  var red = Math.round(r)
    , green = Math.round(g)
    , blue = Math.round(b);

  return 16 + (red * 36) + (green * 6) + blue;
};

/**
 * Marks an end of color sequence.
 *
 * @returns {String} Reset sequence.
 * @api public
 */
Kuler.prototype.reset = function reset() {
  return this.prefix +'39;49'+ this.suffix;
};

/**
 * Colour the terminal using CSS.
 *
 * @param {String} color The HEX color code.
 * @returns {String} the escape code.
 * @api public
 */
Kuler.prototype.style = function style(color) {
  return this.prefix +'38;5;'+ this.rgb.apply(this, this.hex(color)) + this.suffix + this.text + this.reset();
};


//
// Expose the actual interface.
//
module.exports = Kuler;


/***/ }),

/***/ 38409:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


const format = __nccwpck_require__(19541);

/*
 * function align (info)
 * Returns a new instance of the align Format which adds a `\t`
 * delimiter before the message to properly align it in the same place.
 * It was previously { align: true } in winston < 3.0.0
 */
module.exports = format(info => {
  info.message = `\t${info.message}`;
  return info;
});


/***/ }),

/***/ 26658:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


const { Colorizer } = __nccwpck_require__(95085);
const { Padder } = __nccwpck_require__(75925);
const { configs, MESSAGE } = __nccwpck_require__(28836);


/**
 * Cli format class that handles initial state for a a separate
 * Colorizer and Padder instance.
 */
class CliFormat {
  constructor(opts = {}) {
    if (!opts.levels) {
      opts.levels = configs.cli.levels;
    }

    this.colorizer = new Colorizer(opts);
    this.padder = new Padder(opts);
    this.options = opts;
  }

  /*
   * function transform (info, opts)
   * Attempts to both:
   * 1. Pad the { level }
   * 2. Colorize the { level, message }
   * of the given `logform` info object depending on the `opts`.
   */
  transform(info, opts) {
    this.colorizer.transform(
      this.padder.transform(info, opts),
      opts
    );

    info[MESSAGE] = `${info.level}:${info.message}`;
    return info;
  }
}

/*
 * function cli (opts)
 * Returns a new instance of the CLI format that turns a log
 * `info` object into the same format previously available
 * in `winston.cli()` in `winston < 3.0.0`.
 */
module.exports = opts => new CliFormat(opts);

//
// Attach the CliFormat for registration purposes
//
module.exports.Format = CliFormat;


/***/ }),

/***/ 95085:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


const colors = __nccwpck_require__(72708);
const { LEVEL, MESSAGE } = __nccwpck_require__(28836);

//
// Fix colors not appearing in non-tty environments
//
colors.enabled = true;

/**
 * @property {RegExp} hasSpace
 * Simple regex to check for presence of spaces.
 */
const hasSpace = /\s+/;

/*
 * Colorizer format. Wraps the `level` and/or `message` properties
 * of the `info` objects with ANSI color codes based on a few options.
 */
class Colorizer {
  constructor(opts = {}) {
    if (opts.colors) {
      this.addColors(opts.colors);
    }

    this.options = opts;
  }

  /*
   * Adds the colors Object to the set of allColors
   * known by the Colorizer
   *
   * @param {Object} colors Set of color mappings to add.
   */
  static addColors(clrs) {
    const nextColors = Object.keys(clrs).reduce((acc, level) => {
      acc[level] = hasSpace.test(clrs[level])
        ? clrs[level].split(hasSpace)
        : clrs[level];

      return acc;
    }, {});

    Colorizer.allColors = Object.assign({}, Colorizer.allColors || {}, nextColors);
    return Colorizer.allColors;
  }

  /*
   * Adds the colors Object to the set of allColors
   * known by the Colorizer
   *
   * @param {Object} colors Set of color mappings to add.
   */
  addColors(clrs) {
    return Colorizer.addColors(clrs);
  }

  /*
   * function colorize (lookup, level, message)
   * Performs multi-step colorization using @colors/colors/safe
   */
  colorize(lookup, level, message) {
    if (typeof message === 'undefined') {
      message = level;
    }

    //
    // If the color for the level is just a string
    // then attempt to colorize the message with it.
    //
    if (!Array.isArray(Colorizer.allColors[lookup])) {
      return colors[Colorizer.allColors[lookup]](message);
    }

    //
    // If it is an Array then iterate over that Array, applying
    // the colors function for each item.
    //
    for (let i = 0, len = Colorizer.allColors[lookup].length; i < len; i++) {
      message = colors[Colorizer.allColors[lookup][i]](message);
    }

    return message;
  }

  /*
   * function transform (info, opts)
   * Attempts to colorize the { level, message } of the given
   * `logform` info object.
   */
  transform(info, opts) {
    if (opts.all && typeof info[MESSAGE] === 'string') {
      info[MESSAGE] = this.colorize(info[LEVEL], info.level, info[MESSAGE]);
    }

    if (opts.level || opts.all || !opts.message) {
      info.level = this.colorize(info[LEVEL], info.level);
    }

    if (opts.all || opts.message) {
      info.message = this.colorize(info[LEVEL], info.level, info.message);
    }

    return info;
  }
}

/*
 * function colorize (info)
 * Returns a new instance of the colorize Format that applies
 * level colors to `info` objects. This was previously exposed
 * as { colorize: true } to transports in `winston < 3.0.0`.
 */
module.exports = opts => new Colorizer(opts);

//
// Attach the Colorizer for registration purposes
//
module.exports.Colorizer
  = module.exports.Format
  = Colorizer;


/***/ }),

/***/ 68885:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


const format = __nccwpck_require__(19541);

/*
 * function cascade(formats)
 * Returns a function that invokes the `._format` function in-order
 * for the specified set of `formats`. In this manner we say that Formats
 * are "pipe-like", but not a pure pumpify implementation. Since there is no back
 * pressure we can remove all of the "readable" plumbing in Node streams.
 */
function cascade(formats) {
  if (!formats.every(isValidFormat)) {
    return;
  }

  return info => {
    let obj = info;
    for (let i = 0; i < formats.length; i++) {
      obj = formats[i].transform(obj, formats[i].options);
      if (!obj) {
        return false;
      }
    }

    return obj;
  };
}

/*
 * function isValidFormat(format)
 * If the format does not define a `transform` function throw an error
 * with more detailed usage.
 */
function isValidFormat(fmt) {
  if (typeof fmt.transform !== 'function') {
    throw new Error([
      'No transform function found on format. Did you create a format instance?',
      'const myFormat = format(formatFn);',
      'const instance = myFormat();'
    ].join('\n'));
  }

  return true;
}

/*
 * function combine (info)
 * Returns a new instance of the combine Format which combines the specified
 * formats into a new format. This is similar to a pipe-chain in transform streams.
 * We choose to combine the prototypes this way because there is no back pressure in
 * an in-memory transform chain.
 */
module.exports = (...formats) => {
  const combinedFormat = format(cascade(formats));
  const instance = combinedFormat();
  instance.Format = combinedFormat.Format;
  return instance;
};

//
// Export the cascade method for use in cli and other
// combined formats that should not be assumed to be
// singletons.
//
module.exports.cascade = cascade;


/***/ }),

/***/ 75249:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";
/* eslint no-undefined: 0 */


const format = __nccwpck_require__(19541);
const { LEVEL, MESSAGE } = __nccwpck_require__(28836);

/*
 * function errors (info)
 * If the `message` property of the `info` object is an instance of `Error`,
 * replace the `Error` object its own `message` property.
 *
 * Optionally, the Error's `stack` and/or `cause` properties can also be appended to the `info` object.
 */
module.exports = format((einfo, { stack, cause }) => {
  if (einfo instanceof Error) {
    const info = Object.assign({}, einfo, {
      level: einfo.level,
      [LEVEL]: einfo[LEVEL] || einfo.level,
      message: einfo.message,
      [MESSAGE]: einfo[MESSAGE] || einfo.message
    });

    if (stack) info.stack = einfo.stack;
    if (cause) info.cause = einfo.cause;
    return info;
  }

  if (!(einfo.message instanceof Error)) return einfo;

  // Assign all enumerable properties and the
  // message property from the error provided.
  const err = einfo.message;
  Object.assign(einfo, err);
  einfo.message = err.message;
  einfo[MESSAGE] = err.message;

  // Assign the stack and/or cause if requested.
  if (stack) einfo.stack = err.stack;
  if (cause) einfo.cause = err.cause;
  return einfo;
});


/***/ }),

/***/ 19541:
/***/ ((module) => {

"use strict";


/*
 * Displays a helpful message and the source of
 * the format when it is invalid.
 */
class InvalidFormatError extends Error {
  constructor(formatFn) {
    super(`Format functions must be synchronous taking a two arguments: (info, opts)
Found: ${formatFn.toString().split('\n')[0]}\n`);

    Error.captureStackTrace(this, InvalidFormatError);
  }
}

/*
 * function format (formatFn)
 * Returns a create function for the `formatFn`.
 */
module.exports = formatFn => {
  if (formatFn.length > 2) {
    throw new InvalidFormatError(formatFn);
  }

  /*
   * function Format (options)
   * Base prototype which calls a `_format`
   * function and pushes the result.
   */
  function Format(options = {}) {
    this.options = options;
  }

  Format.prototype.transform = formatFn;

  //
  // Create a function which returns new instances of
  // FormatWrap for simple syntax like:
  //
  // require('winston').formats.json();
  //
  function createFormatWrap(opts) {
    return new Format(opts);
  }

  //
  // Expose the FormatWrap through the create function
  // for testability.
  //
  createFormatWrap.Format = Format;
  return createFormatWrap;
};


/***/ }),

/***/ 45440:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


/*
 * @api public
 * @property {function} format
 * Both the construction method and set of exposed
 * formats.
 */
const format = exports.format = __nccwpck_require__(19541);

/*
 * @api public
 * @method {function} levels
 * Registers the specified levels with logform.
 */
exports.levels = __nccwpck_require__(64197);

/*
 * @api private
 * method {function} exposeFormat
 * Exposes a sub-format on the main format object
 * as a lazy-loaded getter.
 */
function exposeFormat(name, requireFormat) {
  Object.defineProperty(format, name, {
    get() {
      return requireFormat();
    },
    configurable: true
  });
}

//
// Setup all transports as lazy-loaded getters.
//
exposeFormat('align', function () { return __nccwpck_require__(38409); });
exposeFormat('errors', function () { return __nccwpck_require__(75249); });
exposeFormat('cli', function () { return __nccwpck_require__(26658); });
exposeFormat('combine', function () { return __nccwpck_require__(68885); });
exposeFormat('colorize', function () { return __nccwpck_require__(95085); });
exposeFormat('json', function () { return __nccwpck_require__(17864); });
exposeFormat('label', function () { return __nccwpck_require__(654); });
exposeFormat('logstash', function () { return __nccwpck_require__(35574); });
exposeFormat('metadata', function () { return __nccwpck_require__(87847); });
exposeFormat('ms', function () { return __nccwpck_require__(82786); });
exposeFormat('padLevels', function () { return __nccwpck_require__(75925); });
exposeFormat('prettyPrint', function () { return __nccwpck_require__(71364); });
exposeFormat('printf', function () { return __nccwpck_require__(9333); });
exposeFormat('simple', function () { return __nccwpck_require__(52740); });
exposeFormat('splat', function () { return __nccwpck_require__(30520); });
exposeFormat('timestamp', function () { return __nccwpck_require__(90728); });
exposeFormat('uncolorize', function () { return __nccwpck_require__(78054); });


/***/ }),

/***/ 17864:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


const format = __nccwpck_require__(19541);
const { MESSAGE } = __nccwpck_require__(28836);
const stringify = __nccwpck_require__(37467);

/*
 * function replacer (key, value)
 * Handles proper stringification of Buffer and bigint output.
 */
function replacer(key, value) {
  // safe-stable-stringify does support BigInt, however, it doesn't wrap the value in quotes.
  // Leading to a loss in fidelity if the resulting string is parsed.
  // It would also be a breaking change for logform.
  if (typeof value === 'bigint')
    return value.toString();
  return value;
}

/*
 * function json (info)
 * Returns a new instance of the JSON format that turns a log `info`
 * object into pure JSON. This was previously exposed as { json: true }
 * to transports in `winston < 3.0.0`.
 */
module.exports = format((info, opts) => {
  const jsonStringify = stringify.configure(opts);
  info[MESSAGE] = jsonStringify(info, opts.replacer || replacer, opts.space);
  return info;
});


/***/ }),

/***/ 654:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


const format = __nccwpck_require__(19541);

/*
 * function label (info)
 * Returns a new instance of the label Format which adds the specified
 * `opts.label` before the message. This was previously exposed as
 * { label: 'my label' } to transports in `winston < 3.0.0`.
 */
module.exports = format((info, opts) => {
  if (opts.message) {
    info.message = `[${opts.label}] ${info.message}`;
    return info;
  }

  info.label = opts.label;
  return info;
});


/***/ }),

/***/ 64197:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


const { Colorizer } = __nccwpck_require__(95085);

/*
 * Simple method to register colors with a simpler require
 * path within the module.
 */
module.exports = config => {
  Colorizer.addColors(config.colors || config);
  return config;
};


/***/ }),

/***/ 35574:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


const format = __nccwpck_require__(19541);
const { MESSAGE } = __nccwpck_require__(28836);
const jsonStringify = __nccwpck_require__(37467);

/*
 * function logstash (info)
 * Returns a new instance of the LogStash Format that turns a
 * log `info` object into pure JSON with the appropriate logstash
 * options. This was previously exposed as { logstash: true }
 * to transports in `winston < 3.0.0`.
 */
module.exports = format(info => {
  const logstash = {};
  if (info.message) {
    logstash['@message'] = info.message;
    delete info.message;
  }

  if (info.timestamp) {
    logstash['@timestamp'] = info.timestamp;
    delete info.timestamp;
  }

  logstash['@fields'] = info;
  info[MESSAGE] = jsonStringify(logstash);
  return info;
});


/***/ }),

/***/ 87847:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


const format = __nccwpck_require__(19541);

function fillExcept(info, fillExceptKeys, metadataKey) {
  const savedKeys = fillExceptKeys.reduce((acc, key) => {
    acc[key] = info[key];
    delete info[key];
    return acc;
  }, {});
  const metadata = Object.keys(info).reduce((acc, key) => {
    acc[key] = info[key];
    delete info[key];
    return acc;
  }, {});

  Object.assign(info, savedKeys, {
    [metadataKey]: metadata
  });
  return info;
}

function fillWith(info, fillWithKeys, metadataKey) {
  info[metadataKey] = fillWithKeys.reduce((acc, key) => {
    acc[key] = info[key];
    delete info[key];
    return acc;
  }, {});
  return info;
}

/**
 * Adds in a "metadata" object to collect extraneous data, similar to the metadata
 * object in winston 2.x.
 */
module.exports = format((info, opts = {}) => {
  let metadataKey = 'metadata';
  if (opts.key) {
    metadataKey = opts.key;
  }

  let fillExceptKeys = [];
  if (!opts.fillExcept && !opts.fillWith) {
    fillExceptKeys.push('level');
    fillExceptKeys.push('message');
  }

  if (opts.fillExcept) {
    fillExceptKeys = opts.fillExcept;
  }

  if (fillExceptKeys.length > 0) {
    return fillExcept(info, fillExceptKeys, metadataKey);
  }

  if (opts.fillWith) {
    return fillWith(info, opts.fillWith, metadataKey);
  }

  return info;
});


/***/ }),

/***/ 82786:
/***/ (function(module, __unused_webpack_exports, __nccwpck_require__) {

"use strict";


const format = __nccwpck_require__(19541);
const ms = __nccwpck_require__(70744);

/*
 * function ms (info)
 * Returns an `info` with a `ms` property. The `ms` property holds the Value
 * of the time difference between two calls in milliseconds.
 */
module.exports = format(info => {
  const curr = +new Date();
  this.diff = curr - (this.prevTime || curr);
  this.prevTime = curr;
  info.ms = `+${ms(this.diff)}`;

  return info;
});


/***/ }),

/***/ 75925:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";
/* eslint no-unused-vars: 0 */


const { configs, LEVEL, MESSAGE } = __nccwpck_require__(28836);

class Padder {
  constructor(opts = { levels: configs.npm.levels }) {
    this.paddings = Padder.paddingForLevels(opts.levels, opts.filler);
    this.options = opts;
  }

  /**
   * Returns the maximum length of keys in the specified `levels` Object.
   * @param  {Object} levels Set of all levels to calculate longest level against.
   * @returns {Number} Maximum length of the longest level string.
   */
  static getLongestLevel(levels) {
    const lvls = Object.keys(levels).map(level => level.length);
    return Math.max(...lvls);
  }

  /**
   * Returns the padding for the specified `level` assuming that the
   * maximum length of all levels it's associated with is `maxLength`.
   * @param  {String} level Level to calculate padding for.
   * @param  {String} filler Repeatable text to use for padding.
   * @param  {Number} maxLength Length of the longest level
   * @returns {String} Padding string for the `level`
   */
  static paddingForLevel(level, filler, maxLength) {
    const targetLen = maxLength + 1 - level.length;
    const rep = Math.floor(targetLen / filler.length);
    const padding = `${filler}${filler.repeat(rep)}`;
    return padding.slice(0, targetLen);
  }

  /**
   * Returns an object with the string paddings for the given `levels`
   * using the specified `filler`.
   * @param  {Object} levels Set of all levels to calculate padding for.
   * @param  {String} filler Repeatable text to use for padding.
   * @returns {Object} Mapping of level to desired padding.
   */
  static paddingForLevels(levels, filler = ' ') {
    const maxLength = Padder.getLongestLevel(levels);
    return Object.keys(levels).reduce((acc, level) => {
      acc[level] = Padder.paddingForLevel(level, filler, maxLength);
      return acc;
    }, {});
  }

  /**
   * Prepends the padding onto the `message` based on the `LEVEL` of
   * the `info`. This is based on the behavior of `winston@2` which also
   * prepended the level onto the message.
   *
   * See: https://github.com/winstonjs/winston/blob/2.x/lib/winston/logger.js#L198-L201
   *
   * @param  {Info} info Logform info object
   * @param  {Object} opts Options passed along to this instance.
   * @returns {Info} Modified logform info object.
   */
  transform(info, opts) {
    info.message = `${this.paddings[info[LEVEL]]}${info.message}`;
    if (info[MESSAGE]) {
      info[MESSAGE] = `${this.paddings[info[LEVEL]]}${info[MESSAGE]}`;
    }

    return info;
  }
}

/*
 * function padLevels (info)
 * Returns a new instance of the padLevels Format which pads
 * levels to be the same length. This was previously exposed as
 * { padLevels: true } to transports in `winston < 3.0.0`.
 */
module.exports = opts => new Padder(opts);

module.exports.Padder
  = module.exports.Format
  = Padder;


/***/ }),

/***/ 71364:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


const inspect = (__nccwpck_require__(39023).inspect);
const format = __nccwpck_require__(19541);
const { LEVEL, MESSAGE, SPLAT } = __nccwpck_require__(28836);

/*
 * function prettyPrint (info)
 * Returns a new instance of the prettyPrint Format that "prettyPrint"
 * serializes `info` objects. This was previously exposed as
 * { prettyPrint: true } to transports in `winston < 3.0.0`.
 */
module.exports = format((info, opts = {}) => {
  //
  // info[{LEVEL, MESSAGE, SPLAT}] are enumerable here. Since they
  // are internal, we remove them before util.inspect so they
  // are not printed.
  //
  const stripped = Object.assign({}, info);

  // Remark (indexzero): update this technique in April 2019
  // when node@6 is EOL
  delete stripped[LEVEL];
  delete stripped[MESSAGE];
  delete stripped[SPLAT];

  info[MESSAGE] = inspect(stripped, false, opts.depth || null, opts.colorize);
  return info;
});


/***/ }),

/***/ 9333:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


const { MESSAGE } = __nccwpck_require__(28836);

class Printf {
  constructor(templateFn) {
    this.template = templateFn;
  }

  transform(info) {
    info[MESSAGE] = this.template(info);
    return info;
  }
}

/*
 * function printf (templateFn)
 * Returns a new instance of the printf Format that creates an
 * intermediate prototype to store the template string-based formatter
 * function.
 */
module.exports = opts => new Printf(opts);

module.exports.Printf
  = module.exports.Format
  = Printf;


/***/ }),

/***/ 52740:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";
/* eslint no-undefined: 0 */


const format = __nccwpck_require__(19541);
const { MESSAGE } = __nccwpck_require__(28836);
const jsonStringify = __nccwpck_require__(37467);

/*
 * function simple (info)
 * Returns a new instance of the simple format TransformStream
 * which writes a simple representation of logs.
 *
 *    const { level, message, splat, ...rest } = info;
 *
 *    ${level}: ${message}                            if rest is empty
 *    ${level}: ${message} ${JSON.stringify(rest)}    otherwise
 */
module.exports = format(info => {
  const stringifiedRest = jsonStringify(Object.assign({}, info, {
    level: undefined,
    message: undefined,
    splat: undefined
  }));

  const padding = info.padding && info.padding[info.level] || '';
  if (stringifiedRest !== '{}') {
    info[MESSAGE] = `${info.level}:${padding} ${info.message} ${stringifiedRest}`;
  } else {
    info[MESSAGE] = `${info.level}:${padding} ${info.message}`;
  }

  return info;
});


/***/ }),

/***/ 30520:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


const util = __nccwpck_require__(39023);
const { SPLAT } = __nccwpck_require__(28836);

/**
 * Captures the number of format (i.e. %s strings) in a given string.
 * Based on `util.format`, see Node.js source:
 * https://github.com/nodejs/node/blob/b1c8f15c5f169e021f7c46eb7b219de95fe97603/lib/util.js#L201-L230
 * @type {RegExp}
 */
const formatRegExp = /%[scdjifoO%]/g;

/**
 * Captures the number of escaped % signs in a format string (i.e. %s strings).
 * @type {RegExp}
 */
const escapedPercent = /%%/g;

class Splatter {
  constructor(opts) {
    this.options = opts;
  }

  /**
     * Check to see if tokens <= splat.length, assign { splat, meta } into the
     * `info` accordingly, and write to this instance.
     *
     * @param  {Info} info Logform info message.
     * @param  {String[]} tokens Set of string interpolation tokens.
     * @returns {Info} Modified info message
     * @private
     */
  _splat(info, tokens) {
    const msg = info.message;
    const splat = info[SPLAT] || info.splat || [];
    const percents = msg.match(escapedPercent);
    const escapes = percents && percents.length || 0;

    // The expected splat is the number of tokens minus the number of escapes
    // e.g.
    // - { expectedSplat: 3 } '%d %s %j'
    // - { expectedSplat: 5 } '[%s] %d%% %d%% %s %j'
    //
    // Any "meta" will be arugments in addition to the expected splat size
    // regardless of type. e.g.
    //
    // logger.log('info', '%d%% %s %j', 100, 'wow', { such: 'js' }, { thisIsMeta: true });
    // would result in splat of four (4), but only three (3) are expected. Therefore:
    //
    // extraSplat = 3 - 4 = -1
    // metas = [100, 'wow', { such: 'js' }, { thisIsMeta: true }].splice(-1, -1 * -1);
    // splat = [100, 'wow', { such: 'js' }]
    const expectedSplat = tokens.length - escapes;
    const extraSplat = expectedSplat - splat.length;
    const metas = extraSplat < 0
      ? splat.splice(extraSplat, -1 * extraSplat)
      : [];

    // Now that { splat } has been separated from any potential { meta }. we
    // can assign this to the `info` object and write it to our format stream.
    // If the additional metas are **NOT** objects or **LACK** enumerable properties
    // you are going to have a bad time.
    const metalen = metas.length;
    if (metalen) {
      for (let i = 0; i < metalen; i++) {
        Object.assign(info, metas[i]);
      }
    }

    info.message = util.format(msg, ...splat);
    return info;
  }

  /**
    * Transforms the `info` message by using `util.format` to complete
    * any `info.message` provided it has string interpolation tokens.
    * If no tokens exist then `info` is immutable.
    *
    * @param  {Info} info Logform info message.
    * @param  {Object} opts Options for this instance.
    * @returns {Info} Modified info message
    */
  transform(info) {
    const msg = info.message;
    const splat = info[SPLAT] || info.splat;

    // No need to process anything if splat is undefined
    if (!splat || !splat.length) {
      return info;
    }

    // Extract tokens, if none available default to empty array to
    // ensure consistancy in expected results
    const tokens = msg && msg.match && msg.match(formatRegExp);

    // This condition will take care of inputs with info[SPLAT]
    // but no tokens present
    if (!tokens && (splat || splat.length)) {
      const metas = splat.length > 1
        ? splat.splice(0)
        : splat;

      // Now that { splat } has been separated from any potential { meta }. we
      // can assign this to the `info` object and write it to our format stream.
      // If the additional metas are **NOT** objects or **LACK** enumerable properties
      // you are going to have a bad time.
      const metalen = metas.length;
      if (metalen) {
        for (let i = 0; i < metalen; i++) {
          Object.assign(info, metas[i]);
        }
      }

      return info;
    }

    if (tokens) {
      return this._splat(info, tokens);
    }

    return info;
  }
}

/*
 * function splat (info)
 * Returns a new instance of the splat format TransformStream
 * which performs string interpolation from `info` objects. This was
 * previously exposed implicitly in `winston < 3.0.0`.
 */
module.exports = opts => new Splatter(opts);


/***/ }),

/***/ 90728:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


const fecha = __nccwpck_require__(1972);
const format = __nccwpck_require__(19541);

/*
 * function timestamp (info)
 * Returns a new instance of the timestamp Format which adds a timestamp
 * to the info. It was previously available in winston < 3.0.0 as:
 *
 * - { timestamp: true }             // `new Date.toISOString()`
 * - { timestamp: function:String }  // Value returned by `timestamp()`
 */
module.exports = format((info, opts = {}) => {
  if (opts.format) {
    info.timestamp = typeof opts.format === 'function'
      ? opts.format()
      : fecha.format(new Date(), opts.format);
  }

  if (!info.timestamp) {
    info.timestamp = new Date().toISOString();
  }

  if (opts.alias) {
    info[opts.alias] = info.timestamp;
  }

  return info;
});


/***/ }),

/***/ 78054:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


const colors = __nccwpck_require__(72708);
const format = __nccwpck_require__(19541);
const { MESSAGE } = __nccwpck_require__(28836);

/*
 * function uncolorize (info)
 * Returns a new instance of the uncolorize Format that strips colors
 * from `info` objects. This was previously exposed as { stripColors: true }
 * to transports in `winston < 3.0.0`.
 */
module.exports = format((info, opts) => {
  if (opts.level !== false) {
    info.level = colors.strip(info.level);
  }

  if (opts.message¬†!== false) {
    info.message = colors.strip(String(info.message));
  }

  if (opts.raw !== false && info[MESSAGE]) {
    info[MESSAGE] = colors.strip(String(info[MESSAGE]));
  }

  return info;
});


/***/ }),

/***/ 46963:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createLRU = void 0;
const createLRU = (options) => {
    let { max } = options;
    if (!(Number.isInteger(max) && max > 0))
        throw new TypeError('`max` must be a positive integer');
    let size = 0;
    let head = 0;
    let tail = 0;
    let free = [];
    const { onEviction } = options;
    const keyMap = new Map();
    const keyList = new Array(max).fill(undefined);
    const valList = new Array(max).fill(undefined);
    const next = new Array(max).fill(0);
    const prev = new Array(max).fill(0);
    const setTail = (index, type) => {
        if (index === tail)
            return;
        const nextIndex = next[index];
        const prevIndex = prev[index];
        if (index === head)
            head = nextIndex;
        else if (type === 'get' || prevIndex !== 0)
            next[prevIndex] = nextIndex;
        if (nextIndex !== 0)
            prev[nextIndex] = prevIndex;
        next[tail] = index;
        prev[index] = tail;
        next[index] = 0;
        tail = index;
    };
    const _evict = () => {
        const evictHead = head;
        const key = keyList[evictHead];
        onEviction === null || onEviction === void 0 ? void 0 : onEviction(key, valList[evictHead]);
        keyMap.delete(key);
        keyList[evictHead] = undefined;
        valList[evictHead] = undefined;
        head = next[evictHead];
        if (head !== 0)
            prev[head] = 0;
        size--;
        if (size === 0)
            head = tail = 0;
        free.push(evictHead);
        return evictHead;
    };
    return {
        /** Adds a key-value pair to the cache. Updates the value if the key already exists. */
        set(key, value) {
            if (key === undefined)
                return;
            let index = keyMap.get(key);
            if (index === undefined) {
                index = size === max ? _evict() : free.length > 0 ? free.pop() : size;
                keyMap.set(key, index);
                keyList[index] = key;
                size++;
            }
            else
                onEviction === null || onEviction === void 0 ? void 0 : onEviction(key, valList[index]);
            valList[index] = value;
            if (size === 1)
                head = tail = index;
            else
                setTail(index, 'set');
        },
        /** Retrieves the value for a given key and moves the key to the most recent position. */
        get(key) {
            const index = keyMap.get(key);
            if (index === undefined)
                return;
            if (index !== tail)
                setTail(index, 'get');
            return valList[index];
        },
        /** Retrieves the value for a given key without changing its position. */
        peek: (key) => {
            const index = keyMap.get(key);
            return index !== undefined ? valList[index] : undefined;
        },
        /** Checks if a key exists in the cache. */
        has: (key) => keyMap.has(key),
        /** Iterates over all keys in the cache, from most recent to least recent. */
        *keys() {
            let current = tail;
            for (let i = 0; i < size; i++) {
                yield keyList[current];
                current = prev[current];
            }
        },
        /** Iterates over all values in the cache, from most recent to least recent. */
        *values() {
            let current = tail;
            for (let i = 0; i < size; i++) {
                yield valList[current];
                current = prev[current];
            }
        },
        /** Iterates over `[key, value]` pairs in the cache, from most recent to least recent. */
        *entries() {
            let current = tail;
            for (let i = 0; i < size; i++) {
                yield [keyList[current], valList[current]];
                current = prev[current];
            }
        },
        /** Iterates over each value-key pair in the cache, from most recent to least recent. */
        forEach: (callback) => {
            let current = tail;
            for (let i = 0; i < size; i++) {
                const key = keyList[current];
                const value = valList[current];
                callback(value, key);
                current = prev[current];
            }
        },
        /** Deletes a key-value pair from the cache. */
        delete(key) {
            const index = keyMap.get(key);
            if (index === undefined)
                return false;
            onEviction === null || onEviction === void 0 ? void 0 : onEviction(key, valList[index]);
            keyMap.delete(key);
            free.push(index);
            keyList[index] = undefined;
            valList[index] = undefined;
            const prevIndex = prev[index];
            const nextIndex = next[index];
            if (prevIndex !== 0)
                next[prevIndex] = nextIndex;
            if (nextIndex !== 0)
                prev[nextIndex] = prevIndex;
            if (index === head)
                head = nextIndex;
            if (index === tail)
                tail = prevIndex;
            size--;
            return true;
        },
        /** Evicts the oldest item or the specified number of the oldest items from the cache. */
        evict: (number) => {
            let toPrune = Math.min(number, size);
            while (toPrune > 0) {
                _evict();
                toPrune--;
            }
        },
        /** Clears all key-value pairs from the cache. */
        clear() {
            if (typeof onEviction === 'function') {
                const iterator = keyMap.values();
                for (let result = iterator.next(); !result.done; result = iterator.next())
                    onEviction(keyList[result.value], valList[result.value]);
            }
            keyMap.clear();
            keyList.fill(undefined);
            valList.fill(undefined);
            free = [];
            size = 0;
            head = tail = 0;
        },
        /** Resizes the cache to a new maximum size, evicting items if necessary. */
        resize: (newMax) => {
            if (!(Number.isInteger(newMax) && newMax > 0))
                throw new TypeError('`max` must be a positive integer');
            if (newMax === max)
                return;
            if (newMax < max) {
                let current = tail;
                const preserve = Math.min(size, newMax);
                const remove = size - preserve;
                const newKeyList = new Array(newMax);
                const newValList = new Array(newMax);
                const newNext = new Array(newMax);
                const newPrev = new Array(newMax);
                for (let i = 1; i <= remove; i++)
                    onEviction === null || onEviction === void 0 ? void 0 : onEviction(keyList[i], valList[i]);
                for (let i = preserve - 1; i >= 0; i--) {
                    newKeyList[i] = keyList[current];
                    newValList[i] = valList[current];
                    newNext[i] = i + 1;
                    newPrev[i] = i - 1;
                    keyMap.set(newKeyList[i], i);
                    current = prev[current];
                }
                head = 0;
                tail = preserve - 1;
                size = preserve;
                keyList.length = newMax;
                valList.length = newMax;
                next.length = newMax;
                prev.length = newMax;
                for (let i = 0; i < preserve; i++) {
                    keyList[i] = newKeyList[i];
                    valList[i] = newValList[i];
                    next[i] = newNext[i];
                    prev[i] = newPrev[i];
                }
                free = [];
                for (let i = preserve; i < newMax; i++)
                    free.push(i);
            }
            else {
                const fill = newMax - max;
                keyList.push(...new Array(fill).fill(undefined));
                valList.push(...new Array(fill).fill(undefined));
                next.push(...new Array(fill).fill(0));
                prev.push(...new Array(fill).fill(0));
            }
            max = newMax;
        },
        /** Returns the maximum number of items that can be stored in the cache. */
        get max() {
            return max;
        },
        /** Returns the number of items currently stored in the cache. */
        get size() {
            return size;
        },
        /** Returns the number of currently available slots in the cache before reaching the maximum size. */
        get available() {
            return max - size;
        },
    };
};
exports.createLRU = createLRU;


/***/ }),

/***/ 55641:
/***/ ((module) => {

"use strict";


/** @type {import('./abs')} */
module.exports = Math.abs;


/***/ }),

/***/ 96171:
/***/ ((module) => {

"use strict";


/** @type {import('./floor')} */
module.exports = Math.floor;


/***/ }),

/***/ 77044:
/***/ ((module) => {

"use strict";


/** @type {import('./isNaN')} */
module.exports = Number.isNaN || function isNaN(a) {
	return a !== a;
};


/***/ }),

/***/ 57147:
/***/ ((module) => {

"use strict";


/** @type {import('./max')} */
module.exports = Math.max;


/***/ }),

/***/ 41017:
/***/ ((module) => {

"use strict";


/** @type {import('./min')} */
module.exports = Math.min;


/***/ }),

/***/ 56947:
/***/ ((module) => {

"use strict";


/** @type {import('./pow')} */
module.exports = Math.pow;


/***/ }),

/***/ 42621:
/***/ ((module) => {

"use strict";


/** @type {import('./round')} */
module.exports = Math.round;


/***/ }),

/***/ 30156:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


var $isNaN = __nccwpck_require__(77044);

/** @type {import('./sign')} */
module.exports = function sign(number) {
	if ($isNaN(number) || number === 0) {
		return number;
	}
	return number < 0 ? -1 : +1;
};


/***/ }),

/***/ 90827:
/***/ ((__unused_webpack_module, exports) => {

/*!
 * media-typer
 * Copyright(c) 2014 Douglas Christopher Wilson
 * MIT Licensed
 */

/**
 * RegExp to match *( ";" parameter ) in RFC 2616 sec 3.7
 *
 * parameter     = token "=" ( token | quoted-string )
 * token         = 1*<any CHAR except CTLs or separators>
 * separators    = "(" | ")" | "<" | ">" | "@"
 *               | "," | ";" | ":" | "\" | <">
 *               | "/" | "[" | "]" | "?" | "="
 *               | "{" | "}" | SP | HT
 * quoted-string = ( <"> *(qdtext | quoted-pair ) <"> )
 * qdtext        = <any TEXT except <">>
 * quoted-pair   = "\" CHAR
 * CHAR          = <any US-ASCII character (octets 0 - 127)>
 * TEXT          = <any OCTET except CTLs, but including LWS>
 * LWS           = [CRLF] 1*( SP | HT )
 * CRLF          = CR LF
 * CR            = <US-ASCII CR, carriage return (13)>
 * LF            = <US-ASCII LF, linefeed (10)>
 * SP            = <US-ASCII SP, space (32)>
 * SHT           = <US-ASCII HT, horizontal-tab (9)>
 * CTL           = <any US-ASCII control character (octets 0 - 31) and DEL (127)>
 * OCTET         = <any 8-bit sequence of data>
 */
var paramRegExp = /; *([!#$%&'\*\+\-\.0-9A-Z\^_`a-z\|~]+) *= *("(?:[ !\u0023-\u005b\u005d-\u007e\u0080-\u00ff]|\\[\u0020-\u007e])*"|[!#$%&'\*\+\-\.0-9A-Z\^_`a-z\|~]+) */g;
var textRegExp = /^[\u0020-\u007e\u0080-\u00ff]+$/
var tokenRegExp = /^[!#$%&'\*\+\-\.0-9A-Z\^_`a-z\|~]+$/

/**
 * RegExp to match quoted-pair in RFC 2616
 *
 * quoted-pair = "\" CHAR
 * CHAR        = <any US-ASCII character (octets 0 - 127)>
 */
var qescRegExp = /\\([\u0000-\u007f])/g;

/**
 * RegExp to match chars that must be quoted-pair in RFC 2616
 */
var quoteRegExp = /([\\"])/g;

/**
 * RegExp to match type in RFC 6838
 *
 * type-name = restricted-name
 * subtype-name = restricted-name
 * restricted-name = restricted-name-first *126restricted-name-chars
 * restricted-name-first  = ALPHA / DIGIT
 * restricted-name-chars  = ALPHA / DIGIT / "!" / "#" /
 *                          "$" / "&" / "-" / "^" / "_"
 * restricted-name-chars =/ "." ; Characters before first dot always
 *                              ; specify a facet name
 * restricted-name-chars =/ "+" ; Characters after last plus always
 *                              ; specify a structured syntax suffix
 * ALPHA =  %x41-5A / %x61-7A   ; A-Z / a-z
 * DIGIT =  %x30-39             ; 0-9
 */
var subtypeNameRegExp = /^[A-Za-z0-9][A-Za-z0-9!#$&^_.-]{0,126}$/
var typeNameRegExp = /^[A-Za-z0-9][A-Za-z0-9!#$&^_-]{0,126}$/
var typeRegExp = /^ *([A-Za-z0-9][A-Za-z0-9!#$&^_-]{0,126})\/([A-Za-z0-9][A-Za-z0-9!#$&^_.+-]{0,126}) *$/;

/**
 * Module exports.
 */

exports.format = format
exports.parse = parse

/**
 * Format object to media type.
 *
 * @param {object} obj
 * @return {string}
 * @api public
 */

function format(obj) {
  if (!obj || typeof obj !== 'object') {
    throw new TypeError('argument obj is required')
  }

  var parameters = obj.parameters
  var subtype = obj.subtype
  var suffix = obj.suffix
  var type = obj.type

  if (!type || !typeNameRegExp.test(type)) {
    throw new TypeError('invalid type')
  }

  if (!subtype || !subtypeNameRegExp.test(subtype)) {
    throw new TypeError('invalid subtype')
  }

  // format as type/subtype
  var string = type + '/' + subtype

  // append +suffix
  if (suffix) {
    if (!typeNameRegExp.test(suffix)) {
      throw new TypeError('invalid suffix')
    }

    string += '+' + suffix
  }

  // append parameters
  if (parameters && typeof parameters === 'object') {
    var param
    var params = Object.keys(parameters).sort()

    for (var i = 0; i < params.length; i++) {
      param = params[i]

      if (!tokenRegExp.test(param)) {
        throw new TypeError('invalid parameter name')
      }

      string += '; ' + param + '=' + qstring(parameters[param])
    }
  }

  return string
}

/**
 * Parse media type to object.
 *
 * @param {string|object} string
 * @return {Object}
 * @api public
 */

function parse(string) {
  if (!string) {
    throw new TypeError('argument string is required')
  }

  // support req/res-like objects as argument
  if (typeof string === 'object') {
    string = getcontenttype(string)
  }

  if (typeof string !== 'string') {
    throw new TypeError('argument string is required to be a string')
  }

  var index = string.indexOf(';')
  var type = index !== -1
    ? string.substr(0, index)
    : string

  var key
  var match
  var obj = splitType(type)
  var params = {}
  var value

  paramRegExp.lastIndex = index

  while (match = paramRegExp.exec(string)) {
    if (match.index !== index) {
      throw new TypeError('invalid parameter format')
    }

    index += match[0].length
    key = match[1].toLowerCase()
    value = match[2]

    if (value[0] === '"') {
      // remove quotes and escapes
      value = value
        .substr(1, value.length - 2)
        .replace(qescRegExp, '$1')
    }

    params[key] = value
  }

  if (index !== -1 && index !== string.length) {
    throw new TypeError('invalid parameter format')
  }

  obj.parameters = params

  return obj
}

/**
 * Get content-type from req/res objects.
 *
 * @param {object}
 * @return {Object}
 * @api private
 */

function getcontenttype(obj) {
  if (typeof obj.getHeader === 'function') {
    // res-like
    return obj.getHeader('content-type')
  }

  if (typeof obj.headers === 'object') {
    // req-like
    return obj.headers && obj.headers['content-type']
  }
}

/**
 * Quote a string if necessary.
 *
 * @param {string} val
 * @return {string}
 * @api private
 */

function qstring(val) {
  var str = String(val)

  // no need to quote tokens
  if (tokenRegExp.test(str)) {
    return str
  }

  if (str.length > 0 && !textRegExp.test(str)) {
    throw new TypeError('invalid parameter value')
  }

  return '"' + str.replace(quoteRegExp, '\\$1') + '"'
}

/**
 * Simply "type/subtype+siffx" into parts.
 *
 * @param {string} string
 * @return {Object}
 * @api private
 */

function splitType(string) {
  var match = typeRegExp.exec(string.toLowerCase())

  if (!match) {
    throw new TypeError('invalid media type')
  }

  var type = match[1]
  var subtype = match[2]
  var suffix

  // suffix after last +
  var index = subtype.lastIndexOf('+')
  if (index !== -1) {
    suffix = subtype.substr(index + 1)
    subtype = subtype.substr(0, index)
  }

  var obj = {
    type: type,
    subtype: subtype,
    suffix: suffix
  }

  return obj
}


/***/ }),

/***/ 41339:
/***/ ((module) => {

"use strict";
/*!
 * merge-descriptors
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module exports.
 * @public
 */

module.exports = merge

/**
 * Module variables.
 * @private
 */

var hasOwnProperty = Object.prototype.hasOwnProperty

/**
 * Merge the property descriptors of `src` into `dest`
 *
 * @param {object} dest Object to add descriptors to
 * @param {object} src Object to clone descriptors from
 * @param {boolean} [redefine=true] Redefine `dest` properties with `src` properties
 * @returns {object} Reference to dest
 * @public
 */

function merge (dest, src, redefine) {
  if (!dest) {
    throw new TypeError('argument dest is required')
  }

  if (!src) {
    throw new TypeError('argument src is required')
  }

  if (redefine === undefined) {
    // Default to true
    redefine = true
  }

  Object.getOwnPropertyNames(src).forEach(function forEachOwnPropertyName (name) {
    if (!redefine && hasOwnProperty.call(dest, name)) {
      // Skip descriptor
      return
    }

    // Copy descriptor
    var descriptor = Object.getOwnPropertyDescriptor(src, name)
    Object.defineProperty(dest, name, descriptor)
  })

  return dest
}


/***/ }),

/***/ 50806:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";
/*!
 * methods
 * Copyright(c) 2013-2014 TJ Holowaychuk
 * Copyright(c) 2015-2016 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module dependencies.
 * @private
 */

var http = __nccwpck_require__(58611);

/**
 * Module exports.
 * @public
 */

module.exports = getCurrentNodeMethods() || getBasicNodeMethods();

/**
 * Get the current Node.js methods.
 * @private
 */

function getCurrentNodeMethods() {
  return http.METHODS && http.METHODS.map(function lowerCaseMethod(method) {
    return method.toLowerCase();
  });
}

/**
 * Get the "basic" Node.js methods, a snapshot from Node.js 0.10.
 * @private
 */

function getBasicNodeMethods() {
  return [
    'get',
    'post',
    'put',
    'head',
    'delete',
    'options',
    'trace',
    'copy',
    'lock',
    'mkcol',
    'move',
    'purge',
    'propfind',
    'proppatch',
    'unlock',
    'report',
    'mkactivity',
    'checkout',
    'merge',
    'm-search',
    'notify',
    'subscribe',
    'unsubscribe',
    'patch',
    'search',
    'connect'
  ];
}


/***/ }),

/***/ 99829:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

/*!
 * mime-db
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015-2022 Douglas Christopher Wilson
 * MIT Licensed
 */

/**
 * Module exports.
 */

module.exports = __nccwpck_require__(81813)


/***/ }),

/***/ 14096:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";
/*!
 * mime-types
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module dependencies.
 * @private
 */

var db = __nccwpck_require__(99829)
var extname = (__nccwpck_require__(16928).extname)

/**
 * Module variables.
 * @private
 */

var EXTRACT_TYPE_REGEXP = /^\s*([^;\s]*)(?:;|\s|$)/
var TEXT_TYPE_REGEXP = /^text\//i

/**
 * Module exports.
 * @public
 */

exports.charset = charset
exports.charsets = { lookup: charset }
exports.contentType = contentType
exports.extension = extension
exports.extensions = Object.create(null)
exports.lookup = lookup
exports.types = Object.create(null)

// Populate the extensions/types maps
populateMaps(exports.extensions, exports.types)

/**
 * Get the default charset for a MIME type.
 *
 * @param {string} type
 * @return {boolean|string}
 */

function charset (type) {
  if (!type || typeof type !== 'string') {
    return false
  }

  // TODO: use media-typer
  var match = EXTRACT_TYPE_REGEXP.exec(type)
  var mime = match && db[match[1].toLowerCase()]

  if (mime && mime.charset) {
    return mime.charset
  }

  // default text/* to utf-8
  if (match && TEXT_TYPE_REGEXP.test(match[1])) {
    return 'UTF-8'
  }

  return false
}

/**
 * Create a full Content-Type header given a MIME type or extension.
 *
 * @param {string} str
 * @return {boolean|string}
 */

function contentType (str) {
  // TODO: should this even be in this module?
  if (!str || typeof str !== 'string') {
    return false
  }

  var mime = str.indexOf('/') === -1
    ? exports.lookup(str)
    : str

  if (!mime) {
    return false
  }

  // TODO: use content-type or other module
  if (mime.indexOf('charset') === -1) {
    var charset = exports.charset(mime)
    if (charset) mime += '; charset=' + charset.toLowerCase()
  }

  return mime
}

/**
 * Get the default extension for a MIME type.
 *
 * @param {string} type
 * @return {boolean|string}
 */

function extension (type) {
  if (!type || typeof type !== 'string') {
    return false
  }

  // TODO: use media-typer
  var match = EXTRACT_TYPE_REGEXP.exec(type)

  // get extensions
  var exts = match && exports.extensions[match[1].toLowerCase()]

  if (!exts || !exts.length) {
    return false
  }

  return exts[0]
}

/**
 * Lookup the MIME type for a file path/extension.
 *
 * @param {string} path
 * @return {boolean|string}
 */

function lookup (path) {
  if (!path || typeof path !== 'string') {
    return false
  }

  // get the extension ("ext" or ".ext" or full path)
  var extension = extname('x.' + path)
    .toLowerCase()
    .substr(1)

  if (!extension) {
    return false
  }

  return exports.types[extension] || false
}

/**
 * Populate the extensions and types maps.
 * @private
 */

function populateMaps (extensions, types) {
  // source preference (least -> most)
  var preference = ['nginx', 'apache', undefined, 'iana']

  Object.keys(db).forEach(function forEachMimeType (type) {
    var mime = db[type]
    var exts = mime.extensions

    if (!exts || !exts.length) {
      return
    }

    // mime -> extensions
    extensions[type] = exts

    // extension -> mime
    for (var i = 0; i < exts.length; i++) {
      var extension = exts[i]

      if (types[extension]) {
        var from = preference.indexOf(db[types[extension]].source)
        var to = preference.indexOf(mime.source)

        if (types[extension] !== 'application/octet-stream' &&
          (from > to || (from === to && types[extension].substr(0, 12) === 'application/'))) {
          // skip the remapping
          continue
        }
      }

      // set the extension -> mime
      types[extension] = type
    }
  })
}


/***/ }),

/***/ 70744:
/***/ ((module) => {

/**
 * Helpers.
 */

var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var w = d * 7;
var y = d * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */

module.exports = function (val, options) {
  options = options || {};
  var type = typeof val;
  if (type === 'string' && val.length > 0) {
    return parse(val);
  } else if (type === 'number' && isFinite(val)) {
    return options.long ? fmtLong(val) : fmtShort(val);
  }
  throw new Error(
    'val is not a non-empty string or a valid number. val=' +
      JSON.stringify(val)
  );
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  str = String(str);
  if (str.length > 100) {
    return;
  }
  var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
    str
  );
  if (!match) {
    return;
  }
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;
    case 'weeks':
    case 'week':
    case 'w':
      return n * w;
    case 'days':
    case 'day':
    case 'd':
      return n * d;
    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h;
    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m;
    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s;
    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;
    default:
      return undefined;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtShort(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d) {
    return Math.round(ms / d) + 'd';
  }
  if (msAbs >= h) {
    return Math.round(ms / h) + 'h';
  }
  if (msAbs >= m) {
    return Math.round(ms / m) + 'm';
  }
  if (msAbs >= s) {
    return Math.round(ms / s) + 's';
  }
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtLong(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d) {
    return plural(ms, msAbs, d, 'day');
  }
  if (msAbs >= h) {
    return plural(ms, msAbs, h, 'hour');
  }
  if (msAbs >= m) {
    return plural(ms, msAbs, m, 'minute');
  }
  if (msAbs >= s) {
    return plural(ms, msAbs, s, 'second');
  }
  return ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural(ms, msAbs, n, name) {
  var isPlural = msAbs >= n * 1.5;
  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');
}


/***/ }),

/***/ 98013:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var makeMiddleware = __nccwpck_require__(68296)

var diskStorage = __nccwpck_require__(86162)
var memoryStorage = __nccwpck_require__(6796)
var MulterError = __nccwpck_require__(6659)

function allowAll (req, file, cb) {
  cb(null, true)
}

function Multer (options) {
  if (options.storage) {
    this.storage = options.storage
  } else if (options.dest) {
    this.storage = diskStorage({ destination: options.dest })
  } else {
    this.storage = memoryStorage()
  }

  this.limits = options.limits
  this.preservePath = options.preservePath
  this.fileFilter = options.fileFilter || allowAll
}

Multer.prototype._makeMiddleware = function (fields, fileStrategy) {
  function setup () {
    var fileFilter = this.fileFilter
    var filesLeft = Object.create(null)

    fields.forEach(function (field) {
      if (typeof field.maxCount === 'number') {
        filesLeft[field.name] = field.maxCount
      } else {
        filesLeft[field.name] = Infinity
      }
    })

    function wrappedFileFilter (req, file, cb) {
      if ((filesLeft[file.fieldname] || 0) <= 0) {
        return cb(new MulterError('LIMIT_UNEXPECTED_FILE', file.fieldname))
      }

      filesLeft[file.fieldname] -= 1
      fileFilter(req, file, cb)
    }

    return {
      limits: this.limits,
      preservePath: this.preservePath,
      storage: this.storage,
      fileFilter: wrappedFileFilter,
      fileStrategy: fileStrategy
    }
  }

  return makeMiddleware(setup.bind(this))
}

Multer.prototype.single = function (name) {
  return this._makeMiddleware([{ name: name, maxCount: 1 }], 'VALUE')
}

Multer.prototype.array = function (name, maxCount) {
  return this._makeMiddleware([{ name: name, maxCount: maxCount }], 'ARRAY')
}

Multer.prototype.fields = function (fields) {
  return this._makeMiddleware(fields, 'OBJECT')
}

Multer.prototype.none = function () {
  return this._makeMiddleware([], 'NONE')
}

Multer.prototype.any = function () {
  function setup () {
    return {
      limits: this.limits,
      preservePath: this.preservePath,
      storage: this.storage,
      fileFilter: this.fileFilter,
      fileStrategy: 'ARRAY'
    }
  }

  return makeMiddleware(setup.bind(this))
}

function multer (options) {
  if (options === undefined) {
    return new Multer({})
  }

  if (typeof options === 'object' && options !== null) {
    return new Multer(options)
  }

  throw new TypeError('Expected object for argument options')
}

module.exports = multer
module.exports.diskStorage = diskStorage
module.exports.memoryStorage = memoryStorage
module.exports.MulterError = MulterError


/***/ }),

/***/ 7929:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var EventEmitter = (__nccwpck_require__(24434).EventEmitter)

function Counter () {
  EventEmitter.call(this)
  this.value = 0
}

Counter.prototype = Object.create(EventEmitter.prototype)

Counter.prototype.increment = function increment () {
  this.value++
}

Counter.prototype.decrement = function decrement () {
  if (--this.value === 0) this.emit('zero')
}

Counter.prototype.isZero = function isZero () {
  return (this.value === 0)
}

Counter.prototype.onceZero = function onceZero (fn) {
  if (this.isZero()) return fn()

  this.once('zero', fn)
}

module.exports = Counter


/***/ }),

/***/ 33099:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var objectAssign = __nccwpck_require__(56996)

function arrayRemove (arr, item) {
  var idx = arr.indexOf(item)
  if (~idx) arr.splice(idx, 1)
}

function FileAppender (strategy, req) {
  this.strategy = strategy
  this.req = req

  switch (strategy) {
    case 'NONE': break
    case 'VALUE': break
    case 'ARRAY': req.files = []; break
    case 'OBJECT': req.files = Object.create(null); break
    default: throw new Error('Unknown file strategy: ' + strategy)
  }
}

FileAppender.prototype.insertPlaceholder = function (file) {
  var placeholder = {
    fieldname: file.fieldname
  }

  switch (this.strategy) {
    case 'NONE': break
    case 'VALUE': break
    case 'ARRAY': this.req.files.push(placeholder); break
    case 'OBJECT':
      if (this.req.files[file.fieldname]) {
        this.req.files[file.fieldname].push(placeholder)
      } else {
        this.req.files[file.fieldname] = [placeholder]
      }
      break
  }

  return placeholder
}

FileAppender.prototype.removePlaceholder = function (placeholder) {
  switch (this.strategy) {
    case 'NONE': break
    case 'VALUE': break
    case 'ARRAY': arrayRemove(this.req.files, placeholder); break
    case 'OBJECT':
      if (this.req.files[placeholder.fieldname].length === 1) {
        delete this.req.files[placeholder.fieldname]
      } else {
        arrayRemove(this.req.files[placeholder.fieldname], placeholder)
      }
      break
  }
}

FileAppender.prototype.replacePlaceholder = function (placeholder, file) {
  if (this.strategy === 'VALUE') {
    this.req.file = file
    return
  }

  delete placeholder.fieldname
  objectAssign(placeholder, file)
}

module.exports = FileAppender


/***/ }),

/***/ 68296:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var is = __nccwpck_require__(27323)
var Busboy = __nccwpck_require__(680)
var extend = __nccwpck_require__(80869)
var appendField = __nccwpck_require__(85541)

var Counter = __nccwpck_require__(7929)
var MulterError = __nccwpck_require__(6659)
var FileAppender = __nccwpck_require__(33099)
var removeUploadedFiles = __nccwpck_require__(12228)

function makeMiddleware (setup) {
  return function multerMiddleware (req, res, next) {
    if (!is(req, ['multipart'])) return next()

    var options = setup()

    var limits = options.limits
    var storage = options.storage
    var fileFilter = options.fileFilter
    var fileStrategy = options.fileStrategy
    var preservePath = options.preservePath

    req.body = Object.create(null)

    var busboy

    try {
      busboy = Busboy({ headers: req.headers, limits: limits, preservePath: preservePath })
    } catch (err) {
      return next(err)
    }

    var appender = new FileAppender(fileStrategy, req)
    var isDone = false
    var readFinished = false
    var errorOccured = false
    var pendingWrites = new Counter()
    var uploadedFiles = []

    function done (err) {
      if (isDone) return
      isDone = true
      req.unpipe(busboy)
      process.nextTick(() => {
        busboy.removeAllListeners()
      })
      next(err)
    }

    function indicateDone () {
      if (readFinished && pendingWrites.isZero() && !errorOccured) done()
    }

    function abortWithError (uploadError) {
      if (errorOccured) return
      errorOccured = true

      pendingWrites.onceZero(function () {
        function remove (file, cb) {
          storage._removeFile(req, file, cb)
        }

        removeUploadedFiles(uploadedFiles, remove, function (err, storageErrors) {
          if (err) return done(err)

          uploadError.storageErrors = storageErrors
          done(uploadError)
        })
      })
    }

    function abortWithCode (code, optionalField) {
      abortWithError(new MulterError(code, optionalField))
    }

    // handle text field data
    busboy.on('field', function (fieldname, value, { nameTruncated, valueTruncated }) {
      if (fieldname == null) return abortWithCode('MISSING_FIELD_NAME')
      if (nameTruncated) return abortWithCode('LIMIT_FIELD_KEY')
      if (valueTruncated) return abortWithCode('LIMIT_FIELD_VALUE', fieldname)

      // Work around bug in Busboy (https://github.com/mscdex/busboy/issues/6)
      if (limits && Object.prototype.hasOwnProperty.call(limits, 'fieldNameSize')) {
        if (fieldname.length > limits.fieldNameSize) return abortWithCode('LIMIT_FIELD_KEY')
      }

      appendField(req.body, fieldname, value)
    })

    // handle files
    busboy.on('file', function (fieldname, fileStream, { filename, encoding, mimeType }) {
      // don't attach to the files object, if there is no file
      if (!filename) return fileStream.resume()

      // Work around bug in Busboy (https://github.com/mscdex/busboy/issues/6)
      if (limits && Object.prototype.hasOwnProperty.call(limits, 'fieldNameSize')) {
        if (fieldname.length > limits.fieldNameSize) return abortWithCode('LIMIT_FIELD_KEY')
      }

      var file = {
        fieldname: fieldname,
        originalname: filename,
        encoding: encoding,
        mimetype: mimeType
      }

      var placeholder = appender.insertPlaceholder(file)

      fileFilter(req, file, function (err, includeFile) {
        if (err) {
          appender.removePlaceholder(placeholder)
          return abortWithError(err)
        }

        if (!includeFile) {
          appender.removePlaceholder(placeholder)
          return fileStream.resume()
        }

        var aborting = false
        pendingWrites.increment()

        Object.defineProperty(file, 'stream', {
          configurable: true,
          enumerable: false,
          value: fileStream
        })

        fileStream.on('error', function (err) {
          pendingWrites.decrement()
          abortWithError(err)
        })

        fileStream.on('limit', function () {
          aborting = true
          abortWithCode('LIMIT_FILE_SIZE', fieldname)
        })

        storage._handleFile(req, file, function (err, info) {
          if (aborting) {
            appender.removePlaceholder(placeholder)
            uploadedFiles.push(extend(file, info))
            return pendingWrites.decrement()
          }

          if (err) {
            appender.removePlaceholder(placeholder)
            pendingWrites.decrement()
            return abortWithError(err)
          }

          var fileInfo = extend(file, info)

          appender.replacePlaceholder(placeholder, fileInfo)
          uploadedFiles.push(fileInfo)
          pendingWrites.decrement()
          indicateDone()
        })
      })
    })

    busboy.on('error', function (err) { abortWithError(err) })
    busboy.on('partsLimit', function () { abortWithCode('LIMIT_PART_COUNT') })
    busboy.on('filesLimit', function () { abortWithCode('LIMIT_FILE_COUNT') })
    busboy.on('fieldsLimit', function () { abortWithCode('LIMIT_FIELD_COUNT') })
    busboy.on('close', function () {
      readFinished = true
      indicateDone()
    })

    req.pipe(busboy)
  }
}

module.exports = makeMiddleware


/***/ }),

/***/ 6659:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var util = __nccwpck_require__(39023)

var errorMessages = {
  LIMIT_PART_COUNT: 'Too many parts',
  LIMIT_FILE_SIZE: 'File too large',
  LIMIT_FILE_COUNT: 'Too many files',
  LIMIT_FIELD_KEY: 'Field name too long',
  LIMIT_FIELD_VALUE: 'Field value too long',
  LIMIT_FIELD_COUNT: 'Too many fields',
  LIMIT_UNEXPECTED_FILE: 'Unexpected field',
  MISSING_FIELD_NAME: 'Field name missing'
}

function MulterError (code, field) {
  Error.captureStackTrace(this, this.constructor)
  this.name = this.constructor.name
  this.message = errorMessages[code]
  this.code = code
  if (field) this.field = field
}

util.inherits(MulterError, Error)

module.exports = MulterError


/***/ }),

/***/ 12228:
/***/ ((module) => {

function removeUploadedFiles (uploadedFiles, remove, cb) {
  var length = uploadedFiles.length
  var errors = []

  if (length === 0) return cb(null, errors)

  function handleFile (idx) {
    var file = uploadedFiles[idx]

    remove(file, function (err) {
      if (err) {
        err.file = file
        err.field = file.fieldname
        errors.push(err)
      }

      if (idx < length - 1) {
        handleFile(idx + 1)
      } else {
        cb(null, errors)
      }
    })
  }

  handleFile(0)
}

module.exports = removeUploadedFiles


/***/ }),

/***/ 10496:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var path = __nccwpck_require__(16928);
var fs = __nccwpck_require__(79896);
var _0777 = parseInt('0777', 8);

module.exports = mkdirP.mkdirp = mkdirP.mkdirP = mkdirP;

function mkdirP (p, opts, f, made) {
    if (typeof opts === 'function') {
        f = opts;
        opts = {};
    }
    else if (!opts || typeof opts !== 'object') {
        opts = { mode: opts };
    }
    
    var mode = opts.mode;
    var xfs = opts.fs || fs;
    
    if (mode === undefined) {
        mode = _0777
    }
    if (!made) made = null;
    
    var cb = f || /* istanbul ignore next */ function () {};
    p = path.resolve(p);
    
    xfs.mkdir(p, mode, function (er) {
        if (!er) {
            made = made || p;
            return cb(null, made);
        }
        switch (er.code) {
            case 'ENOENT':
                /* istanbul ignore if */
                if (path.dirname(p) === p) return cb(er);
                mkdirP(path.dirname(p), opts, function (er, made) {
                    /* istanbul ignore if */
                    if (er) cb(er, made);
                    else mkdirP(p, opts, cb, made);
                });
                break;

            // In the case of any other error, just see if there's a dir
            // there already.  If so, then hooray!  If not, then something
            // is borked.
            default:
                xfs.stat(p, function (er2, stat) {
                    // if the stat fails, then that's super weird.
                    // let the original error be the failure reason.
                    if (er2 || !stat.isDirectory()) cb(er, made)
                    else cb(null, made);
                });
                break;
        }
    });
}

mkdirP.sync = function sync (p, opts, made) {
    if (!opts || typeof opts !== 'object') {
        opts = { mode: opts };
    }
    
    var mode = opts.mode;
    var xfs = opts.fs || fs;
    
    if (mode === undefined) {
        mode = _0777
    }
    if (!made) made = null;

    p = path.resolve(p);

    try {
        xfs.mkdirSync(p, mode);
        made = made || p;
    }
    catch (err0) {
        switch (err0.code) {
            case 'ENOENT' :
                made = sync(path.dirname(p), opts, made);
                sync(p, opts, made);
                break;

            // In the case of any other error, just see if there's a dir
            // there already.  If so, then hooray!  If not, then something
            // is borked.
            default:
                var stat;
                try {
                    stat = xfs.statSync(p);
                }
                catch (err1) /* istanbul ignore next */ {
                    throw err0;
                }
                /* istanbul ignore if */
                if (!stat.isDirectory()) throw err0;
                break;
        }
    }

    return made;
};


/***/ }),

/***/ 86162:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var fs = __nccwpck_require__(79896)
var os = __nccwpck_require__(70857)
var path = __nccwpck_require__(16928)
var crypto = __nccwpck_require__(76982)
var mkdirp = __nccwpck_require__(10496)

function getFilename (req, file, cb) {
  crypto.randomBytes(16, function (err, raw) {
    cb(err, err ? undefined : raw.toString('hex'))
  })
}

function getDestination (req, file, cb) {
  cb(null, os.tmpdir())
}

function DiskStorage (opts) {
  this.getFilename = (opts.filename || getFilename)

  if (typeof opts.destination === 'string') {
    mkdirp.sync(opts.destination)
    this.getDestination = function ($0, $1, cb) { cb(null, opts.destination) }
  } else {
    this.getDestination = (opts.destination || getDestination)
  }
}

DiskStorage.prototype._handleFile = function _handleFile (req, file, cb) {
  var that = this

  that.getDestination(req, file, function (err, destination) {
    if (err) return cb(err)

    that.getFilename(req, file, function (err, filename) {
      if (err) return cb(err)

      var finalPath = path.join(destination, filename)
      var outStream = fs.createWriteStream(finalPath)

      file.stream.pipe(outStream)
      outStream.on('error', cb)
      outStream.on('finish', function () {
        cb(null, {
          destination: destination,
          filename: filename,
          path: finalPath,
          size: outStream.bytesWritten
        })
      })
    })
  })
}

DiskStorage.prototype._removeFile = function _removeFile (req, file, cb) {
  var path = file.path

  delete file.destination
  delete file.filename
  delete file.path

  fs.unlink(path, cb)
}

module.exports = function (opts) {
  return new DiskStorage(opts)
}


/***/ }),

/***/ 6796:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var concat = __nccwpck_require__(18015)

function MemoryStorage (opts) {}

MemoryStorage.prototype._handleFile = function _handleFile (req, file, cb) {
  file.stream.pipe(concat({ encoding: 'buffer' }, function (data) {
    cb(null, {
      buffer: data,
      size: data.length
    })
  }))
}

MemoryStorage.prototype._removeFile = function _removeFile (req, file, cb) {
  delete file.buffer
  cb(null)
}

module.exports = function (opts) {
  return new MemoryStorage(opts)
}


/***/ }),

/***/ 89642:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

var Buffer = (__nccwpck_require__(12803).Buffer)

// Multibyte codec. In this scheme, a character is represented by 1 or more bytes.
// Our codec supports UTF-16 surrogates, extensions for GB18030 and unicode sequences.
// To save memory and loading time, we read table files only when requested.

exports._dbcs = DBCSCodec

var UNASSIGNED = -1
var GB18030_CODE = -2
var SEQ_START = -10
var NODE_START = -1000
var UNASSIGNED_NODE = new Array(0x100)
var DEF_CHAR = -1

for (var i = 0; i < 0x100; i++) { UNASSIGNED_NODE[i] = UNASSIGNED }

// Class DBCSCodec reads and initializes mapping tables.
function DBCSCodec (codecOptions, iconv) {
  this.encodingName = codecOptions.encodingName
  if (!codecOptions) { throw new Error("DBCS codec is called without the data.") }
  if (!codecOptions.table) { throw new Error("Encoding '" + this.encodingName + "' has no data.") }

  // Load tables.
  var mappingTable = codecOptions.table()

  // Decode tables: MBCS -> Unicode.

  // decodeTables is a trie, encoded as an array of arrays of integers. Internal arrays are trie nodes and all have len = 256.
  // Trie root is decodeTables[0].
  // Values: >=  0 -> unicode character code. can be > 0xFFFF
  //         == UNASSIGNED -> unknown/unassigned sequence.
  //         == GB18030_CODE -> this is the end of a GB18030 4-byte sequence.
  //         <= NODE_START -> index of the next node in our trie to process next byte.
  //         <= SEQ_START  -> index of the start of a character code sequence, in decodeTableSeq.
  this.decodeTables = []
  this.decodeTables[0] = UNASSIGNED_NODE.slice(0) // Create root node.

  // Sometimes a MBCS char corresponds to a sequence of unicode chars. We store them as arrays of integers here.
  this.decodeTableSeq = []

  // Actual mapping tables consist of chunks. Use them to fill up decode tables.
  for (var i = 0; i < mappingTable.length; i++) { this._addDecodeChunk(mappingTable[i]) }

  // Load & create GB18030 tables when needed.
  if (typeof codecOptions.gb18030 === "function") {
    this.gb18030 = codecOptions.gb18030() // Load GB18030 ranges.

    // Add GB18030 common decode nodes.
    var commonThirdByteNodeIdx = this.decodeTables.length
    this.decodeTables.push(UNASSIGNED_NODE.slice(0))

    var commonFourthByteNodeIdx = this.decodeTables.length
    this.decodeTables.push(UNASSIGNED_NODE.slice(0))

    // Fill out the tree
    var firstByteNode = this.decodeTables[0]
    for (var i = 0x81; i <= 0xFE; i++) {
      var secondByteNode = this.decodeTables[NODE_START - firstByteNode[i]]
      for (var j = 0x30; j <= 0x39; j++) {
        if (secondByteNode[j] === UNASSIGNED) {
          secondByteNode[j] = NODE_START - commonThirdByteNodeIdx
        } else if (secondByteNode[j] > NODE_START) {
          throw new Error("gb18030 decode tables conflict at byte 2")
        }

        var thirdByteNode = this.decodeTables[NODE_START - secondByteNode[j]]
        for (var k = 0x81; k <= 0xFE; k++) {
          if (thirdByteNode[k] === UNASSIGNED) {
            thirdByteNode[k] = NODE_START - commonFourthByteNodeIdx
          } else if (thirdByteNode[k] === NODE_START - commonFourthByteNodeIdx) {
            continue
          } else if (thirdByteNode[k] > NODE_START) {
            throw new Error("gb18030 decode tables conflict at byte 3")
          }

          var fourthByteNode = this.decodeTables[NODE_START - thirdByteNode[k]]
          for (var l = 0x30; l <= 0x39; l++) {
            if (fourthByteNode[l] === UNASSIGNED) { fourthByteNode[l] = GB18030_CODE }
          }
        }
      }
    }
  }

  this.defaultCharUnicode = iconv.defaultCharUnicode

  // Encode tables: Unicode -> DBCS.

  // `encodeTable` is array mapping from unicode char to encoded char. All its values are integers for performance.
  // Because it can be sparse, it is represented as array of buckets by 256 chars each. Bucket can be null.
  // Values: >=  0 -> it is a normal char. Write the value (if <=256 then 1 byte, if <=65536 then 2 bytes, etc.).
  //         == UNASSIGNED -> no conversion found. Output a default char.
  //         <= SEQ_START  -> it's an index in encodeTableSeq, see below. The character starts a sequence.
  this.encodeTable = []

  // `encodeTableSeq` is used when a sequence of unicode characters is encoded as a single code. We use a tree of
  // objects where keys correspond to characters in sequence and leafs are the encoded dbcs values. A special DEF_CHAR key
  // means end of sequence (needed when one sequence is a strict subsequence of another).
  // Objects are kept separately from encodeTable to increase performance.
  this.encodeTableSeq = []

  // Some chars can be decoded, but need not be encoded.
  var skipEncodeChars = {}
  if (codecOptions.encodeSkipVals) {
    for (var i = 0; i < codecOptions.encodeSkipVals.length; i++) {
      var val = codecOptions.encodeSkipVals[i]
      if (typeof val === "number") { skipEncodeChars[val] = true } else {
        for (var j = val.from; j <= val.to; j++) { skipEncodeChars[j] = true }
      }
    }
  }

  // Use decode trie to recursively fill out encode tables.
  this._fillEncodeTable(0, 0, skipEncodeChars)

  // Add more encoding pairs when needed.
  if (codecOptions.encodeAdd) {
    for (var uChar in codecOptions.encodeAdd) {
      if (Object.prototype.hasOwnProperty.call(codecOptions.encodeAdd, uChar)) { this._setEncodeChar(uChar.charCodeAt(0), codecOptions.encodeAdd[uChar]) }
    }
  }

  this.defCharSB = this.encodeTable[0][iconv.defaultCharSingleByte.charCodeAt(0)]
  if (this.defCharSB === UNASSIGNED) this.defCharSB = this.encodeTable[0]["?"]
  if (this.defCharSB === UNASSIGNED) this.defCharSB = "?".charCodeAt(0)
}

DBCSCodec.prototype.encoder = DBCSEncoder
DBCSCodec.prototype.decoder = DBCSDecoder

// Decoder helpers
DBCSCodec.prototype._getDecodeTrieNode = function (addr) {
  var bytes = []
  for (; addr > 0; addr >>>= 8) { bytes.push(addr & 0xFF) }
  if (bytes.length == 0) { bytes.push(0) }

  var node = this.decodeTables[0]
  for (var i = bytes.length - 1; i > 0; i--) { // Traverse nodes deeper into the trie.
    var val = node[bytes[i]]

    if (val == UNASSIGNED) { // Create new node.
      node[bytes[i]] = NODE_START - this.decodeTables.length
      this.decodeTables.push(node = UNASSIGNED_NODE.slice(0))
    } else if (val <= NODE_START) { // Existing node.
      node = this.decodeTables[NODE_START - val]
    } else { throw new Error("Overwrite byte in " + this.encodingName + ", addr: " + addr.toString(16)) }
  }
  return node
}

DBCSCodec.prototype._addDecodeChunk = function (chunk) {
  // First element of chunk is the hex mbcs code where we start.
  var curAddr = parseInt(chunk[0], 16)

  // Choose the decoding node where we'll write our chars.
  var writeTable = this._getDecodeTrieNode(curAddr)
  curAddr = curAddr & 0xFF

  // Write all other elements of the chunk to the table.
  for (var k = 1; k < chunk.length; k++) {
    var part = chunk[k]
    if (typeof part === "string") { // String, write as-is.
      for (var l = 0; l < part.length;) {
        var code = part.charCodeAt(l++)
        if (code >= 0xD800 && code < 0xDC00) { // Decode surrogate
          var codeTrail = part.charCodeAt(l++)
          if (codeTrail >= 0xDC00 && codeTrail < 0xE000) { writeTable[curAddr++] = 0x10000 + (code - 0xD800) * 0x400 + (codeTrail - 0xDC00) } else { throw new Error("Incorrect surrogate pair in " + this.encodingName + " at chunk " + chunk[0]) }
        } else if (code > 0x0FF0 && code <= 0x0FFF) { // Character sequence (our own encoding used)
          var len = 0xFFF - code + 2
          var seq = []
          for (var m = 0; m < len; m++) { seq.push(part.charCodeAt(l++)) } // Simple variation: don't support surrogates or subsequences in seq.

          writeTable[curAddr++] = SEQ_START - this.decodeTableSeq.length
          this.decodeTableSeq.push(seq)
        } else { writeTable[curAddr++] = code } // Basic char
      }
    } else if (typeof part === "number") { // Integer, meaning increasing sequence starting with prev character.
      var charCode = writeTable[curAddr - 1] + 1
      for (var l = 0; l < part; l++) { writeTable[curAddr++] = charCode++ }
    } else { throw new Error("Incorrect type '" + typeof part + "' given in " + this.encodingName + " at chunk " + chunk[0]) }
  }
  if (curAddr > 0xFF) { throw new Error("Incorrect chunk in " + this.encodingName + " at addr " + chunk[0] + ": too long" + curAddr) }
}

// Encoder helpers
DBCSCodec.prototype._getEncodeBucket = function (uCode) {
  var high = uCode >> 8 // This could be > 0xFF because of astral characters.
  if (this.encodeTable[high] === undefined) {
    this.encodeTable[high] = UNASSIGNED_NODE.slice(0)
  } // Create bucket on demand.
  return this.encodeTable[high]
}

DBCSCodec.prototype._setEncodeChar = function (uCode, dbcsCode) {
  var bucket = this._getEncodeBucket(uCode)
  var low = uCode & 0xFF
  if (bucket[low] <= SEQ_START) { this.encodeTableSeq[SEQ_START - bucket[low]][DEF_CHAR] = dbcsCode } // There's already a sequence, set a single-char subsequence of it.
  else if (bucket[low] == UNASSIGNED) { bucket[low] = dbcsCode }
}

DBCSCodec.prototype._setEncodeSequence = function (seq, dbcsCode) {
  // Get the root of character tree according to first character of the sequence.
  var uCode = seq[0]
  var bucket = this._getEncodeBucket(uCode)
  var low = uCode & 0xFF

  var node
  if (bucket[low] <= SEQ_START) {
    // There's already a sequence with  - use it.
    node = this.encodeTableSeq[SEQ_START - bucket[low]]
  } else {
    // There was no sequence object - allocate a new one.
    node = {}
    if (bucket[low] !== UNASSIGNED) node[DEF_CHAR] = bucket[low] // If a char was set before - make it a single-char subsequence.
    bucket[low] = SEQ_START - this.encodeTableSeq.length
    this.encodeTableSeq.push(node)
  }

  // Traverse the character tree, allocating new nodes as needed.
  for (var j = 1; j < seq.length - 1; j++) {
    var oldVal = node[uCode]
    if (typeof oldVal === "object") { node = oldVal } else {
      node = node[uCode] = {}
      if (oldVal !== undefined) { node[DEF_CHAR] = oldVal }
    }
  }

  // Set the leaf to given dbcsCode.
  uCode = seq[seq.length - 1]
  node[uCode] = dbcsCode
}

DBCSCodec.prototype._fillEncodeTable = function (nodeIdx, prefix, skipEncodeChars) {
  var node = this.decodeTables[nodeIdx]
  var hasValues = false
  var subNodeEmpty = {}
  for (var i = 0; i < 0x100; i++) {
    var uCode = node[i]
    var mbCode = prefix + i
    if (skipEncodeChars[mbCode]) { continue }

    if (uCode >= 0) {
      this._setEncodeChar(uCode, mbCode)
      hasValues = true
    } else if (uCode <= NODE_START) {
      var subNodeIdx = NODE_START - uCode
      if (!subNodeEmpty[subNodeIdx]) {  // Skip empty subtrees (they are too large in gb18030).
        var newPrefix = (mbCode << 8) >>> 0  // NOTE: '>>> 0' keeps 32-bit num positive.
        if (this._fillEncodeTable(subNodeIdx, newPrefix, skipEncodeChars)) { hasValues = true } else { subNodeEmpty[subNodeIdx] = true }
      }
    } else if (uCode <= SEQ_START) {
      this._setEncodeSequence(this.decodeTableSeq[SEQ_START - uCode], mbCode)
      hasValues = true
    }
  }
  return hasValues
}

// == Encoder ==================================================================

function DBCSEncoder (options, codec) {
  // Encoder state
  this.leadSurrogate = -1
  this.seqObj = undefined

  // Static data
  this.encodeTable = codec.encodeTable
  this.encodeTableSeq = codec.encodeTableSeq
  this.defaultCharSingleByte = codec.defCharSB
  this.gb18030 = codec.gb18030
}

DBCSEncoder.prototype.write = function (str) {
  var newBuf = Buffer.alloc(str.length * (this.gb18030 ? 4 : 3))
  var leadSurrogate = this.leadSurrogate
  var seqObj = this.seqObj
  var nextChar = -1
  var i = 0; var j = 0

  while (true) {
    // 0. Get next character.
    if (nextChar === -1) {
      if (i == str.length) break
      var uCode = str.charCodeAt(i++)
    } else {
      var uCode = nextChar
      nextChar = -1
    }

    // 1. Handle surrogates.
    if (uCode >= 0xD800 && uCode < 0xE000) { // Char is one of surrogates.
      if (uCode < 0xDC00) { // We've got lead surrogate.
        if (leadSurrogate === -1) {
          leadSurrogate = uCode
          continue
        } else {
          leadSurrogate = uCode
          // Double lead surrogate found.
          uCode = UNASSIGNED
        }
      } else { // We've got trail surrogate.
        if (leadSurrogate !== -1) {
          uCode = 0x10000 + (leadSurrogate - 0xD800) * 0x400 + (uCode - 0xDC00)
          leadSurrogate = -1
        } else {
          // Incomplete surrogate pair - only trail surrogate found.
          uCode = UNASSIGNED
        }
      }
    } else if (leadSurrogate !== -1) {
      // Incomplete surrogate pair - only lead surrogate found.
      nextChar = uCode; uCode = UNASSIGNED // Write an error, then current char.
      leadSurrogate = -1
    }

    // 2. Convert uCode character.
    var dbcsCode = UNASSIGNED
    if (seqObj !== undefined && uCode != UNASSIGNED) { // We are in the middle of the sequence
      var resCode = seqObj[uCode]
      if (typeof resCode === "object") { // Sequence continues.
        seqObj = resCode
        continue
      } else if (typeof resCode === "number") { // Sequence finished. Write it.
        dbcsCode = resCode
      } else if (resCode == undefined) { // Current character is not part of the sequence.
        // Try default character for this sequence
        resCode = seqObj[DEF_CHAR]
        if (resCode !== undefined) {
          dbcsCode = resCode // Found. Write it.
          nextChar = uCode // Current character will be written too in the next iteration.
        } else {
          // TODO: What if we have no default? (resCode == undefined)
          // Then, we should write first char of the sequence as-is and try the rest recursively.
          // Didn't do it for now because no encoding has this situation yet.
          // Currently, just skip the sequence and write current char.
        }
      }
      seqObj = undefined
    } else if (uCode >= 0) {  // Regular character
      var subtable = this.encodeTable[uCode >> 8]
      if (subtable !== undefined) { dbcsCode = subtable[uCode & 0xFF] }

      if (dbcsCode <= SEQ_START) { // Sequence start
        seqObj = this.encodeTableSeq[SEQ_START - dbcsCode]
        continue
      }

      if (dbcsCode == UNASSIGNED && this.gb18030) {
        // Use GB18030 algorithm to find character(s) to write.
        var idx = findIdx(this.gb18030.uChars, uCode)
        if (idx != -1) {
          var dbcsCode = this.gb18030.gbChars[idx] + (uCode - this.gb18030.uChars[idx])
          newBuf[j++] = 0x81 + Math.floor(dbcsCode / 12600); dbcsCode = dbcsCode % 12600
          newBuf[j++] = 0x30 + Math.floor(dbcsCode / 1260); dbcsCode = dbcsCode % 1260
          newBuf[j++] = 0x81 + Math.floor(dbcsCode / 10); dbcsCode = dbcsCode % 10
          newBuf[j++] = 0x30 + dbcsCode
          continue
        }
      }
    }

    // 3. Write dbcsCode character.
    if (dbcsCode === UNASSIGNED) { dbcsCode = this.defaultCharSingleByte }

    if (dbcsCode < 0x100) {
      newBuf[j++] = dbcsCode
    } else if (dbcsCode < 0x10000) {
      newBuf[j++] = dbcsCode >> 8   // high byte
      newBuf[j++] = dbcsCode & 0xFF // low byte
    } else if (dbcsCode < 0x1000000) {
      newBuf[j++] = dbcsCode >> 16
      newBuf[j++] = (dbcsCode >> 8) & 0xFF
      newBuf[j++] = dbcsCode & 0xFF
    } else {
      newBuf[j++] = dbcsCode >>> 24
      newBuf[j++] = (dbcsCode >>> 16) & 0xFF
      newBuf[j++] = (dbcsCode >>> 8) & 0xFF
      newBuf[j++] = dbcsCode & 0xFF
    }
  }

  this.seqObj = seqObj
  this.leadSurrogate = leadSurrogate
  return newBuf.slice(0, j)
}

DBCSEncoder.prototype.end = function () {
  if (this.leadSurrogate === -1 && this.seqObj === undefined) { return } // All clean. Most often case.

  var newBuf = Buffer.alloc(10); var j = 0

  if (this.seqObj) { // We're in the sequence.
    var dbcsCode = this.seqObj[DEF_CHAR]
    if (dbcsCode !== undefined) { // Write beginning of the sequence.
      if (dbcsCode < 0x100) {
        newBuf[j++] = dbcsCode
      } else {
        newBuf[j++] = dbcsCode >> 8   // high byte
        newBuf[j++] = dbcsCode & 0xFF // low byte
      }
    } else {
      // See todo above.
    }
    this.seqObj = undefined
  }

  if (this.leadSurrogate !== -1) {
    // Incomplete surrogate pair - only lead surrogate found.
    newBuf[j++] = this.defaultCharSingleByte
    this.leadSurrogate = -1
  }

  return newBuf.slice(0, j)
}

// Export for testing
DBCSEncoder.prototype.findIdx = findIdx

// == Decoder ==================================================================

function DBCSDecoder (options, codec) {
  // Decoder state
  this.nodeIdx = 0
  this.prevBytes = []

  // Static data
  this.decodeTables = codec.decodeTables
  this.decodeTableSeq = codec.decodeTableSeq
  this.defaultCharUnicode = codec.defaultCharUnicode
  this.gb18030 = codec.gb18030
}

DBCSDecoder.prototype.write = function (buf) {
  var newBuf = Buffer.alloc(buf.length * 2)
  var nodeIdx = this.nodeIdx
  var prevBytes = this.prevBytes; var prevOffset = this.prevBytes.length
  var seqStart = -this.prevBytes.length // idx of the start of current parsed sequence.
  var uCode

  for (var i = 0, j = 0; i < buf.length; i++) {
    var curByte = (i >= 0) ? buf[i] : prevBytes[i + prevOffset]

    // Lookup in current trie node.
    var uCode = this.decodeTables[nodeIdx][curByte]

    if (uCode >= 0) {
      // Normal character, just use it.
    } else if (uCode === UNASSIGNED) { // Unknown char.
      // TODO: Callback with seq.
      uCode = this.defaultCharUnicode.charCodeAt(0)
      i = seqStart // Skip one byte ('i' will be incremented by the for loop) and try to parse again.
    } else if (uCode === GB18030_CODE) {
      if (i >= 3) {
        var ptr = (buf[i - 3] - 0x81) * 12600 + (buf[i - 2] - 0x30) * 1260 + (buf[i - 1] - 0x81) * 10 + (curByte - 0x30)
      } else {
        var ptr = (prevBytes[i - 3 + prevOffset] - 0x81) * 12600 +
                          (((i - 2 >= 0) ? buf[i - 2] : prevBytes[i - 2 + prevOffset]) - 0x30) * 1260 +
                          (((i - 1 >= 0) ? buf[i - 1] : prevBytes[i - 1 + prevOffset]) - 0x81) * 10 +
                          (curByte - 0x30)
      }
      var idx = findIdx(this.gb18030.gbChars, ptr)
      uCode = this.gb18030.uChars[idx] + ptr - this.gb18030.gbChars[idx]
    } else if (uCode <= NODE_START) { // Go to next trie node.
      nodeIdx = NODE_START - uCode
      continue
    } else if (uCode <= SEQ_START) { // Output a sequence of chars.
      var seq = this.decodeTableSeq[SEQ_START - uCode]
      for (var k = 0; k < seq.length - 1; k++) {
        uCode = seq[k]
        newBuf[j++] = uCode & 0xFF
        newBuf[j++] = uCode >> 8
      }
      uCode = seq[seq.length - 1]
    } else { throw new Error("iconv-lite internal error: invalid decoding table value " + uCode + " at " + nodeIdx + "/" + curByte) }

    // Write the character to buffer, handling higher planes using surrogate pair.
    if (uCode >= 0x10000) {
      uCode -= 0x10000
      var uCodeLead = 0xD800 | (uCode >> 10)
      newBuf[j++] = uCodeLead & 0xFF
      newBuf[j++] = uCodeLead >> 8

      uCode = 0xDC00 | (uCode & 0x3FF)
    }
    newBuf[j++] = uCode & 0xFF
    newBuf[j++] = uCode >> 8

    // Reset trie node.
    nodeIdx = 0; seqStart = i + 1
  }

  this.nodeIdx = nodeIdx
  this.prevBytes = (seqStart >= 0)
    ? Array.prototype.slice.call(buf, seqStart)
    : prevBytes.slice(seqStart + prevOffset).concat(Array.prototype.slice.call(buf))

  return newBuf.slice(0, j).toString("ucs2")
}

DBCSDecoder.prototype.end = function () {
  var ret = ""

  // Try to parse all remaining chars.
  while (this.prevBytes.length > 0) {
    // Skip 1 character in the buffer.
    ret += this.defaultCharUnicode
    var bytesArr = this.prevBytes.slice(1)

    // Parse remaining as usual.
    this.prevBytes = []
    this.nodeIdx = 0
    if (bytesArr.length > 0) { ret += this.write(bytesArr) }
  }

  this.prevBytes = []
  this.nodeIdx = 0
  return ret
}

// Binary search for GB18030. Returns largest i such that table[i] <= val.
function findIdx (table, val) {
  if (table[0] > val) { return -1 }

  var l = 0; var r = table.length
  while (l < r - 1) { // always table[l] <= val < table[r]
    var mid = l + ((r - l + 1) >> 1)
    if (table[mid] <= val) { l = mid } else { r = mid }
  }
  return l
}


/***/ }),

/***/ 58746:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


// Description of supported double byte encodings and aliases.
// Tables are not require()-d until they are needed to speed up library load.
// require()-s are direct to support Browserify.

module.exports = {

  // == Japanese/ShiftJIS ====================================================
  // All japanese encodings are based on JIS X set of standards:
  // JIS X 0201 - Single-byte encoding of ASCII + ¬• + Kana chars at 0xA1-0xDF.
  // JIS X 0208 - Main set of 6879 characters, placed in 94x94 plane, to be encoded by 2 bytes.
  //              Has several variations in 1978, 1983, 1990 and 1997.
  // JIS X 0212 - Supplementary plane of 6067 chars in 94x94 plane. 1990. Effectively dead.
  // JIS X 0213 - Extension and modern replacement of 0208 and 0212. Total chars: 11233.
  //              2 planes, first is superset of 0208, second - revised 0212.
  //              Introduced in 2000, revised 2004. Some characters are in Unicode Plane 2 (0x2xxxx)

  // Byte encodings are:
  //  * Shift_JIS: Compatible with 0201, uses not defined chars in top half as lead bytes for double-byte
  //               encoding of 0208. Lead byte ranges: 0x81-0x9F, 0xE0-0xEF; Trail byte ranges: 0x40-0x7E, 0x80-0x9E, 0x9F-0xFC.
  //               Windows CP932 is a superset of Shift_JIS. Some companies added more chars, notably KDDI.
  //  * EUC-JP:    Up to 3 bytes per character. Used mostly on *nixes.
  //               0x00-0x7F       - lower part of 0201
  //               0x8E, 0xA1-0xDF - upper part of 0201
  //               (0xA1-0xFE)x2   - 0208 plane (94x94).
  //               0x8F, (0xA1-0xFE)x2 - 0212 plane (94x94).
  //  * JIS X 208: 7-bit, direct encoding of 0208. Byte ranges: 0x21-0x7E (94 values). Uncommon.
  //               Used as-is in ISO2022 family.
  //  * ISO2022-JP: Stateful encoding, with escape sequences to switch between ASCII,
  //                0201-1976 Roman, 0208-1978, 0208-1983.
  //  * ISO2022-JP-1: Adds esc seq for 0212-1990.
  //  * ISO2022-JP-2: Adds esc seq for GB2313-1980, KSX1001-1992, ISO8859-1, ISO8859-7.
  //  * ISO2022-JP-3: Adds esc seq for 0201-1976 Kana set, 0213-2000 Planes 1, 2.
  //  * ISO2022-JP-2004: Adds 0213-2004 Plane 1.
  //
  // After JIS X 0213 appeared, Shift_JIS-2004, EUC-JISX0213 and ISO2022-JP-2004 followed, with just changing the planes.
  //
  // Overall, it seems that it's a mess :( http://www8.plala.or.jp/tkubota1/unicode-symbols-map2.html

  shiftjis: {
    type: "_dbcs",
    table: function () { return __nccwpck_require__(49991) },
    encodeAdd: { "\u00a5": 0x5C, "\u203E": 0x7E },
    encodeSkipVals: [{ from: 0xED40, to: 0xF940 }]
  },
  csshiftjis: "shiftjis",
  mskanji: "shiftjis",
  sjis: "shiftjis",
  windows31j: "shiftjis",
  ms31j: "shiftjis",
  xsjis: "shiftjis",
  windows932: "shiftjis",
  ms932: "shiftjis",
  932: "shiftjis",
  cp932: "shiftjis",

  eucjp: {
    type: "_dbcs",
    table: function () { return __nccwpck_require__(3030) },
    encodeAdd: { "\u00a5": 0x5C, "\u203E": 0x7E }
  },

  // TODO: KDDI extension to Shift_JIS
  // TODO: IBM CCSID 942 = CP932, but F0-F9 custom chars and other char changes.
  // TODO: IBM CCSID 943 = Shift_JIS = CP932 with original Shift_JIS lower 128 chars.

  // == Chinese/GBK ==========================================================
  // http://en.wikipedia.org/wiki/GBK
  // We mostly implement W3C recommendation: https://www.w3.org/TR/encoding/#gbk-encoder

  // Oldest GB2312 (1981, ~7600 chars) is a subset of CP936
  gb2312: "cp936",
  gb231280: "cp936",
  gb23121980: "cp936",
  csgb2312: "cp936",
  csiso58gb231280: "cp936",
  euccn: "cp936",

  // Microsoft's CP936 is a subset and approximation of GBK.
  windows936: "cp936",
  ms936: "cp936",
  936: "cp936",
  cp936: {
    type: "_dbcs",
    table: function () { return __nccwpck_require__(952) }
  },

  // GBK (~22000 chars) is an extension of CP936 that added user-mapped chars and some other.
  gbk: {
    type: "_dbcs",
    table: function () { return (__nccwpck_require__(952).concat)(__nccwpck_require__(7626)) }
  },
  xgbk: "gbk",
  isoir58: "gbk",

  // GB18030 is an algorithmic extension of GBK.
  // Main source: https://www.w3.org/TR/encoding/#gbk-encoder
  // http://icu-project.org/docs/papers/gb18030.html
  // http://source.icu-project.org/repos/icu/data/trunk/charset/data/xml/gb-18030-2000.xml
  // http://www.khngai.com/chinese/charmap/tblgbk.php?page=0
  gb18030: {
    type: "_dbcs",
    table: function () { return (__nccwpck_require__(952).concat)(__nccwpck_require__(7626)) },
    gb18030: function () { return __nccwpck_require__(96953) },
    encodeSkipVals: [0x80],
    encodeAdd: { "‚Ç¨": 0xA2E3 }
  },

  chinese: "gb18030",

  // == Korean ===============================================================
  // EUC-KR, KS_C_5601 and KS X 1001 are exactly the same.
  windows949: "cp949",
  ms949: "cp949",
  949: "cp949",
  cp949: {
    type: "_dbcs",
    table: function () { return __nccwpck_require__(3246) }
  },

  cseuckr: "cp949",
  csksc56011987: "cp949",
  euckr: "cp949",
  isoir149: "cp949",
  korean: "cp949",
  ksc56011987: "cp949",
  ksc56011989: "cp949",
  ksc5601: "cp949",

  // == Big5/Taiwan/Hong Kong ================================================
  // There are lots of tables for Big5 and cp950. Please see the following links for history:
  // http://moztw.org/docs/big5/  http://www.haible.de/bruno/charsets/conversion-tables/Big5.html
  // Variations, in roughly number of defined chars:
  //  * Windows CP 950: Microsoft variant of Big5. Canonical: http://www.unicode.org/Public/MAPPINGS/VENDORS/MICSFT/WINDOWS/CP950.TXT
  //  * Windows CP 951: Microsoft variant of Big5-HKSCS-2001. Seems to be never public. http://me.abelcheung.org/articles/research/what-is-cp951/
  //  * Big5-2003 (Taiwan standard) almost superset of cp950.
  //  * Unicode-at-on (UAO) / Mozilla 1.8. Falling out of use on the Web. Not supported by other browsers.
  //  * Big5-HKSCS (-2001, -2004, -2008). Hong Kong standard.
  //    many unicode code points moved from PUA to Supplementary plane (U+2XXXX) over the years.
  //    Plus, it has 4 combining sequences.
  //    Seems that Mozilla refused to support it for 10 yrs. https://bugzilla.mozilla.org/show_bug.cgi?id=162431 https://bugzilla.mozilla.org/show_bug.cgi?id=310299
  //    because big5-hkscs is the only encoding to include astral characters in non-algorithmic way.
  //    Implementations are not consistent within browsers; sometimes labeled as just big5.
  //    MS Internet Explorer switches from big5 to big5-hkscs when a patch applied.
  //    Great discussion & recap of what's going on https://bugzilla.mozilla.org/show_bug.cgi?id=912470#c31
  //    In the encoder, it might make sense to support encoding old PUA mappings to Big5 bytes seq-s.
  //    Official spec: http://www.ogcio.gov.hk/en/business/tech_promotion/ccli/terms/doc/2003cmp_2008.txt
  //                   http://www.ogcio.gov.hk/tc/business/tech_promotion/ccli/terms/doc/hkscs-2008-big5-iso.txt
  //
  // Current understanding of how to deal with Big5(-HKSCS) is in the Encoding Standard, http://encoding.spec.whatwg.org/#big5-encoder
  // Unicode mapping (http://www.unicode.org/Public/MAPPINGS/OBSOLETE/EASTASIA/OTHER/BIG5.TXT) is said to be wrong.

  windows950: "cp950",
  ms950: "cp950",
  950: "cp950",
  cp950: {
    type: "_dbcs",
    table: function () { return __nccwpck_require__(61604) }
  },

  // Big5 has many variations and is an extension of cp950. We use Encoding Standard's as a consensus.
  big5: "big5hkscs",
  big5hkscs: {
    type: "_dbcs",
    table: function () { return (__nccwpck_require__(61604).concat)(__nccwpck_require__(1315)) },
    encodeSkipVals: [
      // Although Encoding Standard says we should avoid encoding to HKSCS area (See Step 1 of
      // https://encoding.spec.whatwg.org/#index-big5-pointer), we still do it to increase compatibility with ICU.
      // But if a single unicode point can be encoded both as HKSCS and regular Big5, we prefer the latter.
      0x8e69, 0x8e6f, 0x8e7e, 0x8eab, 0x8eb4, 0x8ecd, 0x8ed0, 0x8f57, 0x8f69, 0x8f6e, 0x8fcb, 0x8ffe,
      0x906d, 0x907a, 0x90c4, 0x90dc, 0x90f1, 0x91bf, 0x92af, 0x92b0, 0x92b1, 0x92b2, 0x92d1, 0x9447, 0x94ca,
      0x95d9, 0x96fc, 0x9975, 0x9b76, 0x9b78, 0x9b7b, 0x9bc6, 0x9bde, 0x9bec, 0x9bf6, 0x9c42, 0x9c53, 0x9c62,
      0x9c68, 0x9c6b, 0x9c77, 0x9cbc, 0x9cbd, 0x9cd0, 0x9d57, 0x9d5a, 0x9dc4, 0x9def, 0x9dfb, 0x9ea9, 0x9eef,
      0x9efd, 0x9f60, 0x9fcb, 0xa077, 0xa0dc, 0xa0df, 0x8fcc, 0x92c8, 0x9644, 0x96ed,

      // Step 2 of https://encoding.spec.whatwg.org/#index-big5-pointer: Use last pointer for U+2550, U+255E, U+2561, U+256A, U+5341, or U+5345
      0xa2a4, 0xa2a5, 0xa2a7, 0xa2a6, 0xa2cc, 0xa2ce
    ]
  },

  cnbig5: "big5hkscs",
  csbig5: "big5hkscs",
  xxbig5: "big5hkscs"
}


/***/ }),

/***/ 3841:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


var mergeModules = __nccwpck_require__(61304)

// Update this array if you add/rename/remove files in this directory.
// We support Browserify by skipping automatic module discovery and requiring modules directly.
var modules = [
  __nccwpck_require__(38468),
  __nccwpck_require__(37957),
  __nccwpck_require__(70915),
  __nccwpck_require__(30663),
  __nccwpck_require__(48841),
  __nccwpck_require__(83963),
  __nccwpck_require__(16399),
  __nccwpck_require__(89642),
  __nccwpck_require__(58746)
]

// Put all encoding/alias/codec definitions to single object and export it.
for (var i = 0; i < modules.length; i++) {
  var module = modules[i]
  mergeModules(exports, module)
}


/***/ }),

/***/ 38468:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";

var Buffer = (__nccwpck_require__(12803).Buffer)

// Export Node.js internal encodings.

module.exports = {
  // Encodings
  utf8: { type: "_internal", bomAware: true },
  cesu8: { type: "_internal", bomAware: true },
  unicode11utf8: "utf8",

  ucs2: { type: "_internal", bomAware: true },
  utf16le: "ucs2",

  binary: { type: "_internal" },
  base64: { type: "_internal" },
  hex: { type: "_internal" },

  // Codec.
  _internal: InternalCodec
}

// ------------------------------------------------------------------------------

function InternalCodec (codecOptions, iconv) {
  this.enc = codecOptions.encodingName
  this.bomAware = codecOptions.bomAware

  if (this.enc === "base64") { this.encoder = InternalEncoderBase64 } else if (this.enc === "utf8") { this.encoder = InternalEncoderUtf8 } else if (this.enc === "cesu8") {
    this.enc = "utf8" // Use utf8 for decoding.
    this.encoder = InternalEncoderCesu8

    // Add decoder for versions of Node not supporting CESU-8
    if (Buffer.from("eda0bdedb2a9", "hex").toString() !== "üí©") {
      this.decoder = InternalDecoderCesu8
      this.defaultCharUnicode = iconv.defaultCharUnicode
    }
  }
}

InternalCodec.prototype.encoder = InternalEncoder
InternalCodec.prototype.decoder = InternalDecoder

// ------------------------------------------------------------------------------

// We use node.js internal decoder. Its signature is the same as ours.
var StringDecoder = (__nccwpck_require__(13193).StringDecoder)

function InternalDecoder (options, codec) {
  this.decoder = new StringDecoder(codec.enc)
}

InternalDecoder.prototype.write = function (buf) {
  if (!Buffer.isBuffer(buf)) {
    buf = Buffer.from(buf)
  }

  return this.decoder.write(buf)
}

InternalDecoder.prototype.end = function () {
  return this.decoder.end()
}

// ------------------------------------------------------------------------------
// Encoder is mostly trivial

function InternalEncoder (options, codec) {
  this.enc = codec.enc
}

InternalEncoder.prototype.write = function (str) {
  return Buffer.from(str, this.enc)
}

InternalEncoder.prototype.end = function () {
}

// ------------------------------------------------------------------------------
// Except base64 encoder, which must keep its state.

function InternalEncoderBase64 (options, codec) {
  this.prevStr = ""
}

InternalEncoderBase64.prototype.write = function (str) {
  str = this.prevStr + str
  var completeQuads = str.length - (str.length % 4)
  this.prevStr = str.slice(completeQuads)
  str = str.slice(0, completeQuads)

  return Buffer.from(str, "base64")
}

InternalEncoderBase64.prototype.end = function () {
  return Buffer.from(this.prevStr, "base64")
}

// ------------------------------------------------------------------------------
// CESU-8 encoder is also special.

function InternalEncoderCesu8 (options, codec) {
}

InternalEncoderCesu8.prototype.write = function (str) {
  var buf = Buffer.alloc(str.length * 3); var bufIdx = 0
  for (var i = 0; i < str.length; i++) {
    var charCode = str.charCodeAt(i)
    // Naive implementation, but it works because CESU-8 is especially easy
    // to convert from UTF-16 (which all JS strings are encoded in).
    if (charCode < 0x80) { buf[bufIdx++] = charCode } else if (charCode < 0x800) {
      buf[bufIdx++] = 0xC0 + (charCode >>> 6)
      buf[bufIdx++] = 0x80 + (charCode & 0x3f)
    } else { // charCode will always be < 0x10000 in javascript.
      buf[bufIdx++] = 0xE0 + (charCode >>> 12)
      buf[bufIdx++] = 0x80 + ((charCode >>> 6) & 0x3f)
      buf[bufIdx++] = 0x80 + (charCode & 0x3f)
    }
  }
  return buf.slice(0, bufIdx)
}

InternalEncoderCesu8.prototype.end = function () {
}

// ------------------------------------------------------------------------------
// CESU-8 decoder is not implemented in Node v4.0+

function InternalDecoderCesu8 (options, codec) {
  this.acc = 0
  this.contBytes = 0
  this.accBytes = 0
  this.defaultCharUnicode = codec.defaultCharUnicode
}

InternalDecoderCesu8.prototype.write = function (buf) {
  var acc = this.acc; var contBytes = this.contBytes; var accBytes = this.accBytes
  var res = ""
  for (var i = 0; i < buf.length; i++) {
    var curByte = buf[i]
    if ((curByte & 0xC0) !== 0x80) { // Leading byte
      if (contBytes > 0) { // Previous code is invalid
        res += this.defaultCharUnicode
        contBytes = 0
      }

      if (curByte < 0x80) { // Single-byte code
        res += String.fromCharCode(curByte)
      } else if (curByte < 0xE0) { // Two-byte code
        acc = curByte & 0x1F
        contBytes = 1; accBytes = 1
      } else if (curByte < 0xF0) { // Three-byte code
        acc = curByte & 0x0F
        contBytes = 2; accBytes = 1
      } else { // Four or more are not supported for CESU-8.
        res += this.defaultCharUnicode
      }
    } else { // Continuation byte
      if (contBytes > 0) { // We're waiting for it.
        acc = (acc << 6) | (curByte & 0x3f)
        contBytes--; accBytes++
        if (contBytes === 0) {
          // Check for overlong encoding, but support Modified UTF-8 (encoding NULL as C0 80)
          if (accBytes === 2 && acc < 0x80 && acc > 0) {
            res += this.defaultCharUnicode
          } else if (accBytes === 3 && acc < 0x800) {
            res += this.defaultCharUnicode
          } else {
            // Actually add character.
            res += String.fromCharCode(acc)
          }
        }
      } else { // Unexpected continuation byte
        res += this.defaultCharUnicode
      }
    }
  }
  this.acc = acc; this.contBytes = contBytes; this.accBytes = accBytes
  return res
}

InternalDecoderCesu8.prototype.end = function () {
  var res = 0
  if (this.contBytes > 0) { res += this.defaultCharUnicode }
  return res
}

// ------------------------------------------------------------------------------
// check the chunk boundaries for surrogate pair

function InternalEncoderUtf8 (options, codec) {
  this.highSurrogate = ""
}

InternalEncoderUtf8.prototype.write = function (str) {
  if (this.highSurrogate) {
    str = this.highSurrogate + str
    this.highSurrogate = ""
  }

  if (str.length > 0) {
    var charCode = str.charCodeAt(str.length - 1)
    if (charCode >= 0xd800 && charCode < 0xdc00) {
      this.highSurrogate = str[str.length - 1]
      str = str.slice(0, str.length - 1)
    }
  }

  return Buffer.from(str, this.enc)
}

InternalEncoderUtf8.prototype.end = function () {
  if (this.highSurrogate) {
    var str = this.highSurrogate
    this.highSurrogate = ""
    return Buffer.from(str, this.enc)
  }
}


/***/ }),

/***/ 48841:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

var Buffer = (__nccwpck_require__(12803).Buffer)

// Single-byte codec. Needs a 'chars' string parameter that contains 256 or 128 chars that
// correspond to encoded bytes (if 128 - then lower half is ASCII).

exports._sbcs = SBCSCodec
function SBCSCodec (codecOptions, iconv) {
  if (!codecOptions) {
    throw new Error("SBCS codec is called without the data.")
  }

  // Prepare char buffer for decoding.
  if (!codecOptions.chars || (codecOptions.chars.length !== 128 && codecOptions.chars.length !== 256)) {
    throw new Error("Encoding '" + codecOptions.type + "' has incorrect 'chars' (must be of len 128 or 256)")
  }

  if (codecOptions.chars.length === 128) {
    var asciiString = ""
    for (var i = 0; i < 128; i++) {
      asciiString += String.fromCharCode(i)
    }
    codecOptions.chars = asciiString + codecOptions.chars
  }

  this.decodeBuf = Buffer.from(codecOptions.chars, "ucs2")

  // Encoding buffer.
  var encodeBuf = Buffer.alloc(65536, iconv.defaultCharSingleByte.charCodeAt(0))

  for (var i = 0; i < codecOptions.chars.length; i++) {
    encodeBuf[codecOptions.chars.charCodeAt(i)] = i
  }

  this.encodeBuf = encodeBuf
}

SBCSCodec.prototype.encoder = SBCSEncoder
SBCSCodec.prototype.decoder = SBCSDecoder

function SBCSEncoder (options, codec) {
  this.encodeBuf = codec.encodeBuf
}

SBCSEncoder.prototype.write = function (str) {
  var buf = Buffer.alloc(str.length)
  for (var i = 0; i < str.length; i++) {
    buf[i] = this.encodeBuf[str.charCodeAt(i)]
  }

  return buf
}

SBCSEncoder.prototype.end = function () {
}

function SBCSDecoder (options, codec) {
  this.decodeBuf = codec.decodeBuf
}

SBCSDecoder.prototype.write = function (buf) {
  // Strings are immutable in JS -> we use ucs2 buffer to speed up computations.
  var decodeBuf = this.decodeBuf
  var newBuf = Buffer.alloc(buf.length * 2)
  var idx1 = 0; var idx2 = 0
  for (var i = 0; i < buf.length; i++) {
    idx1 = buf[i] * 2; idx2 = i * 2
    newBuf[idx2] = decodeBuf[idx1]
    newBuf[idx2 + 1] = decodeBuf[idx1 + 1]
  }
  return newBuf.toString("ucs2")
}

SBCSDecoder.prototype.end = function () {
}


/***/ }),

/***/ 16399:
/***/ ((module) => {

"use strict";


// Generated data for sbcs codec. Don't edit manually. Regenerate using generation/gen-sbcs.js script.
module.exports = {
  "437": "cp437",
  "737": "cp737",
  "775": "cp775",
  "850": "cp850",
  "852": "cp852",
  "855": "cp855",
  "856": "cp856",
  "857": "cp857",
  "858": "cp858",
  "860": "cp860",
  "861": "cp861",
  "862": "cp862",
  "863": "cp863",
  "864": "cp864",
  "865": "cp865",
  "866": "cp866",
  "869": "cp869",
  "874": "windows874",
  "922": "cp922",
  "1046": "cp1046",
  "1124": "cp1124",
  "1125": "cp1125",
  "1129": "cp1129",
  "1133": "cp1133",
  "1161": "cp1161",
  "1162": "cp1162",
  "1163": "cp1163",
  "1250": "windows1250",
  "1251": "windows1251",
  "1252": "windows1252",
  "1253": "windows1253",
  "1254": "windows1254",
  "1255": "windows1255",
  "1256": "windows1256",
  "1257": "windows1257",
  "1258": "windows1258",
  "28591": "iso88591",
  "28592": "iso88592",
  "28593": "iso88593",
  "28594": "iso88594",
  "28595": "iso88595",
  "28596": "iso88596",
  "28597": "iso88597",
  "28598": "iso88598",
  "28599": "iso88599",
  "28600": "iso885910",
  "28601": "iso885911",
  "28603": "iso885913",
  "28604": "iso885914",
  "28605": "iso885915",
  "28606": "iso885916",
  "windows874": {
    "type": "_sbcs",
    "chars": "‚Ç¨ÔøΩÔøΩÔøΩÔøΩ‚Ä¶ÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩ‚Äò‚Äô‚Äú‚Äù‚Ä¢‚Äì‚ÄîÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩ¬†‡∏Å‡∏Ç‡∏É‡∏Ñ‡∏Ö‡∏Ü‡∏á‡∏à‡∏â‡∏ä‡∏ã‡∏å‡∏ç‡∏é‡∏è‡∏ê‡∏ë‡∏í‡∏ì‡∏î‡∏ï‡∏ñ‡∏ó‡∏ò‡∏ô‡∏ö‡∏õ‡∏ú‡∏ù‡∏û‡∏ü‡∏†‡∏°‡∏¢‡∏£‡∏§‡∏•‡∏¶‡∏ß‡∏®‡∏©‡∏™‡∏´‡∏¨‡∏≠‡∏Æ‡∏Ø‡∏∞‡∏±‡∏≤‡∏≥‡∏¥‡∏µ‡∏∂‡∏∑‡∏∏‡∏π‡∏∫ÔøΩÔøΩÔøΩÔøΩ‡∏ø‡πÄ‡πÅ‡πÇ‡πÉ‡πÑ‡πÖ‡πÜ‡πá‡πà‡πâ‡πä‡πã‡πå‡πç‡πé‡πè‡πê‡πë‡πí‡πì‡πî‡πï‡πñ‡πó‡πò‡πô‡πö‡πõÔøΩÔøΩÔøΩÔøΩ"
  },
  "win874": "windows874",
  "cp874": "windows874",
  "windows1250": {
    "type": "_sbcs",
    "chars": "‚Ç¨ÔøΩ‚ÄöÔøΩ‚Äû‚Ä¶‚Ä†‚Ä°ÔøΩ‚Ä∞≈†‚Äπ≈ö≈§≈Ω≈πÔøΩ‚Äò‚Äô‚Äú‚Äù‚Ä¢‚Äì‚ÄîÔøΩ‚Ñ¢≈°‚Ä∫≈õ≈•≈æ≈∫¬†ÀáÀò≈Å¬§ƒÑ¬¶¬ß¬®¬©≈û¬´¬¨¬≠¬Æ≈ª¬∞¬±Àõ≈Ç¬¥¬µ¬∂¬∑¬∏ƒÖ≈ü¬ªƒΩÀùƒæ≈º≈î√Å√ÇƒÇ√ÑƒπƒÜ√áƒå√âƒò√ãƒö√ç√éƒéƒê≈É≈á√ì√î≈ê√ñ√ó≈ò≈Æ√ö≈∞√ú√ù≈¢√ü≈ï√°√¢ƒÉ√§ƒ∫ƒá√ßƒç√©ƒô√´ƒõ√≠√Æƒèƒë≈Ñ≈à√≥√¥≈ë√∂√∑≈ô≈Ø√∫≈±√º√Ω≈£Àô"
  },
  "win1250": "windows1250",
  "cp1250": "windows1250",
  "windows1251": {
    "type": "_sbcs",
    "chars": "–Ç–É‚Äö—ì‚Äû‚Ä¶‚Ä†‚Ä°‚Ç¨‚Ä∞–â‚Äπ–ä–å–ã–è—í‚Äò‚Äô‚Äú‚Äù‚Ä¢‚Äì‚ÄîÔøΩ‚Ñ¢—ô‚Ä∫—ö—ú—õ—ü¬†–é—û–à¬§“ê¬¶¬ß–Å¬©–Ñ¬´¬¨¬≠¬Æ–á¬∞¬±–Ü—ñ“ë¬µ¬∂¬∑—ë‚Ññ—î¬ª—ò–Ö—ï—ó–ê–ë–í–ì–î–ï–ñ–ó–ò–ô–ö–õ–ú–ù–û–ü–†–°–¢–£–§–•–¶–ß–®–©–™–´–¨–≠–Æ–Ø–∞–±–≤–≥–¥–µ–∂–∑–∏–π–∫–ª–º–Ω–æ–ø—Ä—Å—Ç—É—Ñ—Ö—Ü—á—à—â—ä—ã—å—ç—é—è"
  },
  "win1251": "windows1251",
  "cp1251": "windows1251",
  "windows1252": {
    "type": "_sbcs",
    "chars": "‚Ç¨ÔøΩ‚Äö∆í‚Äû‚Ä¶‚Ä†‚Ä°ÀÜ‚Ä∞≈†‚Äπ≈íÔøΩ≈ΩÔøΩÔøΩ‚Äò‚Äô‚Äú‚Äù‚Ä¢‚Äì‚ÄîÀú‚Ñ¢≈°‚Ä∫≈ìÔøΩ≈æ≈∏¬†¬°¬¢¬£¬§¬•¬¶¬ß¬®¬©¬™¬´¬¨¬≠¬Æ¬Ø¬∞¬±¬≤¬≥¬¥¬µ¬∂¬∑¬∏¬π¬∫¬ª¬º¬Ω¬æ¬ø√Ä√Å√Ç√É√Ñ√Ö√Ü√á√à√â√ä√ã√å√ç√é√è√ê√ë√í√ì√î√ï√ñ√ó√ò√ô√ö√õ√ú√ù√û√ü√†√°√¢√£√§√•√¶√ß√®√©√™√´√¨√≠√Æ√Ø√∞√±√≤√≥√¥√µ√∂√∑√∏√π√∫√ª√º√Ω√æ√ø"
  },
  "win1252": "windows1252",
  "cp1252": "windows1252",
  "windows1253": {
    "type": "_sbcs",
    "chars": "‚Ç¨ÔøΩ‚Äö∆í‚Äû‚Ä¶‚Ä†‚Ä°ÔøΩ‚Ä∞ÔøΩ‚ÄπÔøΩÔøΩÔøΩÔøΩÔøΩ‚Äò‚Äô‚Äú‚Äù‚Ä¢‚Äì‚ÄîÔøΩ‚Ñ¢ÔøΩ‚Ä∫ÔøΩÔøΩÔøΩÔøΩ¬†ŒÖŒÜ¬£¬§¬•¬¶¬ß¬®¬©ÔøΩ¬´¬¨¬≠¬Æ‚Äï¬∞¬±¬≤¬≥ŒÑ¬µ¬∂¬∑ŒàŒâŒä¬ªŒå¬ΩŒéŒèŒêŒëŒíŒìŒîŒïŒñŒóŒòŒôŒöŒõŒúŒùŒûŒüŒ†Œ°ÔøΩŒ£Œ§Œ•Œ¶ŒßŒ®Œ©Œ™Œ´Œ¨Œ≠ŒÆŒØŒ∞Œ±Œ≤Œ≥Œ¥ŒµŒ∂Œ∑Œ∏ŒπŒ∫ŒªŒºŒΩŒæŒøœÄœÅœÇœÉœÑœÖœÜœáœàœâœäœãœåœçœéÔøΩ"
  },
  "win1253": "windows1253",
  "cp1253": "windows1253",
  "windows1254": {
    "type": "_sbcs",
    "chars": "‚Ç¨ÔøΩ‚Äö∆í‚Äû‚Ä¶‚Ä†‚Ä°ÀÜ‚Ä∞≈†‚Äπ≈íÔøΩÔøΩÔøΩÔøΩ‚Äò‚Äô‚Äú‚Äù‚Ä¢‚Äì‚ÄîÀú‚Ñ¢≈°‚Ä∫≈ìÔøΩÔøΩ≈∏¬†¬°¬¢¬£¬§¬•¬¶¬ß¬®¬©¬™¬´¬¨¬≠¬Æ¬Ø¬∞¬±¬≤¬≥¬¥¬µ¬∂¬∑¬∏¬π¬∫¬ª¬º¬Ω¬æ¬ø√Ä√Å√Ç√É√Ñ√Ö√Ü√á√à√â√ä√ã√å√ç√é√èƒû√ë√í√ì√î√ï√ñ√ó√ò√ô√ö√õ√úƒ∞≈û√ü√†√°√¢√£√§√•√¶√ß√®√©√™√´√¨√≠√Æ√Øƒü√±√≤√≥√¥√µ√∂√∑√∏√π√∫√ª√ºƒ±≈ü√ø"
  },
  "win1254": "windows1254",
  "cp1254": "windows1254",
  "windows1255": {
    "type": "_sbcs",
    "chars": "‚Ç¨ÔøΩ‚Äö∆í‚Äû‚Ä¶‚Ä†‚Ä°ÀÜ‚Ä∞ÔøΩ‚ÄπÔøΩÔøΩÔøΩÔøΩÔøΩ‚Äò‚Äô‚Äú‚Äù‚Ä¢‚Äì‚ÄîÀú‚Ñ¢ÔøΩ‚Ä∫ÔøΩÔøΩÔøΩÔøΩ¬†¬°¬¢¬£‚Ç™¬•¬¶¬ß¬®¬©√ó¬´¬¨¬≠¬Æ¬Ø¬∞¬±¬≤¬≥¬¥¬µ¬∂¬∑¬∏¬π√∑¬ª¬º¬Ω¬æ¬ø÷∞÷±÷≤÷≥÷¥÷µ÷∂÷∑÷∏÷π÷∫÷ª÷º÷Ω÷æ÷ø◊Ä◊Å◊Ç◊É◊∞◊±◊≤◊≥◊¥ÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩ◊ê◊ë◊í◊ì◊î◊ï◊ñ◊ó◊ò◊ô◊ö◊õ◊ú◊ù◊û◊ü◊†◊°◊¢◊£◊§◊•◊¶◊ß◊®◊©◊™ÔøΩÔøΩ‚Äé‚ÄèÔøΩ"
  },
  "win1255": "windows1255",
  "cp1255": "windows1255",
  "windows1256": {
    "type": "_sbcs",
    "chars": "‚Ç¨Ÿæ‚Äö∆í‚Äû‚Ä¶‚Ä†‚Ä°ÀÜ‚Ä∞Ÿπ‚Äπ≈í⁄Ü⁄ò⁄à⁄Ø‚Äò‚Äô‚Äú‚Äù‚Ä¢‚Äì‚Äî⁄©‚Ñ¢⁄ë‚Ä∫≈ì‚Äå‚Äç⁄∫¬†ÿå¬¢¬£¬§¬•¬¶¬ß¬®¬©⁄æ¬´¬¨¬≠¬Æ¬Ø¬∞¬±¬≤¬≥¬¥¬µ¬∂¬∑¬∏¬πÿõ¬ª¬º¬Ω¬æÿü€Åÿ°ÿ¢ÿ£ÿ§ÿ•ÿ¶ÿßÿ®ÿ©ÿ™ÿ´ÿ¨ÿ≠ÿÆÿØÿ∞ÿ±ÿ≤ÿ≥ÿ¥ÿµÿ∂√óÿ∑ÿ∏ÿπÿ∫ŸÄŸÅŸÇŸÉ√†ŸÑ√¢ŸÖŸÜŸáŸà√ß√®√©√™√´ŸâŸä√Æ√ØŸãŸåŸçŸé√¥ŸèŸê√∑Ÿë√πŸí√ª√º‚Äé‚Äè€í"
  },
  "win1256": "windows1256",
  "cp1256": "windows1256",
  "windows1257": {
    "type": "_sbcs",
    "chars": "‚Ç¨ÔøΩ‚ÄöÔøΩ‚Äû‚Ä¶‚Ä†‚Ä°ÔøΩ‚Ä∞ÔøΩ‚ÄπÔøΩ¬®Àá¬∏ÔøΩ‚Äò‚Äô‚Äú‚Äù‚Ä¢‚Äì‚ÄîÔøΩ‚Ñ¢ÔøΩ‚Ä∫ÔøΩ¬ØÀõÔøΩ¬†ÔøΩ¬¢¬£¬§ÔøΩ¬¶¬ß√ò¬©≈ñ¬´¬¨¬≠¬Æ√Ü¬∞¬±¬≤¬≥¬¥¬µ¬∂¬∑√∏¬π≈ó¬ª¬º¬Ω¬æ√¶ƒÑƒÆƒÄƒÜ√Ñ√Öƒòƒíƒå√â≈πƒñƒ¢ƒ∂ƒ™ƒª≈†≈É≈Ö√ì≈å√ï√ñ√ó≈≤≈Å≈ö≈™√ú≈ª≈Ω√üƒÖƒØƒÅƒá√§√•ƒôƒìƒç√©≈∫ƒóƒ£ƒ∑ƒ´ƒº≈°≈Ñ≈Ü√≥≈ç√µ√∂√∑≈≥≈Ç≈õ≈´√º≈º≈æÀô"
  },
  "win1257": "windows1257",
  "cp1257": "windows1257",
  "windows1258": {
    "type": "_sbcs",
    "chars": "‚Ç¨ÔøΩ‚Äö∆í‚Äû‚Ä¶‚Ä†‚Ä°ÀÜ‚Ä∞ÔøΩ‚Äπ≈íÔøΩÔøΩÔøΩÔøΩ‚Äò‚Äô‚Äú‚Äù‚Ä¢‚Äì‚ÄîÀú‚Ñ¢ÔøΩ‚Ä∫≈ìÔøΩÔøΩ≈∏¬†¬°¬¢¬£¬§¬•¬¶¬ß¬®¬©¬™¬´¬¨¬≠¬Æ¬Ø¬∞¬±¬≤¬≥¬¥¬µ¬∂¬∑¬∏¬π¬∫¬ª¬º¬Ω¬æ¬ø√Ä√Å√ÇƒÇ√Ñ√Ö√Ü√á√à√â√ä√ãÃÄ√ç√é√èƒê√ëÃâ√ì√î∆†√ñ√ó√ò√ô√ö√õ√ú∆ØÃÉ√ü√†√°√¢ƒÉ√§√•√¶√ß√®√©√™√´ÃÅ√≠√Æ√Øƒë√±Ã£√≥√¥∆°√∂√∑√∏√π√∫√ª√º∆∞‚Ç´√ø"
  },
  "win1258": "windows1258",
  "cp1258": "windows1258",
  "iso88591": {
    "type": "_sbcs",
    "chars": "¬Ä¬Å¬Ç¬É¬Ñ¬Ö¬Ü¬á¬à¬â¬ä¬ã¬å¬ç¬é¬è¬ê¬ë¬í¬ì¬î¬ï¬ñ¬ó¬ò¬ô¬ö¬õ¬ú¬ù¬û¬ü¬†¬°¬¢¬£¬§¬•¬¶¬ß¬®¬©¬™¬´¬¨¬≠¬Æ¬Ø¬∞¬±¬≤¬≥¬¥¬µ¬∂¬∑¬∏¬π¬∫¬ª¬º¬Ω¬æ¬ø√Ä√Å√Ç√É√Ñ√Ö√Ü√á√à√â√ä√ã√å√ç√é√è√ê√ë√í√ì√î√ï√ñ√ó√ò√ô√ö√õ√ú√ù√û√ü√†√°√¢√£√§√•√¶√ß√®√©√™√´√¨√≠√Æ√Ø√∞√±√≤√≥√¥√µ√∂√∑√∏√π√∫√ª√º√Ω√æ√ø"
  },
  "cp28591": "iso88591",
  "iso88592": {
    "type": "_sbcs",
    "chars": "¬Ä¬Å¬Ç¬É¬Ñ¬Ö¬Ü¬á¬à¬â¬ä¬ã¬å¬ç¬é¬è¬ê¬ë¬í¬ì¬î¬ï¬ñ¬ó¬ò¬ô¬ö¬õ¬ú¬ù¬û¬ü¬†ƒÑÀò≈Å¬§ƒΩ≈ö¬ß¬®≈†≈û≈§≈π¬≠≈Ω≈ª¬∞ƒÖÀõ≈Ç¬¥ƒæ≈õÀá¬∏≈°≈ü≈•≈∫Àù≈æ≈º≈î√Å√ÇƒÇ√ÑƒπƒÜ√áƒå√âƒò√ãƒö√ç√éƒéƒê≈É≈á√ì√î≈ê√ñ√ó≈ò≈Æ√ö≈∞√ú√ù≈¢√ü≈ï√°√¢ƒÉ√§ƒ∫ƒá√ßƒç√©ƒô√´ƒõ√≠√Æƒèƒë≈Ñ≈à√≥√¥≈ë√∂√∑≈ô≈Ø√∫≈±√º√Ω≈£Àô"
  },
  "cp28592": "iso88592",
  "iso88593": {
    "type": "_sbcs",
    "chars": "¬Ä¬Å¬Ç¬É¬Ñ¬Ö¬Ü¬á¬à¬â¬ä¬ã¬å¬ç¬é¬è¬ê¬ë¬í¬ì¬î¬ï¬ñ¬ó¬ò¬ô¬ö¬õ¬ú¬ù¬û¬ü¬†ƒ¶Àò¬£¬§ÔøΩƒ§¬ß¬®ƒ∞≈ûƒûƒ¥¬≠ÔøΩ≈ª¬∞ƒß¬≤¬≥¬¥¬µƒ•¬∑¬∏ƒ±≈üƒüƒµ¬ΩÔøΩ≈º√Ä√Å√ÇÔøΩ√Ñƒäƒà√á√à√â√ä√ã√å√ç√é√èÔøΩ√ë√í√ì√îƒ†√ñ√óƒú√ô√ö√õ√ú≈¨≈ú√ü√†√°√¢ÔøΩ√§ƒãƒâ√ß√®√©√™√´√¨√≠√Æ√ØÔøΩ√±√≤√≥√¥ƒ°√∂√∑ƒù√π√∫√ª√º≈≠≈ùÀô"
  },
  "cp28593": "iso88593",
  "iso88594": {
    "type": "_sbcs",
    "chars": "¬Ä¬Å¬Ç¬É¬Ñ¬Ö¬Ü¬á¬à¬â¬ä¬ã¬å¬ç¬é¬è¬ê¬ë¬í¬ì¬î¬ï¬ñ¬ó¬ò¬ô¬ö¬õ¬ú¬ù¬û¬ü¬†ƒÑƒ∏≈ñ¬§ƒ®ƒª¬ß¬®≈†ƒíƒ¢≈¶¬≠≈Ω¬Ø¬∞ƒÖÀõ≈ó¬¥ƒ©ƒºÀá¬∏≈°ƒìƒ£≈ß≈ä≈æ≈ãƒÄ√Å√Ç√É√Ñ√Ö√ÜƒÆƒå√âƒò√ãƒñ√ç√éƒ™ƒê≈Ö≈åƒ∂√î√ï√ñ√ó√ò≈≤√ö√õ√ú≈®≈™√üƒÅ√°√¢√£√§√•√¶ƒØƒç√©ƒô√´ƒó√≠√Æƒ´ƒë≈Ü≈çƒ∑√¥√µ√∂√∑√∏≈≥√∫√ª√º≈©≈´Àô"
  },
  "cp28594": "iso88594",
  "iso88595": {
    "type": "_sbcs",
    "chars": "¬Ä¬Å¬Ç¬É¬Ñ¬Ö¬Ü¬á¬à¬â¬ä¬ã¬å¬ç¬é¬è¬ê¬ë¬í¬ì¬î¬ï¬ñ¬ó¬ò¬ô¬ö¬õ¬ú¬ù¬û¬ü¬†–Å–Ç–É–Ñ–Ö–Ü–á–à–â–ä–ã–å¬≠–é–è–ê–ë–í–ì–î–ï–ñ–ó–ò–ô–ö–õ–ú–ù–û–ü–†–°–¢–£–§–•–¶–ß–®–©–™–´–¨–≠–Æ–Ø–∞–±–≤–≥–¥–µ–∂–∑–∏–π–∫–ª–º–Ω–æ–ø—Ä—Å—Ç—É—Ñ—Ö—Ü—á—à—â—ä—ã—å—ç—é—è‚Ññ—ë—í—ì—î—ï—ñ—ó—ò—ô—ö—õ—ú¬ß—û—ü"
  },
  "cp28595": "iso88595",
  "iso88596": {
    "type": "_sbcs",
    "chars": "¬Ä¬Å¬Ç¬É¬Ñ¬Ö¬Ü¬á¬à¬â¬ä¬ã¬å¬ç¬é¬è¬ê¬ë¬í¬ì¬î¬ï¬ñ¬ó¬ò¬ô¬ö¬õ¬ú¬ù¬û¬ü¬†ÔøΩÔøΩÔøΩ¬§ÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÿå¬≠ÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÿõÔøΩÔøΩÔøΩÿüÔøΩÿ°ÿ¢ÿ£ÿ§ÿ•ÿ¶ÿßÿ®ÿ©ÿ™ÿ´ÿ¨ÿ≠ÿÆÿØÿ∞ÿ±ÿ≤ÿ≥ÿ¥ÿµÿ∂ÿ∑ÿ∏ÿπÿ∫ÔøΩÔøΩÔøΩÔøΩÔøΩŸÄŸÅŸÇŸÉŸÑŸÖŸÜŸáŸàŸâŸäŸãŸåŸçŸéŸèŸêŸëŸíÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩ"
  },
  "cp28596": "iso88596",
  "iso88597": {
    "type": "_sbcs",
    "chars": "¬Ä¬Å¬Ç¬É¬Ñ¬Ö¬Ü¬á¬à¬â¬ä¬ã¬å¬ç¬é¬è¬ê¬ë¬í¬ì¬î¬ï¬ñ¬ó¬ò¬ô¬ö¬õ¬ú¬ù¬û¬ü¬†‚Äò‚Äô¬£‚Ç¨‚ÇØ¬¶¬ß¬®¬©Õ∫¬´¬¨¬≠ÔøΩ‚Äï¬∞¬±¬≤¬≥ŒÑŒÖŒÜ¬∑ŒàŒâŒä¬ªŒå¬ΩŒéŒèŒêŒëŒíŒìŒîŒïŒñŒóŒòŒôŒöŒõŒúŒùŒûŒüŒ†Œ°ÔøΩŒ£Œ§Œ•Œ¶ŒßŒ®Œ©Œ™Œ´Œ¨Œ≠ŒÆŒØŒ∞Œ±Œ≤Œ≥Œ¥ŒµŒ∂Œ∑Œ∏ŒπŒ∫ŒªŒºŒΩŒæŒøœÄœÅœÇœÉœÑœÖœÜœáœàœâœäœãœåœçœéÔøΩ"
  },
  "cp28597": "iso88597",
  "iso88598": {
    "type": "_sbcs",
    "chars": "¬Ä¬Å¬Ç¬É¬Ñ¬Ö¬Ü¬á¬à¬â¬ä¬ã¬å¬ç¬é¬è¬ê¬ë¬í¬ì¬î¬ï¬ñ¬ó¬ò¬ô¬ö¬õ¬ú¬ù¬û¬ü¬†ÔøΩ¬¢¬£¬§¬•¬¶¬ß¬®¬©√ó¬´¬¨¬≠¬Æ¬Ø¬∞¬±¬≤¬≥¬¥¬µ¬∂¬∑¬∏¬π√∑¬ª¬º¬Ω¬æÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩ‚Äó◊ê◊ë◊í◊ì◊î◊ï◊ñ◊ó◊ò◊ô◊ö◊õ◊ú◊ù◊û◊ü◊†◊°◊¢◊£◊§◊•◊¶◊ß◊®◊©◊™ÔøΩÔøΩ‚Äé‚ÄèÔøΩ"
  },
  "cp28598": "iso88598",
  "iso88599": {
    "type": "_sbcs",
    "chars": "¬Ä¬Å¬Ç¬É¬Ñ¬Ö¬Ü¬á¬à¬â¬ä¬ã¬å¬ç¬é¬è¬ê¬ë¬í¬ì¬î¬ï¬ñ¬ó¬ò¬ô¬ö¬õ¬ú¬ù¬û¬ü¬†¬°¬¢¬£¬§¬•¬¶¬ß¬®¬©¬™¬´¬¨¬≠¬Æ¬Ø¬∞¬±¬≤¬≥¬¥¬µ¬∂¬∑¬∏¬π¬∫¬ª¬º¬Ω¬æ¬ø√Ä√Å√Ç√É√Ñ√Ö√Ü√á√à√â√ä√ã√å√ç√é√èƒû√ë√í√ì√î√ï√ñ√ó√ò√ô√ö√õ√úƒ∞≈û√ü√†√°√¢√£√§√•√¶√ß√®√©√™√´√¨√≠√Æ√Øƒü√±√≤√≥√¥√µ√∂√∑√∏√π√∫√ª√ºƒ±≈ü√ø"
  },
  "cp28599": "iso88599",
  "iso885910": {
    "type": "_sbcs",
    "chars": "¬Ä¬Å¬Ç¬É¬Ñ¬Ö¬Ü¬á¬à¬â¬ä¬ã¬å¬ç¬é¬è¬ê¬ë¬í¬ì¬î¬ï¬ñ¬ó¬ò¬ô¬ö¬õ¬ú¬ù¬û¬ü¬†ƒÑƒíƒ¢ƒ™ƒ®ƒ∂¬ßƒªƒê≈†≈¶≈Ω¬≠≈™≈ä¬∞ƒÖƒìƒ£ƒ´ƒ©ƒ∑¬∑ƒºƒë≈°≈ß≈æ‚Äï≈´≈ãƒÄ√Å√Ç√É√Ñ√Ö√ÜƒÆƒå√âƒò√ãƒñ√ç√é√è√ê≈Ö≈å√ì√î√ï√ñ≈®√ò≈≤√ö√õ√ú√ù√û√üƒÅ√°√¢√£√§√•√¶ƒØƒç√©ƒô√´ƒó√≠√Æ√Ø√∞≈Ü≈ç√≥√¥√µ√∂≈©√∏≈≥√∫√ª√º√Ω√æƒ∏"
  },
  "cp28600": "iso885910",
  "iso885911": {
    "type": "_sbcs",
    "chars": "¬Ä¬Å¬Ç¬É¬Ñ¬Ö¬Ü¬á¬à¬â¬ä¬ã¬å¬ç¬é¬è¬ê¬ë¬í¬ì¬î¬ï¬ñ¬ó¬ò¬ô¬ö¬õ¬ú¬ù¬û¬ü¬†‡∏Å‡∏Ç‡∏É‡∏Ñ‡∏Ö‡∏Ü‡∏á‡∏à‡∏â‡∏ä‡∏ã‡∏å‡∏ç‡∏é‡∏è‡∏ê‡∏ë‡∏í‡∏ì‡∏î‡∏ï‡∏ñ‡∏ó‡∏ò‡∏ô‡∏ö‡∏õ‡∏ú‡∏ù‡∏û‡∏ü‡∏†‡∏°‡∏¢‡∏£‡∏§‡∏•‡∏¶‡∏ß‡∏®‡∏©‡∏™‡∏´‡∏¨‡∏≠‡∏Æ‡∏Ø‡∏∞‡∏±‡∏≤‡∏≥‡∏¥‡∏µ‡∏∂‡∏∑‡∏∏‡∏π‡∏∫ÔøΩÔøΩÔøΩÔøΩ‡∏ø‡πÄ‡πÅ‡πÇ‡πÉ‡πÑ‡πÖ‡πÜ‡πá‡πà‡πâ‡πä‡πã‡πå‡πç‡πé‡πè‡πê‡πë‡πí‡πì‡πî‡πï‡πñ‡πó‡πò‡πô‡πö‡πõÔøΩÔøΩÔøΩÔøΩ"
  },
  "cp28601": "iso885911",
  "iso885913": {
    "type": "_sbcs",
    "chars": "¬Ä¬Å¬Ç¬É¬Ñ¬Ö¬Ü¬á¬à¬â¬ä¬ã¬å¬ç¬é¬è¬ê¬ë¬í¬ì¬î¬ï¬ñ¬ó¬ò¬ô¬ö¬õ¬ú¬ù¬û¬ü¬†‚Äù¬¢¬£¬§‚Äû¬¶¬ß√ò¬©≈ñ¬´¬¨¬≠¬Æ√Ü¬∞¬±¬≤¬≥‚Äú¬µ¬∂¬∑√∏¬π≈ó¬ª¬º¬Ω¬æ√¶ƒÑƒÆƒÄƒÜ√Ñ√Öƒòƒíƒå√â≈πƒñƒ¢ƒ∂ƒ™ƒª≈†≈É≈Ö√ì≈å√ï√ñ√ó≈≤≈Å≈ö≈™√ú≈ª≈Ω√üƒÖƒØƒÅƒá√§√•ƒôƒìƒç√©≈∫ƒóƒ£ƒ∑ƒ´ƒº≈°≈Ñ≈Ü√≥≈ç√µ√∂√∑≈≥≈Ç≈õ≈´√º≈º≈æ‚Äô"
  },
  "cp28603": "iso885913",
  "iso885914": {
    "type": "_sbcs",
    "chars": "¬Ä¬Å¬Ç¬É¬Ñ¬Ö¬Ü¬á¬à¬â¬ä¬ã¬å¬ç¬é¬è¬ê¬ë¬í¬ì¬î¬ï¬ñ¬ó¬ò¬ô¬ö¬õ¬ú¬ù¬û¬ü¬†·∏Ç·∏É¬£ƒäƒã·∏ä¬ß·∫Ä¬©·∫Ç·∏ã·ª≤¬≠¬Æ≈∏·∏û·∏üƒ†ƒ°·πÄ·πÅ¬∂·πñ·∫Å·πó·∫É·π†·ª≥·∫Ñ·∫Ö·π°√Ä√Å√Ç√É√Ñ√Ö√Ü√á√à√â√ä√ã√å√ç√é√è≈¥√ë√í√ì√î√ï√ñ·π™√ò√ô√ö√õ√ú√ù≈∂√ü√†√°√¢√£√§√•√¶√ß√®√©√™√´√¨√≠√Æ√Ø≈µ√±√≤√≥√¥√µ√∂·π´√∏√π√∫√ª√º√Ω≈∑√ø"
  },
  "cp28604": "iso885914",
  "iso885915": {
    "type": "_sbcs",
    "chars": "¬Ä¬Å¬Ç¬É¬Ñ¬Ö¬Ü¬á¬à¬â¬ä¬ã¬å¬ç¬é¬è¬ê¬ë¬í¬ì¬î¬ï¬ñ¬ó¬ò¬ô¬ö¬õ¬ú¬ù¬û¬ü¬†¬°¬¢¬£‚Ç¨¬•≈†¬ß≈°¬©¬™¬´¬¨¬≠¬Æ¬Ø¬∞¬±¬≤¬≥≈Ω¬µ¬∂¬∑≈æ¬π¬∫¬ª≈í≈ì≈∏¬ø√Ä√Å√Ç√É√Ñ√Ö√Ü√á√à√â√ä√ã√å√ç√é√è√ê√ë√í√ì√î√ï√ñ√ó√ò√ô√ö√õ√ú√ù√û√ü√†√°√¢√£√§√•√¶√ß√®√©√™√´√¨√≠√Æ√Ø√∞√±√≤√≥√¥√µ√∂√∑√∏√π√∫√ª√º√Ω√æ√ø"
  },
  "cp28605": "iso885915",
  "iso885916": {
    "type": "_sbcs",
    "chars": "¬Ä¬Å¬Ç¬É¬Ñ¬Ö¬Ü¬á¬à¬â¬ä¬ã¬å¬ç¬é¬è¬ê¬ë¬í¬ì¬î¬ï¬ñ¬ó¬ò¬ô¬ö¬õ¬ú¬ù¬û¬ü¬†ƒÑƒÖ≈Å‚Ç¨‚Äû≈†¬ß≈°¬©»ò¬´≈π¬≠≈∫≈ª¬∞¬±ƒå≈Ç≈Ω‚Äù¬∂¬∑≈æƒç»ô¬ª≈í≈ì≈∏≈º√Ä√Å√ÇƒÇ√ÑƒÜ√Ü√á√à√â√ä√ã√å√ç√é√èƒê≈É√í√ì√î≈ê√ñ≈ö≈∞√ô√ö√õ√úƒò»ö√ü√†√°√¢ƒÉ√§ƒá√¶√ß√®√©√™√´√¨√≠√Æ√Øƒë≈Ñ√≤√≥√¥≈ë√∂≈õ≈±√π√∫√ª√ºƒô»õ√ø"
  },
  "cp28606": "iso885916",
  "cp437": {
    "type": "_sbcs",
    "chars": "√á√º√©√¢√§√†√•√ß√™√´√®√Ø√Æ√¨√Ñ√Ö√â√¶√Ü√¥√∂√≤√ª√π√ø√ñ√ú¬¢¬£¬•‚Çß∆í√°√≠√≥√∫√±√ë¬™¬∫¬ø‚åê¬¨¬Ω¬º¬°¬´¬ª‚ñë‚ñí‚ñì‚îÇ‚î§‚ï°‚ï¢‚ïñ‚ïï‚ï£‚ïë‚ïó‚ïù‚ïú‚ïõ‚îê‚îî‚î¥‚î¨‚îú‚îÄ‚îº‚ïû‚ïü‚ïö‚ïî‚ï©‚ï¶‚ï†‚ïê‚ï¨‚ïß‚ï®‚ï§‚ï•‚ïô‚ïò‚ïí‚ïì‚ï´‚ï™‚îò‚îå‚ñà‚ñÑ‚ñå‚ñê‚ñÄŒ±√üŒìœÄŒ£œÉ¬µœÑŒ¶ŒòŒ©Œ¥‚àûœÜŒµ‚à©‚â°¬±‚â•‚â§‚å†‚å°√∑‚âà¬∞‚àô¬∑‚àö‚Åø¬≤‚ñ†¬†"
  },
  "ibm437": "cp437",
  "csibm437": "cp437",
  "cp737": {
    "type": "_sbcs",
    "chars": "ŒëŒíŒìŒîŒïŒñŒóŒòŒôŒöŒõŒúŒùŒûŒüŒ†Œ°Œ£Œ§Œ•Œ¶ŒßŒ®Œ©Œ±Œ≤Œ≥Œ¥ŒµŒ∂Œ∑Œ∏ŒπŒ∫ŒªŒºŒΩŒæŒøœÄœÅœÉœÇœÑœÖœÜœáœà‚ñë‚ñí‚ñì‚îÇ‚î§‚ï°‚ï¢‚ïñ‚ïï‚ï£‚ïë‚ïó‚ïù‚ïú‚ïõ‚îê‚îî‚î¥‚î¨‚îú‚îÄ‚îº‚ïû‚ïü‚ïö‚ïî‚ï©‚ï¶‚ï†‚ïê‚ï¨‚ïß‚ï®‚ï§‚ï•‚ïô‚ïò‚ïí‚ïì‚ï´‚ï™‚îò‚îå‚ñà‚ñÑ‚ñå‚ñê‚ñÄœâŒ¨Œ≠ŒÆœäŒØœåœçœãœéŒÜŒàŒâŒäŒåŒéŒè¬±‚â•‚â§Œ™Œ´√∑‚âà¬∞‚àô¬∑‚àö‚Åø¬≤‚ñ†¬†"
  },
  "ibm737": "cp737",
  "csibm737": "cp737",
  "cp775": {
    "type": "_sbcs",
    "chars": "ƒÜ√º√©ƒÅ√§ƒ£√•ƒá≈Çƒì≈ñ≈óƒ´≈π√Ñ√Ö√â√¶√Ü≈ç√∂ƒ¢¬¢≈ö≈õ√ñ√ú√∏¬£√ò√ó¬§ƒÄƒ™√≥≈ª≈º≈∫‚Äù¬¶¬©¬Æ¬¨¬Ω¬º≈Å¬´¬ª‚ñë‚ñí‚ñì‚îÇ‚î§ƒÑƒåƒòƒñ‚ï£‚ïë‚ïó‚ïùƒÆ≈†‚îê‚îî‚î¥‚î¨‚îú‚îÄ‚îº≈≤≈™‚ïö‚ïî‚ï©‚ï¶‚ï†‚ïê‚ï¨≈ΩƒÖƒçƒôƒóƒØ≈°≈≥≈´≈æ‚îò‚îå‚ñà‚ñÑ‚ñå‚ñê‚ñÄ√ì√ü≈å≈É√µ√ï¬µ≈Ñƒ∂ƒ∑ƒªƒº≈Üƒí≈Ö‚Äô¬≠¬±‚Äú¬æ¬∂¬ß√∑‚Äû¬∞‚àô¬∑¬π¬≥¬≤‚ñ†¬†"
  },
  "ibm775": "cp775",
  "csibm775": "cp775",
  "cp850": {
    "type": "_sbcs",
    "chars": "√á√º√©√¢√§√†√•√ß√™√´√®√Ø√Æ√¨√Ñ√Ö√â√¶√Ü√¥√∂√≤√ª√π√ø√ñ√ú√∏¬£√ò√ó∆í√°√≠√≥√∫√±√ë¬™¬∫¬ø¬Æ¬¨¬Ω¬º¬°¬´¬ª‚ñë‚ñí‚ñì‚îÇ‚î§√Å√Ç√Ä¬©‚ï£‚ïë‚ïó‚ïù¬¢¬•‚îê‚îî‚î¥‚î¨‚îú‚îÄ‚îº√£√É‚ïö‚ïî‚ï©‚ï¶‚ï†‚ïê‚ï¨¬§√∞√ê√ä√ã√àƒ±√ç√é√è‚îò‚îå‚ñà‚ñÑ¬¶√å‚ñÄ√ì√ü√î√í√µ√ï¬µ√æ√û√ö√õ√ô√Ω√ù¬Ø¬¥¬≠¬±‚Äó¬æ¬∂¬ß√∑¬∏¬∞¬®¬∑¬π¬≥¬≤‚ñ†¬†"
  },
  "ibm850": "cp850",
  "csibm850": "cp850",
  "cp852": {
    "type": "_sbcs",
    "chars": "√á√º√©√¢√§≈Øƒá√ß≈Ç√´≈ê≈ë√Æ≈π√ÑƒÜ√âƒπƒ∫√¥√∂ƒΩƒæ≈ö≈õ√ñ√ú≈§≈•≈Å√óƒç√°√≠√≥√∫ƒÑƒÖ≈Ω≈æƒòƒô¬¨≈∫ƒå≈ü¬´¬ª‚ñë‚ñí‚ñì‚îÇ‚î§√Å√Çƒö≈û‚ï£‚ïë‚ïó‚ïù≈ª≈º‚îê‚îî‚î¥‚î¨‚îú‚îÄ‚îºƒÇƒÉ‚ïö‚ïî‚ï©‚ï¶‚ï†‚ïê‚ï¨¬§ƒëƒêƒé√ãƒè≈á√ç√éƒõ‚îò‚îå‚ñà‚ñÑ≈¢≈Æ‚ñÄ√ì√ü√î≈É≈Ñ≈à≈†≈°≈î√ö≈ï≈∞√Ω√ù≈£¬¥¬≠ÀùÀõÀáÀò¬ß√∑¬∏¬∞¬®Àô≈±≈ò≈ô‚ñ†¬†"
  },
  "ibm852": "cp852",
  "csibm852": "cp852",
  "cp855": {
    "type": "_sbcs",
    "chars": "—í–Ç—ì–É—ë–Å—î–Ñ—ï–Ö—ñ–Ü—ó–á—ò–à—ô–â—ö–ä—õ–ã—ú–å—û–é—ü–è—é–Æ—ä–™–∞–ê–±–ë—Ü–¶–¥–î–µ–ï—Ñ–§–≥–ì¬´¬ª‚ñë‚ñí‚ñì‚îÇ‚î§—Ö–•–∏–ò‚ï£‚ïë‚ïó‚ïù–π–ô‚îê‚îî‚î¥‚î¨‚îú‚îÄ‚îº–∫–ö‚ïö‚ïî‚ï©‚ï¶‚ï†‚ïê‚ï¨¬§–ª–õ–º–ú–Ω–ù–æ–û–ø‚îò‚îå‚ñà‚ñÑ–ü—è‚ñÄ–Ø—Ä–†—Å–°—Ç–¢—É–£–∂–ñ–≤–í—å–¨‚Ññ¬≠—ã–´–∑–ó—à–®—ç–≠—â–©—á–ß¬ß‚ñ†¬†"
  },
  "ibm855": "cp855",
  "csibm855": "cp855",
  "cp856": {
    "type": "_sbcs",
    "chars": "◊ê◊ë◊í◊ì◊î◊ï◊ñ◊ó◊ò◊ô◊ö◊õ◊ú◊ù◊û◊ü◊†◊°◊¢◊£◊§◊•◊¶◊ß◊®◊©◊™ÔøΩ¬£ÔøΩ√óÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩ¬Æ¬¨¬Ω¬ºÔøΩ¬´¬ª‚ñë‚ñí‚ñì‚îÇ‚î§ÔøΩÔøΩÔøΩ¬©‚ï£‚ïë‚ïó‚ïù¬¢¬•‚îê‚îî‚î¥‚î¨‚îú‚îÄ‚îºÔøΩÔøΩ‚ïö‚ïî‚ï©‚ï¶‚ï†‚ïê‚ï¨¬§ÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩ‚îò‚îå‚ñà‚ñÑ¬¶ÔøΩ‚ñÄÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩ¬µÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩ¬Ø¬¥¬≠¬±‚Äó¬æ¬∂¬ß√∑¬∏¬∞¬®¬∑¬π¬≥¬≤‚ñ†¬†"
  },
  "ibm856": "cp856",
  "csibm856": "cp856",
  "cp857": {
    "type": "_sbcs",
    "chars": "√á√º√©√¢√§√†√•√ß√™√´√®√Ø√Æƒ±√Ñ√Ö√â√¶√Ü√¥√∂√≤√ª√πƒ∞√ñ√ú√∏¬£√ò≈û≈ü√°√≠√≥√∫√±√ëƒûƒü¬ø¬Æ¬¨¬Ω¬º¬°¬´¬ª‚ñë‚ñí‚ñì‚îÇ‚î§√Å√Ç√Ä¬©‚ï£‚ïë‚ïó‚ïù¬¢¬•‚îê‚îî‚î¥‚î¨‚îú‚îÄ‚îº√£√É‚ïö‚ïî‚ï©‚ï¶‚ï†‚ïê‚ï¨¬§¬∫¬™√ä√ã√àÔøΩ√ç√é√è‚îò‚îå‚ñà‚ñÑ¬¶√å‚ñÄ√ì√ü√î√í√µ√ï¬µÔøΩ√ó√ö√õ√ô√¨√ø¬Ø¬¥¬≠¬±ÔøΩ¬æ¬∂¬ß√∑¬∏¬∞¬®¬∑¬π¬≥¬≤‚ñ†¬†"
  },
  "ibm857": "cp857",
  "csibm857": "cp857",
  "cp858": {
    "type": "_sbcs",
    "chars": "√á√º√©√¢√§√†√•√ß√™√´√®√Ø√Æ√¨√Ñ√Ö√â√¶√Ü√¥√∂√≤√ª√π√ø√ñ√ú√∏¬£√ò√ó∆í√°√≠√≥√∫√±√ë¬™¬∫¬ø¬Æ¬¨¬Ω¬º¬°¬´¬ª‚ñë‚ñí‚ñì‚îÇ‚î§√Å√Ç√Ä¬©‚ï£‚ïë‚ïó‚ïù¬¢¬•‚îê‚îî‚î¥‚î¨‚îú‚îÄ‚îº√£√É‚ïö‚ïî‚ï©‚ï¶‚ï†‚ïê‚ï¨¬§√∞√ê√ä√ã√à‚Ç¨√ç√é√è‚îò‚îå‚ñà‚ñÑ¬¶√å‚ñÄ√ì√ü√î√í√µ√ï¬µ√æ√û√ö√õ√ô√Ω√ù¬Ø¬¥¬≠¬±‚Äó¬æ¬∂¬ß√∑¬∏¬∞¬®¬∑¬π¬≥¬≤‚ñ†¬†"
  },
  "ibm858": "cp858",
  "csibm858": "cp858",
  "cp860": {
    "type": "_sbcs",
    "chars": "√á√º√©√¢√£√†√Å√ß√™√ä√®√ç√î√¨√É√Ç√â√Ä√à√¥√µ√≤√ö√π√å√ï√ú¬¢¬£√ô‚Çß√ì√°√≠√≥√∫√±√ë¬™¬∫¬ø√í¬¨¬Ω¬º¬°¬´¬ª‚ñë‚ñí‚ñì‚îÇ‚î§‚ï°‚ï¢‚ïñ‚ïï‚ï£‚ïë‚ïó‚ïù‚ïú‚ïõ‚îê‚îî‚î¥‚î¨‚îú‚îÄ‚îº‚ïû‚ïü‚ïö‚ïî‚ï©‚ï¶‚ï†‚ïê‚ï¨‚ïß‚ï®‚ï§‚ï•‚ïô‚ïò‚ïí‚ïì‚ï´‚ï™‚îò‚îå‚ñà‚ñÑ‚ñå‚ñê‚ñÄŒ±√üŒìœÄŒ£œÉ¬µœÑŒ¶ŒòŒ©Œ¥‚àûœÜŒµ‚à©‚â°¬±‚â•‚â§‚å†‚å°√∑‚âà¬∞‚àô¬∑‚àö‚Åø¬≤‚ñ†¬†"
  },
  "ibm860": "cp860",
  "csibm860": "cp860",
  "cp861": {
    "type": "_sbcs",
    "chars": "√á√º√©√¢√§√†√•√ß√™√´√®√ê√∞√û√Ñ√Ö√â√¶√Ü√¥√∂√æ√ª√ù√Ω√ñ√ú√∏¬£√ò‚Çß∆í√°√≠√≥√∫√Å√ç√ì√ö¬ø‚åê¬¨¬Ω¬º¬°¬´¬ª‚ñë‚ñí‚ñì‚îÇ‚î§‚ï°‚ï¢‚ïñ‚ïï‚ï£‚ïë‚ïó‚ïù‚ïú‚ïõ‚îê‚îî‚î¥‚î¨‚îú‚îÄ‚îº‚ïû‚ïü‚ïö‚ïî‚ï©‚ï¶‚ï†‚ïê‚ï¨‚ïß‚ï®‚ï§‚ï•‚ïô‚ïò‚ïí‚ïì‚ï´‚ï™‚îò‚îå‚ñà‚ñÑ‚ñå‚ñê‚ñÄŒ±√üŒìœÄŒ£œÉ¬µœÑŒ¶ŒòŒ©Œ¥‚àûœÜŒµ‚à©‚â°¬±‚â•‚â§‚å†‚å°√∑‚âà¬∞‚àô¬∑‚àö‚Åø¬≤‚ñ†¬†"
  },
  "ibm861": "cp861",
  "csibm861": "cp861",
  "cp862": {
    "type": "_sbcs",
    "chars": "◊ê◊ë◊í◊ì◊î◊ï◊ñ◊ó◊ò◊ô◊ö◊õ◊ú◊ù◊û◊ü◊†◊°◊¢◊£◊§◊•◊¶◊ß◊®◊©◊™¬¢¬£¬•‚Çß∆í√°√≠√≥√∫√±√ë¬™¬∫¬ø‚åê¬¨¬Ω¬º¬°¬´¬ª‚ñë‚ñí‚ñì‚îÇ‚î§‚ï°‚ï¢‚ïñ‚ïï‚ï£‚ïë‚ïó‚ïù‚ïú‚ïõ‚îê‚îî‚î¥‚î¨‚îú‚îÄ‚îº‚ïû‚ïü‚ïö‚ïî‚ï©‚ï¶‚ï†‚ïê‚ï¨‚ïß‚ï®‚ï§‚ï•‚ïô‚ïò‚ïí‚ïì‚ï´‚ï™‚îò‚îå‚ñà‚ñÑ‚ñå‚ñê‚ñÄŒ±√üŒìœÄŒ£œÉ¬µœÑŒ¶ŒòŒ©Œ¥‚àûœÜŒµ‚à©‚â°¬±‚â•‚â§‚å†‚å°√∑‚âà¬∞‚àô¬∑‚àö‚Åø¬≤‚ñ†¬†"
  },
  "ibm862": "cp862",
  "csibm862": "cp862",
  "cp863": {
    "type": "_sbcs",
    "chars": "√á√º√©√¢√Ç√†¬∂√ß√™√´√®√Ø√Æ‚Äó√Ä¬ß√â√à√ä√¥√ã√è√ª√π¬§√î√ú¬¢¬£√ô√õ∆í¬¶¬¥√≥√∫¬®¬∏¬≥¬Ø√é‚åê¬¨¬Ω¬º¬æ¬´¬ª‚ñë‚ñí‚ñì‚îÇ‚î§‚ï°‚ï¢‚ïñ‚ïï‚ï£‚ïë‚ïó‚ïù‚ïú‚ïõ‚îê‚îî‚î¥‚î¨‚îú‚îÄ‚îº‚ïû‚ïü‚ïö‚ïî‚ï©‚ï¶‚ï†‚ïê‚ï¨‚ïß‚ï®‚ï§‚ï•‚ïô‚ïò‚ïí‚ïì‚ï´‚ï™‚îò‚îå‚ñà‚ñÑ‚ñå‚ñê‚ñÄŒ±√üŒìœÄŒ£œÉ¬µœÑŒ¶ŒòŒ©Œ¥‚àûœÜŒµ‚à©‚â°¬±‚â•‚â§‚å†‚å°√∑‚âà¬∞‚àô¬∑‚àö‚Åø¬≤‚ñ†¬†"
  },
  "ibm863": "cp863",
  "csibm863": "cp863",
  "cp864": {
    "type": "_sbcs",
    "chars": "\u0000\u0001\u0002\u0003\u0004\u0005\u0006\u0007\b\t\n\u000b\f\r\u000e\u000f\u0010\u0011\u0012\u0013\u0014\u0015\u0016\u0017\u0018\u0019\u001a\u001b\u001c\u001d\u001e\u001f !\"#$Ÿ™&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~¬∞¬∑‚àô‚àö‚ñí‚îÄ‚îÇ‚îº‚î§‚î¨‚îú‚î¥‚îê‚îå‚îî‚îòŒ≤‚àûœÜ¬±¬Ω¬º‚âà¬´¬ªÔª∑Ôª∏ÔøΩÔøΩÔªªÔªºÔøΩ¬†¬≠Ô∫Ç¬£¬§Ô∫ÑÔøΩÔøΩÔ∫éÔ∫èÔ∫ïÔ∫ôÿåÔ∫ùÔ∫°Ô∫•Ÿ†Ÿ°Ÿ¢Ÿ£Ÿ§Ÿ•Ÿ¶ŸßŸ®Ÿ©ÔªëÿõÔ∫±Ô∫µÔ∫πÿü¬¢Ô∫ÄÔ∫ÅÔ∫ÉÔ∫ÖÔªäÔ∫ãÔ∫çÔ∫ëÔ∫ìÔ∫óÔ∫õÔ∫üÔ∫£Ô∫ßÔ∫©Ô∫´Ô∫≠Ô∫ØÔ∫≥Ô∫∑Ô∫ªÔ∫øÔªÅÔªÖÔªãÔªè¬¶¬¨√∑√óÔªâŸÄÔªìÔªóÔªõÔªüÔª£ÔªßÔª´Ôª≠ÔªØÔª≥Ô∫ΩÔªåÔªéÔªçÔª°ÔπΩŸëÔª•Ôª©Ôª¨Ôª∞Ôª≤ÔªêÔªïÔªµÔª∂ÔªùÔªôÔª±‚ñ†ÔøΩ"
  },
  "ibm864": "cp864",
  "csibm864": "cp864",
  "cp865": {
    "type": "_sbcs",
    "chars": "√á√º√©√¢√§√†√•√ß√™√´√®√Ø√Æ√¨√Ñ√Ö√â√¶√Ü√¥√∂√≤√ª√π√ø√ñ√ú√∏¬£√ò‚Çß∆í√°√≠√≥√∫√±√ë¬™¬∫¬ø‚åê¬¨¬Ω¬º¬°¬´¬§‚ñë‚ñí‚ñì‚îÇ‚î§‚ï°‚ï¢‚ïñ‚ïï‚ï£‚ïë‚ïó‚ïù‚ïú‚ïõ‚îê‚îî‚î¥‚î¨‚îú‚îÄ‚îº‚ïû‚ïü‚ïö‚ïî‚ï©‚ï¶‚ï†‚ïê‚ï¨‚ïß‚ï®‚ï§‚ï•‚ïô‚ïò‚ïí‚ïì‚ï´‚ï™‚îò‚îå‚ñà‚ñÑ‚ñå‚ñê‚ñÄŒ±√üŒìœÄŒ£œÉ¬µœÑŒ¶ŒòŒ©Œ¥‚àûœÜŒµ‚à©‚â°¬±‚â•‚â§‚å†‚å°√∑‚âà¬∞‚àô¬∑‚àö‚Åø¬≤‚ñ†¬†"
  },
  "ibm865": "cp865",
  "csibm865": "cp865",
  "cp866": {
    "type": "_sbcs",
    "chars": "–ê–ë–í–ì–î–ï–ñ–ó–ò–ô–ö–õ–ú–ù–û–ü–†–°–¢–£–§–•–¶–ß–®–©–™–´–¨–≠–Æ–Ø–∞–±–≤–≥–¥–µ–∂–∑–∏–π–∫–ª–º–Ω–æ–ø‚ñë‚ñí‚ñì‚îÇ‚î§‚ï°‚ï¢‚ïñ‚ïï‚ï£‚ïë‚ïó‚ïù‚ïú‚ïõ‚îê‚îî‚î¥‚î¨‚îú‚îÄ‚îº‚ïû‚ïü‚ïö‚ïî‚ï©‚ï¶‚ï†‚ïê‚ï¨‚ïß‚ï®‚ï§‚ï•‚ïô‚ïò‚ïí‚ïì‚ï´‚ï™‚îò‚îå‚ñà‚ñÑ‚ñå‚ñê‚ñÄ—Ä—Å—Ç—É—Ñ—Ö—Ü—á—à—â—ä—ã—å—ç—é—è–Å—ë–Ñ—î–á—ó–é—û¬∞‚àô¬∑‚àö‚Ññ¬§‚ñ†¬†"
  },
  "ibm866": "cp866",
  "csibm866": "cp866",
  "cp869": {
    "type": "_sbcs",
    "chars": "ÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩŒÜÔøΩ¬∑¬¨¬¶‚Äò‚ÄôŒà‚ÄïŒâŒäŒ™ŒåÔøΩÔøΩŒéŒ´¬©Œè¬≤¬≥Œ¨¬£Œ≠ŒÆŒØœäŒêœåœçŒëŒíŒìŒîŒïŒñŒó¬ΩŒòŒô¬´¬ª‚ñë‚ñí‚ñì‚îÇ‚î§ŒöŒõŒúŒù‚ï£‚ïë‚ïó‚ïùŒûŒü‚îê‚îî‚î¥‚î¨‚îú‚îÄ‚îºŒ†Œ°‚ïö‚ïî‚ï©‚ï¶‚ï†‚ïê‚ï¨Œ£Œ§Œ•Œ¶ŒßŒ®Œ©Œ±Œ≤Œ≥‚îò‚îå‚ñà‚ñÑŒ¥Œµ‚ñÄŒ∂Œ∑Œ∏ŒπŒ∫ŒªŒºŒΩŒæŒøœÄœÅœÉœÇœÑŒÑ¬≠¬±œÖœÜœá¬ßœàŒÖ¬∞¬®œâœãŒ∞œé‚ñ†¬†"
  },
  "ibm869": "cp869",
  "csibm869": "cp869",
  "cp922": {
    "type": "_sbcs",
    "chars": "¬Ä¬Å¬Ç¬É¬Ñ¬Ö¬Ü¬á¬à¬â¬ä¬ã¬å¬ç¬é¬è¬ê¬ë¬í¬ì¬î¬ï¬ñ¬ó¬ò¬ô¬ö¬õ¬ú¬ù¬û¬ü¬†¬°¬¢¬£¬§¬•¬¶¬ß¬®¬©¬™¬´¬¨¬≠¬Æ‚Äæ¬∞¬±¬≤¬≥¬¥¬µ¬∂¬∑¬∏¬π¬∫¬ª¬º¬Ω¬æ¬ø√Ä√Å√Ç√É√Ñ√Ö√Ü√á√à√â√ä√ã√å√ç√é√è≈†√ë√í√ì√î√ï√ñ√ó√ò√ô√ö√õ√ú√ù≈Ω√ü√†√°√¢√£√§√•√¶√ß√®√©√™√´√¨√≠√Æ√Ø≈°√±√≤√≥√¥√µ√∂√∑√∏√π√∫√ª√º√Ω≈æ√ø"
  },
  "ibm922": "cp922",
  "csibm922": "cp922",
  "cp1046": {
    "type": "_sbcs",
    "chars": "Ô∫à√ó√∑Ô£∂Ô£µÔ£¥Ô£∑Ôπ±¬à‚ñ†‚îÇ‚îÄ‚îê‚îå‚îî‚îòÔππÔπªÔπΩÔπøÔπ∑Ô∫äÔª∞Ôª≥Ôª≤ÔªéÔªèÔªêÔª∂Ôª∏Ôª∫Ôªº¬†Ô£∫Ô£πÔ£∏¬§Ô£ªÔ∫ãÔ∫ëÔ∫óÔ∫õÔ∫üÔ∫£ÿå¬≠Ô∫ßÔ∫≥Ÿ†Ÿ°Ÿ¢Ÿ£Ÿ§Ÿ•Ÿ¶ŸßŸ®Ÿ©Ô∫∑ÿõÔ∫ªÔ∫øÔªäÿüÔªãÿ°ÿ¢ÿ£ÿ§ÿ•ÿ¶ÿßÿ®ÿ©ÿ™ÿ´ÿ¨ÿ≠ÿÆÿØÿ∞ÿ±ÿ≤ÿ≥ÿ¥ÿµÿ∂ÿ∑Ôªáÿπÿ∫ÔªåÔ∫ÇÔ∫ÑÔ∫éÔªìŸÄŸÅŸÇŸÉŸÑŸÖŸÜŸáŸàŸâŸäŸãŸåŸçŸéŸèŸêŸëŸíÔªóÔªõÔªüÔ£ºÔªµÔª∑ÔªπÔªªÔª£ÔªßÔª¨Ôª©ÔøΩ"
  },
  "ibm1046": "cp1046",
  "csibm1046": "cp1046",
  "cp1124": {
    "type": "_sbcs",
    "chars": "¬Ä¬Å¬Ç¬É¬Ñ¬Ö¬Ü¬á¬à¬â¬ä¬ã¬å¬ç¬é¬è¬ê¬ë¬í¬ì¬î¬ï¬ñ¬ó¬ò¬ô¬ö¬õ¬ú¬ù¬û¬ü¬†–Å–Ç“ê–Ñ–Ö–Ü–á–à–â–ä–ã–å¬≠–é–è–ê–ë–í–ì–î–ï–ñ–ó–ò–ô–ö–õ–ú–ù–û–ü–†–°–¢–£–§–•–¶–ß–®–©–™–´–¨–≠–Æ–Ø–∞–±–≤–≥–¥–µ–∂–∑–∏–π–∫–ª–º–Ω–æ–ø—Ä—Å—Ç—É—Ñ—Ö—Ü—á—à—â—ä—ã—å—ç—é—è‚Ññ—ë—í“ë—î—ï—ñ—ó—ò—ô—ö—õ—ú¬ß—û—ü"
  },
  "ibm1124": "cp1124",
  "csibm1124": "cp1124",
  "cp1125": {
    "type": "_sbcs",
    "chars": "–ê–ë–í–ì–î–ï–ñ–ó–ò–ô–ö–õ–ú–ù–û–ü–†–°–¢–£–§–•–¶–ß–®–©–™–´–¨–≠–Æ–Ø–∞–±–≤–≥–¥–µ–∂–∑–∏–π–∫–ª–º–Ω–æ–ø‚ñë‚ñí‚ñì‚îÇ‚î§‚ï°‚ï¢‚ïñ‚ïï‚ï£‚ïë‚ïó‚ïù‚ïú‚ïõ‚îê‚îî‚î¥‚î¨‚îú‚îÄ‚îº‚ïû‚ïü‚ïö‚ïî‚ï©‚ï¶‚ï†‚ïê‚ï¨‚ïß‚ï®‚ï§‚ï•‚ïô‚ïò‚ïí‚ïì‚ï´‚ï™‚îò‚îå‚ñà‚ñÑ‚ñå‚ñê‚ñÄ—Ä—Å—Ç—É—Ñ—Ö—Ü—á—à—â—ä—ã—å—ç—é—è–Å—ë“ê“ë–Ñ—î–Ü—ñ–á—ó¬∑‚àö‚Ññ¬§‚ñ†¬†"
  },
  "ibm1125": "cp1125",
  "csibm1125": "cp1125",
  "cp1129": {
    "type": "_sbcs",
    "chars": "¬Ä¬Å¬Ç¬É¬Ñ¬Ö¬Ü¬á¬à¬â¬ä¬ã¬å¬ç¬é¬è¬ê¬ë¬í¬ì¬î¬ï¬ñ¬ó¬ò¬ô¬ö¬õ¬ú¬ù¬û¬ü¬†¬°¬¢¬£¬§¬•¬¶¬ß≈ì¬©¬™¬´¬¨¬≠¬Æ¬Ø¬∞¬±¬≤¬≥≈∏¬µ¬∂¬∑≈í¬π¬∫¬ª¬º¬Ω¬æ¬ø√Ä√Å√ÇƒÇ√Ñ√Ö√Ü√á√à√â√ä√ãÃÄ√ç√é√èƒê√ëÃâ√ì√î∆†√ñ√ó√ò√ô√ö√õ√ú∆ØÃÉ√ü√†√°√¢ƒÉ√§√•√¶√ß√®√©√™√´ÃÅ√≠√Æ√Øƒë√±Ã£√≥√¥∆°√∂√∑√∏√π√∫√ª√º∆∞‚Ç´√ø"
  },
  "ibm1129": "cp1129",
  "csibm1129": "cp1129",
  "cp1133": {
    "type": "_sbcs",
    "chars": "¬Ä¬Å¬Ç¬É¬Ñ¬Ö¬Ü¬á¬à¬â¬ä¬ã¬å¬ç¬é¬è¬ê¬ë¬í¬ì¬î¬ï¬ñ¬ó¬ò¬ô¬ö¬õ¬ú¬ù¬û¬ü¬†‡∫Å‡∫Ç‡∫Ñ‡∫á‡∫à‡∫™‡∫ä‡∫ç‡∫î‡∫ï‡∫ñ‡∫ó‡∫ô‡∫ö‡∫õ‡∫ú‡∫ù‡∫û‡∫ü‡∫°‡∫¢‡∫£‡∫•‡∫ß‡∫´‡∫≠‡∫ÆÔøΩÔøΩÔøΩ‡∫Ø‡∫∞‡∫≤‡∫≥‡∫¥‡∫µ‡∫∂‡∫∑‡∫∏‡∫π‡∫º‡∫±‡∫ª‡∫ΩÔøΩÔøΩÔøΩ‡ªÄ‡ªÅ‡ªÇ‡ªÉ‡ªÑ‡ªà‡ªâ‡ªä‡ªã‡ªå‡ªç‡ªÜÔøΩ‡ªú‡ªù‚Ç≠ÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩ‡ªê‡ªë‡ªí‡ªì‡ªî‡ªï‡ªñ‡ªó‡ªò‡ªôÔøΩÔøΩ¬¢¬¨¬¶ÔøΩ"
  },
  "ibm1133": "cp1133",
  "csibm1133": "cp1133",
  "cp1161": {
    "type": "_sbcs",
    "chars": "ÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩ‡πà‡∏Å‡∏Ç‡∏É‡∏Ñ‡∏Ö‡∏Ü‡∏á‡∏à‡∏â‡∏ä‡∏ã‡∏å‡∏ç‡∏é‡∏è‡∏ê‡∏ë‡∏í‡∏ì‡∏î‡∏ï‡∏ñ‡∏ó‡∏ò‡∏ô‡∏ö‡∏õ‡∏ú‡∏ù‡∏û‡∏ü‡∏†‡∏°‡∏¢‡∏£‡∏§‡∏•‡∏¶‡∏ß‡∏®‡∏©‡∏™‡∏´‡∏¨‡∏≠‡∏Æ‡∏Ø‡∏∞‡∏±‡∏≤‡∏≥‡∏¥‡∏µ‡∏∂‡∏∑‡∏∏‡∏π‡∏∫‡πâ‡πä‡πã‚Ç¨‡∏ø‡πÄ‡πÅ‡πÇ‡πÉ‡πÑ‡πÖ‡πÜ‡πá‡πà‡πâ‡πä‡πã‡πå‡πç‡πé‡πè‡πê‡πë‡πí‡πì‡πî‡πï‡πñ‡πó‡πò‡πô‡πö‡πõ¬¢¬¨¬¶¬†"
  },
  "ibm1161": "cp1161",
  "csibm1161": "cp1161",
  "cp1162": {
    "type": "_sbcs",
    "chars": "‚Ç¨¬Å¬Ç¬É¬Ñ‚Ä¶¬Ü¬á¬à¬â¬ä¬ã¬å¬ç¬é¬è¬ê‚Äò‚Äô‚Äú‚Äù‚Ä¢‚Äì‚Äî¬ò¬ô¬ö¬õ¬ú¬ù¬û¬ü¬†‡∏Å‡∏Ç‡∏É‡∏Ñ‡∏Ö‡∏Ü‡∏á‡∏à‡∏â‡∏ä‡∏ã‡∏å‡∏ç‡∏é‡∏è‡∏ê‡∏ë‡∏í‡∏ì‡∏î‡∏ï‡∏ñ‡∏ó‡∏ò‡∏ô‡∏ö‡∏õ‡∏ú‡∏ù‡∏û‡∏ü‡∏†‡∏°‡∏¢‡∏£‡∏§‡∏•‡∏¶‡∏ß‡∏®‡∏©‡∏™‡∏´‡∏¨‡∏≠‡∏Æ‡∏Ø‡∏∞‡∏±‡∏≤‡∏≥‡∏¥‡∏µ‡∏∂‡∏∑‡∏∏‡∏π‡∏∫ÔøΩÔøΩÔøΩÔøΩ‡∏ø‡πÄ‡πÅ‡πÇ‡πÉ‡πÑ‡πÖ‡πÜ‡πá‡πà‡πâ‡πä‡πã‡πå‡πç‡πé‡πè‡πê‡πë‡πí‡πì‡πî‡πï‡πñ‡πó‡πò‡πô‡πö‡πõÔøΩÔøΩÔøΩÔøΩ"
  },
  "ibm1162": "cp1162",
  "csibm1162": "cp1162",
  "cp1163": {
    "type": "_sbcs",
    "chars": "¬Ä¬Å¬Ç¬É¬Ñ¬Ö¬Ü¬á¬à¬â¬ä¬ã¬å¬ç¬é¬è¬ê¬ë¬í¬ì¬î¬ï¬ñ¬ó¬ò¬ô¬ö¬õ¬ú¬ù¬û¬ü¬†¬°¬¢¬£‚Ç¨¬•¬¶¬ß≈ì¬©¬™¬´¬¨¬≠¬Æ¬Ø¬∞¬±¬≤¬≥≈∏¬µ¬∂¬∑≈í¬π¬∫¬ª¬º¬Ω¬æ¬ø√Ä√Å√ÇƒÇ√Ñ√Ö√Ü√á√à√â√ä√ãÃÄ√ç√é√èƒê√ëÃâ√ì√î∆†√ñ√ó√ò√ô√ö√õ√ú∆ØÃÉ√ü√†√°√¢ƒÉ√§√•√¶√ß√®√©√™√´ÃÅ√≠√Æ√Øƒë√±Ã£√≥√¥∆°√∂√∑√∏√π√∫√ª√º∆∞‚Ç´√ø"
  },
  "ibm1163": "cp1163",
  "csibm1163": "cp1163",
  "maccroatian": {
    "type": "_sbcs",
    "chars": "√Ñ√Ö√á√â√ë√ñ√ú√°√†√¢√§√£√•√ß√©√®√™√´√≠√¨√Æ√Ø√±√≥√≤√¥√∂√µ√∫√π√ª√º‚Ä†¬∞¬¢¬£¬ß‚Ä¢¬∂√ü¬Æ≈†‚Ñ¢¬¥¬®‚â†≈Ω√ò‚àû¬±‚â§‚â•‚àÜ¬µ‚àÇ‚àë‚àè≈°‚à´¬™¬∫‚Ñ¶≈æ√∏¬ø¬°¬¨‚àö∆í‚âàƒÜ¬´ƒå‚Ä¶¬†√Ä√É√ï≈í≈ìƒê‚Äî‚Äú‚Äù‚Äò‚Äô√∑‚óäÔøΩ¬©‚ÅÑ¬§‚Äπ‚Ä∫√Ü¬ª‚Äì¬∑‚Äö‚Äû‚Ä∞√Çƒá√Åƒç√à√ç√é√è√å√ì√îƒë√í√ö√õ√ôƒ±ÀÜÀú¬ØœÄ√ãÀö¬∏√ä√¶Àá"
  },
  "maccyrillic": {
    "type": "_sbcs",
    "chars": "–ê–ë–í–ì–î–ï–ñ–ó–ò–ô–ö–õ–ú–ù–û–ü–†–°–¢–£–§–•–¶–ß–®–©–™–´–¨–≠–Æ–Ø‚Ä†¬∞¬¢¬£¬ß‚Ä¢¬∂–Ü¬Æ¬©‚Ñ¢–Ç—í‚â†–É—ì‚àû¬±‚â§‚â•—ñ¬µ‚àÇ–à–Ñ—î–á—ó–â—ô–ä—ö—ò–Ö¬¨‚àö∆í‚âà‚àÜ¬´¬ª‚Ä¶¬†–ã—õ–å—ú—ï‚Äì‚Äî‚Äú‚Äù‚Äò‚Äô√∑‚Äû–é—û–è—ü‚Ññ–Å—ë—è–∞–±–≤–≥–¥–µ–∂–∑–∏–π–∫–ª–º–Ω–æ–ø—Ä—Å—Ç—É—Ñ—Ö—Ü—á—à—â—ä—ã—å—ç—é¬§"
  },
  "macgreek": {
    "type": "_sbcs",
    "chars": "√Ñ¬π¬≤√â¬≥√ñ√úŒÖ√†√¢√§ŒÑ¬®√ß√©√®√™√´¬£‚Ñ¢√Æ√Ø‚Ä¢¬Ω‚Ä∞√¥√∂¬¶¬≠√π√ª√º‚Ä†ŒìŒîŒòŒõŒûŒ†√ü¬Æ¬©Œ£Œ™¬ß‚â†¬∞ŒáŒë¬±‚â§‚â•¬•ŒíŒïŒñŒóŒôŒöŒúŒ¶Œ´Œ®Œ©Œ¨Œù¬¨ŒüŒ°‚âàŒ§¬´¬ª‚Ä¶¬†Œ•ŒßŒÜŒà≈ì‚Äì‚Äï‚Äú‚Äù‚Äò‚Äô√∑ŒâŒäŒåŒéŒ≠ŒÆŒØœåŒèœçŒ±Œ≤œàŒ¥ŒµœÜŒ≥Œ∑ŒπŒæŒ∫ŒªŒºŒΩŒøœÄœéœÅœÉœÑŒ∏œâœÇœáœÖŒ∂œäœãŒêŒ∞ÔøΩ"
  },
  "maciceland": {
    "type": "_sbcs",
    "chars": "√Ñ√Ö√á√â√ë√ñ√ú√°√†√¢√§√£√•√ß√©√®√™√´√≠√¨√Æ√Ø√±√≥√≤√¥√∂√µ√∫√π√ª√º√ù¬∞¬¢¬£¬ß‚Ä¢¬∂√ü¬Æ¬©‚Ñ¢¬¥¬®‚â†√Ü√ò‚àû¬±‚â§‚â•¬•¬µ‚àÇ‚àë‚àèœÄ‚à´¬™¬∫‚Ñ¶√¶√∏¬ø¬°¬¨‚àö∆í‚âà‚àÜ¬´¬ª‚Ä¶¬†√Ä√É√ï≈í≈ì‚Äì‚Äî‚Äú‚Äù‚Äò‚Äô√∑‚óä√ø≈∏‚ÅÑ¬§√ê√∞√û√æ√Ω¬∑‚Äö‚Äû‚Ä∞√Ç√ä√Å√ã√à√ç√é√è√å√ì√îÔøΩ√í√ö√õ√ôƒ±ÀÜÀú¬ØÀòÀôÀö¬∏ÀùÀõÀá"
  },
  "macroman": {
    "type": "_sbcs",
    "chars": "√Ñ√Ö√á√â√ë√ñ√ú√°√†√¢√§√£√•√ß√©√®√™√´√≠√¨√Æ√Ø√±√≥√≤√¥√∂√µ√∫√π√ª√º‚Ä†¬∞¬¢¬£¬ß‚Ä¢¬∂√ü¬Æ¬©‚Ñ¢¬¥¬®‚â†√Ü√ò‚àû¬±‚â§‚â•¬•¬µ‚àÇ‚àë‚àèœÄ‚à´¬™¬∫‚Ñ¶√¶√∏¬ø¬°¬¨‚àö∆í‚âà‚àÜ¬´¬ª‚Ä¶¬†√Ä√É√ï≈í≈ì‚Äì‚Äî‚Äú‚Äù‚Äò‚Äô√∑‚óä√ø≈∏‚ÅÑ¬§‚Äπ‚Ä∫Ô¨ÅÔ¨Ç‚Ä°¬∑‚Äö‚Äû‚Ä∞√Ç√ä√Å√ã√à√ç√é√è√å√ì√îÔøΩ√í√ö√õ√ôƒ±ÀÜÀú¬ØÀòÀôÀö¬∏ÀùÀõÀá"
  },
  "macromania": {
    "type": "_sbcs",
    "chars": "√Ñ√Ö√á√â√ë√ñ√ú√°√†√¢√§√£√•√ß√©√®√™√´√≠√¨√Æ√Ø√±√≥√≤√¥√∂√µ√∫√π√ª√º‚Ä†¬∞¬¢¬£¬ß‚Ä¢¬∂√ü¬Æ¬©‚Ñ¢¬¥¬®‚â†ƒÇ≈û‚àû¬±‚â§‚â•¬•¬µ‚àÇ‚àë‚àèœÄ‚à´¬™¬∫‚Ñ¶ƒÉ≈ü¬ø¬°¬¨‚àö∆í‚âà‚àÜ¬´¬ª‚Ä¶¬†√Ä√É√ï≈í≈ì‚Äì‚Äî‚Äú‚Äù‚Äò‚Äô√∑‚óä√ø≈∏‚ÅÑ¬§‚Äπ‚Ä∫≈¢≈£‚Ä°¬∑‚Äö‚Äû‚Ä∞√Ç√ä√Å√ã√à√ç√é√è√å√ì√îÔøΩ√í√ö√õ√ôƒ±ÀÜÀú¬ØÀòÀôÀö¬∏ÀùÀõÀá"
  },
  "macthai": {
    "type": "_sbcs",
    "chars": "¬´¬ª‚Ä¶Ô¢åÔ¢èÔ¢íÔ¢ïÔ¢òÔ¢ãÔ¢éÔ¢ëÔ¢îÔ¢ó‚Äú‚ÄùÔ¢ôÔøΩ‚Ä¢Ô¢ÑÔ¢âÔ¢ÖÔ¢ÜÔ¢áÔ¢àÔ¢äÔ¢çÔ¢êÔ¢ìÔ¢ñ‚Äò‚ÄôÔøΩ¬†‡∏Å‡∏Ç‡∏É‡∏Ñ‡∏Ö‡∏Ü‡∏á‡∏à‡∏â‡∏ä‡∏ã‡∏å‡∏ç‡∏é‡∏è‡∏ê‡∏ë‡∏í‡∏ì‡∏î‡∏ï‡∏ñ‡∏ó‡∏ò‡∏ô‡∏ö‡∏õ‡∏ú‡∏ù‡∏û‡∏ü‡∏†‡∏°‡∏¢‡∏£‡∏§‡∏•‡∏¶‡∏ß‡∏®‡∏©‡∏™‡∏´‡∏¨‡∏≠‡∏Æ‡∏Ø‡∏∞‡∏±‡∏≤‡∏≥‡∏¥‡∏µ‡∏∂‡∏∑‡∏∏‡∏π‡∏∫Ôªø‚Äã‚Äì‚Äî‡∏ø‡πÄ‡πÅ‡πÇ‡πÉ‡πÑ‡πÖ‡πÜ‡πá‡πà‡πâ‡πä‡πã‡πå‡πç‚Ñ¢‡πè‡πê‡πë‡πí‡πì‡πî‡πï‡πñ‡πó‡πò‡πô¬Æ¬©ÔøΩÔøΩÔøΩÔøΩ"
  },
  "macturkish": {
    "type": "_sbcs",
    "chars": "√Ñ√Ö√á√â√ë√ñ√ú√°√†√¢√§√£√•√ß√©√®√™√´√≠√¨√Æ√Ø√±√≥√≤√¥√∂√µ√∫√π√ª√º‚Ä†¬∞¬¢¬£¬ß‚Ä¢¬∂√ü¬Æ¬©‚Ñ¢¬¥¬®‚â†√Ü√ò‚àû¬±‚â§‚â•¬•¬µ‚àÇ‚àë‚àèœÄ‚à´¬™¬∫‚Ñ¶√¶√∏¬ø¬°¬¨‚àö∆í‚âà‚àÜ¬´¬ª‚Ä¶¬†√Ä√É√ï≈í≈ì‚Äì‚Äî‚Äú‚Äù‚Äò‚Äô√∑‚óä√ø≈∏ƒûƒüƒ∞ƒ±≈û≈ü‚Ä°¬∑‚Äö‚Äû‚Ä∞√Ç√ä√Å√ã√à√ç√é√è√å√ì√îÔøΩ√í√ö√õ√ôÔøΩÀÜÀú¬ØÀòÀôÀö¬∏ÀùÀõÀá"
  },
  "macukraine": {
    "type": "_sbcs",
    "chars": "–ê–ë–í–ì–î–ï–ñ–ó–ò–ô–ö–õ–ú–ù–û–ü–†–°–¢–£–§–•–¶–ß–®–©–™–´–¨–≠–Æ–Ø‚Ä†¬∞“ê¬£¬ß‚Ä¢¬∂–Ü¬Æ¬©‚Ñ¢–Ç—í‚â†–É—ì‚àû¬±‚â§‚â•—ñ¬µ“ë–à–Ñ—î–á—ó–â—ô–ä—ö—ò–Ö¬¨‚àö∆í‚âà‚àÜ¬´¬ª‚Ä¶¬†–ã—õ–å—ú—ï‚Äì‚Äî‚Äú‚Äù‚Äò‚Äô√∑‚Äû–é—û–è—ü‚Ññ–Å—ë—è–∞–±–≤–≥–¥–µ–∂–∑–∏–π–∫–ª–º–Ω–æ–ø—Ä—Å—Ç—É—Ñ—Ö—Ü—á—à—â—ä—ã—å—ç—é¬§"
  },
  "koi8r": {
    "type": "_sbcs",
    "chars": "‚îÄ‚îÇ‚îå‚îê‚îî‚îò‚îú‚î§‚î¨‚î¥‚îº‚ñÄ‚ñÑ‚ñà‚ñå‚ñê‚ñë‚ñí‚ñì‚å†‚ñ†‚àô‚àö‚âà‚â§‚â•¬†‚å°¬∞¬≤¬∑√∑‚ïê‚ïë‚ïí—ë‚ïì‚ïî‚ïï‚ïñ‚ïó‚ïò‚ïô‚ïö‚ïõ‚ïú‚ïù‚ïû‚ïü‚ï†‚ï°–Å‚ï¢‚ï£‚ï§‚ï•‚ï¶‚ïß‚ï®‚ï©‚ï™‚ï´‚ï¨¬©—é–∞–±—Ü–¥–µ—Ñ–≥—Ö–∏–π–∫–ª–º–Ω–æ–ø—è—Ä—Å—Ç—É–∂–≤—å—ã–∑—à—ç—â—á—ä–Æ–ê–ë–¶–î–ï–§–ì–•–ò–ô–ö–õ–ú–ù–û–ü–Ø–†–°–¢–£–ñ–í–¨–´–ó–®–≠–©–ß–™"
  },
  "koi8u": {
    "type": "_sbcs",
    "chars": "‚îÄ‚îÇ‚îå‚îê‚îî‚îò‚îú‚î§‚î¨‚î¥‚îº‚ñÄ‚ñÑ‚ñà‚ñå‚ñê‚ñë‚ñí‚ñì‚å†‚ñ†‚àô‚àö‚âà‚â§‚â•¬†‚å°¬∞¬≤¬∑√∑‚ïê‚ïë‚ïí—ë—î‚ïî—ñ—ó‚ïó‚ïò‚ïô‚ïö‚ïõ“ë‚ïù‚ïû‚ïü‚ï†‚ï°–Å–Ñ‚ï£–Ü–á‚ï¶‚ïß‚ï®‚ï©‚ï™“ê‚ï¨¬©—é–∞–±—Ü–¥–µ—Ñ–≥—Ö–∏–π–∫–ª–º–Ω–æ–ø—è—Ä—Å—Ç—É–∂–≤—å—ã–∑—à—ç—â—á—ä–Æ–ê–ë–¶–î–ï–§–ì–•–ò–ô–ö–õ–ú–ù–û–ü–Ø–†–°–¢–£–ñ–í–¨–´–ó–®–≠–©–ß–™"
  },
  "koi8ru": {
    "type": "_sbcs",
    "chars": "‚îÄ‚îÇ‚îå‚îê‚îî‚îò‚îú‚î§‚î¨‚î¥‚îº‚ñÄ‚ñÑ‚ñà‚ñå‚ñê‚ñë‚ñí‚ñì‚å†‚ñ†‚àô‚àö‚âà‚â§‚â•¬†‚å°¬∞¬≤¬∑√∑‚ïê‚ïë‚ïí—ë—î‚ïî—ñ—ó‚ïó‚ïò‚ïô‚ïö‚ïõ“ë—û‚ïû‚ïü‚ï†‚ï°–Å–Ñ‚ï£–Ü–á‚ï¶‚ïß‚ï®‚ï©‚ï™“ê–é¬©—é–∞–±—Ü–¥–µ—Ñ–≥—Ö–∏–π–∫–ª–º–Ω–æ–ø—è—Ä—Å—Ç—É–∂–≤—å—ã–∑—à—ç—â—á—ä–Æ–ê–ë–¶–î–ï–§–ì–•–ò–ô–ö–õ–ú–ù–û–ü–Ø–†–°–¢–£–ñ–í–¨–´–ó–®–≠–©–ß–™"
  },
  "koi8t": {
    "type": "_sbcs",
    "chars": "“õ“ì‚Äö“í‚Äû‚Ä¶‚Ä†‚Ä°ÔøΩ‚Ä∞“≥‚Äπ“≤“∑“∂ÔøΩ“ö‚Äò‚Äô‚Äú‚Äù‚Ä¢‚Äì‚ÄîÔøΩ‚Ñ¢ÔøΩ‚Ä∫ÔøΩÔøΩÔøΩÔøΩÔøΩ”Ø”Æ—ë¬§”£¬¶¬ßÔøΩÔøΩÔøΩ¬´¬¨¬≠¬ÆÔøΩ¬∞¬±¬≤–ÅÔøΩ”¢¬∂¬∑ÔøΩ‚ÑñÔøΩ¬ªÔøΩÔøΩÔøΩ¬©—é–∞–±—Ü–¥–µ—Ñ–≥—Ö–∏–π–∫–ª–º–Ω–æ–ø—è—Ä—Å—Ç—É–∂–≤—å—ã–∑—à—ç—â—á—ä–Æ–ê–ë–¶–î–ï–§–ì–•–ò–ô–ö–õ–ú–ù–û–ü–Ø–†–°–¢–£–ñ–í–¨–´–ó–®–≠–©–ß–™"
  },
  "armscii8": {
    "type": "_sbcs",
    "chars": "¬Ä¬Å¬Ç¬É¬Ñ¬Ö¬Ü¬á¬à¬â¬ä¬ã¬å¬ç¬é¬è¬ê¬ë¬í¬ì¬î¬ï¬ñ¬ó¬ò¬ô¬ö¬õ¬ú¬ù¬û¬ü¬†ÔøΩ÷á÷â)(¬ª¬´‚Äî.’ù,-÷ä‚Ä¶’ú’õ’û‘±’°‘≤’¢‘≥’£‘¥’§‘µ’•‘∂’¶‘∑’ß‘∏’®‘π’©‘∫’™‘ª’´‘º’¨‘Ω’≠‘æ’Æ‘ø’Ø’Ä’∞’Å’±’Ç’≤’É’≥’Ñ’¥’Ö’µ’Ü’∂’á’∑’à’∏’â’π’ä’∫’ã’ª’å’º’ç’Ω’é’æ’è’ø’ê÷Ä’ë÷Å’í÷Ç’ì÷É’î÷Ñ’ï÷Ö’ñ÷Ü’öÔøΩ"
  },
  "rk1048": {
    "type": "_sbcs",
    "chars": "–Ç–É‚Äö—ì‚Äû‚Ä¶‚Ä†‚Ä°‚Ç¨‚Ä∞–â‚Äπ–ä“ö“∫–è—í‚Äò‚Äô‚Äú‚Äù‚Ä¢‚Äì‚ÄîÔøΩ‚Ñ¢—ô‚Ä∫—ö“õ“ª—ü¬†“∞“±”ò¬§”®¬¶¬ß–Å¬©“í¬´¬¨¬≠¬Æ“Æ¬∞¬±–Ü—ñ”©¬µ¬∂¬∑—ë‚Ññ“ì¬ª”ô“¢“£“Ø–ê–ë–í–ì–î–ï–ñ–ó–ò–ô–ö–õ–ú–ù–û–ü–†–°–¢–£–§–•–¶–ß–®–©–™–´–¨–≠–Æ–Ø–∞–±–≤–≥–¥–µ–∂–∑–∏–π–∫–ª–º–Ω–æ–ø—Ä—Å—Ç—É—Ñ—Ö—Ü—á—à—â—ä—ã—å—ç—é—è"
  },
  "tcvn": {
    "type": "_sbcs",
    "chars": "\u0000√ö·ª§\u0003·ª™·ª¨·ªÆ\u0007\b\t\n\u000b\f\r\u000e\u000f\u0010·ª®·ª∞·ª≤·ª∂·ª∏√ù·ª¥\u0018\u0019\u001a\u001b\u001c\u001d\u001e\u001f !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~√Ä·∫¢√É√Å·∫†·∫∂·∫¨√à·∫∫·∫º√â·∫∏·ªÜ√å·ªàƒ®√ç·ªä√í·ªé√ï√ì·ªå·ªò·ªú·ªû·ª†·ªö·ª¢√ô·ª¶≈®¬†ƒÇ√Ç√ä√î∆†∆ØƒêƒÉ√¢√™√¥∆°∆∞ƒë·∫∞ÃÄÃâÃÉÃÅÃ£√†·∫£√£√°·∫°·∫≤·∫±·∫≥·∫µ·∫Ø·∫¥·∫Æ·∫¶·∫®·∫™·∫§·ªÄ·∫∑·∫ß·∫©·∫´·∫•·∫≠√®·ªÇ·∫ª·∫Ω√©·∫π·ªÅ·ªÉ·ªÖ·∫ø·ªá√¨·ªâ·ªÑ·∫æ·ªíƒ©√≠·ªã√≤·ªî·ªè√µ√≥·ªç·ªì·ªï·ªó·ªë·ªô·ªù·ªü·ª°·ªõ·ª£√π·ªñ·ªß≈©√∫·ª•·ª´·ª≠·ªØ·ª©·ª±·ª≥·ª∑·ªπ√Ω·ªµ·ªê"
  },
  "georgianacademy": {
    "type": "_sbcs",
    "chars": "¬Ä¬Å‚Äö∆í‚Äû‚Ä¶‚Ä†‚Ä°ÀÜ‚Ä∞≈†‚Äπ≈í¬ç¬é¬è¬ê‚Äò‚Äô‚Äú‚Äù‚Ä¢‚Äì‚ÄîÀú‚Ñ¢≈°‚Ä∫≈ì¬ù¬û≈∏¬†¬°¬¢¬£¬§¬•¬¶¬ß¬®¬©¬™¬´¬¨¬≠¬Æ¬Ø¬∞¬±¬≤¬≥¬¥¬µ¬∂¬∑¬∏¬π¬∫¬ª¬º¬Ω¬æ¬ø·Éê·Éë·Éí·Éì·Éî·Éï·Éñ·Éó·Éò·Éô·Éö·Éõ·Éú·Éù·Éû·Éü·É†·É°·É¢·É£·É§·É•·É¶·Éß·É®·É©·É™·É´·É¨·É≠·ÉÆ·ÉØ·É∞·É±·É≤·É≥·É¥·Éµ·É∂√ß√®√©√™√´√¨√≠√Æ√Ø√∞√±√≤√≥√¥√µ√∂√∑√∏√π√∫√ª√º√Ω√æ√ø"
  },
  "georgianps": {
    "type": "_sbcs",
    "chars": "¬Ä¬Å‚Äö∆í‚Äû‚Ä¶‚Ä†‚Ä°ÀÜ‚Ä∞≈†‚Äπ≈í¬ç¬é¬è¬ê‚Äò‚Äô‚Äú‚Äù‚Ä¢‚Äì‚ÄîÀú‚Ñ¢≈°‚Ä∫≈ì¬ù¬û≈∏¬†¬°¬¢¬£¬§¬•¬¶¬ß¬®¬©¬™¬´¬¨¬≠¬Æ¬Ø¬∞¬±¬≤¬≥¬¥¬µ¬∂¬∑¬∏¬π¬∫¬ª¬º¬Ω¬æ¬ø·Éê·Éë·Éí·Éì·Éî·Éï·Éñ·É±·Éó·Éò·Éô·Éö·Éõ·Éú·É≤·Éù·Éû·Éü·É†·É°·É¢·É≥·É£·É§·É•·É¶·Éß·É®·É©·É™·É´·É¨·É≠·ÉÆ·É¥·ÉØ·É∞·Éµ√¶√ß√®√©√™√´√¨√≠√Æ√Ø√∞√±√≤√≥√¥√µ√∂√∑√∏√π√∫√ª√º√Ω√æ√ø"
  },
  "pt154": {
    "type": "_sbcs",
    "chars": "“ñ“í”Æ“ì‚Äû‚Ä¶“∂“Æ“≤“Ø“†”¢“¢“ö“∫“∏“ó‚Äò‚Äô‚Äú‚Äù‚Ä¢‚Äì‚Äî“≥“∑“°”£“£“õ“ª“π¬†–é—û–à”®“ò“∞¬ß–Å¬©”ò¬´¬¨”Ø¬Æ“ú¬∞“±–Ü—ñ“ô”©¬∂¬∑—ë‚Ññ”ô¬ª—ò“™“´“ù–ê–ë–í–ì–î–ï–ñ–ó–ò–ô–ö–õ–ú–ù–û–ü–†–°–¢–£–§–•–¶–ß–®–©–™–´–¨–≠–Æ–Ø–∞–±–≤–≥–¥–µ–∂–∑–∏–π–∫–ª–º–Ω–æ–ø—Ä—Å—Ç—É—Ñ—Ö—Ü—á—à—â—ä—ã—å—ç—é—è"
  },
  "viscii": {
    "type": "_sbcs",
    "chars": "\u0000\u0001·∫≤\u0003\u0004·∫¥·∫™\u0007\b\t\n\u000b\f\r\u000e\u000f\u0010\u0011\u0012\u0013·ª∂\u0015\u0016\u0017\u0018·ª∏\u001a\u001b\u001c\u001d·ª¥\u001f !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~·∫†·∫Æ·∫∞·∫∂·∫§·∫¶·∫®·∫¨·∫º·∫∏·∫æ·ªÄ·ªÇ·ªÑ·ªÜ·ªê·ªí·ªî·ªñ·ªò·ª¢·ªö·ªú·ªû·ªä·ªé·ªå·ªà·ª¶≈®·ª§·ª≤√ï·∫Ø·∫±·∫∑·∫•·∫ß·∫©·∫≠·∫Ω·∫π·∫ø·ªÅ·ªÉ·ªÖ·ªá·ªë·ªì·ªï·ªó·ª†∆†·ªô·ªù·ªü·ªã·ª∞·ª®·ª™·ª¨∆°·ªõ∆Ø√Ä√Å√Ç√É·∫¢ƒÇ·∫≥·∫µ√à√â√ä·∫∫√å√çƒ®·ª≥ƒê·ª©√í√ì√î·∫°·ª∑·ª´·ª≠√ô√ö·ªπ·ªµ√ù·ª°∆∞√†√°√¢√£·∫£ƒÉ·ªØ·∫´√®√©√™·∫ª√¨√≠ƒ©·ªâƒë·ª±√≤√≥√¥√µ·ªè·ªç·ª•√π√∫≈©·ªß√Ω·ª£·ªÆ"
  },
  "iso646cn": {
    "type": "_sbcs",
    "chars": "\u0000\u0001\u0002\u0003\u0004\u0005\u0006\u0007\b\t\n\u000b\f\r\u000e\u000f\u0010\u0011\u0012\u0013\u0014\u0015\u0016\u0017\u0018\u0019\u001a\u001b\u001c\u001d\u001e\u001f !\"#¬•%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}‚ÄæÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩ"
  },
  "iso646jp": {
    "type": "_sbcs",
    "chars": "\u0000\u0001\u0002\u0003\u0004\u0005\u0006\u0007\b\t\n\u000b\f\r\u000e\u000f\u0010\u0011\u0012\u0013\u0014\u0015\u0016\u0017\u0018\u0019\u001a\u001b\u001c\u001d\u001e\u001f !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[¬•]^_`abcdefghijklmnopqrstuvwxyz{|}‚ÄæÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩ"
  },
  "hproman8": {
    "type": "_sbcs",
    "chars": "¬Ä¬Å¬Ç¬É¬Ñ¬Ö¬Ü¬á¬à¬â¬ä¬ã¬å¬ç¬é¬è¬ê¬ë¬í¬ì¬î¬ï¬ñ¬ó¬ò¬ô¬ö¬õ¬ú¬ù¬û¬ü¬†√Ä√Ç√à√ä√ã√é√è¬¥ÀãÀÜ¬®Àú√ô√õ‚Ç§¬Ø√ù√Ω¬∞√á√ß√ë√±¬°¬ø¬§¬£¬•¬ß∆í¬¢√¢√™√¥√ª√°√©√≥√∫√†√®√≤√π√§√´√∂√º√Ö√Æ√ò√Ü√•√≠√∏√¶√Ñ√¨√ñ√ú√â√Ø√ü√î√Å√É√£√ê√∞√ç√å√ì√í√ï√µ≈†≈°√ö≈∏√ø√û√æ¬∑¬µ¬∂¬æ‚Äî¬º¬Ω¬™¬∫¬´‚ñ†¬ª¬±ÔøΩ"
  },
  "macintosh": {
    "type": "_sbcs",
    "chars": "√Ñ√Ö√á√â√ë√ñ√ú√°√†√¢√§√£√•√ß√©√®√™√´√≠√¨√Æ√Ø√±√≥√≤√¥√∂√µ√∫√π√ª√º‚Ä†¬∞¬¢¬£¬ß‚Ä¢¬∂√ü¬Æ¬©‚Ñ¢¬¥¬®‚â†√Ü√ò‚àû¬±‚â§‚â•¬•¬µ‚àÇ‚àë‚àèœÄ‚à´¬™¬∫‚Ñ¶√¶√∏¬ø¬°¬¨‚àö∆í‚âà‚àÜ¬´¬ª‚Ä¶¬†√Ä√É√ï≈í≈ì‚Äì‚Äî‚Äú‚Äù‚Äò‚Äô√∑‚óä√ø≈∏‚ÅÑ¬§‚Äπ‚Ä∫Ô¨ÅÔ¨Ç‚Ä°¬∑‚Äö‚Äû‚Ä∞√Ç√ä√Å√ã√à√ç√é√è√å√ì√îÔøΩ√í√ö√õ√ôƒ±ÀÜÀú¬ØÀòÀôÀö¬∏ÀùÀõÀá"
  },
  "ascii": {
    "type": "_sbcs",
    "chars": "ÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩ"
  },
  "tis620": {
    "type": "_sbcs",
    "chars": "ÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩ‡∏Å‡∏Ç‡∏É‡∏Ñ‡∏Ö‡∏Ü‡∏á‡∏à‡∏â‡∏ä‡∏ã‡∏å‡∏ç‡∏é‡∏è‡∏ê‡∏ë‡∏í‡∏ì‡∏î‡∏ï‡∏ñ‡∏ó‡∏ò‡∏ô‡∏ö‡∏õ‡∏ú‡∏ù‡∏û‡∏ü‡∏†‡∏°‡∏¢‡∏£‡∏§‡∏•‡∏¶‡∏ß‡∏®‡∏©‡∏™‡∏´‡∏¨‡∏≠‡∏Æ‡∏Ø‡∏∞‡∏±‡∏≤‡∏≥‡∏¥‡∏µ‡∏∂‡∏∑‡∏∏‡∏π‡∏∫ÔøΩÔøΩÔøΩÔøΩ‡∏ø‡πÄ‡πÅ‡πÇ‡πÉ‡πÑ‡πÖ‡πÜ‡πá‡πà‡πâ‡πä‡πã‡πå‡πç‡πé‡πè‡πê‡πë‡πí‡πì‡πî‡πï‡πñ‡πó‡πò‡πô‡πö‡πõÔøΩÔøΩÔøΩÔøΩ"
  }
}

/***/ }),

/***/ 83963:
/***/ ((module) => {

"use strict";


// Manually added data to be used by sbcs codec in addition to generated one.

module.exports = {
  // Not supported by iconv, not sure why.
  10029: "maccenteuro",
  maccenteuro: {
    type: "_sbcs",
    chars: "√ÑƒÄƒÅ√âƒÑ√ñ√ú√°ƒÖƒå√§ƒçƒÜƒá√©≈π≈∫ƒé√≠ƒèƒíƒìƒñ√≥ƒó√¥√∂√µ√∫ƒöƒõ√º‚Ä†¬∞ƒò¬£¬ß‚Ä¢¬∂√ü¬Æ¬©‚Ñ¢ƒô¬®‚â†ƒ£ƒÆƒØƒ™‚â§‚â•ƒ´ƒ∂‚àÇ‚àë≈ÇƒªƒºƒΩƒæƒπƒ∫≈Ö≈Ü≈É¬¨‚àö≈Ñ≈á‚àÜ¬´¬ª‚Ä¶¬†≈à≈ê√ï≈ë≈å‚Äì‚Äî‚Äú‚Äù‚Äò‚Äô√∑‚óä≈ç≈î≈ï≈ò‚Äπ‚Ä∫≈ô≈ñ≈ó≈†‚Äö‚Äû≈°≈ö≈õ√Å≈§≈•√ç≈Ω≈æ≈™√ì√î≈´≈Æ√ö≈Ø≈∞≈±≈≤≈≥√ù√Ωƒ∑≈ª≈Å≈ºƒ¢Àá"
  },

  808: "cp808",
  ibm808: "cp808",
  cp808: {
    type: "_sbcs",
    chars: "–ê–ë–í–ì–î–ï–ñ–ó–ò–ô–ö–õ–ú–ù–û–ü–†–°–¢–£–§–•–¶–ß–®–©–™–´–¨–≠–Æ–Ø–∞–±–≤–≥–¥–µ–∂–∑–∏–π–∫–ª–º–Ω–æ–ø‚ñë‚ñí‚ñì‚îÇ‚î§‚ï°‚ï¢‚ïñ‚ïï‚ï£‚ïë‚ïó‚ïù‚ïú‚ïõ‚îê‚îî‚î¥‚î¨‚îú‚îÄ‚îº‚ïû‚ïü‚ïö‚ïî‚ï©‚ï¶‚ï†‚ïê‚ï¨‚ïß‚ï®‚ï§‚ï•‚ïô‚ïò‚ïí‚ïì‚ï´‚ï™‚îò‚îå‚ñà‚ñÑ‚ñå‚ñê‚ñÄ—Ä—Å—Ç—É—Ñ—Ö—Ü—á—à—â—ä—ã—å—ç—é—è–Å—ë–Ñ—î–á—ó–é—û¬∞‚àô¬∑‚àö‚Ññ‚Ç¨‚ñ†¬†"
  },

  mik: {
    type: "_sbcs",
    chars: "–ê–ë–í–ì–î–ï–ñ–ó–ò–ô–ö–õ–ú–ù–û–ü–†–°–¢–£–§–•–¶–ß–®–©–™–´–¨–≠–Æ–Ø–∞–±–≤–≥–¥–µ–∂–∑–∏–π–∫–ª–º–Ω–æ–ø—Ä—Å—Ç—É—Ñ—Ö—Ü—á—à—â—ä—ã—å—ç—é—è‚îî‚î¥‚î¨‚îú‚îÄ‚îº‚ï£‚ïë‚ïö‚ïî‚ï©‚ï¶‚ï†‚ïê‚ï¨‚îê‚ñë‚ñí‚ñì‚îÇ‚î§‚Ññ¬ß‚ïó‚ïù‚îò‚îå‚ñà‚ñÑ‚ñå‚ñê‚ñÄŒ±√üŒìœÄŒ£œÉ¬µœÑŒ¶ŒòŒ©Œ¥‚àûœÜŒµ‚à©‚â°¬±‚â•‚â§‚å†‚å°√∑‚âà¬∞‚àô¬∑‚àö‚Åø¬≤‚ñ†¬†"
  },

  cp720: {
    type: "_sbcs",
    chars: "\x80\x81√©√¢\x84√†\x86√ß√™√´√®√Ø√Æ\x8d\x8e\x8f\x90\u0651\u0652√¥¬§ŸÄ√ª√πÿ°ÿ¢ÿ£ÿ§¬£ÿ•ÿ¶ÿßÿ®ÿ©ÿ™ÿ´ÿ¨ÿ≠ÿÆÿØÿ∞ÿ±ÿ≤ÿ≥ÿ¥ÿµ¬´¬ª‚ñë‚ñí‚ñì‚îÇ‚î§‚ï°‚ï¢‚ïñ‚ïï‚ï£‚ïë‚ïó‚ïù‚ïú‚ïõ‚îê‚îî‚î¥‚î¨‚îú‚îÄ‚îº‚ïû‚ïü‚ïö‚ïî‚ï©‚ï¶‚ï†‚ïê‚ï¨‚ïß‚ï®‚ï§‚ï•‚ïô‚ïò‚ïí‚ïì‚ï´‚ï™‚îò‚îå‚ñà‚ñÑ‚ñå‚ñê‚ñÄÿ∂ÿ∑ÿ∏ÿπÿ∫ŸÅ¬µŸÇŸÉŸÑŸÖŸÜŸáŸàŸâŸä‚â°\u064b\u064c\u064d\u064e\u064f\u0650‚âà¬∞‚àô¬∑‚àö‚Åø¬≤‚ñ†\u00a0"
  },

  // Aliases of generated encodings.
  ascii8bit: "ascii",
  usascii: "ascii",
  ansix34: "ascii",
  ansix341968: "ascii",
  ansix341986: "ascii",
  csascii: "ascii",
  cp367: "ascii",
  ibm367: "ascii",
  isoir6: "ascii",
  iso646us: "ascii",
  iso646irv: "ascii",
  us: "ascii",

  latin1: "iso88591",
  latin2: "iso88592",
  latin3: "iso88593",
  latin4: "iso88594",
  latin5: "iso88599",
  latin6: "iso885910",
  latin7: "iso885913",
  latin8: "iso885914",
  latin9: "iso885915",
  latin10: "iso885916",

  csisolatin1: "iso88591",
  csisolatin2: "iso88592",
  csisolatin3: "iso88593",
  csisolatin4: "iso88594",
  csisolatincyrillic: "iso88595",
  csisolatinarabic: "iso88596",
  csisolatingreek: "iso88597",
  csisolatinhebrew: "iso88598",
  csisolatin5: "iso88599",
  csisolatin6: "iso885910",

  l1: "iso88591",
  l2: "iso88592",
  l3: "iso88593",
  l4: "iso88594",
  l5: "iso88599",
  l6: "iso885910",
  l7: "iso885913",
  l8: "iso885914",
  l9: "iso885915",
  l10: "iso885916",

  isoir14: "iso646jp",
  isoir57: "iso646cn",
  isoir100: "iso88591",
  isoir101: "iso88592",
  isoir109: "iso88593",
  isoir110: "iso88594",
  isoir144: "iso88595",
  isoir127: "iso88596",
  isoir126: "iso88597",
  isoir138: "iso88598",
  isoir148: "iso88599",
  isoir157: "iso885910",
  isoir166: "tis620",
  isoir179: "iso885913",
  isoir199: "iso885914",
  isoir203: "iso885915",
  isoir226: "iso885916",

  cp819: "iso88591",
  ibm819: "iso88591",

  cyrillic: "iso88595",

  arabic: "iso88596",
  arabic8: "iso88596",
  ecma114: "iso88596",
  asmo708: "iso88596",

  greek: "iso88597",
  greek8: "iso88597",
  ecma118: "iso88597",
  elot928: "iso88597",

  hebrew: "iso88598",
  hebrew8: "iso88598",

  turkish: "iso88599",
  turkish8: "iso88599",

  thai: "iso885911",
  thai8: "iso885911",

  celtic: "iso885914",
  celtic8: "iso885914",
  isoceltic: "iso885914",

  tis6200: "tis620",
  tis62025291: "tis620",
  tis62025330: "tis620",

  10000: "macroman",
  10006: "macgreek",
  10007: "maccyrillic",
  10079: "maciceland",
  10081: "macturkish",

  cspc8codepage437: "cp437",
  cspc775baltic: "cp775",
  cspc850multilingual: "cp850",
  cspcp852: "cp852",
  cspc862latinhebrew: "cp862",
  cpgr: "cp869",

  msee: "cp1250",
  mscyrl: "cp1251",
  msansi: "cp1252",
  msgreek: "cp1253",
  msturk: "cp1254",
  mshebr: "cp1255",
  msarab: "cp1256",
  winbaltrim: "cp1257",

  cp20866: "koi8r",
  20866: "koi8r",
  ibm878: "koi8r",
  cskoi8r: "koi8r",

  cp21866: "koi8u",
  21866: "koi8u",
  ibm1168: "koi8u",

  strk10482002: "rk1048",

  tcvn5712: "tcvn",
  tcvn57121: "tcvn",

  gb198880: "iso646cn",
  cn: "iso646cn",

  csiso14jisc6220ro: "iso646jp",
  jisc62201969ro: "iso646jp",
  jp: "iso646jp",

  cshproman8: "hproman8",
  r8: "hproman8",
  roman8: "hproman8",
  xroman8: "hproman8",
  ibm1051: "hproman8",

  mac: "macintosh",
  csmacintosh: "macintosh"
}


/***/ }),

/***/ 70915:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

var Buffer = (__nccwpck_require__(12803).Buffer)

// Note: UTF16-LE (or UCS2) codec is Node.js native. See encodings/internal.js

// == UTF16-BE codec. ==========================================================

exports.utf16be = Utf16BECodec
function Utf16BECodec () {
}

Utf16BECodec.prototype.encoder = Utf16BEEncoder
Utf16BECodec.prototype.decoder = Utf16BEDecoder
Utf16BECodec.prototype.bomAware = true

// -- Encoding

function Utf16BEEncoder () {
}

Utf16BEEncoder.prototype.write = function (str) {
  var buf = Buffer.from(str, "ucs2")
  for (var i = 0; i < buf.length; i += 2) {
    var tmp = buf[i]; buf[i] = buf[i + 1]; buf[i + 1] = tmp
  }
  return buf
}

Utf16BEEncoder.prototype.end = function () {
}

// -- Decoding

function Utf16BEDecoder () {
  this.overflowByte = -1
}

Utf16BEDecoder.prototype.write = function (buf) {
  if (buf.length == 0) { return "" }

  var buf2 = Buffer.alloc(buf.length + 1)
  var i = 0; var j = 0

  if (this.overflowByte !== -1) {
    buf2[0] = buf[0]
    buf2[1] = this.overflowByte
    i = 1; j = 2
  }

  for (; i < buf.length - 1; i += 2, j += 2) {
    buf2[j] = buf[i + 1]
    buf2[j + 1] = buf[i]
  }

  this.overflowByte = (i == buf.length - 1) ? buf[buf.length - 1] : -1

  return buf2.slice(0, j).toString("ucs2")
}

Utf16BEDecoder.prototype.end = function () {
  this.overflowByte = -1
}

// == UTF-16 codec =============================================================
// Decoder chooses automatically from UTF-16LE and UTF-16BE using BOM and space-based heuristic.
// Defaults to UTF-16LE, as it's prevalent and default in Node.
// http://en.wikipedia.org/wiki/UTF-16 and http://encoding.spec.whatwg.org/#utf-16le
// Decoder default can be changed: iconv.decode(buf, 'utf16', {defaultEncoding: 'utf-16be'});

// Encoder uses UTF-16LE and prepends BOM (which can be overridden with addBOM: false).

exports.utf16 = Utf16Codec
function Utf16Codec (codecOptions, iconv) {
  this.iconv = iconv
}

Utf16Codec.prototype.encoder = Utf16Encoder
Utf16Codec.prototype.decoder = Utf16Decoder

// -- Encoding (pass-through)

function Utf16Encoder (options, codec) {
  options = options || {}
  if (options.addBOM === undefined) { options.addBOM = true }
  this.encoder = codec.iconv.getEncoder("utf-16le", options)
}

Utf16Encoder.prototype.write = function (str) {
  return this.encoder.write(str)
}

Utf16Encoder.prototype.end = function () {
  return this.encoder.end()
}

// -- Decoding

function Utf16Decoder (options, codec) {
  this.decoder = null
  this.initialBufs = []
  this.initialBufsLen = 0

  this.options = options || {}
  this.iconv = codec.iconv
}

Utf16Decoder.prototype.write = function (buf) {
  if (!this.decoder) {
    // Codec is not chosen yet. Accumulate initial bytes.
    this.initialBufs.push(buf)
    this.initialBufsLen += buf.length

    if (this.initialBufsLen < 16) // We need more bytes to use space heuristic (see below)
    { return "" }

    // We have enough bytes -> detect endianness.
    var encoding = detectEncoding(this.initialBufs, this.options.defaultEncoding)
    this.decoder = this.iconv.getDecoder(encoding, this.options)

    var resStr = ""
    for (var i = 0; i < this.initialBufs.length; i++) { resStr += this.decoder.write(this.initialBufs[i]) }

    this.initialBufs.length = this.initialBufsLen = 0
    return resStr
  }

  return this.decoder.write(buf)
}

Utf16Decoder.prototype.end = function () {
  if (!this.decoder) {
    var encoding = detectEncoding(this.initialBufs, this.options.defaultEncoding)
    this.decoder = this.iconv.getDecoder(encoding, this.options)

    var resStr = ""
    for (var i = 0; i < this.initialBufs.length; i++) { resStr += this.decoder.write(this.initialBufs[i]) }

    var trail = this.decoder.end()
    if (trail) { resStr += trail }

    this.initialBufs.length = this.initialBufsLen = 0
    return resStr
  }
  return this.decoder.end()
}

function detectEncoding (bufs, defaultEncoding) {
  var b = []
  var charsProcessed = 0
  // Number of ASCII chars when decoded as LE or BE.
  var asciiCharsLE = 0
  var asciiCharsBE = 0

  outerLoop:
  for (var i = 0; i < bufs.length; i++) {
    var buf = bufs[i]
    for (var j = 0; j < buf.length; j++) {
      b.push(buf[j])
      if (b.length === 2) {
        if (charsProcessed === 0) {
          // Check BOM first.
          if (b[0] === 0xFF && b[1] === 0xFE) return "utf-16le"
          if (b[0] === 0xFE && b[1] === 0xFF) return "utf-16be"
        }

        if (b[0] === 0 && b[1] !== 0) asciiCharsBE++
        if (b[0] !== 0 && b[1] === 0) asciiCharsLE++

        b.length = 0
        charsProcessed++

        if (charsProcessed >= 100) {
          break outerLoop
        }
      }
    }
  }

  // Make decisions.
  // Most of the time, the content has ASCII chars (U+00**), but the opposite (U+**00) is uncommon.
  // So, we count ASCII as if it was LE or BE, and decide from that.
  if (asciiCharsBE > asciiCharsLE) return "utf-16be"
  if (asciiCharsBE < asciiCharsLE) return "utf-16le"

  // Couldn't decide (likely all zeros or not enough data).
  return defaultEncoding || "utf-16le"
}


/***/ }),

/***/ 37957:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


var Buffer = (__nccwpck_require__(12803).Buffer)

// == UTF32-LE/BE codec. ==========================================================

exports._utf32 = Utf32Codec

function Utf32Codec (codecOptions, iconv) {
  this.iconv = iconv
  this.bomAware = true
  this.isLE = codecOptions.isLE
}

exports.utf32le = { type: "_utf32", isLE: true }
exports.utf32be = { type: "_utf32", isLE: false }

// Aliases
exports.ucs4le = "utf32le"
exports.ucs4be = "utf32be"

Utf32Codec.prototype.encoder = Utf32Encoder
Utf32Codec.prototype.decoder = Utf32Decoder

// -- Encoding

function Utf32Encoder (options, codec) {
  this.isLE = codec.isLE
  this.highSurrogate = 0
}

Utf32Encoder.prototype.write = function (str) {
  var src = Buffer.from(str, "ucs2")
  var dst = Buffer.alloc(src.length * 2)
  var write32 = this.isLE ? dst.writeUInt32LE : dst.writeUInt32BE
  var offset = 0

  for (var i = 0; i < src.length; i += 2) {
    var code = src.readUInt16LE(i)
    var isHighSurrogate = (code >= 0xD800 && code < 0xDC00)
    var isLowSurrogate = (code >= 0xDC00 && code < 0xE000)

    if (this.highSurrogate) {
      if (isHighSurrogate || !isLowSurrogate) {
        // There shouldn't be two high surrogates in a row, nor a high surrogate which isn't followed by a low
        // surrogate. If this happens, keep the pending high surrogate as a stand-alone semi-invalid character
        // (technically wrong, but expected by some applications, like Windows file names).
        write32.call(dst, this.highSurrogate, offset)
        offset += 4
      } else {
        // Create 32-bit value from high and low surrogates;
        var codepoint = (((this.highSurrogate - 0xD800) << 10) | (code - 0xDC00)) + 0x10000

        write32.call(dst, codepoint, offset)
        offset += 4
        this.highSurrogate = 0

        continue
      }
    }

    if (isHighSurrogate) { this.highSurrogate = code } else {
      // Even if the current character is a low surrogate, with no previous high surrogate, we'll
      // encode it as a semi-invalid stand-alone character for the same reasons expressed above for
      // unpaired high surrogates.
      write32.call(dst, code, offset)
      offset += 4
      this.highSurrogate = 0
    }
  }

  if (offset < dst.length) { dst = dst.slice(0, offset) }

  return dst
}

Utf32Encoder.prototype.end = function () {
  // Treat any leftover high surrogate as a semi-valid independent character.
  if (!this.highSurrogate) { return }

  var buf = Buffer.alloc(4)

  if (this.isLE) { buf.writeUInt32LE(this.highSurrogate, 0) } else { buf.writeUInt32BE(this.highSurrogate, 0) }

  this.highSurrogate = 0

  return buf
}

// -- Decoding

function Utf32Decoder (options, codec) {
  this.isLE = codec.isLE
  this.badChar = codec.iconv.defaultCharUnicode.charCodeAt(0)
  this.overflow = []
}

Utf32Decoder.prototype.write = function (src) {
  if (src.length === 0) { return "" }

  var i = 0
  var codepoint = 0
  var dst = Buffer.alloc(src.length + 4)
  var offset = 0
  var isLE = this.isLE
  var overflow = this.overflow
  var badChar = this.badChar

  if (overflow.length > 0) {
    for (; i < src.length && overflow.length < 4; i++) { overflow.push(src[i]) }

    if (overflow.length === 4) {
      // NOTE: codepoint is a signed int32 and can be negative.
      // NOTE: We copied this block from below to help V8 optimize it (it works with array, not buffer).
      if (isLE) {
        codepoint = overflow[i] | (overflow[i + 1] << 8) | (overflow[i + 2] << 16) | (overflow[i + 3] << 24)
      } else {
        codepoint = overflow[i + 3] | (overflow[i + 2] << 8) | (overflow[i + 1] << 16) | (overflow[i] << 24)
      }
      overflow.length = 0

      offset = _writeCodepoint(dst, offset, codepoint, badChar)
    }
  }

  // Main loop. Should be as optimized as possible.
  for (; i < src.length - 3; i += 4) {
    // NOTE: codepoint is a signed int32 and can be negative.
    if (isLE) {
      codepoint = src[i] | (src[i + 1] << 8) | (src[i + 2] << 16) | (src[i + 3] << 24)
    } else {
      codepoint = src[i + 3] | (src[i + 2] << 8) | (src[i + 1] << 16) | (src[i] << 24)
    }
    offset = _writeCodepoint(dst, offset, codepoint, badChar)
  }

  // Keep overflowing bytes.
  for (; i < src.length; i++) {
    overflow.push(src[i])
  }

  return dst.slice(0, offset).toString("ucs2")
}

function _writeCodepoint (dst, offset, codepoint, badChar) {
  // NOTE: codepoint is signed int32 and can be negative. We keep it that way to help V8 with optimizations.
  if (codepoint < 0 || codepoint > 0x10FFFF) {
    // Not a valid Unicode codepoint
    codepoint = badChar
  }

  // Ephemeral Planes: Write high surrogate.
  if (codepoint >= 0x10000) {
    codepoint -= 0x10000

    var high = 0xD800 | (codepoint >> 10)
    dst[offset++] = high & 0xff
    dst[offset++] = high >> 8

    // Low surrogate is written below.
    var codepoint = 0xDC00 | (codepoint & 0x3FF)
  }

  // Write BMP char or low surrogate.
  dst[offset++] = codepoint & 0xff
  dst[offset++] = codepoint >> 8

  return offset
};

Utf32Decoder.prototype.end = function () {
  this.overflow.length = 0
}

// == UTF-32 Auto codec =============================================================
// Decoder chooses automatically from UTF-32LE and UTF-32BE using BOM and space-based heuristic.
// Defaults to UTF-32LE. http://en.wikipedia.org/wiki/UTF-32
// Encoder/decoder default can be changed: iconv.decode(buf, 'utf32', {defaultEncoding: 'utf-32be'});

// Encoder prepends BOM (which can be overridden with (addBOM: false}).

exports.utf32 = Utf32AutoCodec
exports.ucs4 = "utf32"

function Utf32AutoCodec (options, iconv) {
  this.iconv = iconv
}

Utf32AutoCodec.prototype.encoder = Utf32AutoEncoder
Utf32AutoCodec.prototype.decoder = Utf32AutoDecoder

// -- Encoding

function Utf32AutoEncoder (options, codec) {
  options = options || {}

  if (options.addBOM === undefined) {
    options.addBOM = true
  }

  this.encoder = codec.iconv.getEncoder(options.defaultEncoding || "utf-32le", options)
}

Utf32AutoEncoder.prototype.write = function (str) {
  return this.encoder.write(str)
}

Utf32AutoEncoder.prototype.end = function () {
  return this.encoder.end()
}

// -- Decoding

function Utf32AutoDecoder (options, codec) {
  this.decoder = null
  this.initialBufs = []
  this.initialBufsLen = 0
  this.options = options || {}
  this.iconv = codec.iconv
}

Utf32AutoDecoder.prototype.write = function (buf) {
  if (!this.decoder) {
    // Codec is not chosen yet. Accumulate initial bytes.
    this.initialBufs.push(buf)
    this.initialBufsLen += buf.length

    if (this.initialBufsLen < 32) // We need more bytes to use space heuristic (see below)
    { return "" }

    // We have enough bytes -> detect endianness.
    var encoding = detectEncoding(this.initialBufs, this.options.defaultEncoding)
    this.decoder = this.iconv.getDecoder(encoding, this.options)

    var resStr = ""
    for (var i = 0; i < this.initialBufs.length; i++) { resStr += this.decoder.write(this.initialBufs[i]) }

    this.initialBufs.length = this.initialBufsLen = 0
    return resStr
  }

  return this.decoder.write(buf)
}

Utf32AutoDecoder.prototype.end = function () {
  if (!this.decoder) {
    var encoding = detectEncoding(this.initialBufs, this.options.defaultEncoding)
    this.decoder = this.iconv.getDecoder(encoding, this.options)

    var resStr = ""
    for (var i = 0; i < this.initialBufs.length; i++) { resStr += this.decoder.write(this.initialBufs[i]) }

    var trail = this.decoder.end()
    if (trail) { resStr += trail }

    this.initialBufs.length = this.initialBufsLen = 0
    return resStr
  }

  return this.decoder.end()
}

function detectEncoding (bufs, defaultEncoding) {
  var b = []
  var charsProcessed = 0
  var invalidLE = 0; var invalidBE = 0   // Number of invalid chars when decoded as LE or BE.
  var bmpCharsLE = 0; var bmpCharsBE = 0 // Number of BMP chars when decoded as LE or BE.

  outerLoop:
  for (var i = 0; i < bufs.length; i++) {
    var buf = bufs[i]
    for (var j = 0; j < buf.length; j++) {
      b.push(buf[j])
      if (b.length === 4) {
        if (charsProcessed === 0) {
          // Check BOM first.
          if (b[0] === 0xFF && b[1] === 0xFE && b[2] === 0 && b[3] === 0) {
            return "utf-32le"
          }
          if (b[0] === 0 && b[1] === 0 && b[2] === 0xFE && b[3] === 0xFF) {
            return "utf-32be"
          }
        }

        if (b[0] !== 0 || b[1] > 0x10) invalidBE++
        if (b[3] !== 0 || b[2] > 0x10) invalidLE++

        if (b[0] === 0 && b[1] === 0 && (b[2] !== 0 || b[3] !== 0)) bmpCharsBE++
        if ((b[0] !== 0 || b[1] !== 0) && b[2] === 0 && b[3] === 0) bmpCharsLE++

        b.length = 0
        charsProcessed++

        if (charsProcessed >= 100) {
          break outerLoop
        }
      }
    }
  }

  // Make decisions.
  if (bmpCharsBE - invalidBE > bmpCharsLE - invalidLE) return "utf-32be"
  if (bmpCharsBE - invalidBE < bmpCharsLE - invalidLE) return "utf-32le"

  // Couldn't decide (likely all zeros or not enough data).
  return defaultEncoding || "utf-32le"
}


/***/ }),

/***/ 30663:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

var Buffer = (__nccwpck_require__(12803).Buffer)

// UTF-7 codec, according to https://tools.ietf.org/html/rfc2152
// See also below a UTF-7-IMAP codec, according to http://tools.ietf.org/html/rfc3501#section-5.1.3

exports.utf7 = Utf7Codec
exports.unicode11utf7 = "utf7" // Alias UNICODE-1-1-UTF-7
function Utf7Codec (codecOptions, iconv) {
  this.iconv = iconv
};

Utf7Codec.prototype.encoder = Utf7Encoder
Utf7Codec.prototype.decoder = Utf7Decoder
Utf7Codec.prototype.bomAware = true

// -- Encoding

// Why scape ()?./?
// eslint-disable-next-line no-useless-escape
var nonDirectChars = /[^A-Za-z0-9'\(\),-\.\/:\? \n\r\t]+/g

function Utf7Encoder (options, codec) {
  this.iconv = codec.iconv
}

Utf7Encoder.prototype.write = function (str) {
  // Naive implementation.
  // Non-direct chars are encoded as "+<base64>-"; single "+" char is encoded as "+-".
  return Buffer.from(str.replace(nonDirectChars, function (chunk) {
    return "+" + (chunk === "+"
      ? ""
      : this.iconv.encode(chunk, "utf16-be").toString("base64").replace(/=+$/, "")) +
            "-"
  }.bind(this)))
}

Utf7Encoder.prototype.end = function () {
}

// -- Decoding

function Utf7Decoder (options, codec) {
  this.iconv = codec.iconv
  this.inBase64 = false
  this.base64Accum = ""
}

// Why scape /?
// eslint-disable-next-line no-useless-escape
var base64Regex = /[A-Za-z0-9\/+]/
var base64Chars = []
for (var i = 0; i < 256; i++) { base64Chars[i] = base64Regex.test(String.fromCharCode(i)) }

var plusChar = "+".charCodeAt(0)
var minusChar = "-".charCodeAt(0)
var andChar = "&".charCodeAt(0)

Utf7Decoder.prototype.write = function (buf) {
  var res = ""; var lastI = 0
  var inBase64 = this.inBase64
  var base64Accum = this.base64Accum

  // The decoder is more involved as we must handle chunks in stream.

  for (var i = 0; i < buf.length; i++) {
    if (!inBase64) { // We're in direct mode.
      // Write direct chars until '+'
      if (buf[i] == plusChar) {
        res += this.iconv.decode(buf.slice(lastI, i), "ascii") // Write direct chars.
        lastI = i + 1
        inBase64 = true
      }
    } else { // We decode base64.
      if (!base64Chars[buf[i]]) { // Base64 ended.
        if (i == lastI && buf[i] == minusChar) { // "+-" -> "+"
          res += "+"
        } else {
          var b64str = base64Accum + this.iconv.decode(buf.slice(lastI, i), "ascii")
          res += this.iconv.decode(Buffer.from(b64str, "base64"), "utf16-be")
        }

        if (buf[i] != minusChar) // Minus is absorbed after base64.
        { i-- }

        lastI = i + 1
        inBase64 = false
        base64Accum = ""
      }
    }
  }

  if (!inBase64) {
    res += this.iconv.decode(buf.slice(lastI), "ascii") // Write direct chars.
  } else {
    var b64str = base64Accum + this.iconv.decode(buf.slice(lastI), "ascii")

    var canBeDecoded = b64str.length - (b64str.length % 8) // Minimal chunk: 2 quads -> 2x3 bytes -> 3 chars.
    base64Accum = b64str.slice(canBeDecoded) // The rest will be decoded in future.
    b64str = b64str.slice(0, canBeDecoded)

    res += this.iconv.decode(Buffer.from(b64str, "base64"), "utf16-be")
  }

  this.inBase64 = inBase64
  this.base64Accum = base64Accum

  return res
}

Utf7Decoder.prototype.end = function () {
  var res = ""
  if (this.inBase64 && this.base64Accum.length > 0) { res = this.iconv.decode(Buffer.from(this.base64Accum, "base64"), "utf16-be") }

  this.inBase64 = false
  this.base64Accum = ""
  return res
}

// UTF-7-IMAP codec.
// RFC3501 Sec. 5.1.3 Modified UTF-7 (http://tools.ietf.org/html/rfc3501#section-5.1.3)
// Differences:
//  * Base64 part is started by "&" instead of "+"
//  * Direct characters are 0x20-0x7E, except "&" (0x26)
//  * In Base64, "," is used instead of "/"
//  * Base64 must not be used to represent direct characters.
//  * No implicit shift back from Base64 (should always end with '-')
//  * String must end in non-shifted position.
//  * "-&" while in base64 is not allowed.

exports.utf7imap = Utf7IMAPCodec
function Utf7IMAPCodec (codecOptions, iconv) {
  this.iconv = iconv
};

Utf7IMAPCodec.prototype.encoder = Utf7IMAPEncoder
Utf7IMAPCodec.prototype.decoder = Utf7IMAPDecoder
Utf7IMAPCodec.prototype.bomAware = true

// -- Encoding

function Utf7IMAPEncoder (options, codec) {
  this.iconv = codec.iconv
  this.inBase64 = false
  this.base64Accum = Buffer.alloc(6)
  this.base64AccumIdx = 0
}

Utf7IMAPEncoder.prototype.write = function (str) {
  var inBase64 = this.inBase64
  var base64Accum = this.base64Accum
  var base64AccumIdx = this.base64AccumIdx
  var buf = Buffer.alloc(str.length * 5 + 10); var bufIdx = 0

  for (var i = 0; i < str.length; i++) {
    var uChar = str.charCodeAt(i)
    if (uChar >= 0x20 && uChar <= 0x7E) { // Direct character or '&'.
      if (inBase64) {
        if (base64AccumIdx > 0) {
          bufIdx += buf.write(base64Accum.slice(0, base64AccumIdx).toString("base64").replace(/\//g, ",").replace(/=+$/, ""), bufIdx)
          base64AccumIdx = 0
        }

        buf[bufIdx++] = minusChar // Write '-', then go to direct mode.
        inBase64 = false
      }

      if (!inBase64) {
        buf[bufIdx++] = uChar // Write direct character

        if (uChar === andChar)  // Ampersand -> '&-'
        { buf[bufIdx++] = minusChar }
      }
    } else { // Non-direct character
      if (!inBase64) {
        buf[bufIdx++] = andChar // Write '&', then go to base64 mode.
        inBase64 = true
      }
      if (inBase64) {
        base64Accum[base64AccumIdx++] = uChar >> 8
        base64Accum[base64AccumIdx++] = uChar & 0xFF

        if (base64AccumIdx == base64Accum.length) {
          bufIdx += buf.write(base64Accum.toString("base64").replace(/\//g, ","), bufIdx)
          base64AccumIdx = 0
        }
      }
    }
  }

  this.inBase64 = inBase64
  this.base64AccumIdx = base64AccumIdx

  return buf.slice(0, bufIdx)
}

Utf7IMAPEncoder.prototype.end = function () {
  var buf = Buffer.alloc(10); var bufIdx = 0
  if (this.inBase64) {
    if (this.base64AccumIdx > 0) {
      bufIdx += buf.write(this.base64Accum.slice(0, this.base64AccumIdx).toString("base64").replace(/\//g, ",").replace(/=+$/, ""), bufIdx)
      this.base64AccumIdx = 0
    }

    buf[bufIdx++] = minusChar // Write '-', then go to direct mode.
    this.inBase64 = false
  }

  return buf.slice(0, bufIdx)
}

// -- Decoding

function Utf7IMAPDecoder (options, codec) {
  this.iconv = codec.iconv
  this.inBase64 = false
  this.base64Accum = ""
}

var base64IMAPChars = base64Chars.slice()
base64IMAPChars[",".charCodeAt(0)] = true

Utf7IMAPDecoder.prototype.write = function (buf) {
  var res = ""; var lastI = 0
  var inBase64 = this.inBase64
  var base64Accum = this.base64Accum

  // The decoder is more involved as we must handle chunks in stream.
  // It is forgiving, closer to standard UTF-7 (for example, '-' is optional at the end).

  for (var i = 0; i < buf.length; i++) {
    if (!inBase64) { // We're in direct mode.
      // Write direct chars until '&'
      if (buf[i] == andChar) {
        res += this.iconv.decode(buf.slice(lastI, i), "ascii") // Write direct chars.
        lastI = i + 1
        inBase64 = true
      }
    } else { // We decode base64.
      if (!base64IMAPChars[buf[i]]) { // Base64 ended.
        if (i == lastI && buf[i] == minusChar) { // "&-" -> "&"
          res += "&"
        } else {
          var b64str = base64Accum + this.iconv.decode(buf.slice(lastI, i), "ascii").replace(/,/g, "/")
          res += this.iconv.decode(Buffer.from(b64str, "base64"), "utf16-be")
        }

        if (buf[i] != minusChar) // Minus may be absorbed after base64.
        { i-- }

        lastI = i + 1
        inBase64 = false
        base64Accum = ""
      }
    }
  }

  if (!inBase64) {
    res += this.iconv.decode(buf.slice(lastI), "ascii") // Write direct chars.
  } else {
    var b64str = base64Accum + this.iconv.decode(buf.slice(lastI), "ascii").replace(/,/g, "/")

    var canBeDecoded = b64str.length - (b64str.length % 8) // Minimal chunk: 2 quads -> 2x3 bytes -> 3 chars.
    base64Accum = b64str.slice(canBeDecoded) // The rest will be decoded in future.
    b64str = b64str.slice(0, canBeDecoded)

    res += this.iconv.decode(Buffer.from(b64str, "base64"), "utf16-be")
  }

  this.inBase64 = inBase64
  this.base64Accum = base64Accum

  return res
}

Utf7IMAPDecoder.prototype.end = function () {
  var res = ""
  if (this.inBase64 && this.base64Accum.length > 0) { res = this.iconv.decode(Buffer.from(this.base64Accum, "base64"), "utf16-be") }

  this.inBase64 = false
  this.base64Accum = ""
  return res
}


/***/ }),

/***/ 93226:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


var BOMChar = "\uFEFF"

exports.PrependBOM = PrependBOMWrapper
function PrependBOMWrapper (encoder, options) {
  this.encoder = encoder
  this.addBOM = true
}

PrependBOMWrapper.prototype.write = function (str) {
  if (this.addBOM) {
    str = BOMChar + str
    this.addBOM = false
  }

  return this.encoder.write(str)
}

PrependBOMWrapper.prototype.end = function () {
  return this.encoder.end()
}

// ------------------------------------------------------------------------------

exports.StripBOM = StripBOMWrapper
function StripBOMWrapper (decoder, options) {
  this.decoder = decoder
  this.pass = false
  this.options = options || {}
}

StripBOMWrapper.prototype.write = function (buf) {
  var res = this.decoder.write(buf)
  if (this.pass || !res) { return res }

  if (res[0] === BOMChar) {
    res = res.slice(1)
    if (typeof this.options.stripBOM === "function") { this.options.stripBOM() }
  }

  this.pass = true
  return res
}

StripBOMWrapper.prototype.end = function () {
  return this.decoder.end()
}


/***/ }),

/***/ 61304:
/***/ ((module) => {

"use strict";


var hasOwn = typeof Object.hasOwn === "undefined" ? Function.call.bind(Object.prototype.hasOwnProperty) : Object.hasOwn

function mergeModules (target, module) {
  for (var key in module) {
    if (hasOwn(module, key)) {
      target[key] = module[key]
    }
  }
}

module.exports = mergeModules


/***/ }),

/***/ 54820:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


var Buffer = (__nccwpck_require__(12803).Buffer)

var bomHandling = __nccwpck_require__(93226)
var mergeModules = __nccwpck_require__(61304)
var iconv = module.exports

// All codecs and aliases are kept here, keyed by encoding name/alias.
// They are lazy loaded in `iconv.getCodec` from `encodings/index.js`.
// Cannot initialize with { __proto__: null } because Boolean({ __proto__: null }) === true
iconv.encodings = null

// Characters emitted in case of error.
iconv.defaultCharUnicode = "ÔøΩ"
iconv.defaultCharSingleByte = "?"

// Public API.
iconv.encode = function encode (str, encoding, options) {
  str = "" + (str || "") // Ensure string.

  var encoder = iconv.getEncoder(encoding, options)

  var res = encoder.write(str)
  var trail = encoder.end()

  return (trail && trail.length > 0) ? Buffer.concat([res, trail]) : res
}

iconv.decode = function decode (buf, encoding, options) {
  if (typeof buf === "string") {
    if (!iconv.skipDecodeWarning) {
      console.error("Iconv-lite warning: decode()-ing strings is deprecated. Refer to https://github.com/ashtuchkin/iconv-lite/wiki/Use-Buffers-when-decoding")
      iconv.skipDecodeWarning = true
    }

    buf = Buffer.from("" + (buf || ""), "binary") // Ensure buffer.
  }

  var decoder = iconv.getDecoder(encoding, options)

  var res = decoder.write(buf)
  var trail = decoder.end()

  return trail ? (res + trail) : res
}

iconv.encodingExists = function encodingExists (enc) {
  try {
    iconv.getCodec(enc)
    return true
  } catch (e) {
    return false
  }
}

// Legacy aliases to convert functions
iconv.toEncoding = iconv.encode
iconv.fromEncoding = iconv.decode

// Search for a codec in iconv.encodings. Cache codec data in iconv._codecDataCache.
iconv._codecDataCache = { __proto__: null }

iconv.getCodec = function getCodec (encoding) {
  if (!iconv.encodings) {
    var raw = __nccwpck_require__(3841)
    // TODO: In future versions when old nodejs support is removed can use object.assign
    iconv.encodings = { __proto__: null } // Initialize as empty object.
    mergeModules(iconv.encodings, raw)
  }

  // Canonicalize encoding name: strip all non-alphanumeric chars and appended year.
  var enc = iconv._canonicalizeEncoding(encoding)

  // Traverse iconv.encodings to find actual codec.
  var codecOptions = {}
  while (true) {
    var codec = iconv._codecDataCache[enc]

    if (codec) { return codec }

    var codecDef = iconv.encodings[enc]

    switch (typeof codecDef) {
      case "string": // Direct alias to other encoding.
        enc = codecDef
        break

      case "object": // Alias with options. Can be layered.
        for (var key in codecDef) { codecOptions[key] = codecDef[key] }

        if (!codecOptions.encodingName) { codecOptions.encodingName = enc }

        enc = codecDef.type
        break

      case "function": // Codec itself.
        if (!codecOptions.encodingName) { codecOptions.encodingName = enc }

        // The codec function must load all tables and return object with .encoder and .decoder methods.
        // It'll be called only once (for each different options object).
        //
        codec = new codecDef(codecOptions, iconv)

        iconv._codecDataCache[codecOptions.encodingName] = codec // Save it to be reused later.
        return codec

      default:
        throw new Error("Encoding not recognized: '" + encoding + "' (searched as: '" + enc + "')")
    }
  }
}

iconv._canonicalizeEncoding = function (encoding) {
  // Canonicalize encoding name: strip all non-alphanumeric chars and appended year.
  return ("" + encoding).toLowerCase().replace(/:\d{4}$|[^0-9a-z]/g, "")
}

iconv.getEncoder = function getEncoder (encoding, options) {
  var codec = iconv.getCodec(encoding)
  var encoder = new codec.encoder(options, codec)

  if (codec.bomAware && options && options.addBOM) { encoder = new bomHandling.PrependBOM(encoder, options) }

  return encoder
}

iconv.getDecoder = function getDecoder (encoding, options) {
  var codec = iconv.getCodec(encoding)
  var decoder = new codec.decoder(options, codec)

  if (codec.bomAware && !(options && options.stripBOM === false)) { decoder = new bomHandling.StripBOM(decoder, options) }

  return decoder
}

// Streaming API
// NOTE: Streaming API naturally depends on 'stream' module from Node.js. Unfortunately in browser environments this module can add
// up to 100Kb to the output bundle. To avoid unnecessary code bloat, we don't enable Streaming API in browser by default.
// If you would like to enable it explicitly, please add the following code to your app:
// > iconv.enableStreamingAPI(require('stream'));
iconv.enableStreamingAPI = function enableStreamingAPI (streamModule) {
  if (iconv.supportsStreams) { return }

  // Dependency-inject stream module to create IconvLite stream classes.
  var streams = __nccwpck_require__(52649)(streamModule)

  // Not public API yet, but expose the stream classes.
  iconv.IconvLiteEncoderStream = streams.IconvLiteEncoderStream
  iconv.IconvLiteDecoderStream = streams.IconvLiteDecoderStream

  // Streaming API.
  iconv.encodeStream = function encodeStream (encoding, options) {
    return new iconv.IconvLiteEncoderStream(iconv.getEncoder(encoding, options), options)
  }

  iconv.decodeStream = function decodeStream (encoding, options) {
    return new iconv.IconvLiteDecoderStream(iconv.getDecoder(encoding, options), options)
  }

  iconv.supportsStreams = true
}

// Enable Streaming API automatically if 'stream' module is available and non-empty (the majority of environments).
var streamModule
try {
  streamModule = __nccwpck_require__(2203)
} catch (e) {}

if (streamModule && streamModule.Transform) {
  iconv.enableStreamingAPI(streamModule)
} else {
  // In rare cases where 'stream' module is not available by default, throw a helpful exception.
  iconv.encodeStream = iconv.decodeStream = function () {
    throw new Error("iconv-lite Streaming API is not enabled. Use iconv.enableStreamingAPI(require('stream')); to enable it.")
  }
}

// Some environments, such as browsers, may not load JavaScript files as UTF-8
// eslint-disable-next-line no-constant-condition
if (false) {}


/***/ }),

/***/ 52649:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


var Buffer = (__nccwpck_require__(12803).Buffer)

// NOTE: Due to 'stream' module being pretty large (~100Kb, significant in browser environments),
// we opt to dependency-inject it instead of creating a hard dependency.
module.exports = function (streamModule) {
  var Transform = streamModule.Transform

  // == Encoder stream =======================================================

  function IconvLiteEncoderStream (conv, options) {
    this.conv = conv
    options = options || {}
    options.decodeStrings = false // We accept only strings, so we don't need to decode them.
    Transform.call(this, options)
  }

  IconvLiteEncoderStream.prototype = Object.create(Transform.prototype, {
    constructor: { value: IconvLiteEncoderStream }
  })

  IconvLiteEncoderStream.prototype._transform = function (chunk, encoding, done) {
    if (typeof chunk !== "string") {
      return done(new Error("Iconv encoding stream needs strings as its input."))
    }

    try {
      var res = this.conv.write(chunk)
      if (res && res.length) this.push(res)
      done()
    } catch (e) {
      done(e)
    }
  }

  IconvLiteEncoderStream.prototype._flush = function (done) {
    try {
      var res = this.conv.end()
      if (res && res.length) this.push(res)
      done()
    } catch (e) {
      done(e)
    }
  }

  IconvLiteEncoderStream.prototype.collect = function (cb) {
    var chunks = []
    this.on("error", cb)
    this.on("data", function (chunk) { chunks.push(chunk) })
    this.on("end", function () {
      cb(null, Buffer.concat(chunks))
    })
    return this
  }

  // == Decoder stream =======================================================

  function IconvLiteDecoderStream (conv, options) {
    this.conv = conv
    options = options || {}
    options.encoding = this.encoding = "utf8" // We output strings.
    Transform.call(this, options)
  }

  IconvLiteDecoderStream.prototype = Object.create(Transform.prototype, {
    constructor: { value: IconvLiteDecoderStream }
  })

  IconvLiteDecoderStream.prototype._transform = function (chunk, encoding, done) {
    if (!Buffer.isBuffer(chunk) && !(chunk instanceof Uint8Array)) { return done(new Error("Iconv decoding stream needs buffers as its input.")) }
    try {
      var res = this.conv.write(chunk)
      if (res && res.length) this.push(res, this.encoding)
      done()
    } catch (e) {
      done(e)
    }
  }

  IconvLiteDecoderStream.prototype._flush = function (done) {
    try {
      var res = this.conv.end()
      if (res && res.length) this.push(res, this.encoding)
      done()
    } catch (e) {
      done(e)
    }
  }

  IconvLiteDecoderStream.prototype.collect = function (cb) {
    var res = ""
    this.on("error", cb)
    this.on("data", function (chunk) { res += chunk })
    this.on("end", function () {
      cb(null, res)
    })
    return this
  }

  return {
    IconvLiteEncoderStream: IconvLiteEncoderStream,
    IconvLiteDecoderStream: IconvLiteDecoderStream
  }
}


/***/ }),

/***/ 83154:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


// based on code from Brian White @mscdex mariasql library - https://github.com/mscdex/node-mariasql/blob/master/lib/Client.js#L272-L332
// License: https://github.com/mscdex/node-mariasql/blob/master/LICENSE

const RE_PARAM = /(?:\?)|(?::(\d+|(?:[a-zA-Z][a-zA-Z0-9_]*)))/g,
DQUOTE = 34,
SQUOTE = 39,
BSLASH = 92;

function parse(query) {
  let ppos = RE_PARAM.exec(query);
  let curpos = 0;
  let start = 0;
  let end;
  const parts = [];
  let inQuote = false;
  let escape = false;
  let qchr;
  const tokens = [];
  let qcnt = 0;
  let lastTokenEndPos = 0;
  let i;

  if (ppos) {
    do {
      for (i=curpos,end=ppos.index; i<end; ++i) {
        let chr = query.charCodeAt(i);
        if (chr === BSLASH)
        escape = !escape;
        else {
          if (escape) {
            escape = false;
            continue;
          }
          if (inQuote && chr === qchr) {
            if (query.charCodeAt(i + 1) === qchr) {
              // quote escaped via "" or ''
              ++i;
              continue;
            }
            inQuote = false;
          } else if (chr === DQUOTE || chr === SQUOTE) {
            inQuote = true;
            qchr = chr;
          }
        }
      }
      if (!inQuote) {
        parts.push(query.substring(start, end));
        tokens.push(ppos[0].length === 1 ? qcnt++ : ppos[1]);
        start = end + ppos[0].length;
        lastTokenEndPos = start;
      }
      curpos = end + ppos[0].length;
    } while (ppos = RE_PARAM.exec(query));

    if (tokens.length) {
      if (curpos < query.length) {
        parts.push(query.substring(lastTokenEndPos));
      }
      return [parts, tokens];
    }
  }
  return [query];
};

function createCompiler(config) {
  if (!config)
  config = {};
  if (!config.placeholder) {
    config.placeholder = '?';
  }
  let ncache = 100;
  let cache;
  if (typeof config.cache === 'number') {
    ncache = config.cache;
  }
  if (typeof config.cache === 'object') {
    cache = config.cache;
  }
  if (config.cache !== false && !cache) {
    cache = new (__nccwpck_require__(99239))({ max: ncache });
  }

  function toArrayParams(tree, params) {
    const arr = [];
    if (tree.length == 1) {
      return [tree[0], []];
    }

    if (typeof params == 'undefined')
      throw new Error('Named query contains placeholders, but parameters object is undefined');

    const tokens = tree[1];
    for (let i=0; i < tokens.length; ++i) {
      arr.push(params[tokens[i]]);
    }
    return [tree[0], arr];
  }

  function noTailingSemicolon(s) {
    if (s.slice(-1) == ':') {
      return s.slice(0, -1);
    }
    return s;
  }

  function join(tree) {
    if (tree.length == 1) {
      return tree;
    }

    let unnamed = noTailingSemicolon(tree[0][0]);
    for (let i=1; i < tree[0].length; ++i) {
      if (tree[0][i-1].slice(-1) == ':') {
        unnamed += config.placeholder;
      }
      unnamed += config.placeholder;
      unnamed += noTailingSemicolon(tree[0][i]);
    }

    const last = tree[0][tree[0].length -1];
    if (tree[0].length == tree[1].length) {
      if (last.slice(-1) == ':') {
        unnamed += config.placeholder;
      }
      unnamed += config.placeholder;
    }
    return [unnamed, tree[1]];
  }

  function compile(query, paramsObj) {
    let tree;
    if (cache && (tree = cache.get(query))) {
      return toArrayParams(tree, paramsObj)
    }
    tree = join(parse(query));
    if(cache) {
      cache.set(query, tree);
    }
    return toArrayParams(tree, paramsObj);
  }

  compile.parse = parse;
  return compile;
}

// named :one :two to postgres-style numbered $1 $2 $3
function toNumbered(q, params) {
  const tree = parse(q);
  const paramsArr = [];
  if (tree.length == 1) {
    return [tree[0], paramsArr];
  }

  const pIndexes = {};
  let pLastIndex = 0;
  let qs = '';
  let varIndex;
  const varNames = [];
  for (let i=0; i < tree[0].length; ++i) {
    varIndex = pIndexes[tree[1][i]];
    if (!varIndex) {
      varIndex = ++pLastIndex;
      pIndexes[tree[1][i]] = varIndex;
    }
    if (tree[1][i]) {
      varNames[varIndex - 1] = tree[1][i];
      qs += tree[0][i] + '$' + varIndex;
    } else {
      qs += tree[0][i];
    }
  }
  return [qs, varNames.map(n => params[n])];
}

module.exports = createCompiler;
module.exports.toNumbered = toNumbered;


/***/ }),

/***/ 60668:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";
/*!
 * negotiator
 * Copyright(c) 2012 Federico Romero
 * Copyright(c) 2012-2014 Isaac Z. Schlueter
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */



var preferredCharsets = __nccwpck_require__(79168)
var preferredEncodings = __nccwpck_require__(25111)
var preferredLanguages = __nccwpck_require__(56008)
var preferredMediaTypes = __nccwpck_require__(53672)

/**
 * Module exports.
 * @public
 */

module.exports = Negotiator;
module.exports.Negotiator = Negotiator;

/**
 * Create a Negotiator instance from a request.
 * @param {object} request
 * @public
 */

function Negotiator(request) {
  if (!(this instanceof Negotiator)) {
    return new Negotiator(request);
  }

  this.request = request;
}

Negotiator.prototype.charset = function charset(available) {
  var set = this.charsets(available);
  return set && set[0];
};

Negotiator.prototype.charsets = function charsets(available) {
  return preferredCharsets(this.request.headers['accept-charset'], available);
};

Negotiator.prototype.encoding = function encoding(available) {
  var set = this.encodings(available);
  return set && set[0];
};

Negotiator.prototype.encodings = function encodings(available) {
  return preferredEncodings(this.request.headers['accept-encoding'], available);
};

Negotiator.prototype.language = function language(available) {
  var set = this.languages(available);
  return set && set[0];
};

Negotiator.prototype.languages = function languages(available) {
  return preferredLanguages(this.request.headers['accept-language'], available);
};

Negotiator.prototype.mediaType = function mediaType(available) {
  var set = this.mediaTypes(available);
  return set && set[0];
};

Negotiator.prototype.mediaTypes = function mediaTypes(available) {
  return preferredMediaTypes(this.request.headers.accept, available);
};

// Backwards compatibility
Negotiator.prototype.preferredCharset = Negotiator.prototype.charset;
Negotiator.prototype.preferredCharsets = Negotiator.prototype.charsets;
Negotiator.prototype.preferredEncoding = Negotiator.prototype.encoding;
Negotiator.prototype.preferredEncodings = Negotiator.prototype.encodings;
Negotiator.prototype.preferredLanguage = Negotiator.prototype.language;
Negotiator.prototype.preferredLanguages = Negotiator.prototype.languages;
Negotiator.prototype.preferredMediaType = Negotiator.prototype.mediaType;
Negotiator.prototype.preferredMediaTypes = Negotiator.prototype.mediaTypes;


/***/ }),

/***/ 79168:
/***/ ((module) => {

"use strict";
/**
 * negotiator
 * Copyright(c) 2012 Isaac Z. Schlueter
 * Copyright(c) 2014 Federico Romero
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module exports.
 * @public
 */

module.exports = preferredCharsets;
module.exports.preferredCharsets = preferredCharsets;

/**
 * Module variables.
 * @private
 */

var simpleCharsetRegExp = /^\s*([^\s;]+)\s*(?:;(.*))?$/;

/**
 * Parse the Accept-Charset header.
 * @private
 */

function parseAcceptCharset(accept) {
  var accepts = accept.split(',');

  for (var i = 0, j = 0; i < accepts.length; i++) {
    var charset = parseCharset(accepts[i].trim(), i);

    if (charset) {
      accepts[j++] = charset;
    }
  }

  // trim accepts
  accepts.length = j;

  return accepts;
}

/**
 * Parse a charset from the Accept-Charset header.
 * @private
 */

function parseCharset(str, i) {
  var match = simpleCharsetRegExp.exec(str);
  if (!match) return null;

  var charset = match[1];
  var q = 1;
  if (match[2]) {
    var params = match[2].split(';')
    for (var j = 0; j < params.length; j++) {
      var p = params[j].trim().split('=');
      if (p[0] === 'q') {
        q = parseFloat(p[1]);
        break;
      }
    }
  }

  return {
    charset: charset,
    q: q,
    i: i
  };
}

/**
 * Get the priority of a charset.
 * @private
 */

function getCharsetPriority(charset, accepted, index) {
  var priority = {o: -1, q: 0, s: 0};

  for (var i = 0; i < accepted.length; i++) {
    var spec = specify(charset, accepted[i], index);

    if (spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0) {
      priority = spec;
    }
  }

  return priority;
}

/**
 * Get the specificity of the charset.
 * @private
 */

function specify(charset, spec, index) {
  var s = 0;
  if(spec.charset.toLowerCase() === charset.toLowerCase()){
    s |= 1;
  } else if (spec.charset !== '*' ) {
    return null
  }

  return {
    i: index,
    o: spec.i,
    q: spec.q,
    s: s
  }
}

/**
 * Get the preferred charsets from an Accept-Charset header.
 * @public
 */

function preferredCharsets(accept, provided) {
  // RFC 2616 sec 14.2: no header = *
  var accepts = parseAcceptCharset(accept === undefined ? '*' : accept || '');

  if (!provided) {
    // sorted list of all charsets
    return accepts
      .filter(isQuality)
      .sort(compareSpecs)
      .map(getFullCharset);
  }

  var priorities = provided.map(function getPriority(type, index) {
    return getCharsetPriority(type, accepts, index);
  });

  // sorted list of accepted charsets
  return priorities.filter(isQuality).sort(compareSpecs).map(function getCharset(priority) {
    return provided[priorities.indexOf(priority)];
  });
}

/**
 * Compare two specs.
 * @private
 */

function compareSpecs(a, b) {
  return (b.q - a.q) || (b.s - a.s) || (a.o - b.o) || (a.i - b.i) || 0;
}

/**
 * Get full charset string.
 * @private
 */

function getFullCharset(spec) {
  return spec.charset;
}

/**
 * Check if a spec has any quality.
 * @private
 */

function isQuality(spec) {
  return spec.q > 0;
}


/***/ }),

/***/ 25111:
/***/ ((module) => {

"use strict";
/**
 * negotiator
 * Copyright(c) 2012 Isaac Z. Schlueter
 * Copyright(c) 2014 Federico Romero
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module exports.
 * @public
 */

module.exports = preferredEncodings;
module.exports.preferredEncodings = preferredEncodings;

/**
 * Module variables.
 * @private
 */

var simpleEncodingRegExp = /^\s*([^\s;]+)\s*(?:;(.*))?$/;

/**
 * Parse the Accept-Encoding header.
 * @private
 */

function parseAcceptEncoding(accept) {
  var accepts = accept.split(',');
  var hasIdentity = false;
  var minQuality = 1;

  for (var i = 0, j = 0; i < accepts.length; i++) {
    var encoding = parseEncoding(accepts[i].trim(), i);

    if (encoding) {
      accepts[j++] = encoding;
      hasIdentity = hasIdentity || specify('identity', encoding);
      minQuality = Math.min(minQuality, encoding.q || 1);
    }
  }

  if (!hasIdentity) {
    /*
     * If identity doesn't explicitly appear in the accept-encoding header,
     * it's added to the list of acceptable encoding with the lowest q
     */
    accepts[j++] = {
      encoding: 'identity',
      q: minQuality,
      i: i
    };
  }

  // trim accepts
  accepts.length = j;

  return accepts;
}

/**
 * Parse an encoding from the Accept-Encoding header.
 * @private
 */

function parseEncoding(str, i) {
  var match = simpleEncodingRegExp.exec(str);
  if (!match) return null;

  var encoding = match[1];
  var q = 1;
  if (match[2]) {
    var params = match[2].split(';');
    for (var j = 0; j < params.length; j++) {
      var p = params[j].trim().split('=');
      if (p[0] === 'q') {
        q = parseFloat(p[1]);
        break;
      }
    }
  }

  return {
    encoding: encoding,
    q: q,
    i: i
  };
}

/**
 * Get the priority of an encoding.
 * @private
 */

function getEncodingPriority(encoding, accepted, index) {
  var priority = {o: -1, q: 0, s: 0};

  for (var i = 0; i < accepted.length; i++) {
    var spec = specify(encoding, accepted[i], index);

    if (spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0) {
      priority = spec;
    }
  }

  return priority;
}

/**
 * Get the specificity of the encoding.
 * @private
 */

function specify(encoding, spec, index) {
  var s = 0;
  if(spec.encoding.toLowerCase() === encoding.toLowerCase()){
    s |= 1;
  } else if (spec.encoding !== '*' ) {
    return null
  }

  return {
    i: index,
    o: spec.i,
    q: spec.q,
    s: s
  }
};

/**
 * Get the preferred encodings from an Accept-Encoding header.
 * @public
 */

function preferredEncodings(accept, provided) {
  var accepts = parseAcceptEncoding(accept || '');

  if (!provided) {
    // sorted list of all encodings
    return accepts
      .filter(isQuality)
      .sort(compareSpecs)
      .map(getFullEncoding);
  }

  var priorities = provided.map(function getPriority(type, index) {
    return getEncodingPriority(type, accepts, index);
  });

  // sorted list of accepted encodings
  return priorities.filter(isQuality).sort(compareSpecs).map(function getEncoding(priority) {
    return provided[priorities.indexOf(priority)];
  });
}

/**
 * Compare two specs.
 * @private
 */

function compareSpecs(a, b) {
  return (b.q - a.q) || (b.s - a.s) || (a.o - b.o) || (a.i - b.i) || 0;
}

/**
 * Get full encoding string.
 * @private
 */

function getFullEncoding(spec) {
  return spec.encoding;
}

/**
 * Check if a spec has any quality.
 * @private
 */

function isQuality(spec) {
  return spec.q > 0;
}


/***/ }),

/***/ 56008:
/***/ ((module) => {

"use strict";
/**
 * negotiator
 * Copyright(c) 2012 Isaac Z. Schlueter
 * Copyright(c) 2014 Federico Romero
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module exports.
 * @public
 */

module.exports = preferredLanguages;
module.exports.preferredLanguages = preferredLanguages;

/**
 * Module variables.
 * @private
 */

var simpleLanguageRegExp = /^\s*([^\s\-;]+)(?:-([^\s;]+))?\s*(?:;(.*))?$/;

/**
 * Parse the Accept-Language header.
 * @private
 */

function parseAcceptLanguage(accept) {
  var accepts = accept.split(',');

  for (var i = 0, j = 0; i < accepts.length; i++) {
    var language = parseLanguage(accepts[i].trim(), i);

    if (language) {
      accepts[j++] = language;
    }
  }

  // trim accepts
  accepts.length = j;

  return accepts;
}

/**
 * Parse a language from the Accept-Language header.
 * @private
 */

function parseLanguage(str, i) {
  var match = simpleLanguageRegExp.exec(str);
  if (!match) return null;

  var prefix = match[1]
  var suffix = match[2]
  var full = prefix

  if (suffix) full += "-" + suffix;

  var q = 1;
  if (match[3]) {
    var params = match[3].split(';')
    for (var j = 0; j < params.length; j++) {
      var p = params[j].split('=');
      if (p[0] === 'q') q = parseFloat(p[1]);
    }
  }

  return {
    prefix: prefix,
    suffix: suffix,
    q: q,
    i: i,
    full: full
  };
}

/**
 * Get the priority of a language.
 * @private
 */

function getLanguagePriority(language, accepted, index) {
  var priority = {o: -1, q: 0, s: 0};

  for (var i = 0; i < accepted.length; i++) {
    var spec = specify(language, accepted[i], index);

    if (spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0) {
      priority = spec;
    }
  }

  return priority;
}

/**
 * Get the specificity of the language.
 * @private
 */

function specify(language, spec, index) {
  var p = parseLanguage(language)
  if (!p) return null;
  var s = 0;
  if(spec.full.toLowerCase() === p.full.toLowerCase()){
    s |= 4;
  } else if (spec.prefix.toLowerCase() === p.full.toLowerCase()) {
    s |= 2;
  } else if (spec.full.toLowerCase() === p.prefix.toLowerCase()) {
    s |= 1;
  } else if (spec.full !== '*' ) {
    return null
  }

  return {
    i: index,
    o: spec.i,
    q: spec.q,
    s: s
  }
};

/**
 * Get the preferred languages from an Accept-Language header.
 * @public
 */

function preferredLanguages(accept, provided) {
  // RFC 2616 sec 14.4: no header = *
  var accepts = parseAcceptLanguage(accept === undefined ? '*' : accept || '');

  if (!provided) {
    // sorted list of all languages
    return accepts
      .filter(isQuality)
      .sort(compareSpecs)
      .map(getFullLanguage);
  }

  var priorities = provided.map(function getPriority(type, index) {
    return getLanguagePriority(type, accepts, index);
  });

  // sorted list of accepted languages
  return priorities.filter(isQuality).sort(compareSpecs).map(function getLanguage(priority) {
    return provided[priorities.indexOf(priority)];
  });
}

/**
 * Compare two specs.
 * @private
 */

function compareSpecs(a, b) {
  return (b.q - a.q) || (b.s - a.s) || (a.o - b.o) || (a.i - b.i) || 0;
}

/**
 * Get full language string.
 * @private
 */

function getFullLanguage(spec) {
  return spec.full;
}

/**
 * Check if a spec has any quality.
 * @private
 */

function isQuality(spec) {
  return spec.q > 0;
}


/***/ }),

/***/ 53672:
/***/ ((module) => {

"use strict";
/**
 * negotiator
 * Copyright(c) 2012 Isaac Z. Schlueter
 * Copyright(c) 2014 Federico Romero
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module exports.
 * @public
 */

module.exports = preferredMediaTypes;
module.exports.preferredMediaTypes = preferredMediaTypes;

/**
 * Module variables.
 * @private
 */

var simpleMediaTypeRegExp = /^\s*([^\s\/;]+)\/([^;\s]+)\s*(?:;(.*))?$/;

/**
 * Parse the Accept header.
 * @private
 */

function parseAccept(accept) {
  var accepts = splitMediaTypes(accept);

  for (var i = 0, j = 0; i < accepts.length; i++) {
    var mediaType = parseMediaType(accepts[i].trim(), i);

    if (mediaType) {
      accepts[j++] = mediaType;
    }
  }

  // trim accepts
  accepts.length = j;

  return accepts;
}

/**
 * Parse a media type from the Accept header.
 * @private
 */

function parseMediaType(str, i) {
  var match = simpleMediaTypeRegExp.exec(str);
  if (!match) return null;

  var params = Object.create(null);
  var q = 1;
  var subtype = match[2];
  var type = match[1];

  if (match[3]) {
    var kvps = splitParameters(match[3]).map(splitKeyValuePair);

    for (var j = 0; j < kvps.length; j++) {
      var pair = kvps[j];
      var key = pair[0].toLowerCase();
      var val = pair[1];

      // get the value, unwrapping quotes
      var value = val && val[0] === '"' && val[val.length - 1] === '"'
        ? val.substr(1, val.length - 2)
        : val;

      if (key === 'q') {
        q = parseFloat(value);
        break;
      }

      // store parameter
      params[key] = value;
    }
  }

  return {
    type: type,
    subtype: subtype,
    params: params,
    q: q,
    i: i
  };
}

/**
 * Get the priority of a media type.
 * @private
 */

function getMediaTypePriority(type, accepted, index) {
  var priority = {o: -1, q: 0, s: 0};

  for (var i = 0; i < accepted.length; i++) {
    var spec = specify(type, accepted[i], index);

    if (spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0) {
      priority = spec;
    }
  }

  return priority;
}

/**
 * Get the specificity of the media type.
 * @private
 */

function specify(type, spec, index) {
  var p = parseMediaType(type);
  var s = 0;

  if (!p) {
    return null;
  }

  if(spec.type.toLowerCase() == p.type.toLowerCase()) {
    s |= 4
  } else if(spec.type != '*') {
    return null;
  }

  if(spec.subtype.toLowerCase() == p.subtype.toLowerCase()) {
    s |= 2
  } else if(spec.subtype != '*') {
    return null;
  }

  var keys = Object.keys(spec.params);
  if (keys.length > 0) {
    if (keys.every(function (k) {
      return spec.params[k] == '*' || (spec.params[k] || '').toLowerCase() == (p.params[k] || '').toLowerCase();
    })) {
      s |= 1
    } else {
      return null
    }
  }

  return {
    i: index,
    o: spec.i,
    q: spec.q,
    s: s,
  }
}

/**
 * Get the preferred media types from an Accept header.
 * @public
 */

function preferredMediaTypes(accept, provided) {
  // RFC 2616 sec 14.2: no header = */*
  var accepts = parseAccept(accept === undefined ? '*/*' : accept || '');

  if (!provided) {
    // sorted list of all types
    return accepts
      .filter(isQuality)
      .sort(compareSpecs)
      .map(getFullType);
  }

  var priorities = provided.map(function getPriority(type, index) {
    return getMediaTypePriority(type, accepts, index);
  });

  // sorted list of accepted types
  return priorities.filter(isQuality).sort(compareSpecs).map(function getType(priority) {
    return provided[priorities.indexOf(priority)];
  });
}

/**
 * Compare two specs.
 * @private
 */

function compareSpecs(a, b) {
  return (b.q - a.q) || (b.s - a.s) || (a.o - b.o) || (a.i - b.i) || 0;
}

/**
 * Get full type string.
 * @private
 */

function getFullType(spec) {
  return spec.type + '/' + spec.subtype;
}

/**
 * Check if a spec has any quality.
 * @private
 */

function isQuality(spec) {
  return spec.q > 0;
}

/**
 * Count the number of quotes in a string.
 * @private
 */

function quoteCount(string) {
  var count = 0;
  var index = 0;

  while ((index = string.indexOf('"', index)) !== -1) {
    count++;
    index++;
  }

  return count;
}

/**
 * Split a key value pair.
 * @private
 */

function splitKeyValuePair(str) {
  var index = str.indexOf('=');
  var key;
  var val;

  if (index === -1) {
    key = str;
  } else {
    key = str.substr(0, index);
    val = str.substr(index + 1);
  }

  return [key, val];
}

/**
 * Split an Accept header into media types.
 * @private
 */

function splitMediaTypes(accept) {
  var accepts = accept.split(',');

  for (var i = 1, j = 0; i < accepts.length; i++) {
    if (quoteCount(accepts[j]) % 2 == 0) {
      accepts[++j] = accepts[i];
    } else {
      accepts[j] += ',' + accepts[i];
    }
  }

  // trim accepts
  accepts.length = j + 1;

  return accepts;
}

/**
 * Split a string of parameters.
 * @private
 */

function splitParameters(str) {
  var parameters = str.split(';');

  for (var i = 1, j = 0; i < parameters.length; i++) {
    if (quoteCount(parameters[j]) % 2 == 0) {
      parameters[++j] = parameters[i];
    } else {
      parameters[j] += ';' + parameters[i];
    }
  }

  // trim parameters
  parameters.length = j + 1;

  for (var i = 0; i < parameters.length; i++) {
    parameters[i] = parameters[i].trim();
  }

  return parameters;
}


/***/ }),

/***/ 56996:
/***/ ((module) => {

"use strict";
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/


/* eslint-disable no-unused-vars */
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var hasOwnProperty = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;

function toObject(val) {
	if (val === null || val === undefined) {
		throw new TypeError('Object.assign cannot be called with null or undefined');
	}

	return Object(val);
}

function shouldUseNative() {
	try {
		if (!Object.assign) {
			return false;
		}

		// Detect buggy property enumeration order in older V8 versions.

		// https://bugs.chromium.org/p/v8/issues/detail?id=4118
		var test1 = new String('abc');  // eslint-disable-line no-new-wrappers
		test1[5] = 'de';
		if (Object.getOwnPropertyNames(test1)[0] === '5') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test2 = {};
		for (var i = 0; i < 10; i++) {
			test2['_' + String.fromCharCode(i)] = i;
		}
		var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
			return test2[n];
		});
		if (order2.join('') !== '0123456789') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test3 = {};
		'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
			test3[letter] = letter;
		});
		if (Object.keys(Object.assign({}, test3)).join('') !==
				'abcdefghijklmnopqrst') {
			return false;
		}

		return true;
	} catch (err) {
		// We don't expect any of the above to throw, but better to be safe.
		return false;
	}
}

module.exports = shouldUseNative() ? Object.assign : function (target, source) {
	var from;
	var to = toObject(target);
	var symbols;

	for (var s = 1; s < arguments.length; s++) {
		from = Object(arguments[s]);

		for (var key in from) {
			if (hasOwnProperty.call(from, key)) {
				to[key] = from[key];
			}
		}

		if (getOwnPropertySymbols) {
			symbols = getOwnPropertySymbols(from);
			for (var i = 0; i < symbols.length; i++) {
				if (propIsEnumerable.call(from, symbols[i])) {
					to[symbols[i]] = from[symbols[i]];
				}
			}
		}
	}

	return to;
};


/***/ }),

/***/ 60506:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var hasMap = typeof Map === 'function' && Map.prototype;
var mapSizeDescriptor = Object.getOwnPropertyDescriptor && hasMap ? Object.getOwnPropertyDescriptor(Map.prototype, 'size') : null;
var mapSize = hasMap && mapSizeDescriptor && typeof mapSizeDescriptor.get === 'function' ? mapSizeDescriptor.get : null;
var mapForEach = hasMap && Map.prototype.forEach;
var hasSet = typeof Set === 'function' && Set.prototype;
var setSizeDescriptor = Object.getOwnPropertyDescriptor && hasSet ? Object.getOwnPropertyDescriptor(Set.prototype, 'size') : null;
var setSize = hasSet && setSizeDescriptor && typeof setSizeDescriptor.get === 'function' ? setSizeDescriptor.get : null;
var setForEach = hasSet && Set.prototype.forEach;
var hasWeakMap = typeof WeakMap === 'function' && WeakMap.prototype;
var weakMapHas = hasWeakMap ? WeakMap.prototype.has : null;
var hasWeakSet = typeof WeakSet === 'function' && WeakSet.prototype;
var weakSetHas = hasWeakSet ? WeakSet.prototype.has : null;
var hasWeakRef = typeof WeakRef === 'function' && WeakRef.prototype;
var weakRefDeref = hasWeakRef ? WeakRef.prototype.deref : null;
var booleanValueOf = Boolean.prototype.valueOf;
var objectToString = Object.prototype.toString;
var functionToString = Function.prototype.toString;
var $match = String.prototype.match;
var $slice = String.prototype.slice;
var $replace = String.prototype.replace;
var $toUpperCase = String.prototype.toUpperCase;
var $toLowerCase = String.prototype.toLowerCase;
var $test = RegExp.prototype.test;
var $concat = Array.prototype.concat;
var $join = Array.prototype.join;
var $arrSlice = Array.prototype.slice;
var $floor = Math.floor;
var bigIntValueOf = typeof BigInt === 'function' ? BigInt.prototype.valueOf : null;
var gOPS = Object.getOwnPropertySymbols;
var symToString = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? Symbol.prototype.toString : null;
var hasShammedSymbols = typeof Symbol === 'function' && typeof Symbol.iterator === 'object';
// ie, `has-tostringtag/shams
var toStringTag = typeof Symbol === 'function' && Symbol.toStringTag && (typeof Symbol.toStringTag === hasShammedSymbols ? 'object' : 'symbol')
    ? Symbol.toStringTag
    : null;
var isEnumerable = Object.prototype.propertyIsEnumerable;

var gPO = (typeof Reflect === 'function' ? Reflect.getPrototypeOf : Object.getPrototypeOf) || (
    [].__proto__ === Array.prototype // eslint-disable-line no-proto
        ? function (O) {
            return O.__proto__; // eslint-disable-line no-proto
        }
        : null
);

function addNumericSeparator(num, str) {
    if (
        num === Infinity
        || num === -Infinity
        || num !== num
        || (num && num > -1000 && num < 1000)
        || $test.call(/e/, str)
    ) {
        return str;
    }
    var sepRegex = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;
    if (typeof num === 'number') {
        var int = num < 0 ? -$floor(-num) : $floor(num); // trunc(num)
        if (int !== num) {
            var intStr = String(int);
            var dec = $slice.call(str, intStr.length + 1);
            return $replace.call(intStr, sepRegex, '$&_') + '.' + $replace.call($replace.call(dec, /([0-9]{3})/g, '$&_'), /_$/, '');
        }
    }
    return $replace.call(str, sepRegex, '$&_');
}

var utilInspect = __nccwpck_require__(58502);
var inspectCustom = utilInspect.custom;
var inspectSymbol = isSymbol(inspectCustom) ? inspectCustom : null;

var quotes = {
    __proto__: null,
    'double': '"',
    single: "'"
};
var quoteREs = {
    __proto__: null,
    'double': /(["\\])/g,
    single: /(['\\])/g
};

module.exports = function inspect_(obj, options, depth, seen) {
    var opts = options || {};

    if (has(opts, 'quoteStyle') && !has(quotes, opts.quoteStyle)) {
        throw new TypeError('option "quoteStyle" must be "single" or "double"');
    }
    if (
        has(opts, 'maxStringLength') && (typeof opts.maxStringLength === 'number'
            ? opts.maxStringLength < 0 && opts.maxStringLength !== Infinity
            : opts.maxStringLength !== null
        )
    ) {
        throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');
    }
    var customInspect = has(opts, 'customInspect') ? opts.customInspect : true;
    if (typeof customInspect !== 'boolean' && customInspect !== 'symbol') {
        throw new TypeError('option "customInspect", if provided, must be `true`, `false`, or `\'symbol\'`');
    }

    if (
        has(opts, 'indent')
        && opts.indent !== null
        && opts.indent !== '\t'
        && !(parseInt(opts.indent, 10) === opts.indent && opts.indent > 0)
    ) {
        throw new TypeError('option "indent" must be "\\t", an integer > 0, or `null`');
    }
    if (has(opts, 'numericSeparator') && typeof opts.numericSeparator !== 'boolean') {
        throw new TypeError('option "numericSeparator", if provided, must be `true` or `false`');
    }
    var numericSeparator = opts.numericSeparator;

    if (typeof obj === 'undefined') {
        return 'undefined';
    }
    if (obj === null) {
        return 'null';
    }
    if (typeof obj === 'boolean') {
        return obj ? 'true' : 'false';
    }

    if (typeof obj === 'string') {
        return inspectString(obj, opts);
    }
    if (typeof obj === 'number') {
        if (obj === 0) {
            return Infinity / obj > 0 ? '0' : '-0';
        }
        var str = String(obj);
        return numericSeparator ? addNumericSeparator(obj, str) : str;
    }
    if (typeof obj === 'bigint') {
        var bigIntStr = String(obj) + 'n';
        return numericSeparator ? addNumericSeparator(obj, bigIntStr) : bigIntStr;
    }

    var maxDepth = typeof opts.depth === 'undefined' ? 5 : opts.depth;
    if (typeof depth === 'undefined') { depth = 0; }
    if (depth >= maxDepth && maxDepth > 0 && typeof obj === 'object') {
        return isArray(obj) ? '[Array]' : '[Object]';
    }

    var indent = getIndent(opts, depth);

    if (typeof seen === 'undefined') {
        seen = [];
    } else if (indexOf(seen, obj) >= 0) {
        return '[Circular]';
    }

    function inspect(value, from, noIndent) {
        if (from) {
            seen = $arrSlice.call(seen);
            seen.push(from);
        }
        if (noIndent) {
            var newOpts = {
                depth: opts.depth
            };
            if (has(opts, 'quoteStyle')) {
                newOpts.quoteStyle = opts.quoteStyle;
            }
            return inspect_(value, newOpts, depth + 1, seen);
        }
        return inspect_(value, opts, depth + 1, seen);
    }

    if (typeof obj === 'function' && !isRegExp(obj)) { // in older engines, regexes are callable
        var name = nameOf(obj);
        var keys = arrObjKeys(obj, inspect);
        return '[Function' + (name ? ': ' + name : ' (anonymous)') + ']' + (keys.length > 0 ? ' { ' + $join.call(keys, ', ') + ' }' : '');
    }
    if (isSymbol(obj)) {
        var symString = hasShammedSymbols ? $replace.call(String(obj), /^(Symbol\(.*\))_[^)]*$/, '$1') : symToString.call(obj);
        return typeof obj === 'object' && !hasShammedSymbols ? markBoxed(symString) : symString;
    }
    if (isElement(obj)) {
        var s = '<' + $toLowerCase.call(String(obj.nodeName));
        var attrs = obj.attributes || [];
        for (var i = 0; i < attrs.length; i++) {
            s += ' ' + attrs[i].name + '=' + wrapQuotes(quote(attrs[i].value), 'double', opts);
        }
        s += '>';
        if (obj.childNodes && obj.childNodes.length) { s += '...'; }
        s += '</' + $toLowerCase.call(String(obj.nodeName)) + '>';
        return s;
    }
    if (isArray(obj)) {
        if (obj.length === 0) { return '[]'; }
        var xs = arrObjKeys(obj, inspect);
        if (indent && !singleLineValues(xs)) {
            return '[' + indentedJoin(xs, indent) + ']';
        }
        return '[ ' + $join.call(xs, ', ') + ' ]';
    }
    if (isError(obj)) {
        var parts = arrObjKeys(obj, inspect);
        if (!('cause' in Error.prototype) && 'cause' in obj && !isEnumerable.call(obj, 'cause')) {
            return '{ [' + String(obj) + '] ' + $join.call($concat.call('[cause]: ' + inspect(obj.cause), parts), ', ') + ' }';
        }
        if (parts.length === 0) { return '[' + String(obj) + ']'; }
        return '{ [' + String(obj) + '] ' + $join.call(parts, ', ') + ' }';
    }
    if (typeof obj === 'object' && customInspect) {
        if (inspectSymbol && typeof obj[inspectSymbol] === 'function' && utilInspect) {
            return utilInspect(obj, { depth: maxDepth - depth });
        } else if (customInspect !== 'symbol' && typeof obj.inspect === 'function') {
            return obj.inspect();
        }
    }
    if (isMap(obj)) {
        var mapParts = [];
        if (mapForEach) {
            mapForEach.call(obj, function (value, key) {
                mapParts.push(inspect(key, obj, true) + ' => ' + inspect(value, obj));
            });
        }
        return collectionOf('Map', mapSize.call(obj), mapParts, indent);
    }
    if (isSet(obj)) {
        var setParts = [];
        if (setForEach) {
            setForEach.call(obj, function (value) {
                setParts.push(inspect(value, obj));
            });
        }
        return collectionOf('Set', setSize.call(obj), setParts, indent);
    }
    if (isWeakMap(obj)) {
        return weakCollectionOf('WeakMap');
    }
    if (isWeakSet(obj)) {
        return weakCollectionOf('WeakSet');
    }
    if (isWeakRef(obj)) {
        return weakCollectionOf('WeakRef');
    }
    if (isNumber(obj)) {
        return markBoxed(inspect(Number(obj)));
    }
    if (isBigInt(obj)) {
        return markBoxed(inspect(bigIntValueOf.call(obj)));
    }
    if (isBoolean(obj)) {
        return markBoxed(booleanValueOf.call(obj));
    }
    if (isString(obj)) {
        return markBoxed(inspect(String(obj)));
    }
    // note: in IE 8, sometimes `global !== window` but both are the prototypes of each other
    /* eslint-env browser */
    if (typeof window !== 'undefined' && obj === window) {
        return '{ [object Window] }';
    }
    if (
        (typeof globalThis !== 'undefined' && obj === globalThis)
        || (typeof global !== 'undefined' && obj === global)
    ) {
        return '{ [object globalThis] }';
    }
    if (!isDate(obj) && !isRegExp(obj)) {
        var ys = arrObjKeys(obj, inspect);
        var isPlainObject = gPO ? gPO(obj) === Object.prototype : obj instanceof Object || obj.constructor === Object;
        var protoTag = obj instanceof Object ? '' : 'null prototype';
        var stringTag = !isPlainObject && toStringTag && Object(obj) === obj && toStringTag in obj ? $slice.call(toStr(obj), 8, -1) : protoTag ? 'Object' : '';
        var constructorTag = isPlainObject || typeof obj.constructor !== 'function' ? '' : obj.constructor.name ? obj.constructor.name + ' ' : '';
        var tag = constructorTag + (stringTag || protoTag ? '[' + $join.call($concat.call([], stringTag || [], protoTag || []), ': ') + '] ' : '');
        if (ys.length === 0) { return tag + '{}'; }
        if (indent) {
            return tag + '{' + indentedJoin(ys, indent) + '}';
        }
        return tag + '{ ' + $join.call(ys, ', ') + ' }';
    }
    return String(obj);
};

function wrapQuotes(s, defaultStyle, opts) {
    var style = opts.quoteStyle || defaultStyle;
    var quoteChar = quotes[style];
    return quoteChar + s + quoteChar;
}

function quote(s) {
    return $replace.call(String(s), /"/g, '&quot;');
}

function canTrustToString(obj) {
    return !toStringTag || !(typeof obj === 'object' && (toStringTag in obj || typeof obj[toStringTag] !== 'undefined'));
}
function isArray(obj) { return toStr(obj) === '[object Array]' && canTrustToString(obj); }
function isDate(obj) { return toStr(obj) === '[object Date]' && canTrustToString(obj); }
function isRegExp(obj) { return toStr(obj) === '[object RegExp]' && canTrustToString(obj); }
function isError(obj) { return toStr(obj) === '[object Error]' && canTrustToString(obj); }
function isString(obj) { return toStr(obj) === '[object String]' && canTrustToString(obj); }
function isNumber(obj) { return toStr(obj) === '[object Number]' && canTrustToString(obj); }
function isBoolean(obj) { return toStr(obj) === '[object Boolean]' && canTrustToString(obj); }

// Symbol and BigInt do have Symbol.toStringTag by spec, so that can't be used to eliminate false positives
function isSymbol(obj) {
    if (hasShammedSymbols) {
        return obj && typeof obj === 'object' && obj instanceof Symbol;
    }
    if (typeof obj === 'symbol') {
        return true;
    }
    if (!obj || typeof obj !== 'object' || !symToString) {
        return false;
    }
    try {
        symToString.call(obj);
        return true;
    } catch (e) {}
    return false;
}

function isBigInt(obj) {
    if (!obj || typeof obj !== 'object' || !bigIntValueOf) {
        return false;
    }
    try {
        bigIntValueOf.call(obj);
        return true;
    } catch (e) {}
    return false;
}

var hasOwn = Object.prototype.hasOwnProperty || function (key) { return key in this; };
function has(obj, key) {
    return hasOwn.call(obj, key);
}

function toStr(obj) {
    return objectToString.call(obj);
}

function nameOf(f) {
    if (f.name) { return f.name; }
    var m = $match.call(functionToString.call(f), /^function\s*([\w$]+)/);
    if (m) { return m[1]; }
    return null;
}

function indexOf(xs, x) {
    if (xs.indexOf) { return xs.indexOf(x); }
    for (var i = 0, l = xs.length; i < l; i++) {
        if (xs[i] === x) { return i; }
    }
    return -1;
}

function isMap(x) {
    if (!mapSize || !x || typeof x !== 'object') {
        return false;
    }
    try {
        mapSize.call(x);
        try {
            setSize.call(x);
        } catch (s) {
            return true;
        }
        return x instanceof Map; // core-js workaround, pre-v2.5.0
    } catch (e) {}
    return false;
}

function isWeakMap(x) {
    if (!weakMapHas || !x || typeof x !== 'object') {
        return false;
    }
    try {
        weakMapHas.call(x, weakMapHas);
        try {
            weakSetHas.call(x, weakSetHas);
        } catch (s) {
            return true;
        }
        return x instanceof WeakMap; // core-js workaround, pre-v2.5.0
    } catch (e) {}
    return false;
}

function isWeakRef(x) {
    if (!weakRefDeref || !x || typeof x !== 'object') {
        return false;
    }
    try {
        weakRefDeref.call(x);
        return true;
    } catch (e) {}
    return false;
}

function isSet(x) {
    if (!setSize || !x || typeof x !== 'object') {
        return false;
    }
    try {
        setSize.call(x);
        try {
            mapSize.call(x);
        } catch (m) {
            return true;
        }
        return x instanceof Set; // core-js workaround, pre-v2.5.0
    } catch (e) {}
    return false;
}

function isWeakSet(x) {
    if (!weakSetHas || !x || typeof x !== 'object') {
        return false;
    }
    try {
        weakSetHas.call(x, weakSetHas);
        try {
            weakMapHas.call(x, weakMapHas);
        } catch (s) {
            return true;
        }
        return x instanceof WeakSet; // core-js workaround, pre-v2.5.0
    } catch (e) {}
    return false;
}

function isElement(x) {
    if (!x || typeof x !== 'object') { return false; }
    if (typeof HTMLElement !== 'undefined' && x instanceof HTMLElement) {
        return true;
    }
    return typeof x.nodeName === 'string' && typeof x.getAttribute === 'function';
}

function inspectString(str, opts) {
    if (str.length > opts.maxStringLength) {
        var remaining = str.length - opts.maxStringLength;
        var trailer = '... ' + remaining + ' more character' + (remaining > 1 ? 's' : '');
        return inspectString($slice.call(str, 0, opts.maxStringLength), opts) + trailer;
    }
    var quoteRE = quoteREs[opts.quoteStyle || 'single'];
    quoteRE.lastIndex = 0;
    // eslint-disable-next-line no-control-regex
    var s = $replace.call($replace.call(str, quoteRE, '\\$1'), /[\x00-\x1f]/g, lowbyte);
    return wrapQuotes(s, 'single', opts);
}

function lowbyte(c) {
    var n = c.charCodeAt(0);
    var x = {
        8: 'b',
        9: 't',
        10: 'n',
        12: 'f',
        13: 'r'
    }[n];
    if (x) { return '\\' + x; }
    return '\\x' + (n < 0x10 ? '0' : '') + $toUpperCase.call(n.toString(16));
}

function markBoxed(str) {
    return 'Object(' + str + ')';
}

function weakCollectionOf(type) {
    return type + ' { ? }';
}

function collectionOf(type, size, entries, indent) {
    var joinedEntries = indent ? indentedJoin(entries, indent) : $join.call(entries, ', ');
    return type + ' (' + size + ') {' + joinedEntries + '}';
}

function singleLineValues(xs) {
    for (var i = 0; i < xs.length; i++) {
        if (indexOf(xs[i], '\n') >= 0) {
            return false;
        }
    }
    return true;
}

function getIndent(opts, depth) {
    var baseIndent;
    if (opts.indent === '\t') {
        baseIndent = '\t';
    } else if (typeof opts.indent === 'number' && opts.indent > 0) {
        baseIndent = $join.call(Array(opts.indent + 1), ' ');
    } else {
        return null;
    }
    return {
        base: baseIndent,
        prev: $join.call(Array(depth + 1), baseIndent)
    };
}

function indentedJoin(xs, indent) {
    if (xs.length === 0) { return ''; }
    var lineJoiner = '\n' + indent.prev + indent.base;
    return lineJoiner + $join.call(xs, ',' + lineJoiner) + '\n' + indent.prev;
}

function arrObjKeys(obj, inspect) {
    var isArr = isArray(obj);
    var xs = [];
    if (isArr) {
        xs.length = obj.length;
        for (var i = 0; i < obj.length; i++) {
            xs[i] = has(obj, i) ? inspect(obj[i], obj) : '';
        }
    }
    var syms = typeof gOPS === 'function' ? gOPS(obj) : [];
    var symMap;
    if (hasShammedSymbols) {
        symMap = {};
        for (var k = 0; k < syms.length; k++) {
            symMap['$' + syms[k]] = syms[k];
        }
    }

    for (var key in obj) { // eslint-disable-line no-restricted-syntax
        if (!has(obj, key)) { continue; } // eslint-disable-line no-restricted-syntax, no-continue
        if (isArr && String(Number(key)) === key && key < obj.length) { continue; } // eslint-disable-line no-restricted-syntax, no-continue
        if (hasShammedSymbols && symMap['$' + key] instanceof Symbol) {
            // this is to prevent shammed Symbols, which are stored as strings, from being included in the string key section
            continue; // eslint-disable-line no-restricted-syntax, no-continue
        } else if ($test.call(/[^\w$]/, key)) {
            xs.push(inspect(key, obj) + ': ' + inspect(obj[key], obj));
        } else {
            xs.push(key + ': ' + inspect(obj[key], obj));
        }
    }
    if (typeof gOPS === 'function') {
        for (var j = 0; j < syms.length; j++) {
            if (isEnumerable.call(obj, syms[j])) {
                xs.push('[' + inspect(syms[j]) + ']: ' + inspect(obj[syms[j]], obj));
            }
        }
    }
    return xs;
}


/***/ }),

/***/ 58502:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

module.exports = __nccwpck_require__(39023).inspect;


/***/ }),

/***/ 5698:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";
/*!
 * on-finished
 * Copyright(c) 2013 Jonathan Ong
 * Copyright(c) 2014 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module exports.
 * @public
 */

module.exports = onFinished
module.exports.isFinished = isFinished

/**
 * Module dependencies.
 * @private
 */

var asyncHooks = tryRequireAsyncHooks()
var first = __nccwpck_require__(25049)

/**
 * Variables.
 * @private
 */

/* istanbul ignore next */
var defer = typeof setImmediate === 'function'
  ? setImmediate
  : function (fn) { process.nextTick(fn.bind.apply(fn, arguments)) }

/**
 * Invoke callback when the response has finished, useful for
 * cleaning up resources afterwards.
 *
 * @param {object} msg
 * @param {function} listener
 * @return {object}
 * @public
 */

function onFinished (msg, listener) {
  if (isFinished(msg) !== false) {
    defer(listener, null, msg)
    return msg
  }

  // attach the listener to the message
  attachListener(msg, wrap(listener))

  return msg
}

/**
 * Determine if message is already finished.
 *
 * @param {object} msg
 * @return {boolean}
 * @public
 */

function isFinished (msg) {
  var socket = msg.socket

  if (typeof msg.finished === 'boolean') {
    // OutgoingMessage
    return Boolean(msg.finished || (socket && !socket.writable))
  }

  if (typeof msg.complete === 'boolean') {
    // IncomingMessage
    return Boolean(msg.upgrade || !socket || !socket.readable || (msg.complete && !msg.readable))
  }

  // don't know
  return undefined
}

/**
 * Attach a finished listener to the message.
 *
 * @param {object} msg
 * @param {function} callback
 * @private
 */

function attachFinishedListener (msg, callback) {
  var eeMsg
  var eeSocket
  var finished = false

  function onFinish (error) {
    eeMsg.cancel()
    eeSocket.cancel()

    finished = true
    callback(error)
  }

  // finished on first message event
  eeMsg = eeSocket = first([[msg, 'end', 'finish']], onFinish)

  function onSocket (socket) {
    // remove listener
    msg.removeListener('socket', onSocket)

    if (finished) return
    if (eeMsg !== eeSocket) return

    // finished on first socket event
    eeSocket = first([[socket, 'error', 'close']], onFinish)
  }

  if (msg.socket) {
    // socket already assigned
    onSocket(msg.socket)
    return
  }

  // wait for socket to be assigned
  msg.on('socket', onSocket)

  if (msg.socket === undefined) {
    // istanbul ignore next: node.js 0.8 patch
    patchAssignSocket(msg, onSocket)
  }
}

/**
 * Attach the listener to the message.
 *
 * @param {object} msg
 * @return {function}
 * @private
 */

function attachListener (msg, listener) {
  var attached = msg.__onFinished

  // create a private single listener with queue
  if (!attached || !attached.queue) {
    attached = msg.__onFinished = createListener(msg)
    attachFinishedListener(msg, attached)
  }

  attached.queue.push(listener)
}

/**
 * Create listener on message.
 *
 * @param {object} msg
 * @return {function}
 * @private
 */

function createListener (msg) {
  function listener (err) {
    if (msg.__onFinished === listener) msg.__onFinished = null
    if (!listener.queue) return

    var queue = listener.queue
    listener.queue = null

    for (var i = 0; i < queue.length; i++) {
      queue[i](err, msg)
    }
  }

  listener.queue = []

  return listener
}

/**
 * Patch ServerResponse.prototype.assignSocket for node.js 0.8.
 *
 * @param {ServerResponse} res
 * @param {function} callback
 * @private
 */

// istanbul ignore next: node.js 0.8 patch
function patchAssignSocket (res, callback) {
  var assignSocket = res.assignSocket

  if (typeof assignSocket !== 'function') return

  // res.on('socket', callback) is broken in 0.8
  res.assignSocket = function _assignSocket (socket) {
    assignSocket.call(this, socket)
    callback(socket)
  }
}

/**
 * Try to require async_hooks
 * @private
 */

function tryRequireAsyncHooks () {
  try {
    return __nccwpck_require__(90290)
  } catch (e) {
    return {}
  }
}

/**
 * Wrap function with async resource, if possible.
 * AsyncResource.bind static method backported.
 * @private
 */

function wrap (fn) {
  var res

  // create anonymous resource
  if (asyncHooks.AsyncResource) {
    res = new asyncHooks.AsyncResource(fn.name || 'bound-anonymous-fn')
  }

  // incompatible node.js
  if (!res || !res.runInAsyncScope) {
    return fn
  }

  // return bound function
  return res.runInAsyncScope.bind(res, fn, null)
}


/***/ }),

/***/ 38186:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


var name = __nccwpck_require__(16057);

/**
 * Wrap callbacks to prevent double execution.
 *
 * @param {Function} fn Function that should only be called once.
 * @returns {Function} A wrapped callback which prevents multiple executions.
 * @public
 */
module.exports = function one(fn) {
  var called = 0
    , value;

  /**
   * The function that prevents double execution.
   *
   * @private
   */
  function onetime() {
    if (called) return value;

    called = 1;
    value = fn.apply(this, arguments);
    fn = null;

    return value;
  }

  //
  // To make debugging more easy we want to use the name of the supplied
  // function. So when you look at the functions that are assigned to event
  // listeners you don't see a load of `onetime` functions but actually the
  // names of the functions that this module will call.
  //
  // NOTE: We cannot override the `name` property, as that is `readOnly`
  // property, so displayName will have to do.
  //
  onetime.displayName = name(fn);
  return onetime;
};


/***/ }),

/***/ 83404:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";
/*!
 * parseurl
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2014-2017 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module dependencies.
 * @private
 */

var url = __nccwpck_require__(87016)
var parse = url.parse
var Url = url.Url

/**
 * Module exports.
 * @public
 */

module.exports = parseurl
module.exports.original = originalurl

/**
 * Parse the `req` url with memoization.
 *
 * @param {ServerRequest} req
 * @return {Object}
 * @public
 */

function parseurl (req) {
  var url = req.url

  if (url === undefined) {
    // URL is undefined
    return undefined
  }

  var parsed = req._parsedUrl

  if (fresh(url, parsed)) {
    // Return cached URL parse
    return parsed
  }

  // Parse the URL
  parsed = fastparse(url)
  parsed._raw = url

  return (req._parsedUrl = parsed)
};

/**
 * Parse the `req` original url with fallback and memoization.
 *
 * @param {ServerRequest} req
 * @return {Object}
 * @public
 */

function originalurl (req) {
  var url = req.originalUrl

  if (typeof url !== 'string') {
    // Fallback
    return parseurl(req)
  }

  var parsed = req._parsedOriginalUrl

  if (fresh(url, parsed)) {
    // Return cached URL parse
    return parsed
  }

  // Parse the URL
  parsed = fastparse(url)
  parsed._raw = url

  return (req._parsedOriginalUrl = parsed)
};

/**
 * Parse the `str` url with fast-path short-cut.
 *
 * @param {string} str
 * @return {Object}
 * @private
 */

function fastparse (str) {
  if (typeof str !== 'string' || str.charCodeAt(0) !== 0x2f /* / */) {
    return parse(str)
  }

  var pathname = str
  var query = null
  var search = null

  // This takes the regexp from https://github.com/joyent/node/pull/7878
  // Which is /^(\/[^?#\s]*)(\?[^#\s]*)?$/
  // And unrolls it into a for loop
  for (var i = 1; i < str.length; i++) {
    switch (str.charCodeAt(i)) {
      case 0x3f: /* ?  */
        if (search === null) {
          pathname = str.substring(0, i)
          query = str.substring(i + 1)
          search = str.substring(i)
        }
        break
      case 0x09: /* \t */
      case 0x0a: /* \n */
      case 0x0c: /* \f */
      case 0x0d: /* \r */
      case 0x20: /*    */
      case 0x23: /* #  */
      case 0xa0:
      case 0xfeff:
        return parse(str)
    }
  }

  var url = Url !== undefined
    ? new Url()
    : {}

  url.path = str
  url.href = str
  url.pathname = pathname

  if (search !== null) {
    url.query = query
    url.search = search
  }

  return url
}

/**
 * Determine if parsed is still fresh for url.
 *
 * @param {string} url
 * @param {object} parsedUrl
 * @return {boolean}
 * @private
 */

function fresh (url, parsedUrl) {
  return typeof parsedUrl === 'object' &&
    parsedUrl !== null &&
    (Url === undefined || parsedUrl instanceof Url) &&
    parsedUrl._raw === url
}


/***/ }),

/***/ 19455:
/***/ ((module) => {

/**
 * Expose `pathToRegexp`.
 */

module.exports = pathToRegexp;

/**
 * Match matching groups in a regular expression.
 */
var MATCHING_GROUP_REGEXP = /\\.|\((?:\?<(.*?)>)?(?!\?)/g;

/**
 * Normalize the given path string,
 * returning a regular expression.
 *
 * An empty array should be passed,
 * which will contain the placeholder
 * key names. For example "/user/:id" will
 * then contain ["id"].
 *
 * @param  {String|RegExp|Array} path
 * @param  {Array} keys
 * @param  {Object} options
 * @return {RegExp}
 * @api private
 */

function pathToRegexp(path, keys, options) {
  options = options || {};
  keys = keys || [];
  var strict = options.strict;
  var end = options.end !== false;
  var flags = options.sensitive ? '' : 'i';
  var lookahead = options.lookahead !== false;
  var extraOffset = 0;
  var keysOffset = keys.length;
  var i = 0;
  var name = 0;
  var pos = 0;
  var backtrack = '';
  var m;

  if (path instanceof RegExp) {
    while (m = MATCHING_GROUP_REGEXP.exec(path.source)) {
      if (m[0][0] === '\\') continue;

      keys.push({
        name: m[1] || name++,
        optional: false,
        offset: m.index
      });
    }

    return path;
  }

  if (Array.isArray(path)) {
    // Map array parts into regexps and return their source. We also pass
    // the same keys and options instance into every generation to get
    // consistent matching groups before we join the sources together.
    path = path.map(function (value) {
      return pathToRegexp(value, keys, options).source;
    });

    return new RegExp(path.join('|'), flags);
  }

  if (typeof path !== 'string') {
    throw new TypeError('path must be a string, array of strings, or regular expression');
  }

  path = path.replace(
    /\\.|(\/)?(\.)?:(\w+)(\(.*?\))?(\*)?(\?)?|[.*]|\/\(/g,
    function (match, slash, format, key, capture, star, optional, offset) {
      if (match[0] === '\\') {
        backtrack += match;
        pos += 2;
        return match;
      }

      if (match === '.') {
        backtrack += '\\.';
        extraOffset += 1;
        pos += 1;
        return '\\.';
      }

      if (slash || format) {
        backtrack = '';
      } else {
        backtrack += path.slice(pos, offset);
      }

      pos = offset + match.length;

      if (match === '*') {
        extraOffset += 3;
        return '(.*)';
      }

      if (match === '/(') {
        backtrack += '/';
        extraOffset += 2;
        return '/(?:';
      }

      slash = slash || '';
      format = format ? '\\.' : '';
      optional = optional || '';
      capture = capture ?
        capture.replace(/\\.|\*/, function (m) { return m === '*' ? '(.*)' : m; }) :
        (backtrack ? '((?:(?!/|' + backtrack + ').)+?)' : '([^/' + format + ']+?)');

      keys.push({
        name: key,
        optional: !!optional,
        offset: offset + extraOffset
      });

      var result = '(?:'
        + format + slash + capture
        + (star ? '((?:[/' + format + '].+?)?)' : '')
        + ')'
        + optional;

      extraOffset += result.length - match.length;

      return result;
    });

  // This is a workaround for handling unnamed matching groups.
  while (m = MATCHING_GROUP_REGEXP.exec(path)) {
    if (m[0][0] === '\\') continue;

    if (keysOffset + i === keys.length || keys[keysOffset + i].offset > m.index) {
      keys.splice(keysOffset + i, 0, {
        name: name++, // Unnamed matching groups must be consistently linear.
        optional: false,
        offset: m.index
      });
    }

    i++;
  }

  path += strict ? '' : path[path.length - 1] === '/' ? '?' : '/?';

  // If the path is non-ending, match until the end or a slash.
  if (end) {
    path += '$';
  } else if (path[path.length - 1] !== '/') {
    path += lookahead ? '(?=/|$)' : '(?:/|$)';
  }

  return new RegExp('^' + path, flags);
};


/***/ }),

/***/ 41564:
/***/ ((module) => {

"use strict";


if (typeof process === 'undefined' ||
    !process.version ||
    process.version.indexOf('v0.') === 0 ||
    process.version.indexOf('v1.') === 0 && process.version.indexOf('v1.8.') !== 0) {
  module.exports = { nextTick: nextTick };
} else {
  module.exports = process
}

function nextTick(fn, arg1, arg2, arg3) {
  if (typeof fn !== 'function') {
    throw new TypeError('"callback" argument must be a function');
  }
  var len = arguments.length;
  var args, i;
  switch (len) {
  case 0:
  case 1:
    return process.nextTick(fn);
  case 2:
    return process.nextTick(function afterTickOne() {
      fn.call(null, arg1);
    });
  case 3:
    return process.nextTick(function afterTickTwo() {
      fn.call(null, arg1, arg2);
    });
  case 4:
    return process.nextTick(function afterTickThree() {
      fn.call(null, arg1, arg2, arg3);
    });
  default:
    args = new Array(len - 1);
    i = 0;
    while (i < args.length) {
      args[i++] = arguments[i];
    }
    return process.nextTick(function afterTick() {
      fn.apply(null, args);
    });
  }
}



/***/ }),

/***/ 98916:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";
/*!
 * proxy-addr
 * Copyright(c) 2014-2016 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module exports.
 * @public
 */

module.exports = proxyaddr
module.exports.all = alladdrs
module.exports.compile = compile

/**
 * Module dependencies.
 * @private
 */

var forwarded = __nccwpck_require__(55200)
var ipaddr = __nccwpck_require__(60461)

/**
 * Variables.
 * @private
 */

var DIGIT_REGEXP = /^[0-9]+$/
var isip = ipaddr.isValid
var parseip = ipaddr.parse

/**
 * Pre-defined IP ranges.
 * @private
 */

var IP_RANGES = {
  linklocal: ['169.254.0.0/16', 'fe80::/10'],
  loopback: ['127.0.0.1/8', '::1/128'],
  uniquelocal: ['10.0.0.0/8', '172.16.0.0/12', '192.168.0.0/16', 'fc00::/7']
}

/**
 * Get all addresses in the request, optionally stopping
 * at the first untrusted.
 *
 * @param {Object} request
 * @param {Function|Array|String} [trust]
 * @public
 */

function alladdrs (req, trust) {
  // get addresses
  var addrs = forwarded(req)

  if (!trust) {
    // Return all addresses
    return addrs
  }

  if (typeof trust !== 'function') {
    trust = compile(trust)
  }

  for (var i = 0; i < addrs.length - 1; i++) {
    if (trust(addrs[i], i)) continue

    addrs.length = i + 1
  }

  return addrs
}

/**
 * Compile argument into trust function.
 *
 * @param {Array|String} val
 * @private
 */

function compile (val) {
  if (!val) {
    throw new TypeError('argument is required')
  }

  var trust

  if (typeof val === 'string') {
    trust = [val]
  } else if (Array.isArray(val)) {
    trust = val.slice()
  } else {
    throw new TypeError('unsupported trust argument')
  }

  for (var i = 0; i < trust.length; i++) {
    val = trust[i]

    if (!Object.prototype.hasOwnProperty.call(IP_RANGES, val)) {
      continue
    }

    // Splice in pre-defined range
    val = IP_RANGES[val]
    trust.splice.apply(trust, [i, 1].concat(val))
    i += val.length - 1
  }

  return compileTrust(compileRangeSubnets(trust))
}

/**
 * Compile `arr` elements into range subnets.
 *
 * @param {Array} arr
 * @private
 */

function compileRangeSubnets (arr) {
  var rangeSubnets = new Array(arr.length)

  for (var i = 0; i < arr.length; i++) {
    rangeSubnets[i] = parseipNotation(arr[i])
  }

  return rangeSubnets
}

/**
 * Compile range subnet array into trust function.
 *
 * @param {Array} rangeSubnets
 * @private
 */

function compileTrust (rangeSubnets) {
  // Return optimized function based on length
  var len = rangeSubnets.length
  return len === 0
    ? trustNone
    : len === 1
      ? trustSingle(rangeSubnets[0])
      : trustMulti(rangeSubnets)
}

/**
 * Parse IP notation string into range subnet.
 *
 * @param {String} note
 * @private
 */

function parseipNotation (note) {
  var pos = note.lastIndexOf('/')
  var str = pos !== -1
    ? note.substring(0, pos)
    : note

  if (!isip(str)) {
    throw new TypeError('invalid IP address: ' + str)
  }

  var ip = parseip(str)

  if (pos === -1 && ip.kind() === 'ipv6' && ip.isIPv4MappedAddress()) {
    // Store as IPv4
    ip = ip.toIPv4Address()
  }

  var max = ip.kind() === 'ipv6'
    ? 128
    : 32

  var range = pos !== -1
    ? note.substring(pos + 1, note.length)
    : null

  if (range === null) {
    range = max
  } else if (DIGIT_REGEXP.test(range)) {
    range = parseInt(range, 10)
  } else if (ip.kind() === 'ipv4' && isip(range)) {
    range = parseNetmask(range)
  } else {
    range = null
  }

  if (range <= 0 || range > max) {
    throw new TypeError('invalid range on address: ' + note)
  }

  return [ip, range]
}

/**
 * Parse netmask string into CIDR range.
 *
 * @param {String} netmask
 * @private
 */

function parseNetmask (netmask) {
  var ip = parseip(netmask)
  var kind = ip.kind()

  return kind === 'ipv4'
    ? ip.prefixLengthFromSubnetMask()
    : null
}

/**
 * Determine address of proxied request.
 *
 * @param {Object} request
 * @param {Function|Array|String} trust
 * @public
 */

function proxyaddr (req, trust) {
  if (!req) {
    throw new TypeError('req argument is required')
  }

  if (!trust) {
    throw new TypeError('trust argument is required')
  }

  var addrs = alladdrs(req, trust)
  var addr = addrs[addrs.length - 1]

  return addr
}

/**
 * Static trust function to trust nothing.
 *
 * @private
 */

function trustNone () {
  return false
}

/**
 * Compile trust function for multiple subnets.
 *
 * @param {Array} subnets
 * @private
 */

function trustMulti (subnets) {
  return function trust (addr) {
    if (!isip(addr)) return false

    var ip = parseip(addr)
    var ipconv
    var kind = ip.kind()

    for (var i = 0; i < subnets.length; i++) {
      var subnet = subnets[i]
      var subnetip = subnet[0]
      var subnetkind = subnetip.kind()
      var subnetrange = subnet[1]
      var trusted = ip

      if (kind !== subnetkind) {
        if (subnetkind === 'ipv4' && !ip.isIPv4MappedAddress()) {
          // Incompatible IP addresses
          continue
        }

        if (!ipconv) {
          // Convert IP to match subnet IP kind
          ipconv = subnetkind === 'ipv4'
            ? ip.toIPv4Address()
            : ip.toIPv4MappedAddress()
        }

        trusted = ipconv
      }

      if (trusted.match(subnetip, subnetrange)) {
        return true
      }
    }

    return false
  }
}

/**
 * Compile trust function for single subnet.
 *
 * @param {Object} subnet
 * @private
 */

function trustSingle (subnet) {
  var subnetip = subnet[0]
  var subnetkind = subnetip.kind()
  var subnetisipv4 = subnetkind === 'ipv4'
  var subnetrange = subnet[1]

  return function trust (addr) {
    if (!isip(addr)) return false

    var ip = parseip(addr)
    var kind = ip.kind()

    if (kind !== subnetkind) {
      if (subnetisipv4 && !ip.isIPv4MappedAddress()) {
        // Incompatible IP addresses
        return false
      }

      // Convert IP to match subnet IP kind
      ip = subnetisipv4
        ? ip.toIPv4Address()
        : ip.toIPv4MappedAddress()
    }

    return ip.match(subnetip, subnetrange)
  }
}


/***/ }),

/***/ 86032:
/***/ ((module) => {

"use strict";


var replace = String.prototype.replace;
var percentTwenties = /%20/g;

var Format = {
    RFC1738: 'RFC1738',
    RFC3986: 'RFC3986'
};

module.exports = {
    'default': Format.RFC3986,
    formatters: {
        RFC1738: function (value) {
            return replace.call(value, percentTwenties, '+');
        },
        RFC3986: function (value) {
            return String(value);
        }
    },
    RFC1738: Format.RFC1738,
    RFC3986: Format.RFC3986
};


/***/ }),

/***/ 40240:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


var stringify = __nccwpck_require__(71293);
var parse = __nccwpck_require__(79091);
var formats = __nccwpck_require__(86032);

module.exports = {
    formats: formats,
    parse: parse,
    stringify: stringify
};


/***/ }),

/***/ 79091:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


var utils = __nccwpck_require__(25225);

var has = Object.prototype.hasOwnProperty;
var isArray = Array.isArray;

var defaults = {
    allowDots: false,
    allowEmptyArrays: false,
    allowPrototypes: false,
    allowSparse: false,
    arrayLimit: 20,
    charset: 'utf-8',
    charsetSentinel: false,
    comma: false,
    decodeDotInKeys: false,
    decoder: utils.decode,
    delimiter: '&',
    depth: 5,
    duplicates: 'combine',
    ignoreQueryPrefix: false,
    interpretNumericEntities: false,
    parameterLimit: 1000,
    parseArrays: true,
    plainObjects: false,
    strictDepth: false,
    strictNullHandling: false
};

var interpretNumericEntities = function (str) {
    return str.replace(/&#(\d+);/g, function ($0, numberStr) {
        return String.fromCharCode(parseInt(numberStr, 10));
    });
};

var parseArrayValue = function (val, options) {
    if (val && typeof val === 'string' && options.comma && val.indexOf(',') > -1) {
        return val.split(',');
    }

    return val;
};

// This is what browsers will submit when the ‚úì character occurs in an
// application/x-www-form-urlencoded body and the encoding of the page containing
// the form is iso-8859-1, or when the submitted form has an accept-charset
// attribute of iso-8859-1. Presumably also with other charsets that do not contain
// the ‚úì character, such as us-ascii.
var isoSentinel = 'utf8=%26%2310003%3B'; // encodeURIComponent('&#10003;')

// These are the percent-encoded utf-8 octets representing a checkmark, indicating that the request actually is utf-8 encoded.
var charsetSentinel = 'utf8=%E2%9C%93'; // encodeURIComponent('‚úì')

var parseValues = function parseQueryStringValues(str, options) {
    var obj = { __proto__: null };

    var cleanStr = options.ignoreQueryPrefix ? str.replace(/^\?/, '') : str;
    cleanStr = cleanStr.replace(/%5B/gi, '[').replace(/%5D/gi, ']');
    var limit = options.parameterLimit === Infinity ? undefined : options.parameterLimit;
    var parts = cleanStr.split(options.delimiter, limit);
    var skipIndex = -1; // Keep track of where the utf8 sentinel was found
    var i;

    var charset = options.charset;
    if (options.charsetSentinel) {
        for (i = 0; i < parts.length; ++i) {
            if (parts[i].indexOf('utf8=') === 0) {
                if (parts[i] === charsetSentinel) {
                    charset = 'utf-8';
                } else if (parts[i] === isoSentinel) {
                    charset = 'iso-8859-1';
                }
                skipIndex = i;
                i = parts.length; // The eslint settings do not allow break;
            }
        }
    }

    for (i = 0; i < parts.length; ++i) {
        if (i === skipIndex) {
            continue;
        }
        var part = parts[i];

        var bracketEqualsPos = part.indexOf(']=');
        var pos = bracketEqualsPos === -1 ? part.indexOf('=') : bracketEqualsPos + 1;

        var key, val;
        if (pos === -1) {
            key = options.decoder(part, defaults.decoder, charset, 'key');
            val = options.strictNullHandling ? null : '';
        } else {
            key = options.decoder(part.slice(0, pos), defaults.decoder, charset, 'key');
            val = utils.maybeMap(
                parseArrayValue(part.slice(pos + 1), options),
                function (encodedVal) {
                    return options.decoder(encodedVal, defaults.decoder, charset, 'value');
                }
            );
        }

        if (val && options.interpretNumericEntities && charset === 'iso-8859-1') {
            val = interpretNumericEntities(val);
        }

        if (part.indexOf('[]=') > -1) {
            val = isArray(val) ? [val] : val;
        }

        var existing = has.call(obj, key);
        if (existing && options.duplicates === 'combine') {
            obj[key] = utils.combine(obj[key], val);
        } else if (!existing || options.duplicates === 'last') {
            obj[key] = val;
        }
    }

    return obj;
};

var parseObject = function (chain, val, options, valuesParsed) {
    var leaf = valuesParsed ? val : parseArrayValue(val, options);

    for (var i = chain.length - 1; i >= 0; --i) {
        var obj;
        var root = chain[i];

        if (root === '[]' && options.parseArrays) {
            obj = options.allowEmptyArrays && (leaf === '' || (options.strictNullHandling && leaf === null))
                ? []
                : [].concat(leaf);
        } else {
            obj = options.plainObjects ? Object.create(null) : {};
            var cleanRoot = root.charAt(0) === '[' && root.charAt(root.length - 1) === ']' ? root.slice(1, -1) : root;
            var decodedRoot = options.decodeDotInKeys ? cleanRoot.replace(/%2E/g, '.') : cleanRoot;
            var index = parseInt(decodedRoot, 10);
            if (!options.parseArrays && decodedRoot === '') {
                obj = { 0: leaf };
            } else if (
                !isNaN(index)
                && root !== decodedRoot
                && String(index) === decodedRoot
                && index >= 0
                && (options.parseArrays && index <= options.arrayLimit)
            ) {
                obj = [];
                obj[index] = leaf;
            } else if (decodedRoot !== '__proto__') {
                obj[decodedRoot] = leaf;
            }
        }

        leaf = obj;
    }

    return leaf;
};

var parseKeys = function parseQueryStringKeys(givenKey, val, options, valuesParsed) {
    if (!givenKey) {
        return;
    }

    // Transform dot notation to bracket notation
    var key = options.allowDots ? givenKey.replace(/\.([^.[]+)/g, '[$1]') : givenKey;

    // The regex chunks

    var brackets = /(\[[^[\]]*])/;
    var child = /(\[[^[\]]*])/g;

    // Get the parent

    var segment = options.depth > 0 && brackets.exec(key);
    var parent = segment ? key.slice(0, segment.index) : key;

    // Stash the parent if it exists

    var keys = [];
    if (parent) {
        // If we aren't using plain objects, optionally prefix keys that would overwrite object prototype properties
        if (!options.plainObjects && has.call(Object.prototype, parent)) {
            if (!options.allowPrototypes) {
                return;
            }
        }

        keys.push(parent);
    }

    // Loop through children appending to the array until we hit depth

    var i = 0;
    while (options.depth > 0 && (segment = child.exec(key)) !== null && i < options.depth) {
        i += 1;
        if (!options.plainObjects && has.call(Object.prototype, segment[1].slice(1, -1))) {
            if (!options.allowPrototypes) {
                return;
            }
        }
        keys.push(segment[1]);
    }

    // If there's a remainder, check strictDepth option for throw, else just add whatever is left

    if (segment) {
        if (options.strictDepth === true) {
            throw new RangeError('Input depth exceeded depth option of ' + options.depth + ' and strictDepth is true');
        }
        keys.push('[' + key.slice(segment.index) + ']');
    }

    return parseObject(keys, val, options, valuesParsed);
};

var normalizeParseOptions = function normalizeParseOptions(opts) {
    if (!opts) {
        return defaults;
    }

    if (typeof opts.allowEmptyArrays !== 'undefined' && typeof opts.allowEmptyArrays !== 'boolean') {
        throw new TypeError('`allowEmptyArrays` option can only be `true` or `false`, when provided');
    }

    if (typeof opts.decodeDotInKeys !== 'undefined' && typeof opts.decodeDotInKeys !== 'boolean') {
        throw new TypeError('`decodeDotInKeys` option can only be `true` or `false`, when provided');
    }

    if (opts.decoder !== null && typeof opts.decoder !== 'undefined' && typeof opts.decoder !== 'function') {
        throw new TypeError('Decoder has to be a function.');
    }

    if (typeof opts.charset !== 'undefined' && opts.charset !== 'utf-8' && opts.charset !== 'iso-8859-1') {
        throw new TypeError('The charset option must be either utf-8, iso-8859-1, or undefined');
    }
    var charset = typeof opts.charset === 'undefined' ? defaults.charset : opts.charset;

    var duplicates = typeof opts.duplicates === 'undefined' ? defaults.duplicates : opts.duplicates;

    if (duplicates !== 'combine' && duplicates !== 'first' && duplicates !== 'last') {
        throw new TypeError('The duplicates option must be either combine, first, or last');
    }

    var allowDots = typeof opts.allowDots === 'undefined' ? opts.decodeDotInKeys === true ? true : defaults.allowDots : !!opts.allowDots;

    return {
        allowDots: allowDots,
        allowEmptyArrays: typeof opts.allowEmptyArrays === 'boolean' ? !!opts.allowEmptyArrays : defaults.allowEmptyArrays,
        allowPrototypes: typeof opts.allowPrototypes === 'boolean' ? opts.allowPrototypes : defaults.allowPrototypes,
        allowSparse: typeof opts.allowSparse === 'boolean' ? opts.allowSparse : defaults.allowSparse,
        arrayLimit: typeof opts.arrayLimit === 'number' ? opts.arrayLimit : defaults.arrayLimit,
        charset: charset,
        charsetSentinel: typeof opts.charsetSentinel === 'boolean' ? opts.charsetSentinel : defaults.charsetSentinel,
        comma: typeof opts.comma === 'boolean' ? opts.comma : defaults.comma,
        decodeDotInKeys: typeof opts.decodeDotInKeys === 'boolean' ? opts.decodeDotInKeys : defaults.decodeDotInKeys,
        decoder: typeof opts.decoder === 'function' ? opts.decoder : defaults.decoder,
        delimiter: typeof opts.delimiter === 'string' || utils.isRegExp(opts.delimiter) ? opts.delimiter : defaults.delimiter,
        // eslint-disable-next-line no-implicit-coercion, no-extra-parens
        depth: (typeof opts.depth === 'number' || opts.depth === false) ? +opts.depth : defaults.depth,
        duplicates: duplicates,
        ignoreQueryPrefix: opts.ignoreQueryPrefix === true,
        interpretNumericEntities: typeof opts.interpretNumericEntities === 'boolean' ? opts.interpretNumericEntities : defaults.interpretNumericEntities,
        parameterLimit: typeof opts.parameterLimit === 'number' ? opts.parameterLimit : defaults.parameterLimit,
        parseArrays: opts.parseArrays !== false,
        plainObjects: typeof opts.plainObjects === 'boolean' ? opts.plainObjects : defaults.plainObjects,
        strictDepth: typeof opts.strictDepth === 'boolean' ? !!opts.strictDepth : defaults.strictDepth,
        strictNullHandling: typeof opts.strictNullHandling === 'boolean' ? opts.strictNullHandling : defaults.strictNullHandling
    };
};

module.exports = function (str, opts) {
    var options = normalizeParseOptions(opts);

    if (str === '' || str === null || typeof str === 'undefined') {
        return options.plainObjects ? Object.create(null) : {};
    }

    var tempObj = typeof str === 'string' ? parseValues(str, options) : str;
    var obj = options.plainObjects ? Object.create(null) : {};

    // Iterate over the keys and setup the new object

    var keys = Object.keys(tempObj);
    for (var i = 0; i < keys.length; ++i) {
        var key = keys[i];
        var newObj = parseKeys(key, tempObj[key], options, typeof str === 'string');
        obj = utils.merge(obj, newObj, options);
    }

    if (options.allowSparse === true) {
        return obj;
    }

    return utils.compact(obj);
};


/***/ }),

/***/ 71293:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


var getSideChannel = __nccwpck_require__(94753);
var utils = __nccwpck_require__(25225);
var formats = __nccwpck_require__(86032);
var has = Object.prototype.hasOwnProperty;

var arrayPrefixGenerators = {
    brackets: function brackets(prefix) {
        return prefix + '[]';
    },
    comma: 'comma',
    indices: function indices(prefix, key) {
        return prefix + '[' + key + ']';
    },
    repeat: function repeat(prefix) {
        return prefix;
    }
};

var isArray = Array.isArray;
var push = Array.prototype.push;
var pushToArray = function (arr, valueOrArray) {
    push.apply(arr, isArray(valueOrArray) ? valueOrArray : [valueOrArray]);
};

var toISO = Date.prototype.toISOString;

var defaultFormat = formats['default'];
var defaults = {
    addQueryPrefix: false,
    allowDots: false,
    allowEmptyArrays: false,
    arrayFormat: 'indices',
    charset: 'utf-8',
    charsetSentinel: false,
    delimiter: '&',
    encode: true,
    encodeDotInKeys: false,
    encoder: utils.encode,
    encodeValuesOnly: false,
    format: defaultFormat,
    formatter: formats.formatters[defaultFormat],
    // deprecated
    indices: false,
    serializeDate: function serializeDate(date) {
        return toISO.call(date);
    },
    skipNulls: false,
    strictNullHandling: false
};

var isNonNullishPrimitive = function isNonNullishPrimitive(v) {
    return typeof v === 'string'
        || typeof v === 'number'
        || typeof v === 'boolean'
        || typeof v === 'symbol'
        || typeof v === 'bigint';
};

var sentinel = {};

var stringify = function stringify(
    object,
    prefix,
    generateArrayPrefix,
    commaRoundTrip,
    allowEmptyArrays,
    strictNullHandling,
    skipNulls,
    encodeDotInKeys,
    encoder,
    filter,
    sort,
    allowDots,
    serializeDate,
    format,
    formatter,
    encodeValuesOnly,
    charset,
    sideChannel
) {
    var obj = object;

    var tmpSc = sideChannel;
    var step = 0;
    var findFlag = false;
    while ((tmpSc = tmpSc.get(sentinel)) !== void undefined && !findFlag) {
        // Where object last appeared in the ref tree
        var pos = tmpSc.get(object);
        step += 1;
        if (typeof pos !== 'undefined') {
            if (pos === step) {
                throw new RangeError('Cyclic object value');
            } else {
                findFlag = true; // Break while
            }
        }
        if (typeof tmpSc.get(sentinel) === 'undefined') {
            step = 0;
        }
    }

    if (typeof filter === 'function') {
        obj = filter(prefix, obj);
    } else if (obj instanceof Date) {
        obj = serializeDate(obj);
    } else if (generateArrayPrefix === 'comma' && isArray(obj)) {
        obj = utils.maybeMap(obj, function (value) {
            if (value instanceof Date) {
                return serializeDate(value);
            }
            return value;
        });
    }

    if (obj === null) {
        if (strictNullHandling) {
            return encoder && !encodeValuesOnly ? encoder(prefix, defaults.encoder, charset, 'key', format) : prefix;
        }

        obj = '';
    }

    if (isNonNullishPrimitive(obj) || utils.isBuffer(obj)) {
        if (encoder) {
            var keyValue = encodeValuesOnly ? prefix : encoder(prefix, defaults.encoder, charset, 'key', format);
            return [formatter(keyValue) + '=' + formatter(encoder(obj, defaults.encoder, charset, 'value', format))];
        }
        return [formatter(prefix) + '=' + formatter(String(obj))];
    }

    var values = [];

    if (typeof obj === 'undefined') {
        return values;
    }

    var objKeys;
    if (generateArrayPrefix === 'comma' && isArray(obj)) {
        // we need to join elements in
        if (encodeValuesOnly && encoder) {
            obj = utils.maybeMap(obj, encoder);
        }
        objKeys = [{ value: obj.length > 0 ? obj.join(',') || null : void undefined }];
    } else if (isArray(filter)) {
        objKeys = filter;
    } else {
        var keys = Object.keys(obj);
        objKeys = sort ? keys.sort(sort) : keys;
    }

    var encodedPrefix = encodeDotInKeys ? prefix.replace(/\./g, '%2E') : prefix;

    var adjustedPrefix = commaRoundTrip && isArray(obj) && obj.length === 1 ? encodedPrefix + '[]' : encodedPrefix;

    if (allowEmptyArrays && isArray(obj) && obj.length === 0) {
        return adjustedPrefix + '[]';
    }

    for (var j = 0; j < objKeys.length; ++j) {
        var key = objKeys[j];
        var value = typeof key === 'object' && typeof key.value !== 'undefined' ? key.value : obj[key];

        if (skipNulls && value === null) {
            continue;
        }

        var encodedKey = allowDots && encodeDotInKeys ? key.replace(/\./g, '%2E') : key;
        var keyPrefix = isArray(obj)
            ? typeof generateArrayPrefix === 'function' ? generateArrayPrefix(adjustedPrefix, encodedKey) : adjustedPrefix
            : adjustedPrefix + (allowDots ? '.' + encodedKey : '[' + encodedKey + ']');

        sideChannel.set(object, step);
        var valueSideChannel = getSideChannel();
        valueSideChannel.set(sentinel, sideChannel);
        pushToArray(values, stringify(
            value,
            keyPrefix,
            generateArrayPrefix,
            commaRoundTrip,
            allowEmptyArrays,
            strictNullHandling,
            skipNulls,
            encodeDotInKeys,
            generateArrayPrefix === 'comma' && encodeValuesOnly && isArray(obj) ? null : encoder,
            filter,
            sort,
            allowDots,
            serializeDate,
            format,
            formatter,
            encodeValuesOnly,
            charset,
            valueSideChannel
        ));
    }

    return values;
};

var normalizeStringifyOptions = function normalizeStringifyOptions(opts) {
    if (!opts) {
        return defaults;
    }

    if (typeof opts.allowEmptyArrays !== 'undefined' && typeof opts.allowEmptyArrays !== 'boolean') {
        throw new TypeError('`allowEmptyArrays` option can only be `true` or `false`, when provided');
    }

    if (typeof opts.encodeDotInKeys !== 'undefined' && typeof opts.encodeDotInKeys !== 'boolean') {
        throw new TypeError('`encodeDotInKeys` option can only be `true` or `false`, when provided');
    }

    if (opts.encoder !== null && typeof opts.encoder !== 'undefined' && typeof opts.encoder !== 'function') {
        throw new TypeError('Encoder has to be a function.');
    }

    var charset = opts.charset || defaults.charset;
    if (typeof opts.charset !== 'undefined' && opts.charset !== 'utf-8' && opts.charset !== 'iso-8859-1') {
        throw new TypeError('The charset option must be either utf-8, iso-8859-1, or undefined');
    }

    var format = formats['default'];
    if (typeof opts.format !== 'undefined') {
        if (!has.call(formats.formatters, opts.format)) {
            throw new TypeError('Unknown format option provided.');
        }
        format = opts.format;
    }
    var formatter = formats.formatters[format];

    var filter = defaults.filter;
    if (typeof opts.filter === 'function' || isArray(opts.filter)) {
        filter = opts.filter;
    }

    var arrayFormat;
    if (opts.arrayFormat in arrayPrefixGenerators) {
        arrayFormat = opts.arrayFormat;
    } else if ('indices' in opts) {
        arrayFormat = opts.indices ? 'indices' : 'repeat';
    } else {
        arrayFormat = defaults.arrayFormat;
    }

    if ('commaRoundTrip' in opts && typeof opts.commaRoundTrip !== 'boolean') {
        throw new TypeError('`commaRoundTrip` must be a boolean, or absent');
    }

    var allowDots = typeof opts.allowDots === 'undefined' ? opts.encodeDotInKeys === true ? true : defaults.allowDots : !!opts.allowDots;

    return {
        addQueryPrefix: typeof opts.addQueryPrefix === 'boolean' ? opts.addQueryPrefix : defaults.addQueryPrefix,
        allowDots: allowDots,
        allowEmptyArrays: typeof opts.allowEmptyArrays === 'boolean' ? !!opts.allowEmptyArrays : defaults.allowEmptyArrays,
        arrayFormat: arrayFormat,
        charset: charset,
        charsetSentinel: typeof opts.charsetSentinel === 'boolean' ? opts.charsetSentinel : defaults.charsetSentinel,
        commaRoundTrip: opts.commaRoundTrip,
        delimiter: typeof opts.delimiter === 'undefined' ? defaults.delimiter : opts.delimiter,
        encode: typeof opts.encode === 'boolean' ? opts.encode : defaults.encode,
        encodeDotInKeys: typeof opts.encodeDotInKeys === 'boolean' ? opts.encodeDotInKeys : defaults.encodeDotInKeys,
        encoder: typeof opts.encoder === 'function' ? opts.encoder : defaults.encoder,
        encodeValuesOnly: typeof opts.encodeValuesOnly === 'boolean' ? opts.encodeValuesOnly : defaults.encodeValuesOnly,
        filter: filter,
        format: format,
        formatter: formatter,
        serializeDate: typeof opts.serializeDate === 'function' ? opts.serializeDate : defaults.serializeDate,
        skipNulls: typeof opts.skipNulls === 'boolean' ? opts.skipNulls : defaults.skipNulls,
        sort: typeof opts.sort === 'function' ? opts.sort : null,
        strictNullHandling: typeof opts.strictNullHandling === 'boolean' ? opts.strictNullHandling : defaults.strictNullHandling
    };
};

module.exports = function (object, opts) {
    var obj = object;
    var options = normalizeStringifyOptions(opts);

    var objKeys;
    var filter;

    if (typeof options.filter === 'function') {
        filter = options.filter;
        obj = filter('', obj);
    } else if (isArray(options.filter)) {
        filter = options.filter;
        objKeys = filter;
    }

    var keys = [];

    if (typeof obj !== 'object' || obj === null) {
        return '';
    }

    var generateArrayPrefix = arrayPrefixGenerators[options.arrayFormat];
    var commaRoundTrip = generateArrayPrefix === 'comma' && options.commaRoundTrip;

    if (!objKeys) {
        objKeys = Object.keys(obj);
    }

    if (options.sort) {
        objKeys.sort(options.sort);
    }

    var sideChannel = getSideChannel();
    for (var i = 0; i < objKeys.length; ++i) {
        var key = objKeys[i];

        if (options.skipNulls && obj[key] === null) {
            continue;
        }
        pushToArray(keys, stringify(
            obj[key],
            key,
            generateArrayPrefix,
            commaRoundTrip,
            options.allowEmptyArrays,
            options.strictNullHandling,
            options.skipNulls,
            options.encodeDotInKeys,
            options.encode ? options.encoder : null,
            options.filter,
            options.sort,
            options.allowDots,
            options.serializeDate,
            options.format,
            options.formatter,
            options.encodeValuesOnly,
            options.charset,
            sideChannel
        ));
    }

    var joined = keys.join(options.delimiter);
    var prefix = options.addQueryPrefix === true ? '?' : '';

    if (options.charsetSentinel) {
        if (options.charset === 'iso-8859-1') {
            // encodeURIComponent('&#10003;'), the "numeric entity" representation of a checkmark
            prefix += 'utf8=%26%2310003%3B&';
        } else {
            // encodeURIComponent('‚úì')
            prefix += 'utf8=%E2%9C%93&';
        }
    }

    return joined.length > 0 ? prefix + joined : '';
};


/***/ }),

/***/ 25225:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


var formats = __nccwpck_require__(86032);

var has = Object.prototype.hasOwnProperty;
var isArray = Array.isArray;

var hexTable = (function () {
    var array = [];
    for (var i = 0; i < 256; ++i) {
        array.push('%' + ((i < 16 ? '0' : '') + i.toString(16)).toUpperCase());
    }

    return array;
}());

var compactQueue = function compactQueue(queue) {
    while (queue.length > 1) {
        var item = queue.pop();
        var obj = item.obj[item.prop];

        if (isArray(obj)) {
            var compacted = [];

            for (var j = 0; j < obj.length; ++j) {
                if (typeof obj[j] !== 'undefined') {
                    compacted.push(obj[j]);
                }
            }

            item.obj[item.prop] = compacted;
        }
    }
};

var arrayToObject = function arrayToObject(source, options) {
    var obj = options && options.plainObjects ? Object.create(null) : {};
    for (var i = 0; i < source.length; ++i) {
        if (typeof source[i] !== 'undefined') {
            obj[i] = source[i];
        }
    }

    return obj;
};

var merge = function merge(target, source, options) {
    /* eslint no-param-reassign: 0 */
    if (!source) {
        return target;
    }

    if (typeof source !== 'object') {
        if (isArray(target)) {
            target.push(source);
        } else if (target && typeof target === 'object') {
            if ((options && (options.plainObjects || options.allowPrototypes)) || !has.call(Object.prototype, source)) {
                target[source] = true;
            }
        } else {
            return [target, source];
        }

        return target;
    }

    if (!target || typeof target !== 'object') {
        return [target].concat(source);
    }

    var mergeTarget = target;
    if (isArray(target) && !isArray(source)) {
        mergeTarget = arrayToObject(target, options);
    }

    if (isArray(target) && isArray(source)) {
        source.forEach(function (item, i) {
            if (has.call(target, i)) {
                var targetItem = target[i];
                if (targetItem && typeof targetItem === 'object' && item && typeof item === 'object') {
                    target[i] = merge(targetItem, item, options);
                } else {
                    target.push(item);
                }
            } else {
                target[i] = item;
            }
        });
        return target;
    }

    return Object.keys(source).reduce(function (acc, key) {
        var value = source[key];

        if (has.call(acc, key)) {
            acc[key] = merge(acc[key], value, options);
        } else {
            acc[key] = value;
        }
        return acc;
    }, mergeTarget);
};

var assign = function assignSingleSource(target, source) {
    return Object.keys(source).reduce(function (acc, key) {
        acc[key] = source[key];
        return acc;
    }, target);
};

var decode = function (str, decoder, charset) {
    var strWithoutPlus = str.replace(/\+/g, ' ');
    if (charset === 'iso-8859-1') {
        // unescape never throws, no try...catch needed:
        return strWithoutPlus.replace(/%[0-9a-f]{2}/gi, unescape);
    }
    // utf-8
    try {
        return decodeURIComponent(strWithoutPlus);
    } catch (e) {
        return strWithoutPlus;
    }
};

var limit = 1024;

/* eslint operator-linebreak: [2, "before"] */

var encode = function encode(str, defaultEncoder, charset, kind, format) {
    // This code was originally written by Brian White (mscdex) for the io.js core querystring library.
    // It has been adapted here for stricter adherence to RFC 3986
    if (str.length === 0) {
        return str;
    }

    var string = str;
    if (typeof str === 'symbol') {
        string = Symbol.prototype.toString.call(str);
    } else if (typeof str !== 'string') {
        string = String(str);
    }

    if (charset === 'iso-8859-1') {
        return escape(string).replace(/%u[0-9a-f]{4}/gi, function ($0) {
            return '%26%23' + parseInt($0.slice(2), 16) + '%3B';
        });
    }

    var out = '';
    for (var j = 0; j < string.length; j += limit) {
        var segment = string.length >= limit ? string.slice(j, j + limit) : string;
        var arr = [];

        for (var i = 0; i < segment.length; ++i) {
            var c = segment.charCodeAt(i);
            if (
                c === 0x2D // -
                || c === 0x2E // .
                || c === 0x5F // _
                || c === 0x7E // ~
                || (c >= 0x30 && c <= 0x39) // 0-9
                || (c >= 0x41 && c <= 0x5A) // a-z
                || (c >= 0x61 && c <= 0x7A) // A-Z
                || (format === formats.RFC1738 && (c === 0x28 || c === 0x29)) // ( )
            ) {
                arr[arr.length] = segment.charAt(i);
                continue;
            }

            if (c < 0x80) {
                arr[arr.length] = hexTable[c];
                continue;
            }

            if (c < 0x800) {
                arr[arr.length] = hexTable[0xC0 | (c >> 6)]
                    + hexTable[0x80 | (c & 0x3F)];
                continue;
            }

            if (c < 0xD800 || c >= 0xE000) {
                arr[arr.length] = hexTable[0xE0 | (c >> 12)]
                    + hexTable[0x80 | ((c >> 6) & 0x3F)]
                    + hexTable[0x80 | (c & 0x3F)];
                continue;
            }

            i += 1;
            c = 0x10000 + (((c & 0x3FF) << 10) | (segment.charCodeAt(i) & 0x3FF));

            arr[arr.length] = hexTable[0xF0 | (c >> 18)]
                + hexTable[0x80 | ((c >> 12) & 0x3F)]
                + hexTable[0x80 | ((c >> 6) & 0x3F)]
                + hexTable[0x80 | (c & 0x3F)];
        }

        out += arr.join('');
    }

    return out;
};

var compact = function compact(value) {
    var queue = [{ obj: { o: value }, prop: 'o' }];
    var refs = [];

    for (var i = 0; i < queue.length; ++i) {
        var item = queue[i];
        var obj = item.obj[item.prop];

        var keys = Object.keys(obj);
        for (var j = 0; j < keys.length; ++j) {
            var key = keys[j];
            var val = obj[key];
            if (typeof val === 'object' && val !== null && refs.indexOf(val) === -1) {
                queue.push({ obj: obj, prop: key });
                refs.push(val);
            }
        }
    }

    compactQueue(queue);

    return value;
};

var isRegExp = function isRegExp(obj) {
    return Object.prototype.toString.call(obj) === '[object RegExp]';
};

var isBuffer = function isBuffer(obj) {
    if (!obj || typeof obj !== 'object') {
        return false;
    }

    return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));
};

var combine = function combine(a, b) {
    return [].concat(a, b);
};

var maybeMap = function maybeMap(val, fn) {
    if (isArray(val)) {
        var mapped = [];
        for (var i = 0; i < val.length; i += 1) {
            mapped.push(fn(val[i]));
        }
        return mapped;
    }
    return fn(val);
};

module.exports = {
    arrayToObject: arrayToObject,
    assign: assign,
    combine: combine,
    compact: compact,
    decode: decode,
    encode: encode,
    isBuffer: isBuffer,
    isRegExp: isRegExp,
    maybeMap: maybeMap,
    merge: merge
};


/***/ }),

/***/ 74031:
/***/ ((module) => {

"use strict";
/*!
 * range-parser
 * Copyright(c) 2012-2014 TJ Holowaychuk
 * Copyright(c) 2015-2016 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module exports.
 * @public
 */

module.exports = rangeParser

/**
 * Parse "Range" header `str` relative to the given file `size`.
 *
 * @param {Number} size
 * @param {String} str
 * @param {Object} [options]
 * @return {Array}
 * @public
 */

function rangeParser (size, str, options) {
  if (typeof str !== 'string') {
    throw new TypeError('argument str must be a string')
  }

  var index = str.indexOf('=')

  if (index === -1) {
    return -2
  }

  // split the range string
  var arr = str.slice(index + 1).split(',')
  var ranges = []

  // add ranges type
  ranges.type = str.slice(0, index)

  // parse all ranges
  for (var i = 0; i < arr.length; i++) {
    var range = arr[i].split('-')
    var start = parseInt(range[0], 10)
    var end = parseInt(range[1], 10)

    // -nnn
    if (isNaN(start)) {
      start = size - end
      end = size - 1
    // nnn-
    } else if (isNaN(end)) {
      end = size - 1
    }

    // limit last-byte-pos to current length
    if (end > size - 1) {
      end = size - 1
    }

    // invalid or unsatisifiable
    if (isNaN(start) || isNaN(end) || start > end || start < 0) {
      continue
    }

    // add range
    ranges.push({
      start: start,
      end: end
    })
  }

  if (ranges.length < 1) {
    // unsatisifiable
    return -1
  }

  return options && options.combine
    ? combineRanges(ranges)
    : ranges
}

/**
 * Combine overlapping & adjacent ranges.
 * @private
 */

function combineRanges (ranges) {
  var ordered = ranges.map(mapWithIndex).sort(sortByRangeStart)

  for (var j = 0, i = 1; i < ordered.length; i++) {
    var range = ordered[i]
    var current = ordered[j]

    if (range.start > current.end + 1) {
      // next range
      ordered[++j] = range
    } else if (range.end > current.end) {
      // extend range
      current.end = range.end
      current.index = Math.min(current.index, range.index)
    }
  }

  // trim ordered array
  ordered.length = j + 1

  // generate combined range
  var combined = ordered.sort(sortByRangeIndex).map(mapWithoutIndex)

  // copy ranges type
  combined.type = ranges.type

  return combined
}

/**
 * Map function to add index value to ranges.
 * @private
 */

function mapWithIndex (range, index) {
  return {
    start: range.start,
    end: range.end,
    index: index
  }
}

/**
 * Map function to remove index value from ranges.
 * @private
 */

function mapWithoutIndex (range) {
  return {
    start: range.start,
    end: range.end
  }
}

/**
 * Sort function to sort ranges by index.
 * @private
 */

function sortByRangeIndex (a, b) {
  return a.index - b.index
}

/**
 * Sort function to sort ranges by start position.
 * @private
 */

function sortByRangeStart (a, b) {
  return a.start - b.start
}


/***/ }),

/***/ 60949:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";
/*!
 * raw-body
 * Copyright(c) 2013-2014 Jonathan Ong
 * Copyright(c) 2014-2022 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module dependencies.
 * @private
 */

var asyncHooks = tryRequireAsyncHooks()
var bytes = __nccwpck_require__(34531)
var createError = __nccwpck_require__(78024)
var iconv = __nccwpck_require__(79073)
var unpipe = __nccwpck_require__(66367)

/**
 * Module exports.
 * @public
 */

module.exports = getRawBody

/**
 * Module variables.
 * @private
 */

var ICONV_ENCODING_MESSAGE_REGEXP = /^Encoding not recognized: /

/**
 * Get the decoder for a given encoding.
 *
 * @param {string} encoding
 * @private
 */

function getDecoder (encoding) {
  if (!encoding) return null

  try {
    return iconv.getDecoder(encoding)
  } catch (e) {
    // error getting decoder
    if (!ICONV_ENCODING_MESSAGE_REGEXP.test(e.message)) throw e

    // the encoding was not found
    throw createError(415, 'specified encoding unsupported', {
      encoding: encoding,
      type: 'encoding.unsupported'
    })
  }
}

/**
 * Get the raw body of a stream (typically HTTP).
 *
 * @param {object} stream
 * @param {object|string|function} [options]
 * @param {function} [callback]
 * @public
 */

function getRawBody (stream, options, callback) {
  var done = callback
  var opts = options || {}

  // light validation
  if (stream === undefined) {
    throw new TypeError('argument stream is required')
  } else if (typeof stream !== 'object' || stream === null || typeof stream.on !== 'function') {
    throw new TypeError('argument stream must be a stream')
  }

  if (options === true || typeof options === 'string') {
    // short cut for encoding
    opts = {
      encoding: options
    }
  }

  if (typeof options === 'function') {
    done = options
    opts = {}
  }

  // validate callback is a function, if provided
  if (done !== undefined && typeof done !== 'function') {
    throw new TypeError('argument callback must be a function')
  }

  // require the callback without promises
  if (!done && !global.Promise) {
    throw new TypeError('argument callback is required')
  }

  // get encoding
  var encoding = opts.encoding !== true
    ? opts.encoding
    : 'utf-8'

  // convert the limit to an integer
  var limit = bytes.parse(opts.limit)

  // convert the expected length to an integer
  var length = opts.length != null && !isNaN(opts.length)
    ? parseInt(opts.length, 10)
    : null

  if (done) {
    // classic callback style
    return readStream(stream, encoding, length, limit, wrap(done))
  }

  return new Promise(function executor (resolve, reject) {
    readStream(stream, encoding, length, limit, function onRead (err, buf) {
      if (err) return reject(err)
      resolve(buf)
    })
  })
}

/**
 * Halt a stream.
 *
 * @param {Object} stream
 * @private
 */

function halt (stream) {
  // unpipe everything from the stream
  unpipe(stream)

  // pause stream
  if (typeof stream.pause === 'function') {
    stream.pause()
  }
}

/**
 * Read the data from the stream.
 *
 * @param {object} stream
 * @param {string} encoding
 * @param {number} length
 * @param {number} limit
 * @param {function} callback
 * @public
 */

function readStream (stream, encoding, length, limit, callback) {
  var complete = false
  var sync = true

  // check the length and limit options.
  // note: we intentionally leave the stream paused,
  // so users should handle the stream themselves.
  if (limit !== null && length !== null && length > limit) {
    return done(createError(413, 'request entity too large', {
      expected: length,
      length: length,
      limit: limit,
      type: 'entity.too.large'
    }))
  }

  // streams1: assert request encoding is buffer.
  // streams2+: assert the stream encoding is buffer.
  //   stream._decoder: streams1
  //   state.encoding: streams2
  //   state.decoder: streams2, specifically < 0.10.6
  var state = stream._readableState
  if (stream._decoder || (state && (state.encoding || state.decoder))) {
    // developer error
    return done(createError(500, 'stream encoding should not be set', {
      type: 'stream.encoding.set'
    }))
  }

  if (typeof stream.readable !== 'undefined' && !stream.readable) {
    return done(createError(500, 'stream is not readable', {
      type: 'stream.not.readable'
    }))
  }

  var received = 0
  var decoder

  try {
    decoder = getDecoder(encoding)
  } catch (err) {
    return done(err)
  }

  var buffer = decoder
    ? ''
    : []

  // attach listeners
  stream.on('aborted', onAborted)
  stream.on('close', cleanup)
  stream.on('data', onData)
  stream.on('end', onEnd)
  stream.on('error', onEnd)

  // mark sync section complete
  sync = false

  function done () {
    var args = new Array(arguments.length)

    // copy arguments
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i]
    }

    // mark complete
    complete = true

    if (sync) {
      process.nextTick(invokeCallback)
    } else {
      invokeCallback()
    }

    function invokeCallback () {
      cleanup()

      if (args[0]) {
        // halt the stream on error
        halt(stream)
      }

      callback.apply(null, args)
    }
  }

  function onAborted () {
    if (complete) return

    done(createError(400, 'request aborted', {
      code: 'ECONNABORTED',
      expected: length,
      length: length,
      received: received,
      type: 'request.aborted'
    }))
  }

  function onData (chunk) {
    if (complete) return

    received += chunk.length

    if (limit !== null && received > limit) {
      done(createError(413, 'request entity too large', {
        limit: limit,
        received: received,
        type: 'entity.too.large'
      }))
    } else if (decoder) {
      buffer += decoder.write(chunk)
    } else {
      buffer.push(chunk)
    }
  }

  function onEnd (err) {
    if (complete) return
    if (err) return done(err)

    if (length !== null && received !== length) {
      done(createError(400, 'request size did not match content length', {
        expected: length,
        length: length,
        received: received,
        type: 'request.size.invalid'
      }))
    } else {
      var string = decoder
        ? buffer + (decoder.end() || '')
        : Buffer.concat(buffer)
      done(null, string)
    }
  }

  function cleanup () {
    buffer = null

    stream.removeListener('aborted', onAborted)
    stream.removeListener('data', onData)
    stream.removeListener('end', onEnd)
    stream.removeListener('error', onEnd)
    stream.removeListener('close', cleanup)
  }
}

/**
 * Try to require async_hooks
 * @private
 */

function tryRequireAsyncHooks () {
  try {
    return __nccwpck_require__(90290)
  } catch (e) {
    return {}
  }
}

/**
 * Wrap function with async resource, if possible.
 * AsyncResource.bind static method backported.
 * @private
 */

function wrap (fn) {
  var res

  // create anonymous resource
  if (asyncHooks.AsyncResource) {
    res = new asyncHooks.AsyncResource(fn.name || 'bound-anonymous-fn')
  }

  // incompatible node.js
  if (!res || !res.runInAsyncScope) {
    return fn
  }

  // return bound function
  return res.runInAsyncScope.bind(res, fn, null)
}


/***/ }),

/***/ 745:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

var Buffer = (__nccwpck_require__(12803).Buffer);

// Multibyte codec. In this scheme, a character is represented by 1 or more bytes.
// Our codec supports UTF-16 surrogates, extensions for GB18030 and unicode sequences.
// To save memory and loading time, we read table files only when requested.

exports._dbcs = DBCSCodec;

var UNASSIGNED = -1,
    GB18030_CODE = -2,
    SEQ_START  = -10,
    NODE_START = -1000,
    UNASSIGNED_NODE = new Array(0x100),
    DEF_CHAR = -1;

for (var i = 0; i < 0x100; i++)
    UNASSIGNED_NODE[i] = UNASSIGNED;


// Class DBCSCodec reads and initializes mapping tables.
function DBCSCodec(codecOptions, iconv) {
    this.encodingName = codecOptions.encodingName;
    if (!codecOptions)
        throw new Error("DBCS codec is called without the data.")
    if (!codecOptions.table)
        throw new Error("Encoding '" + this.encodingName + "' has no data.");

    // Load tables.
    var mappingTable = codecOptions.table();


    // Decode tables: MBCS -> Unicode.

    // decodeTables is a trie, encoded as an array of arrays of integers. Internal arrays are trie nodes and all have len = 256.
    // Trie root is decodeTables[0].
    // Values: >=  0 -> unicode character code. can be > 0xFFFF
    //         == UNASSIGNED -> unknown/unassigned sequence.
    //         == GB18030_CODE -> this is the end of a GB18030 4-byte sequence.
    //         <= NODE_START -> index of the next node in our trie to process next byte.
    //         <= SEQ_START  -> index of the start of a character code sequence, in decodeTableSeq.
    this.decodeTables = [];
    this.decodeTables[0] = UNASSIGNED_NODE.slice(0); // Create root node.

    // Sometimes a MBCS char corresponds to a sequence of unicode chars. We store them as arrays of integers here. 
    this.decodeTableSeq = [];

    // Actual mapping tables consist of chunks. Use them to fill up decode tables.
    for (var i = 0; i < mappingTable.length; i++)
        this._addDecodeChunk(mappingTable[i]);

    this.defaultCharUnicode = iconv.defaultCharUnicode;

    
    // Encode tables: Unicode -> DBCS.

    // `encodeTable` is array mapping from unicode char to encoded char. All its values are integers for performance.
    // Because it can be sparse, it is represented as array of buckets by 256 chars each. Bucket can be null.
    // Values: >=  0 -> it is a normal char. Write the value (if <=256 then 1 byte, if <=65536 then 2 bytes, etc.).
    //         == UNASSIGNED -> no conversion found. Output a default char.
    //         <= SEQ_START  -> it's an index in encodeTableSeq, see below. The character starts a sequence.
    this.encodeTable = [];
    
    // `encodeTableSeq` is used when a sequence of unicode characters is encoded as a single code. We use a tree of
    // objects where keys correspond to characters in sequence and leafs are the encoded dbcs values. A special DEF_CHAR key
    // means end of sequence (needed when one sequence is a strict subsequence of another).
    // Objects are kept separately from encodeTable to increase performance.
    this.encodeTableSeq = [];

    // Some chars can be decoded, but need not be encoded.
    var skipEncodeChars = {};
    if (codecOptions.encodeSkipVals)
        for (var i = 0; i < codecOptions.encodeSkipVals.length; i++) {
            var val = codecOptions.encodeSkipVals[i];
            if (typeof val === 'number')
                skipEncodeChars[val] = true;
            else
                for (var j = val.from; j <= val.to; j++)
                    skipEncodeChars[j] = true;
        }
        
    // Use decode trie to recursively fill out encode tables.
    this._fillEncodeTable(0, 0, skipEncodeChars);

    // Add more encoding pairs when needed.
    if (codecOptions.encodeAdd) {
        for (var uChar in codecOptions.encodeAdd)
            if (Object.prototype.hasOwnProperty.call(codecOptions.encodeAdd, uChar))
                this._setEncodeChar(uChar.charCodeAt(0), codecOptions.encodeAdd[uChar]);
    }

    this.defCharSB  = this.encodeTable[0][iconv.defaultCharSingleByte.charCodeAt(0)];
    if (this.defCharSB === UNASSIGNED) this.defCharSB = this.encodeTable[0]['?'];
    if (this.defCharSB === UNASSIGNED) this.defCharSB = "?".charCodeAt(0);


    // Load & create GB18030 tables when needed.
    if (typeof codecOptions.gb18030 === 'function') {
        this.gb18030 = codecOptions.gb18030(); // Load GB18030 ranges.

        // Add GB18030 decode tables.
        var thirdByteNodeIdx = this.decodeTables.length;
        var thirdByteNode = this.decodeTables[thirdByteNodeIdx] = UNASSIGNED_NODE.slice(0);

        var fourthByteNodeIdx = this.decodeTables.length;
        var fourthByteNode = this.decodeTables[fourthByteNodeIdx] = UNASSIGNED_NODE.slice(0);

        for (var i = 0x81; i <= 0xFE; i++) {
            var secondByteNodeIdx = NODE_START - this.decodeTables[0][i];
            var secondByteNode = this.decodeTables[secondByteNodeIdx];
            for (var j = 0x30; j <= 0x39; j++)
                secondByteNode[j] = NODE_START - thirdByteNodeIdx;
        }
        for (var i = 0x81; i <= 0xFE; i++)
            thirdByteNode[i] = NODE_START - fourthByteNodeIdx;
        for (var i = 0x30; i <= 0x39; i++)
            fourthByteNode[i] = GB18030_CODE
    }        
}

DBCSCodec.prototype.encoder = DBCSEncoder;
DBCSCodec.prototype.decoder = DBCSDecoder;

// Decoder helpers
DBCSCodec.prototype._getDecodeTrieNode = function(addr) {
    var bytes = [];
    for (; addr > 0; addr >>= 8)
        bytes.push(addr & 0xFF);
    if (bytes.length == 0)
        bytes.push(0);

    var node = this.decodeTables[0];
    for (var i = bytes.length-1; i > 0; i--) { // Traverse nodes deeper into the trie.
        var val = node[bytes[i]];

        if (val == UNASSIGNED) { // Create new node.
            node[bytes[i]] = NODE_START - this.decodeTables.length;
            this.decodeTables.push(node = UNASSIGNED_NODE.slice(0));
        }
        else if (val <= NODE_START) { // Existing node.
            node = this.decodeTables[NODE_START - val];
        }
        else
            throw new Error("Overwrite byte in " + this.encodingName + ", addr: " + addr.toString(16));
    }
    return node;
}


DBCSCodec.prototype._addDecodeChunk = function(chunk) {
    // First element of chunk is the hex mbcs code where we start.
    var curAddr = parseInt(chunk[0], 16);

    // Choose the decoding node where we'll write our chars.
    var writeTable = this._getDecodeTrieNode(curAddr);
    curAddr = curAddr & 0xFF;

    // Write all other elements of the chunk to the table.
    for (var k = 1; k < chunk.length; k++) {
        var part = chunk[k];
        if (typeof part === "string") { // String, write as-is.
            for (var l = 0; l < part.length;) {
                var code = part.charCodeAt(l++);
                if (0xD800 <= code && code < 0xDC00) { // Decode surrogate
                    var codeTrail = part.charCodeAt(l++);
                    if (0xDC00 <= codeTrail && codeTrail < 0xE000)
                        writeTable[curAddr++] = 0x10000 + (code - 0xD800) * 0x400 + (codeTrail - 0xDC00);
                    else
                        throw new Error("Incorrect surrogate pair in "  + this.encodingName + " at chunk " + chunk[0]);
                }
                else if (0x0FF0 < code && code <= 0x0FFF) { // Character sequence (our own encoding used)
                    var len = 0xFFF - code + 2;
                    var seq = [];
                    for (var m = 0; m < len; m++)
                        seq.push(part.charCodeAt(l++)); // Simple variation: don't support surrogates or subsequences in seq.

                    writeTable[curAddr++] = SEQ_START - this.decodeTableSeq.length;
                    this.decodeTableSeq.push(seq);
                }
                else
                    writeTable[curAddr++] = code; // Basic char
            }
        } 
        else if (typeof part === "number") { // Integer, meaning increasing sequence starting with prev character.
            var charCode = writeTable[curAddr - 1] + 1;
            for (var l = 0; l < part; l++)
                writeTable[curAddr++] = charCode++;
        }
        else
            throw new Error("Incorrect type '" + typeof part + "' given in "  + this.encodingName + " at chunk " + chunk[0]);
    }
    if (curAddr > 0xFF)
        throw new Error("Incorrect chunk in "  + this.encodingName + " at addr " + chunk[0] + ": too long" + curAddr);
}

// Encoder helpers
DBCSCodec.prototype._getEncodeBucket = function(uCode) {
    var high = uCode >> 8; // This could be > 0xFF because of astral characters.
    if (this.encodeTable[high] === undefined)
        this.encodeTable[high] = UNASSIGNED_NODE.slice(0); // Create bucket on demand.
    return this.encodeTable[high];
}

DBCSCodec.prototype._setEncodeChar = function(uCode, dbcsCode) {
    var bucket = this._getEncodeBucket(uCode);
    var low = uCode & 0xFF;
    if (bucket[low] <= SEQ_START)
        this.encodeTableSeq[SEQ_START-bucket[low]][DEF_CHAR] = dbcsCode; // There's already a sequence, set a single-char subsequence of it.
    else if (bucket[low] == UNASSIGNED)
        bucket[low] = dbcsCode;
}

DBCSCodec.prototype._setEncodeSequence = function(seq, dbcsCode) {
    
    // Get the root of character tree according to first character of the sequence.
    var uCode = seq[0];
    var bucket = this._getEncodeBucket(uCode);
    var low = uCode & 0xFF;

    var node;
    if (bucket[low] <= SEQ_START) {
        // There's already a sequence with  - use it.
        node = this.encodeTableSeq[SEQ_START-bucket[low]];
    }
    else {
        // There was no sequence object - allocate a new one.
        node = {};
        if (bucket[low] !== UNASSIGNED) node[DEF_CHAR] = bucket[low]; // If a char was set before - make it a single-char subsequence.
        bucket[low] = SEQ_START - this.encodeTableSeq.length;
        this.encodeTableSeq.push(node);
    }

    // Traverse the character tree, allocating new nodes as needed.
    for (var j = 1; j < seq.length-1; j++) {
        var oldVal = node[uCode];
        if (typeof oldVal === 'object')
            node = oldVal;
        else {
            node = node[uCode] = {}
            if (oldVal !== undefined)
                node[DEF_CHAR] = oldVal
        }
    }

    // Set the leaf to given dbcsCode.
    uCode = seq[seq.length-1];
    node[uCode] = dbcsCode;
}

DBCSCodec.prototype._fillEncodeTable = function(nodeIdx, prefix, skipEncodeChars) {
    var node = this.decodeTables[nodeIdx];
    for (var i = 0; i < 0x100; i++) {
        var uCode = node[i];
        var mbCode = prefix + i;
        if (skipEncodeChars[mbCode])
            continue;

        if (uCode >= 0)
            this._setEncodeChar(uCode, mbCode);
        else if (uCode <= NODE_START)
            this._fillEncodeTable(NODE_START - uCode, mbCode << 8, skipEncodeChars);
        else if (uCode <= SEQ_START)
            this._setEncodeSequence(this.decodeTableSeq[SEQ_START - uCode], mbCode);
    }
}



// == Encoder ==================================================================

function DBCSEncoder(options, codec) {
    // Encoder state
    this.leadSurrogate = -1;
    this.seqObj = undefined;
    
    // Static data
    this.encodeTable = codec.encodeTable;
    this.encodeTableSeq = codec.encodeTableSeq;
    this.defaultCharSingleByte = codec.defCharSB;
    this.gb18030 = codec.gb18030;
}

DBCSEncoder.prototype.write = function(str) {
    var newBuf = Buffer.alloc(str.length * (this.gb18030 ? 4 : 3)),
        leadSurrogate = this.leadSurrogate,
        seqObj = this.seqObj, nextChar = -1,
        i = 0, j = 0;

    while (true) {
        // 0. Get next character.
        if (nextChar === -1) {
            if (i == str.length) break;
            var uCode = str.charCodeAt(i++);
        }
        else {
            var uCode = nextChar;
            nextChar = -1;    
        }

        // 1. Handle surrogates.
        if (0xD800 <= uCode && uCode < 0xE000) { // Char is one of surrogates.
            if (uCode < 0xDC00) { // We've got lead surrogate.
                if (leadSurrogate === -1) {
                    leadSurrogate = uCode;
                    continue;
                } else {
                    leadSurrogate = uCode;
                    // Double lead surrogate found.
                    uCode = UNASSIGNED;
                }
            } else { // We've got trail surrogate.
                if (leadSurrogate !== -1) {
                    uCode = 0x10000 + (leadSurrogate - 0xD800) * 0x400 + (uCode - 0xDC00);
                    leadSurrogate = -1;
                } else {
                    // Incomplete surrogate pair - only trail surrogate found.
                    uCode = UNASSIGNED;
                }
                
            }
        }
        else if (leadSurrogate !== -1) {
            // Incomplete surrogate pair - only lead surrogate found.
            nextChar = uCode; uCode = UNASSIGNED; // Write an error, then current char.
            leadSurrogate = -1;
        }

        // 2. Convert uCode character.
        var dbcsCode = UNASSIGNED;
        if (seqObj !== undefined && uCode != UNASSIGNED) { // We are in the middle of the sequence
            var resCode = seqObj[uCode];
            if (typeof resCode === 'object') { // Sequence continues.
                seqObj = resCode;
                continue;

            } else if (typeof resCode == 'number') { // Sequence finished. Write it.
                dbcsCode = resCode;

            } else if (resCode == undefined) { // Current character is not part of the sequence.

                // Try default character for this sequence
                resCode = seqObj[DEF_CHAR];
                if (resCode !== undefined) {
                    dbcsCode = resCode; // Found. Write it.
                    nextChar = uCode; // Current character will be written too in the next iteration.

                } else {
                    // TODO: What if we have no default? (resCode == undefined)
                    // Then, we should write first char of the sequence as-is and try the rest recursively.
                    // Didn't do it for now because no encoding has this situation yet.
                    // Currently, just skip the sequence and write current char.
                }
            }
            seqObj = undefined;
        }
        else if (uCode >= 0) {  // Regular character
            var subtable = this.encodeTable[uCode >> 8];
            if (subtable !== undefined)
                dbcsCode = subtable[uCode & 0xFF];
            
            if (dbcsCode <= SEQ_START) { // Sequence start
                seqObj = this.encodeTableSeq[SEQ_START-dbcsCode];
                continue;
            }

            if (dbcsCode == UNASSIGNED && this.gb18030) {
                // Use GB18030 algorithm to find character(s) to write.
                var idx = findIdx(this.gb18030.uChars, uCode);
                if (idx != -1) {
                    var dbcsCode = this.gb18030.gbChars[idx] + (uCode - this.gb18030.uChars[idx]);
                    newBuf[j++] = 0x81 + Math.floor(dbcsCode / 12600); dbcsCode = dbcsCode % 12600;
                    newBuf[j++] = 0x30 + Math.floor(dbcsCode / 1260); dbcsCode = dbcsCode % 1260;
                    newBuf[j++] = 0x81 + Math.floor(dbcsCode / 10); dbcsCode = dbcsCode % 10;
                    newBuf[j++] = 0x30 + dbcsCode;
                    continue;
                }
            }
        }

        // 3. Write dbcsCode character.
        if (dbcsCode === UNASSIGNED)
            dbcsCode = this.defaultCharSingleByte;
        
        if (dbcsCode < 0x100) {
            newBuf[j++] = dbcsCode;
        }
        else if (dbcsCode < 0x10000) {
            newBuf[j++] = dbcsCode >> 8;   // high byte
            newBuf[j++] = dbcsCode & 0xFF; // low byte
        }
        else {
            newBuf[j++] = dbcsCode >> 16;
            newBuf[j++] = (dbcsCode >> 8) & 0xFF;
            newBuf[j++] = dbcsCode & 0xFF;
        }
    }

    this.seqObj = seqObj;
    this.leadSurrogate = leadSurrogate;
    return newBuf.slice(0, j);
}

DBCSEncoder.prototype.end = function() {
    if (this.leadSurrogate === -1 && this.seqObj === undefined)
        return; // All clean. Most often case.

    var newBuf = Buffer.alloc(10), j = 0;

    if (this.seqObj) { // We're in the sequence.
        var dbcsCode = this.seqObj[DEF_CHAR];
        if (dbcsCode !== undefined) { // Write beginning of the sequence.
            if (dbcsCode < 0x100) {
                newBuf[j++] = dbcsCode;
            }
            else {
                newBuf[j++] = dbcsCode >> 8;   // high byte
                newBuf[j++] = dbcsCode & 0xFF; // low byte
            }
        } else {
            // See todo above.
        }
        this.seqObj = undefined;
    }

    if (this.leadSurrogate !== -1) {
        // Incomplete surrogate pair - only lead surrogate found.
        newBuf[j++] = this.defaultCharSingleByte;
        this.leadSurrogate = -1;
    }
    
    return newBuf.slice(0, j);
}

// Export for testing
DBCSEncoder.prototype.findIdx = findIdx;


// == Decoder ==================================================================

function DBCSDecoder(options, codec) {
    // Decoder state
    this.nodeIdx = 0;
    this.prevBuf = Buffer.alloc(0);

    // Static data
    this.decodeTables = codec.decodeTables;
    this.decodeTableSeq = codec.decodeTableSeq;
    this.defaultCharUnicode = codec.defaultCharUnicode;
    this.gb18030 = codec.gb18030;
}

DBCSDecoder.prototype.write = function(buf) {
    var newBuf = Buffer.alloc(buf.length*2),
        nodeIdx = this.nodeIdx, 
        prevBuf = this.prevBuf, prevBufOffset = this.prevBuf.length,
        seqStart = -this.prevBuf.length, // idx of the start of current parsed sequence.
        uCode;

    if (prevBufOffset > 0) // Make prev buf overlap a little to make it easier to slice later.
        prevBuf = Buffer.concat([prevBuf, buf.slice(0, 10)]);
    
    for (var i = 0, j = 0; i < buf.length; i++) {
        var curByte = (i >= 0) ? buf[i] : prevBuf[i + prevBufOffset];

        // Lookup in current trie node.
        var uCode = this.decodeTables[nodeIdx][curByte];

        if (uCode >= 0) { 
            // Normal character, just use it.
        }
        else if (uCode === UNASSIGNED) { // Unknown char.
            // TODO: Callback with seq.
            //var curSeq = (seqStart >= 0) ? buf.slice(seqStart, i+1) : prevBuf.slice(seqStart + prevBufOffset, i+1 + prevBufOffset);
            i = seqStart; // Try to parse again, after skipping first byte of the sequence ('i' will be incremented by 'for' cycle).
            uCode = this.defaultCharUnicode.charCodeAt(0);
        }
        else if (uCode === GB18030_CODE) {
            var curSeq = (seqStart >= 0) ? buf.slice(seqStart, i+1) : prevBuf.slice(seqStart + prevBufOffset, i+1 + prevBufOffset);
            var ptr = (curSeq[0]-0x81)*12600 + (curSeq[1]-0x30)*1260 + (curSeq[2]-0x81)*10 + (curSeq[3]-0x30);
            var idx = findIdx(this.gb18030.gbChars, ptr);
            uCode = this.gb18030.uChars[idx] + ptr - this.gb18030.gbChars[idx];
        }
        else if (uCode <= NODE_START) { // Go to next trie node.
            nodeIdx = NODE_START - uCode;
            continue;
        }
        else if (uCode <= SEQ_START) { // Output a sequence of chars.
            var seq = this.decodeTableSeq[SEQ_START - uCode];
            for (var k = 0; k < seq.length - 1; k++) {
                uCode = seq[k];
                newBuf[j++] = uCode & 0xFF;
                newBuf[j++] = uCode >> 8;
            }
            uCode = seq[seq.length-1];
        }
        else
            throw new Error("iconv-lite internal error: invalid decoding table value " + uCode + " at " + nodeIdx + "/" + curByte);

        // Write the character to buffer, handling higher planes using surrogate pair.
        if (uCode > 0xFFFF) { 
            uCode -= 0x10000;
            var uCodeLead = 0xD800 + Math.floor(uCode / 0x400);
            newBuf[j++] = uCodeLead & 0xFF;
            newBuf[j++] = uCodeLead >> 8;

            uCode = 0xDC00 + uCode % 0x400;
        }
        newBuf[j++] = uCode & 0xFF;
        newBuf[j++] = uCode >> 8;

        // Reset trie node.
        nodeIdx = 0; seqStart = i+1;
    }

    this.nodeIdx = nodeIdx;
    this.prevBuf = (seqStart >= 0) ? buf.slice(seqStart) : prevBuf.slice(seqStart + prevBufOffset);
    return newBuf.slice(0, j).toString('ucs2');
}

DBCSDecoder.prototype.end = function() {
    var ret = '';

    // Try to parse all remaining chars.
    while (this.prevBuf.length > 0) {
        // Skip 1 character in the buffer.
        ret += this.defaultCharUnicode;
        var buf = this.prevBuf.slice(1);

        // Parse remaining as usual.
        this.prevBuf = Buffer.alloc(0);
        this.nodeIdx = 0;
        if (buf.length > 0)
            ret += this.write(buf);
    }

    this.nodeIdx = 0;
    return ret;
}

// Binary search for GB18030. Returns largest i such that table[i] <= val.
function findIdx(table, val) {
    if (table[0] > val)
        return -1;

    var l = 0, r = table.length;
    while (l < r-1) { // always table[l] <= val < table[r]
        var mid = l + Math.floor((r-l+1)/2);
        if (table[mid] <= val)
            l = mid;
        else
            r = mid;
    }
    return l;
}



/***/ }),

/***/ 36955:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


// Description of supported double byte encodings and aliases.
// Tables are not require()-d until they are needed to speed up library load.
// require()-s are direct to support Browserify.

module.exports = {
    
    // == Japanese/ShiftJIS ====================================================
    // All japanese encodings are based on JIS X set of standards:
    // JIS X 0201 - Single-byte encoding of ASCII + ¬• + Kana chars at 0xA1-0xDF.
    // JIS X 0208 - Main set of 6879 characters, placed in 94x94 plane, to be encoded by 2 bytes. 
    //              Has several variations in 1978, 1983, 1990 and 1997.
    // JIS X 0212 - Supplementary plane of 6067 chars in 94x94 plane. 1990. Effectively dead.
    // JIS X 0213 - Extension and modern replacement of 0208 and 0212. Total chars: 11233.
    //              2 planes, first is superset of 0208, second - revised 0212.
    //              Introduced in 2000, revised 2004. Some characters are in Unicode Plane 2 (0x2xxxx)

    // Byte encodings are:
    //  * Shift_JIS: Compatible with 0201, uses not defined chars in top half as lead bytes for double-byte
    //               encoding of 0208. Lead byte ranges: 0x81-0x9F, 0xE0-0xEF; Trail byte ranges: 0x40-0x7E, 0x80-0x9E, 0x9F-0xFC.
    //               Windows CP932 is a superset of Shift_JIS. Some companies added more chars, notably KDDI.
    //  * EUC-JP:    Up to 3 bytes per character. Used mostly on *nixes.
    //               0x00-0x7F       - lower part of 0201
    //               0x8E, 0xA1-0xDF - upper part of 0201
    //               (0xA1-0xFE)x2   - 0208 plane (94x94).
    //               0x8F, (0xA1-0xFE)x2 - 0212 plane (94x94).
    //  * JIS X 208: 7-bit, direct encoding of 0208. Byte ranges: 0x21-0x7E (94 values). Uncommon.
    //               Used as-is in ISO2022 family.
    //  * ISO2022-JP: Stateful encoding, with escape sequences to switch between ASCII, 
    //                0201-1976 Roman, 0208-1978, 0208-1983.
    //  * ISO2022-JP-1: Adds esc seq for 0212-1990.
    //  * ISO2022-JP-2: Adds esc seq for GB2313-1980, KSX1001-1992, ISO8859-1, ISO8859-7.
    //  * ISO2022-JP-3: Adds esc seq for 0201-1976 Kana set, 0213-2000 Planes 1, 2.
    //  * ISO2022-JP-2004: Adds 0213-2004 Plane 1.
    //
    // After JIS X 0213 appeared, Shift_JIS-2004, EUC-JISX0213 and ISO2022-JP-2004 followed, with just changing the planes.
    //
    // Overall, it seems that it's a mess :( http://www8.plala.or.jp/tkubota1/unicode-symbols-map2.html

    'shiftjis': {
        type: '_dbcs',
        table: function() { return __nccwpck_require__(14450) },
        encodeAdd: {'\u00a5': 0x5C, '\u203E': 0x7E},
        encodeSkipVals: [{from: 0xED40, to: 0xF940}],
    },
    'csshiftjis': 'shiftjis',
    'mskanji': 'shiftjis',
    'sjis': 'shiftjis',
    'windows31j': 'shiftjis',
    'ms31j': 'shiftjis',
    'xsjis': 'shiftjis',
    'windows932': 'shiftjis',
    'ms932': 'shiftjis',
    '932': 'shiftjis',
    'cp932': 'shiftjis',

    'eucjp': {
        type: '_dbcs',
        table: function() { return __nccwpck_require__(57185) },
        encodeAdd: {'\u00a5': 0x5C, '\u203E': 0x7E},
    },

    // TODO: KDDI extension to Shift_JIS
    // TODO: IBM CCSID 942 = CP932, but F0-F9 custom chars and other char changes.
    // TODO: IBM CCSID 943 = Shift_JIS = CP932 with original Shift_JIS lower 128 chars.


    // == Chinese/GBK ==========================================================
    // http://en.wikipedia.org/wiki/GBK
    // We mostly implement W3C recommendation: https://www.w3.org/TR/encoding/#gbk-encoder

    // Oldest GB2312 (1981, ~7600 chars) is a subset of CP936
    'gb2312': 'cp936',
    'gb231280': 'cp936',
    'gb23121980': 'cp936',
    'csgb2312': 'cp936',
    'csiso58gb231280': 'cp936',
    'euccn': 'cp936',

    // Microsoft's CP936 is a subset and approximation of GBK.
    'windows936': 'cp936',
    'ms936': 'cp936',
    '936': 'cp936',
    'cp936': {
        type: '_dbcs',
        table: function() { return __nccwpck_require__(22787) },
    },

    // GBK (~22000 chars) is an extension of CP936 that added user-mapped chars and some other.
    'gbk': {
        type: '_dbcs',
        table: function() { return (__nccwpck_require__(22787).concat)(__nccwpck_require__(93617)) },
    },
    'xgbk': 'gbk',
    'isoir58': 'gbk',

    // GB18030 is an algorithmic extension of GBK.
    // Main source: https://www.w3.org/TR/encoding/#gbk-encoder
    // http://icu-project.org/docs/papers/gb18030.html
    // http://source.icu-project.org/repos/icu/data/trunk/charset/data/xml/gb-18030-2000.xml
    // http://www.khngai.com/chinese/charmap/tblgbk.php?page=0
    'gb18030': {
        type: '_dbcs',
        table: function() { return (__nccwpck_require__(22787).concat)(__nccwpck_require__(93617)) },
        gb18030: function() { return __nccwpck_require__(67936) },
        encodeSkipVals: [0x80],
        encodeAdd: {'‚Ç¨': 0xA2E3},
    },

    'chinese': 'gb18030',


    // == Korean ===============================================================
    // EUC-KR, KS_C_5601 and KS X 1001 are exactly the same.
    'windows949': 'cp949',
    'ms949': 'cp949',
    '949': 'cp949',
    'cp949': {
        type: '_dbcs',
        table: function() { return __nccwpck_require__(82753) },
    },

    'cseuckr': 'cp949',
    'csksc56011987': 'cp949',
    'euckr': 'cp949',
    'isoir149': 'cp949',
    'korean': 'cp949',
    'ksc56011987': 'cp949',
    'ksc56011989': 'cp949',
    'ksc5601': 'cp949',


    // == Big5/Taiwan/Hong Kong ================================================
    // There are lots of tables for Big5 and cp950. Please see the following links for history:
    // http://moztw.org/docs/big5/  http://www.haible.de/bruno/charsets/conversion-tables/Big5.html
    // Variations, in roughly number of defined chars:
    //  * Windows CP 950: Microsoft variant of Big5. Canonical: http://www.unicode.org/Public/MAPPINGS/VENDORS/MICSFT/WINDOWS/CP950.TXT
    //  * Windows CP 951: Microsoft variant of Big5-HKSCS-2001. Seems to be never public. http://me.abelcheung.org/articles/research/what-is-cp951/
    //  * Big5-2003 (Taiwan standard) almost superset of cp950.
    //  * Unicode-at-on (UAO) / Mozilla 1.8. Falling out of use on the Web. Not supported by other browsers.
    //  * Big5-HKSCS (-2001, -2004, -2008). Hong Kong standard. 
    //    many unicode code points moved from PUA to Supplementary plane (U+2XXXX) over the years.
    //    Plus, it has 4 combining sequences.
    //    Seems that Mozilla refused to support it for 10 yrs. https://bugzilla.mozilla.org/show_bug.cgi?id=162431 https://bugzilla.mozilla.org/show_bug.cgi?id=310299
    //    because big5-hkscs is the only encoding to include astral characters in non-algorithmic way.
    //    Implementations are not consistent within browsers; sometimes labeled as just big5.
    //    MS Internet Explorer switches from big5 to big5-hkscs when a patch applied.
    //    Great discussion & recap of what's going on https://bugzilla.mozilla.org/show_bug.cgi?id=912470#c31
    //    In the encoder, it might make sense to support encoding old PUA mappings to Big5 bytes seq-s.
    //    Official spec: http://www.ogcio.gov.hk/en/business/tech_promotion/ccli/terms/doc/2003cmp_2008.txt
    //                   http://www.ogcio.gov.hk/tc/business/tech_promotion/ccli/terms/doc/hkscs-2008-big5-iso.txt
    // 
    // Current understanding of how to deal with Big5(-HKSCS) is in the Encoding Standard, http://encoding.spec.whatwg.org/#big5-encoder
    // Unicode mapping (http://www.unicode.org/Public/MAPPINGS/OBSOLETE/EASTASIA/OTHER/BIG5.TXT) is said to be wrong.

    'windows950': 'cp950',
    'ms950': 'cp950',
    '950': 'cp950',
    'cp950': {
        type: '_dbcs',
        table: function() { return __nccwpck_require__(8115) },
    },

    // Big5 has many variations and is an extension of cp950. We use Encoding Standard's as a consensus.
    'big5': 'big5hkscs',
    'big5hkscs': {
        type: '_dbcs',
        table: function() { return (__nccwpck_require__(8115).concat)(__nccwpck_require__(89338)) },
        encodeSkipVals: [0xa2cc],
    },

    'cnbig5': 'big5hkscs',
    'csbig5': 'big5hkscs',
    'xxbig5': 'big5hkscs',
};


/***/ }),

/***/ 78456:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


// Update this array if you add/rename/remove files in this directory.
// We support Browserify by skipping automatic module discovery and requiring modules directly.
var modules = [
    __nccwpck_require__(45199),
    __nccwpck_require__(26682),
    __nccwpck_require__(37368),
    __nccwpck_require__(78282),
    __nccwpck_require__(75194),
    __nccwpck_require__(98854),
    __nccwpck_require__(745),
    __nccwpck_require__(36955),
];

// Put all encoding/alias/codec definitions to single object and export it. 
for (var i = 0; i < modules.length; i++) {
    var module = modules[i];
    for (var enc in module)
        if (Object.prototype.hasOwnProperty.call(module, enc))
            exports[enc] = module[enc];
}


/***/ }),

/***/ 45199:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";

var Buffer = (__nccwpck_require__(12803).Buffer);

// Export Node.js internal encodings.

module.exports = {
    // Encodings
    utf8:   { type: "_internal", bomAware: true},
    cesu8:  { type: "_internal", bomAware: true},
    unicode11utf8: "utf8",

    ucs2:   { type: "_internal", bomAware: true},
    utf16le: "ucs2",

    binary: { type: "_internal" },
    base64: { type: "_internal" },
    hex:    { type: "_internal" },

    // Codec.
    _internal: InternalCodec,
};

//------------------------------------------------------------------------------

function InternalCodec(codecOptions, iconv) {
    this.enc = codecOptions.encodingName;
    this.bomAware = codecOptions.bomAware;

    if (this.enc === "base64")
        this.encoder = InternalEncoderBase64;
    else if (this.enc === "cesu8") {
        this.enc = "utf8"; // Use utf8 for decoding.
        this.encoder = InternalEncoderCesu8;

        // Add decoder for versions of Node not supporting CESU-8
        if (Buffer.from('eda0bdedb2a9', 'hex').toString() !== 'üí©') {
            this.decoder = InternalDecoderCesu8;
            this.defaultCharUnicode = iconv.defaultCharUnicode;
        }
    }
}

InternalCodec.prototype.encoder = InternalEncoder;
InternalCodec.prototype.decoder = InternalDecoder;

//------------------------------------------------------------------------------

// We use node.js internal decoder. Its signature is the same as ours.
var StringDecoder = (__nccwpck_require__(13193).StringDecoder);

if (!StringDecoder.prototype.end) // Node v0.8 doesn't have this method.
    StringDecoder.prototype.end = function() {};


function InternalDecoder(options, codec) {
    StringDecoder.call(this, codec.enc);
}

InternalDecoder.prototype = StringDecoder.prototype;


//------------------------------------------------------------------------------
// Encoder is mostly trivial

function InternalEncoder(options, codec) {
    this.enc = codec.enc;
}

InternalEncoder.prototype.write = function(str) {
    return Buffer.from(str, this.enc);
}

InternalEncoder.prototype.end = function() {
}


//------------------------------------------------------------------------------
// Except base64 encoder, which must keep its state.

function InternalEncoderBase64(options, codec) {
    this.prevStr = '';
}

InternalEncoderBase64.prototype.write = function(str) {
    str = this.prevStr + str;
    var completeQuads = str.length - (str.length % 4);
    this.prevStr = str.slice(completeQuads);
    str = str.slice(0, completeQuads);

    return Buffer.from(str, "base64");
}

InternalEncoderBase64.prototype.end = function() {
    return Buffer.from(this.prevStr, "base64");
}


//------------------------------------------------------------------------------
// CESU-8 encoder is also special.

function InternalEncoderCesu8(options, codec) {
}

InternalEncoderCesu8.prototype.write = function(str) {
    var buf = Buffer.alloc(str.length * 3), bufIdx = 0;
    for (var i = 0; i < str.length; i++) {
        var charCode = str.charCodeAt(i);
        // Naive implementation, but it works because CESU-8 is especially easy
        // to convert from UTF-16 (which all JS strings are encoded in).
        if (charCode < 0x80)
            buf[bufIdx++] = charCode;
        else if (charCode < 0x800) {
            buf[bufIdx++] = 0xC0 + (charCode >>> 6);
            buf[bufIdx++] = 0x80 + (charCode & 0x3f);
        }
        else { // charCode will always be < 0x10000 in javascript.
            buf[bufIdx++] = 0xE0 + (charCode >>> 12);
            buf[bufIdx++] = 0x80 + ((charCode >>> 6) & 0x3f);
            buf[bufIdx++] = 0x80 + (charCode & 0x3f);
        }
    }
    return buf.slice(0, bufIdx);
}

InternalEncoderCesu8.prototype.end = function() {
}

//------------------------------------------------------------------------------
// CESU-8 decoder is not implemented in Node v4.0+

function InternalDecoderCesu8(options, codec) {
    this.acc = 0;
    this.contBytes = 0;
    this.accBytes = 0;
    this.defaultCharUnicode = codec.defaultCharUnicode;
}

InternalDecoderCesu8.prototype.write = function(buf) {
    var acc = this.acc, contBytes = this.contBytes, accBytes = this.accBytes, 
        res = '';
    for (var i = 0; i < buf.length; i++) {
        var curByte = buf[i];
        if ((curByte & 0xC0) !== 0x80) { // Leading byte
            if (contBytes > 0) { // Previous code is invalid
                res += this.defaultCharUnicode;
                contBytes = 0;
            }

            if (curByte < 0x80) { // Single-byte code
                res += String.fromCharCode(curByte);
            } else if (curByte < 0xE0) { // Two-byte code
                acc = curByte & 0x1F;
                contBytes = 1; accBytes = 1;
            } else if (curByte < 0xF0) { // Three-byte code
                acc = curByte & 0x0F;
                contBytes = 2; accBytes = 1;
            } else { // Four or more are not supported for CESU-8.
                res += this.defaultCharUnicode;
            }
        } else { // Continuation byte
            if (contBytes > 0) { // We're waiting for it.
                acc = (acc << 6) | (curByte & 0x3f);
                contBytes--; accBytes++;
                if (contBytes === 0) {
                    // Check for overlong encoding, but support Modified UTF-8 (encoding NULL as C0 80)
                    if (accBytes === 2 && acc < 0x80 && acc > 0)
                        res += this.defaultCharUnicode;
                    else if (accBytes === 3 && acc < 0x800)
                        res += this.defaultCharUnicode;
                    else
                        // Actually add character.
                        res += String.fromCharCode(acc);
                }
            } else { // Unexpected continuation byte
                res += this.defaultCharUnicode;
            }
        }
    }
    this.acc = acc; this.contBytes = contBytes; this.accBytes = accBytes;
    return res;
}

InternalDecoderCesu8.prototype.end = function() {
    var res = 0;
    if (this.contBytes > 0)
        res += this.defaultCharUnicode;
    return res;
}


/***/ }),

/***/ 78282:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

var Buffer = (__nccwpck_require__(12803).Buffer);

// Single-byte codec. Needs a 'chars' string parameter that contains 256 or 128 chars that
// correspond to encoded bytes (if 128 - then lower half is ASCII). 

exports._sbcs = SBCSCodec;
function SBCSCodec(codecOptions, iconv) {
    if (!codecOptions)
        throw new Error("SBCS codec is called without the data.")
    
    // Prepare char buffer for decoding.
    if (!codecOptions.chars || (codecOptions.chars.length !== 128 && codecOptions.chars.length !== 256))
        throw new Error("Encoding '"+codecOptions.type+"' has incorrect 'chars' (must be of len 128 or 256)");
    
    if (codecOptions.chars.length === 128) {
        var asciiString = "";
        for (var i = 0; i < 128; i++)
            asciiString += String.fromCharCode(i);
        codecOptions.chars = asciiString + codecOptions.chars;
    }

    this.decodeBuf = Buffer.from(codecOptions.chars, 'ucs2');
    
    // Encoding buffer.
    var encodeBuf = Buffer.alloc(65536, iconv.defaultCharSingleByte.charCodeAt(0));

    for (var i = 0; i < codecOptions.chars.length; i++)
        encodeBuf[codecOptions.chars.charCodeAt(i)] = i;

    this.encodeBuf = encodeBuf;
}

SBCSCodec.prototype.encoder = SBCSEncoder;
SBCSCodec.prototype.decoder = SBCSDecoder;


function SBCSEncoder(options, codec) {
    this.encodeBuf = codec.encodeBuf;
}

SBCSEncoder.prototype.write = function(str) {
    var buf = Buffer.alloc(str.length);
    for (var i = 0; i < str.length; i++)
        buf[i] = this.encodeBuf[str.charCodeAt(i)];
    
    return buf;
}

SBCSEncoder.prototype.end = function() {
}


function SBCSDecoder(options, codec) {
    this.decodeBuf = codec.decodeBuf;
}

SBCSDecoder.prototype.write = function(buf) {
    // Strings are immutable in JS -> we use ucs2 buffer to speed up computations.
    var decodeBuf = this.decodeBuf;
    var newBuf = Buffer.alloc(buf.length*2);
    var idx1 = 0, idx2 = 0;
    for (var i = 0; i < buf.length; i++) {
        idx1 = buf[i]*2; idx2 = i*2;
        newBuf[idx2] = decodeBuf[idx1];
        newBuf[idx2+1] = decodeBuf[idx1+1];
    }
    return newBuf.toString('ucs2');
}

SBCSDecoder.prototype.end = function() {
}


/***/ }),

/***/ 98854:
/***/ ((module) => {

"use strict";


// Generated data for sbcs codec. Don't edit manually. Regenerate using generation/gen-sbcs.js script.
module.exports = {
  "437": "cp437",
  "737": "cp737",
  "775": "cp775",
  "850": "cp850",
  "852": "cp852",
  "855": "cp855",
  "856": "cp856",
  "857": "cp857",
  "858": "cp858",
  "860": "cp860",
  "861": "cp861",
  "862": "cp862",
  "863": "cp863",
  "864": "cp864",
  "865": "cp865",
  "866": "cp866",
  "869": "cp869",
  "874": "windows874",
  "922": "cp922",
  "1046": "cp1046",
  "1124": "cp1124",
  "1125": "cp1125",
  "1129": "cp1129",
  "1133": "cp1133",
  "1161": "cp1161",
  "1162": "cp1162",
  "1163": "cp1163",
  "1250": "windows1250",
  "1251": "windows1251",
  "1252": "windows1252",
  "1253": "windows1253",
  "1254": "windows1254",
  "1255": "windows1255",
  "1256": "windows1256",
  "1257": "windows1257",
  "1258": "windows1258",
  "28591": "iso88591",
  "28592": "iso88592",
  "28593": "iso88593",
  "28594": "iso88594",
  "28595": "iso88595",
  "28596": "iso88596",
  "28597": "iso88597",
  "28598": "iso88598",
  "28599": "iso88599",
  "28600": "iso885910",
  "28601": "iso885911",
  "28603": "iso885913",
  "28604": "iso885914",
  "28605": "iso885915",
  "28606": "iso885916",
  "windows874": {
    "type": "_sbcs",
    "chars": "‚Ç¨ÔøΩÔøΩÔøΩÔøΩ‚Ä¶ÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩ‚Äò‚Äô‚Äú‚Äù‚Ä¢‚Äì‚ÄîÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩ¬†‡∏Å‡∏Ç‡∏É‡∏Ñ‡∏Ö‡∏Ü‡∏á‡∏à‡∏â‡∏ä‡∏ã‡∏å‡∏ç‡∏é‡∏è‡∏ê‡∏ë‡∏í‡∏ì‡∏î‡∏ï‡∏ñ‡∏ó‡∏ò‡∏ô‡∏ö‡∏õ‡∏ú‡∏ù‡∏û‡∏ü‡∏†‡∏°‡∏¢‡∏£‡∏§‡∏•‡∏¶‡∏ß‡∏®‡∏©‡∏™‡∏´‡∏¨‡∏≠‡∏Æ‡∏Ø‡∏∞‡∏±‡∏≤‡∏≥‡∏¥‡∏µ‡∏∂‡∏∑‡∏∏‡∏π‡∏∫ÔøΩÔøΩÔøΩÔøΩ‡∏ø‡πÄ‡πÅ‡πÇ‡πÉ‡πÑ‡πÖ‡πÜ‡πá‡πà‡πâ‡πä‡πã‡πå‡πç‡πé‡πè‡πê‡πë‡πí‡πì‡πî‡πï‡πñ‡πó‡πò‡πô‡πö‡πõÔøΩÔøΩÔøΩÔøΩ"
  },
  "win874": "windows874",
  "cp874": "windows874",
  "windows1250": {
    "type": "_sbcs",
    "chars": "‚Ç¨ÔøΩ‚ÄöÔøΩ‚Äû‚Ä¶‚Ä†‚Ä°ÔøΩ‚Ä∞≈†‚Äπ≈ö≈§≈Ω≈πÔøΩ‚Äò‚Äô‚Äú‚Äù‚Ä¢‚Äì‚ÄîÔøΩ‚Ñ¢≈°‚Ä∫≈õ≈•≈æ≈∫¬†ÀáÀò≈Å¬§ƒÑ¬¶¬ß¬®¬©≈û¬´¬¨¬≠¬Æ≈ª¬∞¬±Àõ≈Ç¬¥¬µ¬∂¬∑¬∏ƒÖ≈ü¬ªƒΩÀùƒæ≈º≈î√Å√ÇƒÇ√ÑƒπƒÜ√áƒå√âƒò√ãƒö√ç√éƒéƒê≈É≈á√ì√î≈ê√ñ√ó≈ò≈Æ√ö≈∞√ú√ù≈¢√ü≈ï√°√¢ƒÉ√§ƒ∫ƒá√ßƒç√©ƒô√´ƒõ√≠√Æƒèƒë≈Ñ≈à√≥√¥≈ë√∂√∑≈ô≈Ø√∫≈±√º√Ω≈£Àô"
  },
  "win1250": "windows1250",
  "cp1250": "windows1250",
  "windows1251": {
    "type": "_sbcs",
    "chars": "–Ç–É‚Äö—ì‚Äû‚Ä¶‚Ä†‚Ä°‚Ç¨‚Ä∞–â‚Äπ–ä–å–ã–è—í‚Äò‚Äô‚Äú‚Äù‚Ä¢‚Äì‚ÄîÔøΩ‚Ñ¢—ô‚Ä∫—ö—ú—õ—ü¬†–é—û–à¬§“ê¬¶¬ß–Å¬©–Ñ¬´¬¨¬≠¬Æ–á¬∞¬±–Ü—ñ“ë¬µ¬∂¬∑—ë‚Ññ—î¬ª—ò–Ö—ï—ó–ê–ë–í–ì–î–ï–ñ–ó–ò–ô–ö–õ–ú–ù–û–ü–†–°–¢–£–§–•–¶–ß–®–©–™–´–¨–≠–Æ–Ø–∞–±–≤–≥–¥–µ–∂–∑–∏–π–∫–ª–º–Ω–æ–ø—Ä—Å—Ç—É—Ñ—Ö—Ü—á—à—â—ä—ã—å—ç—é—è"
  },
  "win1251": "windows1251",
  "cp1251": "windows1251",
  "windows1252": {
    "type": "_sbcs",
    "chars": "‚Ç¨ÔøΩ‚Äö∆í‚Äû‚Ä¶‚Ä†‚Ä°ÀÜ‚Ä∞≈†‚Äπ≈íÔøΩ≈ΩÔøΩÔøΩ‚Äò‚Äô‚Äú‚Äù‚Ä¢‚Äì‚ÄîÀú‚Ñ¢≈°‚Ä∫≈ìÔøΩ≈æ≈∏¬†¬°¬¢¬£¬§¬•¬¶¬ß¬®¬©¬™¬´¬¨¬≠¬Æ¬Ø¬∞¬±¬≤¬≥¬¥¬µ¬∂¬∑¬∏¬π¬∫¬ª¬º¬Ω¬æ¬ø√Ä√Å√Ç√É√Ñ√Ö√Ü√á√à√â√ä√ã√å√ç√é√è√ê√ë√í√ì√î√ï√ñ√ó√ò√ô√ö√õ√ú√ù√û√ü√†√°√¢√£√§√•√¶√ß√®√©√™√´√¨√≠√Æ√Ø√∞√±√≤√≥√¥√µ√∂√∑√∏√π√∫√ª√º√Ω√æ√ø"
  },
  "win1252": "windows1252",
  "cp1252": "windows1252",
  "windows1253": {
    "type": "_sbcs",
    "chars": "‚Ç¨ÔøΩ‚Äö∆í‚Äû‚Ä¶‚Ä†‚Ä°ÔøΩ‚Ä∞ÔøΩ‚ÄπÔøΩÔøΩÔøΩÔøΩÔøΩ‚Äò‚Äô‚Äú‚Äù‚Ä¢‚Äì‚ÄîÔøΩ‚Ñ¢ÔøΩ‚Ä∫ÔøΩÔøΩÔøΩÔøΩ¬†ŒÖŒÜ¬£¬§¬•¬¶¬ß¬®¬©ÔøΩ¬´¬¨¬≠¬Æ‚Äï¬∞¬±¬≤¬≥ŒÑ¬µ¬∂¬∑ŒàŒâŒä¬ªŒå¬ΩŒéŒèŒêŒëŒíŒìŒîŒïŒñŒóŒòŒôŒöŒõŒúŒùŒûŒüŒ†Œ°ÔøΩŒ£Œ§Œ•Œ¶ŒßŒ®Œ©Œ™Œ´Œ¨Œ≠ŒÆŒØŒ∞Œ±Œ≤Œ≥Œ¥ŒµŒ∂Œ∑Œ∏ŒπŒ∫ŒªŒºŒΩŒæŒøœÄœÅœÇœÉœÑœÖœÜœáœàœâœäœãœåœçœéÔøΩ"
  },
  "win1253": "windows1253",
  "cp1253": "windows1253",
  "windows1254": {
    "type": "_sbcs",
    "chars": "‚Ç¨ÔøΩ‚Äö∆í‚Äû‚Ä¶‚Ä†‚Ä°ÀÜ‚Ä∞≈†‚Äπ≈íÔøΩÔøΩÔøΩÔøΩ‚Äò‚Äô‚Äú‚Äù‚Ä¢‚Äì‚ÄîÀú‚Ñ¢≈°‚Ä∫≈ìÔøΩÔøΩ≈∏¬†¬°¬¢¬£¬§¬•¬¶¬ß¬®¬©¬™¬´¬¨¬≠¬Æ¬Ø¬∞¬±¬≤¬≥¬¥¬µ¬∂¬∑¬∏¬π¬∫¬ª¬º¬Ω¬æ¬ø√Ä√Å√Ç√É√Ñ√Ö√Ü√á√à√â√ä√ã√å√ç√é√èƒû√ë√í√ì√î√ï√ñ√ó√ò√ô√ö√õ√úƒ∞≈û√ü√†√°√¢√£√§√•√¶√ß√®√©√™√´√¨√≠√Æ√Øƒü√±√≤√≥√¥√µ√∂√∑√∏√π√∫√ª√ºƒ±≈ü√ø"
  },
  "win1254": "windows1254",
  "cp1254": "windows1254",
  "windows1255": {
    "type": "_sbcs",
    "chars": "‚Ç¨ÔøΩ‚Äö∆í‚Äû‚Ä¶‚Ä†‚Ä°ÀÜ‚Ä∞ÔøΩ‚ÄπÔøΩÔøΩÔøΩÔøΩÔøΩ‚Äò‚Äô‚Äú‚Äù‚Ä¢‚Äì‚ÄîÀú‚Ñ¢ÔøΩ‚Ä∫ÔøΩÔøΩÔøΩÔøΩ¬†¬°¬¢¬£‚Ç™¬•¬¶¬ß¬®¬©√ó¬´¬¨¬≠¬Æ¬Ø¬∞¬±¬≤¬≥¬¥¬µ¬∂¬∑¬∏¬π√∑¬ª¬º¬Ω¬æ¬ø÷∞÷±÷≤÷≥÷¥÷µ÷∂÷∑÷∏÷π÷∫÷ª÷º÷Ω÷æ÷ø◊Ä◊Å◊Ç◊É◊∞◊±◊≤◊≥◊¥ÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩ◊ê◊ë◊í◊ì◊î◊ï◊ñ◊ó◊ò◊ô◊ö◊õ◊ú◊ù◊û◊ü◊†◊°◊¢◊£◊§◊•◊¶◊ß◊®◊©◊™ÔøΩÔøΩ‚Äé‚ÄèÔøΩ"
  },
  "win1255": "windows1255",
  "cp1255": "windows1255",
  "windows1256": {
    "type": "_sbcs",
    "chars": "‚Ç¨Ÿæ‚Äö∆í‚Äû‚Ä¶‚Ä†‚Ä°ÀÜ‚Ä∞Ÿπ‚Äπ≈í⁄Ü⁄ò⁄à⁄Ø‚Äò‚Äô‚Äú‚Äù‚Ä¢‚Äì‚Äî⁄©‚Ñ¢⁄ë‚Ä∫≈ì‚Äå‚Äç⁄∫¬†ÿå¬¢¬£¬§¬•¬¶¬ß¬®¬©⁄æ¬´¬¨¬≠¬Æ¬Ø¬∞¬±¬≤¬≥¬¥¬µ¬∂¬∑¬∏¬πÿõ¬ª¬º¬Ω¬æÿü€Åÿ°ÿ¢ÿ£ÿ§ÿ•ÿ¶ÿßÿ®ÿ©ÿ™ÿ´ÿ¨ÿ≠ÿÆÿØÿ∞ÿ±ÿ≤ÿ≥ÿ¥ÿµÿ∂√óÿ∑ÿ∏ÿπÿ∫ŸÄŸÅŸÇŸÉ√†ŸÑ√¢ŸÖŸÜŸáŸà√ß√®√©√™√´ŸâŸä√Æ√ØŸãŸåŸçŸé√¥ŸèŸê√∑Ÿë√πŸí√ª√º‚Äé‚Äè€í"
  },
  "win1256": "windows1256",
  "cp1256": "windows1256",
  "windows1257": {
    "type": "_sbcs",
    "chars": "‚Ç¨ÔøΩ‚ÄöÔøΩ‚Äû‚Ä¶‚Ä†‚Ä°ÔøΩ‚Ä∞ÔøΩ‚ÄπÔøΩ¬®Àá¬∏ÔøΩ‚Äò‚Äô‚Äú‚Äù‚Ä¢‚Äì‚ÄîÔøΩ‚Ñ¢ÔøΩ‚Ä∫ÔøΩ¬ØÀõÔøΩ¬†ÔøΩ¬¢¬£¬§ÔøΩ¬¶¬ß√ò¬©≈ñ¬´¬¨¬≠¬Æ√Ü¬∞¬±¬≤¬≥¬¥¬µ¬∂¬∑√∏¬π≈ó¬ª¬º¬Ω¬æ√¶ƒÑƒÆƒÄƒÜ√Ñ√Öƒòƒíƒå√â≈πƒñƒ¢ƒ∂ƒ™ƒª≈†≈É≈Ö√ì≈å√ï√ñ√ó≈≤≈Å≈ö≈™√ú≈ª≈Ω√üƒÖƒØƒÅƒá√§√•ƒôƒìƒç√©≈∫ƒóƒ£ƒ∑ƒ´ƒº≈°≈Ñ≈Ü√≥≈ç√µ√∂√∑≈≥≈Ç≈õ≈´√º≈º≈æÀô"
  },
  "win1257": "windows1257",
  "cp1257": "windows1257",
  "windows1258": {
    "type": "_sbcs",
    "chars": "‚Ç¨ÔøΩ‚Äö∆í‚Äû‚Ä¶‚Ä†‚Ä°ÀÜ‚Ä∞ÔøΩ‚Äπ≈íÔøΩÔøΩÔøΩÔøΩ‚Äò‚Äô‚Äú‚Äù‚Ä¢‚Äì‚ÄîÀú‚Ñ¢ÔøΩ‚Ä∫≈ìÔøΩÔøΩ≈∏¬†¬°¬¢¬£¬§¬•¬¶¬ß¬®¬©¬™¬´¬¨¬≠¬Æ¬Ø¬∞¬±¬≤¬≥¬¥¬µ¬∂¬∑¬∏¬π¬∫¬ª¬º¬Ω¬æ¬ø√Ä√Å√ÇƒÇ√Ñ√Ö√Ü√á√à√â√ä√ãÃÄ√ç√é√èƒê√ëÃâ√ì√î∆†√ñ√ó√ò√ô√ö√õ√ú∆ØÃÉ√ü√†√°√¢ƒÉ√§√•√¶√ß√®√©√™√´ÃÅ√≠√Æ√Øƒë√±Ã£√≥√¥∆°√∂√∑√∏√π√∫√ª√º∆∞‚Ç´√ø"
  },
  "win1258": "windows1258",
  "cp1258": "windows1258",
  "iso88591": {
    "type": "_sbcs",
    "chars": "¬Ä¬Å¬Ç¬É¬Ñ¬Ö¬Ü¬á¬à¬â¬ä¬ã¬å¬ç¬é¬è¬ê¬ë¬í¬ì¬î¬ï¬ñ¬ó¬ò¬ô¬ö¬õ¬ú¬ù¬û¬ü¬†¬°¬¢¬£¬§¬•¬¶¬ß¬®¬©¬™¬´¬¨¬≠¬Æ¬Ø¬∞¬±¬≤¬≥¬¥¬µ¬∂¬∑¬∏¬π¬∫¬ª¬º¬Ω¬æ¬ø√Ä√Å√Ç√É√Ñ√Ö√Ü√á√à√â√ä√ã√å√ç√é√è√ê√ë√í√ì√î√ï√ñ√ó√ò√ô√ö√õ√ú√ù√û√ü√†√°√¢√£√§√•√¶√ß√®√©√™√´√¨√≠√Æ√Ø√∞√±√≤√≥√¥√µ√∂√∑√∏√π√∫√ª√º√Ω√æ√ø"
  },
  "cp28591": "iso88591",
  "iso88592": {
    "type": "_sbcs",
    "chars": "¬Ä¬Å¬Ç¬É¬Ñ¬Ö¬Ü¬á¬à¬â¬ä¬ã¬å¬ç¬é¬è¬ê¬ë¬í¬ì¬î¬ï¬ñ¬ó¬ò¬ô¬ö¬õ¬ú¬ù¬û¬ü¬†ƒÑÀò≈Å¬§ƒΩ≈ö¬ß¬®≈†≈û≈§≈π¬≠≈Ω≈ª¬∞ƒÖÀõ≈Ç¬¥ƒæ≈õÀá¬∏≈°≈ü≈•≈∫Àù≈æ≈º≈î√Å√ÇƒÇ√ÑƒπƒÜ√áƒå√âƒò√ãƒö√ç√éƒéƒê≈É≈á√ì√î≈ê√ñ√ó≈ò≈Æ√ö≈∞√ú√ù≈¢√ü≈ï√°√¢ƒÉ√§ƒ∫ƒá√ßƒç√©ƒô√´ƒõ√≠√Æƒèƒë≈Ñ≈à√≥√¥≈ë√∂√∑≈ô≈Ø√∫≈±√º√Ω≈£Àô"
  },
  "cp28592": "iso88592",
  "iso88593": {
    "type": "_sbcs",
    "chars": "¬Ä¬Å¬Ç¬É¬Ñ¬Ö¬Ü¬á¬à¬â¬ä¬ã¬å¬ç¬é¬è¬ê¬ë¬í¬ì¬î¬ï¬ñ¬ó¬ò¬ô¬ö¬õ¬ú¬ù¬û¬ü¬†ƒ¶Àò¬£¬§ÔøΩƒ§¬ß¬®ƒ∞≈ûƒûƒ¥¬≠ÔøΩ≈ª¬∞ƒß¬≤¬≥¬¥¬µƒ•¬∑¬∏ƒ±≈üƒüƒµ¬ΩÔøΩ≈º√Ä√Å√ÇÔøΩ√Ñƒäƒà√á√à√â√ä√ã√å√ç√é√èÔøΩ√ë√í√ì√îƒ†√ñ√óƒú√ô√ö√õ√ú≈¨≈ú√ü√†√°√¢ÔøΩ√§ƒãƒâ√ß√®√©√™√´√¨√≠√Æ√ØÔøΩ√±√≤√≥√¥ƒ°√∂√∑ƒù√π√∫√ª√º≈≠≈ùÀô"
  },
  "cp28593": "iso88593",
  "iso88594": {
    "type": "_sbcs",
    "chars": "¬Ä¬Å¬Ç¬É¬Ñ¬Ö¬Ü¬á¬à¬â¬ä¬ã¬å¬ç¬é¬è¬ê¬ë¬í¬ì¬î¬ï¬ñ¬ó¬ò¬ô¬ö¬õ¬ú¬ù¬û¬ü¬†ƒÑƒ∏≈ñ¬§ƒ®ƒª¬ß¬®≈†ƒíƒ¢≈¶¬≠≈Ω¬Ø¬∞ƒÖÀõ≈ó¬¥ƒ©ƒºÀá¬∏≈°ƒìƒ£≈ß≈ä≈æ≈ãƒÄ√Å√Ç√É√Ñ√Ö√ÜƒÆƒå√âƒò√ãƒñ√ç√éƒ™ƒê≈Ö≈åƒ∂√î√ï√ñ√ó√ò≈≤√ö√õ√ú≈®≈™√üƒÅ√°√¢√£√§√•√¶ƒØƒç√©ƒô√´ƒó√≠√Æƒ´ƒë≈Ü≈çƒ∑√¥√µ√∂√∑√∏≈≥√∫√ª√º≈©≈´Àô"
  },
  "cp28594": "iso88594",
  "iso88595": {
    "type": "_sbcs",
    "chars": "¬Ä¬Å¬Ç¬É¬Ñ¬Ö¬Ü¬á¬à¬â¬ä¬ã¬å¬ç¬é¬è¬ê¬ë¬í¬ì¬î¬ï¬ñ¬ó¬ò¬ô¬ö¬õ¬ú¬ù¬û¬ü¬†–Å–Ç–É–Ñ–Ö–Ü–á–à–â–ä–ã–å¬≠–é–è–ê–ë–í–ì–î–ï–ñ–ó–ò–ô–ö–õ–ú–ù–û–ü–†–°–¢–£–§–•–¶–ß–®–©–™–´–¨–≠–Æ–Ø–∞–±–≤–≥–¥–µ–∂–∑–∏–π–∫–ª–º–Ω–æ–ø—Ä—Å—Ç—É—Ñ—Ö—Ü—á—à—â—ä—ã—å—ç—é—è‚Ññ—ë—í—ì—î—ï—ñ—ó—ò—ô—ö—õ—ú¬ß—û—ü"
  },
  "cp28595": "iso88595",
  "iso88596": {
    "type": "_sbcs",
    "chars": "¬Ä¬Å¬Ç¬É¬Ñ¬Ö¬Ü¬á¬à¬â¬ä¬ã¬å¬ç¬é¬è¬ê¬ë¬í¬ì¬î¬ï¬ñ¬ó¬ò¬ô¬ö¬õ¬ú¬ù¬û¬ü¬†ÔøΩÔøΩÔøΩ¬§ÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÿå¬≠ÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÿõÔøΩÔøΩÔøΩÿüÔøΩÿ°ÿ¢ÿ£ÿ§ÿ•ÿ¶ÿßÿ®ÿ©ÿ™ÿ´ÿ¨ÿ≠ÿÆÿØÿ∞ÿ±ÿ≤ÿ≥ÿ¥ÿµÿ∂ÿ∑ÿ∏ÿπÿ∫ÔøΩÔøΩÔøΩÔøΩÔøΩŸÄŸÅŸÇŸÉŸÑŸÖŸÜŸáŸàŸâŸäŸãŸåŸçŸéŸèŸêŸëŸíÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩ"
  },
  "cp28596": "iso88596",
  "iso88597": {
    "type": "_sbcs",
    "chars": "¬Ä¬Å¬Ç¬É¬Ñ¬Ö¬Ü¬á¬à¬â¬ä¬ã¬å¬ç¬é¬è¬ê¬ë¬í¬ì¬î¬ï¬ñ¬ó¬ò¬ô¬ö¬õ¬ú¬ù¬û¬ü¬†‚Äò‚Äô¬£‚Ç¨‚ÇØ¬¶¬ß¬®¬©Õ∫¬´¬¨¬≠ÔøΩ‚Äï¬∞¬±¬≤¬≥ŒÑŒÖŒÜ¬∑ŒàŒâŒä¬ªŒå¬ΩŒéŒèŒêŒëŒíŒìŒîŒïŒñŒóŒòŒôŒöŒõŒúŒùŒûŒüŒ†Œ°ÔøΩŒ£Œ§Œ•Œ¶ŒßŒ®Œ©Œ™Œ´Œ¨Œ≠ŒÆŒØŒ∞Œ±Œ≤Œ≥Œ¥ŒµŒ∂Œ∑Œ∏ŒπŒ∫ŒªŒºŒΩŒæŒøœÄœÅœÇœÉœÑœÖœÜœáœàœâœäœãœåœçœéÔøΩ"
  },
  "cp28597": "iso88597",
  "iso88598": {
    "type": "_sbcs",
    "chars": "¬Ä¬Å¬Ç¬É¬Ñ¬Ö¬Ü¬á¬à¬â¬ä¬ã¬å¬ç¬é¬è¬ê¬ë¬í¬ì¬î¬ï¬ñ¬ó¬ò¬ô¬ö¬õ¬ú¬ù¬û¬ü¬†ÔøΩ¬¢¬£¬§¬•¬¶¬ß¬®¬©√ó¬´¬¨¬≠¬Æ¬Ø¬∞¬±¬≤¬≥¬¥¬µ¬∂¬∑¬∏¬π√∑¬ª¬º¬Ω¬æÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩ‚Äó◊ê◊ë◊í◊ì◊î◊ï◊ñ◊ó◊ò◊ô◊ö◊õ◊ú◊ù◊û◊ü◊†◊°◊¢◊£◊§◊•◊¶◊ß◊®◊©◊™ÔøΩÔøΩ‚Äé‚ÄèÔøΩ"
  },
  "cp28598": "iso88598",
  "iso88599": {
    "type": "_sbcs",
    "chars": "¬Ä¬Å¬Ç¬É¬Ñ¬Ö¬Ü¬á¬à¬â¬ä¬ã¬å¬ç¬é¬è¬ê¬ë¬í¬ì¬î¬ï¬ñ¬ó¬ò¬ô¬ö¬õ¬ú¬ù¬û¬ü¬†¬°¬¢¬£¬§¬•¬¶¬ß¬®¬©¬™¬´¬¨¬≠¬Æ¬Ø¬∞¬±¬≤¬≥¬¥¬µ¬∂¬∑¬∏¬π¬∫¬ª¬º¬Ω¬æ¬ø√Ä√Å√Ç√É√Ñ√Ö√Ü√á√à√â√ä√ã√å√ç√é√èƒû√ë√í√ì√î√ï√ñ√ó√ò√ô√ö√õ√úƒ∞≈û√ü√†√°√¢√£√§√•√¶√ß√®√©√™√´√¨√≠√Æ√Øƒü√±√≤√≥√¥√µ√∂√∑√∏√π√∫√ª√ºƒ±≈ü√ø"
  },
  "cp28599": "iso88599",
  "iso885910": {
    "type": "_sbcs",
    "chars": "¬Ä¬Å¬Ç¬É¬Ñ¬Ö¬Ü¬á¬à¬â¬ä¬ã¬å¬ç¬é¬è¬ê¬ë¬í¬ì¬î¬ï¬ñ¬ó¬ò¬ô¬ö¬õ¬ú¬ù¬û¬ü¬†ƒÑƒíƒ¢ƒ™ƒ®ƒ∂¬ßƒªƒê≈†≈¶≈Ω¬≠≈™≈ä¬∞ƒÖƒìƒ£ƒ´ƒ©ƒ∑¬∑ƒºƒë≈°≈ß≈æ‚Äï≈´≈ãƒÄ√Å√Ç√É√Ñ√Ö√ÜƒÆƒå√âƒò√ãƒñ√ç√é√è√ê≈Ö≈å√ì√î√ï√ñ≈®√ò≈≤√ö√õ√ú√ù√û√üƒÅ√°√¢√£√§√•√¶ƒØƒç√©ƒô√´ƒó√≠√Æ√Ø√∞≈Ü≈ç√≥√¥√µ√∂≈©√∏≈≥√∫√ª√º√Ω√æƒ∏"
  },
  "cp28600": "iso885910",
  "iso885911": {
    "type": "_sbcs",
    "chars": "¬Ä¬Å¬Ç¬É¬Ñ¬Ö¬Ü¬á¬à¬â¬ä¬ã¬å¬ç¬é¬è¬ê¬ë¬í¬ì¬î¬ï¬ñ¬ó¬ò¬ô¬ö¬õ¬ú¬ù¬û¬ü¬†‡∏Å‡∏Ç‡∏É‡∏Ñ‡∏Ö‡∏Ü‡∏á‡∏à‡∏â‡∏ä‡∏ã‡∏å‡∏ç‡∏é‡∏è‡∏ê‡∏ë‡∏í‡∏ì‡∏î‡∏ï‡∏ñ‡∏ó‡∏ò‡∏ô‡∏ö‡∏õ‡∏ú‡∏ù‡∏û‡∏ü‡∏†‡∏°‡∏¢‡∏£‡∏§‡∏•‡∏¶‡∏ß‡∏®‡∏©‡∏™‡∏´‡∏¨‡∏≠‡∏Æ‡∏Ø‡∏∞‡∏±‡∏≤‡∏≥‡∏¥‡∏µ‡∏∂‡∏∑‡∏∏‡∏π‡∏∫ÔøΩÔøΩÔøΩÔøΩ‡∏ø‡πÄ‡πÅ‡πÇ‡πÉ‡πÑ‡πÖ‡πÜ‡πá‡πà‡πâ‡πä‡πã‡πå‡πç‡πé‡πè‡πê‡πë‡πí‡πì‡πî‡πï‡πñ‡πó‡πò‡πô‡πö‡πõÔøΩÔøΩÔøΩÔøΩ"
  },
  "cp28601": "iso885911",
  "iso885913": {
    "type": "_sbcs",
    "chars": "¬Ä¬Å¬Ç¬É¬Ñ¬Ö¬Ü¬á¬à¬â¬ä¬ã¬å¬ç¬é¬è¬ê¬ë¬í¬ì¬î¬ï¬ñ¬ó¬ò¬ô¬ö¬õ¬ú¬ù¬û¬ü¬†‚Äù¬¢¬£¬§‚Äû¬¶¬ß√ò¬©≈ñ¬´¬¨¬≠¬Æ√Ü¬∞¬±¬≤¬≥‚Äú¬µ¬∂¬∑√∏¬π≈ó¬ª¬º¬Ω¬æ√¶ƒÑƒÆƒÄƒÜ√Ñ√Öƒòƒíƒå√â≈πƒñƒ¢ƒ∂ƒ™ƒª≈†≈É≈Ö√ì≈å√ï√ñ√ó≈≤≈Å≈ö≈™√ú≈ª≈Ω√üƒÖƒØƒÅƒá√§√•ƒôƒìƒç√©≈∫ƒóƒ£ƒ∑ƒ´ƒº≈°≈Ñ≈Ü√≥≈ç√µ√∂√∑≈≥≈Ç≈õ≈´√º≈º≈æ‚Äô"
  },
  "cp28603": "iso885913",
  "iso885914": {
    "type": "_sbcs",
    "chars": "¬Ä¬Å¬Ç¬É¬Ñ¬Ö¬Ü¬á¬à¬â¬ä¬ã¬å¬ç¬é¬è¬ê¬ë¬í¬ì¬î¬ï¬ñ¬ó¬ò¬ô¬ö¬õ¬ú¬ù¬û¬ü¬†·∏Ç·∏É¬£ƒäƒã·∏ä¬ß·∫Ä¬©·∫Ç·∏ã·ª≤¬≠¬Æ≈∏·∏û·∏üƒ†ƒ°·πÄ·πÅ¬∂·πñ·∫Å·πó·∫É·π†·ª≥·∫Ñ·∫Ö·π°√Ä√Å√Ç√É√Ñ√Ö√Ü√á√à√â√ä√ã√å√ç√é√è≈¥√ë√í√ì√î√ï√ñ·π™√ò√ô√ö√õ√ú√ù≈∂√ü√†√°√¢√£√§√•√¶√ß√®√©√™√´√¨√≠√Æ√Ø≈µ√±√≤√≥√¥√µ√∂·π´√∏√π√∫√ª√º√Ω≈∑√ø"
  },
  "cp28604": "iso885914",
  "iso885915": {
    "type": "_sbcs",
    "chars": "¬Ä¬Å¬Ç¬É¬Ñ¬Ö¬Ü¬á¬à¬â¬ä¬ã¬å¬ç¬é¬è¬ê¬ë¬í¬ì¬î¬ï¬ñ¬ó¬ò¬ô¬ö¬õ¬ú¬ù¬û¬ü¬†¬°¬¢¬£‚Ç¨¬•≈†¬ß≈°¬©¬™¬´¬¨¬≠¬Æ¬Ø¬∞¬±¬≤¬≥≈Ω¬µ¬∂¬∑≈æ¬π¬∫¬ª≈í≈ì≈∏¬ø√Ä√Å√Ç√É√Ñ√Ö√Ü√á√à√â√ä√ã√å√ç√é√è√ê√ë√í√ì√î√ï√ñ√ó√ò√ô√ö√õ√ú√ù√û√ü√†√°√¢√£√§√•√¶√ß√®√©√™√´√¨√≠√Æ√Ø√∞√±√≤√≥√¥√µ√∂√∑√∏√π√∫√ª√º√Ω√æ√ø"
  },
  "cp28605": "iso885915",
  "iso885916": {
    "type": "_sbcs",
    "chars": "¬Ä¬Å¬Ç¬É¬Ñ¬Ö¬Ü¬á¬à¬â¬ä¬ã¬å¬ç¬é¬è¬ê¬ë¬í¬ì¬î¬ï¬ñ¬ó¬ò¬ô¬ö¬õ¬ú¬ù¬û¬ü¬†ƒÑƒÖ≈Å‚Ç¨‚Äû≈†¬ß≈°¬©»ò¬´≈π¬≠≈∫≈ª¬∞¬±ƒå≈Ç≈Ω‚Äù¬∂¬∑≈æƒç»ô¬ª≈í≈ì≈∏≈º√Ä√Å√ÇƒÇ√ÑƒÜ√Ü√á√à√â√ä√ã√å√ç√é√èƒê≈É√í√ì√î≈ê√ñ≈ö≈∞√ô√ö√õ√úƒò»ö√ü√†√°√¢ƒÉ√§ƒá√¶√ß√®√©√™√´√¨√≠√Æ√Øƒë≈Ñ√≤√≥√¥≈ë√∂≈õ≈±√π√∫√ª√ºƒô»õ√ø"
  },
  "cp28606": "iso885916",
  "cp437": {
    "type": "_sbcs",
    "chars": "√á√º√©√¢√§√†√•√ß√™√´√®√Ø√Æ√¨√Ñ√Ö√â√¶√Ü√¥√∂√≤√ª√π√ø√ñ√ú¬¢¬£¬•‚Çß∆í√°√≠√≥√∫√±√ë¬™¬∫¬ø‚åê¬¨¬Ω¬º¬°¬´¬ª‚ñë‚ñí‚ñì‚îÇ‚î§‚ï°‚ï¢‚ïñ‚ïï‚ï£‚ïë‚ïó‚ïù‚ïú‚ïõ‚îê‚îî‚î¥‚î¨‚îú‚îÄ‚îº‚ïû‚ïü‚ïö‚ïî‚ï©‚ï¶‚ï†‚ïê‚ï¨‚ïß‚ï®‚ï§‚ï•‚ïô‚ïò‚ïí‚ïì‚ï´‚ï™‚îò‚îå‚ñà‚ñÑ‚ñå‚ñê‚ñÄŒ±√üŒìœÄŒ£œÉ¬µœÑŒ¶ŒòŒ©Œ¥‚àûœÜŒµ‚à©‚â°¬±‚â•‚â§‚å†‚å°√∑‚âà¬∞‚àô¬∑‚àö‚Åø¬≤‚ñ†¬†"
  },
  "ibm437": "cp437",
  "csibm437": "cp437",
  "cp737": {
    "type": "_sbcs",
    "chars": "ŒëŒíŒìŒîŒïŒñŒóŒòŒôŒöŒõŒúŒùŒûŒüŒ†Œ°Œ£Œ§Œ•Œ¶ŒßŒ®Œ©Œ±Œ≤Œ≥Œ¥ŒµŒ∂Œ∑Œ∏ŒπŒ∫ŒªŒºŒΩŒæŒøœÄœÅœÉœÇœÑœÖœÜœáœà‚ñë‚ñí‚ñì‚îÇ‚î§‚ï°‚ï¢‚ïñ‚ïï‚ï£‚ïë‚ïó‚ïù‚ïú‚ïõ‚îê‚îî‚î¥‚î¨‚îú‚îÄ‚îº‚ïû‚ïü‚ïö‚ïî‚ï©‚ï¶‚ï†‚ïê‚ï¨‚ïß‚ï®‚ï§‚ï•‚ïô‚ïò‚ïí‚ïì‚ï´‚ï™‚îò‚îå‚ñà‚ñÑ‚ñå‚ñê‚ñÄœâŒ¨Œ≠ŒÆœäŒØœåœçœãœéŒÜŒàŒâŒäŒåŒéŒè¬±‚â•‚â§Œ™Œ´√∑‚âà¬∞‚àô¬∑‚àö‚Åø¬≤‚ñ†¬†"
  },
  "ibm737": "cp737",
  "csibm737": "cp737",
  "cp775": {
    "type": "_sbcs",
    "chars": "ƒÜ√º√©ƒÅ√§ƒ£√•ƒá≈Çƒì≈ñ≈óƒ´≈π√Ñ√Ö√â√¶√Ü≈ç√∂ƒ¢¬¢≈ö≈õ√ñ√ú√∏¬£√ò√ó¬§ƒÄƒ™√≥≈ª≈º≈∫‚Äù¬¶¬©¬Æ¬¨¬Ω¬º≈Å¬´¬ª‚ñë‚ñí‚ñì‚îÇ‚î§ƒÑƒåƒòƒñ‚ï£‚ïë‚ïó‚ïùƒÆ≈†‚îê‚îî‚î¥‚î¨‚îú‚îÄ‚îº≈≤≈™‚ïö‚ïî‚ï©‚ï¶‚ï†‚ïê‚ï¨≈ΩƒÖƒçƒôƒóƒØ≈°≈≥≈´≈æ‚îò‚îå‚ñà‚ñÑ‚ñå‚ñê‚ñÄ√ì√ü≈å≈É√µ√ï¬µ≈Ñƒ∂ƒ∑ƒªƒº≈Üƒí≈Ö‚Äô¬≠¬±‚Äú¬æ¬∂¬ß√∑‚Äû¬∞‚àô¬∑¬π¬≥¬≤‚ñ†¬†"
  },
  "ibm775": "cp775",
  "csibm775": "cp775",
  "cp850": {
    "type": "_sbcs",
    "chars": "√á√º√©√¢√§√†√•√ß√™√´√®√Ø√Æ√¨√Ñ√Ö√â√¶√Ü√¥√∂√≤√ª√π√ø√ñ√ú√∏¬£√ò√ó∆í√°√≠√≥√∫√±√ë¬™¬∫¬ø¬Æ¬¨¬Ω¬º¬°¬´¬ª‚ñë‚ñí‚ñì‚îÇ‚î§√Å√Ç√Ä¬©‚ï£‚ïë‚ïó‚ïù¬¢¬•‚îê‚îî‚î¥‚î¨‚îú‚îÄ‚îº√£√É‚ïö‚ïî‚ï©‚ï¶‚ï†‚ïê‚ï¨¬§√∞√ê√ä√ã√àƒ±√ç√é√è‚îò‚îå‚ñà‚ñÑ¬¶√å‚ñÄ√ì√ü√î√í√µ√ï¬µ√æ√û√ö√õ√ô√Ω√ù¬Ø¬¥¬≠¬±‚Äó¬æ¬∂¬ß√∑¬∏¬∞¬®¬∑¬π¬≥¬≤‚ñ†¬†"
  },
  "ibm850": "cp850",
  "csibm850": "cp850",
  "cp852": {
    "type": "_sbcs",
    "chars": "√á√º√©√¢√§≈Øƒá√ß≈Ç√´≈ê≈ë√Æ≈π√ÑƒÜ√âƒπƒ∫√¥√∂ƒΩƒæ≈ö≈õ√ñ√ú≈§≈•≈Å√óƒç√°√≠√≥√∫ƒÑƒÖ≈Ω≈æƒòƒô¬¨≈∫ƒå≈ü¬´¬ª‚ñë‚ñí‚ñì‚îÇ‚î§√Å√Çƒö≈û‚ï£‚ïë‚ïó‚ïù≈ª≈º‚îê‚îî‚î¥‚î¨‚îú‚îÄ‚îºƒÇƒÉ‚ïö‚ïî‚ï©‚ï¶‚ï†‚ïê‚ï¨¬§ƒëƒêƒé√ãƒè≈á√ç√éƒõ‚îò‚îå‚ñà‚ñÑ≈¢≈Æ‚ñÄ√ì√ü√î≈É≈Ñ≈à≈†≈°≈î√ö≈ï≈∞√Ω√ù≈£¬¥¬≠ÀùÀõÀáÀò¬ß√∑¬∏¬∞¬®Àô≈±≈ò≈ô‚ñ†¬†"
  },
  "ibm852": "cp852",
  "csibm852": "cp852",
  "cp855": {
    "type": "_sbcs",
    "chars": "—í–Ç—ì–É—ë–Å—î–Ñ—ï–Ö—ñ–Ü—ó–á—ò–à—ô–â—ö–ä—õ–ã—ú–å—û–é—ü–è—é–Æ—ä–™–∞–ê–±–ë—Ü–¶–¥–î–µ–ï—Ñ–§–≥–ì¬´¬ª‚ñë‚ñí‚ñì‚îÇ‚î§—Ö–•–∏–ò‚ï£‚ïë‚ïó‚ïù–π–ô‚îê‚îî‚î¥‚î¨‚îú‚îÄ‚îº–∫–ö‚ïö‚ïî‚ï©‚ï¶‚ï†‚ïê‚ï¨¬§–ª–õ–º–ú–Ω–ù–æ–û–ø‚îò‚îå‚ñà‚ñÑ–ü—è‚ñÄ–Ø—Ä–†—Å–°—Ç–¢—É–£–∂–ñ–≤–í—å–¨‚Ññ¬≠—ã–´–∑–ó—à–®—ç–≠—â–©—á–ß¬ß‚ñ†¬†"
  },
  "ibm855": "cp855",
  "csibm855": "cp855",
  "cp856": {
    "type": "_sbcs",
    "chars": "◊ê◊ë◊í◊ì◊î◊ï◊ñ◊ó◊ò◊ô◊ö◊õ◊ú◊ù◊û◊ü◊†◊°◊¢◊£◊§◊•◊¶◊ß◊®◊©◊™ÔøΩ¬£ÔøΩ√óÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩ¬Æ¬¨¬Ω¬ºÔøΩ¬´¬ª‚ñë‚ñí‚ñì‚îÇ‚î§ÔøΩÔøΩÔøΩ¬©‚ï£‚ïë‚ïó‚ïù¬¢¬•‚îê‚îî‚î¥‚î¨‚îú‚îÄ‚îºÔøΩÔøΩ‚ïö‚ïî‚ï©‚ï¶‚ï†‚ïê‚ï¨¬§ÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩ‚îò‚îå‚ñà‚ñÑ¬¶ÔøΩ‚ñÄÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩ¬µÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩ¬Ø¬¥¬≠¬±‚Äó¬æ¬∂¬ß√∑¬∏¬∞¬®¬∑¬π¬≥¬≤‚ñ†¬†"
  },
  "ibm856": "cp856",
  "csibm856": "cp856",
  "cp857": {
    "type": "_sbcs",
    "chars": "√á√º√©√¢√§√†√•√ß√™√´√®√Ø√Æƒ±√Ñ√Ö√â√¶√Ü√¥√∂√≤√ª√πƒ∞√ñ√ú√∏¬£√ò≈û≈ü√°√≠√≥√∫√±√ëƒûƒü¬ø¬Æ¬¨¬Ω¬º¬°¬´¬ª‚ñë‚ñí‚ñì‚îÇ‚î§√Å√Ç√Ä¬©‚ï£‚ïë‚ïó‚ïù¬¢¬•‚îê‚îî‚î¥‚î¨‚îú‚îÄ‚îº√£√É‚ïö‚ïî‚ï©‚ï¶‚ï†‚ïê‚ï¨¬§¬∫¬™√ä√ã√àÔøΩ√ç√é√è‚îò‚îå‚ñà‚ñÑ¬¶√å‚ñÄ√ì√ü√î√í√µ√ï¬µÔøΩ√ó√ö√õ√ô√¨√ø¬Ø¬¥¬≠¬±ÔøΩ¬æ¬∂¬ß√∑¬∏¬∞¬®¬∑¬π¬≥¬≤‚ñ†¬†"
  },
  "ibm857": "cp857",
  "csibm857": "cp857",
  "cp858": {
    "type": "_sbcs",
    "chars": "√á√º√©√¢√§√†√•√ß√™√´√®√Ø√Æ√¨√Ñ√Ö√â√¶√Ü√¥√∂√≤√ª√π√ø√ñ√ú√∏¬£√ò√ó∆í√°√≠√≥√∫√±√ë¬™¬∫¬ø¬Æ¬¨¬Ω¬º¬°¬´¬ª‚ñë‚ñí‚ñì‚îÇ‚î§√Å√Ç√Ä¬©‚ï£‚ïë‚ïó‚ïù¬¢¬•‚îê‚îî‚î¥‚î¨‚îú‚îÄ‚îº√£√É‚ïö‚ïî‚ï©‚ï¶‚ï†‚ïê‚ï¨¬§√∞√ê√ä√ã√à‚Ç¨√ç√é√è‚îò‚îå‚ñà‚ñÑ¬¶√å‚ñÄ√ì√ü√î√í√µ√ï¬µ√æ√û√ö√õ√ô√Ω√ù¬Ø¬¥¬≠¬±‚Äó¬æ¬∂¬ß√∑¬∏¬∞¬®¬∑¬π¬≥¬≤‚ñ†¬†"
  },
  "ibm858": "cp858",
  "csibm858": "cp858",
  "cp860": {
    "type": "_sbcs",
    "chars": "√á√º√©√¢√£√†√Å√ß√™√ä√®√ç√î√¨√É√Ç√â√Ä√à√¥√µ√≤√ö√π√å√ï√ú¬¢¬£√ô‚Çß√ì√°√≠√≥√∫√±√ë¬™¬∫¬ø√í¬¨¬Ω¬º¬°¬´¬ª‚ñë‚ñí‚ñì‚îÇ‚î§‚ï°‚ï¢‚ïñ‚ïï‚ï£‚ïë‚ïó‚ïù‚ïú‚ïõ‚îê‚îî‚î¥‚î¨‚îú‚îÄ‚îº‚ïû‚ïü‚ïö‚ïî‚ï©‚ï¶‚ï†‚ïê‚ï¨‚ïß‚ï®‚ï§‚ï•‚ïô‚ïò‚ïí‚ïì‚ï´‚ï™‚îò‚îå‚ñà‚ñÑ‚ñå‚ñê‚ñÄŒ±√üŒìœÄŒ£œÉ¬µœÑŒ¶ŒòŒ©Œ¥‚àûœÜŒµ‚à©‚â°¬±‚â•‚â§‚å†‚å°√∑‚âà¬∞‚àô¬∑‚àö‚Åø¬≤‚ñ†¬†"
  },
  "ibm860": "cp860",
  "csibm860": "cp860",
  "cp861": {
    "type": "_sbcs",
    "chars": "√á√º√©√¢√§√†√•√ß√™√´√®√ê√∞√û√Ñ√Ö√â√¶√Ü√¥√∂√æ√ª√ù√Ω√ñ√ú√∏¬£√ò‚Çß∆í√°√≠√≥√∫√Å√ç√ì√ö¬ø‚åê¬¨¬Ω¬º¬°¬´¬ª‚ñë‚ñí‚ñì‚îÇ‚î§‚ï°‚ï¢‚ïñ‚ïï‚ï£‚ïë‚ïó‚ïù‚ïú‚ïõ‚îê‚îî‚î¥‚î¨‚îú‚îÄ‚îº‚ïû‚ïü‚ïö‚ïî‚ï©‚ï¶‚ï†‚ïê‚ï¨‚ïß‚ï®‚ï§‚ï•‚ïô‚ïò‚ïí‚ïì‚ï´‚ï™‚îò‚îå‚ñà‚ñÑ‚ñå‚ñê‚ñÄŒ±√üŒìœÄŒ£œÉ¬µœÑŒ¶ŒòŒ©Œ¥‚àûœÜŒµ‚à©‚â°¬±‚â•‚â§‚å†‚å°√∑‚âà¬∞‚àô¬∑‚àö‚Åø¬≤‚ñ†¬†"
  },
  "ibm861": "cp861",
  "csibm861": "cp861",
  "cp862": {
    "type": "_sbcs",
    "chars": "◊ê◊ë◊í◊ì◊î◊ï◊ñ◊ó◊ò◊ô◊ö◊õ◊ú◊ù◊û◊ü◊†◊°◊¢◊£◊§◊•◊¶◊ß◊®◊©◊™¬¢¬£¬•‚Çß∆í√°√≠√≥√∫√±√ë¬™¬∫¬ø‚åê¬¨¬Ω¬º¬°¬´¬ª‚ñë‚ñí‚ñì‚îÇ‚î§‚ï°‚ï¢‚ïñ‚ïï‚ï£‚ïë‚ïó‚ïù‚ïú‚ïõ‚îê‚îî‚î¥‚î¨‚îú‚îÄ‚îº‚ïû‚ïü‚ïö‚ïî‚ï©‚ï¶‚ï†‚ïê‚ï¨‚ïß‚ï®‚ï§‚ï•‚ïô‚ïò‚ïí‚ïì‚ï´‚ï™‚îò‚îå‚ñà‚ñÑ‚ñå‚ñê‚ñÄŒ±√üŒìœÄŒ£œÉ¬µœÑŒ¶ŒòŒ©Œ¥‚àûœÜŒµ‚à©‚â°¬±‚â•‚â§‚å†‚å°√∑‚âà¬∞‚àô¬∑‚àö‚Åø¬≤‚ñ†¬†"
  },
  "ibm862": "cp862",
  "csibm862": "cp862",
  "cp863": {
    "type": "_sbcs",
    "chars": "√á√º√©√¢√Ç√†¬∂√ß√™√´√®√Ø√Æ‚Äó√Ä¬ß√â√à√ä√¥√ã√è√ª√π¬§√î√ú¬¢¬£√ô√õ∆í¬¶¬¥√≥√∫¬®¬∏¬≥¬Ø√é‚åê¬¨¬Ω¬º¬æ¬´¬ª‚ñë‚ñí‚ñì‚îÇ‚î§‚ï°‚ï¢‚ïñ‚ïï‚ï£‚ïë‚ïó‚ïù‚ïú‚ïõ‚îê‚îî‚î¥‚î¨‚îú‚îÄ‚îº‚ïû‚ïü‚ïö‚ïî‚ï©‚ï¶‚ï†‚ïê‚ï¨‚ïß‚ï®‚ï§‚ï•‚ïô‚ïò‚ïí‚ïì‚ï´‚ï™‚îò‚îå‚ñà‚ñÑ‚ñå‚ñê‚ñÄŒ±√üŒìœÄŒ£œÉ¬µœÑŒ¶ŒòŒ©Œ¥‚àûœÜŒµ‚à©‚â°¬±‚â•‚â§‚å†‚å°√∑‚âà¬∞‚àô¬∑‚àö‚Åø¬≤‚ñ†¬†"
  },
  "ibm863": "cp863",
  "csibm863": "cp863",
  "cp864": {
    "type": "_sbcs",
    "chars": "\u0000\u0001\u0002\u0003\u0004\u0005\u0006\u0007\b\t\n\u000b\f\r\u000e\u000f\u0010\u0011\u0012\u0013\u0014\u0015\u0016\u0017\u0018\u0019\u001a\u001b\u001c\u001d\u001e\u001f !\"#$Ÿ™&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~¬∞¬∑‚àô‚àö‚ñí‚îÄ‚îÇ‚îº‚î§‚î¨‚îú‚î¥‚îê‚îå‚îî‚îòŒ≤‚àûœÜ¬±¬Ω¬º‚âà¬´¬ªÔª∑Ôª∏ÔøΩÔøΩÔªªÔªºÔøΩ¬†¬≠Ô∫Ç¬£¬§Ô∫ÑÔøΩÔøΩÔ∫éÔ∫èÔ∫ïÔ∫ôÿåÔ∫ùÔ∫°Ô∫•Ÿ†Ÿ°Ÿ¢Ÿ£Ÿ§Ÿ•Ÿ¶ŸßŸ®Ÿ©ÔªëÿõÔ∫±Ô∫µÔ∫πÿü¬¢Ô∫ÄÔ∫ÅÔ∫ÉÔ∫ÖÔªäÔ∫ãÔ∫çÔ∫ëÔ∫ìÔ∫óÔ∫õÔ∫üÔ∫£Ô∫ßÔ∫©Ô∫´Ô∫≠Ô∫ØÔ∫≥Ô∫∑Ô∫ªÔ∫øÔªÅÔªÖÔªãÔªè¬¶¬¨√∑√óÔªâŸÄÔªìÔªóÔªõÔªüÔª£ÔªßÔª´Ôª≠ÔªØÔª≥Ô∫ΩÔªåÔªéÔªçÔª°ÔπΩŸëÔª•Ôª©Ôª¨Ôª∞Ôª≤ÔªêÔªïÔªµÔª∂ÔªùÔªôÔª±‚ñ†ÔøΩ"
  },
  "ibm864": "cp864",
  "csibm864": "cp864",
  "cp865": {
    "type": "_sbcs",
    "chars": "√á√º√©√¢√§√†√•√ß√™√´√®√Ø√Æ√¨√Ñ√Ö√â√¶√Ü√¥√∂√≤√ª√π√ø√ñ√ú√∏¬£√ò‚Çß∆í√°√≠√≥√∫√±√ë¬™¬∫¬ø‚åê¬¨¬Ω¬º¬°¬´¬§‚ñë‚ñí‚ñì‚îÇ‚î§‚ï°‚ï¢‚ïñ‚ïï‚ï£‚ïë‚ïó‚ïù‚ïú‚ïõ‚îê‚îî‚î¥‚î¨‚îú‚îÄ‚îº‚ïû‚ïü‚ïö‚ïî‚ï©‚ï¶‚ï†‚ïê‚ï¨‚ïß‚ï®‚ï§‚ï•‚ïô‚ïò‚ïí‚ïì‚ï´‚ï™‚îò‚îå‚ñà‚ñÑ‚ñå‚ñê‚ñÄŒ±√üŒìœÄŒ£œÉ¬µœÑŒ¶ŒòŒ©Œ¥‚àûœÜŒµ‚à©‚â°¬±‚â•‚â§‚å†‚å°√∑‚âà¬∞‚àô¬∑‚àö‚Åø¬≤‚ñ†¬†"
  },
  "ibm865": "cp865",
  "csibm865": "cp865",
  "cp866": {
    "type": "_sbcs",
    "chars": "–ê–ë–í–ì–î–ï–ñ–ó–ò–ô–ö–õ–ú–ù–û–ü–†–°–¢–£–§–•–¶–ß–®–©–™–´–¨–≠–Æ–Ø–∞–±–≤–≥–¥–µ–∂–∑–∏–π–∫–ª–º–Ω–æ–ø‚ñë‚ñí‚ñì‚îÇ‚î§‚ï°‚ï¢‚ïñ‚ïï‚ï£‚ïë‚ïó‚ïù‚ïú‚ïõ‚îê‚îî‚î¥‚î¨‚îú‚îÄ‚îº‚ïû‚ïü‚ïö‚ïî‚ï©‚ï¶‚ï†‚ïê‚ï¨‚ïß‚ï®‚ï§‚ï•‚ïô‚ïò‚ïí‚ïì‚ï´‚ï™‚îò‚îå‚ñà‚ñÑ‚ñå‚ñê‚ñÄ—Ä—Å—Ç—É—Ñ—Ö—Ü—á—à—â—ä—ã—å—ç—é—è–Å—ë–Ñ—î–á—ó–é—û¬∞‚àô¬∑‚àö‚Ññ¬§‚ñ†¬†"
  },
  "ibm866": "cp866",
  "csibm866": "cp866",
  "cp869": {
    "type": "_sbcs",
    "chars": "ÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩŒÜÔøΩ¬∑¬¨¬¶‚Äò‚ÄôŒà‚ÄïŒâŒäŒ™ŒåÔøΩÔøΩŒéŒ´¬©Œè¬≤¬≥Œ¨¬£Œ≠ŒÆŒØœäŒêœåœçŒëŒíŒìŒîŒïŒñŒó¬ΩŒòŒô¬´¬ª‚ñë‚ñí‚ñì‚îÇ‚î§ŒöŒõŒúŒù‚ï£‚ïë‚ïó‚ïùŒûŒü‚îê‚îî‚î¥‚î¨‚îú‚îÄ‚îºŒ†Œ°‚ïö‚ïî‚ï©‚ï¶‚ï†‚ïê‚ï¨Œ£Œ§Œ•Œ¶ŒßŒ®Œ©Œ±Œ≤Œ≥‚îò‚îå‚ñà‚ñÑŒ¥Œµ‚ñÄŒ∂Œ∑Œ∏ŒπŒ∫ŒªŒºŒΩŒæŒøœÄœÅœÉœÇœÑŒÑ¬≠¬±œÖœÜœá¬ßœàŒÖ¬∞¬®œâœãŒ∞œé‚ñ†¬†"
  },
  "ibm869": "cp869",
  "csibm869": "cp869",
  "cp922": {
    "type": "_sbcs",
    "chars": "¬Ä¬Å¬Ç¬É¬Ñ¬Ö¬Ü¬á¬à¬â¬ä¬ã¬å¬ç¬é¬è¬ê¬ë¬í¬ì¬î¬ï¬ñ¬ó¬ò¬ô¬ö¬õ¬ú¬ù¬û¬ü¬†¬°¬¢¬£¬§¬•¬¶¬ß¬®¬©¬™¬´¬¨¬≠¬Æ‚Äæ¬∞¬±¬≤¬≥¬¥¬µ¬∂¬∑¬∏¬π¬∫¬ª¬º¬Ω¬æ¬ø√Ä√Å√Ç√É√Ñ√Ö√Ü√á√à√â√ä√ã√å√ç√é√è≈†√ë√í√ì√î√ï√ñ√ó√ò√ô√ö√õ√ú√ù≈Ω√ü√†√°√¢√£√§√•√¶√ß√®√©√™√´√¨√≠√Æ√Ø≈°√±√≤√≥√¥√µ√∂√∑√∏√π√∫√ª√º√Ω≈æ√ø"
  },
  "ibm922": "cp922",
  "csibm922": "cp922",
  "cp1046": {
    "type": "_sbcs",
    "chars": "Ô∫à√ó√∑Ô£∂Ô£µÔ£¥Ô£∑Ôπ±¬à‚ñ†‚îÇ‚îÄ‚îê‚îå‚îî‚îòÔππÔπªÔπΩÔπøÔπ∑Ô∫äÔª∞Ôª≥Ôª≤ÔªéÔªèÔªêÔª∂Ôª∏Ôª∫Ôªº¬†Ô£∫Ô£πÔ£∏¬§Ô£ªÔ∫ãÔ∫ëÔ∫óÔ∫õÔ∫üÔ∫£ÿå¬≠Ô∫ßÔ∫≥Ÿ†Ÿ°Ÿ¢Ÿ£Ÿ§Ÿ•Ÿ¶ŸßŸ®Ÿ©Ô∫∑ÿõÔ∫ªÔ∫øÔªäÿüÔªãÿ°ÿ¢ÿ£ÿ§ÿ•ÿ¶ÿßÿ®ÿ©ÿ™ÿ´ÿ¨ÿ≠ÿÆÿØÿ∞ÿ±ÿ≤ÿ≥ÿ¥ÿµÿ∂ÿ∑Ôªáÿπÿ∫ÔªåÔ∫ÇÔ∫ÑÔ∫éÔªìŸÄŸÅŸÇŸÉŸÑŸÖŸÜŸáŸàŸâŸäŸãŸåŸçŸéŸèŸêŸëŸíÔªóÔªõÔªüÔ£ºÔªµÔª∑ÔªπÔªªÔª£ÔªßÔª¨Ôª©ÔøΩ"
  },
  "ibm1046": "cp1046",
  "csibm1046": "cp1046",
  "cp1124": {
    "type": "_sbcs",
    "chars": "¬Ä¬Å¬Ç¬É¬Ñ¬Ö¬Ü¬á¬à¬â¬ä¬ã¬å¬ç¬é¬è¬ê¬ë¬í¬ì¬î¬ï¬ñ¬ó¬ò¬ô¬ö¬õ¬ú¬ù¬û¬ü¬†–Å–Ç“ê–Ñ–Ö–Ü–á–à–â–ä–ã–å¬≠–é–è–ê–ë–í–ì–î–ï–ñ–ó–ò–ô–ö–õ–ú–ù–û–ü–†–°–¢–£–§–•–¶–ß–®–©–™–´–¨–≠–Æ–Ø–∞–±–≤–≥–¥–µ–∂–∑–∏–π–∫–ª–º–Ω–æ–ø—Ä—Å—Ç—É—Ñ—Ö—Ü—á—à—â—ä—ã—å—ç—é—è‚Ññ—ë—í“ë—î—ï—ñ—ó—ò—ô—ö—õ—ú¬ß—û—ü"
  },
  "ibm1124": "cp1124",
  "csibm1124": "cp1124",
  "cp1125": {
    "type": "_sbcs",
    "chars": "–ê–ë–í–ì–î–ï–ñ–ó–ò–ô–ö–õ–ú–ù–û–ü–†–°–¢–£–§–•–¶–ß–®–©–™–´–¨–≠–Æ–Ø–∞–±–≤–≥–¥–µ–∂–∑–∏–π–∫–ª–º–Ω–æ–ø‚ñë‚ñí‚ñì‚îÇ‚î§‚ï°‚ï¢‚ïñ‚ïï‚ï£‚ïë‚ïó‚ïù‚ïú‚ïõ‚îê‚îî‚î¥‚î¨‚îú‚îÄ‚îº‚ïû‚ïü‚ïö‚ïî‚ï©‚ï¶‚ï†‚ïê‚ï¨‚ïß‚ï®‚ï§‚ï•‚ïô‚ïò‚ïí‚ïì‚ï´‚ï™‚îò‚îå‚ñà‚ñÑ‚ñå‚ñê‚ñÄ—Ä—Å—Ç—É—Ñ—Ö—Ü—á—à—â—ä—ã—å—ç—é—è–Å—ë“ê“ë–Ñ—î–Ü—ñ–á—ó¬∑‚àö‚Ññ¬§‚ñ†¬†"
  },
  "ibm1125": "cp1125",
  "csibm1125": "cp1125",
  "cp1129": {
    "type": "_sbcs",
    "chars": "¬Ä¬Å¬Ç¬É¬Ñ¬Ö¬Ü¬á¬à¬â¬ä¬ã¬å¬ç¬é¬è¬ê¬ë¬í¬ì¬î¬ï¬ñ¬ó¬ò¬ô¬ö¬õ¬ú¬ù¬û¬ü¬†¬°¬¢¬£¬§¬•¬¶¬ß≈ì¬©¬™¬´¬¨¬≠¬Æ¬Ø¬∞¬±¬≤¬≥≈∏¬µ¬∂¬∑≈í¬π¬∫¬ª¬º¬Ω¬æ¬ø√Ä√Å√ÇƒÇ√Ñ√Ö√Ü√á√à√â√ä√ãÃÄ√ç√é√èƒê√ëÃâ√ì√î∆†√ñ√ó√ò√ô√ö√õ√ú∆ØÃÉ√ü√†√°√¢ƒÉ√§√•√¶√ß√®√©√™√´ÃÅ√≠√Æ√Øƒë√±Ã£√≥√¥∆°√∂√∑√∏√π√∫√ª√º∆∞‚Ç´√ø"
  },
  "ibm1129": "cp1129",
  "csibm1129": "cp1129",
  "cp1133": {
    "type": "_sbcs",
    "chars": "¬Ä¬Å¬Ç¬É¬Ñ¬Ö¬Ü¬á¬à¬â¬ä¬ã¬å¬ç¬é¬è¬ê¬ë¬í¬ì¬î¬ï¬ñ¬ó¬ò¬ô¬ö¬õ¬ú¬ù¬û¬ü¬†‡∫Å‡∫Ç‡∫Ñ‡∫á‡∫à‡∫™‡∫ä‡∫ç‡∫î‡∫ï‡∫ñ‡∫ó‡∫ô‡∫ö‡∫õ‡∫ú‡∫ù‡∫û‡∫ü‡∫°‡∫¢‡∫£‡∫•‡∫ß‡∫´‡∫≠‡∫ÆÔøΩÔøΩÔøΩ‡∫Ø‡∫∞‡∫≤‡∫≥‡∫¥‡∫µ‡∫∂‡∫∑‡∫∏‡∫π‡∫º‡∫±‡∫ª‡∫ΩÔøΩÔøΩÔøΩ‡ªÄ‡ªÅ‡ªÇ‡ªÉ‡ªÑ‡ªà‡ªâ‡ªä‡ªã‡ªå‡ªç‡ªÜÔøΩ‡ªú‡ªù‚Ç≠ÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩ‡ªê‡ªë‡ªí‡ªì‡ªî‡ªï‡ªñ‡ªó‡ªò‡ªôÔøΩÔøΩ¬¢¬¨¬¶ÔøΩ"
  },
  "ibm1133": "cp1133",
  "csibm1133": "cp1133",
  "cp1161": {
    "type": "_sbcs",
    "chars": "ÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩ‡πà‡∏Å‡∏Ç‡∏É‡∏Ñ‡∏Ö‡∏Ü‡∏á‡∏à‡∏â‡∏ä‡∏ã‡∏å‡∏ç‡∏é‡∏è‡∏ê‡∏ë‡∏í‡∏ì‡∏î‡∏ï‡∏ñ‡∏ó‡∏ò‡∏ô‡∏ö‡∏õ‡∏ú‡∏ù‡∏û‡∏ü‡∏†‡∏°‡∏¢‡∏£‡∏§‡∏•‡∏¶‡∏ß‡∏®‡∏©‡∏™‡∏´‡∏¨‡∏≠‡∏Æ‡∏Ø‡∏∞‡∏±‡∏≤‡∏≥‡∏¥‡∏µ‡∏∂‡∏∑‡∏∏‡∏π‡∏∫‡πâ‡πä‡πã‚Ç¨‡∏ø‡πÄ‡πÅ‡πÇ‡πÉ‡πÑ‡πÖ‡πÜ‡πá‡πà‡πâ‡πä‡πã‡πå‡πç‡πé‡πè‡πê‡πë‡πí‡πì‡πî‡πï‡πñ‡πó‡πò‡πô‡πö‡πõ¬¢¬¨¬¶¬†"
  },
  "ibm1161": "cp1161",
  "csibm1161": "cp1161",
  "cp1162": {
    "type": "_sbcs",
    "chars": "‚Ç¨¬Å¬Ç¬É¬Ñ‚Ä¶¬Ü¬á¬à¬â¬ä¬ã¬å¬ç¬é¬è¬ê‚Äò‚Äô‚Äú‚Äù‚Ä¢‚Äì‚Äî¬ò¬ô¬ö¬õ¬ú¬ù¬û¬ü¬†‡∏Å‡∏Ç‡∏É‡∏Ñ‡∏Ö‡∏Ü‡∏á‡∏à‡∏â‡∏ä‡∏ã‡∏å‡∏ç‡∏é‡∏è‡∏ê‡∏ë‡∏í‡∏ì‡∏î‡∏ï‡∏ñ‡∏ó‡∏ò‡∏ô‡∏ö‡∏õ‡∏ú‡∏ù‡∏û‡∏ü‡∏†‡∏°‡∏¢‡∏£‡∏§‡∏•‡∏¶‡∏ß‡∏®‡∏©‡∏™‡∏´‡∏¨‡∏≠‡∏Æ‡∏Ø‡∏∞‡∏±‡∏≤‡∏≥‡∏¥‡∏µ‡∏∂‡∏∑‡∏∏‡∏π‡∏∫ÔøΩÔøΩÔøΩÔøΩ‡∏ø‡πÄ‡πÅ‡πÇ‡πÉ‡πÑ‡πÖ‡πÜ‡πá‡πà‡πâ‡πä‡πã‡πå‡πç‡πé‡πè‡πê‡πë‡πí‡πì‡πî‡πï‡πñ‡πó‡πò‡πô‡πö‡πõÔøΩÔøΩÔøΩÔøΩ"
  },
  "ibm1162": "cp1162",
  "csibm1162": "cp1162",
  "cp1163": {
    "type": "_sbcs",
    "chars": "¬Ä¬Å¬Ç¬É¬Ñ¬Ö¬Ü¬á¬à¬â¬ä¬ã¬å¬ç¬é¬è¬ê¬ë¬í¬ì¬î¬ï¬ñ¬ó¬ò¬ô¬ö¬õ¬ú¬ù¬û¬ü¬†¬°¬¢¬£‚Ç¨¬•¬¶¬ß≈ì¬©¬™¬´¬¨¬≠¬Æ¬Ø¬∞¬±¬≤¬≥≈∏¬µ¬∂¬∑≈í¬π¬∫¬ª¬º¬Ω¬æ¬ø√Ä√Å√ÇƒÇ√Ñ√Ö√Ü√á√à√â√ä√ãÃÄ√ç√é√èƒê√ëÃâ√ì√î∆†√ñ√ó√ò√ô√ö√õ√ú∆ØÃÉ√ü√†√°√¢ƒÉ√§√•√¶√ß√®√©√™√´ÃÅ√≠√Æ√Øƒë√±Ã£√≥√¥∆°√∂√∑√∏√π√∫√ª√º∆∞‚Ç´√ø"
  },
  "ibm1163": "cp1163",
  "csibm1163": "cp1163",
  "maccroatian": {
    "type": "_sbcs",
    "chars": "√Ñ√Ö√á√â√ë√ñ√ú√°√†√¢√§√£√•√ß√©√®√™√´√≠√¨√Æ√Ø√±√≥√≤√¥√∂√µ√∫√π√ª√º‚Ä†¬∞¬¢¬£¬ß‚Ä¢¬∂√ü¬Æ≈†‚Ñ¢¬¥¬®‚â†≈Ω√ò‚àû¬±‚â§‚â•‚àÜ¬µ‚àÇ‚àë‚àè≈°‚à´¬™¬∫‚Ñ¶≈æ√∏¬ø¬°¬¨‚àö∆í‚âàƒÜ¬´ƒå‚Ä¶¬†√Ä√É√ï≈í≈ìƒê‚Äî‚Äú‚Äù‚Äò‚Äô√∑‚óäÔøΩ¬©‚ÅÑ¬§‚Äπ‚Ä∫√Ü¬ª‚Äì¬∑‚Äö‚Äû‚Ä∞√Çƒá√Åƒç√à√ç√é√è√å√ì√îƒë√í√ö√õ√ôƒ±ÀÜÀú¬ØœÄ√ãÀö¬∏√ä√¶Àá"
  },
  "maccyrillic": {
    "type": "_sbcs",
    "chars": "–ê–ë–í–ì–î–ï–ñ–ó–ò–ô–ö–õ–ú–ù–û–ü–†–°–¢–£–§–•–¶–ß–®–©–™–´–¨–≠–Æ–Ø‚Ä†¬∞¬¢¬£¬ß‚Ä¢¬∂–Ü¬Æ¬©‚Ñ¢–Ç—í‚â†–É—ì‚àû¬±‚â§‚â•—ñ¬µ‚àÇ–à–Ñ—î–á—ó–â—ô–ä—ö—ò–Ö¬¨‚àö∆í‚âà‚àÜ¬´¬ª‚Ä¶¬†–ã—õ–å—ú—ï‚Äì‚Äî‚Äú‚Äù‚Äò‚Äô√∑‚Äû–é—û–è—ü‚Ññ–Å—ë—è–∞–±–≤–≥–¥–µ–∂–∑–∏–π–∫–ª–º–Ω–æ–ø—Ä—Å—Ç—É—Ñ—Ö—Ü—á—à—â—ä—ã—å—ç—é¬§"
  },
  "macgreek": {
    "type": "_sbcs",
    "chars": "√Ñ¬π¬≤√â¬≥√ñ√úŒÖ√†√¢√§ŒÑ¬®√ß√©√®√™√´¬£‚Ñ¢√Æ√Ø‚Ä¢¬Ω‚Ä∞√¥√∂¬¶¬≠√π√ª√º‚Ä†ŒìŒîŒòŒõŒûŒ†√ü¬Æ¬©Œ£Œ™¬ß‚â†¬∞ŒáŒë¬±‚â§‚â•¬•ŒíŒïŒñŒóŒôŒöŒúŒ¶Œ´Œ®Œ©Œ¨Œù¬¨ŒüŒ°‚âàŒ§¬´¬ª‚Ä¶¬†Œ•ŒßŒÜŒà≈ì‚Äì‚Äï‚Äú‚Äù‚Äò‚Äô√∑ŒâŒäŒåŒéŒ≠ŒÆŒØœåŒèœçŒ±Œ≤œàŒ¥ŒµœÜŒ≥Œ∑ŒπŒæŒ∫ŒªŒºŒΩŒøœÄœéœÅœÉœÑŒ∏œâœÇœáœÖŒ∂œäœãŒêŒ∞ÔøΩ"
  },
  "maciceland": {
    "type": "_sbcs",
    "chars": "√Ñ√Ö√á√â√ë√ñ√ú√°√†√¢√§√£√•√ß√©√®√™√´√≠√¨√Æ√Ø√±√≥√≤√¥√∂√µ√∫√π√ª√º√ù¬∞¬¢¬£¬ß‚Ä¢¬∂√ü¬Æ¬©‚Ñ¢¬¥¬®‚â†√Ü√ò‚àû¬±‚â§‚â•¬•¬µ‚àÇ‚àë‚àèœÄ‚à´¬™¬∫‚Ñ¶√¶√∏¬ø¬°¬¨‚àö∆í‚âà‚àÜ¬´¬ª‚Ä¶¬†√Ä√É√ï≈í≈ì‚Äì‚Äî‚Äú‚Äù‚Äò‚Äô√∑‚óä√ø≈∏‚ÅÑ¬§√ê√∞√û√æ√Ω¬∑‚Äö‚Äû‚Ä∞√Ç√ä√Å√ã√à√ç√é√è√å√ì√îÔøΩ√í√ö√õ√ôƒ±ÀÜÀú¬ØÀòÀôÀö¬∏ÀùÀõÀá"
  },
  "macroman": {
    "type": "_sbcs",
    "chars": "√Ñ√Ö√á√â√ë√ñ√ú√°√†√¢√§√£√•√ß√©√®√™√´√≠√¨√Æ√Ø√±√≥√≤√¥√∂√µ√∫√π√ª√º‚Ä†¬∞¬¢¬£¬ß‚Ä¢¬∂√ü¬Æ¬©‚Ñ¢¬¥¬®‚â†√Ü√ò‚àû¬±‚â§‚â•¬•¬µ‚àÇ‚àë‚àèœÄ‚à´¬™¬∫‚Ñ¶√¶√∏¬ø¬°¬¨‚àö∆í‚âà‚àÜ¬´¬ª‚Ä¶¬†√Ä√É√ï≈í≈ì‚Äì‚Äî‚Äú‚Äù‚Äò‚Äô√∑‚óä√ø≈∏‚ÅÑ¬§‚Äπ‚Ä∫Ô¨ÅÔ¨Ç‚Ä°¬∑‚Äö‚Äû‚Ä∞√Ç√ä√Å√ã√à√ç√é√è√å√ì√îÔøΩ√í√ö√õ√ôƒ±ÀÜÀú¬ØÀòÀôÀö¬∏ÀùÀõÀá"
  },
  "macromania": {
    "type": "_sbcs",
    "chars": "√Ñ√Ö√á√â√ë√ñ√ú√°√†√¢√§√£√•√ß√©√®√™√´√≠√¨√Æ√Ø√±√≥√≤√¥√∂√µ√∫√π√ª√º‚Ä†¬∞¬¢¬£¬ß‚Ä¢¬∂√ü¬Æ¬©‚Ñ¢¬¥¬®‚â†ƒÇ≈û‚àû¬±‚â§‚â•¬•¬µ‚àÇ‚àë‚àèœÄ‚à´¬™¬∫‚Ñ¶ƒÉ≈ü¬ø¬°¬¨‚àö∆í‚âà‚àÜ¬´¬ª‚Ä¶¬†√Ä√É√ï≈í≈ì‚Äì‚Äî‚Äú‚Äù‚Äò‚Äô√∑‚óä√ø≈∏‚ÅÑ¬§‚Äπ‚Ä∫≈¢≈£‚Ä°¬∑‚Äö‚Äû‚Ä∞√Ç√ä√Å√ã√à√ç√é√è√å√ì√îÔøΩ√í√ö√õ√ôƒ±ÀÜÀú¬ØÀòÀôÀö¬∏ÀùÀõÀá"
  },
  "macthai": {
    "type": "_sbcs",
    "chars": "¬´¬ª‚Ä¶Ô¢åÔ¢èÔ¢íÔ¢ïÔ¢òÔ¢ãÔ¢éÔ¢ëÔ¢îÔ¢ó‚Äú‚ÄùÔ¢ôÔøΩ‚Ä¢Ô¢ÑÔ¢âÔ¢ÖÔ¢ÜÔ¢áÔ¢àÔ¢äÔ¢çÔ¢êÔ¢ìÔ¢ñ‚Äò‚ÄôÔøΩ¬†‡∏Å‡∏Ç‡∏É‡∏Ñ‡∏Ö‡∏Ü‡∏á‡∏à‡∏â‡∏ä‡∏ã‡∏å‡∏ç‡∏é‡∏è‡∏ê‡∏ë‡∏í‡∏ì‡∏î‡∏ï‡∏ñ‡∏ó‡∏ò‡∏ô‡∏ö‡∏õ‡∏ú‡∏ù‡∏û‡∏ü‡∏†‡∏°‡∏¢‡∏£‡∏§‡∏•‡∏¶‡∏ß‡∏®‡∏©‡∏™‡∏´‡∏¨‡∏≠‡∏Æ‡∏Ø‡∏∞‡∏±‡∏≤‡∏≥‡∏¥‡∏µ‡∏∂‡∏∑‡∏∏‡∏π‡∏∫Ôªø‚Äã‚Äì‚Äî‡∏ø‡πÄ‡πÅ‡πÇ‡πÉ‡πÑ‡πÖ‡πÜ‡πá‡πà‡πâ‡πä‡πã‡πå‡πç‚Ñ¢‡πè‡πê‡πë‡πí‡πì‡πî‡πï‡πñ‡πó‡πò‡πô¬Æ¬©ÔøΩÔøΩÔøΩÔøΩ"
  },
  "macturkish": {
    "type": "_sbcs",
    "chars": "√Ñ√Ö√á√â√ë√ñ√ú√°√†√¢√§√£√•√ß√©√®√™√´√≠√¨√Æ√Ø√±√≥√≤√¥√∂√µ√∫√π√ª√º‚Ä†¬∞¬¢¬£¬ß‚Ä¢¬∂√ü¬Æ¬©‚Ñ¢¬¥¬®‚â†√Ü√ò‚àû¬±‚â§‚â•¬•¬µ‚àÇ‚àë‚àèœÄ‚à´¬™¬∫‚Ñ¶√¶√∏¬ø¬°¬¨‚àö∆í‚âà‚àÜ¬´¬ª‚Ä¶¬†√Ä√É√ï≈í≈ì‚Äì‚Äî‚Äú‚Äù‚Äò‚Äô√∑‚óä√ø≈∏ƒûƒüƒ∞ƒ±≈û≈ü‚Ä°¬∑‚Äö‚Äû‚Ä∞√Ç√ä√Å√ã√à√ç√é√è√å√ì√îÔøΩ√í√ö√õ√ôÔøΩÀÜÀú¬ØÀòÀôÀö¬∏ÀùÀõÀá"
  },
  "macukraine": {
    "type": "_sbcs",
    "chars": "–ê–ë–í–ì–î–ï–ñ–ó–ò–ô–ö–õ–ú–ù–û–ü–†–°–¢–£–§–•–¶–ß–®–©–™–´–¨–≠–Æ–Ø‚Ä†¬∞“ê¬£¬ß‚Ä¢¬∂–Ü¬Æ¬©‚Ñ¢–Ç—í‚â†–É—ì‚àû¬±‚â§‚â•—ñ¬µ“ë–à–Ñ—î–á—ó–â—ô–ä—ö—ò–Ö¬¨‚àö∆í‚âà‚àÜ¬´¬ª‚Ä¶¬†–ã—õ–å—ú—ï‚Äì‚Äî‚Äú‚Äù‚Äò‚Äô√∑‚Äû–é—û–è—ü‚Ññ–Å—ë—è–∞–±–≤–≥–¥–µ–∂–∑–∏–π–∫–ª–º–Ω–æ–ø—Ä—Å—Ç—É—Ñ—Ö—Ü—á—à—â—ä—ã—å—ç—é¬§"
  },
  "koi8r": {
    "type": "_sbcs",
    "chars": "‚îÄ‚îÇ‚îå‚îê‚îî‚îò‚îú‚î§‚î¨‚î¥‚îº‚ñÄ‚ñÑ‚ñà‚ñå‚ñê‚ñë‚ñí‚ñì‚å†‚ñ†‚àô‚àö‚âà‚â§‚â•¬†‚å°¬∞¬≤¬∑√∑‚ïê‚ïë‚ïí—ë‚ïì‚ïî‚ïï‚ïñ‚ïó‚ïò‚ïô‚ïö‚ïõ‚ïú‚ïù‚ïû‚ïü‚ï†‚ï°–Å‚ï¢‚ï£‚ï§‚ï•‚ï¶‚ïß‚ï®‚ï©‚ï™‚ï´‚ï¨¬©—é–∞–±—Ü–¥–µ—Ñ–≥—Ö–∏–π–∫–ª–º–Ω–æ–ø—è—Ä—Å—Ç—É–∂–≤—å—ã–∑—à—ç—â—á—ä–Æ–ê–ë–¶–î–ï–§–ì–•–ò–ô–ö–õ–ú–ù–û–ü–Ø–†–°–¢–£–ñ–í–¨–´–ó–®–≠–©–ß–™"
  },
  "koi8u": {
    "type": "_sbcs",
    "chars": "‚îÄ‚îÇ‚îå‚îê‚îî‚îò‚îú‚î§‚î¨‚î¥‚îº‚ñÄ‚ñÑ‚ñà‚ñå‚ñê‚ñë‚ñí‚ñì‚å†‚ñ†‚àô‚àö‚âà‚â§‚â•¬†‚å°¬∞¬≤¬∑√∑‚ïê‚ïë‚ïí—ë—î‚ïî—ñ—ó‚ïó‚ïò‚ïô‚ïö‚ïõ“ë‚ïù‚ïû‚ïü‚ï†‚ï°–Å–Ñ‚ï£–Ü–á‚ï¶‚ïß‚ï®‚ï©‚ï™“ê‚ï¨¬©—é–∞–±—Ü–¥–µ—Ñ–≥—Ö–∏–π–∫–ª–º–Ω–æ–ø—è—Ä—Å—Ç—É–∂–≤—å—ã–∑—à—ç—â—á—ä–Æ–ê–ë–¶–î–ï–§–ì–•–ò–ô–ö–õ–ú–ù–û–ü–Ø–†–°–¢–£–ñ–í–¨–´–ó–®–≠–©–ß–™"
  },
  "koi8ru": {
    "type": "_sbcs",
    "chars": "‚îÄ‚îÇ‚îå‚îê‚îî‚îò‚îú‚î§‚î¨‚î¥‚îº‚ñÄ‚ñÑ‚ñà‚ñå‚ñê‚ñë‚ñí‚ñì‚å†‚ñ†‚àô‚àö‚âà‚â§‚â•¬†‚å°¬∞¬≤¬∑√∑‚ïê‚ïë‚ïí—ë—î‚ïî—ñ—ó‚ïó‚ïò‚ïô‚ïö‚ïõ“ë—û‚ïû‚ïü‚ï†‚ï°–Å–Ñ‚ï£–Ü–á‚ï¶‚ïß‚ï®‚ï©‚ï™“ê–é¬©—é–∞–±—Ü–¥–µ—Ñ–≥—Ö–∏–π–∫–ª–º–Ω–æ–ø—è—Ä—Å—Ç—É–∂–≤—å—ã–∑—à—ç—â—á—ä–Æ–ê–ë–¶–î–ï–§–ì–•–ò–ô–ö–õ–ú–ù–û–ü–Ø–†–°–¢–£–ñ–í–¨–´–ó–®–≠–©–ß–™"
  },
  "koi8t": {
    "type": "_sbcs",
    "chars": "“õ“ì‚Äö“í‚Äû‚Ä¶‚Ä†‚Ä°ÔøΩ‚Ä∞“≥‚Äπ“≤“∑“∂ÔøΩ“ö‚Äò‚Äô‚Äú‚Äù‚Ä¢‚Äì‚ÄîÔøΩ‚Ñ¢ÔøΩ‚Ä∫ÔøΩÔøΩÔøΩÔøΩÔøΩ”Ø”Æ—ë¬§”£¬¶¬ßÔøΩÔøΩÔøΩ¬´¬¨¬≠¬ÆÔøΩ¬∞¬±¬≤–ÅÔøΩ”¢¬∂¬∑ÔøΩ‚ÑñÔøΩ¬ªÔøΩÔøΩÔøΩ¬©—é–∞–±—Ü–¥–µ—Ñ–≥—Ö–∏–π–∫–ª–º–Ω–æ–ø—è—Ä—Å—Ç—É–∂–≤—å—ã–∑—à—ç—â—á—ä–Æ–ê–ë–¶–î–ï–§–ì–•–ò–ô–ö–õ–ú–ù–û–ü–Ø–†–°–¢–£–ñ–í–¨–´–ó–®–≠–©–ß–™"
  },
  "armscii8": {
    "type": "_sbcs",
    "chars": "¬Ä¬Å¬Ç¬É¬Ñ¬Ö¬Ü¬á¬à¬â¬ä¬ã¬å¬ç¬é¬è¬ê¬ë¬í¬ì¬î¬ï¬ñ¬ó¬ò¬ô¬ö¬õ¬ú¬ù¬û¬ü¬†ÔøΩ÷á÷â)(¬ª¬´‚Äî.’ù,-÷ä‚Ä¶’ú’õ’û‘±’°‘≤’¢‘≥’£‘¥’§‘µ’•‘∂’¶‘∑’ß‘∏’®‘π’©‘∫’™‘ª’´‘º’¨‘Ω’≠‘æ’Æ‘ø’Ø’Ä’∞’Å’±’Ç’≤’É’≥’Ñ’¥’Ö’µ’Ü’∂’á’∑’à’∏’â’π’ä’∫’ã’ª’å’º’ç’Ω’é’æ’è’ø’ê÷Ä’ë÷Å’í÷Ç’ì÷É’î÷Ñ’ï÷Ö’ñ÷Ü’öÔøΩ"
  },
  "rk1048": {
    "type": "_sbcs",
    "chars": "–Ç–É‚Äö—ì‚Äû‚Ä¶‚Ä†‚Ä°‚Ç¨‚Ä∞–â‚Äπ–ä“ö“∫–è—í‚Äò‚Äô‚Äú‚Äù‚Ä¢‚Äì‚ÄîÔøΩ‚Ñ¢—ô‚Ä∫—ö“õ“ª—ü¬†“∞“±”ò¬§”®¬¶¬ß–Å¬©“í¬´¬¨¬≠¬Æ“Æ¬∞¬±–Ü—ñ”©¬µ¬∂¬∑—ë‚Ññ“ì¬ª”ô“¢“£“Ø–ê–ë–í–ì–î–ï–ñ–ó–ò–ô–ö–õ–ú–ù–û–ü–†–°–¢–£–§–•–¶–ß–®–©–™–´–¨–≠–Æ–Ø–∞–±–≤–≥–¥–µ–∂–∑–∏–π–∫–ª–º–Ω–æ–ø—Ä—Å—Ç—É—Ñ—Ö—Ü—á—à—â—ä—ã—å—ç—é—è"
  },
  "tcvn": {
    "type": "_sbcs",
    "chars": "\u0000√ö·ª§\u0003·ª™·ª¨·ªÆ\u0007\b\t\n\u000b\f\r\u000e\u000f\u0010·ª®·ª∞·ª≤·ª∂·ª∏√ù·ª¥\u0018\u0019\u001a\u001b\u001c\u001d\u001e\u001f !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~√Ä·∫¢√É√Å·∫†·∫∂·∫¨√à·∫∫·∫º√â·∫∏·ªÜ√å·ªàƒ®√ç·ªä√í·ªé√ï√ì·ªå·ªò·ªú·ªû·ª†·ªö·ª¢√ô·ª¶≈®¬†ƒÇ√Ç√ä√î∆†∆ØƒêƒÉ√¢√™√¥∆°∆∞ƒë·∫∞ÃÄÃâÃÉÃÅÃ£√†·∫£√£√°·∫°·∫≤·∫±·∫≥·∫µ·∫Ø·∫¥·∫Æ·∫¶·∫®·∫™·∫§·ªÄ·∫∑·∫ß·∫©·∫´·∫•·∫≠√®·ªÇ·∫ª·∫Ω√©·∫π·ªÅ·ªÉ·ªÖ·∫ø·ªá√¨·ªâ·ªÑ·∫æ·ªíƒ©√≠·ªã√≤·ªî·ªè√µ√≥·ªç·ªì·ªï·ªó·ªë·ªô·ªù·ªü·ª°·ªõ·ª£√π·ªñ·ªß≈©√∫·ª•·ª´·ª≠·ªØ·ª©·ª±·ª≥·ª∑·ªπ√Ω·ªµ·ªê"
  },
  "georgianacademy": {
    "type": "_sbcs",
    "chars": "¬Ä¬Å‚Äö∆í‚Äû‚Ä¶‚Ä†‚Ä°ÀÜ‚Ä∞≈†‚Äπ≈í¬ç¬é¬è¬ê‚Äò‚Äô‚Äú‚Äù‚Ä¢‚Äì‚ÄîÀú‚Ñ¢≈°‚Ä∫≈ì¬ù¬û≈∏¬†¬°¬¢¬£¬§¬•¬¶¬ß¬®¬©¬™¬´¬¨¬≠¬Æ¬Ø¬∞¬±¬≤¬≥¬¥¬µ¬∂¬∑¬∏¬π¬∫¬ª¬º¬Ω¬æ¬ø·Éê·Éë·Éí·Éì·Éî·Éï·Éñ·Éó·Éò·Éô·Éö·Éõ·Éú·Éù·Éû·Éü·É†·É°·É¢·É£·É§·É•·É¶·Éß·É®·É©·É™·É´·É¨·É≠·ÉÆ·ÉØ·É∞·É±·É≤·É≥·É¥·Éµ·É∂√ß√®√©√™√´√¨√≠√Æ√Ø√∞√±√≤√≥√¥√µ√∂√∑√∏√π√∫√ª√º√Ω√æ√ø"
  },
  "georgianps": {
    "type": "_sbcs",
    "chars": "¬Ä¬Å‚Äö∆í‚Äû‚Ä¶‚Ä†‚Ä°ÀÜ‚Ä∞≈†‚Äπ≈í¬ç¬é¬è¬ê‚Äò‚Äô‚Äú‚Äù‚Ä¢‚Äì‚ÄîÀú‚Ñ¢≈°‚Ä∫≈ì¬ù¬û≈∏¬†¬°¬¢¬£¬§¬•¬¶¬ß¬®¬©¬™¬´¬¨¬≠¬Æ¬Ø¬∞¬±¬≤¬≥¬¥¬µ¬∂¬∑¬∏¬π¬∫¬ª¬º¬Ω¬æ¬ø·Éê·Éë·Éí·Éì·Éî·Éï·Éñ·É±·Éó·Éò·Éô·Éö·Éõ·Éú·É≤·Éù·Éû·Éü·É†·É°·É¢·É≥·É£·É§·É•·É¶·Éß·É®·É©·É™·É´·É¨·É≠·ÉÆ·É¥·ÉØ·É∞·Éµ√¶√ß√®√©√™√´√¨√≠√Æ√Ø√∞√±√≤√≥√¥√µ√∂√∑√∏√π√∫√ª√º√Ω√æ√ø"
  },
  "pt154": {
    "type": "_sbcs",
    "chars": "“ñ“í”Æ“ì‚Äû‚Ä¶“∂“Æ“≤“Ø“†”¢“¢“ö“∫“∏“ó‚Äò‚Äô‚Äú‚Äù‚Ä¢‚Äì‚Äî“≥“∑“°”£“£“õ“ª“π¬†–é—û–à”®“ò“∞¬ß–Å¬©”ò¬´¬¨”Ø¬Æ“ú¬∞“±–Ü—ñ“ô”©¬∂¬∑—ë‚Ññ”ô¬ª—ò“™“´“ù–ê–ë–í–ì–î–ï–ñ–ó–ò–ô–ö–õ–ú–ù–û–ü–†–°–¢–£–§–•–¶–ß–®–©–™–´–¨–≠–Æ–Ø–∞–±–≤–≥–¥–µ–∂–∑–∏–π–∫–ª–º–Ω–æ–ø—Ä—Å—Ç—É—Ñ—Ö—Ü—á—à—â—ä—ã—å—ç—é—è"
  },
  "viscii": {
    "type": "_sbcs",
    "chars": "\u0000\u0001·∫≤\u0003\u0004·∫¥·∫™\u0007\b\t\n\u000b\f\r\u000e\u000f\u0010\u0011\u0012\u0013·ª∂\u0015\u0016\u0017\u0018·ª∏\u001a\u001b\u001c\u001d·ª¥\u001f !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~·∫†·∫Æ·∫∞·∫∂·∫§·∫¶·∫®·∫¨·∫º·∫∏·∫æ·ªÄ·ªÇ·ªÑ·ªÜ·ªê·ªí·ªî·ªñ·ªò·ª¢·ªö·ªú·ªû·ªä·ªé·ªå·ªà·ª¶≈®·ª§·ª≤√ï·∫Ø·∫±·∫∑·∫•·∫ß·∫©·∫≠·∫Ω·∫π·∫ø·ªÅ·ªÉ·ªÖ·ªá·ªë·ªì·ªï·ªó·ª†∆†·ªô·ªù·ªü·ªã·ª∞·ª®·ª™·ª¨∆°·ªõ∆Ø√Ä√Å√Ç√É·∫¢ƒÇ·∫≥·∫µ√à√â√ä·∫∫√å√çƒ®·ª≥ƒê·ª©√í√ì√î·∫°·ª∑·ª´·ª≠√ô√ö·ªπ·ªµ√ù·ª°∆∞√†√°√¢√£·∫£ƒÉ·ªØ·∫´√®√©√™·∫ª√¨√≠ƒ©·ªâƒë·ª±√≤√≥√¥√µ·ªè·ªç·ª•√π√∫≈©·ªß√Ω·ª£·ªÆ"
  },
  "iso646cn": {
    "type": "_sbcs",
    "chars": "\u0000\u0001\u0002\u0003\u0004\u0005\u0006\u0007\b\t\n\u000b\f\r\u000e\u000f\u0010\u0011\u0012\u0013\u0014\u0015\u0016\u0017\u0018\u0019\u001a\u001b\u001c\u001d\u001e\u001f !\"#¬•%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}‚ÄæÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩ"
  },
  "iso646jp": {
    "type": "_sbcs",
    "chars": "\u0000\u0001\u0002\u0003\u0004\u0005\u0006\u0007\b\t\n\u000b\f\r\u000e\u000f\u0010\u0011\u0012\u0013\u0014\u0015\u0016\u0017\u0018\u0019\u001a\u001b\u001c\u001d\u001e\u001f !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[¬•]^_`abcdefghijklmnopqrstuvwxyz{|}‚ÄæÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩ"
  },
  "hproman8": {
    "type": "_sbcs",
    "chars": "¬Ä¬Å¬Ç¬É¬Ñ¬Ö¬Ü¬á¬à¬â¬ä¬ã¬å¬ç¬é¬è¬ê¬ë¬í¬ì¬î¬ï¬ñ¬ó¬ò¬ô¬ö¬õ¬ú¬ù¬û¬ü¬†√Ä√Ç√à√ä√ã√é√è¬¥ÀãÀÜ¬®Àú√ô√õ‚Ç§¬Ø√ù√Ω¬∞√á√ß√ë√±¬°¬ø¬§¬£¬•¬ß∆í¬¢√¢√™√¥√ª√°√©√≥√∫√†√®√≤√π√§√´√∂√º√Ö√Æ√ò√Ü√•√≠√∏√¶√Ñ√¨√ñ√ú√â√Ø√ü√î√Å√É√£√ê√∞√ç√å√ì√í√ï√µ≈†≈°√ö≈∏√ø√û√æ¬∑¬µ¬∂¬æ‚Äî¬º¬Ω¬™¬∫¬´‚ñ†¬ª¬±ÔøΩ"
  },
  "macintosh": {
    "type": "_sbcs",
    "chars": "√Ñ√Ö√á√â√ë√ñ√ú√°√†√¢√§√£√•√ß√©√®√™√´√≠√¨√Æ√Ø√±√≥√≤√¥√∂√µ√∫√π√ª√º‚Ä†¬∞¬¢¬£¬ß‚Ä¢¬∂√ü¬Æ¬©‚Ñ¢¬¥¬®‚â†√Ü√ò‚àû¬±‚â§‚â•¬•¬µ‚àÇ‚àë‚àèœÄ‚à´¬™¬∫‚Ñ¶√¶√∏¬ø¬°¬¨‚àö∆í‚âà‚àÜ¬´¬ª‚Ä¶¬†√Ä√É√ï≈í≈ì‚Äì‚Äî‚Äú‚Äù‚Äò‚Äô√∑‚óä√ø≈∏‚ÅÑ¬§‚Äπ‚Ä∫Ô¨ÅÔ¨Ç‚Ä°¬∑‚Äö‚Äû‚Ä∞√Ç√ä√Å√ã√à√ç√é√è√å√ì√îÔøΩ√í√ö√õ√ôƒ±ÀÜÀú¬ØÀòÀôÀö¬∏ÀùÀõÀá"
  },
  "ascii": {
    "type": "_sbcs",
    "chars": "ÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩ"
  },
  "tis620": {
    "type": "_sbcs",
    "chars": "ÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩ‡∏Å‡∏Ç‡∏É‡∏Ñ‡∏Ö‡∏Ü‡∏á‡∏à‡∏â‡∏ä‡∏ã‡∏å‡∏ç‡∏é‡∏è‡∏ê‡∏ë‡∏í‡∏ì‡∏î‡∏ï‡∏ñ‡∏ó‡∏ò‡∏ô‡∏ö‡∏õ‡∏ú‡∏ù‡∏û‡∏ü‡∏†‡∏°‡∏¢‡∏£‡∏§‡∏•‡∏¶‡∏ß‡∏®‡∏©‡∏™‡∏´‡∏¨‡∏≠‡∏Æ‡∏Ø‡∏∞‡∏±‡∏≤‡∏≥‡∏¥‡∏µ‡∏∂‡∏∑‡∏∏‡∏π‡∏∫ÔøΩÔøΩÔøΩÔøΩ‡∏ø‡πÄ‡πÅ‡πÇ‡πÉ‡πÑ‡πÖ‡πÜ‡πá‡πà‡πâ‡πä‡πã‡πå‡πç‡πé‡πè‡πê‡πë‡πí‡πì‡πî‡πï‡πñ‡πó‡πò‡πô‡πö‡πõÔøΩÔøΩÔøΩÔøΩ"
  }
}

/***/ }),

/***/ 75194:
/***/ ((module) => {

"use strict";


// Manually added data to be used by sbcs codec in addition to generated one.

module.exports = {
    // Not supported by iconv, not sure why.
    "10029": "maccenteuro",
    "maccenteuro": {
        "type": "_sbcs",
        "chars": "√ÑƒÄƒÅ√âƒÑ√ñ√ú√°ƒÖƒå√§ƒçƒÜƒá√©≈π≈∫ƒé√≠ƒèƒíƒìƒñ√≥ƒó√¥√∂√µ√∫ƒöƒõ√º‚Ä†¬∞ƒò¬£¬ß‚Ä¢¬∂√ü¬Æ¬©‚Ñ¢ƒô¬®‚â†ƒ£ƒÆƒØƒ™‚â§‚â•ƒ´ƒ∂‚àÇ‚àë≈ÇƒªƒºƒΩƒæƒπƒ∫≈Ö≈Ü≈É¬¨‚àö≈Ñ≈á‚àÜ¬´¬ª‚Ä¶¬†≈à≈ê√ï≈ë≈å‚Äì‚Äî‚Äú‚Äù‚Äò‚Äô√∑‚óä≈ç≈î≈ï≈ò‚Äπ‚Ä∫≈ô≈ñ≈ó≈†‚Äö‚Äû≈°≈ö≈õ√Å≈§≈•√ç≈Ω≈æ≈™√ì√î≈´≈Æ√ö≈Ø≈∞≈±≈≤≈≥√ù√Ωƒ∑≈ª≈Å≈ºƒ¢Àá"
    },

    "808": "cp808",
    "ibm808": "cp808",
    "cp808": {
        "type": "_sbcs",
        "chars": "–ê–ë–í–ì–î–ï–ñ–ó–ò–ô–ö–õ–ú–ù–û–ü–†–°–¢–£–§–•–¶–ß–®–©–™–´–¨–≠–Æ–Ø–∞–±–≤–≥–¥–µ–∂–∑–∏–π–∫–ª–º–Ω–æ–ø‚ñë‚ñí‚ñì‚îÇ‚î§‚ï°‚ï¢‚ïñ‚ïï‚ï£‚ïë‚ïó‚ïù‚ïú‚ïõ‚îê‚îî‚î¥‚î¨‚îú‚îÄ‚îº‚ïû‚ïü‚ïö‚ïî‚ï©‚ï¶‚ï†‚ïê‚ï¨‚ïß‚ï®‚ï§‚ï•‚ïô‚ïò‚ïí‚ïì‚ï´‚ï™‚îò‚îå‚ñà‚ñÑ‚ñå‚ñê‚ñÄ—Ä—Å—Ç—É—Ñ—Ö—Ü—á—à—â—ä—ã—å—ç—é—è–Å—ë–Ñ—î–á—ó–é—û¬∞‚àô¬∑‚àö‚Ññ‚Ç¨‚ñ†¬†"
    },

    "mik": {
        "type": "_sbcs",
        "chars": "–ê–ë–í–ì–î–ï–ñ–ó–ò–ô–ö–õ–ú–ù–û–ü–†–°–¢–£–§–•–¶–ß–®–©–™–´–¨–≠–Æ–Ø–∞–±–≤–≥–¥–µ–∂–∑–∏–π–∫–ª–º–Ω–æ–ø—Ä—Å—Ç—É—Ñ—Ö—Ü—á—à—â—ä—ã—å—ç—é—è‚îî‚î¥‚î¨‚îú‚îÄ‚îº‚ï£‚ïë‚ïö‚ïî‚ï©‚ï¶‚ï†‚ïê‚ï¨‚îê‚ñë‚ñí‚ñì‚îÇ‚î§‚Ññ¬ß‚ïó‚ïù‚îò‚îå‚ñà‚ñÑ‚ñå‚ñê‚ñÄŒ±√üŒìœÄŒ£œÉ¬µœÑŒ¶ŒòŒ©Œ¥‚àûœÜŒµ‚à©‚â°¬±‚â•‚â§‚å†‚å°√∑‚âà¬∞‚àô¬∑‚àö‚Åø¬≤‚ñ†¬†"
    },

    // Aliases of generated encodings.
    "ascii8bit": "ascii",
    "usascii": "ascii",
    "ansix34": "ascii",
    "ansix341968": "ascii",
    "ansix341986": "ascii",
    "csascii": "ascii",
    "cp367": "ascii",
    "ibm367": "ascii",
    "isoir6": "ascii",
    "iso646us": "ascii",
    "iso646irv": "ascii",
    "us": "ascii",

    "latin1": "iso88591",
    "latin2": "iso88592",
    "latin3": "iso88593",
    "latin4": "iso88594",
    "latin5": "iso88599",
    "latin6": "iso885910",
    "latin7": "iso885913",
    "latin8": "iso885914",
    "latin9": "iso885915",
    "latin10": "iso885916",

    "csisolatin1": "iso88591",
    "csisolatin2": "iso88592",
    "csisolatin3": "iso88593",
    "csisolatin4": "iso88594",
    "csisolatincyrillic": "iso88595",
    "csisolatinarabic": "iso88596",
    "csisolatingreek" : "iso88597",
    "csisolatinhebrew": "iso88598",
    "csisolatin5": "iso88599",
    "csisolatin6": "iso885910",

    "l1": "iso88591",
    "l2": "iso88592",
    "l3": "iso88593",
    "l4": "iso88594",
    "l5": "iso88599",
    "l6": "iso885910",
    "l7": "iso885913",
    "l8": "iso885914",
    "l9": "iso885915",
    "l10": "iso885916",

    "isoir14": "iso646jp",
    "isoir57": "iso646cn",
    "isoir100": "iso88591",
    "isoir101": "iso88592",
    "isoir109": "iso88593",
    "isoir110": "iso88594",
    "isoir144": "iso88595",
    "isoir127": "iso88596",
    "isoir126": "iso88597",
    "isoir138": "iso88598",
    "isoir148": "iso88599",
    "isoir157": "iso885910",
    "isoir166": "tis620",
    "isoir179": "iso885913",
    "isoir199": "iso885914",
    "isoir203": "iso885915",
    "isoir226": "iso885916",

    "cp819": "iso88591",
    "ibm819": "iso88591",

    "cyrillic": "iso88595",

    "arabic": "iso88596",
    "arabic8": "iso88596",
    "ecma114": "iso88596",
    "asmo708": "iso88596",

    "greek" : "iso88597",
    "greek8" : "iso88597",
    "ecma118" : "iso88597",
    "elot928" : "iso88597",

    "hebrew": "iso88598",
    "hebrew8": "iso88598",

    "turkish": "iso88599",
    "turkish8": "iso88599",

    "thai": "iso885911",
    "thai8": "iso885911",

    "celtic": "iso885914",
    "celtic8": "iso885914",
    "isoceltic": "iso885914",

    "tis6200": "tis620",
    "tis62025291": "tis620",
    "tis62025330": "tis620",

    "10000": "macroman",
    "10006": "macgreek",
    "10007": "maccyrillic",
    "10079": "maciceland",
    "10081": "macturkish",

    "cspc8codepage437": "cp437",
    "cspc775baltic": "cp775",
    "cspc850multilingual": "cp850",
    "cspcp852": "cp852",
    "cspc862latinhebrew": "cp862",
    "cpgr": "cp869",

    "msee": "cp1250",
    "mscyrl": "cp1251",
    "msansi": "cp1252",
    "msgreek": "cp1253",
    "msturk": "cp1254",
    "mshebr": "cp1255",
    "msarab": "cp1256",
    "winbaltrim": "cp1257",

    "cp20866": "koi8r",
    "20866": "koi8r",
    "ibm878": "koi8r",
    "cskoi8r": "koi8r",

    "cp21866": "koi8u",
    "21866": "koi8u",
    "ibm1168": "koi8u",

    "strk10482002": "rk1048",

    "tcvn5712": "tcvn",
    "tcvn57121": "tcvn",

    "gb198880": "iso646cn",
    "cn": "iso646cn",

    "csiso14jisc6220ro": "iso646jp",
    "jisc62201969ro": "iso646jp",
    "jp": "iso646jp",

    "cshproman8": "hproman8",
    "r8": "hproman8",
    "roman8": "hproman8",
    "xroman8": "hproman8",
    "ibm1051": "hproman8",

    "mac": "macintosh",
    "csmacintosh": "macintosh",
};



/***/ }),

/***/ 26682:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

var Buffer = (__nccwpck_require__(12803).Buffer);

// Note: UTF16-LE (or UCS2) codec is Node.js native. See encodings/internal.js

// == UTF16-BE codec. ==========================================================

exports.utf16be = Utf16BECodec;
function Utf16BECodec() {
}

Utf16BECodec.prototype.encoder = Utf16BEEncoder;
Utf16BECodec.prototype.decoder = Utf16BEDecoder;
Utf16BECodec.prototype.bomAware = true;


// -- Encoding

function Utf16BEEncoder() {
}

Utf16BEEncoder.prototype.write = function(str) {
    var buf = Buffer.from(str, 'ucs2');
    for (var i = 0; i < buf.length; i += 2) {
        var tmp = buf[i]; buf[i] = buf[i+1]; buf[i+1] = tmp;
    }
    return buf;
}

Utf16BEEncoder.prototype.end = function() {
}


// -- Decoding

function Utf16BEDecoder() {
    this.overflowByte = -1;
}

Utf16BEDecoder.prototype.write = function(buf) {
    if (buf.length == 0)
        return '';

    var buf2 = Buffer.alloc(buf.length + 1),
        i = 0, j = 0;

    if (this.overflowByte !== -1) {
        buf2[0] = buf[0];
        buf2[1] = this.overflowByte;
        i = 1; j = 2;
    }

    for (; i < buf.length-1; i += 2, j+= 2) {
        buf2[j] = buf[i+1];
        buf2[j+1] = buf[i];
    }

    this.overflowByte = (i == buf.length-1) ? buf[buf.length-1] : -1;

    return buf2.slice(0, j).toString('ucs2');
}

Utf16BEDecoder.prototype.end = function() {
}


// == UTF-16 codec =============================================================
// Decoder chooses automatically from UTF-16LE and UTF-16BE using BOM and space-based heuristic.
// Defaults to UTF-16LE, as it's prevalent and default in Node.
// http://en.wikipedia.org/wiki/UTF-16 and http://encoding.spec.whatwg.org/#utf-16le
// Decoder default can be changed: iconv.decode(buf, 'utf16', {defaultEncoding: 'utf-16be'});

// Encoder uses UTF-16LE and prepends BOM (which can be overridden with addBOM: false).

exports.utf16 = Utf16Codec;
function Utf16Codec(codecOptions, iconv) {
    this.iconv = iconv;
}

Utf16Codec.prototype.encoder = Utf16Encoder;
Utf16Codec.prototype.decoder = Utf16Decoder;


// -- Encoding (pass-through)

function Utf16Encoder(options, codec) {
    options = options || {};
    if (options.addBOM === undefined)
        options.addBOM = true;
    this.encoder = codec.iconv.getEncoder('utf-16le', options);
}

Utf16Encoder.prototype.write = function(str) {
    return this.encoder.write(str);
}

Utf16Encoder.prototype.end = function() {
    return this.encoder.end();
}


// -- Decoding

function Utf16Decoder(options, codec) {
    this.decoder = null;
    this.initialBytes = [];
    this.initialBytesLen = 0;

    this.options = options || {};
    this.iconv = codec.iconv;
}

Utf16Decoder.prototype.write = function(buf) {
    if (!this.decoder) {
        // Codec is not chosen yet. Accumulate initial bytes.
        this.initialBytes.push(buf);
        this.initialBytesLen += buf.length;
        
        if (this.initialBytesLen < 16) // We need more bytes to use space heuristic (see below)
            return '';

        // We have enough bytes -> detect endianness.
        var buf = Buffer.concat(this.initialBytes),
            encoding = detectEncoding(buf, this.options.defaultEncoding);
        this.decoder = this.iconv.getDecoder(encoding, this.options);
        this.initialBytes.length = this.initialBytesLen = 0;
    }

    return this.decoder.write(buf);
}

Utf16Decoder.prototype.end = function() {
    if (!this.decoder) {
        var buf = Buffer.concat(this.initialBytes),
            encoding = detectEncoding(buf, this.options.defaultEncoding);
        this.decoder = this.iconv.getDecoder(encoding, this.options);

        var res = this.decoder.write(buf),
            trail = this.decoder.end();

        return trail ? (res + trail) : res;
    }
    return this.decoder.end();
}

function detectEncoding(buf, defaultEncoding) {
    var enc = defaultEncoding || 'utf-16le';

    if (buf.length >= 2) {
        // Check BOM.
        if (buf[0] == 0xFE && buf[1] == 0xFF) // UTF-16BE BOM
            enc = 'utf-16be';
        else if (buf[0] == 0xFF && buf[1] == 0xFE) // UTF-16LE BOM
            enc = 'utf-16le';
        else {
            // No BOM found. Try to deduce encoding from initial content.
            // Most of the time, the content has ASCII chars (U+00**), but the opposite (U+**00) is uncommon.
            // So, we count ASCII as if it was LE or BE, and decide from that.
            var asciiCharsLE = 0, asciiCharsBE = 0, // Counts of chars in both positions
                _len = Math.min(buf.length - (buf.length % 2), 64); // Len is always even.

            for (var i = 0; i < _len; i += 2) {
                if (buf[i] === 0 && buf[i+1] !== 0) asciiCharsBE++;
                if (buf[i] !== 0 && buf[i+1] === 0) asciiCharsLE++;
            }

            if (asciiCharsBE > asciiCharsLE)
                enc = 'utf-16be';
            else if (asciiCharsBE < asciiCharsLE)
                enc = 'utf-16le';
        }
    }

    return enc;
}




/***/ }),

/***/ 37368:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

var Buffer = (__nccwpck_require__(12803).Buffer);

// UTF-7 codec, according to https://tools.ietf.org/html/rfc2152
// See also below a UTF-7-IMAP codec, according to http://tools.ietf.org/html/rfc3501#section-5.1.3

exports.utf7 = Utf7Codec;
exports.unicode11utf7 = 'utf7'; // Alias UNICODE-1-1-UTF-7
function Utf7Codec(codecOptions, iconv) {
    this.iconv = iconv;
};

Utf7Codec.prototype.encoder = Utf7Encoder;
Utf7Codec.prototype.decoder = Utf7Decoder;
Utf7Codec.prototype.bomAware = true;


// -- Encoding

var nonDirectChars = /[^A-Za-z0-9'\(\),-\.\/:\? \n\r\t]+/g;

function Utf7Encoder(options, codec) {
    this.iconv = codec.iconv;
}

Utf7Encoder.prototype.write = function(str) {
    // Naive implementation.
    // Non-direct chars are encoded as "+<base64>-"; single "+" char is encoded as "+-".
    return Buffer.from(str.replace(nonDirectChars, function(chunk) {
        return "+" + (chunk === '+' ? '' : 
            this.iconv.encode(chunk, 'utf16-be').toString('base64').replace(/=+$/, '')) 
            + "-";
    }.bind(this)));
}

Utf7Encoder.prototype.end = function() {
}


// -- Decoding

function Utf7Decoder(options, codec) {
    this.iconv = codec.iconv;
    this.inBase64 = false;
    this.base64Accum = '';
}

var base64Regex = /[A-Za-z0-9\/+]/;
var base64Chars = [];
for (var i = 0; i < 256; i++)
    base64Chars[i] = base64Regex.test(String.fromCharCode(i));

var plusChar = '+'.charCodeAt(0), 
    minusChar = '-'.charCodeAt(0),
    andChar = '&'.charCodeAt(0);

Utf7Decoder.prototype.write = function(buf) {
    var res = "", lastI = 0,
        inBase64 = this.inBase64,
        base64Accum = this.base64Accum;

    // The decoder is more involved as we must handle chunks in stream.

    for (var i = 0; i < buf.length; i++) {
        if (!inBase64) { // We're in direct mode.
            // Write direct chars until '+'
            if (buf[i] == plusChar) {
                res += this.iconv.decode(buf.slice(lastI, i), "ascii"); // Write direct chars.
                lastI = i+1;
                inBase64 = true;
            }
        } else { // We decode base64.
            if (!base64Chars[buf[i]]) { // Base64 ended.
                if (i == lastI && buf[i] == minusChar) {// "+-" -> "+"
                    res += "+";
                } else {
                    var b64str = base64Accum + buf.slice(lastI, i).toString();
                    res += this.iconv.decode(Buffer.from(b64str, 'base64'), "utf16-be");
                }

                if (buf[i] != minusChar) // Minus is absorbed after base64.
                    i--;

                lastI = i+1;
                inBase64 = false;
                base64Accum = '';
            }
        }
    }

    if (!inBase64) {
        res += this.iconv.decode(buf.slice(lastI), "ascii"); // Write direct chars.
    } else {
        var b64str = base64Accum + buf.slice(lastI).toString();

        var canBeDecoded = b64str.length - (b64str.length % 8); // Minimal chunk: 2 quads -> 2x3 bytes -> 3 chars.
        base64Accum = b64str.slice(canBeDecoded); // The rest will be decoded in future.
        b64str = b64str.slice(0, canBeDecoded);

        res += this.iconv.decode(Buffer.from(b64str, 'base64'), "utf16-be");
    }

    this.inBase64 = inBase64;
    this.base64Accum = base64Accum;

    return res;
}

Utf7Decoder.prototype.end = function() {
    var res = "";
    if (this.inBase64 && this.base64Accum.length > 0)
        res = this.iconv.decode(Buffer.from(this.base64Accum, 'base64'), "utf16-be");

    this.inBase64 = false;
    this.base64Accum = '';
    return res;
}


// UTF-7-IMAP codec.
// RFC3501 Sec. 5.1.3 Modified UTF-7 (http://tools.ietf.org/html/rfc3501#section-5.1.3)
// Differences:
//  * Base64 part is started by "&" instead of "+"
//  * Direct characters are 0x20-0x7E, except "&" (0x26)
//  * In Base64, "," is used instead of "/"
//  * Base64 must not be used to represent direct characters.
//  * No implicit shift back from Base64 (should always end with '-')
//  * String must end in non-shifted position.
//  * "-&" while in base64 is not allowed.


exports.utf7imap = Utf7IMAPCodec;
function Utf7IMAPCodec(codecOptions, iconv) {
    this.iconv = iconv;
};

Utf7IMAPCodec.prototype.encoder = Utf7IMAPEncoder;
Utf7IMAPCodec.prototype.decoder = Utf7IMAPDecoder;
Utf7IMAPCodec.prototype.bomAware = true;


// -- Encoding

function Utf7IMAPEncoder(options, codec) {
    this.iconv = codec.iconv;
    this.inBase64 = false;
    this.base64Accum = Buffer.alloc(6);
    this.base64AccumIdx = 0;
}

Utf7IMAPEncoder.prototype.write = function(str) {
    var inBase64 = this.inBase64,
        base64Accum = this.base64Accum,
        base64AccumIdx = this.base64AccumIdx,
        buf = Buffer.alloc(str.length*5 + 10), bufIdx = 0;

    for (var i = 0; i < str.length; i++) {
        var uChar = str.charCodeAt(i);
        if (0x20 <= uChar && uChar <= 0x7E) { // Direct character or '&'.
            if (inBase64) {
                if (base64AccumIdx > 0) {
                    bufIdx += buf.write(base64Accum.slice(0, base64AccumIdx).toString('base64').replace(/\//g, ',').replace(/=+$/, ''), bufIdx);
                    base64AccumIdx = 0;
                }

                buf[bufIdx++] = minusChar; // Write '-', then go to direct mode.
                inBase64 = false;
            }

            if (!inBase64) {
                buf[bufIdx++] = uChar; // Write direct character

                if (uChar === andChar)  // Ampersand -> '&-'
                    buf[bufIdx++] = minusChar;
            }

        } else { // Non-direct character
            if (!inBase64) {
                buf[bufIdx++] = andChar; // Write '&', then go to base64 mode.
                inBase64 = true;
            }
            if (inBase64) {
                base64Accum[base64AccumIdx++] = uChar >> 8;
                base64Accum[base64AccumIdx++] = uChar & 0xFF;

                if (base64AccumIdx == base64Accum.length) {
                    bufIdx += buf.write(base64Accum.toString('base64').replace(/\//g, ','), bufIdx);
                    base64AccumIdx = 0;
                }
            }
        }
    }

    this.inBase64 = inBase64;
    this.base64AccumIdx = base64AccumIdx;

    return buf.slice(0, bufIdx);
}

Utf7IMAPEncoder.prototype.end = function() {
    var buf = Buffer.alloc(10), bufIdx = 0;
    if (this.inBase64) {
        if (this.base64AccumIdx > 0) {
            bufIdx += buf.write(this.base64Accum.slice(0, this.base64AccumIdx).toString('base64').replace(/\//g, ',').replace(/=+$/, ''), bufIdx);
            this.base64AccumIdx = 0;
        }

        buf[bufIdx++] = minusChar; // Write '-', then go to direct mode.
        this.inBase64 = false;
    }

    return buf.slice(0, bufIdx);
}


// -- Decoding

function Utf7IMAPDecoder(options, codec) {
    this.iconv = codec.iconv;
    this.inBase64 = false;
    this.base64Accum = '';
}

var base64IMAPChars = base64Chars.slice();
base64IMAPChars[','.charCodeAt(0)] = true;

Utf7IMAPDecoder.prototype.write = function(buf) {
    var res = "", lastI = 0,
        inBase64 = this.inBase64,
        base64Accum = this.base64Accum;

    // The decoder is more involved as we must handle chunks in stream.
    // It is forgiving, closer to standard UTF-7 (for example, '-' is optional at the end).

    for (var i = 0; i < buf.length; i++) {
        if (!inBase64) { // We're in direct mode.
            // Write direct chars until '&'
            if (buf[i] == andChar) {
                res += this.iconv.decode(buf.slice(lastI, i), "ascii"); // Write direct chars.
                lastI = i+1;
                inBase64 = true;
            }
        } else { // We decode base64.
            if (!base64IMAPChars[buf[i]]) { // Base64 ended.
                if (i == lastI && buf[i] == minusChar) { // "&-" -> "&"
                    res += "&";
                } else {
                    var b64str = base64Accum + buf.slice(lastI, i).toString().replace(/,/g, '/');
                    res += this.iconv.decode(Buffer.from(b64str, 'base64'), "utf16-be");
                }

                if (buf[i] != minusChar) // Minus may be absorbed after base64.
                    i--;

                lastI = i+1;
                inBase64 = false;
                base64Accum = '';
            }
        }
    }

    if (!inBase64) {
        res += this.iconv.decode(buf.slice(lastI), "ascii"); // Write direct chars.
    } else {
        var b64str = base64Accum + buf.slice(lastI).toString().replace(/,/g, '/');

        var canBeDecoded = b64str.length - (b64str.length % 8); // Minimal chunk: 2 quads -> 2x3 bytes -> 3 chars.
        base64Accum = b64str.slice(canBeDecoded); // The rest will be decoded in future.
        b64str = b64str.slice(0, canBeDecoded);

        res += this.iconv.decode(Buffer.from(b64str, 'base64'), "utf16-be");
    }

    this.inBase64 = inBase64;
    this.base64Accum = base64Accum;

    return res;
}

Utf7IMAPDecoder.prototype.end = function() {
    var res = "";
    if (this.inBase64 && this.base64Accum.length > 0)
        res = this.iconv.decode(Buffer.from(this.base64Accum, 'base64'), "utf16-be");

    this.inBase64 = false;
    this.base64Accum = '';
    return res;
}




/***/ }),

/***/ 60733:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


var BOMChar = '\uFEFF';

exports.PrependBOM = PrependBOMWrapper
function PrependBOMWrapper(encoder, options) {
    this.encoder = encoder;
    this.addBOM = true;
}

PrependBOMWrapper.prototype.write = function(str) {
    if (this.addBOM) {
        str = BOMChar + str;
        this.addBOM = false;
    }

    return this.encoder.write(str);
}

PrependBOMWrapper.prototype.end = function() {
    return this.encoder.end();
}


//------------------------------------------------------------------------------

exports.StripBOM = StripBOMWrapper;
function StripBOMWrapper(decoder, options) {
    this.decoder = decoder;
    this.pass = false;
    this.options = options || {};
}

StripBOMWrapper.prototype.write = function(buf) {
    var res = this.decoder.write(buf);
    if (this.pass || !res)
        return res;

    if (res[0] === BOMChar) {
        res = res.slice(1);
        if (typeof this.options.stripBOM === 'function')
            this.options.stripBOM();
    }

    this.pass = true;
    return res;
}

StripBOMWrapper.prototype.end = function() {
    return this.decoder.end();
}



/***/ }),

/***/ 50018:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";

var Buffer = (__nccwpck_require__(20181).Buffer);
// Note: not polyfilled with safer-buffer on a purpose, as overrides Buffer

// == Extend Node primitives to use iconv-lite =================================

module.exports = function (iconv) {
    var original = undefined; // Place to keep original methods.

    // Node authors rewrote Buffer internals to make it compatible with
    // Uint8Array and we cannot patch key functions since then.
    // Note: this does use older Buffer API on a purpose
    iconv.supportsNodeEncodingsExtension = !(Buffer.from || new Buffer(0) instanceof Uint8Array);

    iconv.extendNodeEncodings = function extendNodeEncodings() {
        if (original) return;
        original = {};

        if (!iconv.supportsNodeEncodingsExtension) {
            console.error("ACTION NEEDED: require('iconv-lite').extendNodeEncodings() is not supported in your version of Node");
            console.error("See more info at https://github.com/ashtuchkin/iconv-lite/wiki/Node-v4-compatibility");
            return;
        }

        var nodeNativeEncodings = {
            'hex': true, 'utf8': true, 'utf-8': true, 'ascii': true, 'binary': true, 
            'base64': true, 'ucs2': true, 'ucs-2': true, 'utf16le': true, 'utf-16le': true,
        };

        Buffer.isNativeEncoding = function(enc) {
            return enc && nodeNativeEncodings[enc.toLowerCase()];
        }

        // -- SlowBuffer -----------------------------------------------------------
        var SlowBuffer = (__nccwpck_require__(20181).SlowBuffer);

        original.SlowBufferToString = SlowBuffer.prototype.toString;
        SlowBuffer.prototype.toString = function(encoding, start, end) {
            encoding = String(encoding || 'utf8').toLowerCase();

            // Use native conversion when possible
            if (Buffer.isNativeEncoding(encoding))
                return original.SlowBufferToString.call(this, encoding, start, end);

            // Otherwise, use our decoding method.
            if (typeof start == 'undefined') start = 0;
            if (typeof end == 'undefined') end = this.length;
            return iconv.decode(this.slice(start, end), encoding);
        }

        original.SlowBufferWrite = SlowBuffer.prototype.write;
        SlowBuffer.prototype.write = function(string, offset, length, encoding) {
            // Support both (string, offset, length, encoding)
            // and the legacy (string, encoding, offset, length)
            if (isFinite(offset)) {
                if (!isFinite(length)) {
                    encoding = length;
                    length = undefined;
                }
            } else {  // legacy
                var swap = encoding;
                encoding = offset;
                offset = length;
                length = swap;
            }

            offset = +offset || 0;
            var remaining = this.length - offset;
            if (!length) {
                length = remaining;
            } else {
                length = +length;
                if (length > remaining) {
                    length = remaining;
                }
            }
            encoding = String(encoding || 'utf8').toLowerCase();

            // Use native conversion when possible
            if (Buffer.isNativeEncoding(encoding))
                return original.SlowBufferWrite.call(this, string, offset, length, encoding);

            if (string.length > 0 && (length < 0 || offset < 0))
                throw new RangeError('attempt to write beyond buffer bounds');

            // Otherwise, use our encoding method.
            var buf = iconv.encode(string, encoding);
            if (buf.length < length) length = buf.length;
            buf.copy(this, offset, 0, length);
            return length;
        }

        // -- Buffer ---------------------------------------------------------------

        original.BufferIsEncoding = Buffer.isEncoding;
        Buffer.isEncoding = function(encoding) {
            return Buffer.isNativeEncoding(encoding) || iconv.encodingExists(encoding);
        }

        original.BufferByteLength = Buffer.byteLength;
        Buffer.byteLength = SlowBuffer.byteLength = function(str, encoding) {
            encoding = String(encoding || 'utf8').toLowerCase();

            // Use native conversion when possible
            if (Buffer.isNativeEncoding(encoding))
                return original.BufferByteLength.call(this, str, encoding);

            // Slow, I know, but we don't have a better way yet.
            return iconv.encode(str, encoding).length;
        }

        original.BufferToString = Buffer.prototype.toString;
        Buffer.prototype.toString = function(encoding, start, end) {
            encoding = String(encoding || 'utf8').toLowerCase();

            // Use native conversion when possible
            if (Buffer.isNativeEncoding(encoding))
                return original.BufferToString.call(this, encoding, start, end);

            // Otherwise, use our decoding method.
            if (typeof start == 'undefined') start = 0;
            if (typeof end == 'undefined') end = this.length;
            return iconv.decode(this.slice(start, end), encoding);
        }

        original.BufferWrite = Buffer.prototype.write;
        Buffer.prototype.write = function(string, offset, length, encoding) {
            var _offset = offset, _length = length, _encoding = encoding;
            // Support both (string, offset, length, encoding)
            // and the legacy (string, encoding, offset, length)
            if (isFinite(offset)) {
                if (!isFinite(length)) {
                    encoding = length;
                    length = undefined;
                }
            } else {  // legacy
                var swap = encoding;
                encoding = offset;
                offset = length;
                length = swap;
            }

            encoding = String(encoding || 'utf8').toLowerCase();

            // Use native conversion when possible
            if (Buffer.isNativeEncoding(encoding))
                return original.BufferWrite.call(this, string, _offset, _length, _encoding);

            offset = +offset || 0;
            var remaining = this.length - offset;
            if (!length) {
                length = remaining;
            } else {
                length = +length;
                if (length > remaining) {
                    length = remaining;
                }
            }

            if (string.length > 0 && (length < 0 || offset < 0))
                throw new RangeError('attempt to write beyond buffer bounds');

            // Otherwise, use our encoding method.
            var buf = iconv.encode(string, encoding);
            if (buf.length < length) length = buf.length;
            buf.copy(this, offset, 0, length);
            return length;

            // TODO: Set _charsWritten.
        }


        // -- Readable -------------------------------------------------------------
        if (iconv.supportsStreams) {
            var Readable = (__nccwpck_require__(2203).Readable);

            original.ReadableSetEncoding = Readable.prototype.setEncoding;
            Readable.prototype.setEncoding = function setEncoding(enc, options) {
                // Use our own decoder, it has the same interface.
                // We cannot use original function as it doesn't handle BOM-s.
                this._readableState.decoder = iconv.getDecoder(enc, options);
                this._readableState.encoding = enc;
            }

            Readable.prototype.collect = iconv._collect;
        }
    }

    // Remove iconv-lite Node primitive extensions.
    iconv.undoExtendNodeEncodings = function undoExtendNodeEncodings() {
        if (!iconv.supportsNodeEncodingsExtension)
            return;
        if (!original)
            throw new Error("require('iconv-lite').undoExtendNodeEncodings(): Nothing to undo; extendNodeEncodings() is not called.")

        delete Buffer.isNativeEncoding;

        var SlowBuffer = (__nccwpck_require__(20181).SlowBuffer);

        SlowBuffer.prototype.toString = original.SlowBufferToString;
        SlowBuffer.prototype.write = original.SlowBufferWrite;

        Buffer.isEncoding = original.BufferIsEncoding;
        Buffer.byteLength = original.BufferByteLength;
        Buffer.prototype.toString = original.BufferToString;
        Buffer.prototype.write = original.BufferWrite;

        if (iconv.supportsStreams) {
            var Readable = (__nccwpck_require__(2203).Readable);

            Readable.prototype.setEncoding = original.ReadableSetEncoding;
            delete Readable.prototype.collect;
        }

        original = undefined;
    }
}


/***/ }),

/***/ 79073:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


// Some environments don't have global Buffer (e.g. React Native).
// Solution would be installing npm modules "buffer" and "stream" explicitly.
var Buffer = (__nccwpck_require__(12803).Buffer);

var bomHandling = __nccwpck_require__(60733),
    iconv = module.exports;

// All codecs and aliases are kept here, keyed by encoding name/alias.
// They are lazy loaded in `iconv.getCodec` from `encodings/index.js`.
iconv.encodings = null;

// Characters emitted in case of error.
iconv.defaultCharUnicode = 'ÔøΩ';
iconv.defaultCharSingleByte = '?';

// Public API.
iconv.encode = function encode(str, encoding, options) {
    str = "" + (str || ""); // Ensure string.

    var encoder = iconv.getEncoder(encoding, options);

    var res = encoder.write(str);
    var trail = encoder.end();
    
    return (trail && trail.length > 0) ? Buffer.concat([res, trail]) : res;
}

iconv.decode = function decode(buf, encoding, options) {
    if (typeof buf === 'string') {
        if (!iconv.skipDecodeWarning) {
            console.error('Iconv-lite warning: decode()-ing strings is deprecated. Refer to https://github.com/ashtuchkin/iconv-lite/wiki/Use-Buffers-when-decoding');
            iconv.skipDecodeWarning = true;
        }

        buf = Buffer.from("" + (buf || ""), "binary"); // Ensure buffer.
    }

    var decoder = iconv.getDecoder(encoding, options);

    var res = decoder.write(buf);
    var trail = decoder.end();

    return trail ? (res + trail) : res;
}

iconv.encodingExists = function encodingExists(enc) {
    try {
        iconv.getCodec(enc);
        return true;
    } catch (e) {
        return false;
    }
}

// Legacy aliases to convert functions
iconv.toEncoding = iconv.encode;
iconv.fromEncoding = iconv.decode;

// Search for a codec in iconv.encodings. Cache codec data in iconv._codecDataCache.
iconv._codecDataCache = {};
iconv.getCodec = function getCodec(encoding) {
    if (!iconv.encodings)
        iconv.encodings = __nccwpck_require__(78456); // Lazy load all encoding definitions.
    
    // Canonicalize encoding name: strip all non-alphanumeric chars and appended year.
    var enc = iconv._canonicalizeEncoding(encoding);

    // Traverse iconv.encodings to find actual codec.
    var codecOptions = {};
    while (true) {
        var codec = iconv._codecDataCache[enc];
        if (codec)
            return codec;

        var codecDef = iconv.encodings[enc];

        switch (typeof codecDef) {
            case "string": // Direct alias to other encoding.
                enc = codecDef;
                break;

            case "object": // Alias with options. Can be layered.
                for (var key in codecDef)
                    codecOptions[key] = codecDef[key];

                if (!codecOptions.encodingName)
                    codecOptions.encodingName = enc;
                
                enc = codecDef.type;
                break;

            case "function": // Codec itself.
                if (!codecOptions.encodingName)
                    codecOptions.encodingName = enc;

                // The codec function must load all tables and return object with .encoder and .decoder methods.
                // It'll be called only once (for each different options object).
                codec = new codecDef(codecOptions, iconv);

                iconv._codecDataCache[codecOptions.encodingName] = codec; // Save it to be reused later.
                return codec;

            default:
                throw new Error("Encoding not recognized: '" + encoding + "' (searched as: '"+enc+"')");
        }
    }
}

iconv._canonicalizeEncoding = function(encoding) {
    // Canonicalize encoding name: strip all non-alphanumeric chars and appended year.
    return (''+encoding).toLowerCase().replace(/:\d{4}$|[^0-9a-z]/g, "");
}

iconv.getEncoder = function getEncoder(encoding, options) {
    var codec = iconv.getCodec(encoding),
        encoder = new codec.encoder(options, codec);

    if (codec.bomAware && options && options.addBOM)
        encoder = new bomHandling.PrependBOM(encoder, options);

    return encoder;
}

iconv.getDecoder = function getDecoder(encoding, options) {
    var codec = iconv.getCodec(encoding),
        decoder = new codec.decoder(options, codec);

    if (codec.bomAware && !(options && options.stripBOM === false))
        decoder = new bomHandling.StripBOM(decoder, options);

    return decoder;
}


// Load extensions in Node. All of them are omitted in Browserify build via 'browser' field in package.json.
var nodeVer = typeof process !== 'undefined' && process.versions && process.versions.node;
if (nodeVer) {

    // Load streaming support in Node v0.10+
    var nodeVerArr = nodeVer.split(".").map(Number);
    if (nodeVerArr[0] > 0 || nodeVerArr[1] >= 10) {
        __nccwpck_require__(48176)(iconv);
    }

    // Load Node primitive extensions.
    __nccwpck_require__(50018)(iconv);
}

if (false) {}


/***/ }),

/***/ 48176:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


var Buffer = (__nccwpck_require__(20181).Buffer),
    Transform = (__nccwpck_require__(2203).Transform);


// == Exports ==================================================================
module.exports = function(iconv) {
    
    // Additional Public API.
    iconv.encodeStream = function encodeStream(encoding, options) {
        return new IconvLiteEncoderStream(iconv.getEncoder(encoding, options), options);
    }

    iconv.decodeStream = function decodeStream(encoding, options) {
        return new IconvLiteDecoderStream(iconv.getDecoder(encoding, options), options);
    }

    iconv.supportsStreams = true;


    // Not published yet.
    iconv.IconvLiteEncoderStream = IconvLiteEncoderStream;
    iconv.IconvLiteDecoderStream = IconvLiteDecoderStream;
    iconv._collect = IconvLiteDecoderStream.prototype.collect;
};


// == Encoder stream =======================================================
function IconvLiteEncoderStream(conv, options) {
    this.conv = conv;
    options = options || {};
    options.decodeStrings = false; // We accept only strings, so we don't need to decode them.
    Transform.call(this, options);
}

IconvLiteEncoderStream.prototype = Object.create(Transform.prototype, {
    constructor: { value: IconvLiteEncoderStream }
});

IconvLiteEncoderStream.prototype._transform = function(chunk, encoding, done) {
    if (typeof chunk != 'string')
        return done(new Error("Iconv encoding stream needs strings as its input."));
    try {
        var res = this.conv.write(chunk);
        if (res && res.length) this.push(res);
        done();
    }
    catch (e) {
        done(e);
    }
}

IconvLiteEncoderStream.prototype._flush = function(done) {
    try {
        var res = this.conv.end();
        if (res && res.length) this.push(res);
        done();
    }
    catch (e) {
        done(e);
    }
}

IconvLiteEncoderStream.prototype.collect = function(cb) {
    var chunks = [];
    this.on('error', cb);
    this.on('data', function(chunk) { chunks.push(chunk); });
    this.on('end', function() {
        cb(null, Buffer.concat(chunks));
    });
    return this;
}


// == Decoder stream =======================================================
function IconvLiteDecoderStream(conv, options) {
    this.conv = conv;
    options = options || {};
    options.encoding = this.encoding = 'utf8'; // We output strings.
    Transform.call(this, options);
}

IconvLiteDecoderStream.prototype = Object.create(Transform.prototype, {
    constructor: { value: IconvLiteDecoderStream }
});

IconvLiteDecoderStream.prototype._transform = function(chunk, encoding, done) {
    if (!Buffer.isBuffer(chunk))
        return done(new Error("Iconv decoding stream needs buffers as its input."));
    try {
        var res = this.conv.write(chunk);
        if (res && res.length) this.push(res, this.encoding);
        done();
    }
    catch (e) {
        done(e);
    }
}

IconvLiteDecoderStream.prototype._flush = function(done) {
    try {
        var res = this.conv.end();
        if (res && res.length) this.push(res, this.encoding);                
        done();
    }
    catch (e) {
        done(e);
    }
}

IconvLiteDecoderStream.prototype.collect = function(cb) {
    var res = '';
    this.on('error', cb);
    this.on('data', function(chunk) { res += chunk; });
    this.on('end', function() {
        cb(null, res);
    });
    return this;
}



/***/ }),

/***/ 25500:
/***/ ((module) => {

"use strict";


const codes = {};

function createErrorType(code, message, Base) {
  if (!Base) {
    Base = Error
  }

  function getMessage (arg1, arg2, arg3) {
    if (typeof message === 'string') {
      return message
    } else {
      return message(arg1, arg2, arg3)
    }
  }

  class NodeError extends Base {
    constructor (arg1, arg2, arg3) {
      super(getMessage(arg1, arg2, arg3));
    }
  }

  NodeError.prototype.name = Base.name;
  NodeError.prototype.code = code;

  codes[code] = NodeError;
}

// https://github.com/nodejs/node/blob/v10.8.0/lib/internal/errors.js
function oneOf(expected, thing) {
  if (Array.isArray(expected)) {
    const len = expected.length;
    expected = expected.map((i) => String(i));
    if (len > 2) {
      return `one of ${thing} ${expected.slice(0, len - 1).join(', ')}, or ` +
             expected[len - 1];
    } else if (len === 2) {
      return `one of ${thing} ${expected[0]} or ${expected[1]}`;
    } else {
      return `of ${thing} ${expected[0]}`;
    }
  } else {
    return `of ${thing} ${String(expected)}`;
  }
}

// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith
function startsWith(str, search, pos) {
	return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
}

// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith
function endsWith(str, search, this_len) {
	if (this_len === undefined || this_len > str.length) {
		this_len = str.length;
	}
	return str.substring(this_len - search.length, this_len) === search;
}

// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/includes
function includes(str, search, start) {
  if (typeof start !== 'number') {
    start = 0;
  }

  if (start + search.length > str.length) {
    return false;
  } else {
    return str.indexOf(search, start) !== -1;
  }
}

createErrorType('ERR_INVALID_OPT_VALUE', function (name, value) {
  return 'The value "' + value + '" is invalid for option "' + name + '"'
}, TypeError);
createErrorType('ERR_INVALID_ARG_TYPE', function (name, expected, actual) {
  // determiner: 'must be' or 'must not be'
  let determiner;
  if (typeof expected === 'string' && startsWith(expected, 'not ')) {
    determiner = 'must not be';
    expected = expected.replace(/^not /, '');
  } else {
    determiner = 'must be';
  }

  let msg;
  if (endsWith(name, ' argument')) {
    // For cases like 'first argument'
    msg = `The ${name} ${determiner} ${oneOf(expected, 'type')}`;
  } else {
    const type = includes(name, '.') ? 'property' : 'argument';
    msg = `The "${name}" ${type} ${determiner} ${oneOf(expected, 'type')}`;
  }

  msg += `. Received type ${typeof actual}`;
  return msg;
}, TypeError);
createErrorType('ERR_STREAM_PUSH_AFTER_EOF', 'stream.push() after EOF');
createErrorType('ERR_METHOD_NOT_IMPLEMENTED', function (name) {
  return 'The ' + name + ' method is not implemented'
});
createErrorType('ERR_STREAM_PREMATURE_CLOSE', 'Premature close');
createErrorType('ERR_STREAM_DESTROYED', function (name) {
  return 'Cannot call ' + name + ' after a stream was destroyed';
});
createErrorType('ERR_MULTIPLE_CALLBACK', 'Callback called multiple times');
createErrorType('ERR_STREAM_CANNOT_PIPE', 'Cannot pipe, not readable');
createErrorType('ERR_STREAM_WRITE_AFTER_END', 'write after end');
createErrorType('ERR_STREAM_NULL_VALUES', 'May not write null values to stream', TypeError);
createErrorType('ERR_UNKNOWN_ENCODING', function (arg) {
  return 'Unknown encoding: ' + arg
}, TypeError);
createErrorType('ERR_STREAM_UNSHIFT_AFTER_END_EVENT', 'stream.unshift() after end event');

module.exports.F = codes;


/***/ }),

/***/ 82063:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.



/*<replacement>*/
var objectKeys = Object.keys || function (obj) {
  var keys = [];
  for (var key in obj) keys.push(key);
  return keys;
};
/*</replacement>*/

module.exports = Duplex;
var Readable = __nccwpck_require__(86893);
var Writable = __nccwpck_require__(38797);
__nccwpck_require__(39598)(Duplex, Readable);
{
  // Allow the keys array to be GC'ed.
  var keys = objectKeys(Writable.prototype);
  for (var v = 0; v < keys.length; v++) {
    var method = keys[v];
    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
  }
}
function Duplex(options) {
  if (!(this instanceof Duplex)) return new Duplex(options);
  Readable.call(this, options);
  Writable.call(this, options);
  this.allowHalfOpen = true;
  if (options) {
    if (options.readable === false) this.readable = false;
    if (options.writable === false) this.writable = false;
    if (options.allowHalfOpen === false) {
      this.allowHalfOpen = false;
      this.once('end', onend);
    }
  }
}
Object.defineProperty(Duplex.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.highWaterMark;
  }
});
Object.defineProperty(Duplex.prototype, 'writableBuffer', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState && this._writableState.getBuffer();
  }
});
Object.defineProperty(Duplex.prototype, 'writableLength', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.length;
  }
});

// the no-half-open enforcer
function onend() {
  // If the writable side ended, then we're ok.
  if (this._writableState.ended) return;

  // no more data can be written.
  // But allow more writes to happen in this tick.
  process.nextTick(onEndNT, this);
}
function onEndNT(self) {
  self.end();
}
Object.defineProperty(Duplex.prototype, 'destroyed', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    if (this._readableState === undefined || this._writableState === undefined) {
      return false;
    }
    return this._readableState.destroyed && this._writableState.destroyed;
  },
  set: function set(value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (this._readableState === undefined || this._writableState === undefined) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._readableState.destroyed = value;
    this._writableState.destroyed = value;
  }
});

/***/ }),

/***/ 35283:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a passthrough stream.
// basically just the most minimal sort of Transform stream.
// Every written chunk gets output as-is.



module.exports = PassThrough;
var Transform = __nccwpck_require__(12337);
__nccwpck_require__(39598)(PassThrough, Transform);
function PassThrough(options) {
  if (!(this instanceof PassThrough)) return new PassThrough(options);
  Transform.call(this, options);
}
PassThrough.prototype._transform = function (chunk, encoding, cb) {
  cb(null, chunk);
};

/***/ }),

/***/ 86893:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



module.exports = Readable;

/*<replacement>*/
var Duplex;
/*</replacement>*/

Readable.ReadableState = ReadableState;

/*<replacement>*/
var EE = (__nccwpck_require__(24434).EventEmitter);
var EElistenerCount = function EElistenerCount(emitter, type) {
  return emitter.listeners(type).length;
};
/*</replacement>*/

/*<replacement>*/
var Stream = __nccwpck_require__(63283);
/*</replacement>*/

var Buffer = (__nccwpck_require__(20181).Buffer);
var OurUint8Array = (typeof global !== 'undefined' ? global : typeof window !== 'undefined' ? window : typeof self !== 'undefined' ? self : {}).Uint8Array || function () {};
function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}
function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}

/*<replacement>*/
var debugUtil = __nccwpck_require__(39023);
var debug;
if (debugUtil && debugUtil.debuglog) {
  debug = debugUtil.debuglog('stream');
} else {
  debug = function debug() {};
}
/*</replacement>*/

var BufferList = __nccwpck_require__(77336);
var destroyImpl = __nccwpck_require__(65089);
var _require = __nccwpck_require__(54874),
  getHighWaterMark = _require.getHighWaterMark;
var _require$codes = (__nccwpck_require__(25500)/* .codes */ .F),
  ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,
  ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF,
  ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
  ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;

// Lazy loaded to improve the startup performance.
var StringDecoder;
var createReadableStreamAsyncIterator;
var from;
__nccwpck_require__(39598)(Readable, Stream);
var errorOrDestroy = destroyImpl.errorOrDestroy;
var kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];
function prependListener(emitter, event, fn) {
  // Sadly this is not cacheable as some libraries bundle their own
  // event emitter implementation with them.
  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn);

  // This is a hack to make sure that our error handler is attached before any
  // userland ones.  NEVER DO THIS. This is here only because this code needs
  // to continue to work with older versions of Node.js that do not include
  // the prependListener() method. The goal is to eventually remove this hack.
  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (Array.isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];
}
function ReadableState(options, stream, isDuplex) {
  Duplex = Duplex || __nccwpck_require__(82063);
  options = options || {};

  // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream.
  // These options can be provided separately as readableXXX and writableXXX.
  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex;

  // object stream flag. Used to make read(n) ignore n and to
  // make all the buffer merging and length checks go away
  this.objectMode = !!options.objectMode;
  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;

  // the point at which it stops calling _read() to fill the buffer
  // Note: 0 is a valid value, means "don't call _read preemptively ever"
  this.highWaterMark = getHighWaterMark(this, options, 'readableHighWaterMark', isDuplex);

  // A linked list is used to store data chunks instead of an array because the
  // linked list can remove elements from the beginning faster than
  // array.shift()
  this.buffer = new BufferList();
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false;

  // a flag to be able to tell if the event 'readable'/'data' is emitted
  // immediately, or on a later tick.  We set this to true at first, because
  // any actions that shouldn't happen until "later" should generally also
  // not happen before the first read call.
  this.sync = true;

  // whenever we return null, then we set a flag to say
  // that we're awaiting a 'readable' event emission.
  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;
  this.resumeScheduled = false;
  this.paused = true;

  // Should close be emitted on destroy. Defaults to true.
  this.emitClose = options.emitClose !== false;

  // Should .destroy() be called after 'end' (and potentially 'finish')
  this.autoDestroy = !!options.autoDestroy;

  // has it been destroyed
  this.destroyed = false;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // the number of writers that are awaiting a drain event in .pipe()s
  this.awaitDrain = 0;

  // if true, a maybeReadMore has been scheduled
  this.readingMore = false;
  this.decoder = null;
  this.encoding = null;
  if (options.encoding) {
    if (!StringDecoder) StringDecoder = (__nccwpck_require__(80634)/* .StringDecoder */ .I);
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}
function Readable(options) {
  Duplex = Duplex || __nccwpck_require__(82063);
  if (!(this instanceof Readable)) return new Readable(options);

  // Checking for a Stream.Duplex instance is faster here instead of inside
  // the ReadableState constructor, at least with V8 6.5
  var isDuplex = this instanceof Duplex;
  this._readableState = new ReadableState(options, this, isDuplex);

  // legacy
  this.readable = true;
  if (options) {
    if (typeof options.read === 'function') this._read = options.read;
    if (typeof options.destroy === 'function') this._destroy = options.destroy;
  }
  Stream.call(this);
}
Object.defineProperty(Readable.prototype, 'destroyed', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    if (this._readableState === undefined) {
      return false;
    }
    return this._readableState.destroyed;
  },
  set: function set(value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._readableState) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._readableState.destroyed = value;
  }
});
Readable.prototype.destroy = destroyImpl.destroy;
Readable.prototype._undestroy = destroyImpl.undestroy;
Readable.prototype._destroy = function (err, cb) {
  cb(err);
};

// Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.
Readable.prototype.push = function (chunk, encoding) {
  var state = this._readableState;
  var skipChunkCheck;
  if (!state.objectMode) {
    if (typeof chunk === 'string') {
      encoding = encoding || state.defaultEncoding;
      if (encoding !== state.encoding) {
        chunk = Buffer.from(chunk, encoding);
        encoding = '';
      }
      skipChunkCheck = true;
    }
  } else {
    skipChunkCheck = true;
  }
  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
};

// Unshift should *always* be something directly out of read()
Readable.prototype.unshift = function (chunk) {
  return readableAddChunk(this, chunk, null, true, false);
};
function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
  debug('readableAddChunk', chunk);
  var state = stream._readableState;
  if (chunk === null) {
    state.reading = false;
    onEofChunk(stream, state);
  } else {
    var er;
    if (!skipChunkCheck) er = chunkInvalid(state, chunk);
    if (er) {
      errorOrDestroy(stream, er);
    } else if (state.objectMode || chunk && chunk.length > 0) {
      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {
        chunk = _uint8ArrayToBuffer(chunk);
      }
      if (addToFront) {
        if (state.endEmitted) errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());else addChunk(stream, state, chunk, true);
      } else if (state.ended) {
        errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
      } else if (state.destroyed) {
        return false;
      } else {
        state.reading = false;
        if (state.decoder && !encoding) {
          chunk = state.decoder.write(chunk);
          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);
        } else {
          addChunk(stream, state, chunk, false);
        }
      }
    } else if (!addToFront) {
      state.reading = false;
      maybeReadMore(stream, state);
    }
  }

  // We can push more data if we are below the highWaterMark.
  // Also, if we have no data yet, we can stand some more bytes.
  // This is to work around cases where hwm=0, such as the repl.
  return !state.ended && (state.length < state.highWaterMark || state.length === 0);
}
function addChunk(stream, state, chunk, addToFront) {
  if (state.flowing && state.length === 0 && !state.sync) {
    state.awaitDrain = 0;
    stream.emit('data', chunk);
  } else {
    // update the buffer info.
    state.length += state.objectMode ? 1 : chunk.length;
    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);
    if (state.needReadable) emitReadable(stream);
  }
  maybeReadMore(stream, state);
}
function chunkInvalid(state, chunk) {
  var er;
  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer', 'Uint8Array'], chunk);
  }
  return er;
}
Readable.prototype.isPaused = function () {
  return this._readableState.flowing === false;
};

// backwards compatibility.
Readable.prototype.setEncoding = function (enc) {
  if (!StringDecoder) StringDecoder = (__nccwpck_require__(80634)/* .StringDecoder */ .I);
  var decoder = new StringDecoder(enc);
  this._readableState.decoder = decoder;
  // If setEncoding(null), decoder.encoding equals utf8
  this._readableState.encoding = this._readableState.decoder.encoding;

  // Iterate over current buffer to convert already stored Buffers:
  var p = this._readableState.buffer.head;
  var content = '';
  while (p !== null) {
    content += decoder.write(p.data);
    p = p.next;
  }
  this._readableState.buffer.clear();
  if (content !== '') this._readableState.buffer.push(content);
  this._readableState.length = content.length;
  return this;
};

// Don't raise the hwm > 1GB
var MAX_HWM = 0x40000000;
function computeNewHighWaterMark(n) {
  if (n >= MAX_HWM) {
    // TODO(ronag): Throw ERR_VALUE_OUT_OF_RANGE.
    n = MAX_HWM;
  } else {
    // Get the next highest power of 2 to prevent increasing hwm excessively in
    // tiny amounts
    n--;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    n++;
  }
  return n;
}

// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function howMuchToRead(n, state) {
  if (n <= 0 || state.length === 0 && state.ended) return 0;
  if (state.objectMode) return 1;
  if (n !== n) {
    // Only flow one buffer at a time
    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;
  }
  // If we're asking for more than the current hwm, then raise the hwm.
  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
  if (n <= state.length) return n;
  // Don't have enough
  if (!state.ended) {
    state.needReadable = true;
    return 0;
  }
  return state.length;
}

// you can override either this method, or the async _read(n) below.
Readable.prototype.read = function (n) {
  debug('read', n);
  n = parseInt(n, 10);
  var state = this._readableState;
  var nOrig = n;
  if (n !== 0) state.emittedReadable = false;

  // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.
  if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
    debug('read: emitReadable', state.length, state.ended);
    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
    return null;
  }
  n = howMuchToRead(n, state);

  // if we've ended, and we're now clear, then finish it up.
  if (n === 0 && state.ended) {
    if (state.length === 0) endReadable(this);
    return null;
  }

  // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.

  // if we need a readable event, then we need to do some reading.
  var doRead = state.needReadable;
  debug('need readable', doRead);

  // if we currently have less than the highWaterMark, then also read some
  if (state.length === 0 || state.length - n < state.highWaterMark) {
    doRead = true;
    debug('length less than watermark', doRead);
  }

  // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.
  if (state.ended || state.reading) {
    doRead = false;
    debug('reading or ended', doRead);
  } else if (doRead) {
    debug('do read');
    state.reading = true;
    state.sync = true;
    // if the length is currently zero, then we *need* a readable event.
    if (state.length === 0) state.needReadable = true;
    // call internal read method
    this._read(state.highWaterMark);
    state.sync = false;
    // If _read pushed data synchronously, then `reading` will be false,
    // and we need to re-evaluate how much data we can return to the user.
    if (!state.reading) n = howMuchToRead(nOrig, state);
  }
  var ret;
  if (n > 0) ret = fromList(n, state);else ret = null;
  if (ret === null) {
    state.needReadable = state.length <= state.highWaterMark;
    n = 0;
  } else {
    state.length -= n;
    state.awaitDrain = 0;
  }
  if (state.length === 0) {
    // If we have nothing in the buffer, then we want to know
    // as soon as we *do* get something into the buffer.
    if (!state.ended) state.needReadable = true;

    // If we tried to read() past the EOF, then emit end on the next tick.
    if (nOrig !== n && state.ended) endReadable(this);
  }
  if (ret !== null) this.emit('data', ret);
  return ret;
};
function onEofChunk(stream, state) {
  debug('onEofChunk');
  if (state.ended) return;
  if (state.decoder) {
    var chunk = state.decoder.end();
    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }
  state.ended = true;
  if (state.sync) {
    // if we are sync, wait until next tick to emit the data.
    // Otherwise we risk emitting data in the flow()
    // the readable code triggers during a read() call
    emitReadable(stream);
  } else {
    // emit 'readable' now to make sure it gets picked up.
    state.needReadable = false;
    if (!state.emittedReadable) {
      state.emittedReadable = true;
      emitReadable_(stream);
    }
  }
}

// Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.
function emitReadable(stream) {
  var state = stream._readableState;
  debug('emitReadable', state.needReadable, state.emittedReadable);
  state.needReadable = false;
  if (!state.emittedReadable) {
    debug('emitReadable', state.flowing);
    state.emittedReadable = true;
    process.nextTick(emitReadable_, stream);
  }
}
function emitReadable_(stream) {
  var state = stream._readableState;
  debug('emitReadable_', state.destroyed, state.length, state.ended);
  if (!state.destroyed && (state.length || state.ended)) {
    stream.emit('readable');
    state.emittedReadable = false;
  }

  // The stream needs another readable event if
  // 1. It is not flowing, as the flow mechanism will take
  //    care of it.
  // 2. It is not ended.
  // 3. It is below the highWaterMark, so we can schedule
  //    another readable later.
  state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
  flow(stream);
}

// at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.
function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    process.nextTick(maybeReadMore_, stream, state);
  }
}
function maybeReadMore_(stream, state) {
  // Attempt to read more data if we should.
  //
  // The conditions for reading more data are (one of):
  // - Not enough data buffered (state.length < state.highWaterMark). The loop
  //   is responsible for filling the buffer with enough data if such data
  //   is available. If highWaterMark is 0 and we are not in the flowing mode
  //   we should _not_ attempt to buffer any extra data. We'll get more data
  //   when the stream consumer calls read() instead.
  // - No data in the buffer, and the stream is in flowing mode. In this mode
  //   the loop below is responsible for ensuring read() is called. Failing to
  //   call read here would abort the flow and there's no other mechanism for
  //   continuing the flow if the stream consumer has just subscribed to the
  //   'data' event.
  //
  // In addition to the above conditions to keep reading data, the following
  // conditions prevent the data from being read:
  // - The stream has ended (state.ended).
  // - There is already a pending 'read' operation (state.reading). This is a
  //   case where the the stream has called the implementation defined _read()
  //   method, but they are processing the call asynchronously and have _not_
  //   called push() with new data. In this case we skip performing more
  //   read()s. The execution ends in this method again after the _read() ends
  //   up calling push() with more data.
  while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
    var len = state.length;
    debug('maybeReadMore read 0');
    stream.read(0);
    if (len === state.length)
      // didn't get any data, stop spinning.
      break;
  }
  state.readingMore = false;
}

// abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.
Readable.prototype._read = function (n) {
  errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED('_read()'));
};
Readable.prototype.pipe = function (dest, pipeOpts) {
  var src = this;
  var state = this._readableState;
  switch (state.pipesCount) {
    case 0:
      state.pipes = dest;
      break;
    case 1:
      state.pipes = [state.pipes, dest];
      break;
    default:
      state.pipes.push(dest);
      break;
  }
  state.pipesCount += 1;
  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);
  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
  var endFn = doEnd ? onend : unpipe;
  if (state.endEmitted) process.nextTick(endFn);else src.once('end', endFn);
  dest.on('unpipe', onunpipe);
  function onunpipe(readable, unpipeInfo) {
    debug('onunpipe');
    if (readable === src) {
      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
        unpipeInfo.hasUnpiped = true;
        cleanup();
      }
    }
  }
  function onend() {
    debug('onend');
    dest.end();
  }

  // when the dest drains, it reduces the awaitDrain counter
  // on the source.  This would be more elegant with a .once()
  // handler in flow(), but adding and removing repeatedly is
  // too slow.
  var ondrain = pipeOnDrain(src);
  dest.on('drain', ondrain);
  var cleanedUp = false;
  function cleanup() {
    debug('cleanup');
    // cleanup event handlers once the pipe is broken
    dest.removeListener('close', onclose);
    dest.removeListener('finish', onfinish);
    dest.removeListener('drain', ondrain);
    dest.removeListener('error', onerror);
    dest.removeListener('unpipe', onunpipe);
    src.removeListener('end', onend);
    src.removeListener('end', unpipe);
    src.removeListener('data', ondata);
    cleanedUp = true;

    // if the reader is waiting for a drain event from this
    // specific writer, then it would cause it to never start
    // flowing again.
    // So, if this is awaiting a drain, then we just call it now.
    // If we don't know, then assume that we are waiting for one.
    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
  }
  src.on('data', ondata);
  function ondata(chunk) {
    debug('ondata');
    var ret = dest.write(chunk);
    debug('dest.write', ret);
    if (ret === false) {
      // If the user unpiped during `dest.write()`, it is possible
      // to get stuck in a permanently paused state if that write
      // also returned false.
      // => Check whether `dest` is still a piping destination.
      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
        debug('false write response, pause', state.awaitDrain);
        state.awaitDrain++;
      }
      src.pause();
    }
  }

  // if the dest has an error, then stop piping into it.
  // however, don't suppress the throwing behavior for this.
  function onerror(er) {
    debug('onerror', er);
    unpipe();
    dest.removeListener('error', onerror);
    if (EElistenerCount(dest, 'error') === 0) errorOrDestroy(dest, er);
  }

  // Make sure our error handler is attached before userland ones.
  prependListener(dest, 'error', onerror);

  // Both close and finish should trigger unpipe, but only once.
  function onclose() {
    dest.removeListener('finish', onfinish);
    unpipe();
  }
  dest.once('close', onclose);
  function onfinish() {
    debug('onfinish');
    dest.removeListener('close', onclose);
    unpipe();
  }
  dest.once('finish', onfinish);
  function unpipe() {
    debug('unpipe');
    src.unpipe(dest);
  }

  // tell the dest that it's being piped to
  dest.emit('pipe', src);

  // start the flow if it hasn't been started already.
  if (!state.flowing) {
    debug('pipe resume');
    src.resume();
  }
  return dest;
};
function pipeOnDrain(src) {
  return function pipeOnDrainFunctionResult() {
    var state = src._readableState;
    debug('pipeOnDrain', state.awaitDrain);
    if (state.awaitDrain) state.awaitDrain--;
    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
      state.flowing = true;
      flow(src);
    }
  };
}
Readable.prototype.unpipe = function (dest) {
  var state = this._readableState;
  var unpipeInfo = {
    hasUnpiped: false
  };

  // if we're not piping anywhere, then do nothing.
  if (state.pipesCount === 0) return this;

  // just one destination.  most common case.
  if (state.pipesCount === 1) {
    // passed in one, but it's not the right one.
    if (dest && dest !== state.pipes) return this;
    if (!dest) dest = state.pipes;

    // got a match.
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;
    if (dest) dest.emit('unpipe', this, unpipeInfo);
    return this;
  }

  // slow case. multiple pipe destinations.

  if (!dest) {
    // remove all.
    var dests = state.pipes;
    var len = state.pipesCount;
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;
    for (var i = 0; i < len; i++) dests[i].emit('unpipe', this, {
      hasUnpiped: false
    });
    return this;
  }

  // try to find the right one.
  var index = indexOf(state.pipes, dest);
  if (index === -1) return this;
  state.pipes.splice(index, 1);
  state.pipesCount -= 1;
  if (state.pipesCount === 1) state.pipes = state.pipes[0];
  dest.emit('unpipe', this, unpipeInfo);
  return this;
};

// set up data events if they are asked for
// Ensure readable listeners eventually get something
Readable.prototype.on = function (ev, fn) {
  var res = Stream.prototype.on.call(this, ev, fn);
  var state = this._readableState;
  if (ev === 'data') {
    // update readableListening so that resume() may be a no-op
    // a few lines down. This is needed to support once('readable').
    state.readableListening = this.listenerCount('readable') > 0;

    // Try start flowing on next tick if stream isn't explicitly paused
    if (state.flowing !== false) this.resume();
  } else if (ev === 'readable') {
    if (!state.endEmitted && !state.readableListening) {
      state.readableListening = state.needReadable = true;
      state.flowing = false;
      state.emittedReadable = false;
      debug('on readable', state.length, state.reading);
      if (state.length) {
        emitReadable(this);
      } else if (!state.reading) {
        process.nextTick(nReadingNextTick, this);
      }
    }
  }
  return res;
};
Readable.prototype.addListener = Readable.prototype.on;
Readable.prototype.removeListener = function (ev, fn) {
  var res = Stream.prototype.removeListener.call(this, ev, fn);
  if (ev === 'readable') {
    // We need to check if there is someone still listening to
    // readable and reset the state. However this needs to happen
    // after readable has been emitted but before I/O (nextTick) to
    // support once('readable', fn) cycles. This means that calling
    // resume within the same tick will have no
    // effect.
    process.nextTick(updateReadableListening, this);
  }
  return res;
};
Readable.prototype.removeAllListeners = function (ev) {
  var res = Stream.prototype.removeAllListeners.apply(this, arguments);
  if (ev === 'readable' || ev === undefined) {
    // We need to check if there is someone still listening to
    // readable and reset the state. However this needs to happen
    // after readable has been emitted but before I/O (nextTick) to
    // support once('readable', fn) cycles. This means that calling
    // resume within the same tick will have no
    // effect.
    process.nextTick(updateReadableListening, this);
  }
  return res;
};
function updateReadableListening(self) {
  var state = self._readableState;
  state.readableListening = self.listenerCount('readable') > 0;
  if (state.resumeScheduled && !state.paused) {
    // flowing needs to be set to true now, otherwise
    // the upcoming resume will not flow.
    state.flowing = true;

    // crude way to check if we should resume
  } else if (self.listenerCount('data') > 0) {
    self.resume();
  }
}
function nReadingNextTick(self) {
  debug('readable nexttick read 0');
  self.read(0);
}

// pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.
Readable.prototype.resume = function () {
  var state = this._readableState;
  if (!state.flowing) {
    debug('resume');
    // we flow only if there is no one listening
    // for readable, but we still have to call
    // resume()
    state.flowing = !state.readableListening;
    resume(this, state);
  }
  state.paused = false;
  return this;
};
function resume(stream, state) {
  if (!state.resumeScheduled) {
    state.resumeScheduled = true;
    process.nextTick(resume_, stream, state);
  }
}
function resume_(stream, state) {
  debug('resume', state.reading);
  if (!state.reading) {
    stream.read(0);
  }
  state.resumeScheduled = false;
  stream.emit('resume');
  flow(stream);
  if (state.flowing && !state.reading) stream.read(0);
}
Readable.prototype.pause = function () {
  debug('call pause flowing=%j', this._readableState.flowing);
  if (this._readableState.flowing !== false) {
    debug('pause');
    this._readableState.flowing = false;
    this.emit('pause');
  }
  this._readableState.paused = true;
  return this;
};
function flow(stream) {
  var state = stream._readableState;
  debug('flow', state.flowing);
  while (state.flowing && stream.read() !== null);
}

// wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.
Readable.prototype.wrap = function (stream) {
  var _this = this;
  var state = this._readableState;
  var paused = false;
  stream.on('end', function () {
    debug('wrapped end');
    if (state.decoder && !state.ended) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length) _this.push(chunk);
    }
    _this.push(null);
  });
  stream.on('data', function (chunk) {
    debug('wrapped data');
    if (state.decoder) chunk = state.decoder.write(chunk);

    // don't skip over falsy values in objectMode
    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;
    var ret = _this.push(chunk);
    if (!ret) {
      paused = true;
      stream.pause();
    }
  });

  // proxy all the other methods.
  // important when wrapping filters and duplexes.
  for (var i in stream) {
    if (this[i] === undefined && typeof stream[i] === 'function') {
      this[i] = function methodWrap(method) {
        return function methodWrapReturnFunction() {
          return stream[method].apply(stream, arguments);
        };
      }(i);
    }
  }

  // proxy certain important events.
  for (var n = 0; n < kProxyEvents.length; n++) {
    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
  }

  // when we try to consume some more bytes, simply unpause the
  // underlying stream.
  this._read = function (n) {
    debug('wrapped _read', n);
    if (paused) {
      paused = false;
      stream.resume();
    }
  };
  return this;
};
if (typeof Symbol === 'function') {
  Readable.prototype[Symbol.asyncIterator] = function () {
    if (createReadableStreamAsyncIterator === undefined) {
      createReadableStreamAsyncIterator = __nccwpck_require__(14868);
    }
    return createReadableStreamAsyncIterator(this);
  };
}
Object.defineProperty(Readable.prototype, 'readableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState.highWaterMark;
  }
});
Object.defineProperty(Readable.prototype, 'readableBuffer', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState && this._readableState.buffer;
  }
});
Object.defineProperty(Readable.prototype, 'readableFlowing', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState.flowing;
  },
  set: function set(state) {
    if (this._readableState) {
      this._readableState.flowing = state;
    }
  }
});

// exposed for testing purposes only.
Readable._fromList = fromList;
Object.defineProperty(Readable.prototype, 'readableLength', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState.length;
  }
});

// Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function fromList(n, state) {
  // nothing buffered
  if (state.length === 0) return null;
  var ret;
  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {
    // read it all, truncate the list
    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.first();else ret = state.buffer.concat(state.length);
    state.buffer.clear();
  } else {
    // read part of list
    ret = state.buffer.consume(n, state.decoder);
  }
  return ret;
}
function endReadable(stream) {
  var state = stream._readableState;
  debug('endReadable', state.endEmitted);
  if (!state.endEmitted) {
    state.ended = true;
    process.nextTick(endReadableNT, state, stream);
  }
}
function endReadableNT(state, stream) {
  debug('endReadableNT', state.endEmitted, state.length);

  // Check that we didn't get one last unshift.
  if (!state.endEmitted && state.length === 0) {
    state.endEmitted = true;
    stream.readable = false;
    stream.emit('end');
    if (state.autoDestroy) {
      // In case of duplex streams we need a way to detect
      // if the writable side is ready for autoDestroy as well
      var wState = stream._writableState;
      if (!wState || wState.autoDestroy && wState.finished) {
        stream.destroy();
      }
    }
  }
}
if (typeof Symbol === 'function') {
  Readable.from = function (iterable, opts) {
    if (from === undefined) {
      from = __nccwpck_require__(4659);
    }
    return from(Readable, iterable, opts);
  };
}
function indexOf(xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x) return i;
  }
  return -1;
}

/***/ }),

/***/ 12337:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.



module.exports = Transform;
var _require$codes = (__nccwpck_require__(25500)/* .codes */ .F),
  ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
  ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,
  ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING,
  ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;
var Duplex = __nccwpck_require__(82063);
__nccwpck_require__(39598)(Transform, Duplex);
function afterTransform(er, data) {
  var ts = this._transformState;
  ts.transforming = false;
  var cb = ts.writecb;
  if (cb === null) {
    return this.emit('error', new ERR_MULTIPLE_CALLBACK());
  }
  ts.writechunk = null;
  ts.writecb = null;
  if (data != null)
    // single equals check for both `null` and `undefined`
    this.push(data);
  cb(er);
  var rs = this._readableState;
  rs.reading = false;
  if (rs.needReadable || rs.length < rs.highWaterMark) {
    this._read(rs.highWaterMark);
  }
}
function Transform(options) {
  if (!(this instanceof Transform)) return new Transform(options);
  Duplex.call(this, options);
  this._transformState = {
    afterTransform: afterTransform.bind(this),
    needTransform: false,
    transforming: false,
    writecb: null,
    writechunk: null,
    writeencoding: null
  };

  // start out asking for a readable event once data is transformed.
  this._readableState.needReadable = true;

  // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.
  this._readableState.sync = false;
  if (options) {
    if (typeof options.transform === 'function') this._transform = options.transform;
    if (typeof options.flush === 'function') this._flush = options.flush;
  }

  // When the writable side finishes, then flush out anything remaining.
  this.on('prefinish', prefinish);
}
function prefinish() {
  var _this = this;
  if (typeof this._flush === 'function' && !this._readableState.destroyed) {
    this._flush(function (er, data) {
      done(_this, er, data);
    });
  } else {
    done(this, null, null);
  }
}
Transform.prototype.push = function (chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
};

// This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.
Transform.prototype._transform = function (chunk, encoding, cb) {
  cb(new ERR_METHOD_NOT_IMPLEMENTED('_transform()'));
};
Transform.prototype._write = function (chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;
  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
  }
};

// Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.
Transform.prototype._read = function (n) {
  var ts = this._transformState;
  if (ts.writechunk !== null && !ts.transforming) {
    ts.transforming = true;
    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
  }
};
Transform.prototype._destroy = function (err, cb) {
  Duplex.prototype._destroy.call(this, err, function (err2) {
    cb(err2);
  });
};
function done(stream, er, data) {
  if (er) return stream.emit('error', er);
  if (data != null)
    // single equals check for both `null` and `undefined`
    stream.push(data);

  // TODO(BridgeAR): Write a test for these two error cases
  // if there's nothing in the write buffer, then that means
  // that nothing more will ever be provided
  if (stream._writableState.length) throw new ERR_TRANSFORM_WITH_LENGTH_0();
  if (stream._transformState.transforming) throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
  return stream.push(null);
}

/***/ }),

/***/ 38797:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// A bit simpler than readable streams.
// Implement an async ._write(chunk, encoding, cb), and it'll handle all
// the drain event emission and buffering.



module.exports = Writable;

/* <replacement> */
function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
  this.next = null;
}

// It seems a linked list but it is not
// there will be only 2 of these for each stream
function CorkedRequest(state) {
  var _this = this;
  this.next = null;
  this.entry = null;
  this.finish = function () {
    onCorkedFinish(_this, state);
  };
}
/* </replacement> */

/*<replacement>*/
var Duplex;
/*</replacement>*/

Writable.WritableState = WritableState;

/*<replacement>*/
var internalUtil = {
  deprecate: __nccwpck_require__(24488)
};
/*</replacement>*/

/*<replacement>*/
var Stream = __nccwpck_require__(63283);
/*</replacement>*/

var Buffer = (__nccwpck_require__(20181).Buffer);
var OurUint8Array = (typeof global !== 'undefined' ? global : typeof window !== 'undefined' ? window : typeof self !== 'undefined' ? self : {}).Uint8Array || function () {};
function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}
function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}
var destroyImpl = __nccwpck_require__(65089);
var _require = __nccwpck_require__(54874),
  getHighWaterMark = _require.getHighWaterMark;
var _require$codes = (__nccwpck_require__(25500)/* .codes */ .F),
  ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,
  ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
  ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,
  ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE,
  ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED,
  ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES,
  ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END,
  ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;
var errorOrDestroy = destroyImpl.errorOrDestroy;
__nccwpck_require__(39598)(Writable, Stream);
function nop() {}
function WritableState(options, stream, isDuplex) {
  Duplex = Duplex || __nccwpck_require__(82063);
  options = options || {};

  // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream,
  // e.g. options.readableObjectMode vs. options.writableObjectMode, etc.
  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex;

  // object stream flag to indicate whether or not this stream
  // contains buffers or objects.
  this.objectMode = !!options.objectMode;
  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;

  // the point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write()
  this.highWaterMark = getHighWaterMark(this, options, 'writableHighWaterMark', isDuplex);

  // if _final has been called
  this.finalCalled = false;

  // drain event flag.
  this.needDrain = false;
  // at the start of calling end()
  this.ending = false;
  // when end() has been called, and returned
  this.ended = false;
  // when 'finish' is emitted
  this.finished = false;

  // has it been destroyed
  this.destroyed = false;

  // should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.
  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.
  this.length = 0;

  // a flag to see when we're in the middle of a write.
  this.writing = false;

  // when true all writes will be buffered until .uncork() call
  this.corked = 0;

  // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.
  this.sync = true;

  // a flag to know if we're processing previously buffered items, which
  // may call the _write() callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.
  this.bufferProcessing = false;

  // the callback that's passed to _write(chunk,cb)
  this.onwrite = function (er) {
    onwrite(stream, er);
  };

  // the callback that the user supplies to write(chunk,encoding,cb)
  this.writecb = null;

  // the amount that is being written when _write is called.
  this.writelen = 0;
  this.bufferedRequest = null;
  this.lastBufferedRequest = null;

  // number of pending user-supplied write callbacks
  // this must be 0 before 'finish' can be emitted
  this.pendingcb = 0;

  // emit prefinish if the only thing we're waiting for is _write cbs
  // This is relevant for synchronous Transform streams
  this.prefinished = false;

  // True if the error was already emitted and should not be thrown again
  this.errorEmitted = false;

  // Should close be emitted on destroy. Defaults to true.
  this.emitClose = options.emitClose !== false;

  // Should .destroy() be called after 'finish' (and potentially 'end')
  this.autoDestroy = !!options.autoDestroy;

  // count buffered requests
  this.bufferedRequestCount = 0;

  // allocate the first CorkedRequest, there is always
  // one allocated and free to use, and we maintain at most two
  this.corkedRequestsFree = new CorkedRequest(this);
}
WritableState.prototype.getBuffer = function getBuffer() {
  var current = this.bufferedRequest;
  var out = [];
  while (current) {
    out.push(current);
    current = current.next;
  }
  return out;
};
(function () {
  try {
    Object.defineProperty(WritableState.prototype, 'buffer', {
      get: internalUtil.deprecate(function writableStateBufferGetter() {
        return this.getBuffer();
      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')
    });
  } catch (_) {}
})();

// Test _writableState for inheritance to account for Duplex streams,
// whose prototype chain only points to Readable.
var realHasInstance;
if (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {
  realHasInstance = Function.prototype[Symbol.hasInstance];
  Object.defineProperty(Writable, Symbol.hasInstance, {
    value: function value(object) {
      if (realHasInstance.call(this, object)) return true;
      if (this !== Writable) return false;
      return object && object._writableState instanceof WritableState;
    }
  });
} else {
  realHasInstance = function realHasInstance(object) {
    return object instanceof this;
  };
}
function Writable(options) {
  Duplex = Duplex || __nccwpck_require__(82063);

  // Writable ctor is applied to Duplexes, too.
  // `realHasInstance` is necessary because using plain `instanceof`
  // would return false, as no `_writableState` property is attached.

  // Trying to use the custom `instanceof` for Writable here will also break the
  // Node.js LazyTransform implementation, which has a non-trivial getter for
  // `_writableState` that would lead to infinite recursion.

  // Checking for a Stream.Duplex instance is faster here instead of inside
  // the WritableState constructor, at least with V8 6.5
  var isDuplex = this instanceof Duplex;
  if (!isDuplex && !realHasInstance.call(Writable, this)) return new Writable(options);
  this._writableState = new WritableState(options, this, isDuplex);

  // legacy.
  this.writable = true;
  if (options) {
    if (typeof options.write === 'function') this._write = options.write;
    if (typeof options.writev === 'function') this._writev = options.writev;
    if (typeof options.destroy === 'function') this._destroy = options.destroy;
    if (typeof options.final === 'function') this._final = options.final;
  }
  Stream.call(this);
}

// Otherwise people can pipe Writable streams, which is just wrong.
Writable.prototype.pipe = function () {
  errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
};
function writeAfterEnd(stream, cb) {
  var er = new ERR_STREAM_WRITE_AFTER_END();
  // TODO: defer error events consistently everywhere, not just the cb
  errorOrDestroy(stream, er);
  process.nextTick(cb, er);
}

// Checks that a user-supplied chunk is valid, especially for the particular
// mode the stream is in. Currently this means that `null` is never accepted
// and undefined/non-string values are only allowed in object mode.
function validChunk(stream, state, chunk, cb) {
  var er;
  if (chunk === null) {
    er = new ERR_STREAM_NULL_VALUES();
  } else if (typeof chunk !== 'string' && !state.objectMode) {
    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer'], chunk);
  }
  if (er) {
    errorOrDestroy(stream, er);
    process.nextTick(cb, er);
    return false;
  }
  return true;
}
Writable.prototype.write = function (chunk, encoding, cb) {
  var state = this._writableState;
  var ret = false;
  var isBuf = !state.objectMode && _isUint8Array(chunk);
  if (isBuf && !Buffer.isBuffer(chunk)) {
    chunk = _uint8ArrayToBuffer(chunk);
  }
  if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }
  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;
  if (typeof cb !== 'function') cb = nop;
  if (state.ending) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {
    state.pendingcb++;
    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
  }
  return ret;
};
Writable.prototype.cork = function () {
  this._writableState.corked++;
};
Writable.prototype.uncork = function () {
  var state = this._writableState;
  if (state.corked) {
    state.corked--;
    if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
  }
};
Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
  // node::ParseEncoding() requires lower case.
  if (typeof encoding === 'string') encoding = encoding.toLowerCase();
  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new ERR_UNKNOWN_ENCODING(encoding);
  this._writableState.defaultEncoding = encoding;
  return this;
};
Object.defineProperty(Writable.prototype, 'writableBuffer', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState && this._writableState.getBuffer();
  }
});
function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
    chunk = Buffer.from(chunk, encoding);
  }
  return chunk;
}
Object.defineProperty(Writable.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.highWaterMark;
  }
});

// if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.
function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
  if (!isBuf) {
    var newChunk = decodeChunk(state, chunk, encoding);
    if (chunk !== newChunk) {
      isBuf = true;
      encoding = 'buffer';
      chunk = newChunk;
    }
  }
  var len = state.objectMode ? 1 : chunk.length;
  state.length += len;
  var ret = state.length < state.highWaterMark;
  // we must ensure that previous needDrain will not be reset to false.
  if (!ret) state.needDrain = true;
  if (state.writing || state.corked) {
    var last = state.lastBufferedRequest;
    state.lastBufferedRequest = {
      chunk: chunk,
      encoding: encoding,
      isBuf: isBuf,
      callback: cb,
      next: null
    };
    if (last) {
      last.next = state.lastBufferedRequest;
    } else {
      state.bufferedRequest = state.lastBufferedRequest;
    }
    state.bufferedRequestCount += 1;
  } else {
    doWrite(stream, state, false, len, chunk, encoding, cb);
  }
  return ret;
}
function doWrite(stream, state, writev, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  if (state.destroyed) state.onwrite(new ERR_STREAM_DESTROYED('write'));else if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}
function onwriteError(stream, state, sync, er, cb) {
  --state.pendingcb;
  if (sync) {
    // defer the callback if we are being called synchronously
    // to avoid piling up things on the stack
    process.nextTick(cb, er);
    // this can emit finish, and it will always happen
    // after error
    process.nextTick(finishMaybe, stream, state);
    stream._writableState.errorEmitted = true;
    errorOrDestroy(stream, er);
  } else {
    // the caller expect this to happen before if
    // it is async
    cb(er);
    stream._writableState.errorEmitted = true;
    errorOrDestroy(stream, er);
    // this can emit finish, but finish must
    // always follow error
    finishMaybe(stream, state);
  }
}
function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}
function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;
  if (typeof cb !== 'function') throw new ERR_MULTIPLE_CALLBACK();
  onwriteStateUpdate(state);
  if (er) onwriteError(stream, state, sync, er, cb);else {
    // Check if we're actually ready to finish, but don't emit yet
    var finished = needFinish(state) || stream.destroyed;
    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
      clearBuffer(stream, state);
    }
    if (sync) {
      process.nextTick(afterWrite, stream, state, finished, cb);
    } else {
      afterWrite(stream, state, finished, cb);
    }
  }
}
function afterWrite(stream, state, finished, cb) {
  if (!finished) onwriteDrain(stream, state);
  state.pendingcb--;
  cb();
  finishMaybe(stream, state);
}

// Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.
function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit('drain');
  }
}

// if there's something in the buffer waiting, then process it
function clearBuffer(stream, state) {
  state.bufferProcessing = true;
  var entry = state.bufferedRequest;
  if (stream._writev && entry && entry.next) {
    // Fast case, write everything using _writev()
    var l = state.bufferedRequestCount;
    var buffer = new Array(l);
    var holder = state.corkedRequestsFree;
    holder.entry = entry;
    var count = 0;
    var allBuffers = true;
    while (entry) {
      buffer[count] = entry;
      if (!entry.isBuf) allBuffers = false;
      entry = entry.next;
      count += 1;
    }
    buffer.allBuffers = allBuffers;
    doWrite(stream, state, true, state.length, buffer, '', holder.finish);

    // doWrite is almost always async, defer these to save a bit of time
    // as the hot path ends with doWrite
    state.pendingcb++;
    state.lastBufferedRequest = null;
    if (holder.next) {
      state.corkedRequestsFree = holder.next;
      holder.next = null;
    } else {
      state.corkedRequestsFree = new CorkedRequest(state);
    }
    state.bufferedRequestCount = 0;
  } else {
    // Slow case, write chunks one-by-one
    while (entry) {
      var chunk = entry.chunk;
      var encoding = entry.encoding;
      var cb = entry.callback;
      var len = state.objectMode ? 1 : chunk.length;
      doWrite(stream, state, false, len, chunk, encoding, cb);
      entry = entry.next;
      state.bufferedRequestCount--;
      // if we didn't call the onwrite immediately, then
      // it means that we need to wait until it does.
      // also, that means that the chunk and cb are currently
      // being processed, so move the buffer counter past them.
      if (state.writing) {
        break;
      }
    }
    if (entry === null) state.lastBufferedRequest = null;
  }
  state.bufferedRequest = entry;
  state.bufferProcessing = false;
}
Writable.prototype._write = function (chunk, encoding, cb) {
  cb(new ERR_METHOD_NOT_IMPLEMENTED('_write()'));
};
Writable.prototype._writev = null;
Writable.prototype.end = function (chunk, encoding, cb) {
  var state = this._writableState;
  if (typeof chunk === 'function') {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }
  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);

  // .end() fully uncorks
  if (state.corked) {
    state.corked = 1;
    this.uncork();
  }

  // ignore unnecessary end() calls.
  if (!state.ending) endWritable(this, state, cb);
  return this;
};
Object.defineProperty(Writable.prototype, 'writableLength', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.length;
  }
});
function needFinish(state) {
  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
}
function callFinal(stream, state) {
  stream._final(function (err) {
    state.pendingcb--;
    if (err) {
      errorOrDestroy(stream, err);
    }
    state.prefinished = true;
    stream.emit('prefinish');
    finishMaybe(stream, state);
  });
}
function prefinish(stream, state) {
  if (!state.prefinished && !state.finalCalled) {
    if (typeof stream._final === 'function' && !state.destroyed) {
      state.pendingcb++;
      state.finalCalled = true;
      process.nextTick(callFinal, stream, state);
    } else {
      state.prefinished = true;
      stream.emit('prefinish');
    }
  }
}
function finishMaybe(stream, state) {
  var need = needFinish(state);
  if (need) {
    prefinish(stream, state);
    if (state.pendingcb === 0) {
      state.finished = true;
      stream.emit('finish');
      if (state.autoDestroy) {
        // In case of duplex streams we need a way to detect
        // if the readable side is ready for autoDestroy as well
        var rState = stream._readableState;
        if (!rState || rState.autoDestroy && rState.endEmitted) {
          stream.destroy();
        }
      }
    }
  }
  return need;
}
function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);
  if (cb) {
    if (state.finished) process.nextTick(cb);else stream.once('finish', cb);
  }
  state.ended = true;
  stream.writable = false;
}
function onCorkedFinish(corkReq, state, err) {
  var entry = corkReq.entry;
  corkReq.entry = null;
  while (entry) {
    var cb = entry.callback;
    state.pendingcb--;
    cb(err);
    entry = entry.next;
  }

  // reuse the free corkReq.
  state.corkedRequestsFree.next = corkReq;
}
Object.defineProperty(Writable.prototype, 'destroyed', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    if (this._writableState === undefined) {
      return false;
    }
    return this._writableState.destroyed;
  },
  set: function set(value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._writableState) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._writableState.destroyed = value;
  }
});
Writable.prototype.destroy = destroyImpl.destroy;
Writable.prototype._undestroy = destroyImpl.undestroy;
Writable.prototype._destroy = function (err, cb) {
  cb(err);
};

/***/ }),

/***/ 14868:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


var _Object$setPrototypeO;
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
var finished = __nccwpck_require__(36815);
var kLastResolve = Symbol('lastResolve');
var kLastReject = Symbol('lastReject');
var kError = Symbol('error');
var kEnded = Symbol('ended');
var kLastPromise = Symbol('lastPromise');
var kHandlePromise = Symbol('handlePromise');
var kStream = Symbol('stream');
function createIterResult(value, done) {
  return {
    value: value,
    done: done
  };
}
function readAndResolve(iter) {
  var resolve = iter[kLastResolve];
  if (resolve !== null) {
    var data = iter[kStream].read();
    // we defer if data is null
    // we can be expecting either 'end' or
    // 'error'
    if (data !== null) {
      iter[kLastPromise] = null;
      iter[kLastResolve] = null;
      iter[kLastReject] = null;
      resolve(createIterResult(data, false));
    }
  }
}
function onReadable(iter) {
  // we wait for the next tick, because it might
  // emit an error with process.nextTick
  process.nextTick(readAndResolve, iter);
}
function wrapForNext(lastPromise, iter) {
  return function (resolve, reject) {
    lastPromise.then(function () {
      if (iter[kEnded]) {
        resolve(createIterResult(undefined, true));
        return;
      }
      iter[kHandlePromise](resolve, reject);
    }, reject);
  };
}
var AsyncIteratorPrototype = Object.getPrototypeOf(function () {});
var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
  get stream() {
    return this[kStream];
  },
  next: function next() {
    var _this = this;
    // if we have detected an error in the meanwhile
    // reject straight away
    var error = this[kError];
    if (error !== null) {
      return Promise.reject(error);
    }
    if (this[kEnded]) {
      return Promise.resolve(createIterResult(undefined, true));
    }
    if (this[kStream].destroyed) {
      // We need to defer via nextTick because if .destroy(err) is
      // called, the error will be emitted via nextTick, and
      // we cannot guarantee that there is no error lingering around
      // waiting to be emitted.
      return new Promise(function (resolve, reject) {
        process.nextTick(function () {
          if (_this[kError]) {
            reject(_this[kError]);
          } else {
            resolve(createIterResult(undefined, true));
          }
        });
      });
    }

    // if we have multiple next() calls
    // we will wait for the previous Promise to finish
    // this logic is optimized to support for await loops,
    // where next() is only called once at a time
    var lastPromise = this[kLastPromise];
    var promise;
    if (lastPromise) {
      promise = new Promise(wrapForNext(lastPromise, this));
    } else {
      // fast path needed to support multiple this.push()
      // without triggering the next() queue
      var data = this[kStream].read();
      if (data !== null) {
        return Promise.resolve(createIterResult(data, false));
      }
      promise = new Promise(this[kHandlePromise]);
    }
    this[kLastPromise] = promise;
    return promise;
  }
}, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function () {
  return this;
}), _defineProperty(_Object$setPrototypeO, "return", function _return() {
  var _this2 = this;
  // destroy(err, cb) is a private API
  // we can guarantee we have that here, because we control the
  // Readable class this is attached to
  return new Promise(function (resolve, reject) {
    _this2[kStream].destroy(null, function (err) {
      if (err) {
        reject(err);
        return;
      }
      resolve(createIterResult(undefined, true));
    });
  });
}), _Object$setPrototypeO), AsyncIteratorPrototype);
var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator(stream) {
  var _Object$create;
  var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
    value: stream,
    writable: true
  }), _defineProperty(_Object$create, kLastResolve, {
    value: null,
    writable: true
  }), _defineProperty(_Object$create, kLastReject, {
    value: null,
    writable: true
  }), _defineProperty(_Object$create, kError, {
    value: null,
    writable: true
  }), _defineProperty(_Object$create, kEnded, {
    value: stream._readableState.endEmitted,
    writable: true
  }), _defineProperty(_Object$create, kHandlePromise, {
    value: function value(resolve, reject) {
      var data = iterator[kStream].read();
      if (data) {
        iterator[kLastPromise] = null;
        iterator[kLastResolve] = null;
        iterator[kLastReject] = null;
        resolve(createIterResult(data, false));
      } else {
        iterator[kLastResolve] = resolve;
        iterator[kLastReject] = reject;
      }
    },
    writable: true
  }), _Object$create));
  iterator[kLastPromise] = null;
  finished(stream, function (err) {
    if (err && err.code !== 'ERR_STREAM_PREMATURE_CLOSE') {
      var reject = iterator[kLastReject];
      // reject if we are waiting for data in the Promise
      // returned by next() and store the error
      if (reject !== null) {
        iterator[kLastPromise] = null;
        iterator[kLastResolve] = null;
        iterator[kLastReject] = null;
        reject(err);
      }
      iterator[kError] = err;
      return;
    }
    var resolve = iterator[kLastResolve];
    if (resolve !== null) {
      iterator[kLastPromise] = null;
      iterator[kLastResolve] = null;
      iterator[kLastReject] = null;
      resolve(createIterResult(undefined, true));
    }
    iterator[kEnded] = true;
  });
  stream.on('readable', onReadable.bind(null, iterator));
  return iterator;
};
module.exports = createReadableStreamAsyncIterator;

/***/ }),

/***/ 77336:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
var _require = __nccwpck_require__(20181),
  Buffer = _require.Buffer;
var _require2 = __nccwpck_require__(39023),
  inspect = _require2.inspect;
var custom = inspect && inspect.custom || 'inspect';
function copyBuffer(src, target, offset) {
  Buffer.prototype.copy.call(src, target, offset);
}
module.exports = /*#__PURE__*/function () {
  function BufferList() {
    _classCallCheck(this, BufferList);
    this.head = null;
    this.tail = null;
    this.length = 0;
  }
  _createClass(BufferList, [{
    key: "push",
    value: function push(v) {
      var entry = {
        data: v,
        next: null
      };
      if (this.length > 0) this.tail.next = entry;else this.head = entry;
      this.tail = entry;
      ++this.length;
    }
  }, {
    key: "unshift",
    value: function unshift(v) {
      var entry = {
        data: v,
        next: this.head
      };
      if (this.length === 0) this.tail = entry;
      this.head = entry;
      ++this.length;
    }
  }, {
    key: "shift",
    value: function shift() {
      if (this.length === 0) return;
      var ret = this.head.data;
      if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;
      --this.length;
      return ret;
    }
  }, {
    key: "clear",
    value: function clear() {
      this.head = this.tail = null;
      this.length = 0;
    }
  }, {
    key: "join",
    value: function join(s) {
      if (this.length === 0) return '';
      var p = this.head;
      var ret = '' + p.data;
      while (p = p.next) ret += s + p.data;
      return ret;
    }
  }, {
    key: "concat",
    value: function concat(n) {
      if (this.length === 0) return Buffer.alloc(0);
      var ret = Buffer.allocUnsafe(n >>> 0);
      var p = this.head;
      var i = 0;
      while (p) {
        copyBuffer(p.data, ret, i);
        i += p.data.length;
        p = p.next;
      }
      return ret;
    }

    // Consumes a specified amount of bytes or characters from the buffered data.
  }, {
    key: "consume",
    value: function consume(n, hasStrings) {
      var ret;
      if (n < this.head.data.length) {
        // `slice` is the same for buffers and strings.
        ret = this.head.data.slice(0, n);
        this.head.data = this.head.data.slice(n);
      } else if (n === this.head.data.length) {
        // First chunk is a perfect match.
        ret = this.shift();
      } else {
        // Result spans more than one buffer.
        ret = hasStrings ? this._getString(n) : this._getBuffer(n);
      }
      return ret;
    }
  }, {
    key: "first",
    value: function first() {
      return this.head.data;
    }

    // Consumes a specified amount of characters from the buffered data.
  }, {
    key: "_getString",
    value: function _getString(n) {
      var p = this.head;
      var c = 1;
      var ret = p.data;
      n -= ret.length;
      while (p = p.next) {
        var str = p.data;
        var nb = n > str.length ? str.length : n;
        if (nb === str.length) ret += str;else ret += str.slice(0, n);
        n -= nb;
        if (n === 0) {
          if (nb === str.length) {
            ++c;
            if (p.next) this.head = p.next;else this.head = this.tail = null;
          } else {
            this.head = p;
            p.data = str.slice(nb);
          }
          break;
        }
        ++c;
      }
      this.length -= c;
      return ret;
    }

    // Consumes a specified amount of bytes from the buffered data.
  }, {
    key: "_getBuffer",
    value: function _getBuffer(n) {
      var ret = Buffer.allocUnsafe(n);
      var p = this.head;
      var c = 1;
      p.data.copy(ret);
      n -= p.data.length;
      while (p = p.next) {
        var buf = p.data;
        var nb = n > buf.length ? buf.length : n;
        buf.copy(ret, ret.length - n, 0, nb);
        n -= nb;
        if (n === 0) {
          if (nb === buf.length) {
            ++c;
            if (p.next) this.head = p.next;else this.head = this.tail = null;
          } else {
            this.head = p;
            p.data = buf.slice(nb);
          }
          break;
        }
        ++c;
      }
      this.length -= c;
      return ret;
    }

    // Make sure the linked list only shows the minimal necessary information.
  }, {
    key: custom,
    value: function value(_, options) {
      return inspect(this, _objectSpread(_objectSpread({}, options), {}, {
        // Only inspect one level.
        depth: 0,
        // It should not recurse.
        customInspect: false
      }));
    }
  }]);
  return BufferList;
}();

/***/ }),

/***/ 65089:
/***/ ((module) => {

"use strict";


// undocumented cb() API, needed for core, not for public API
function destroy(err, cb) {
  var _this = this;
  var readableDestroyed = this._readableState && this._readableState.destroyed;
  var writableDestroyed = this._writableState && this._writableState.destroyed;
  if (readableDestroyed || writableDestroyed) {
    if (cb) {
      cb(err);
    } else if (err) {
      if (!this._writableState) {
        process.nextTick(emitErrorNT, this, err);
      } else if (!this._writableState.errorEmitted) {
        this._writableState.errorEmitted = true;
        process.nextTick(emitErrorNT, this, err);
      }
    }
    return this;
  }

  // we set destroyed to true before firing error callbacks in order
  // to make it re-entrance safe in case destroy() is called within callbacks

  if (this._readableState) {
    this._readableState.destroyed = true;
  }

  // if this is a duplex stream mark the writable part as destroyed as well
  if (this._writableState) {
    this._writableState.destroyed = true;
  }
  this._destroy(err || null, function (err) {
    if (!cb && err) {
      if (!_this._writableState) {
        process.nextTick(emitErrorAndCloseNT, _this, err);
      } else if (!_this._writableState.errorEmitted) {
        _this._writableState.errorEmitted = true;
        process.nextTick(emitErrorAndCloseNT, _this, err);
      } else {
        process.nextTick(emitCloseNT, _this);
      }
    } else if (cb) {
      process.nextTick(emitCloseNT, _this);
      cb(err);
    } else {
      process.nextTick(emitCloseNT, _this);
    }
  });
  return this;
}
function emitErrorAndCloseNT(self, err) {
  emitErrorNT(self, err);
  emitCloseNT(self);
}
function emitCloseNT(self) {
  if (self._writableState && !self._writableState.emitClose) return;
  if (self._readableState && !self._readableState.emitClose) return;
  self.emit('close');
}
function undestroy() {
  if (this._readableState) {
    this._readableState.destroyed = false;
    this._readableState.reading = false;
    this._readableState.ended = false;
    this._readableState.endEmitted = false;
  }
  if (this._writableState) {
    this._writableState.destroyed = false;
    this._writableState.ended = false;
    this._writableState.ending = false;
    this._writableState.finalCalled = false;
    this._writableState.prefinished = false;
    this._writableState.finished = false;
    this._writableState.errorEmitted = false;
  }
}
function emitErrorNT(self, err) {
  self.emit('error', err);
}
function errorOrDestroy(stream, err) {
  // We have tests that rely on errors being emitted
  // in the same tick, so changing this is semver major.
  // For now when you opt-in to autoDestroy we allow
  // the error to be emitted nextTick. In a future
  // semver major update we should change the default to this.

  var rState = stream._readableState;
  var wState = stream._writableState;
  if (rState && rState.autoDestroy || wState && wState.autoDestroy) stream.destroy(err);else stream.emit('error', err);
}
module.exports = {
  destroy: destroy,
  undestroy: undestroy,
  errorOrDestroy: errorOrDestroy
};

/***/ }),

/***/ 36815:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";
// Ported from https://github.com/mafintosh/end-of-stream with
// permission from the author, Mathias Buus (@mafintosh).



var ERR_STREAM_PREMATURE_CLOSE = (__nccwpck_require__(25500)/* .codes */ .F).ERR_STREAM_PREMATURE_CLOSE;
function once(callback) {
  var called = false;
  return function () {
    if (called) return;
    called = true;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    callback.apply(this, args);
  };
}
function noop() {}
function isRequest(stream) {
  return stream.setHeader && typeof stream.abort === 'function';
}
function eos(stream, opts, callback) {
  if (typeof opts === 'function') return eos(stream, null, opts);
  if (!opts) opts = {};
  callback = once(callback || noop);
  var readable = opts.readable || opts.readable !== false && stream.readable;
  var writable = opts.writable || opts.writable !== false && stream.writable;
  var onlegacyfinish = function onlegacyfinish() {
    if (!stream.writable) onfinish();
  };
  var writableEnded = stream._writableState && stream._writableState.finished;
  var onfinish = function onfinish() {
    writable = false;
    writableEnded = true;
    if (!readable) callback.call(stream);
  };
  var readableEnded = stream._readableState && stream._readableState.endEmitted;
  var onend = function onend() {
    readable = false;
    readableEnded = true;
    if (!writable) callback.call(stream);
  };
  var onerror = function onerror(err) {
    callback.call(stream, err);
  };
  var onclose = function onclose() {
    var err;
    if (readable && !readableEnded) {
      if (!stream._readableState || !stream._readableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
      return callback.call(stream, err);
    }
    if (writable && !writableEnded) {
      if (!stream._writableState || !stream._writableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
      return callback.call(stream, err);
    }
  };
  var onrequest = function onrequest() {
    stream.req.on('finish', onfinish);
  };
  if (isRequest(stream)) {
    stream.on('complete', onfinish);
    stream.on('abort', onclose);
    if (stream.req) onrequest();else stream.on('request', onrequest);
  } else if (writable && !stream._writableState) {
    // legacy streams
    stream.on('end', onlegacyfinish);
    stream.on('close', onlegacyfinish);
  }
  stream.on('end', onend);
  stream.on('finish', onfinish);
  if (opts.error !== false) stream.on('error', onerror);
  stream.on('close', onclose);
  return function () {
    stream.removeListener('complete', onfinish);
    stream.removeListener('abort', onclose);
    stream.removeListener('request', onrequest);
    if (stream.req) stream.req.removeListener('finish', onfinish);
    stream.removeListener('end', onlegacyfinish);
    stream.removeListener('close', onlegacyfinish);
    stream.removeListener('finish', onfinish);
    stream.removeListener('end', onend);
    stream.removeListener('error', onerror);
    stream.removeListener('close', onclose);
  };
}
module.exports = eos;

/***/ }),

/***/ 4659:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
var ERR_INVALID_ARG_TYPE = (__nccwpck_require__(25500)/* .codes */ .F).ERR_INVALID_ARG_TYPE;
function from(Readable, iterable, opts) {
  var iterator;
  if (iterable && typeof iterable.next === 'function') {
    iterator = iterable;
  } else if (iterable && iterable[Symbol.asyncIterator]) iterator = iterable[Symbol.asyncIterator]();else if (iterable && iterable[Symbol.iterator]) iterator = iterable[Symbol.iterator]();else throw new ERR_INVALID_ARG_TYPE('iterable', ['Iterable'], iterable);
  var readable = new Readable(_objectSpread({
    objectMode: true
  }, opts));
  // Reading boolean to protect against _read
  // being called before last iteration completion.
  var reading = false;
  readable._read = function () {
    if (!reading) {
      reading = true;
      next();
    }
  };
  function next() {
    return _next2.apply(this, arguments);
  }
  function _next2() {
    _next2 = _asyncToGenerator(function* () {
      try {
        var _yield$iterator$next = yield iterator.next(),
          value = _yield$iterator$next.value,
          done = _yield$iterator$next.done;
        if (done) {
          readable.push(null);
        } else if (readable.push(yield value)) {
          next();
        } else {
          reading = false;
        }
      } catch (err) {
        readable.destroy(err);
      }
    });
    return _next2.apply(this, arguments);
  }
  return readable;
}
module.exports = from;


/***/ }),

/***/ 16701:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";
// Ported from https://github.com/mafintosh/pump with
// permission from the author, Mathias Buus (@mafintosh).



var eos;
function once(callback) {
  var called = false;
  return function () {
    if (called) return;
    called = true;
    callback.apply(void 0, arguments);
  };
}
var _require$codes = (__nccwpck_require__(25500)/* .codes */ .F),
  ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS,
  ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
function noop(err) {
  // Rethrow the error if it exists to avoid swallowing it
  if (err) throw err;
}
function isRequest(stream) {
  return stream.setHeader && typeof stream.abort === 'function';
}
function destroyer(stream, reading, writing, callback) {
  callback = once(callback);
  var closed = false;
  stream.on('close', function () {
    closed = true;
  });
  if (eos === undefined) eos = __nccwpck_require__(36815);
  eos(stream, {
    readable: reading,
    writable: writing
  }, function (err) {
    if (err) return callback(err);
    closed = true;
    callback();
  });
  var destroyed = false;
  return function (err) {
    if (closed) return;
    if (destroyed) return;
    destroyed = true;

    // request.destroy just do .end - .abort is what we want
    if (isRequest(stream)) return stream.abort();
    if (typeof stream.destroy === 'function') return stream.destroy();
    callback(err || new ERR_STREAM_DESTROYED('pipe'));
  };
}
function call(fn) {
  fn();
}
function pipe(from, to) {
  return from.pipe(to);
}
function popCallback(streams) {
  if (!streams.length) return noop;
  if (typeof streams[streams.length - 1] !== 'function') return noop;
  return streams.pop();
}
function pipeline() {
  for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
    streams[_key] = arguments[_key];
  }
  var callback = popCallback(streams);
  if (Array.isArray(streams[0])) streams = streams[0];
  if (streams.length < 2) {
    throw new ERR_MISSING_ARGS('streams');
  }
  var error;
  var destroys = streams.map(function (stream, i) {
    var reading = i < streams.length - 1;
    var writing = i > 0;
    return destroyer(stream, reading, writing, function (err) {
      if (!error) error = err;
      if (err) destroys.forEach(call);
      if (reading) return;
      destroys.forEach(call);
      callback(error);
    });
  });
  return streams.reduce(pipe);
}
module.exports = pipeline;

/***/ }),

/***/ 54874:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


var ERR_INVALID_OPT_VALUE = (__nccwpck_require__(25500)/* .codes */ .F).ERR_INVALID_OPT_VALUE;
function highWaterMarkFrom(options, isDuplex, duplexKey) {
  return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
}
function getHighWaterMark(state, options, duplexKey, isDuplex) {
  var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
  if (hwm != null) {
    if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
      var name = isDuplex ? duplexKey : 'highWaterMark';
      throw new ERR_INVALID_OPT_VALUE(name, hwm);
    }
    return Math.floor(hwm);
  }

  // Default value
  return state.objectMode ? 16 : 16 * 1024;
}
module.exports = {
  getHighWaterMark: getHighWaterMark
};

/***/ }),

/***/ 63283:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

module.exports = __nccwpck_require__(2203);


/***/ }),

/***/ 86131:
/***/ ((module, exports, __nccwpck_require__) => {

var Stream = __nccwpck_require__(2203);
if (process.env.READABLE_STREAM === 'disable' && Stream) {
  module.exports = Stream.Readable;
  Object.assign(module.exports, Stream);
  module.exports.Stream = Stream;
} else {
  exports = module.exports = __nccwpck_require__(86893);
  exports.Stream = Stream || exports;
  exports.Readable = exports;
  exports.Writable = __nccwpck_require__(38797);
  exports.Duplex = __nccwpck_require__(82063);
  exports.Transform = __nccwpck_require__(12337);
  exports.PassThrough = __nccwpck_require__(35283);
  exports.finished = __nccwpck_require__(36815);
  exports.pipeline = __nccwpck_require__(16701);
}


/***/ }),

/***/ 93058:
/***/ ((module, exports, __nccwpck_require__) => {

/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
/* eslint-disable node/no-deprecated-api */
var buffer = __nccwpck_require__(20181)
var Buffer = buffer.Buffer

// alternative to using Object.keys for old browsers
function copyProps (src, dst) {
  for (var key in src) {
    dst[key] = src[key]
  }
}
if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
  module.exports = buffer
} else {
  // Copy properties from require('buffer')
  copyProps(buffer, exports)
  exports.Buffer = SafeBuffer
}

function SafeBuffer (arg, encodingOrOffset, length) {
  return Buffer(arg, encodingOrOffset, length)
}

SafeBuffer.prototype = Object.create(Buffer.prototype)

// Copy static methods from Buffer
copyProps(Buffer, SafeBuffer)

SafeBuffer.from = function (arg, encodingOrOffset, length) {
  if (typeof arg === 'number') {
    throw new TypeError('Argument must not be a number')
  }
  return Buffer(arg, encodingOrOffset, length)
}

SafeBuffer.alloc = function (size, fill, encoding) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  var buf = Buffer(size)
  if (fill !== undefined) {
    if (typeof encoding === 'string') {
      buf.fill(fill, encoding)
    } else {
      buf.fill(fill)
    }
  } else {
    buf.fill(0)
  }
  return buf
}

SafeBuffer.allocUnsafe = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return Buffer(size)
}

SafeBuffer.allocUnsafeSlow = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return buffer.SlowBuffer(size)
}


/***/ }),

/***/ 37467:
/***/ ((module, exports) => {

"use strict";


const { hasOwnProperty } = Object.prototype

const stringify = configure()

// @ts-expect-error
stringify.configure = configure
// @ts-expect-error
stringify.stringify = stringify

// @ts-expect-error
stringify.default = stringify

// @ts-expect-error used for named export
exports.stringify = stringify
// @ts-expect-error used for named export
exports.configure = configure

module.exports = stringify

// eslint-disable-next-line no-control-regex
const strEscapeSequencesRegExp = /[\u0000-\u001f\u0022\u005c\ud800-\udfff]/

// Escape C0 control characters, double quotes, the backslash and every code
// unit with a numeric value in the inclusive range 0xD800 to 0xDFFF.
function strEscape (str) {
  // Some magic numbers that worked out fine while benchmarking with v8 8.0
  if (str.length < 5000 && !strEscapeSequencesRegExp.test(str)) {
    return `"${str}"`
  }
  return JSON.stringify(str)
}

function sort (array, comparator) {
  // Insertion sort is very efficient for small input sizes, but it has a bad
  // worst case complexity. Thus, use native array sort for bigger values.
  if (array.length > 2e2 || comparator) {
    return array.sort(comparator)
  }
  for (let i = 1; i < array.length; i++) {
    const currentValue = array[i]
    let position = i
    while (position !== 0 && array[position - 1] > currentValue) {
      array[position] = array[position - 1]
      position--
    }
    array[position] = currentValue
  }
  return array
}

const typedArrayPrototypeGetSymbolToStringTag =
  Object.getOwnPropertyDescriptor(
    Object.getPrototypeOf(
      Object.getPrototypeOf(
        new Int8Array()
      )
    ),
    Symbol.toStringTag
  ).get

function isTypedArrayWithEntries (value) {
  return typedArrayPrototypeGetSymbolToStringTag.call(value) !== undefined && value.length !== 0
}

function stringifyTypedArray (array, separator, maximumBreadth) {
  if (array.length < maximumBreadth) {
    maximumBreadth = array.length
  }
  const whitespace = separator === ',' ? '' : ' '
  let res = `"0":${whitespace}${array[0]}`
  for (let i = 1; i < maximumBreadth; i++) {
    res += `${separator}"${i}":${whitespace}${array[i]}`
  }
  return res
}

function getCircularValueOption (options) {
  if (hasOwnProperty.call(options, 'circularValue')) {
    const circularValue = options.circularValue
    if (typeof circularValue === 'string') {
      return `"${circularValue}"`
    }
    if (circularValue == null) {
      return circularValue
    }
    if (circularValue === Error || circularValue === TypeError) {
      return {
        toString () {
          throw new TypeError('Converting circular structure to JSON')
        }
      }
    }
    throw new TypeError('The "circularValue" argument must be of type string or the value null or undefined')
  }
  return '"[Circular]"'
}

function getDeterministicOption (options) {
  let value
  if (hasOwnProperty.call(options, 'deterministic')) {
    value = options.deterministic
    if (typeof value !== 'boolean' && typeof value !== 'function') {
      throw new TypeError('The "deterministic" argument must be of type boolean or comparator function')
    }
  }
  return value === undefined ? true : value
}

function getBooleanOption (options, key) {
  let value
  if (hasOwnProperty.call(options, key)) {
    value = options[key]
    if (typeof value !== 'boolean') {
      throw new TypeError(`The "${key}" argument must be of type boolean`)
    }
  }
  return value === undefined ? true : value
}

function getPositiveIntegerOption (options, key) {
  let value
  if (hasOwnProperty.call(options, key)) {
    value = options[key]
    if (typeof value !== 'number') {
      throw new TypeError(`The "${key}" argument must be of type number`)
    }
    if (!Number.isInteger(value)) {
      throw new TypeError(`The "${key}" argument must be an integer`)
    }
    if (value < 1) {
      throw new RangeError(`The "${key}" argument must be >= 1`)
    }
  }
  return value === undefined ? Infinity : value
}

function getItemCount (number) {
  if (number === 1) {
    return '1 item'
  }
  return `${number} items`
}

function getUniqueReplacerSet (replacerArray) {
  const replacerSet = new Set()
  for (const value of replacerArray) {
    if (typeof value === 'string' || typeof value === 'number') {
      replacerSet.add(String(value))
    }
  }
  return replacerSet
}

function getStrictOption (options) {
  if (hasOwnProperty.call(options, 'strict')) {
    const value = options.strict
    if (typeof value !== 'boolean') {
      throw new TypeError('The "strict" argument must be of type boolean')
    }
    if (value) {
      return (value) => {
        let message = `Object can not safely be stringified. Received type ${typeof value}`
        if (typeof value !== 'function') message += ` (${value.toString()})`
        throw new Error(message)
      }
    }
  }
}

function configure (options) {
  options = { ...options }
  const fail = getStrictOption(options)
  if (fail) {
    if (options.bigint === undefined) {
      options.bigint = false
    }
    if (!('circularValue' in options)) {
      options.circularValue = Error
    }
  }
  const circularValue = getCircularValueOption(options)
  const bigint = getBooleanOption(options, 'bigint')
  const deterministic = getDeterministicOption(options)
  const comparator = typeof deterministic === 'function' ? deterministic : undefined
  const maximumDepth = getPositiveIntegerOption(options, 'maximumDepth')
  const maximumBreadth = getPositiveIntegerOption(options, 'maximumBreadth')

  function stringifyFnReplacer (key, parent, stack, replacer, spacer, indentation) {
    let value = parent[key]

    if (typeof value === 'object' && value !== null && typeof value.toJSON === 'function') {
      value = value.toJSON(key)
    }
    value = replacer.call(parent, key, value)

    switch (typeof value) {
      case 'string':
        return strEscape(value)
      case 'object': {
        if (value === null) {
          return 'null'
        }
        if (stack.indexOf(value) !== -1) {
          return circularValue
        }

        let res = ''
        let join = ','
        const originalIndentation = indentation

        if (Array.isArray(value)) {
          if (value.length === 0) {
            return '[]'
          }
          if (maximumDepth < stack.length + 1) {
            return '"[Array]"'
          }
          stack.push(value)
          if (spacer !== '') {
            indentation += spacer
            res += `\n${indentation}`
            join = `,\n${indentation}`
          }
          const maximumValuesToStringify = Math.min(value.length, maximumBreadth)
          let i = 0
          for (; i < maximumValuesToStringify - 1; i++) {
            const tmp = stringifyFnReplacer(String(i), value, stack, replacer, spacer, indentation)
            res += tmp !== undefined ? tmp : 'null'
            res += join
          }
          const tmp = stringifyFnReplacer(String(i), value, stack, replacer, spacer, indentation)
          res += tmp !== undefined ? tmp : 'null'
          if (value.length - 1 > maximumBreadth) {
            const removedKeys = value.length - maximumBreadth - 1
            res += `${join}"... ${getItemCount(removedKeys)} not stringified"`
          }
          if (spacer !== '') {
            res += `\n${originalIndentation}`
          }
          stack.pop()
          return `[${res}]`
        }

        let keys = Object.keys(value)
        const keyLength = keys.length
        if (keyLength === 0) {
          return '{}'
        }
        if (maximumDepth < stack.length + 1) {
          return '"[Object]"'
        }
        let whitespace = ''
        let separator = ''
        if (spacer !== '') {
          indentation += spacer
          join = `,\n${indentation}`
          whitespace = ' '
        }
        const maximumPropertiesToStringify = Math.min(keyLength, maximumBreadth)
        if (deterministic && !isTypedArrayWithEntries(value)) {
          keys = sort(keys, comparator)
        }
        stack.push(value)
        for (let i = 0; i < maximumPropertiesToStringify; i++) {
          const key = keys[i]
          const tmp = stringifyFnReplacer(key, value, stack, replacer, spacer, indentation)
          if (tmp !== undefined) {
            res += `${separator}${strEscape(key)}:${whitespace}${tmp}`
            separator = join
          }
        }
        if (keyLength > maximumBreadth) {
          const removedKeys = keyLength - maximumBreadth
          res += `${separator}"...":${whitespace}"${getItemCount(removedKeys)} not stringified"`
          separator = join
        }
        if (spacer !== '' && separator.length > 1) {
          res = `\n${indentation}${res}\n${originalIndentation}`
        }
        stack.pop()
        return `{${res}}`
      }
      case 'number':
        return isFinite(value) ? String(value) : fail ? fail(value) : 'null'
      case 'boolean':
        return value === true ? 'true' : 'false'
      case 'undefined':
        return undefined
      case 'bigint':
        if (bigint) {
          return String(value)
        }
        // fallthrough
      default:
        return fail ? fail(value) : undefined
    }
  }

  function stringifyArrayReplacer (key, value, stack, replacer, spacer, indentation) {
    if (typeof value === 'object' && value !== null && typeof value.toJSON === 'function') {
      value = value.toJSON(key)
    }

    switch (typeof value) {
      case 'string':
        return strEscape(value)
      case 'object': {
        if (value === null) {
          return 'null'
        }
        if (stack.indexOf(value) !== -1) {
          return circularValue
        }

        const originalIndentation = indentation
        let res = ''
        let join = ','

        if (Array.isArray(value)) {
          if (value.length === 0) {
            return '[]'
          }
          if (maximumDepth < stack.length + 1) {
            return '"[Array]"'
          }
          stack.push(value)
          if (spacer !== '') {
            indentation += spacer
            res += `\n${indentation}`
            join = `,\n${indentation}`
          }
          const maximumValuesToStringify = Math.min(value.length, maximumBreadth)
          let i = 0
          for (; i < maximumValuesToStringify - 1; i++) {
            const tmp = stringifyArrayReplacer(String(i), value[i], stack, replacer, spacer, indentation)
            res += tmp !== undefined ? tmp : 'null'
            res += join
          }
          const tmp = stringifyArrayReplacer(String(i), value[i], stack, replacer, spacer, indentation)
          res += tmp !== undefined ? tmp : 'null'
          if (value.length - 1 > maximumBreadth) {
            const removedKeys = value.length - maximumBreadth - 1
            res += `${join}"... ${getItemCount(removedKeys)} not stringified"`
          }
          if (spacer !== '') {
            res += `\n${originalIndentation}`
          }
          stack.pop()
          return `[${res}]`
        }
        stack.push(value)
        let whitespace = ''
        if (spacer !== '') {
          indentation += spacer
          join = `,\n${indentation}`
          whitespace = ' '
        }
        let separator = ''
        for (const key of replacer) {
          const tmp = stringifyArrayReplacer(key, value[key], stack, replacer, spacer, indentation)
          if (tmp !== undefined) {
            res += `${separator}${strEscape(key)}:${whitespace}${tmp}`
            separator = join
          }
        }
        if (spacer !== '' && separator.length > 1) {
          res = `\n${indentation}${res}\n${originalIndentation}`
        }
        stack.pop()
        return `{${res}}`
      }
      case 'number':
        return isFinite(value) ? String(value) : fail ? fail(value) : 'null'
      case 'boolean':
        return value === true ? 'true' : 'false'
      case 'undefined':
        return undefined
      case 'bigint':
        if (bigint) {
          return String(value)
        }
        // fallthrough
      default:
        return fail ? fail(value) : undefined
    }
  }

  function stringifyIndent (key, value, stack, spacer, indentation) {
    switch (typeof value) {
      case 'string':
        return strEscape(value)
      case 'object': {
        if (value === null) {
          return 'null'
        }
        if (typeof value.toJSON === 'function') {
          value = value.toJSON(key)
          // Prevent calling `toJSON` again.
          if (typeof value !== 'object') {
            return stringifyIndent(key, value, stack, spacer, indentation)
          }
          if (value === null) {
            return 'null'
          }
        }
        if (stack.indexOf(value) !== -1) {
          return circularValue
        }
        const originalIndentation = indentation

        if (Array.isArray(value)) {
          if (value.length === 0) {
            return '[]'
          }
          if (maximumDepth < stack.length + 1) {
            return '"[Array]"'
          }
          stack.push(value)
          indentation += spacer
          let res = `\n${indentation}`
          const join = `,\n${indentation}`
          const maximumValuesToStringify = Math.min(value.length, maximumBreadth)
          let i = 0
          for (; i < maximumValuesToStringify - 1; i++) {
            const tmp = stringifyIndent(String(i), value[i], stack, spacer, indentation)
            res += tmp !== undefined ? tmp : 'null'
            res += join
          }
          const tmp = stringifyIndent(String(i), value[i], stack, spacer, indentation)
          res += tmp !== undefined ? tmp : 'null'
          if (value.length - 1 > maximumBreadth) {
            const removedKeys = value.length - maximumBreadth - 1
            res += `${join}"... ${getItemCount(removedKeys)} not stringified"`
          }
          res += `\n${originalIndentation}`
          stack.pop()
          return `[${res}]`
        }

        let keys = Object.keys(value)
        const keyLength = keys.length
        if (keyLength === 0) {
          return '{}'
        }
        if (maximumDepth < stack.length + 1) {
          return '"[Object]"'
        }
        indentation += spacer
        const join = `,\n${indentation}`
        let res = ''
        let separator = ''
        let maximumPropertiesToStringify = Math.min(keyLength, maximumBreadth)
        if (isTypedArrayWithEntries(value)) {
          res += stringifyTypedArray(value, join, maximumBreadth)
          keys = keys.slice(value.length)
          maximumPropertiesToStringify -= value.length
          separator = join
        }
        if (deterministic) {
          keys = sort(keys, comparator)
        }
        stack.push(value)
        for (let i = 0; i < maximumPropertiesToStringify; i++) {
          const key = keys[i]
          const tmp = stringifyIndent(key, value[key], stack, spacer, indentation)
          if (tmp !== undefined) {
            res += `${separator}${strEscape(key)}: ${tmp}`
            separator = join
          }
        }
        if (keyLength > maximumBreadth) {
          const removedKeys = keyLength - maximumBreadth
          res += `${separator}"...": "${getItemCount(removedKeys)} not stringified"`
          separator = join
        }
        if (separator !== '') {
          res = `\n${indentation}${res}\n${originalIndentation}`
        }
        stack.pop()
        return `{${res}}`
      }
      case 'number':
        return isFinite(value) ? String(value) : fail ? fail(value) : 'null'
      case 'boolean':
        return value === true ? 'true' : 'false'
      case 'undefined':
        return undefined
      case 'bigint':
        if (bigint) {
          return String(value)
        }
        // fallthrough
      default:
        return fail ? fail(value) : undefined
    }
  }

  function stringifySimple (key, value, stack) {
    switch (typeof value) {
      case 'string':
        return strEscape(value)
      case 'object': {
        if (value === null) {
          return 'null'
        }
        if (typeof value.toJSON === 'function') {
          value = value.toJSON(key)
          // Prevent calling `toJSON` again
          if (typeof value !== 'object') {
            return stringifySimple(key, value, stack)
          }
          if (value === null) {
            return 'null'
          }
        }
        if (stack.indexOf(value) !== -1) {
          return circularValue
        }

        let res = ''

        const hasLength = value.length !== undefined
        if (hasLength && Array.isArray(value)) {
          if (value.length === 0) {
            return '[]'
          }
          if (maximumDepth < stack.length + 1) {
            return '"[Array]"'
          }
          stack.push(value)
          const maximumValuesToStringify = Math.min(value.length, maximumBreadth)
          let i = 0
          for (; i < maximumValuesToStringify - 1; i++) {
            const tmp = stringifySimple(String(i), value[i], stack)
            res += tmp !== undefined ? tmp : 'null'
            res += ','
          }
          const tmp = stringifySimple(String(i), value[i], stack)
          res += tmp !== undefined ? tmp : 'null'
          if (value.length - 1 > maximumBreadth) {
            const removedKeys = value.length - maximumBreadth - 1
            res += `,"... ${getItemCount(removedKeys)} not stringified"`
          }
          stack.pop()
          return `[${res}]`
        }

        let keys = Object.keys(value)
        const keyLength = keys.length
        if (keyLength === 0) {
          return '{}'
        }
        if (maximumDepth < stack.length + 1) {
          return '"[Object]"'
        }
        let separator = ''
        let maximumPropertiesToStringify = Math.min(keyLength, maximumBreadth)
        if (hasLength && isTypedArrayWithEntries(value)) {
          res += stringifyTypedArray(value, ',', maximumBreadth)
          keys = keys.slice(value.length)
          maximumPropertiesToStringify -= value.length
          separator = ','
        }
        if (deterministic) {
          keys = sort(keys, comparator)
        }
        stack.push(value)
        for (let i = 0; i < maximumPropertiesToStringify; i++) {
          const key = keys[i]
          const tmp = stringifySimple(key, value[key], stack)
          if (tmp !== undefined) {
            res += `${separator}${strEscape(key)}:${tmp}`
            separator = ','
          }
        }
        if (keyLength > maximumBreadth) {
          const removedKeys = keyLength - maximumBreadth
          res += `${separator}"...":"${getItemCount(removedKeys)} not stringified"`
        }
        stack.pop()
        return `{${res}}`
      }
      case 'number':
        return isFinite(value) ? String(value) : fail ? fail(value) : 'null'
      case 'boolean':
        return value === true ? 'true' : 'false'
      case 'undefined':
        return undefined
      case 'bigint':
        if (bigint) {
          return String(value)
        }
        // fallthrough
      default:
        return fail ? fail(value) : undefined
    }
  }

  function stringify (value, replacer, space) {
    if (arguments.length > 1) {
      let spacer = ''
      if (typeof space === 'number') {
        spacer = ' '.repeat(Math.min(space, 10))
      } else if (typeof space === 'string') {
        spacer = space.slice(0, 10)
      }
      if (replacer != null) {
        if (typeof replacer === 'function') {
          return stringifyFnReplacer('', { '': value }, [], replacer, spacer, '')
        }
        if (Array.isArray(replacer)) {
          return stringifyArrayReplacer('', value, [], getUniqueReplacerSet(replacer), spacer, '')
        }
      }
      if (spacer.length !== 0) {
        return stringifyIndent('', value, [], spacer, '')
      }
    }
    return stringifySimple('', value, [])
  }

  return stringify
}


/***/ }),

/***/ 12803:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";
/* eslint-disable node/no-deprecated-api */



var buffer = __nccwpck_require__(20181)
var Buffer = buffer.Buffer

var safer = {}

var key

for (key in buffer) {
  if (!buffer.hasOwnProperty(key)) continue
  if (key === 'SlowBuffer' || key === 'Buffer') continue
  safer[key] = buffer[key]
}

var Safer = safer.Buffer = {}
for (key in Buffer) {
  if (!Buffer.hasOwnProperty(key)) continue
  if (key === 'allocUnsafe' || key === 'allocUnsafeSlow') continue
  Safer[key] = Buffer[key]
}

safer.Buffer.prototype = Buffer.prototype

if (!Safer.from || Safer.from === Uint8Array.from) {
  Safer.from = function (value, encodingOrOffset, length) {
    if (typeof value === 'number') {
      throw new TypeError('The "value" argument must not be of type number. Received type ' + typeof value)
    }
    if (value && typeof value.length === 'undefined') {
      throw new TypeError('The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type ' + typeof value)
    }
    return Buffer(value, encodingOrOffset, length)
  }
}

if (!Safer.alloc) {
  Safer.alloc = function (size, fill, encoding) {
    if (typeof size !== 'number') {
      throw new TypeError('The "size" argument must be of type number. Received type ' + typeof size)
    }
    if (size < 0 || size >= 2 * (1 << 30)) {
      throw new RangeError('The value "' + size + '" is invalid for option "size"')
    }
    var buf = Buffer(size)
    if (!fill || fill.length === 0) {
      buf.fill(0)
    } else if (typeof encoding === 'string') {
      buf.fill(fill, encoding)
    } else {
      buf.fill(fill)
    }
    return buf
  }
}

if (!safer.kStringMaxLength) {
  try {
    safer.kStringMaxLength = process.binding('buffer').kStringMaxLength
  } catch (e) {
    // we can't determine kStringMaxLength in environments where process.binding
    // is unsupported, so let's not set it
  }
}

if (!safer.constants) {
  safer.constants = {
    MAX_LENGTH: safer.kMaxLength
  }
  if (safer.kStringMaxLength) {
    safer.constants.MAX_STRING_LENGTH = safer.kStringMaxLength
  }
}

module.exports = safer


/***/ }),

/***/ 60814:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";
/*!
 * send
 * Copyright(c) 2012 TJ Holowaychuk
 * Copyright(c) 2014-2022 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module dependencies.
 * @private
 */

var createError = __nccwpck_require__(78024)
var debug = __nccwpck_require__(87500)('send')
var deprecate = __nccwpck_require__(60095)('send')
var destroy = __nccwpck_require__(32194)
var encodeUrl = __nccwpck_require__(92505)
var escapeHtml = __nccwpck_require__(12759)
var etag = __nccwpck_require__(61825)
var fresh = __nccwpck_require__(53136)
var fs = __nccwpck_require__(79896)
var mime = __nccwpck_require__(15708)
var ms = __nccwpck_require__(70744)
var onFinished = __nccwpck_require__(5698)
var parseRange = __nccwpck_require__(74031)
var path = __nccwpck_require__(16928)
var statuses = __nccwpck_require__(44650)
var Stream = __nccwpck_require__(2203)
var util = __nccwpck_require__(39023)

/**
 * Path function references.
 * @private
 */

var extname = path.extname
var join = path.join
var normalize = path.normalize
var resolve = path.resolve
var sep = path.sep

/**
 * Regular expression for identifying a bytes Range header.
 * @private
 */

var BYTES_RANGE_REGEXP = /^ *bytes=/

/**
 * Maximum value allowed for the max age.
 * @private
 */

var MAX_MAXAGE = 60 * 60 * 24 * 365 * 1000 // 1 year

/**
 * Regular expression to match a path with a directory up component.
 * @private
 */

var UP_PATH_REGEXP = /(?:^|[\\/])\.\.(?:[\\/]|$)/

/**
 * Module exports.
 * @public
 */

module.exports = send
module.exports.mime = mime

/**
 * Return a `SendStream` for `req` and `path`.
 *
 * @param {object} req
 * @param {string} path
 * @param {object} [options]
 * @return {SendStream}
 * @public
 */

function send (req, path, options) {
  return new SendStream(req, path, options)
}

/**
 * Initialize a `SendStream` with the given `path`.
 *
 * @param {Request} req
 * @param {String} path
 * @param {object} [options]
 * @private
 */

function SendStream (req, path, options) {
  Stream.call(this)

  var opts = options || {}

  this.options = opts
  this.path = path
  this.req = req

  this._acceptRanges = opts.acceptRanges !== undefined
    ? Boolean(opts.acceptRanges)
    : true

  this._cacheControl = opts.cacheControl !== undefined
    ? Boolean(opts.cacheControl)
    : true

  this._etag = opts.etag !== undefined
    ? Boolean(opts.etag)
    : true

  this._dotfiles = opts.dotfiles !== undefined
    ? opts.dotfiles
    : 'ignore'

  if (this._dotfiles !== 'ignore' && this._dotfiles !== 'allow' && this._dotfiles !== 'deny') {
    throw new TypeError('dotfiles option must be "allow", "deny", or "ignore"')
  }

  this._hidden = Boolean(opts.hidden)

  if (opts.hidden !== undefined) {
    deprecate('hidden: use dotfiles: \'' + (this._hidden ? 'allow' : 'ignore') + '\' instead')
  }

  // legacy support
  if (opts.dotfiles === undefined) {
    this._dotfiles = undefined
  }

  this._extensions = opts.extensions !== undefined
    ? normalizeList(opts.extensions, 'extensions option')
    : []

  this._immutable = opts.immutable !== undefined
    ? Boolean(opts.immutable)
    : false

  this._index = opts.index !== undefined
    ? normalizeList(opts.index, 'index option')
    : ['index.html']

  this._lastModified = opts.lastModified !== undefined
    ? Boolean(opts.lastModified)
    : true

  this._maxage = opts.maxAge || opts.maxage
  this._maxage = typeof this._maxage === 'string'
    ? ms(this._maxage)
    : Number(this._maxage)
  this._maxage = !isNaN(this._maxage)
    ? Math.min(Math.max(0, this._maxage), MAX_MAXAGE)
    : 0

  this._root = opts.root
    ? resolve(opts.root)
    : null

  if (!this._root && opts.from) {
    this.from(opts.from)
  }
}

/**
 * Inherits from `Stream`.
 */

util.inherits(SendStream, Stream)

/**
 * Enable or disable etag generation.
 *
 * @param {Boolean} val
 * @return {SendStream}
 * @api public
 */

SendStream.prototype.etag = deprecate.function(function etag (val) {
  this._etag = Boolean(val)
  debug('etag %s', this._etag)
  return this
}, 'send.etag: pass etag as option')

/**
 * Enable or disable "hidden" (dot) files.
 *
 * @param {Boolean} path
 * @return {SendStream}
 * @api public
 */

SendStream.prototype.hidden = deprecate.function(function hidden (val) {
  this._hidden = Boolean(val)
  this._dotfiles = undefined
  debug('hidden %s', this._hidden)
  return this
}, 'send.hidden: use dotfiles option')

/**
 * Set index `paths`, set to a falsy
 * value to disable index support.
 *
 * @param {String|Boolean|Array} paths
 * @return {SendStream}
 * @api public
 */

SendStream.prototype.index = deprecate.function(function index (paths) {
  var index = !paths ? [] : normalizeList(paths, 'paths argument')
  debug('index %o', paths)
  this._index = index
  return this
}, 'send.index: pass index as option')

/**
 * Set root `path`.
 *
 * @param {String} path
 * @return {SendStream}
 * @api public
 */

SendStream.prototype.root = function root (path) {
  this._root = resolve(String(path))
  debug('root %s', this._root)
  return this
}

SendStream.prototype.from = deprecate.function(SendStream.prototype.root,
  'send.from: pass root as option')

SendStream.prototype.root = deprecate.function(SendStream.prototype.root,
  'send.root: pass root as option')

/**
 * Set max-age to `maxAge`.
 *
 * @param {Number} maxAge
 * @return {SendStream}
 * @api public
 */

SendStream.prototype.maxage = deprecate.function(function maxage (maxAge) {
  this._maxage = typeof maxAge === 'string'
    ? ms(maxAge)
    : Number(maxAge)
  this._maxage = !isNaN(this._maxage)
    ? Math.min(Math.max(0, this._maxage), MAX_MAXAGE)
    : 0
  debug('max-age %d', this._maxage)
  return this
}, 'send.maxage: pass maxAge as option')

/**
 * Emit error with `status`.
 *
 * @param {number} status
 * @param {Error} [err]
 * @private
 */

SendStream.prototype.error = function error (status, err) {
  // emit if listeners instead of responding
  if (hasListeners(this, 'error')) {
    return this.emit('error', createHttpError(status, err))
  }

  var res = this.res
  var msg = statuses.message[status] || String(status)
  var doc = createHtmlDocument('Error', escapeHtml(msg))

  // clear existing headers
  clearHeaders(res)

  // add error headers
  if (err && err.headers) {
    setHeaders(res, err.headers)
  }

  // send basic response
  res.statusCode = status
  res.setHeader('Content-Type', 'text/html; charset=UTF-8')
  res.setHeader('Content-Length', Buffer.byteLength(doc))
  res.setHeader('Content-Security-Policy', "default-src 'none'")
  res.setHeader('X-Content-Type-Options', 'nosniff')
  res.end(doc)
}

/**
 * Check if the pathname ends with "/".
 *
 * @return {boolean}
 * @private
 */

SendStream.prototype.hasTrailingSlash = function hasTrailingSlash () {
  return this.path[this.path.length - 1] === '/'
}

/**
 * Check if this is a conditional GET request.
 *
 * @return {Boolean}
 * @api private
 */

SendStream.prototype.isConditionalGET = function isConditionalGET () {
  return this.req.headers['if-match'] ||
    this.req.headers['if-unmodified-since'] ||
    this.req.headers['if-none-match'] ||
    this.req.headers['if-modified-since']
}

/**
 * Check if the request preconditions failed.
 *
 * @return {boolean}
 * @private
 */

SendStream.prototype.isPreconditionFailure = function isPreconditionFailure () {
  var req = this.req
  var res = this.res

  // if-match
  var match = req.headers['if-match']
  if (match) {
    var etag = res.getHeader('ETag')
    return !etag || (match !== '*' && parseTokenList(match).every(function (match) {
      return match !== etag && match !== 'W/' + etag && 'W/' + match !== etag
    }))
  }

  // if-unmodified-since
  var unmodifiedSince = parseHttpDate(req.headers['if-unmodified-since'])
  if (!isNaN(unmodifiedSince)) {
    var lastModified = parseHttpDate(res.getHeader('Last-Modified'))
    return isNaN(lastModified) || lastModified > unmodifiedSince
  }

  return false
}

/**
 * Strip various content header fields for a change in entity.
 *
 * @private
 */

SendStream.prototype.removeContentHeaderFields = function removeContentHeaderFields () {
  var res = this.res

  res.removeHeader('Content-Encoding')
  res.removeHeader('Content-Language')
  res.removeHeader('Content-Length')
  res.removeHeader('Content-Range')
  res.removeHeader('Content-Type')
}

/**
 * Respond with 304 not modified.
 *
 * @api private
 */

SendStream.prototype.notModified = function notModified () {
  var res = this.res
  debug('not modified')
  this.removeContentHeaderFields()
  res.statusCode = 304
  res.end()
}

/**
 * Raise error that headers already sent.
 *
 * @api private
 */

SendStream.prototype.headersAlreadySent = function headersAlreadySent () {
  var err = new Error('Can\'t set headers after they are sent.')
  debug('headers already sent')
  this.error(500, err)
}

/**
 * Check if the request is cacheable, aka
 * responded with 2xx or 304 (see RFC 2616 section 14.2{5,6}).
 *
 * @return {Boolean}
 * @api private
 */

SendStream.prototype.isCachable = function isCachable () {
  var statusCode = this.res.statusCode
  return (statusCode >= 200 && statusCode < 300) ||
    statusCode === 304
}

/**
 * Handle stat() error.
 *
 * @param {Error} error
 * @private
 */

SendStream.prototype.onStatError = function onStatError (error) {
  switch (error.code) {
    case 'ENAMETOOLONG':
    case 'ENOENT':
    case 'ENOTDIR':
      this.error(404, error)
      break
    default:
      this.error(500, error)
      break
  }
}

/**
 * Check if the cache is fresh.
 *
 * @return {Boolean}
 * @api private
 */

SendStream.prototype.isFresh = function isFresh () {
  return fresh(this.req.headers, {
    etag: this.res.getHeader('ETag'),
    'last-modified': this.res.getHeader('Last-Modified')
  })
}

/**
 * Check if the range is fresh.
 *
 * @return {Boolean}
 * @api private
 */

SendStream.prototype.isRangeFresh = function isRangeFresh () {
  var ifRange = this.req.headers['if-range']

  if (!ifRange) {
    return true
  }

  // if-range as etag
  if (ifRange.indexOf('"') !== -1) {
    var etag = this.res.getHeader('ETag')
    return Boolean(etag && ifRange.indexOf(etag) !== -1)
  }

  // if-range as modified date
  var lastModified = this.res.getHeader('Last-Modified')
  return parseHttpDate(lastModified) <= parseHttpDate(ifRange)
}

/**
 * Redirect to path.
 *
 * @param {string} path
 * @private
 */

SendStream.prototype.redirect = function redirect (path) {
  var res = this.res

  if (hasListeners(this, 'directory')) {
    this.emit('directory', res, path)
    return
  }

  if (this.hasTrailingSlash()) {
    this.error(403)
    return
  }

  var loc = encodeUrl(collapseLeadingSlashes(this.path + '/'))
  var doc = createHtmlDocument('Redirecting', 'Redirecting to ' + escapeHtml(loc))

  // redirect
  res.statusCode = 301
  res.setHeader('Content-Type', 'text/html; charset=UTF-8')
  res.setHeader('Content-Length', Buffer.byteLength(doc))
  res.setHeader('Content-Security-Policy', "default-src 'none'")
  res.setHeader('X-Content-Type-Options', 'nosniff')
  res.setHeader('Location', loc)
  res.end(doc)
}

/**
 * Pipe to `res.
 *
 * @param {Stream} res
 * @return {Stream} res
 * @api public
 */

SendStream.prototype.pipe = function pipe (res) {
  // root path
  var root = this._root

  // references
  this.res = res

  // decode the path
  var path = decode(this.path)
  if (path === -1) {
    this.error(400)
    return res
  }

  // null byte(s)
  if (~path.indexOf('\0')) {
    this.error(400)
    return res
  }

  var parts
  if (root !== null) {
    // normalize
    if (path) {
      path = normalize('.' + sep + path)
    }

    // malicious path
    if (UP_PATH_REGEXP.test(path)) {
      debug('malicious path "%s"', path)
      this.error(403)
      return res
    }

    // explode path parts
    parts = path.split(sep)

    // join / normalize from optional root dir
    path = normalize(join(root, path))
  } else {
    // ".." is malicious without "root"
    if (UP_PATH_REGEXP.test(path)) {
      debug('malicious path "%s"', path)
      this.error(403)
      return res
    }

    // explode path parts
    parts = normalize(path).split(sep)

    // resolve the path
    path = resolve(path)
  }

  // dotfile handling
  if (containsDotFile(parts)) {
    var access = this._dotfiles

    // legacy support
    if (access === undefined) {
      access = parts[parts.length - 1][0] === '.'
        ? (this._hidden ? 'allow' : 'ignore')
        : 'allow'
    }

    debug('%s dotfile "%s"', access, path)
    switch (access) {
      case 'allow':
        break
      case 'deny':
        this.error(403)
        return res
      case 'ignore':
      default:
        this.error(404)
        return res
    }
  }

  // index file support
  if (this._index.length && this.hasTrailingSlash()) {
    this.sendIndex(path)
    return res
  }

  this.sendFile(path)
  return res
}

/**
 * Transfer `path`.
 *
 * @param {String} path
 * @api public
 */

SendStream.prototype.send = function send (path, stat) {
  var len = stat.size
  var options = this.options
  var opts = {}
  var res = this.res
  var req = this.req
  var ranges = req.headers.range
  var offset = options.start || 0

  if (headersSent(res)) {
    // impossible to send now
    this.headersAlreadySent()
    return
  }

  debug('pipe "%s"', path)

  // set header fields
  this.setHeader(path, stat)

  // set content-type
  this.type(path)

  // conditional GET support
  if (this.isConditionalGET()) {
    if (this.isPreconditionFailure()) {
      this.error(412)
      return
    }

    if (this.isCachable() && this.isFresh()) {
      this.notModified()
      return
    }
  }

  // adjust len to start/end options
  len = Math.max(0, len - offset)
  if (options.end !== undefined) {
    var bytes = options.end - offset + 1
    if (len > bytes) len = bytes
  }

  // Range support
  if (this._acceptRanges && BYTES_RANGE_REGEXP.test(ranges)) {
    // parse
    ranges = parseRange(len, ranges, {
      combine: true
    })

    // If-Range support
    if (!this.isRangeFresh()) {
      debug('range stale')
      ranges = -2
    }

    // unsatisfiable
    if (ranges === -1) {
      debug('range unsatisfiable')

      // Content-Range
      res.setHeader('Content-Range', contentRange('bytes', len))

      // 416 Requested Range Not Satisfiable
      return this.error(416, {
        headers: { 'Content-Range': res.getHeader('Content-Range') }
      })
    }

    // valid (syntactically invalid/multiple ranges are treated as a regular response)
    if (ranges !== -2 && ranges.length === 1) {
      debug('range %j', ranges)

      // Content-Range
      res.statusCode = 206
      res.setHeader('Content-Range', contentRange('bytes', len, ranges[0]))

      // adjust for requested range
      offset += ranges[0].start
      len = ranges[0].end - ranges[0].start + 1
    }
  }

  // clone options
  for (var prop in options) {
    opts[prop] = options[prop]
  }

  // set read options
  opts.start = offset
  opts.end = Math.max(offset, offset + len - 1)

  // content-length
  res.setHeader('Content-Length', len)

  // HEAD support
  if (req.method === 'HEAD') {
    res.end()
    return
  }

  this.stream(path, opts)
}

/**
 * Transfer file for `path`.
 *
 * @param {String} path
 * @api private
 */
SendStream.prototype.sendFile = function sendFile (path) {
  var i = 0
  var self = this

  debug('stat "%s"', path)
  fs.stat(path, function onstat (err, stat) {
    if (err && err.code === 'ENOENT' && !extname(path) && path[path.length - 1] !== sep) {
      // not found, check extensions
      return next(err)
    }
    if (err) return self.onStatError(err)
    if (stat.isDirectory()) return self.redirect(path)
    self.emit('file', path, stat)
    self.send(path, stat)
  })

  function next (err) {
    if (self._extensions.length <= i) {
      return err
        ? self.onStatError(err)
        : self.error(404)
    }

    var p = path + '.' + self._extensions[i++]

    debug('stat "%s"', p)
    fs.stat(p, function (err, stat) {
      if (err) return next(err)
      if (stat.isDirectory()) return next()
      self.emit('file', p, stat)
      self.send(p, stat)
    })
  }
}

/**
 * Transfer index for `path`.
 *
 * @param {String} path
 * @api private
 */
SendStream.prototype.sendIndex = function sendIndex (path) {
  var i = -1
  var self = this

  function next (err) {
    if (++i >= self._index.length) {
      if (err) return self.onStatError(err)
      return self.error(404)
    }

    var p = join(path, self._index[i])

    debug('stat "%s"', p)
    fs.stat(p, function (err, stat) {
      if (err) return next(err)
      if (stat.isDirectory()) return next()
      self.emit('file', p, stat)
      self.send(p, stat)
    })
  }

  next()
}

/**
 * Stream `path` to the response.
 *
 * @param {String} path
 * @param {Object} options
 * @api private
 */

SendStream.prototype.stream = function stream (path, options) {
  var self = this
  var res = this.res

  // pipe
  var stream = fs.createReadStream(path, options)
  this.emit('stream', stream)
  stream.pipe(res)

  // cleanup
  function cleanup () {
    destroy(stream, true)
  }

  // response finished, cleanup
  onFinished(res, cleanup)

  // error handling
  stream.on('error', function onerror (err) {
    // clean up stream early
    cleanup()

    // error
    self.onStatError(err)
  })

  // end
  stream.on('end', function onend () {
    self.emit('end')
  })
}

/**
 * Set content-type based on `path`
 * if it hasn't been explicitly set.
 *
 * @param {String} path
 * @api private
 */

SendStream.prototype.type = function type (path) {
  var res = this.res

  if (res.getHeader('Content-Type')) return

  var type = mime.lookup(path)

  if (!type) {
    debug('no content-type')
    return
  }

  var charset = mime.charsets.lookup(type)

  debug('content-type %s', type)
  res.setHeader('Content-Type', type + (charset ? '; charset=' + charset : ''))
}

/**
 * Set response header fields, most
 * fields may be pre-defined.
 *
 * @param {String} path
 * @param {Object} stat
 * @api private
 */

SendStream.prototype.setHeader = function setHeader (path, stat) {
  var res = this.res

  this.emit('headers', res, path, stat)

  if (this._acceptRanges && !res.getHeader('Accept-Ranges')) {
    debug('accept ranges')
    res.setHeader('Accept-Ranges', 'bytes')
  }

  if (this._cacheControl && !res.getHeader('Cache-Control')) {
    var cacheControl = 'public, max-age=' + Math.floor(this._maxage / 1000)

    if (this._immutable) {
      cacheControl += ', immutable'
    }

    debug('cache-control %s', cacheControl)
    res.setHeader('Cache-Control', cacheControl)
  }

  if (this._lastModified && !res.getHeader('Last-Modified')) {
    var modified = stat.mtime.toUTCString()
    debug('modified %s', modified)
    res.setHeader('Last-Modified', modified)
  }

  if (this._etag && !res.getHeader('ETag')) {
    var val = etag(stat)
    debug('etag %s', val)
    res.setHeader('ETag', val)
  }
}

/**
 * Clear all headers from a response.
 *
 * @param {object} res
 * @private
 */

function clearHeaders (res) {
  var headers = getHeaderNames(res)

  for (var i = 0; i < headers.length; i++) {
    res.removeHeader(headers[i])
  }
}

/**
 * Collapse all leading slashes into a single slash
 *
 * @param {string} str
 * @private
 */
function collapseLeadingSlashes (str) {
  for (var i = 0; i < str.length; i++) {
    if (str[i] !== '/') {
      break
    }
  }

  return i > 1
    ? '/' + str.substr(i)
    : str
}

/**
 * Determine if path parts contain a dotfile.
 *
 * @api private
 */

function containsDotFile (parts) {
  for (var i = 0; i < parts.length; i++) {
    var part = parts[i]
    if (part.length > 1 && part[0] === '.') {
      return true
    }
  }

  return false
}

/**
 * Create a Content-Range header.
 *
 * @param {string} type
 * @param {number} size
 * @param {array} [range]
 */

function contentRange (type, size, range) {
  return type + ' ' + (range ? range.start + '-' + range.end : '*') + '/' + size
}

/**
 * Create a minimal HTML document.
 *
 * @param {string} title
 * @param {string} body
 * @private
 */

function createHtmlDocument (title, body) {
  return '<!DOCTYPE html>\n' +
    '<html lang="en">\n' +
    '<head>\n' +
    '<meta charset="utf-8">\n' +
    '<title>' + title + '</title>\n' +
    '</head>\n' +
    '<body>\n' +
    '<pre>' + body + '</pre>\n' +
    '</body>\n' +
    '</html>\n'
}

/**
 * Create a HttpError object from simple arguments.
 *
 * @param {number} status
 * @param {Error|object} err
 * @private
 */

function createHttpError (status, err) {
  if (!err) {
    return createError(status)
  }

  return err instanceof Error
    ? createError(status, err, { expose: false })
    : createError(status, err)
}

/**
 * decodeURIComponent.
 *
 * Allows V8 to only deoptimize this fn instead of all
 * of send().
 *
 * @param {String} path
 * @api private
 */

function decode (path) {
  try {
    return decodeURIComponent(path)
  } catch (err) {
    return -1
  }
}

/**
 * Get the header names on a respnse.
 *
 * @param {object} res
 * @returns {array[string]}
 * @private
 */

function getHeaderNames (res) {
  return typeof res.getHeaderNames !== 'function'
    ? Object.keys(res._headers || {})
    : res.getHeaderNames()
}

/**
 * Determine if emitter has listeners of a given type.
 *
 * The way to do this check is done three different ways in Node.js >= 0.8
 * so this consolidates them into a minimal set using instance methods.
 *
 * @param {EventEmitter} emitter
 * @param {string} type
 * @returns {boolean}
 * @private
 */

function hasListeners (emitter, type) {
  var count = typeof emitter.listenerCount !== 'function'
    ? emitter.listeners(type).length
    : emitter.listenerCount(type)

  return count > 0
}

/**
 * Determine if the response headers have been sent.
 *
 * @param {object} res
 * @returns {boolean}
 * @private
 */

function headersSent (res) {
  return typeof res.headersSent !== 'boolean'
    ? Boolean(res._header)
    : res.headersSent
}

/**
 * Normalize the index option into an array.
 *
 * @param {boolean|string|array} val
 * @param {string} name
 * @private
 */

function normalizeList (val, name) {
  var list = [].concat(val || [])

  for (var i = 0; i < list.length; i++) {
    if (typeof list[i] !== 'string') {
      throw new TypeError(name + ' must be array of strings or false')
    }
  }

  return list
}

/**
 * Parse an HTTP Date into a number.
 *
 * @param {string} date
 * @private
 */

function parseHttpDate (date) {
  var timestamp = date && Date.parse(date)

  return typeof timestamp === 'number'
    ? timestamp
    : NaN
}

/**
 * Parse a HTTP token list.
 *
 * @param {string} str
 * @private
 */

function parseTokenList (str) {
  var end = 0
  var list = []
  var start = 0

  // gather tokens
  for (var i = 0, len = str.length; i < len; i++) {
    switch (str.charCodeAt(i)) {
      case 0x20: /*   */
        if (start === end) {
          start = end = i + 1
        }
        break
      case 0x2c: /* , */
        if (start !== end) {
          list.push(str.substring(start, end))
        }
        start = end = i + 1
        break
      default:
        end = i + 1
        break
    }
  }

  // final token
  if (start !== end) {
    list.push(str.substring(start, end))
  }

  return list
}

/**
 * Set an object of headers on a response.
 *
 * @param {object} res
 * @param {object} headers
 * @private
 */

function setHeaders (res, headers) {
  var keys = Object.keys(headers)

  for (var i = 0; i < keys.length; i++) {
    var key = keys[i]
    res.setHeader(key, headers[key])
  }
}


/***/ }),

/***/ 24697:
/***/ ((module) => {

/**
 * Helpers.
 */

var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var y = d * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */

module.exports = function(val, options) {
  options = options || {};
  var type = typeof val;
  if (type === 'string' && val.length > 0) {
    return parse(val);
  } else if (type === 'number' && isNaN(val) === false) {
    return options.long ? fmtLong(val) : fmtShort(val);
  }
  throw new Error(
    'val is not a non-empty string or a valid number. val=' +
      JSON.stringify(val)
  );
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  str = String(str);
  if (str.length > 100) {
    return;
  }
  var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(
    str
  );
  if (!match) {
    return;
  }
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;
    case 'days':
    case 'day':
    case 'd':
      return n * d;
    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h;
    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m;
    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s;
    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;
    default:
      return undefined;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtShort(ms) {
  if (ms >= d) {
    return Math.round(ms / d) + 'd';
  }
  if (ms >= h) {
    return Math.round(ms / h) + 'h';
  }
  if (ms >= m) {
    return Math.round(ms / m) + 'm';
  }
  if (ms >= s) {
    return Math.round(ms / s) + 's';
  }
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtLong(ms) {
  return plural(ms, d, 'day') ||
    plural(ms, h, 'hour') ||
    plural(ms, m, 'minute') ||
    plural(ms, s, 'second') ||
    ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural(ms, n, name) {
  if (ms < n) {
    return;
  }
  if (ms < n * 1.5) {
    return Math.floor(ms / n) + ' ' + name;
  }
  return Math.ceil(ms / n) + ' ' + name + 's';
}


/***/ }),

/***/ 22936:
/***/ ((module, exports, __nccwpck_require__) => {

/**
 * This is the web browser implementation of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = __nccwpck_require__(75955);
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = 'undefined' != typeof chrome
               && 'undefined' != typeof chrome.storage
                  ? chrome.storage.local
                  : localstorage();

/**
 * Colors.
 */

exports.colors = [
  'lightseagreen',
  'forestgreen',
  'goldenrod',
  'dodgerblue',
  'darkorchid',
  'crimson'
];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

function useColors() {
  // NB: In an Electron preload script, document will be defined but not fully
  // initialized. Since we know we're in Chrome, we'll just detect this case
  // explicitly
  if (typeof window !== 'undefined' && window.process && window.process.type === 'renderer') {
    return true;
  }

  // is webkit? http://stackoverflow.com/a/16459606/376773
  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
  return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||
    // is firebug? http://stackoverflow.com/a/398120/376773
    (typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||
    // is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||
    // double check webkit in userAgent just in case we are in a worker
    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/));
}

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

exports.formatters.j = function(v) {
  try {
    return JSON.stringify(v);
  } catch (err) {
    return '[UnexpectedJSONParseError]: ' + err.message;
  }
};


/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs(args) {
  var useColors = this.useColors;

  args[0] = (useColors ? '%c' : '')
    + this.namespace
    + (useColors ? ' %c' : ' ')
    + args[0]
    + (useColors ? '%c ' : ' ')
    + '+' + exports.humanize(this.diff);

  if (!useColors) return;

  var c = 'color: ' + this.color;
  args.splice(1, 0, c, 'color: inherit')

  // the final "%c" is somewhat tricky, because there could be other
  // arguments passed either before or after the %c, so we need to
  // figure out the correct index to insert the CSS into
  var index = 0;
  var lastC = 0;
  args[0].replace(/%[a-zA-Z%]/g, function(match) {
    if ('%%' === match) return;
    index++;
    if ('%c' === match) {
      // we only are interested in the *last* %c
      // (the user may have provided their own)
      lastC = index;
    }
  });

  args.splice(lastC, 0, c);
}

/**
 * Invokes `console.log()` when available.
 * No-op when `console.log` is not a "function".
 *
 * @api public
 */

function log() {
  // this hackery is required for IE8/9, where
  // the `console.log` function doesn't have 'apply'
  return 'object' === typeof console
    && console.log
    && Function.prototype.apply.call(console.log, console, arguments);
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */

function save(namespaces) {
  try {
    if (null == namespaces) {
      exports.storage.removeItem('debug');
    } else {
      exports.storage.debug = namespaces;
    }
  } catch(e) {}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

function load() {
  var r;
  try {
    r = exports.storage.debug;
  } catch(e) {}

  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG
  if (!r && typeof process !== 'undefined' && 'env' in process) {
    r = process.env.DEBUG;
  }

  return r;
}

/**
 * Enable namespaces listed in `localStorage.debug` initially.
 */

exports.enable(load());

/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */

function localstorage() {
  try {
    return window.localStorage;
  } catch (e) {}
}


/***/ }),

/***/ 75955:
/***/ ((module, exports, __nccwpck_require__) => {


/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = createDebug.debug = createDebug['default'] = createDebug;
exports.coerce = coerce;
exports.disable = disable;
exports.enable = enable;
exports.enabled = enabled;
exports.humanize = __nccwpck_require__(24697);

/**
 * The currently active debug mode names, and names to skip.
 */

exports.names = [];
exports.skips = [];

/**
 * Map of special "%n" handling functions, for the debug "format" argument.
 *
 * Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
 */

exports.formatters = {};

/**
 * Previous log timestamp.
 */

var prevTime;

/**
 * Select a color.
 * @param {String} namespace
 * @return {Number}
 * @api private
 */

function selectColor(namespace) {
  var hash = 0, i;

  for (i in namespace) {
    hash  = ((hash << 5) - hash) + namespace.charCodeAt(i);
    hash |= 0; // Convert to 32bit integer
  }

  return exports.colors[Math.abs(hash) % exports.colors.length];
}

/**
 * Create a debugger with the given `namespace`.
 *
 * @param {String} namespace
 * @return {Function}
 * @api public
 */

function createDebug(namespace) {

  function debug() {
    // disabled?
    if (!debug.enabled) return;

    var self = debug;

    // set `diff` timestamp
    var curr = +new Date();
    var ms = curr - (prevTime || curr);
    self.diff = ms;
    self.prev = prevTime;
    self.curr = curr;
    prevTime = curr;

    // turn the `arguments` into a proper Array
    var args = new Array(arguments.length);
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i];
    }

    args[0] = exports.coerce(args[0]);

    if ('string' !== typeof args[0]) {
      // anything else let's inspect with %O
      args.unshift('%O');
    }

    // apply any `formatters` transformations
    var index = 0;
    args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {
      // if we encounter an escaped % then don't increase the array index
      if (match === '%%') return match;
      index++;
      var formatter = exports.formatters[format];
      if ('function' === typeof formatter) {
        var val = args[index];
        match = formatter.call(self, val);

        // now we need to remove `args[index]` since it's inlined in the `format`
        args.splice(index, 1);
        index--;
      }
      return match;
    });

    // apply env-specific formatting (colors, etc.)
    exports.formatArgs.call(self, args);

    var logFn = debug.log || exports.log || console.log.bind(console);
    logFn.apply(self, args);
  }

  debug.namespace = namespace;
  debug.enabled = exports.enabled(namespace);
  debug.useColors = exports.useColors();
  debug.color = selectColor(namespace);

  // env-specific initialization logic for debug instances
  if ('function' === typeof exports.init) {
    exports.init(debug);
  }

  return debug;
}

/**
 * Enables a debug mode by namespaces. This can include modes
 * separated by a colon and wildcards.
 *
 * @param {String} namespaces
 * @api public
 */

function enable(namespaces) {
  exports.save(namespaces);

  exports.names = [];
  exports.skips = [];

  var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
  var len = split.length;

  for (var i = 0; i < len; i++) {
    if (!split[i]) continue; // ignore empty strings
    namespaces = split[i].replace(/\*/g, '.*?');
    if (namespaces[0] === '-') {
      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
    } else {
      exports.names.push(new RegExp('^' + namespaces + '$'));
    }
  }
}

/**
 * Disable debug output.
 *
 * @api public
 */

function disable() {
  exports.enable('');
}

/**
 * Returns true if the given mode name is enabled, false otherwise.
 *
 * @param {String} name
 * @return {Boolean}
 * @api public
 */

function enabled(name) {
  var i, len;
  for (i = 0, len = exports.skips.length; i < len; i++) {
    if (exports.skips[i].test(name)) {
      return false;
    }
  }
  for (i = 0, len = exports.names.length; i < len; i++) {
    if (exports.names[i].test(name)) {
      return true;
    }
  }
  return false;
}

/**
 * Coerce `val`.
 *
 * @param {Mixed} val
 * @return {Mixed}
 * @api private
 */

function coerce(val) {
  if (val instanceof Error) return val.stack || val.message;
  return val;
}


/***/ }),

/***/ 87500:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

/**
 * Detect Electron renderer process, which is node, but we should
 * treat as a browser.
 */

if (typeof process !== 'undefined' && process.type === 'renderer') {
  module.exports = __nccwpck_require__(22936);
} else {
  module.exports = __nccwpck_require__(39098);
}


/***/ }),

/***/ 39098:
/***/ ((module, exports, __nccwpck_require__) => {

/**
 * Module dependencies.
 */

var tty = __nccwpck_require__(52018);
var util = __nccwpck_require__(39023);

/**
 * This is the Node.js implementation of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = __nccwpck_require__(75955);
exports.init = init;
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;

/**
 * Colors.
 */

exports.colors = [6, 2, 3, 4, 5, 1];

/**
 * Build up the default `inspectOpts` object from the environment variables.
 *
 *   $ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js
 */

exports.inspectOpts = Object.keys(process.env).filter(function (key) {
  return /^debug_/i.test(key);
}).reduce(function (obj, key) {
  // camel-case
  var prop = key
    .substring(6)
    .toLowerCase()
    .replace(/_([a-z])/g, function (_, k) { return k.toUpperCase() });

  // coerce string value into JS value
  var val = process.env[key];
  if (/^(yes|on|true|enabled)$/i.test(val)) val = true;
  else if (/^(no|off|false|disabled)$/i.test(val)) val = false;
  else if (val === 'null') val = null;
  else val = Number(val);

  obj[prop] = val;
  return obj;
}, {});

/**
 * The file descriptor to write the `debug()` calls to.
 * Set the `DEBUG_FD` env variable to override with another value. i.e.:
 *
 *   $ DEBUG_FD=3 node script.js 3>debug.log
 */

var fd = parseInt(process.env.DEBUG_FD, 10) || 2;

if (1 !== fd && 2 !== fd) {
  util.deprecate(function(){}, 'except for stderr(2) and stdout(1), any other usage of DEBUG_FD is deprecated. Override debug.log if you want to use a different log function (https://git.io/debug_fd)')()
}

var stream = 1 === fd ? process.stdout :
             2 === fd ? process.stderr :
             createWritableStdioStream(fd);

/**
 * Is stdout a TTY? Colored output is enabled when `true`.
 */

function useColors() {
  return 'colors' in exports.inspectOpts
    ? Boolean(exports.inspectOpts.colors)
    : tty.isatty(fd);
}

/**
 * Map %o to `util.inspect()`, all on a single line.
 */

exports.formatters.o = function(v) {
  this.inspectOpts.colors = this.useColors;
  return util.inspect(v, this.inspectOpts)
    .split('\n').map(function(str) {
      return str.trim()
    }).join(' ');
};

/**
 * Map %o to `util.inspect()`, allowing multiple lines if needed.
 */

exports.formatters.O = function(v) {
  this.inspectOpts.colors = this.useColors;
  return util.inspect(v, this.inspectOpts);
};

/**
 * Adds ANSI color escape codes if enabled.
 *
 * @api public
 */

function formatArgs(args) {
  var name = this.namespace;
  var useColors = this.useColors;

  if (useColors) {
    var c = this.color;
    var prefix = '  \u001b[3' + c + ';1m' + name + ' ' + '\u001b[0m';

    args[0] = prefix + args[0].split('\n').join('\n' + prefix);
    args.push('\u001b[3' + c + 'm+' + exports.humanize(this.diff) + '\u001b[0m');
  } else {
    args[0] = new Date().toUTCString()
      + ' ' + name + ' ' + args[0];
  }
}

/**
 * Invokes `util.format()` with the specified arguments and writes to `stream`.
 */

function log() {
  return stream.write(util.format.apply(util, arguments) + '\n');
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */

function save(namespaces) {
  if (null == namespaces) {
    // If you set a process.env field to null or undefined, it gets cast to the
    // string 'null' or 'undefined'. Just delete instead.
    delete process.env.DEBUG;
  } else {
    process.env.DEBUG = namespaces;
  }
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

function load() {
  return process.env.DEBUG;
}

/**
 * Copied from `node/src/node.js`.
 *
 * XXX: It's lame that node doesn't expose this API out-of-the-box. It also
 * relies on the undocumented `tty_wrap.guessHandleType()` which is also lame.
 */

function createWritableStdioStream (fd) {
  var stream;
  var tty_wrap = process.binding('tty_wrap');

  // Note stream._type is used for test-module-load-list.js

  switch (tty_wrap.guessHandleType(fd)) {
    case 'TTY':
      stream = new tty.WriteStream(fd);
      stream._type = 'tty';

      // Hack to have stream not keep the event loop alive.
      // See https://github.com/joyent/node/issues/1726
      if (stream._handle && stream._handle.unref) {
        stream._handle.unref();
      }
      break;

    case 'FILE':
      var fs = __nccwpck_require__(79896);
      stream = new fs.SyncWriteStream(fd, { autoClose: false });
      stream._type = 'fs';
      break;

    case 'PIPE':
    case 'TCP':
      var net = __nccwpck_require__(69278);
      stream = new net.Socket({
        fd: fd,
        readable: false,
        writable: true
      });

      // FIXME Should probably have an option in net.Socket to create a
      // stream from an existing fd which is writable only. But for now
      // we'll just add this hack and set the `readable` member to false.
      // Test: ./node test/fixtures/echo.js < /etc/passwd
      stream.readable = false;
      stream.read = null;
      stream._type = 'pipe';

      // FIXME Hack to have stream not keep the event loop alive.
      // See https://github.com/joyent/node/issues/1726
      if (stream._handle && stream._handle.unref) {
        stream._handle.unref();
      }
      break;

    default:
      // Probably an error on in uv_guess_handle()
      throw new Error('Implement me. Unknown stream file type!');
  }

  // For supporting legacy API we put the FD here.
  stream.fd = fd;

  stream._isStdio = true;

  return stream;
}

/**
 * Init logic for `debug` instances.
 *
 * Create a new `inspectOpts` object in case `useColors` is set
 * differently for a particular `debug` instance.
 */

function init (debug) {
  debug.inspectOpts = {};

  var keys = Object.keys(exports.inspectOpts);
  for (var i = 0; i < keys.length; i++) {
    debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
  }
}

/**
 * Enable namespaces listed in `process.env.DEBUG` initially.
 */

exports.enable(load());


/***/ }),

/***/ 92505:
/***/ ((module) => {

"use strict";
/*!
 * encodeurl
 * Copyright(c) 2016 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module exports.
 * @public
 */

module.exports = encodeUrl

/**
 * RegExp to match non-URL code points, *after* encoding (i.e. not including "%")
 * and including invalid escape sequences.
 * @private
 */

var ENCODE_CHARS_REGEXP = /(?:[^\x21\x25\x26-\x3B\x3D\x3F-\x5B\x5D\x5F\x61-\x7A\x7E]|%(?:[^0-9A-Fa-f]|[0-9A-Fa-f][^0-9A-Fa-f]|$))+/g

/**
 * RegExp to match unmatched surrogate pair.
 * @private
 */

var UNMATCHED_SURROGATE_PAIR_REGEXP = /(^|[^\uD800-\uDBFF])[\uDC00-\uDFFF]|[\uD800-\uDBFF]([^\uDC00-\uDFFF]|$)/g

/**
 * String to replace unmatched surrogate pair with.
 * @private
 */

var UNMATCHED_SURROGATE_PAIR_REPLACE = '$1\uFFFD$2'

/**
 * Encode a URL to a percent-encoded form, excluding already-encoded sequences.
 *
 * This function will take an already-encoded URL and encode all the non-URL
 * code points. This function will not encode the "%" character unless it is
 * not part of a valid sequence (`%20` will be left as-is, but `%foo` will
 * be encoded as `%25foo`).
 *
 * This encode is meant to be "safe" and does not throw errors. It will try as
 * hard as it can to properly encode the given URL, including replacing any raw,
 * unpaired surrogate pairs with the Unicode replacement character prior to
 * encoding.
 *
 * @param {string} url
 * @return {string}
 * @public
 */

function encodeUrl (url) {
  return String(url)
    .replace(UNMATCHED_SURROGATE_PAIR_REGEXP, UNMATCHED_SURROGATE_PAIR_REPLACE)
    .replace(ENCODE_CHARS_REGEXP, encodeURI)
}


/***/ }),

/***/ 15708:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var path = __nccwpck_require__(16928);
var fs = __nccwpck_require__(79896);

function Mime() {
  // Map of extension -> mime type
  this.types = Object.create(null);

  // Map of mime type -> extension
  this.extensions = Object.create(null);
}

/**
 * Define mimetype -> extension mappings.  Each key is a mime-type that maps
 * to an array of extensions associated with the type.  The first extension is
 * used as the default extension for the type.
 *
 * e.g. mime.define({'audio/ogg', ['oga', 'ogg', 'spx']});
 *
 * @param map (Object) type definitions
 */
Mime.prototype.define = function (map) {
  for (var type in map) {
    var exts = map[type];
    for (var i = 0; i < exts.length; i++) {
      if (process.env.DEBUG_MIME && this.types[exts[i]]) {
        console.warn((this._loading || "define()").replace(/.*\//, ''), 'changes "' + exts[i] + '" extension type from ' +
          this.types[exts[i]] + ' to ' + type);
      }

      this.types[exts[i]] = type;
    }

    // Default extension is the first one we encounter
    if (!this.extensions[type]) {
      this.extensions[type] = exts[0];
    }
  }
};

/**
 * Load an Apache2-style ".types" file
 *
 * This may be called multiple times (it's expected).  Where files declare
 * overlapping types/extensions, the last file wins.
 *
 * @param file (String) path of file to load.
 */
Mime.prototype.load = function(file) {
  this._loading = file;
  // Read file and split into lines
  var map = {},
      content = fs.readFileSync(file, 'ascii'),
      lines = content.split(/[\r\n]+/);

  lines.forEach(function(line) {
    // Clean up whitespace/comments, and split into fields
    var fields = line.replace(/\s*#.*|^\s*|\s*$/g, '').split(/\s+/);
    map[fields.shift()] = fields;
  });

  this.define(map);

  this._loading = null;
};

/**
 * Lookup a mime type based on extension
 */
Mime.prototype.lookup = function(path, fallback) {
  var ext = path.replace(/^.*[\.\/\\]/, '').toLowerCase();

  return this.types[ext] || fallback || this.default_type;
};

/**
 * Return file extension associated with a mime type
 */
Mime.prototype.extension = function(mimeType) {
  var type = mimeType.match(/^\s*([^;\s]*)(?:;|\s|$)/)[1].toLowerCase();
  return this.extensions[type];
};

// Default instance
var mime = new Mime();

// Define built-in types
mime.define(__nccwpck_require__(59593));

// Default type
mime.default_type = mime.lookup('bin');

//
// Additional API specific to the default instance
//

mime.Mime = Mime;

/**
 * Lookup a charset based on mime type.
 */
mime.charsets = {
  lookup: function(mimeType, fallback) {
    // Assume text types are utf8
    return (/^text\/|^application\/(javascript|json)/).test(mimeType) ? 'UTF-8' : fallback;
  }
};

module.exports = mime;


/***/ }),

/***/ 99221:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

module.exports = __nccwpck_require__(62068);

/***/ }),

/***/ 62068:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var EventEmitter = (__nccwpck_require__(24434).EventEmitter);
var util = __nccwpck_require__(39023);

var DEFAULT_TIMEOUT = 3000;
var INIT_ID = 0;
var EVENT_CLOSED = 'closed';
var EVENT_DRAINED = 'drained';

/**
 * Instance a new queue
 *
 * @param {Number} timeout a global timeout for new queue
 * @class
 * @constructor
 */
var SeqQueue = function(timeout) {
	EventEmitter.call(this);
	
	if(timeout && timeout > 0) {
		this.timeout = timeout;
	} else {
		this.timeout = DEFAULT_TIMEOUT;
	}
	
	this.status = SeqQueueManager.STATUS_IDLE;
	this.curId = INIT_ID;
	this.queue = [];
};
util.inherits(SeqQueue, EventEmitter);

/**
 * Add a task into queue.
 * 
 * @param fn new request
 * @param ontimeout callback when task timeout
 * @param timeout timeout for current request. take the global timeout if this is invalid
 * @returns true or false
 */
SeqQueue.prototype.push = function(fn, ontimeout, timeout) {
	if(this.status !== SeqQueueManager.STATUS_IDLE && this.status !== SeqQueueManager.STATUS_BUSY) {
		//ignore invalid status
		return false;
	}
	
	if(typeof fn !== 'function') {
		throw new Error('fn should be a function.');
	}
	this.queue.push({fn: fn, ontimeout: ontimeout, timeout: timeout});

	if(this.status === SeqQueueManager.STATUS_IDLE) {
		this.status = SeqQueueManager.STATUS_BUSY;
		var self = this;
		process.nextTick(function() {
			self._next(self.curId);
		});
	}
	return true;
};

/**
 * Close queue
 * 
 * @param {Boolean} force if true will close the queue immediately else will execute the rest task in queue
 */
SeqQueue.prototype.close = function(force) {
	if(this.status !== SeqQueueManager.STATUS_IDLE && this.status !== SeqQueueManager.STATUS_BUSY) {
		//ignore invalid status
		return;
	}
	
	if(force) {
		this.status = SeqQueueManager.STATUS_DRAINED;
		if(this.timerId) {
			clearTimeout(this.timerId);
			this.timerId = undefined;
		}
		this.emit(EVENT_DRAINED);
	} else {
		this.status = SeqQueueManager.STATUS_CLOSED;
		this.emit(EVENT_CLOSED);
	}
};

/**
 * Invoke next task
 * 
 * @param {String|Number} tid last executed task id
 * @api private
 */
SeqQueue.prototype._next = function(tid) {
	if(tid !== this.curId || this.status !== SeqQueueManager.STATUS_BUSY && this.status !== SeqQueueManager.STATUS_CLOSED) {
		//ignore invalid next call
		return;
	}
	
	if(this.timerId) {
		clearTimeout(this.timerId);
		this.timerId = undefined;
	}
	
	var task = this.queue.shift();
	if(!task) {
		if(this.status === SeqQueueManager.STATUS_BUSY) {
			this.status = SeqQueueManager.STATUS_IDLE;
			this.curId++;	//modify curId to invalidate timeout task
		} else {
			this.status = SeqQueueManager.STATUS_DRAINED;
			this.emit(EVENT_DRAINED);
		}
		return;
	}
	
	var self = this;
	task.id = ++this.curId;

	var timeout = task.timeout > 0 ? task.timeout : this.timeout;
	timeout = timeout > 0 ? timeout : DEFAULT_TIMEOUT;
	this.timerId = setTimeout(function() {
		process.nextTick(function() {
			self._next(task.id);
		});
		self.emit('timeout', task);
		if(task.ontimeout) {
			task.ontimeout();
		}
	}, timeout);

	try {
		task.fn({
			done: function() {
				var res = task.id === self.curId;
				process.nextTick(function() {
					self._next(task.id);
				});
				return res;
			}
		});
	} catch(err) {
		self.emit('error', err, task);
		process.nextTick(function() {
			self._next(task.id);
		});
	}
};

/**
 * Queue manager.
 * 
 * @module
 */
var SeqQueueManager = module.exports;

/**
 * Queue status: idle, welcome new tasks
 *
 * @const
 * @type {Number}
 * @memberOf SeqQueueManager
 */
SeqQueueManager.STATUS_IDLE = 0;

/**
 * Queue status: busy, queue is working for some tasks now
 *
 * @const
 * @type {Number}
 * @memberOf SeqQueueManager
 */
SeqQueueManager.STATUS_BUSY = 1;

/**
 * Queue status: closed, queue has closed and would not receive task any more 
 * 					and is processing the remaining tasks now.
 *
 * @const
 * @type {Number}
 * @memberOf SeqQueueManager
 */
SeqQueueManager.STATUS_CLOSED = 2; 

/**
 * Queue status: drained, queue is ready to be destroy
 *
 * @const
 * @type {Number}
 * @memberOf SeqQueueManager
 */
SeqQueueManager.STATUS_DRAINED = 3;

/**
 * Create Sequence queue
 * 
 * @param  {Number} timeout a global timeout for the new queue instance
 * @return {Object}         new queue instance
 * @memberOf SeqQueueManager
 */
SeqQueueManager.createQueue = function(timeout) {
	return new SeqQueue(timeout);
};

/***/ }),

/***/ 96004:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";
/*!
 * serve-static
 * Copyright(c) 2010 Sencha Inc.
 * Copyright(c) 2011 TJ Holowaychuk
 * Copyright(c) 2014-2016 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module dependencies.
 * @private
 */

var encodeUrl = __nccwpck_require__(83835)
var escapeHtml = __nccwpck_require__(12759)
var parseUrl = __nccwpck_require__(83404)
var resolve = (__nccwpck_require__(16928).resolve)
var send = __nccwpck_require__(60814)
var url = __nccwpck_require__(87016)

/**
 * Module exports.
 * @public
 */

module.exports = serveStatic
module.exports.mime = send.mime

/**
 * @param {string} root
 * @param {object} [options]
 * @return {function}
 * @public
 */

function serveStatic (root, options) {
  if (!root) {
    throw new TypeError('root path required')
  }

  if (typeof root !== 'string') {
    throw new TypeError('root path must be a string')
  }

  // copy options object
  var opts = Object.create(options || null)

  // fall-though
  var fallthrough = opts.fallthrough !== false

  // default redirect
  var redirect = opts.redirect !== false

  // headers listener
  var setHeaders = opts.setHeaders

  if (setHeaders && typeof setHeaders !== 'function') {
    throw new TypeError('option setHeaders must be function')
  }

  // setup options for send
  opts.maxage = opts.maxage || opts.maxAge || 0
  opts.root = resolve(root)

  // construct directory listener
  var onDirectory = redirect
    ? createRedirectDirectoryListener()
    : createNotFoundDirectoryListener()

  return function serveStatic (req, res, next) {
    if (req.method !== 'GET' && req.method !== 'HEAD') {
      if (fallthrough) {
        return next()
      }

      // method not allowed
      res.statusCode = 405
      res.setHeader('Allow', 'GET, HEAD')
      res.setHeader('Content-Length', '0')
      res.end()
      return
    }

    var forwardError = !fallthrough
    var originalUrl = parseUrl.original(req)
    var path = parseUrl(req).pathname

    // make sure redirect occurs at mount
    if (path === '/' && originalUrl.pathname.substr(-1) !== '/') {
      path = ''
    }

    // create send stream
    var stream = send(req, path, opts)

    // add directory handler
    stream.on('directory', onDirectory)

    // add headers listener
    if (setHeaders) {
      stream.on('headers', setHeaders)
    }

    // add file listener for fallthrough
    if (fallthrough) {
      stream.on('file', function onFile () {
        // once file is determined, always forward error
        forwardError = true
      })
    }

    // forward errors
    stream.on('error', function error (err) {
      if (forwardError || !(err.statusCode < 500)) {
        next(err)
        return
      }

      next()
    })

    // pipe
    stream.pipe(res)
  }
}

/**
 * Collapse all leading slashes into a single slash
 * @private
 */
function collapseLeadingSlashes (str) {
  for (var i = 0; i < str.length; i++) {
    if (str.charCodeAt(i) !== 0x2f /* / */) {
      break
    }
  }

  return i > 1
    ? '/' + str.substr(i)
    : str
}

/**
 * Create a minimal HTML document.
 *
 * @param {string} title
 * @param {string} body
 * @private
 */

function createHtmlDocument (title, body) {
  return '<!DOCTYPE html>\n' +
    '<html lang="en">\n' +
    '<head>\n' +
    '<meta charset="utf-8">\n' +
    '<title>' + title + '</title>\n' +
    '</head>\n' +
    '<body>\n' +
    '<pre>' + body + '</pre>\n' +
    '</body>\n' +
    '</html>\n'
}

/**
 * Create a directory listener that just 404s.
 * @private
 */

function createNotFoundDirectoryListener () {
  return function notFound () {
    this.error(404)
  }
}

/**
 * Create a directory listener that performs a redirect.
 * @private
 */

function createRedirectDirectoryListener () {
  return function redirect (res) {
    if (this.hasTrailingSlash()) {
      this.error(404)
      return
    }

    // get original URL
    var originalUrl = parseUrl.original(this.req)

    // append trailing slash
    originalUrl.path = null
    originalUrl.pathname = collapseLeadingSlashes(originalUrl.pathname + '/')

    // reformat the URL
    var loc = encodeUrl(url.format(originalUrl))
    var doc = createHtmlDocument('Redirecting', 'Redirecting to ' + escapeHtml(loc))

    // send redirect response
    res.statusCode = 301
    res.setHeader('Content-Type', 'text/html; charset=UTF-8')
    res.setHeader('Content-Length', Buffer.byteLength(doc))
    res.setHeader('Content-Security-Policy', "default-src 'none'")
    res.setHeader('X-Content-Type-Options', 'nosniff')
    res.setHeader('Location', loc)
    res.end(doc)
  }
}


/***/ }),

/***/ 41015:
/***/ ((module) => {

"use strict";

/* eslint no-proto: 0 */
module.exports = Object.setPrototypeOf || ({ __proto__: [] } instanceof Array ? setProtoOf : mixinProperties)

function setProtoOf (obj, proto) {
  obj.__proto__ = proto
  return obj
}

function mixinProperties (obj, proto) {
  for (var prop in proto) {
    if (!Object.prototype.hasOwnProperty.call(obj, prop)) {
      obj[prop] = proto[prop]
    }
  }
  return obj
}


/***/ }),

/***/ 8948:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


var inspect = __nccwpck_require__(60506);

var $TypeError = __nccwpck_require__(73314);

/*
* This function traverses the list returning the node corresponding to the given key.
*
* That node is also moved to the head of the list, so that if it's accessed again we don't need to traverse the whole list.
* By doing so, all the recently used nodes can be accessed relatively quickly.
*/
/** @type {import('./list.d.ts').listGetNode} */
// eslint-disable-next-line consistent-return
var listGetNode = function (list, key, isDelete) {
	/** @type {typeof list | NonNullable<(typeof list)['next']>} */
	var prev = list;
	/** @type {(typeof list)['next']} */
	var curr;
	// eslint-disable-next-line eqeqeq
	for (; (curr = prev.next) != null; prev = curr) {
		if (curr.key === key) {
			prev.next = curr.next;
			if (!isDelete) {
				// eslint-disable-next-line no-extra-parens
				curr.next = /** @type {NonNullable<typeof list.next>} */ (list.next);
				list.next = curr; // eslint-disable-line no-param-reassign
			}
			return curr;
		}
	}
};

/** @type {import('./list.d.ts').listGet} */
var listGet = function (objects, key) {
	if (!objects) {
		return void undefined;
	}
	var node = listGetNode(objects, key);
	return node && node.value;
};
/** @type {import('./list.d.ts').listSet} */
var listSet = function (objects, key, value) {
	var node = listGetNode(objects, key);
	if (node) {
		node.value = value;
	} else {
		// Prepend the new node to the beginning of the list
		objects.next = /** @type {import('./list.d.ts').ListNode<typeof value, typeof key>} */ ({ // eslint-disable-line no-param-reassign, no-extra-parens
			key: key,
			next: objects.next,
			value: value
		});
	}
};
/** @type {import('./list.d.ts').listHas} */
var listHas = function (objects, key) {
	if (!objects) {
		return false;
	}
	return !!listGetNode(objects, key);
};
/** @type {import('./list.d.ts').listDelete} */
// eslint-disable-next-line consistent-return
var listDelete = function (objects, key) {
	if (objects) {
		return listGetNode(objects, key, true);
	}
};

/** @type {import('.')} */
module.exports = function getSideChannelList() {
	/** @typedef {ReturnType<typeof getSideChannelList>} Channel */
	/** @typedef {Parameters<Channel['get']>[0]} K */
	/** @typedef {Parameters<Channel['set']>[1]} V */

	/** @type {import('./list.d.ts').RootNode<V, K> | undefined} */ var $o;

	/** @type {Channel} */
	var channel = {
		assert: function (key) {
			if (!channel.has(key)) {
				throw new $TypeError('Side channel does not contain ' + inspect(key));
			}
		},
		'delete': function (key) {
			var root = $o && $o.next;
			var deletedNode = listDelete($o, key);
			if (deletedNode && root && root === deletedNode) {
				$o = void undefined;
			}
			return !!deletedNode;
		},
		get: function (key) {
			return listGet($o, key);
		},
		has: function (key) {
			return listHas($o, key);
		},
		set: function (key, value) {
			if (!$o) {
				// Initialize the linked list as an empty node, so that we don't have to special-case handling of the first node: we can always refer to it as (previous node).next, instead of something like (list).head
				$o = {
					next: void undefined
				};
			}
			// eslint-disable-next-line no-extra-parens
			listSet(/** @type {NonNullable<typeof $o>} */ ($o), key, value);
		}
	};
	// @ts-expect-error TODO: figure out why this is erroring
	return channel;
};


/***/ }),

/***/ 82622:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


var GetIntrinsic = __nccwpck_require__(60470);
var callBound = __nccwpck_require__(23105);
var inspect = __nccwpck_require__(60506);

var $TypeError = __nccwpck_require__(73314);
var $Map = GetIntrinsic('%Map%', true);

/** @type {<K, V>(thisArg: Map<K, V>, key: K) => V} */
var $mapGet = callBound('Map.prototype.get', true);
/** @type {<K, V>(thisArg: Map<K, V>, key: K, value: V) => void} */
var $mapSet = callBound('Map.prototype.set', true);
/** @type {<K, V>(thisArg: Map<K, V>, key: K) => boolean} */
var $mapHas = callBound('Map.prototype.has', true);
/** @type {<K, V>(thisArg: Map<K, V>, key: K) => boolean} */
var $mapDelete = callBound('Map.prototype.delete', true);
/** @type {<K, V>(thisArg: Map<K, V>) => number} */
var $mapSize = callBound('Map.prototype.size', true);

/** @type {import('.')} */
module.exports = !!$Map && /** @type {Exclude<import('.'), false>} */ function getSideChannelMap() {
	/** @typedef {ReturnType<typeof getSideChannelMap>} Channel */
	/** @typedef {Parameters<Channel['get']>[0]} K */
	/** @typedef {Parameters<Channel['set']>[1]} V */

	/** @type {Map<K, V> | undefined} */ var $m;

	/** @type {Channel} */
	var channel = {
		assert: function (key) {
			if (!channel.has(key)) {
				throw new $TypeError('Side channel does not contain ' + inspect(key));
			}
		},
		'delete': function (key) {
			if ($m) {
				var result = $mapDelete($m, key);
				if ($mapSize($m) === 0) {
					$m = void undefined;
				}
				return result;
			}
			return false;
		},
		get: function (key) { // eslint-disable-line consistent-return
			if ($m) {
				return $mapGet($m, key);
			}
		},
		has: function (key) {
			if ($m) {
				return $mapHas($m, key);
			}
			return false;
		},
		set: function (key, value) {
			if (!$m) {
				// @ts-expect-error TS can't handle narrowing a variable inside a closure
				$m = new $Map();
			}
			$mapSet($m, key, value);
		}
	};

	// @ts-expect-error TODO: figure out why TS is erroring here
	return channel;
};


/***/ }),

/***/ 92870:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


var GetIntrinsic = __nccwpck_require__(60470);
var callBound = __nccwpck_require__(23105);
var inspect = __nccwpck_require__(60506);
var getSideChannelMap = __nccwpck_require__(82622);

var $TypeError = __nccwpck_require__(73314);
var $WeakMap = GetIntrinsic('%WeakMap%', true);

/** @type {<K extends object, V>(thisArg: WeakMap<K, V>, key: K) => V} */
var $weakMapGet = callBound('WeakMap.prototype.get', true);
/** @type {<K extends object, V>(thisArg: WeakMap<K, V>, key: K, value: V) => void} */
var $weakMapSet = callBound('WeakMap.prototype.set', true);
/** @type {<K extends object, V>(thisArg: WeakMap<K, V>, key: K) => boolean} */
var $weakMapHas = callBound('WeakMap.prototype.has', true);
/** @type {<K extends object, V>(thisArg: WeakMap<K, V>, key: K) => boolean} */
var $weakMapDelete = callBound('WeakMap.prototype.delete', true);

/** @type {import('.')} */
module.exports = $WeakMap
	? /** @type {Exclude<import('.'), false>} */ function getSideChannelWeakMap() {
		/** @typedef {ReturnType<typeof getSideChannelWeakMap>} Channel */
		/** @typedef {Parameters<Channel['get']>[0]} K */
		/** @typedef {Parameters<Channel['set']>[1]} V */

		/** @type {WeakMap<K & object, V> | undefined} */ var $wm;
		/** @type {Channel | undefined} */ var $m;

		/** @type {Channel} */
		var channel = {
			assert: function (key) {
				if (!channel.has(key)) {
					throw new $TypeError('Side channel does not contain ' + inspect(key));
				}
			},
			'delete': function (key) {
				if ($WeakMap && key && (typeof key === 'object' || typeof key === 'function')) {
					if ($wm) {
						return $weakMapDelete($wm, key);
					}
				} else if (getSideChannelMap) {
					if ($m) {
						return $m['delete'](key);
					}
				}
				return false;
			},
			get: function (key) {
				if ($WeakMap && key && (typeof key === 'object' || typeof key === 'function')) {
					if ($wm) {
						return $weakMapGet($wm, key);
					}
				}
				return $m && $m.get(key);
			},
			has: function (key) {
				if ($WeakMap && key && (typeof key === 'object' || typeof key === 'function')) {
					if ($wm) {
						return $weakMapHas($wm, key);
					}
				}
				return !!$m && $m.has(key);
			},
			set: function (key, value) {
				if ($WeakMap && key && (typeof key === 'object' || typeof key === 'function')) {
					if (!$wm) {
						$wm = new $WeakMap();
					}
					$weakMapSet($wm, key, value);
				} else if (getSideChannelMap) {
					if (!$m) {
						$m = getSideChannelMap();
					}
					// eslint-disable-next-line no-extra-parens
					/** @type {NonNullable<typeof $m>} */ ($m).set(key, value);
				}
			}
		};

		// @ts-expect-error TODO: figure out why this is erroring
		return channel;
	}
	: getSideChannelMap;


/***/ }),

/***/ 94753:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


var $TypeError = __nccwpck_require__(73314);
var inspect = __nccwpck_require__(60506);
var getSideChannelList = __nccwpck_require__(8948);
var getSideChannelMap = __nccwpck_require__(82622);
var getSideChannelWeakMap = __nccwpck_require__(92870);

var makeChannel = getSideChannelWeakMap || getSideChannelMap || getSideChannelList;

/** @type {import('.')} */
module.exports = function getSideChannel() {
	/** @typedef {ReturnType<typeof getSideChannel>} Channel */

	/** @type {Channel | undefined} */ var $channelData;

	/** @type {Channel} */
	var channel = {
		assert: function (key) {
			if (!channel.has(key)) {
				throw new $TypeError('Side channel does not contain ' + inspect(key));
			}
		},
		'delete': function (key) {
			return !!$channelData && $channelData['delete'](key);
		},
		get: function (key) {
			return $channelData && $channelData.get(key);
		},
		has: function (key) {
			return !!$channelData && $channelData.has(key);
		},
		set: function (key, value) {
			if (!$channelData) {
				$channelData = makeChannel();
			}

			$channelData.set(key, value);
		}
	};
	// @ts-expect-error TODO: figure out why this is erroring
	return channel;
};


/***/ }),

/***/ 81788:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

module.exports = __nccwpck_require__(85938)('node_sqlite3.node');


/***/ }),

/***/ 38488:
/***/ ((module, exports, __nccwpck_require__) => {

const path = __nccwpck_require__(16928);
const sqlite3 = __nccwpck_require__(81788);
const EventEmitter = (__nccwpck_require__(24434).EventEmitter);
module.exports = exports = sqlite3;

function normalizeMethod (fn) {
    return function (sql) {
        let errBack;
        const args = Array.prototype.slice.call(arguments, 1);

        if (typeof args[args.length - 1] === 'function') {
            const callback = args[args.length - 1];
            errBack = function(err) {
                if (err) {
                    callback(err);
                }
            };
        }
        const statement = new Statement(this, sql, errBack);
        return fn.call(this, statement, args);
    };
}

function inherits(target, source) {
    for (const k in source.prototype)
        target.prototype[k] = source.prototype[k];
}

sqlite3.cached = {
    Database: function(file, a, b) {
        if (file === '' || file === ':memory:') {
            // Don't cache special databases.
            return new Database(file, a, b);
        }

        let db;
        file = path.resolve(file);

        if (!sqlite3.cached.objects[file]) {
            db = sqlite3.cached.objects[file] = new Database(file, a, b);
        }
        else {
            // Make sure the callback is called.
            db = sqlite3.cached.objects[file];
            const callback = (typeof a === 'number') ? b : a;
            if (typeof callback === 'function') {
                function cb() { callback.call(db, null); }
                if (db.open) process.nextTick(cb);
                else db.once('open', cb);
            }
        }

        return db;
    },
    objects: {}
};


const Database = sqlite3.Database;
const Statement = sqlite3.Statement;
const Backup = sqlite3.Backup;

inherits(Database, EventEmitter);
inherits(Statement, EventEmitter);
inherits(Backup, EventEmitter);

// Database#prepare(sql, [bind1, bind2, ...], [callback])
Database.prototype.prepare = normalizeMethod(function(statement, params) {
    return params.length
        ? statement.bind.apply(statement, params)
        : statement;
});

// Database#run(sql, [bind1, bind2, ...], [callback])
Database.prototype.run = normalizeMethod(function(statement, params) {
    statement.run.apply(statement, params).finalize();
    return this;
});

// Database#get(sql, [bind1, bind2, ...], [callback])
Database.prototype.get = normalizeMethod(function(statement, params) {
    statement.get.apply(statement, params).finalize();
    return this;
});

// Database#all(sql, [bind1, bind2, ...], [callback])
Database.prototype.all = normalizeMethod(function(statement, params) {
    statement.all.apply(statement, params).finalize();
    return this;
});

// Database#each(sql, [bind1, bind2, ...], [callback], [complete])
Database.prototype.each = normalizeMethod(function(statement, params) {
    statement.each.apply(statement, params).finalize();
    return this;
});

Database.prototype.map = normalizeMethod(function(statement, params) {
    statement.map.apply(statement, params).finalize();
    return this;
});

// Database#backup(filename, [callback])
// Database#backup(filename, destName, sourceName, filenameIsDest, [callback])
Database.prototype.backup = function() {
    let backup;
    if (arguments.length <= 2) {
        // By default, we write the main database out to the main database of the named file.
        // This is the most likely use of the backup api.
        backup = new Backup(this, arguments[0], 'main', 'main', true, arguments[1]);
    } else {
        // Otherwise, give the user full control over the sqlite3_backup_init arguments.
        backup = new Backup(this, arguments[0], arguments[1], arguments[2], arguments[3], arguments[4]);
    }
    // Per the sqlite docs, exclude the following errors as non-fatal by default.
    backup.retryErrors = [sqlite3.BUSY, sqlite3.LOCKED];
    return backup;
};

Statement.prototype.map = function() {
    const params = Array.prototype.slice.call(arguments);
    const callback = params.pop();
    params.push(function(err, rows) {
        if (err) return callback(err);
        const result = {};
        if (rows.length) {
            const keys = Object.keys(rows[0]);
            const key = keys[0];
            if (keys.length > 2) {
                // Value is an object
                for (let i = 0; i < rows.length; i++) {
                    result[rows[i][key]] = rows[i];
                }
            } else {
                const value = keys[1];
                // Value is a plain value
                for (let i = 0; i < rows.length; i++) {
                    result[rows[i][key]] = rows[i][value];
                }
            }
        }
        callback(err, result);
    });
    return this.all.apply(this, params);
};

let isVerbose = false;

const supportedEvents = [ 'trace', 'profile', 'change' ];

Database.prototype.addListener = Database.prototype.on = function(type) {
    const val = EventEmitter.prototype.addListener.apply(this, arguments);
    if (supportedEvents.indexOf(type) >= 0) {
        this.configure(type, true);
    }
    return val;
};

Database.prototype.removeListener = function(type) {
    const val = EventEmitter.prototype.removeListener.apply(this, arguments);
    if (supportedEvents.indexOf(type) >= 0 && !this._events[type]) {
        this.configure(type, false);
    }
    return val;
};

Database.prototype.removeAllListeners = function(type) {
    const val = EventEmitter.prototype.removeAllListeners.apply(this, arguments);
    if (supportedEvents.indexOf(type) >= 0) {
        this.configure(type, false);
    }
    return val;
};

// Save the stack trace over EIO callbacks.
sqlite3.verbose = function() {
    if (!isVerbose) {
        const trace = __nccwpck_require__(21668);
        [
            'prepare',
            'get',
            'run',
            'all',
            'each',
            'map',
            'close',
            'exec'
        ].forEach(function (name) {
            trace.extendTrace(Database.prototype, name);
        });
        [
            'bind',
            'get',
            'run',
            'all',
            'each',
            'map',
            'reset',
            'finalize',
        ].forEach(function (name) {
            trace.extendTrace(Statement.prototype, name);
        });
        isVerbose = true;
    }

    return sqlite3;
};


/***/ }),

/***/ 21668:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

// Inspired by https://github.com/tlrobinson/long-stack-traces
const util = __nccwpck_require__(39023);

function extendTrace(object, property, pos) {
    const old = object[property];
    object[property] = function() {
        const error = new Error();
        const name = object.constructor.name + '#' + property + '(' +
            Array.prototype.slice.call(arguments).map(function(el) {
                return util.inspect(el, false, 0);
            }).join(', ') + ')';

        if (typeof pos === 'undefined') pos = -1;
        if (pos < 0) pos += arguments.length;
        const cb = arguments[pos];
        if (typeof arguments[pos] === 'function') {
            arguments[pos] = function replacement() {
                const err = arguments[0];
                if (err && err.stack && !err.__augmented) {
                    err.stack = filter(err).join('\n');
                    err.stack += '\n--> in ' + name;
                    err.stack += '\n' + filter(error).slice(1).join('\n');
                    err.__augmented = true;
                }
                return cb.apply(this, arguments);
            };
        }
        return old.apply(this, arguments);
    };
}
exports.extendTrace = extendTrace;


function filter(error) {
    return error.stack.split('\n').filter(function(line) {
        return line.indexOf(__filename) < 0;
    });
}


/***/ }),

/***/ 16921:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

module.exports = __nccwpck_require__(3940);


/***/ }),

/***/ 3940:
/***/ ((__unused_webpack_module, exports) => {

var SqlString  = exports;

var ID_GLOBAL_REGEXP    = /`/g;
var QUAL_GLOBAL_REGEXP  = /\./g;
var CHARS_GLOBAL_REGEXP = /[\0\b\t\n\r\x1a\"\'\\]/g; // eslint-disable-line no-control-regex
var CHARS_ESCAPE_MAP    = {
  '\0'   : '\\0',
  '\b'   : '\\b',
  '\t'   : '\\t',
  '\n'   : '\\n',
  '\r'   : '\\r',
  '\x1a' : '\\Z',
  '"'    : '\\"',
  '\''   : '\\\'',
  '\\'   : '\\\\'
};

SqlString.escapeId = function escapeId(val, forbidQualified) {
  if (Array.isArray(val)) {
    var sql = '';

    for (var i = 0; i < val.length; i++) {
      sql += (i === 0 ? '' : ', ') + SqlString.escapeId(val[i], forbidQualified);
    }

    return sql;
  } else if (forbidQualified) {
    return '`' + String(val).replace(ID_GLOBAL_REGEXP, '``') + '`';
  } else {
    return '`' + String(val).replace(ID_GLOBAL_REGEXP, '``').replace(QUAL_GLOBAL_REGEXP, '`.`') + '`';
  }
};

SqlString.escape = function escape(val, stringifyObjects, timeZone) {
  if (val === undefined || val === null) {
    return 'NULL';
  }

  switch (typeof val) {
    case 'boolean': return (val) ? 'true' : 'false';
    case 'number': return val + '';
    case 'object':
      if (Object.prototype.toString.call(val) === '[object Date]') {
        return SqlString.dateToString(val, timeZone || 'local');
      } else if (Array.isArray(val)) {
        return SqlString.arrayToList(val, timeZone);
      } else if (Buffer.isBuffer(val)) {
        return SqlString.bufferToString(val);
      } else if (typeof val.toSqlString === 'function') {
        return String(val.toSqlString());
      } else if (stringifyObjects) {
        return escapeString(val.toString());
      } else {
        return SqlString.objectToValues(val, timeZone);
      }
    default: return escapeString(val);
  }
};

SqlString.arrayToList = function arrayToList(array, timeZone) {
  var sql = '';

  for (var i = 0; i < array.length; i++) {
    var val = array[i];

    if (Array.isArray(val)) {
      sql += (i === 0 ? '' : ', ') + '(' + SqlString.arrayToList(val, timeZone) + ')';
    } else {
      sql += (i === 0 ? '' : ', ') + SqlString.escape(val, true, timeZone);
    }
  }

  return sql;
};

SqlString.format = function format(sql, values, stringifyObjects, timeZone) {
  if (values == null) {
    return sql;
  }

  if (!Array.isArray(values)) {
    values = [values];
  }

  var chunkIndex        = 0;
  var placeholdersRegex = /\?+/g;
  var result            = '';
  var valuesIndex       = 0;
  var match;

  while (valuesIndex < values.length && (match = placeholdersRegex.exec(sql))) {
    var len = match[0].length;

    if (len > 2) {
      continue;
    }

    var value = len === 2
      ? SqlString.escapeId(values[valuesIndex])
      : SqlString.escape(values[valuesIndex], stringifyObjects, timeZone);

    result += sql.slice(chunkIndex, match.index) + value;
    chunkIndex = placeholdersRegex.lastIndex;
    valuesIndex++;
  }

  if (chunkIndex === 0) {
    // Nothing was replaced
    return sql;
  }

  if (chunkIndex < sql.length) {
    return result + sql.slice(chunkIndex);
  }

  return result;
};

SqlString.dateToString = function dateToString(date, timeZone) {
  var dt = new Date(date);

  if (isNaN(dt.getTime())) {
    return 'NULL';
  }

  var year;
  var month;
  var day;
  var hour;
  var minute;
  var second;
  var millisecond;

  if (timeZone === 'local') {
    year        = dt.getFullYear();
    month       = dt.getMonth() + 1;
    day         = dt.getDate();
    hour        = dt.getHours();
    minute      = dt.getMinutes();
    second      = dt.getSeconds();
    millisecond = dt.getMilliseconds();
  } else {
    var tz = convertTimezone(timeZone);

    if (tz !== false && tz !== 0) {
      dt.setTime(dt.getTime() + (tz * 60000));
    }

    year       = dt.getUTCFullYear();
    month       = dt.getUTCMonth() + 1;
    day         = dt.getUTCDate();
    hour        = dt.getUTCHours();
    minute      = dt.getUTCMinutes();
    second      = dt.getUTCSeconds();
    millisecond = dt.getUTCMilliseconds();
  }

  // YYYY-MM-DD HH:mm:ss.mmm
  var str = zeroPad(year, 4) + '-' + zeroPad(month, 2) + '-' + zeroPad(day, 2) + ' ' +
    zeroPad(hour, 2) + ':' + zeroPad(minute, 2) + ':' + zeroPad(second, 2) + '.' +
    zeroPad(millisecond, 3);

  return escapeString(str);
};

SqlString.bufferToString = function bufferToString(buffer) {
  return 'X' + escapeString(buffer.toString('hex'));
};

SqlString.objectToValues = function objectToValues(object, timeZone) {
  var sql = '';

  for (var key in object) {
    var val = object[key];

    if (typeof val === 'function') {
      continue;
    }

    sql += (sql.length === 0 ? '' : ', ') + SqlString.escapeId(key) + ' = ' + SqlString.escape(val, true, timeZone);
  }

  return sql;
};

SqlString.raw = function raw(sql) {
  if (typeof sql !== 'string') {
    throw new TypeError('argument sql must be a string');
  }

  return {
    toSqlString: function toSqlString() { return sql; }
  };
};

function escapeString(val) {
  var chunkIndex = CHARS_GLOBAL_REGEXP.lastIndex = 0;
  var escapedVal = '';
  var match;

  while ((match = CHARS_GLOBAL_REGEXP.exec(val))) {
    escapedVal += val.slice(chunkIndex, match.index) + CHARS_ESCAPE_MAP[match[0]];
    chunkIndex = CHARS_GLOBAL_REGEXP.lastIndex;
  }

  if (chunkIndex === 0) {
    // Nothing was escaped
    return "'" + val + "'";
  }

  if (chunkIndex < val.length) {
    return "'" + escapedVal + val.slice(chunkIndex) + "'";
  }

  return "'" + escapedVal + "'";
}

function zeroPad(number, length) {
  number = number.toString();
  while (number.length < length) {
    number = '0' + number;
  }

  return number;
}

function convertTimezone(tz) {
  if (tz === 'Z') {
    return 0;
  }

  var m = tz.match(/([\+\-\s])(\d\d):?(\d\d)?/);
  if (m) {
    return (m[1] === '-' ? -1 : 1) * (parseInt(m[2], 10) + ((m[3] ? parseInt(m[3], 10) : 0) / 60)) * 60;
  }
  return false;
}


/***/ }),

/***/ 39428:
/***/ ((__unused_webpack_module, exports) => {

exports.get = function(belowFn) {
  var oldLimit = Error.stackTraceLimit;
  Error.stackTraceLimit = Infinity;

  var dummyObject = {};

  var v8Handler = Error.prepareStackTrace;
  Error.prepareStackTrace = function(dummyObject, v8StackTrace) {
    return v8StackTrace;
  };
  Error.captureStackTrace(dummyObject, belowFn || exports.get);

  var v8StackTrace = dummyObject.stack;
  Error.prepareStackTrace = v8Handler;
  Error.stackTraceLimit = oldLimit;

  return v8StackTrace;
};

exports.parse = function(err) {
  if (!err.stack) {
    return [];
  }

  var self = this;
  var lines = err.stack.split('\n').slice(1);

  return lines
    .map(function(line) {
      if (line.match(/^\s*[-]{4,}$/)) {
        return self._createParsedCallSite({
          fileName: line,
          lineNumber: null,
          functionName: null,
          typeName: null,
          methodName: null,
          columnNumber: null,
          'native': null,
        });
      }

      var lineMatch = line.match(/at (?:(.+)\s+\()?(?:(.+?):(\d+)(?::(\d+))?|([^)]+))\)?/);
      if (!lineMatch) {
        return;
      }

      var object = null;
      var method = null;
      var functionName = null;
      var typeName = null;
      var methodName = null;
      var isNative = (lineMatch[5] === 'native');

      if (lineMatch[1]) {
        functionName = lineMatch[1];
        var methodStart = functionName.lastIndexOf('.');
        if (functionName[methodStart-1] == '.')
          methodStart--;
        if (methodStart > 0) {
          object = functionName.substr(0, methodStart);
          method = functionName.substr(methodStart + 1);
          var objectEnd = object.indexOf('.Module');
          if (objectEnd > 0) {
            functionName = functionName.substr(objectEnd + 1);
            object = object.substr(0, objectEnd);
          }
        }
        typeName = null;
      }

      if (method) {
        typeName = object;
        methodName = method;
      }

      if (method === '<anonymous>') {
        methodName = null;
        functionName = null;
      }

      var properties = {
        fileName: lineMatch[2] || null,
        lineNumber: parseInt(lineMatch[3], 10) || null,
        functionName: functionName,
        typeName: typeName,
        methodName: methodName,
        columnNumber: parseInt(lineMatch[4], 10) || null,
        'native': isNative,
      };

      return self._createParsedCallSite(properties);
    })
    .filter(function(callSite) {
      return !!callSite;
    });
};

function CallSite(properties) {
  for (var property in properties) {
    this[property] = properties[property];
  }
}

var strProperties = [
  'this',
  'typeName',
  'functionName',
  'methodName',
  'fileName',
  'lineNumber',
  'columnNumber',
  'function',
  'evalOrigin'
];
var boolProperties = [
  'topLevel',
  'eval',
  'native',
  'constructor'
];
strProperties.forEach(function (property) {
  CallSite.prototype[property] = null;
  CallSite.prototype['get' + property[0].toUpperCase() + property.substr(1)] = function () {
    return this[property];
  }
});
boolProperties.forEach(function (property) {
  CallSite.prototype[property] = false;
  CallSite.prototype['is' + property[0].toUpperCase() + property.substr(1)] = function () {
    return this[property];
  }
});

exports._createParsedCallSite = function(properties) {
  return new CallSite(properties);
};


/***/ }),

/***/ 44650:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";
/*!
 * statuses
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2016 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module dependencies.
 * @private
 */

var codes = __nccwpck_require__(17662)

/**
 * Module exports.
 * @public
 */

module.exports = status

// status code to message map
status.message = codes

// status message (lower-case) to code map
status.code = createMessageToStatusCodeMap(codes)

// array of status codes
status.codes = createStatusCodeList(codes)

// status codes for redirects
status.redirect = {
  300: true,
  301: true,
  302: true,
  303: true,
  305: true,
  307: true,
  308: true
}

// status codes for empty bodies
status.empty = {
  204: true,
  205: true,
  304: true
}

// status codes for when you should retry the request
status.retry = {
  502: true,
  503: true,
  504: true
}

/**
 * Create a map of message to status code.
 * @private
 */

function createMessageToStatusCodeMap (codes) {
  var map = {}

  Object.keys(codes).forEach(function forEachCode (code) {
    var message = codes[code]
    var status = Number(code)

    // populate map
    map[message.toLowerCase()] = status
  })

  return map
}

/**
 * Create a list of all status codes.
 * @private
 */

function createStatusCodeList (codes) {
  return Object.keys(codes).map(function mapCode (code) {
    return Number(code)
  })
}

/**
 * Get the status code for given message.
 * @private
 */

function getStatusCode (message) {
  var msg = message.toLowerCase()

  if (!Object.prototype.hasOwnProperty.call(status.code, msg)) {
    throw new Error('invalid status message: "' + message + '"')
  }

  return status.code[msg]
}

/**
 * Get the status message for given code.
 * @private
 */

function getStatusMessage (code) {
  if (!Object.prototype.hasOwnProperty.call(status.message, code)) {
    throw new Error('invalid status code: ' + code)
  }

  return status.message[code]
}

/**
 * Get the status code.
 *
 * Given a number, this will throw if it is not a known status
 * code, otherwise the code will be returned. Given a string,
 * the string will be parsed for a number and return the code
 * if valid, otherwise will lookup the code assuming this is
 * the status message.
 *
 * @param {string|number} code
 * @returns {number}
 * @public
 */

function status (code) {
  if (typeof code === 'number') {
    return getStatusMessage(code)
  }

  if (typeof code !== 'string') {
    throw new TypeError('code must be a number or string')
  }

  // '403'
  var n = parseInt(code, 10)
  if (!isNaN(n)) {
    return getStatusMessage(n)
  }

  return getStatusCode(code)
}


/***/ }),

/***/ 59026:
/***/ ((module) => {

"use strict";

/*
  Based heavily on the Streaming Boyer-Moore-Horspool C++ implementation
  by Hongli Lai at: https://github.com/FooBarWidget/boyer-moore-horspool
*/
function memcmp(buf1, pos1, buf2, pos2, num) {
  for (let i = 0; i < num; ++i) {
    if (buf1[pos1 + i] !== buf2[pos2 + i])
      return false;
  }
  return true;
}

class SBMH {
  constructor(needle, cb) {
    if (typeof cb !== 'function')
      throw new Error('Missing match callback');

    if (typeof needle === 'string')
      needle = Buffer.from(needle);
    else if (!Buffer.isBuffer(needle))
      throw new Error(`Expected Buffer for needle, got ${typeof needle}`);

    const needleLen = needle.length;

    this.maxMatches = Infinity;
    this.matches = 0;

    this._cb = cb;
    this._lookbehindSize = 0;
    this._needle = needle;
    this._bufPos = 0;

    this._lookbehind = Buffer.allocUnsafe(needleLen);

    // Initialize occurrence table.
    this._occ = [
      needleLen, needleLen, needleLen, needleLen, needleLen, needleLen,
      needleLen, needleLen, needleLen, needleLen, needleLen, needleLen,
      needleLen, needleLen, needleLen, needleLen, needleLen, needleLen,
      needleLen, needleLen, needleLen, needleLen, needleLen, needleLen,
      needleLen, needleLen, needleLen, needleLen, needleLen, needleLen,
      needleLen, needleLen, needleLen, needleLen, needleLen, needleLen,
      needleLen, needleLen, needleLen, needleLen, needleLen, needleLen,
      needleLen, needleLen, needleLen, needleLen, needleLen, needleLen,
      needleLen, needleLen, needleLen, needleLen, needleLen, needleLen,
      needleLen, needleLen, needleLen, needleLen, needleLen, needleLen,
      needleLen, needleLen, needleLen, needleLen, needleLen, needleLen,
      needleLen, needleLen, needleLen, needleLen, needleLen, needleLen,
      needleLen, needleLen, needleLen, needleLen, needleLen, needleLen,
      needleLen, needleLen, needleLen, needleLen, needleLen, needleLen,
      needleLen, needleLen, needleLen, needleLen, needleLen, needleLen,
      needleLen, needleLen, needleLen, needleLen, needleLen, needleLen,
      needleLen, needleLen, needleLen, needleLen, needleLen, needleLen,
      needleLen, needleLen, needleLen, needleLen, needleLen, needleLen,
      needleLen, needleLen, needleLen, needleLen, needleLen, needleLen,
      needleLen, needleLen, needleLen, needleLen, needleLen, needleLen,
      needleLen, needleLen, needleLen, needleLen, needleLen, needleLen,
      needleLen, needleLen, needleLen, needleLen, needleLen, needleLen,
      needleLen, needleLen, needleLen, needleLen, needleLen, needleLen,
      needleLen, needleLen, needleLen, needleLen, needleLen, needleLen,
      needleLen, needleLen, needleLen, needleLen, needleLen, needleLen,
      needleLen, needleLen, needleLen, needleLen, needleLen, needleLen,
      needleLen, needleLen, needleLen, needleLen, needleLen, needleLen,
      needleLen, needleLen, needleLen, needleLen, needleLen, needleLen,
      needleLen, needleLen, needleLen, needleLen, needleLen, needleLen,
      needleLen, needleLen, needleLen, needleLen, needleLen, needleLen,
      needleLen, needleLen, needleLen, needleLen, needleLen, needleLen,
      needleLen, needleLen, needleLen, needleLen, needleLen, needleLen,
      needleLen, needleLen, needleLen, needleLen, needleLen, needleLen,
      needleLen, needleLen, needleLen, needleLen, needleLen, needleLen,
      needleLen, needleLen, needleLen, needleLen, needleLen, needleLen,
      needleLen, needleLen, needleLen, needleLen, needleLen, needleLen,
      needleLen, needleLen, needleLen, needleLen, needleLen, needleLen,
      needleLen, needleLen, needleLen, needleLen, needleLen, needleLen,
      needleLen, needleLen, needleLen, needleLen, needleLen, needleLen,
      needleLen, needleLen, needleLen, needleLen, needleLen, needleLen,
      needleLen, needleLen, needleLen, needleLen, needleLen, needleLen,
      needleLen, needleLen, needleLen, needleLen, needleLen, needleLen,
      needleLen, needleLen, needleLen, needleLen
    ];

    // Populate occurrence table with analysis of the needle, ignoring the last
    // letter.
    if (needleLen > 1) {
      for (let i = 0; i < needleLen - 1; ++i)
        this._occ[needle[i]] = needleLen - 1 - i;
    }
  }

  reset() {
    this.matches = 0;
    this._lookbehindSize = 0;
    this._bufPos = 0;
  }

  push(chunk, pos) {
    let result;
    if (!Buffer.isBuffer(chunk))
      chunk = Buffer.from(chunk, 'latin1');
    const chunkLen = chunk.length;
    this._bufPos = pos || 0;
    while (result !== chunkLen && this.matches < this.maxMatches)
      result = feed(this, chunk);
    return result;
  }

  destroy() {
    const lbSize = this._lookbehindSize;
    if (lbSize)
      this._cb(false, this._lookbehind, 0, lbSize, false);
    this.reset();
  }
}

function feed(self, data) {
  const len = data.length;
  const needle = self._needle;
  const needleLen = needle.length;

  // Positive: points to a position in `data`
  //           pos == 3 points to data[3]
  // Negative: points to a position in the lookbehind buffer
  //           pos == -2 points to lookbehind[lookbehindSize - 2]
  let pos = -self._lookbehindSize;
  const lastNeedleCharPos = needleLen - 1;
  const lastNeedleChar = needle[lastNeedleCharPos];
  const end = len - needleLen;
  const occ = self._occ;
  const lookbehind = self._lookbehind;

  if (pos < 0) {
    // Lookbehind buffer is not empty. Perform Boyer-Moore-Horspool
    // search with character lookup code that considers both the
    // lookbehind buffer and the current round's haystack data.
    //
    // Loop until
    //   there is a match.
    // or until
    //   we've moved past the position that requires the
    //   lookbehind buffer. In this case we switch to the
    //   optimized loop.
    // or until
    //   the character to look at lies outside the haystack.
    while (pos < 0 && pos <= end) {
      const nextPos = pos + lastNeedleCharPos;
      const ch = (nextPos < 0
                  ? lookbehind[self._lookbehindSize + nextPos]
                  : data[nextPos]);

      if (ch === lastNeedleChar
          && matchNeedle(self, data, pos, lastNeedleCharPos)) {
        self._lookbehindSize = 0;
        ++self.matches;
        if (pos > -self._lookbehindSize)
          self._cb(true, lookbehind, 0, self._lookbehindSize + pos, false);
        else
          self._cb(true, undefined, 0, 0, true);

        return (self._bufPos = pos + needleLen);
      }

      pos += occ[ch];
    }

    // No match.

    // There's too few data for Boyer-Moore-Horspool to run,
    // so let's use a different algorithm to skip as much as
    // we can.
    // Forward pos until
    //   the trailing part of lookbehind + data
    //   looks like the beginning of the needle
    // or until
    //   pos == 0
    while (pos < 0 && !matchNeedle(self, data, pos, len - pos))
      ++pos;

    if (pos < 0) {
      // Cut off part of the lookbehind buffer that has
      // been processed and append the entire haystack
      // into it.
      const bytesToCutOff = self._lookbehindSize + pos;

      if (bytesToCutOff > 0) {
        // The cut off data is guaranteed not to contain the needle.
        self._cb(false, lookbehind, 0, bytesToCutOff, false);
      }

      self._lookbehindSize -= bytesToCutOff;
      lookbehind.copy(lookbehind, 0, bytesToCutOff, self._lookbehindSize);
      lookbehind.set(data, self._lookbehindSize);
      self._lookbehindSize += len;

      self._bufPos = len;
      return len;
    }

    // Discard lookbehind buffer.
    self._cb(false, lookbehind, 0, self._lookbehindSize, false);
    self._lookbehindSize = 0;
  }

  pos += self._bufPos;

  const firstNeedleChar = needle[0];

  // Lookbehind buffer is now empty. Perform Boyer-Moore-Horspool
  // search with optimized character lookup code that only considers
  // the current round's haystack data.
  while (pos <= end) {
    const ch = data[pos + lastNeedleCharPos];

    if (ch === lastNeedleChar
        && data[pos] === firstNeedleChar
        && memcmp(needle, 0, data, pos, lastNeedleCharPos)) {
      ++self.matches;
      if (pos > 0)
        self._cb(true, data, self._bufPos, pos, true);
      else
        self._cb(true, undefined, 0, 0, true);

      return (self._bufPos = pos + needleLen);
    }

    pos += occ[ch];
  }

  // There was no match. If there's trailing haystack data that we cannot
  // match yet using the Boyer-Moore-Horspool algorithm (because the trailing
  // data is less than the needle size) then match using a modified
  // algorithm that starts matching from the beginning instead of the end.
  // Whatever trailing data is left after running this algorithm is added to
  // the lookbehind buffer.
  while (pos < len) {
    if (data[pos] !== firstNeedleChar
        || !memcmp(data, pos, needle, 0, len - pos)) {
      ++pos;
      continue;
    }
    data.copy(lookbehind, 0, pos, len);
    self._lookbehindSize = len - pos;
    break;
  }

  // Everything until `pos` is guaranteed not to contain needle data.
  if (pos > 0)
    self._cb(false, data, self._bufPos, pos < len ? pos : len, true);

  self._bufPos = len;
  return len;
}

function matchNeedle(self, data, pos, len) {
  const lb = self._lookbehind;
  const lbSize = self._lookbehindSize;
  const needle = self._needle;

  for (let i = 0; i < len; ++i, ++pos) {
    const ch = (pos < 0 ? lb[lbSize + pos] : data[pos]);
    if (ch !== needle[i])
      return false;
  }
  return true;
}

module.exports = SBMH;


/***/ }),

/***/ 80634:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



/*<replacement>*/

var Buffer = (__nccwpck_require__(93058).Buffer);
/*</replacement>*/

var isEncoding = Buffer.isEncoding || function (encoding) {
  encoding = '' + encoding;
  switch (encoding && encoding.toLowerCase()) {
    case 'hex':case 'utf8':case 'utf-8':case 'ascii':case 'binary':case 'base64':case 'ucs2':case 'ucs-2':case 'utf16le':case 'utf-16le':case 'raw':
      return true;
    default:
      return false;
  }
};

function _normalizeEncoding(enc) {
  if (!enc) return 'utf8';
  var retried;
  while (true) {
    switch (enc) {
      case 'utf8':
      case 'utf-8':
        return 'utf8';
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return 'utf16le';
      case 'latin1':
      case 'binary':
        return 'latin1';
      case 'base64':
      case 'ascii':
      case 'hex':
        return enc;
      default:
        if (retried) return; // undefined
        enc = ('' + enc).toLowerCase();
        retried = true;
    }
  }
};

// Do not cache `Buffer.isEncoding` when checking encoding names as some
// modules monkey-patch it to support additional encodings
function normalizeEncoding(enc) {
  var nenc = _normalizeEncoding(enc);
  if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);
  return nenc || enc;
}

// StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters.
exports.I = StringDecoder;
function StringDecoder(encoding) {
  this.encoding = normalizeEncoding(encoding);
  var nb;
  switch (this.encoding) {
    case 'utf16le':
      this.text = utf16Text;
      this.end = utf16End;
      nb = 4;
      break;
    case 'utf8':
      this.fillLast = utf8FillLast;
      nb = 4;
      break;
    case 'base64':
      this.text = base64Text;
      this.end = base64End;
      nb = 3;
      break;
    default:
      this.write = simpleWrite;
      this.end = simpleEnd;
      return;
  }
  this.lastNeed = 0;
  this.lastTotal = 0;
  this.lastChar = Buffer.allocUnsafe(nb);
}

StringDecoder.prototype.write = function (buf) {
  if (buf.length === 0) return '';
  var r;
  var i;
  if (this.lastNeed) {
    r = this.fillLast(buf);
    if (r === undefined) return '';
    i = this.lastNeed;
    this.lastNeed = 0;
  } else {
    i = 0;
  }
  if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
  return r || '';
};

StringDecoder.prototype.end = utf8End;

// Returns only complete characters in a Buffer
StringDecoder.prototype.text = utf8Text;

// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer
StringDecoder.prototype.fillLast = function (buf) {
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
  this.lastNeed -= buf.length;
};

// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a
// continuation byte. If an invalid byte is detected, -2 is returned.
function utf8CheckByte(byte) {
  if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;
  return byte >> 6 === 0x02 ? -1 : -2;
}

// Checks at most 3 bytes at the end of a Buffer in order to detect an
// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)
// needed to complete the UTF-8 character (if applicable) are returned.
function utf8CheckIncomplete(self, buf, i) {
  var j = buf.length - 1;
  if (j < i) return 0;
  var nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 1;
    return nb;
  }
  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 2;
    return nb;
  }
  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) {
      if (nb === 2) nb = 0;else self.lastNeed = nb - 3;
    }
    return nb;
  }
  return 0;
}

// Validates as many continuation bytes for a multi-byte UTF-8 character as
// needed or are available. If we see a non-continuation byte where we expect
// one, we "replace" the validated continuation bytes we've seen so far with
// a single UTF-8 replacement character ('\ufffd'), to match v8's UTF-8 decoding
// behavior. The continuation byte check is included three times in the case
// where all of the continuation bytes for a character exist in the same buffer.
// It is also done this way as a slight performance increase instead of using a
// loop.
function utf8CheckExtraBytes(self, buf, p) {
  if ((buf[0] & 0xC0) !== 0x80) {
    self.lastNeed = 0;
    return '\ufffd';
  }
  if (self.lastNeed > 1 && buf.length > 1) {
    if ((buf[1] & 0xC0) !== 0x80) {
      self.lastNeed = 1;
      return '\ufffd';
    }
    if (self.lastNeed > 2 && buf.length > 2) {
      if ((buf[2] & 0xC0) !== 0x80) {
        self.lastNeed = 2;
        return '\ufffd';
      }
    }
  }
}

// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.
function utf8FillLast(buf) {
  var p = this.lastTotal - this.lastNeed;
  var r = utf8CheckExtraBytes(this, buf, p);
  if (r !== undefined) return r;
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, p, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, p, 0, buf.length);
  this.lastNeed -= buf.length;
}

// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a
// partial character, the character's bytes are buffered until the required
// number of bytes are available.
function utf8Text(buf, i) {
  var total = utf8CheckIncomplete(this, buf, i);
  if (!this.lastNeed) return buf.toString('utf8', i);
  this.lastTotal = total;
  var end = buf.length - (total - this.lastNeed);
  buf.copy(this.lastChar, 0, end);
  return buf.toString('utf8', i, end);
}

// For UTF-8, a replacement character is added when ending on a partial
// character.
function utf8End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + '\ufffd';
  return r;
}

// UTF-16LE typically needs two bytes per character, but even if we have an even
// number of bytes available, we need to check if we end on a leading/high
// surrogate. In that case, we need to wait for the next two bytes in order to
// decode the last character properly.
function utf16Text(buf, i) {
  if ((buf.length - i) % 2 === 0) {
    var r = buf.toString('utf16le', i);
    if (r) {
      var c = r.charCodeAt(r.length - 1);
      if (c >= 0xD800 && c <= 0xDBFF) {
        this.lastNeed = 2;
        this.lastTotal = 4;
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
        return r.slice(0, -1);
      }
    }
    return r;
  }
  this.lastNeed = 1;
  this.lastTotal = 2;
  this.lastChar[0] = buf[buf.length - 1];
  return buf.toString('utf16le', i, buf.length - 1);
}

// For UTF-16LE we do not explicitly append special replacement characters if we
// end on a partial character, we simply let v8 handle that.
function utf16End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) {
    var end = this.lastTotal - this.lastNeed;
    return r + this.lastChar.toString('utf16le', 0, end);
  }
  return r;
}

function base64Text(buf, i) {
  var n = (buf.length - i) % 3;
  if (n === 0) return buf.toString('base64', i);
  this.lastNeed = 3 - n;
  this.lastTotal = 3;
  if (n === 1) {
    this.lastChar[0] = buf[buf.length - 1];
  } else {
    this.lastChar[0] = buf[buf.length - 2];
    this.lastChar[1] = buf[buf.length - 1];
  }
  return buf.toString('base64', i, buf.length - n);
}

function base64End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);
  return r;
}

// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)
function simpleWrite(buf) {
  return buf.toString(this.encoding);
}

function simpleEnd(buf) {
  return buf && buf.length ? this.write(buf) : '';
}

/***/ }),

/***/ 52794:
/***/ ((module) => {

"use strict";
/*!
 * toidentifier
 * Copyright(c) 2016 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module exports.
 * @public
 */

module.exports = toIdentifier

/**
 * Trasform the given string into a JavaScript identifier
 *
 * @param {string} str
 * @returns {string}
 * @public
 */

function toIdentifier (str) {
  return str
    .split(' ')
    .map(function (token) {
      return token.slice(0, 1).toUpperCase() + token.slice(1)
    })
    .join('')
    .replace(/[^ _0-9a-z]/gi, '')
}


/***/ }),

/***/ 98913:
/***/ ((__unused_webpack_module, exports) => {

"use strict";
/**
 * cli.js: Config that conform to commonly used CLI logging levels.
 *
 * (C) 2010 Charlie Robbins
 * MIT LICENCE
 */



/**
 * Default levels for the CLI configuration.
 * @type {Object}
 */
exports.levels = {
  error: 0,
  warn: 1,
  help: 2,
  data: 3,
  info: 4,
  debug: 5,
  prompt: 6,
  verbose: 7,
  input: 8,
  silly: 9
};

/**
 * Default colors for the CLI configuration.
 * @type {Object}
 */
exports.colors = {
  error: 'red',
  warn: 'yellow',
  help: 'cyan',
  data: 'grey',
  info: 'green',
  debug: 'blue',
  prompt: 'grey',
  verbose: 'cyan',
  input: 'grey',
  silly: 'magenta'
};


/***/ }),

/***/ 44815:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";
/**
 * index.js: Default settings for all levels that winston knows about.
 *
 * (C) 2010 Charlie Robbins
 * MIT LICENCE
 */



/**
 * Export config set for the CLI.
 * @type {Object}
 */
Object.defineProperty(exports, "cli", ({
  value: __nccwpck_require__(98913)
}));

/**
 * Export config set for npm.
 * @type {Object}
 */
Object.defineProperty(exports, "npm", ({
  value: __nccwpck_require__(74110)
}));

/**
 * Export config set for the syslog.
 * @type {Object}
 */
Object.defineProperty(exports, "syslog", ({
  value: __nccwpck_require__(61906)
}));


/***/ }),

/***/ 74110:
/***/ ((__unused_webpack_module, exports) => {

"use strict";
/**
 * npm.js: Config that conform to npm logging levels.
 *
 * (C) 2010 Charlie Robbins
 * MIT LICENCE
 */



/**
 * Default levels for the npm configuration.
 * @type {Object}
 */
exports.levels = {
  error: 0,
  warn: 1,
  info: 2,
  http: 3,
  verbose: 4,
  debug: 5,
  silly: 6
};

/**
 * Default levels for the npm configuration.
 * @type {Object}
 */
exports.colors = {
  error: 'red',
  warn: 'yellow',
  info: 'green',
  http: 'green',
  verbose: 'cyan',
  debug: 'blue',
  silly: 'magenta'
};


/***/ }),

/***/ 61906:
/***/ ((__unused_webpack_module, exports) => {

"use strict";
/**
 * syslog.js: Config that conform to syslog logging levels.
 *
 * (C) 2010 Charlie Robbins
 * MIT LICENCE
 */



/**
 * Default levels for the syslog configuration.
 * @type {Object}
 */
exports.levels = {
  emerg: 0,
  alert: 1,
  crit: 2,
  error: 3,
  warning: 4,
  notice: 5,
  info: 6,
  debug: 7
};

/**
 * Default levels for the syslog configuration.
 * @type {Object}
 */
exports.colors = {
  emerg: 'red',
  alert: 'yellow',
  crit: 'red',
  error: 'red',
  warning: 'red',
  notice: 'yellow',
  info: 'green',
  debug: 'blue'
};


/***/ }),

/***/ 28836:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


/**
 * A shareable symbol constant that can be used
 * as a non-enumerable / semi-hidden level identifier
 * to allow the readable level property to be mutable for
 * operations like colorization
 *
 * @type {Symbol}
 */
Object.defineProperty(exports, "LEVEL", ({
  value: Symbol.for('level')
}));

/**
 * A shareable symbol constant that can be used
 * as a non-enumerable / semi-hidden message identifier
 * to allow the final message property to not have
 * side effects on another.
 *
 * @type {Symbol}
 */
Object.defineProperty(exports, "MESSAGE", ({
  value: Symbol.for('message')
}));

/**
 * A shareable symbol constant that can be used
 * as a non-enumerable / semi-hidden message identifier
 * to allow the extracted splat property be hidden
 *
 * @type {Symbol}
 */
Object.defineProperty(exports, "SPLAT", ({
  value: Symbol.for('splat')
}));

/**
 * A shareable object constant  that can be used
 * as a standard configuration for winston@3.
 *
 * @type {Object}
 */
Object.defineProperty(exports, "configs", ({
  value: __nccwpck_require__(44815)
}));


/***/ }),

/***/ 27323:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";
/*!
 * type-is
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module dependencies.
 * @private
 */

var typer = __nccwpck_require__(90827)
var mime = __nccwpck_require__(14096)

/**
 * Module exports.
 * @public
 */

module.exports = typeofrequest
module.exports.is = typeis
module.exports.hasBody = hasbody
module.exports.normalize = normalize
module.exports.match = mimeMatch

/**
 * Compare a `value` content-type with `types`.
 * Each `type` can be an extension like `html`,
 * a special shortcut like `multipart` or `urlencoded`,
 * or a mime type.
 *
 * If no types match, `false` is returned.
 * Otherwise, the first `type` that matches is returned.
 *
 * @param {String} value
 * @param {Array} types
 * @public
 */

function typeis (value, types_) {
  var i
  var types = types_

  // remove parameters and normalize
  var val = tryNormalizeType(value)

  // no type or invalid
  if (!val) {
    return false
  }

  // support flattened arguments
  if (types && !Array.isArray(types)) {
    types = new Array(arguments.length - 1)
    for (i = 0; i < types.length; i++) {
      types[i] = arguments[i + 1]
    }
  }

  // no types, return the content type
  if (!types || !types.length) {
    return val
  }

  var type
  for (i = 0; i < types.length; i++) {
    if (mimeMatch(normalize(type = types[i]), val)) {
      return type[0] === '+' || type.indexOf('*') !== -1
        ? val
        : type
    }
  }

  // no matches
  return false
}

/**
 * Check if a request has a request body.
 * A request with a body __must__ either have `transfer-encoding`
 * or `content-length` headers set.
 * http://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html#sec4.3
 *
 * @param {Object} request
 * @return {Boolean}
 * @public
 */

function hasbody (req) {
  return req.headers['transfer-encoding'] !== undefined ||
    !isNaN(req.headers['content-length'])
}

/**
 * Check if the incoming request contains the "Content-Type"
 * header field, and it contains any of the give mime `type`s.
 * If there is no request body, `null` is returned.
 * If there is no content type, `false` is returned.
 * Otherwise, it returns the first `type` that matches.
 *
 * Examples:
 *
 *     // With Content-Type: text/html; charset=utf-8
 *     this.is('html'); // => 'html'
 *     this.is('text/html'); // => 'text/html'
 *     this.is('text/*', 'application/json'); // => 'text/html'
 *
 *     // When Content-Type is application/json
 *     this.is('json', 'urlencoded'); // => 'json'
 *     this.is('application/json'); // => 'application/json'
 *     this.is('html', 'application/*'); // => 'application/json'
 *
 *     this.is('html'); // => false
 *
 * @param {String|Array} types...
 * @return {String|false|null}
 * @public
 */

function typeofrequest (req, types_) {
  var types = types_

  // no body
  if (!hasbody(req)) {
    return null
  }

  // support flattened arguments
  if (arguments.length > 2) {
    types = new Array(arguments.length - 1)
    for (var i = 0; i < types.length; i++) {
      types[i] = arguments[i + 1]
    }
  }

  // request content type
  var value = req.headers['content-type']

  return typeis(value, types)
}

/**
 * Normalize a mime type.
 * If it's a shorthand, expand it to a valid mime type.
 *
 * In general, you probably want:
 *
 *   var type = is(req, ['urlencoded', 'json', 'multipart']);
 *
 * Then use the appropriate body parsers.
 * These three are the most common request body types
 * and are thus ensured to work.
 *
 * @param {String} type
 * @private
 */

function normalize (type) {
  if (typeof type !== 'string') {
    // invalid type
    return false
  }

  switch (type) {
    case 'urlencoded':
      return 'application/x-www-form-urlencoded'
    case 'multipart':
      return 'multipart/*'
  }

  if (type[0] === '+') {
    // "+json" -> "*/*+json" expando
    return '*/*' + type
  }

  return type.indexOf('/') === -1
    ? mime.lookup(type)
    : type
}

/**
 * Check if `expected` mime type
 * matches `actual` mime type with
 * wildcard and +suffix support.
 *
 * @param {String} expected
 * @param {String} actual
 * @return {Boolean}
 * @private
 */

function mimeMatch (expected, actual) {
  // invalid type
  if (expected === false) {
    return false
  }

  // split types
  var actualParts = actual.split('/')
  var expectedParts = expected.split('/')

  // invalid format
  if (actualParts.length !== 2 || expectedParts.length !== 2) {
    return false
  }

  // validate type
  if (expectedParts[0] !== '*' && expectedParts[0] !== actualParts[0]) {
    return false
  }

  // validate suffix wildcard
  if (expectedParts[1].substr(0, 2) === '*+') {
    return expectedParts[1].length <= actualParts[1].length + 1 &&
      expectedParts[1].substr(1) === actualParts[1].substr(1 - expectedParts[1].length)
  }

  // validate subtype
  if (expectedParts[1] !== '*' && expectedParts[1] !== actualParts[1]) {
    return false
  }

  return true
}

/**
 * Normalize a type and remove parameters.
 *
 * @param {string} value
 * @return {string}
 * @private
 */

function normalizeType (value) {
  // parse the type
  var type = typer.parse(value)

  // remove the parameters
  type.parameters = undefined

  // reformat it
  return typer.format(type)
}

/**
 * Try to normalize a type and remove parameters.
 *
 * @param {string} value
 * @return {string}
 * @private
 */

function tryNormalizeType (value) {
  if (!value) {
    return null
  }

  try {
    return normalizeType(value)
  } catch (err) {
    return null
  }
}


/***/ }),

/***/ 2317:
/***/ ((__unused_webpack_module, exports) => {

var undefined = (void 0); // Paranoia

// Beyond this value, index getters/setters (i.e. array[0], array[1]) are so slow to
// create, and consume so much memory, that the browser appears frozen.
var MAX_ARRAY_LENGTH = 1e5;

// Approximations of internal ECMAScript conversion functions
var ECMAScript = (function() {
  // Stash a copy in case other scripts modify these
  var opts = Object.prototype.toString,
      ophop = Object.prototype.hasOwnProperty;

  return {
    // Class returns internal [[Class]] property, used to avoid cross-frame instanceof issues:
    Class: function(v) { return opts.call(v).replace(/^\[object *|\]$/g, ''); },
    HasProperty: function(o, p) { return p in o; },
    HasOwnProperty: function(o, p) { return ophop.call(o, p); },
    IsCallable: function(o) { return typeof o === 'function'; },
    ToInt32: function(v) { return v >> 0; },
    ToUint32: function(v) { return v >>> 0; }
  };
}());

// Snapshot intrinsics
var LN2 = Math.LN2,
    abs = Math.abs,
    floor = Math.floor,
    log = Math.log,
    min = Math.min,
    pow = Math.pow,
    round = Math.round;

// ES5: lock down object properties
function configureProperties(obj) {
  if (getOwnPropNames && defineProp) {
    var props = getOwnPropNames(obj), i;
    for (i = 0; i < props.length; i += 1) {
      defineProp(obj, props[i], {
        value: obj[props[i]],
        writable: false,
        enumerable: false,
        configurable: false
      });
    }
  }
}

// emulate ES5 getter/setter API using legacy APIs
// http://blogs.msdn.com/b/ie/archive/2010/09/07/transitioning-existing-code-to-the-es5-getter-setter-apis.aspx
// (second clause tests for Object.defineProperty() in IE<9 that only supports extending DOM prototypes, but
// note that IE<9 does not support __defineGetter__ or __defineSetter__ so it just renders the method harmless)
var defineProp
if (Object.defineProperty && (function() {
      try {
        Object.defineProperty({}, 'x', {});
        return true;
      } catch (e) {
        return false;
      }
    })()) {
  defineProp = Object.defineProperty;
} else {
  defineProp = function(o, p, desc) {
    if (!o === Object(o)) throw new TypeError("Object.defineProperty called on non-object");
    if (ECMAScript.HasProperty(desc, 'get') && Object.prototype.__defineGetter__) { Object.prototype.__defineGetter__.call(o, p, desc.get); }
    if (ECMAScript.HasProperty(desc, 'set') && Object.prototype.__defineSetter__) { Object.prototype.__defineSetter__.call(o, p, desc.set); }
    if (ECMAScript.HasProperty(desc, 'value')) { o[p] = desc.value; }
    return o;
  };
}

var getOwnPropNames = Object.getOwnPropertyNames || function (o) {
  if (o !== Object(o)) throw new TypeError("Object.getOwnPropertyNames called on non-object");
  var props = [], p;
  for (p in o) {
    if (ECMAScript.HasOwnProperty(o, p)) {
      props.push(p);
    }
  }
  return props;
};

// ES5: Make obj[index] an alias for obj._getter(index)/obj._setter(index, value)
// for index in 0 ... obj.length
function makeArrayAccessors(obj) {
  if (!defineProp) { return; }

  if (obj.length > MAX_ARRAY_LENGTH) throw new RangeError("Array too large for polyfill");

  function makeArrayAccessor(index) {
    defineProp(obj, index, {
      'get': function() { return obj._getter(index); },
      'set': function(v) { obj._setter(index, v); },
      enumerable: true,
      configurable: false
    });
  }

  var i;
  for (i = 0; i < obj.length; i += 1) {
    makeArrayAccessor(i);
  }
}

// Internal conversion functions:
//    pack<Type>()   - take a number (interpreted as Type), output a byte array
//    unpack<Type>() - take a byte array, output a Type-like number

function as_signed(value, bits) { var s = 32 - bits; return (value << s) >> s; }
function as_unsigned(value, bits) { var s = 32 - bits; return (value << s) >>> s; }

function packI8(n) { return [n & 0xff]; }
function unpackI8(bytes) { return as_signed(bytes[0], 8); }

function packU8(n) { return [n & 0xff]; }
function unpackU8(bytes) { return as_unsigned(bytes[0], 8); }

function packU8Clamped(n) { n = round(Number(n)); return [n < 0 ? 0 : n > 0xff ? 0xff : n & 0xff]; }

function packI16(n) { return [(n >> 8) & 0xff, n & 0xff]; }
function unpackI16(bytes) { return as_signed(bytes[0] << 8 | bytes[1], 16); }

function packU16(n) { return [(n >> 8) & 0xff, n & 0xff]; }
function unpackU16(bytes) { return as_unsigned(bytes[0] << 8 | bytes[1], 16); }

function packI32(n) { return [(n >> 24) & 0xff, (n >> 16) & 0xff, (n >> 8) & 0xff, n & 0xff]; }
function unpackI32(bytes) { return as_signed(bytes[0] << 24 | bytes[1] << 16 | bytes[2] << 8 | bytes[3], 32); }

function packU32(n) { return [(n >> 24) & 0xff, (n >> 16) & 0xff, (n >> 8) & 0xff, n & 0xff]; }
function unpackU32(bytes) { return as_unsigned(bytes[0] << 24 | bytes[1] << 16 | bytes[2] << 8 | bytes[3], 32); }

function packIEEE754(v, ebits, fbits) {

  var bias = (1 << (ebits - 1)) - 1,
      s, e, f, ln,
      i, bits, str, bytes;

  function roundToEven(n) {
    var w = floor(n), f = n - w;
    if (f < 0.5)
      return w;
    if (f > 0.5)
      return w + 1;
    return w % 2 ? w + 1 : w;
  }

  // Compute sign, exponent, fraction
  if (v !== v) {
    // NaN
    // http://dev.w3.org/2006/webapi/WebIDL/#es-type-mapping
    e = (1 << ebits) - 1; f = pow(2, fbits - 1); s = 0;
  } else if (v === Infinity || v === -Infinity) {
    e = (1 << ebits) - 1; f = 0; s = (v < 0) ? 1 : 0;
  } else if (v === 0) {
    e = 0; f = 0; s = (1 / v === -Infinity) ? 1 : 0;
  } else {
    s = v < 0;
    v = abs(v);

    if (v >= pow(2, 1 - bias)) {
      e = min(floor(log(v) / LN2), 1023);
      f = roundToEven(v / pow(2, e) * pow(2, fbits));
      if (f / pow(2, fbits) >= 2) {
        e = e + 1;
        f = 1;
      }
      if (e > bias) {
        // Overflow
        e = (1 << ebits) - 1;
        f = 0;
      } else {
        // Normalized
        e = e + bias;
        f = f - pow(2, fbits);
      }
    } else {
      // Denormalized
      e = 0;
      f = roundToEven(v / pow(2, 1 - bias - fbits));
    }
  }

  // Pack sign, exponent, fraction
  bits = [];
  for (i = fbits; i; i -= 1) { bits.push(f % 2 ? 1 : 0); f = floor(f / 2); }
  for (i = ebits; i; i -= 1) { bits.push(e % 2 ? 1 : 0); e = floor(e / 2); }
  bits.push(s ? 1 : 0);
  bits.reverse();
  str = bits.join('');

  // Bits to bytes
  bytes = [];
  while (str.length) {
    bytes.push(parseInt(str.substring(0, 8), 2));
    str = str.substring(8);
  }
  return bytes;
}

function unpackIEEE754(bytes, ebits, fbits) {

  // Bytes to bits
  var bits = [], i, j, b, str,
      bias, s, e, f;

  for (i = bytes.length; i; i -= 1) {
    b = bytes[i - 1];
    for (j = 8; j; j -= 1) {
      bits.push(b % 2 ? 1 : 0); b = b >> 1;
    }
  }
  bits.reverse();
  str = bits.join('');

  // Unpack sign, exponent, fraction
  bias = (1 << (ebits - 1)) - 1;
  s = parseInt(str.substring(0, 1), 2) ? -1 : 1;
  e = parseInt(str.substring(1, 1 + ebits), 2);
  f = parseInt(str.substring(1 + ebits), 2);

  // Produce number
  if (e === (1 << ebits) - 1) {
    return f !== 0 ? NaN : s * Infinity;
  } else if (e > 0) {
    // Normalized
    return s * pow(2, e - bias) * (1 + f / pow(2, fbits));
  } else if (f !== 0) {
    // Denormalized
    return s * pow(2, -(bias - 1)) * (f / pow(2, fbits));
  } else {
    return s < 0 ? -0 : 0;
  }
}

function unpackF64(b) { return unpackIEEE754(b, 11, 52); }
function packF64(v) { return packIEEE754(v, 11, 52); }
function unpackF32(b) { return unpackIEEE754(b, 8, 23); }
function packF32(v) { return packIEEE754(v, 8, 23); }


//
// 3 The ArrayBuffer Type
//

(function() {

  /** @constructor */
  var ArrayBuffer = function ArrayBuffer(length) {
    length = ECMAScript.ToInt32(length);
    if (length < 0) throw new RangeError('ArrayBuffer size is not a small enough positive integer');

    this.byteLength = length;
    this._bytes = [];
    this._bytes.length = length;

    var i;
    for (i = 0; i < this.byteLength; i += 1) {
      this._bytes[i] = 0;
    }

    configureProperties(this);
  };

  exports.Az = exports.Az || ArrayBuffer;

  //
  // 4 The ArrayBufferView Type
  //

  // NOTE: this constructor is not exported
  /** @constructor */
  var ArrayBufferView = function ArrayBufferView() {
    //this.buffer = null;
    //this.byteOffset = 0;
    //this.byteLength = 0;
  };

  //
  // 5 The Typed Array View Types
  //

  function makeConstructor(bytesPerElement, pack, unpack) {
    // Each TypedArray type requires a distinct constructor instance with
    // identical logic, which this produces.

    var ctor;
    ctor = function(buffer, byteOffset, length) {
      var array, sequence, i, s;

      if (!arguments.length || typeof arguments[0] === 'number') {
        // Constructor(unsigned long length)
        this.length = ECMAScript.ToInt32(arguments[0]);
        if (length < 0) throw new RangeError('ArrayBufferView size is not a small enough positive integer');

        this.byteLength = this.length * this.BYTES_PER_ELEMENT;
        this.buffer = new ArrayBuffer(this.byteLength);
        this.byteOffset = 0;
      } else if (typeof arguments[0] === 'object' && arguments[0].constructor === ctor) {
        // Constructor(TypedArray array)
        array = arguments[0];

        this.length = array.length;
        this.byteLength = this.length * this.BYTES_PER_ELEMENT;
        this.buffer = new ArrayBuffer(this.byteLength);
        this.byteOffset = 0;

        for (i = 0; i < this.length; i += 1) {
          this._setter(i, array._getter(i));
        }
      } else if (typeof arguments[0] === 'object' &&
                 !(arguments[0] instanceof ArrayBuffer || ECMAScript.Class(arguments[0]) === 'ArrayBuffer')) {
        // Constructor(sequence<type> array)
        sequence = arguments[0];

        this.length = ECMAScript.ToUint32(sequence.length);
        this.byteLength = this.length * this.BYTES_PER_ELEMENT;
        this.buffer = new ArrayBuffer(this.byteLength);
        this.byteOffset = 0;

        for (i = 0; i < this.length; i += 1) {
          s = sequence[i];
          this._setter(i, Number(s));
        }
      } else if (typeof arguments[0] === 'object' &&
                 (arguments[0] instanceof ArrayBuffer || ECMAScript.Class(arguments[0]) === 'ArrayBuffer')) {
        // Constructor(ArrayBuffer buffer,
        //             optional unsigned long byteOffset, optional unsigned long length)
        this.buffer = buffer;

        this.byteOffset = ECMAScript.ToUint32(byteOffset);
        if (this.byteOffset > this.buffer.byteLength) {
          throw new RangeError("byteOffset out of range");
        }

        if (this.byteOffset % this.BYTES_PER_ELEMENT) {
          // The given byteOffset must be a multiple of the element
          // size of the specific type, otherwise an exception is raised.
          throw new RangeError("ArrayBuffer length minus the byteOffset is not a multiple of the element size.");
        }

        if (arguments.length < 3) {
          this.byteLength = this.buffer.byteLength - this.byteOffset;

          if (this.byteLength % this.BYTES_PER_ELEMENT) {
            throw new RangeError("length of buffer minus byteOffset not a multiple of the element size");
          }
          this.length = this.byteLength / this.BYTES_PER_ELEMENT;
        } else {
          this.length = ECMAScript.ToUint32(length);
          this.byteLength = this.length * this.BYTES_PER_ELEMENT;
        }

        if ((this.byteOffset + this.byteLength) > this.buffer.byteLength) {
          throw new RangeError("byteOffset and length reference an area beyond the end of the buffer");
        }
      } else {
        throw new TypeError("Unexpected argument type(s)");
      }

      this.constructor = ctor;

      configureProperties(this);
      makeArrayAccessors(this);
    };

    ctor.prototype = new ArrayBufferView();
    ctor.prototype.BYTES_PER_ELEMENT = bytesPerElement;
    ctor.prototype._pack = pack;
    ctor.prototype._unpack = unpack;
    ctor.BYTES_PER_ELEMENT = bytesPerElement;

    // getter type (unsigned long index);
    ctor.prototype._getter = function(index) {
      if (arguments.length < 1) throw new SyntaxError("Not enough arguments");

      index = ECMAScript.ToUint32(index);
      if (index >= this.length) {
        return undefined;
      }

      var bytes = [], i, o;
      for (i = 0, o = this.byteOffset + index * this.BYTES_PER_ELEMENT;
           i < this.BYTES_PER_ELEMENT;
           i += 1, o += 1) {
        bytes.push(this.buffer._bytes[o]);
      }
      return this._unpack(bytes);
    };

    // NONSTANDARD: convenience alias for getter: type get(unsigned long index);
    ctor.prototype.get = ctor.prototype._getter;

    // setter void (unsigned long index, type value);
    ctor.prototype._setter = function(index, value) {
      if (arguments.length < 2) throw new SyntaxError("Not enough arguments");

      index = ECMAScript.ToUint32(index);
      if (index >= this.length) {
        return undefined;
      }

      var bytes = this._pack(value), i, o;
      for (i = 0, o = this.byteOffset + index * this.BYTES_PER_ELEMENT;
           i < this.BYTES_PER_ELEMENT;
           i += 1, o += 1) {
        this.buffer._bytes[o] = bytes[i];
      }
    };

    // void set(TypedArray array, optional unsigned long offset);
    // void set(sequence<type> array, optional unsigned long offset);
    ctor.prototype.set = function(index, value) {
      if (arguments.length < 1) throw new SyntaxError("Not enough arguments");
      var array, sequence, offset, len,
          i, s, d,
          byteOffset, byteLength, tmp;

      if (typeof arguments[0] === 'object' && arguments[0].constructor === this.constructor) {
        // void set(TypedArray array, optional unsigned long offset);
        array = arguments[0];
        offset = ECMAScript.ToUint32(arguments[1]);

        if (offset + array.length > this.length) {
          throw new RangeError("Offset plus length of array is out of range");
        }

        byteOffset = this.byteOffset + offset * this.BYTES_PER_ELEMENT;
        byteLength = array.length * this.BYTES_PER_ELEMENT;

        if (array.buffer === this.buffer) {
          tmp = [];
          for (i = 0, s = array.byteOffset; i < byteLength; i += 1, s += 1) {
            tmp[i] = array.buffer._bytes[s];
          }
          for (i = 0, d = byteOffset; i < byteLength; i += 1, d += 1) {
            this.buffer._bytes[d] = tmp[i];
          }
        } else {
          for (i = 0, s = array.byteOffset, d = byteOffset;
               i < byteLength; i += 1, s += 1, d += 1) {
            this.buffer._bytes[d] = array.buffer._bytes[s];
          }
        }
      } else if (typeof arguments[0] === 'object' && typeof arguments[0].length !== 'undefined') {
        // void set(sequence<type> array, optional unsigned long offset);
        sequence = arguments[0];
        len = ECMAScript.ToUint32(sequence.length);
        offset = ECMAScript.ToUint32(arguments[1]);

        if (offset + len > this.length) {
          throw new RangeError("Offset plus length of array is out of range");
        }

        for (i = 0; i < len; i += 1) {
          s = sequence[i];
          this._setter(offset + i, Number(s));
        }
      } else {
        throw new TypeError("Unexpected argument type(s)");
      }
    };

    // TypedArray subarray(long begin, optional long end);
    ctor.prototype.subarray = function(start, end) {
      function clamp(v, min, max) { return v < min ? min : v > max ? max : v; }

      start = ECMAScript.ToInt32(start);
      end = ECMAScript.ToInt32(end);

      if (arguments.length < 1) { start = 0; }
      if (arguments.length < 2) { end = this.length; }

      if (start < 0) { start = this.length + start; }
      if (end < 0) { end = this.length + end; }

      start = clamp(start, 0, this.length);
      end = clamp(end, 0, this.length);

      var len = end - start;
      if (len < 0) {
        len = 0;
      }

      return new this.constructor(
        this.buffer, this.byteOffset + start * this.BYTES_PER_ELEMENT, len);
    };

    return ctor;
  }

  var Int8Array = makeConstructor(1, packI8, unpackI8);
  var Uint8Array = makeConstructor(1, packU8, unpackU8);
  var Uint8ClampedArray = makeConstructor(1, packU8Clamped, unpackU8);
  var Int16Array = makeConstructor(2, packI16, unpackI16);
  var Uint16Array = makeConstructor(2, packU16, unpackU16);
  var Int32Array = makeConstructor(4, packI32, unpackI32);
  var Uint32Array = makeConstructor(4, packU32, unpackU32);
  var Float32Array = makeConstructor(4, packF32, unpackF32);
  var Float64Array = makeConstructor(8, packF64, unpackF64);

  exports.fo = exports.fo || Int8Array;
  exports.SE = exports.SE || Uint8Array;
  exports.ER = exports.ER || Uint8ClampedArray;
  exports.ss = exports.ss || Int16Array;
  exports.hR = exports.hR || Uint16Array;
  exports.GM = exports.GM || Int32Array;
  exports.bt = exports.bt || Uint32Array;
  exports.l6 = exports.l6 || Float32Array;
  exports.aQ = exports.aQ || Float64Array;
}());

//
// 6 The DataView View Type
//

(function() {
  function r(array, index) {
    return ECMAScript.IsCallable(array.get) ? array.get(index) : array[index];
  }

  var IS_BIG_ENDIAN = (function() {
    var u16array = new(exports.hR)([0x1234]),
        u8array = new(exports.SE)(u16array.buffer);
    return r(u8array, 0) === 0x12;
  }());

  // Constructor(ArrayBuffer buffer,
  //             optional unsigned long byteOffset,
  //             optional unsigned long byteLength)
  /** @constructor */
  var DataView = function DataView(buffer, byteOffset, byteLength) {
    if (arguments.length === 0) {
      buffer = new exports.Az(0);
    } else if (!(buffer instanceof exports.Az || ECMAScript.Class(buffer) === 'ArrayBuffer')) {
      throw new TypeError("TypeError");
    }

    this.buffer = buffer || new exports.Az(0);

    this.byteOffset = ECMAScript.ToUint32(byteOffset);
    if (this.byteOffset > this.buffer.byteLength) {
      throw new RangeError("byteOffset out of range");
    }

    if (arguments.length < 3) {
      this.byteLength = this.buffer.byteLength - this.byteOffset;
    } else {
      this.byteLength = ECMAScript.ToUint32(byteLength);
    }

    if ((this.byteOffset + this.byteLength) > this.buffer.byteLength) {
      throw new RangeError("byteOffset and length reference an area beyond the end of the buffer");
    }

    configureProperties(this);
  };

  function makeGetter(arrayType) {
    return function(byteOffset, littleEndian) {

      byteOffset = ECMAScript.ToUint32(byteOffset);

      if (byteOffset + arrayType.BYTES_PER_ELEMENT > this.byteLength) {
        throw new RangeError("Array index out of range");
      }
      byteOffset += this.byteOffset;

      var uint8Array = new exports.SE(this.buffer, byteOffset, arrayType.BYTES_PER_ELEMENT),
          bytes = [], i;
      for (i = 0; i < arrayType.BYTES_PER_ELEMENT; i += 1) {
        bytes.push(r(uint8Array, i));
      }

      if (Boolean(littleEndian) === Boolean(IS_BIG_ENDIAN)) {
        bytes.reverse();
      }

      return r(new arrayType(new exports.SE(bytes).buffer), 0);
    };
  }

  DataView.prototype.getUint8 = makeGetter(exports.SE);
  DataView.prototype.getInt8 = makeGetter(exports.fo);
  DataView.prototype.getUint16 = makeGetter(exports.hR);
  DataView.prototype.getInt16 = makeGetter(exports.ss);
  DataView.prototype.getUint32 = makeGetter(exports.bt);
  DataView.prototype.getInt32 = makeGetter(exports.GM);
  DataView.prototype.getFloat32 = makeGetter(exports.l6);
  DataView.prototype.getFloat64 = makeGetter(exports.aQ);

  function makeSetter(arrayType) {
    return function(byteOffset, value, littleEndian) {

      byteOffset = ECMAScript.ToUint32(byteOffset);
      if (byteOffset + arrayType.BYTES_PER_ELEMENT > this.byteLength) {
        throw new RangeError("Array index out of range");
      }

      // Get bytes
      var typeArray = new arrayType([value]),
          byteArray = new exports.SE(typeArray.buffer),
          bytes = [], i, byteView;

      for (i = 0; i < arrayType.BYTES_PER_ELEMENT; i += 1) {
        bytes.push(r(byteArray, i));
      }

      // Flip if necessary
      if (Boolean(littleEndian) === Boolean(IS_BIG_ENDIAN)) {
        bytes.reverse();
      }

      // Write them
      byteView = new exports.SE(this.buffer, byteOffset, arrayType.BYTES_PER_ELEMENT);
      byteView.set(bytes);
    };
  }

  DataView.prototype.setUint8 = makeSetter(exports.SE);
  DataView.prototype.setInt8 = makeSetter(exports.fo);
  DataView.prototype.setUint16 = makeSetter(exports.hR);
  DataView.prototype.setInt16 = makeSetter(exports.ss);
  DataView.prototype.setUint32 = makeSetter(exports.bt);
  DataView.prototype.setInt32 = makeSetter(exports.GM);
  DataView.prototype.setFloat32 = makeSetter(exports.l6);
  DataView.prototype.setFloat64 = makeSetter(exports.aQ);

  exports.U$ = exports.U$ || DataView;

}());


/***/ }),

/***/ 66367:
/***/ ((module) => {

"use strict";
/*!
 * unpipe
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module exports.
 * @public
 */

module.exports = unpipe

/**
 * Determine if there are Node.js pipe-like data listeners.
 * @private
 */

function hasPipeDataListeners(stream) {
  var listeners = stream.listeners('data')

  for (var i = 0; i < listeners.length; i++) {
    if (listeners[i].name === 'ondata') {
      return true
    }
  }

  return false
}

/**
 * Unpipe a stream from all destinations.
 *
 * @param {object} stream
 * @public
 */

function unpipe(stream) {
  if (!stream) {
    throw new TypeError('argument stream is required')
  }

  if (typeof stream.unpipe === 'function') {
    // new-style
    stream.unpipe()
    return
  }

  // Node.js 0.8 hack
  if (!hasPipeDataListeners(stream)) {
    return
  }

  var listener
  var listeners = stream.listeners('close')

  for (var i = 0; i < listeners.length; i++) {
    listener = listeners[i]

    if (listener.name !== 'cleanup' && listener.name !== 'onclose') {
      continue
    }

    // invoke the listener
    listener.call(stream)
  }
}


/***/ }),

/***/ 24488:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {


/**
 * For Node.js, simply re-export the core `util.deprecate` function.
 */

module.exports = __nccwpck_require__(39023).deprecate;


/***/ }),

/***/ 51448:
/***/ ((module, exports) => {

/**
 * Merge object b with object a.
 *
 *     var a = { foo: 'bar' }
 *       , b = { bar: 'baz' };
 *
 *     merge(a, b);
 *     // => { foo: 'bar', bar: 'baz' }
 *
 * @param {Object} a
 * @param {Object} b
 * @return {Object}
 * @api public
 */

exports = module.exports = function(a, b){
  if (a && b) {
    for (var key in b) {
      a[key] = b[key];
    }
  }
  return a;
};


/***/ }),

/***/ 45116:
/***/ ((module) => {

"use strict";
/*!
 * vary
 * Copyright(c) 2014-2017 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module exports.
 */

module.exports = vary
module.exports.append = append

/**
 * RegExp to match field-name in RFC 7230 sec 3.2
 *
 * field-name    = token
 * token         = 1*tchar
 * tchar         = "!" / "#" / "$" / "%" / "&" / "'" / "*"
 *               / "+" / "-" / "." / "^" / "_" / "`" / "|" / "~"
 *               / DIGIT / ALPHA
 *               ; any VCHAR, except delimiters
 */

var FIELD_NAME_REGEXP = /^[!#$%&'*+\-.^_`|~0-9A-Za-z]+$/

/**
 * Append a field to a vary header.
 *
 * @param {String} header
 * @param {String|Array} field
 * @return {String}
 * @public
 */

function append (header, field) {
  if (typeof header !== 'string') {
    throw new TypeError('header argument is required')
  }

  if (!field) {
    throw new TypeError('field argument is required')
  }

  // get fields array
  var fields = !Array.isArray(field)
    ? parse(String(field))
    : field

  // assert on invalid field names
  for (var j = 0; j < fields.length; j++) {
    if (!FIELD_NAME_REGEXP.test(fields[j])) {
      throw new TypeError('field argument contains an invalid header name')
    }
  }

  // existing, unspecified vary
  if (header === '*') {
    return header
  }

  // enumerate current values
  var val = header
  var vals = parse(header.toLowerCase())

  // unspecified vary
  if (fields.indexOf('*') !== -1 || vals.indexOf('*') !== -1) {
    return '*'
  }

  for (var i = 0; i < fields.length; i++) {
    var fld = fields[i].toLowerCase()

    // append value (case-preserving)
    if (vals.indexOf(fld) === -1) {
      vals.push(fld)
      val = val
        ? val + ', ' + fields[i]
        : fields[i]
    }
  }

  return val
}

/**
 * Parse a vary header into an array.
 *
 * @param {String} header
 * @return {Array}
 * @private
 */

function parse (header) {
  var end = 0
  var list = []
  var start = 0

  // gather tokens
  for (var i = 0, len = header.length; i < len; i++) {
    switch (header.charCodeAt(i)) {
      case 0x20: /*   */
        if (start === end) {
          start = end = i + 1
        }
        break
      case 0x2c: /* , */
        list.push(header.substring(start, end))
        start = end = i + 1
        break
      default:
        end = i + 1
        break
    }
  }

  // final token
  list.push(header.substring(start, end))

  return list
}

/**
 * Mark that a request is varied on a header field.
 *
 * @param {Object} res
 * @param {String|Array} field
 * @public
 */

function vary (res, field) {
  if (!res || !res.getHeader || !res.setHeader) {
    // quack quack
    throw new TypeError('res argument is required')
  }

  // get existing header
  var val = res.getHeader('Vary') || ''
  var header = Array.isArray(val)
    ? val.join(', ')
    : String(val)

  // set new header
  if ((val = append(header, field))) {
    res.setHeader('Vary', val)
  }
}


/***/ }),

/***/ 3588:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


// Expose modern transport directly as the export
module.exports = __nccwpck_require__(78241);

// Expose legacy stream
module.exports.LegacyTransportStream = __nccwpck_require__(56493);


/***/ }),

/***/ 56493:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


const util = __nccwpck_require__(39023);
const { LEVEL } = __nccwpck_require__(28836);
const TransportStream = __nccwpck_require__(78241);

/**
 * Constructor function for the LegacyTransportStream. This is an internal
 * wrapper `winston >= 3` uses to wrap older transports implementing
 * log(level, message, meta).
 * @param {Object} options - Options for this TransportStream instance.
 * @param {Transpot} options.transport - winston@2 or older Transport to wrap.
 */

const LegacyTransportStream = module.exports = function LegacyTransportStream(options = {}) {
  TransportStream.call(this, options);
  if (!options.transport || typeof options.transport.log !== 'function') {
    throw new Error('Invalid transport, must be an object with a log method.');
  }

  this.transport = options.transport;
  this.level = this.level || options.transport.level;
  this.handleExceptions = this.handleExceptions || options.transport.handleExceptions;

  // Display our deprecation notice.
  this._deprecated();

  // Properly bubble up errors from the transport to the
  // LegacyTransportStream instance, but only once no matter how many times
  // this transport is shared.
  function transportError(err) {
    this.emit('error', err, this.transport);
  }

  if (!this.transport.__winstonError) {
    this.transport.__winstonError = transportError.bind(this);
    this.transport.on('error', this.transport.__winstonError);
  }
};

/*
 * Inherit from TransportStream using Node.js built-ins
 */
util.inherits(LegacyTransportStream, TransportStream);

/**
 * Writes the info object to our transport instance.
 * @param {mixed} info - TODO: add param description.
 * @param {mixed} enc - TODO: add param description.
 * @param {function} callback - TODO: add param description.
 * @returns {undefined}
 * @private
 */
LegacyTransportStream.prototype._write = function _write(info, enc, callback) {
  if (this.silent || (info.exception === true && !this.handleExceptions)) {
    return callback(null);
  }

  // Remark: This has to be handled in the base transport now because we
  // cannot conditionally write to our pipe targets as stream.
  if (!this.level || this.levels[this.level] >= this.levels[info[LEVEL]]) {
    this.transport.log(info[LEVEL], info.message, info, this._nop);
  }

  callback(null);
};

/**
 * Writes the batch of info objects (i.e. "object chunks") to our transport
 * instance after performing any necessary filtering.
 * @param {mixed} chunks - TODO: add params description.
 * @param {function} callback - TODO: add params description.
 * @returns {mixed} - TODO: add returns description.
 * @private
 */
LegacyTransportStream.prototype._writev = function _writev(chunks, callback) {
  for (let i = 0; i < chunks.length; i++) {
    if (this._accept(chunks[i])) {
      this.transport.log(
        chunks[i].chunk[LEVEL],
        chunks[i].chunk.message,
        chunks[i].chunk,
        this._nop
      );
      chunks[i].callback();
    }
  }

  return callback(null);
};

/**
 * Displays a deprecation notice. Defined as a function so it can be
 * overriden in tests.
 * @returns {undefined}
 */
LegacyTransportStream.prototype._deprecated = function _deprecated() {
  // eslint-disable-next-line no-console
  console.error([
    `${this.transport.name} is a legacy winston transport. Consider upgrading: `,
    '- Upgrade docs: https://github.com/winstonjs/winston/blob/master/UPGRADE-3.0.md'
  ].join('\n'));
};

/**
 * Clean up error handling state on the legacy transport associated
 * with this instance.
 * @returns {undefined}
 */
LegacyTransportStream.prototype.close = function close() {
  if (this.transport.close) {
    this.transport.close();
  }

  if (this.transport.__winstonError) {
    this.transport.removeListener('error', this.transport.__winstonError);
    this.transport.__winstonError = null;
  }
};


/***/ }),

/***/ 78241:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


const util = __nccwpck_require__(39023);
const Writable = __nccwpck_require__(38797);
const { LEVEL } = __nccwpck_require__(28836);

/**
 * Constructor function for the TransportStream. This is the base prototype
 * that all `winston >= 3` transports should inherit from.
 * @param {Object} options - Options for this TransportStream instance
 * @param {String} options.level - Highest level according to RFC5424.
 * @param {Boolean} options.handleExceptions - If true, info with
 * { exception: true } will be written.
 * @param {Function} options.log - Custom log function for simple Transport
 * creation
 * @param {Function} options.close - Called on "unpipe" from parent.
 */
const TransportStream = module.exports = function TransportStream(options = {}) {
  Writable.call(this, { objectMode: true, highWaterMark: options.highWaterMark });

  this.format = options.format;
  this.level = options.level;
  this.handleExceptions = options.handleExceptions;
  this.handleRejections = options.handleRejections;
  this.silent = options.silent;

  if (options.log) this.log = options.log;
  if (options.logv) this.logv = options.logv;
  if (options.close) this.close = options.close;

  // Get the levels from the source we are piped from.
  this.once('pipe', logger => {
    // Remark (indexzero): this bookkeeping can only support multiple
    // Logger parents with the same `levels`. This comes into play in
    // the `winston.Container` code in which `container.add` takes
    // a fully realized set of options with pre-constructed TransportStreams.
    this.levels = logger.levels;
    this.parent = logger;
  });

  // If and/or when the transport is removed from this instance
  this.once('unpipe', src => {
    // Remark (indexzero): this bookkeeping can only support multiple
    // Logger parents with the same `levels`. This comes into play in
    // the `winston.Container` code in which `container.add` takes
    // a fully realized set of options with pre-constructed TransportStreams.
    if (src === this.parent) {
      this.parent = null;
      if (this.close) {
        this.close();
      }
    }
  });
};

/*
 * Inherit from Writeable using Node.js built-ins
 */
util.inherits(TransportStream, Writable);

/**
 * Writes the info object to our transport instance.
 * @param {mixed} info - TODO: add param description.
 * @param {mixed} enc - TODO: add param description.
 * @param {function} callback - TODO: add param description.
 * @returns {undefined}
 * @private
 */
TransportStream.prototype._write = function _write(info, enc, callback) {
  if (this.silent || (info.exception === true && !this.handleExceptions)) {
    return callback(null);
  }

  // Remark: This has to be handled in the base transport now because we
  // cannot conditionally write to our pipe targets as stream. We always
  // prefer any explicit level set on the Transport itself falling back to
  // any level set on the parent.
  const level = this.level || (this.parent && this.parent.level);

  if (!level || this.levels[level] >= this.levels[info[LEVEL]]) {
    if (info && !this.format) {
      return this.log(info, callback);
    }

    let errState;
    let transformed;

    // We trap(and re-throw) any errors generated by the user-provided format, but also
    // guarantee that the streams callback is invoked so that we can continue flowing.
    try {
      transformed = this.format.transform(Object.assign({}, info), this.format.options);
    } catch (err) {
      errState = err;
    }

    if (errState || !transformed) {
      // eslint-disable-next-line callback-return
      callback();
      if (errState) throw errState;
      return;
    }

    return this.log(transformed, callback);
  }
  this._writableState.sync = false;
  return callback(null);
};

/**
 * Writes the batch of info objects (i.e. "object chunks") to our transport
 * instance after performing any necessary filtering.
 * @param {mixed} chunks - TODO: add params description.
 * @param {function} callback - TODO: add params description.
 * @returns {mixed} - TODO: add returns description.
 * @private
 */
TransportStream.prototype._writev = function _writev(chunks, callback) {
  if (this.logv) {
    const infos = chunks.filter(this._accept, this);
    if (!infos.length) {
      return callback(null);
    }

    // Remark (indexzero): from a performance perspective if Transport
    // implementers do choose to implement logv should we make it their
    // responsibility to invoke their format?
    return this.logv(infos, callback);
  }

  for (let i = 0; i < chunks.length; i++) {
    if (!this._accept(chunks[i])) continue;

    if (chunks[i].chunk && !this.format) {
      this.log(chunks[i].chunk, chunks[i].callback);
      continue;
    }

    let errState;
    let transformed;

    // We trap(and re-throw) any errors generated by the user-provided format, but also
    // guarantee that the streams callback is invoked so that we can continue flowing.
    try {
      transformed = this.format.transform(
        Object.assign({}, chunks[i].chunk),
        this.format.options
      );
    } catch (err) {
      errState = err;
    }

    if (errState || !transformed) {
      // eslint-disable-next-line callback-return
      chunks[i].callback();
      if (errState) {
        // eslint-disable-next-line callback-return
        callback(null);
        throw errState;
      }
    } else {
      this.log(transformed, chunks[i].callback);
    }
  }

  return callback(null);
};

/**
 * Predicate function that returns true if the specfied `info` on the
 * WriteReq, `write`, should be passed down into the derived
 * TransportStream's I/O via `.log(info, callback)`.
 * @param {WriteReq} write - winston@3 Node.js WriteReq for the `info` object
 * representing the log message.
 * @returns {Boolean} - Value indicating if the `write` should be accepted &
 * logged.
 */
TransportStream.prototype._accept = function _accept(write) {
  const info = write.chunk;
  if (this.silent) {
    return false;
  }

  // We always prefer any explicit level set on the Transport itself
  // falling back to any level set on the parent.
  const level = this.level || (this.parent && this.parent.level);

  // Immediately check the average case: log level filtering.
  if (
    info.exception === true ||
    !level ||
    this.levels[level] >= this.levels[info[LEVEL]]
  ) {
    // Ensure the info object is valid based on `{ exception }`:
    // 1. { handleExceptions: true }: all `info` objects are valid
    // 2. { exception: false }: accepted by all transports.
    if (this.handleExceptions || info.exception !== true) {
      return true;
    }
  }

  return false;
};

/**
 * _nop is short for "No operation"
 * @returns {Boolean} Intentionally false.
 */
TransportStream.prototype._nop = function _nop() {
  // eslint-disable-next-line no-undefined
  return void undefined;
};


/***/ }),

/***/ 34240:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";
/**
 * winston.js: Top-level include defining Winston.
 *
 * (C) 2010 Charlie Robbins
 * MIT LICENCE
 */



const logform = __nccwpck_require__(45440);
const { warn } = __nccwpck_require__(63254);

/**
 * Expose version. Use `require` method for `webpack` support.
 * @type {string}
 */
exports.version = __nccwpck_require__(6256).version;
/**
 * Include transports defined by default by winston
 * @type {Array}
 */
exports.transports = __nccwpck_require__(27522);
/**
 * Expose utility methods
 * @type {Object}
 */
exports.config = __nccwpck_require__(51942);
/**
 * Hoist format-related functionality from logform.
 * @type {Object}
 */
exports.addColors = logform.levels;
/**
 * Hoist format-related functionality from logform.
 * @type {Object}
 */
exports.format = logform.format;
/**
 * Expose core Logging-related prototypes.
 * @type {function}
 */
exports.createLogger = __nccwpck_require__(74092);
/**
 * Expose core Logging-related prototypes.
 * @type {function}
 */
exports.Logger = __nccwpck_require__(51279);
/**
 * Expose core Logging-related prototypes.
 * @type {Object}
 */
exports.ExceptionHandler = __nccwpck_require__(71019);
/**
 * Expose core Logging-related prototypes.
 * @type {Object}
 */
exports.RejectionHandler = __nccwpck_require__(55421);
/**
 * Expose core Logging-related prototypes.
 * @type {Container}
 */
exports.Container = __nccwpck_require__(70632);
/**
 * Expose core Logging-related prototypes.
 * @type {Object}
 */
exports.Transport = __nccwpck_require__(3588);
/**
 * We create and expose a default `Container` to `winston.loggers` so that the
 * programmer may manage multiple `winston.Logger` instances without any
 * additional overhead.
 * @example
 *   // some-file1.js
 *   const logger = require('winston').loggers.get('something');
 *
 *   // some-file2.js
 *   const logger = require('winston').loggers.get('something');
 */
exports.loggers = new exports.Container();

/**
 * We create and expose a 'defaultLogger' so that the programmer may do the
 * following without the need to create an instance of winston.Logger directly:
 * @example
 *   const winston = require('winston');
 *   winston.log('info', 'some message');
 *   winston.error('some error');
 */
const defaultLogger = exports.createLogger();

// Pass through the target methods onto `winston.
Object.keys(exports.config.npm.levels)
  .concat([
    'log',
    'query',
    'stream',
    'add',
    'remove',
    'clear',
    'profile',
    'startTimer',
    'handleExceptions',
    'unhandleExceptions',
    'handleRejections',
    'unhandleRejections',
    'configure',
    'child'
  ])
  .forEach(
    method => (exports[method] = (...args) => defaultLogger[method](...args))
  );

/**
 * Define getter / setter for the default logger level which need to be exposed
 * by winston.
 * @type {string}
 */
Object.defineProperty(exports, "level", ({
  get() {
    return defaultLogger.level;
  },
  set(val) {
    defaultLogger.level = val;
  }
}));

/**
 * Define getter for `exceptions` which replaces `handleExceptions` and
 * `unhandleExceptions`.
 * @type {Object}
 */
Object.defineProperty(exports, "exceptions", ({
  get() {
    return defaultLogger.exceptions;
  }
}));

/**
 * Define getter for `rejections` which replaces `handleRejections` and
 * `unhandleRejections`.
 * @type {Object}
 */
Object.defineProperty(exports, "rejections", ({
  get() {
    return defaultLogger.rejections;
  }
}));

/**
 * Define getters / setters for appropriate properties of the default logger
 * which need to be exposed by winston.
 * @type {Logger}
 */
['exitOnError'].forEach(prop => {
  Object.defineProperty(exports, prop, {
    get() {
      return defaultLogger[prop];
    },
    set(val) {
      defaultLogger[prop] = val;
    }
  });
});

/**
 * The default transports and exceptionHandlers for the default winston logger.
 * @type {Object}
 */
Object.defineProperty(exports, "default", ({
  get() {
    return {
      exceptionHandlers: defaultLogger.exceptionHandlers,
      rejectionHandlers: defaultLogger.rejectionHandlers,
      transports: defaultLogger.transports
    };
  }
}));

// Have friendlier breakage notices for properties that were exposed by default
// on winston < 3.0.
warn.deprecated(exports, 'setLevels');
warn.forFunctions(exports, 'useFormat', ['cli']);
warn.forProperties(exports, 'useFormat', ['padLevels', 'stripColors']);
warn.forFunctions(exports, 'deprecated', [
  'addRewriter',
  'addFilter',
  'clone',
  'extend'
]);
warn.forProperties(exports, 'deprecated', ['emitErrs', 'levelLength']);



/***/ }),

/***/ 63254:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";
/**
 * common.js: Internal helper and utility functions for winston.
 *
 * (C) 2010 Charlie Robbins
 * MIT LICENCE
 */



const { format } = __nccwpck_require__(39023);

/**
 * Set of simple deprecation notices and a way to expose them for a set of
 * properties.
 * @type {Object}
 * @private
 */
exports.warn = {
  deprecated(prop) {
    return () => {
      throw new Error(format('{ %s } was removed in winston@3.0.0.', prop));
    };
  },
  useFormat(prop) {
    return () => {
      throw new Error([
        format('{ %s } was removed in winston@3.0.0.', prop),
        'Use a custom winston.format = winston.format(function) instead.'
      ].join('\n'));
    };
  },
  forFunctions(obj, type, props) {
    props.forEach(prop => {
      obj[prop] = exports.warn[type](prop);
    });
  },
  forProperties(obj, type, props) {
    props.forEach(prop => {
      const notice = exports.warn[type](prop);
      Object.defineProperty(obj, prop, {
        get: notice,
        set: notice
      });
    });
  }
};


/***/ }),

/***/ 51942:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";
/**
 * index.js: Default settings for all levels that winston knows about.
 *
 * (C) 2010 Charlie Robbins
 * MIT LICENCE
 */



const logform = __nccwpck_require__(45440);
const { configs } = __nccwpck_require__(28836);

/**
 * Export config set for the CLI.
 * @type {Object}
 */
exports.cli = logform.levels(configs.cli);

/**
 * Export config set for npm.
 * @type {Object}
 */
exports.npm = logform.levels(configs.npm);

/**
 * Export config set for the syslog.
 * @type {Object}
 */
exports.syslog = logform.levels(configs.syslog);

/**
 * Hoist addColors from logform where it was refactored into in winston@3.
 * @type {Object}
 */
exports.addColors = logform.levels;


/***/ }),

/***/ 70632:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";
/**
 * container.js: Inversion of control container for winston logger instances.
 *
 * (C) 2010 Charlie Robbins
 * MIT LICENCE
 */



const createLogger = __nccwpck_require__(74092);

/**
 * Inversion of control container for winston logger instances.
 * @type {Container}
 */
module.exports = class Container {
  /**
   * Constructor function for the Container object responsible for managing a
   * set of `winston.Logger` instances based on string ids.
   * @param {!Object} [options={}] - Default pass-thru options for Loggers.
   */
  constructor(options = {}) {
    this.loggers = new Map();
    this.options = options;
  }

  /**
   * Retrieves a `winston.Logger` instance for the specified `id`. If an
   * instance does not exist, one is created.
   * @param {!string} id - The id of the Logger to get.
   * @param {?Object} [options] - Options for the Logger instance.
   * @returns {Logger} - A configured Logger instance with a specified id.
   */
  add(id, options) {
    if (!this.loggers.has(id)) {
      // Remark: Simple shallow clone for configuration options in case we pass
      // in instantiated protoypal objects
      options = Object.assign({}, options || this.options);
      const existing = options.transports || this.options.transports;

      // Remark: Make sure if we have an array of transports we slice it to
      // make copies of those references.
      if (existing) {
        options.transports = Array.isArray(existing) ? existing.slice() : [existing];
      } else {
        options.transports = [];
      }

      const logger = createLogger(options);
      logger.on('close', () => this._delete(id));
      this.loggers.set(id, logger);
    }

    return this.loggers.get(id);
  }

  /**
   * Retreives a `winston.Logger` instance for the specified `id`. If
   * an instance does not exist, one is created.
   * @param {!string} id - The id of the Logger to get.
   * @param {?Object} [options] - Options for the Logger instance.
   * @returns {Logger} - A configured Logger instance with a specified id.
   */
  get(id, options) {
    return this.add(id, options);
  }

  /**
   * Check if the container has a logger with the id.
   * @param {?string} id - The id of the Logger instance to find.
   * @returns {boolean} - Boolean value indicating if this instance has a
   * logger with the specified `id`.
   */
  has(id) {
    return !!this.loggers.has(id);
  }

  /**
   * Closes a `Logger` instance with the specified `id` if it exists.
   * If no `id` is supplied then all Loggers are closed.
   * @param {?string} id - The id of the Logger instance to close.
   * @returns {undefined}
   */
  close(id) {
    if (id) {
      return this._removeLogger(id);
    }

    this.loggers.forEach((val, key) => this._removeLogger(key));
  }

  /**
   * Remove a logger based on the id.
   * @param {!string} id - The id of the logger to remove.
   * @returns {undefined}
   * @private
   */
  _removeLogger(id) {
    if (!this.loggers.has(id)) {
      return;
    }

    const logger = this.loggers.get(id);
    logger.close();
    this._delete(id);
  }

  /**
   * Deletes a `Logger` instance with the specified `id`.
   * @param {!string} id - The id of the Logger instance to delete from
   * container.
   * @returns {undefined}
   * @private
   */
  _delete(id) {
    this.loggers.delete(id);
  }
};


/***/ }),

/***/ 74092:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";
/**
 * create-logger.js: Logger factory for winston logger instances.
 *
 * (C) 2010 Charlie Robbins
 * MIT LICENCE
 */



const { LEVEL } = __nccwpck_require__(28836);
const config = __nccwpck_require__(51942);
const Logger = __nccwpck_require__(51279);
const debug = __nccwpck_require__(1379)('winston:create-logger');

function isLevelEnabledFunctionName(level) {
  return 'is' + level.charAt(0).toUpperCase() + level.slice(1) + 'Enabled';
}

/**
 * Create a new instance of a winston Logger. Creates a new
 * prototype for each instance.
 * @param {!Object} opts - Options for the created logger.
 * @returns {Logger} - A newly created logger instance.
 */
module.exports = function (opts = {}) {
  //
  // Default levels: npm
  //
  opts.levels = opts.levels || config.npm.levels;

  /**
   * DerivedLogger to attach the logs level methods.
   * @type {DerivedLogger}
   * @extends {Logger}
   */
  class DerivedLogger extends Logger {
    /**
     * Create a new class derived logger for which the levels can be attached to
     * the prototype of. This is a V8 optimization that is well know to increase
     * performance of prototype functions.
     * @param {!Object} options - Options for the created logger.
     */
    constructor(options) {
      super(options);
    }
  }

  const logger = new DerivedLogger(opts);

  //
  // Create the log level methods for the derived logger.
  //
  Object.keys(opts.levels).forEach(function (level) {
    debug('Define prototype method for "%s"', level);
    if (level === 'log') {
      // eslint-disable-next-line no-console
      console.warn('Level "log" not defined: conflicts with the method "log". Use a different level name.');
      return;
    }

    //
    // Define prototype methods for each log level e.g.:
    // logger.log('info', msg) implies these methods are defined:
    // - logger.info(msg)
    // - logger.isInfoEnabled()
    //
    // Remark: to support logger.child this **MUST** be a function
    // so it'll always be called on the instance instead of a fixed
    // place in the prototype chain.
    //
    DerivedLogger.prototype[level] = function (...args) {
      // Prefer any instance scope, but default to "root" logger
      const self = this || logger;

      // Optimize the hot-path which is the single object.
      if (args.length === 1) {
        const [msg] = args;
        const info = msg && msg.message && msg || { message: msg };
        info.level = info[LEVEL] = level;
        self._addDefaultMeta(info);
        self.write(info);
        return (this || logger);
      }

      // When provided nothing assume the empty string
      if (args.length === 0) {
        self.log(level, '');
        return self;
      }

      // Otherwise build argument list which could potentially conform to
      // either:
      // . v3 API: log(obj)
      // 2. v1/v2 API: log(level, msg, ... [string interpolate], [{metadata}], [callback])
      return self.log(level, ...args);
    };

    DerivedLogger.prototype[isLevelEnabledFunctionName(level)] = function () {
      return (this || logger).isLevelEnabled(level);
    };
  });

  return logger;
};


/***/ }),

/***/ 71019:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";
/**
 * exception-handler.js: Object for handling uncaughtException events.
 *
 * (C) 2010 Charlie Robbins
 * MIT LICENCE
 */



const os = __nccwpck_require__(70857);
const asyncForEach = __nccwpck_require__(63650);
const debug = __nccwpck_require__(1379)('winston:exception');
const once = __nccwpck_require__(38186);
const stackTrace = __nccwpck_require__(39428);
const ExceptionStream = __nccwpck_require__(391);

/**
 * Object for handling uncaughtException events.
 * @type {ExceptionHandler}
 */
module.exports = class ExceptionHandler {
  /**
   * TODO: add contructor description
   * @param {!Logger} logger - TODO: add param description
   */
  constructor(logger) {
    if (!logger) {
      throw new Error('Logger is required to handle exceptions');
    }

    this.logger = logger;
    this.handlers = new Map();
  }

  /**
   * Handles `uncaughtException` events for the current process by adding any
   * handlers passed in.
   * @returns {undefined}
   */
  handle(...args) {
    args.forEach(arg => {
      if (Array.isArray(arg)) {
        return arg.forEach(handler => this._addHandler(handler));
      }

      this._addHandler(arg);
    });

    if (!this.catcher) {
      this.catcher = this._uncaughtException.bind(this);
      process.on('uncaughtException', this.catcher);
    }
  }

  /**
   * Removes any handlers to `uncaughtException` events for the current
   * process. This does not modify the state of the `this.handlers` set.
   * @returns {undefined}
   */
  unhandle() {
    if (this.catcher) {
      process.removeListener('uncaughtException', this.catcher);
      this.catcher = false;

      Array.from(this.handlers.values())
        .forEach(wrapper => this.logger.unpipe(wrapper));
    }
  }

  /**
   * TODO: add method description
   * @param {Error} err - Error to get information about.
   * @returns {mixed} - TODO: add return description.
   */
  getAllInfo(err) {
    let message = null;
    if (err) {
      message = typeof err === 'string' ? err : err.message;
    }

    return {
      error: err,
      // TODO (indexzero): how do we configure this?
      level: 'error',
      message: [
        `uncaughtException: ${(message || '(no error message)')}`,
        err && err.stack || '  No stack trace'
      ].join('\n'),
      stack: err && err.stack,
      exception: true,
      date: new Date().toString(),
      process: this.getProcessInfo(),
      os: this.getOsInfo(),
      trace: this.getTrace(err)
    };
  }

  /**
   * Gets all relevant process information for the currently running process.
   * @returns {mixed} - TODO: add return description.
   */
  getProcessInfo() {
    return {
      pid: process.pid,
      uid: process.getuid ? process.getuid() : null,
      gid: process.getgid ? process.getgid() : null,
      cwd: process.cwd(),
      execPath: process.execPath,
      version: process.version,
      argv: process.argv,
      memoryUsage: process.memoryUsage()
    };
  }

  /**
   * Gets all relevant OS information for the currently running process.
   * @returns {mixed} - TODO: add return description.
   */
  getOsInfo() {
    return {
      loadavg: os.loadavg(),
      uptime: os.uptime()
    };
  }

  /**
   * Gets a stack trace for the specified error.
   * @param {mixed} err - TODO: add param description.
   * @returns {mixed} - TODO: add return description.
   */
  getTrace(err) {
    const trace = err ? stackTrace.parse(err) : stackTrace.get();
    return trace.map(site => {
      return {
        column: site.getColumnNumber(),
        file: site.getFileName(),
        function: site.getFunctionName(),
        line: site.getLineNumber(),
        method: site.getMethodName(),
        native: site.isNative()
      };
    });
  }

  /**
   * Helper method to add a transport as an exception handler.
   * @param {Transport} handler - The transport to add as an exception handler.
   * @returns {void}
   */
  _addHandler(handler) {
    if (!this.handlers.has(handler)) {
      handler.handleExceptions = true;
      const wrapper = new ExceptionStream(handler);
      this.handlers.set(handler, wrapper);
      this.logger.pipe(wrapper);
    }
  }

  /**
   * Logs all relevant information around the `err` and exits the current
   * process.
   * @param {Error} err - Error to handle
   * @returns {mixed} - TODO: add return description.
   * @private
   */
  _uncaughtException(err) {
    const info = this.getAllInfo(err);
    const handlers = this._getExceptionHandlers();
    // Calculate if we should exit on this error
    let doExit = typeof this.logger.exitOnError === 'function'
      ? this.logger.exitOnError(err)
      : this.logger.exitOnError;
    let timeout;

    if (!handlers.length && doExit) {
      // eslint-disable-next-line no-console
      console.warn('winston: exitOnError cannot be true with no exception handlers.');
      // eslint-disable-next-line no-console
      console.warn('winston: not exiting process.');
      doExit = false;
    }

    function gracefulExit() {
      debug('doExit', doExit);
      debug('process._exiting', process._exiting);

      if (doExit && !process._exiting) {
        // Remark: Currently ignoring any exceptions from transports when
        // catching uncaught exceptions.
        if (timeout) {
          clearTimeout(timeout);
        }
        // eslint-disable-next-line no-process-exit
        process.exit(1);
      }
    }

    if (!handlers || handlers.length === 0) {
      return process.nextTick(gracefulExit);
    }

    // Log to all transports attempting to listen for when they are completed.
    asyncForEach(handlers, (handler, next) => {
      const done = once(next);
      const transport = handler.transport || handler;

      // Debug wrapping so that we can inspect what's going on under the covers.
      function onDone(event) {
        return () => {
          debug(event);
          done();
        };
      }

      transport._ending = true;
      transport.once('finish', onDone('finished'));
      transport.once('error', onDone('error'));
    }, () => doExit && gracefulExit());

    this.logger.log(info);

    // If exitOnError is true, then only allow the logging of exceptions to
    // take up to `3000ms`.
    if (doExit) {
      timeout = setTimeout(gracefulExit, 3000);
    }
  }

  /**
   * Returns the list of transports and exceptionHandlers for this instance.
   * @returns {Array} - List of transports and exceptionHandlers for this
   * instance.
   * @private
   */
  _getExceptionHandlers() {
    // Remark (indexzero): since `logger.transports` returns all of the pipes
    // from the _readableState of the stream we actually get the join of the
    // explicit handlers and the implicit transports with
    // `handleExceptions: true`
    return this.logger.transports.filter(wrap => {
      const transport = wrap.transport || wrap;
      return transport.handleExceptions;
    });
  }
};


/***/ }),

/***/ 391:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";
/**
 * exception-stream.js: TODO: add file header handler.
 *
 * (C) 2010 Charlie Robbins
 * MIT LICENCE
 */



const { Writable } = __nccwpck_require__(86131);

/**
 * TODO: add class description.
 * @type {ExceptionStream}
 * @extends {Writable}
 */
module.exports = class ExceptionStream extends Writable {
  /**
   * Constructor function for the ExceptionStream responsible for wrapping a
   * TransportStream; only allowing writes of `info` objects with
   * `info.exception` set to true.
   * @param {!TransportStream} transport - Stream to filter to exceptions
   */
  constructor(transport) {
    super({ objectMode: true });

    if (!transport) {
      throw new Error('ExceptionStream requires a TransportStream instance.');
    }

    // Remark (indexzero): we set `handleExceptions` here because it's the
    // predicate checked in ExceptionHandler.prototype.__getExceptionHandlers
    this.handleExceptions = true;
    this.transport = transport;
  }

  /**
   * Writes the info object to our transport instance if (and only if) the
   * `exception` property is set on the info.
   * @param {mixed} info - TODO: add param description.
   * @param {mixed} enc - TODO: add param description.
   * @param {mixed} callback - TODO: add param description.
   * @returns {mixed} - TODO: add return description.
   * @private
   */
  _write(info, enc, callback) {
    if (info.exception) {
      return this.transport.log(info, callback);
    }

    callback();
    return true;
  }
};


/***/ }),

/***/ 51279:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";
/**
 * logger.js: TODO: add file header description.
 *
 * (C) 2010 Charlie Robbins
 * MIT LICENCE
 */



const { Stream, Transform } = __nccwpck_require__(86131);
const asyncForEach = __nccwpck_require__(63650);
const { LEVEL, SPLAT } = __nccwpck_require__(28836);
const isStream = __nccwpck_require__(96543);
const ExceptionHandler = __nccwpck_require__(71019);
const RejectionHandler = __nccwpck_require__(55421);
const LegacyTransportStream = __nccwpck_require__(56493);
const Profiler = __nccwpck_require__(80314);
const { warn } = __nccwpck_require__(63254);
const config = __nccwpck_require__(51942);

/**
 * Captures the number of format (i.e. %s strings) in a given string.
 * Based on `util.format`, see Node.js source:
 * https://github.com/nodejs/node/blob/b1c8f15c5f169e021f7c46eb7b219de95fe97603/lib/util.js#L201-L230
 * @type {RegExp}
 */
const formatRegExp = /%[scdjifoO%]/g;

/**
 * TODO: add class description.
 * @type {Logger}
 * @extends {Transform}
 */
class Logger extends Transform {
  /**
   * Constructor function for the Logger object responsible for persisting log
   * messages and metadata to one or more transports.
   * @param {!Object} options - foo
   */
  constructor(options) {
    super({ objectMode: true });
    this.configure(options);
  }

  child(defaultRequestMetadata) {
    const logger = this;
    return Object.create(logger, {
      write: {
        value: function (info) {
          const infoClone = Object.assign(
            {},
            defaultRequestMetadata,
            info
          );

          // Object.assign doesn't copy inherited Error
          // properties so we have to do that explicitly
          //
          // Remark (indexzero): we should remove this
          // since the errors format will handle this case.
          //
          if (info instanceof Error) {
            infoClone.stack = info.stack;
            infoClone.message = info.message;
            infoClone.cause = info.cause;
          }

          logger.write(infoClone);
        }
      }
    });
  }

  /**
   * This will wholesale reconfigure this instance by:
   * 1. Resetting all transports. Older transports will be removed implicitly.
   * 2. Set all other options including levels, colors, rewriters, filters,
   *    exceptionHandlers, etc.
   * @param {!Object} options - TODO: add param description.
   * @returns {undefined}
   */
  configure({
    silent,
    format,
    defaultMeta,
    levels,
    level = 'info',
    exitOnError = true,
    transports,
    colors,
    emitErrs,
    formatters,
    padLevels,
    rewriters,
    stripColors,
    exceptionHandlers,
    rejectionHandlers
  } = {}) {
    // Reset transports if we already have them
    if (this.transports.length) {
      this.clear();
    }

    this.silent = silent;
    this.format = format || this.format || __nccwpck_require__(17864)();

    this.defaultMeta = defaultMeta || null;
    // Hoist other options onto this instance.
    this.levels = levels || this.levels || config.npm.levels;
    this.level = level;
    if (this.exceptions) {
      this.exceptions.unhandle();
    }
    if (this.rejections) {
      this.rejections.unhandle();
    }
    this.exceptions = new ExceptionHandler(this);
    this.rejections = new RejectionHandler(this);
    this.profilers = {};
    this.exitOnError = exitOnError;

    // Add all transports we have been provided.
    if (transports) {
      transports = Array.isArray(transports) ? transports : [transports];
      transports.forEach(transport => this.add(transport));
    }

    if (
      colors ||
      emitErrs ||
      formatters ||
      padLevels ||
      rewriters ||
      stripColors
    ) {
      throw new Error(
        [
          '{ colors, emitErrs, formatters, padLevels, rewriters, stripColors } were removed in winston@3.0.0.',
          'Use a custom winston.format(function) instead.',
          'See: https://github.com/winstonjs/winston/tree/master/UPGRADE-3.0.md'
        ].join('\n')
      );
    }

    if (exceptionHandlers) {
      this.exceptions.handle(exceptionHandlers);
    }
    if (rejectionHandlers) {
      this.rejections.handle(rejectionHandlers);
    }
  }

  /* eslint-disable valid-jsdoc */
  /**
   * Helper method to get the highest logging level associated with a logger
   *
   * @returns { number | null } - The highest configured logging level, null
   * for invalid configuration
   */
  getHighestLogLevel() {
    // This can be null, if this.level has an invalid value
    const configuredLevelValue = getLevelValue(this.levels, this.level);

    // If there are no transports, return the level configured at the logger level
    if (!this.transports || this.transports.length === 0) {
      return configuredLevelValue;
    }

    return this.transports.reduce((max, transport) => {
      const levelValue = getLevelValue(this.levels, transport.level);
      return levelValue !== null && levelValue > max ? levelValue : max;
    }, configuredLevelValue);
  }

  isLevelEnabled(level) {
    const givenLevelValue = getLevelValue(this.levels, level);
    if (givenLevelValue === null) {
      return false;
    }

    const configuredLevelValue = getLevelValue(this.levels, this.level);
    if (configuredLevelValue === null) {
      return false;
    }

    if (!this.transports || this.transports.length === 0) {
      return configuredLevelValue >= givenLevelValue;
    }

    const index = this.transports.findIndex(transport => {
      let transportLevelValue = getLevelValue(this.levels, transport.level);
      if (transportLevelValue === null) {
        transportLevelValue = configuredLevelValue;
      }
      return transportLevelValue >= givenLevelValue;
    });
    return index !== -1;
  }

  /* eslint-disable valid-jsdoc */
  /**
   * Ensure backwards compatibility with a `log` method
   * @param {mixed} level - Level the log message is written at.
   * @param {mixed} msg - TODO: add param description.
   * @param {mixed} meta - TODO: add param description.
   * @returns {Logger} - TODO: add return description.
   *
   * @example
   *    // Supports the existing API:
   *    logger.log('info', 'Hello world', { custom: true });
   *    logger.log('info', new Error('Yo, it\'s on fire'));
   *
   *    // Requires winston.format.splat()
   *    logger.log('info', '%s %d%%', 'A string', 50, { thisIsMeta: true });
   *
   *    // And the new API with a single JSON literal:
   *    logger.log({ level: 'info', message: 'Hello world', custom: true });
   *    logger.log({ level: 'info', message: new Error('Yo, it\'s on fire') });
   *
   *    // Also requires winston.format.splat()
   *    logger.log({
   *      level: 'info',
   *      message: '%s %d%%',
   *      [SPLAT]: ['A string', 50],
   *      meta: { thisIsMeta: true }
   *    });
   *
   */
  /* eslint-enable valid-jsdoc */
  log(level, msg, ...splat) {
    // eslint-disable-line max-params
    // Optimize for the hotpath of logging JSON literals
    if (arguments.length === 1) {
      // Yo dawg, I heard you like levels ... seriously ...
      // In this context the LHS `level` here is actually the `info` so read
      // this as: info[LEVEL] = info.level;
      level[LEVEL] = level.level;
      this._addDefaultMeta(level);
      this.write(level);
      return this;
    }

    // Slightly less hotpath, but worth optimizing for.
    if (arguments.length === 2) {
      if (msg && typeof msg === 'object') {
        msg[LEVEL] = msg.level = level;
        this._addDefaultMeta(msg);
        this.write(msg);
        return this;
      }

      msg = { [LEVEL]: level, level, message: msg };
      this._addDefaultMeta(msg);
      this.write(msg);
      return this;
    }

    const [meta] = splat;
    if (typeof meta === 'object' && meta !== null) {
      // Extract tokens, if none available default to empty array to
      // ensure consistancy in expected results
      const tokens = msg && msg.match && msg.match(formatRegExp);

      if (!tokens) {
        const info = Object.assign({}, this.defaultMeta, meta, {
          [LEVEL]: level,
          [SPLAT]: splat,
          level,
          message: msg
        });

        if (meta.message) info.message = `${info.message} ${meta.message}`;
        if (meta.stack) info.stack = meta.stack;
        if (meta.cause) info.cause = meta.cause;

        this.write(info);
        return this;
      }
    }

    this.write(Object.assign({}, this.defaultMeta, {
      [LEVEL]: level,
      [SPLAT]: splat,
      level,
      message: msg
    }));

    return this;
  }

  /**
   * Pushes data so that it can be picked up by all of our pipe targets.
   * @param {mixed} info - TODO: add param description.
   * @param {mixed} enc - TODO: add param description.
   * @param {mixed} callback - Continues stream processing.
   * @returns {undefined}
   * @private
   */
  _transform(info, enc, callback) {
    if (this.silent) {
      return callback();
    }

    // [LEVEL] is only soft guaranteed to be set here since we are a proper
    // stream. It is likely that `info` came in through `.log(info)` or
    // `.info(info)`. If it is not defined, however, define it.
    // This LEVEL symbol is provided by `triple-beam` and also used in:
    // - logform
    // - winston-transport
    // - abstract-winston-transport
    if (!info[LEVEL]) {
      info[LEVEL] = info.level;
    }

    // Remark: really not sure what to do here, but this has been reported as
    // very confusing by pre winston@2.0.0 users as quite confusing when using
    // custom levels.
    if (!this.levels[info[LEVEL]] && this.levels[info[LEVEL]] !== 0) {
      // eslint-disable-next-line no-console
      console.error('[winston] Unknown logger level: %s', info[LEVEL]);
    }

    // Remark: not sure if we should simply error here.
    if (!this._readableState.pipes) {
      // eslint-disable-next-line no-console
      console.error(
        '[winston] Attempt to write logs with no transports, which can increase memory usage: %j',
        info
      );
    }

    // Here we write to the `format` pipe-chain, which on `readable` above will
    // push the formatted `info` Object onto the buffer for this instance. We trap
    // (and re-throw) any errors generated by the user-provided format, but also
    // guarantee that the streams callback is invoked so that we can continue flowing.
    try {
      this.push(this.format.transform(info, this.format.options));
    } finally {
      this._writableState.sync = false;
      // eslint-disable-next-line callback-return
      callback();
    }
  }

  /**
   * Delays the 'finish' event until all transport pipe targets have
   * also emitted 'finish' or are already finished.
   * @param {mixed} callback - Continues stream processing.
   */
  _final(callback) {
    const transports = this.transports.slice();
    asyncForEach(
      transports,
      (transport, next) => {
        if (!transport || transport.finished) return setImmediate(next);
        transport.once('finish', next);
        transport.end();
      },
      callback
    );
  }

  /**
   * Adds the transport to this logger instance by piping to it.
   * @param {mixed} transport - TODO: add param description.
   * @returns {Logger} - TODO: add return description.
   */
  add(transport) {
    // Support backwards compatibility with all existing `winston < 3.x.x`
    // transports which meet one of two criteria:
    // 1. They inherit from winston.Transport in  < 3.x.x which is NOT a stream.
    // 2. They expose a log method which has a length greater than 2 (i.e. more then
    //    just `log(info, callback)`.
    const target =
      !isStream(transport) || transport.log.length > 2
        ? new LegacyTransportStream({ transport })
        : transport;

    if (!target._writableState || !target._writableState.objectMode) {
      throw new Error(
        'Transports must WritableStreams in objectMode. Set { objectMode: true }.'
      );
    }

    // Listen for the `error` event and the `warn` event on the new Transport.
    this._onEvent('error', target);
    this._onEvent('warn', target);
    this.pipe(target);

    if (transport.handleExceptions) {
      this.exceptions.handle();
    }

    if (transport.handleRejections) {
      this.rejections.handle();
    }

    return this;
  }

  /**
   * Removes the transport from this logger instance by unpiping from it.
   * @param {mixed} transport - TODO: add param description.
   * @returns {Logger} - TODO: add return description.
   */
  remove(transport) {
    if (!transport) return this;
    let target = transport;
    if (!isStream(transport) || transport.log.length > 2) {
      target = this.transports.filter(
        match => match.transport === transport
      )[0];
    }

    if (target) {
      this.unpipe(target);
    }
    return this;
  }

  /**
   * Removes all transports from this logger instance.
   * @returns {Logger} - TODO: add return description.
   */
  clear() {
    this.unpipe();
    return this;
  }

  /**
   * Cleans up resources (streams, event listeners) for all transports
   * associated with this instance (if necessary).
   * @returns {Logger} - TODO: add return description.
   */
  close() {
    this.exceptions.unhandle();
    this.rejections.unhandle();
    this.clear();
    this.emit('close');
    return this;
  }

  /**
   * Sets the `target` levels specified on this instance.
   * @param {Object} Target levels to use on this instance.
   */
  setLevels() {
    warn.deprecated('setLevels');
  }

  /**
   * Queries the all transports for this instance with the specified `options`.
   * This will aggregate each transport's results into one object containing
   * a property per transport.
   * @param {Object} options - Query options for this instance.
   * @param {function} callback - Continuation to respond to when complete.
   */
  query(options, callback) {
    if (typeof options === 'function') {
      callback = options;
      options = {};
    }

    options = options || {};
    const results = {};
    const queryObject = Object.assign({}, options.query || {});

    // Helper function to query a single transport
    function queryTransport(transport, next) {
      if (options.query && typeof transport.formatQuery === 'function') {
        options.query = transport.formatQuery(queryObject);
      }

      transport.query(options, (err, res) => {
        if (err) {
          return next(err);
        }

        if (typeof transport.formatResults === 'function') {
          res = transport.formatResults(res, options.format);
        }

        next(null, res);
      });
    }

    // Helper function to accumulate the results from `queryTransport` into
    // the `results`.
    function addResults(transport, next) {
      queryTransport(transport, (err, result) => {
        // queryTransport could potentially invoke the callback multiple times
        // since Transport code can be unpredictable.
        if (next) {
          result = err || result;
          if (result) {
            results[transport.name] = result;
          }

          // eslint-disable-next-line callback-return
          next();
        }

        next = null;
      });
    }

    // Iterate over the transports in parallel setting the appropriate key in
    // the `results`.
    asyncForEach(
      this.transports.filter(transport => !!transport.query),
      addResults,
      () => callback(null, results)
    );
  }

  /**
   * Returns a log stream for all transports. Options object is optional.
   * @param{Object} options={} - Stream options for this instance.
   * @returns {Stream} - TODO: add return description.
   */
  stream(options = {}) {
    const out = new Stream();
    const streams = [];

    out._streams = streams;
    out.destroy = () => {
      let i = streams.length;
      while (i--) {
        streams[i].destroy();
      }
    };

    // Create a list of all transports for this instance.
    this.transports
      .filter(transport => !!transport.stream)
      .forEach(transport => {
        const str = transport.stream(options);
        if (!str) {
          return;
        }

        streams.push(str);

        str.on('log', log => {
          log.transport = log.transport || [];
          log.transport.push(transport.name);
          out.emit('log', log);
        });

        str.on('error', err => {
          err.transport = err.transport || [];
          err.transport.push(transport.name);
          out.emit('error', err);
        });
      });

    return out;
  }

  /**
   * Returns an object corresponding to a specific timing. When done is called
   * the timer will finish and log the duration. e.g.:
   * @returns {Profile} - TODO: add return description.
   * @example
   *    const timer = winston.startTimer()
   *    setTimeout(() => {
   *      timer.done({
   *        message: 'Logging message'
   *      });
   *    }, 1000);
   */
  startTimer() {
    return new Profiler(this);
  }

  /**
   * Tracks the time inbetween subsequent calls to this method with the same
   * `id` parameter. The second call to this method will log the difference in
   * milliseconds along with the message.
   * @param {string} id Unique id of the profiler
   * @returns {Logger} - TODO: add return description.
   */
  profile(id, ...args) {
    const time = Date.now();
    if (this.profilers[id]) {
      const timeEnd = this.profilers[id];
      delete this.profilers[id];

      // Attempt to be kind to users if they are still using older APIs.
      if (typeof args[args.length - 2] === 'function') {
        // eslint-disable-next-line no-console
        console.warn(
          'Callback function no longer supported as of winston@3.0.0'
        );
        args.pop();
      }

      // Set the duration property of the metadata
      const info = typeof args[args.length - 1] === 'object' ? args.pop() : {};
      info.level = info.level || 'info';
      info.durationMs = time - timeEnd;
      info.message = info.message || id;
      return this.write(info);
    }

    this.profilers[id] = time;
    return this;
  }

  /**
   * Backwards compatibility to `exceptions.handle` in winston < 3.0.0.
   * @returns {undefined}
   * @deprecated
   */
  handleExceptions(...args) {
    // eslint-disable-next-line no-console
    console.warn(
      'Deprecated: .handleExceptions() will be removed in winston@4. Use .exceptions.handle()'
    );
    this.exceptions.handle(...args);
  }

  /**
   * Backwards compatibility to `exceptions.handle` in winston < 3.0.0.
   * @returns {undefined}
   * @deprecated
   */
  unhandleExceptions(...args) {
    // eslint-disable-next-line no-console
    console.warn(
      'Deprecated: .unhandleExceptions() will be removed in winston@4. Use .exceptions.unhandle()'
    );
    this.exceptions.unhandle(...args);
  }

  /**
   * Throw a more meaningful deprecation notice
   * @throws {Error} - TODO: add throws description.
   */
  cli() {
    throw new Error(
      [
        'Logger.cli() was removed in winston@3.0.0',
        'Use a custom winston.formats.cli() instead.',
        'See: https://github.com/winstonjs/winston/tree/master/UPGRADE-3.0.md'
      ].join('\n')
    );
  }

  /**
   * Bubbles the `event` that occured on the specified `transport` up
   * from this instance.
   * @param {string} event - The event that occured
   * @param {Object} transport - Transport on which the event occured
   * @private
   */
  _onEvent(event, transport) {
    function transportEvent(err) {
      // https://github.com/winstonjs/winston/issues/1364
      if (event === 'error' && !this.transports.includes(transport)) {
        this.add(transport);
      }
      this.emit(event, err, transport);
    }

    if (!transport['__winston' + event]) {
      transport['__winston' + event] = transportEvent.bind(this);
      transport.on(event, transport['__winston' + event]);
    }
  }

  _addDefaultMeta(msg) {
    if (this.defaultMeta) {
      Object.assign(msg, this.defaultMeta);
    }
  }
}

function getLevelValue(levels, level) {
  const value = levels[level];
  if (!value && value !== 0) {
    return null;
  }
  return value;
}

/**
 * Represents the current readableState pipe targets for this Logger instance.
 * @type {Array|Object}
 */
Object.defineProperty(Logger.prototype, 'transports', {
  configurable: false,
  enumerable: true,
  get() {
    const { pipes } = this._readableState;
    return !Array.isArray(pipes) ? [pipes].filter(Boolean) : pipes;
  }
});

module.exports = Logger;


/***/ }),

/***/ 80314:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";
/**
 * profiler.js: TODO: add file header description.
 *
 * (C) 2010 Charlie Robbins
 * MIT LICENCE
 */


/**
 * TODO: add class description.
 * @type {Profiler}
 * @private
 */
class Profiler {
  /**
   * Constructor function for the Profiler instance used by
   * `Logger.prototype.startTimer`. When done is called the timer will finish
   * and log the duration.
   * @param {!Logger} logger - TODO: add param description.
   * @private
   */
  constructor(logger) {
    const Logger = __nccwpck_require__(51279);
    if (typeof logger !== 'object' || Array.isArray(logger) || !(logger instanceof Logger)) {
      throw new Error('Logger is required for profiling');
    } else {
      this.logger = logger;
      this.start = Date.now();
    }
  }

  /**
   * Ends the current timer (i.e. Profiler) instance and logs the `msg` along
   * with the duration since creation.
   * @returns {mixed} - TODO: add return description.
   * @private
   */
  done(...args) {
    if (typeof args[args.length - 1] === 'function') {
      // eslint-disable-next-line no-console
      console.warn('Callback function no longer supported as of winston@3.0.0');
      args.pop();
    }

    const info = typeof args[args.length - 1] === 'object' ? args.pop() : {};
    info.level = info.level || 'info';
    info.durationMs = (Date.now()) - this.start;

    return this.logger.write(info);
  }
}

module.exports = Profiler;


/***/ }),

/***/ 55421:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";
/**
 * exception-handler.js: Object for handling uncaughtException events.
 *
 * (C) 2010 Charlie Robbins
 * MIT LICENCE
 */



const os = __nccwpck_require__(70857);
const asyncForEach = __nccwpck_require__(63650);
const debug = __nccwpck_require__(1379)('winston:rejection');
const once = __nccwpck_require__(38186);
const stackTrace = __nccwpck_require__(39428);
const RejectionStream = __nccwpck_require__(93309);

/**
 * Object for handling unhandledRejection events.
 * @type {RejectionHandler}
 */
module.exports = class RejectionHandler {
  /**
   * TODO: add contructor description
   * @param {!Logger} logger - TODO: add param description
   */
  constructor(logger) {
    if (!logger) {
      throw new Error('Logger is required to handle rejections');
    }

    this.logger = logger;
    this.handlers = new Map();
  }

  /**
   * Handles `unhandledRejection` events for the current process by adding any
   * handlers passed in.
   * @returns {undefined}
   */
  handle(...args) {
    args.forEach(arg => {
      if (Array.isArray(arg)) {
        return arg.forEach(handler => this._addHandler(handler));
      }

      this._addHandler(arg);
    });

    if (!this.catcher) {
      this.catcher = this._unhandledRejection.bind(this);
      process.on('unhandledRejection', this.catcher);
    }
  }

  /**
   * Removes any handlers to `unhandledRejection` events for the current
   * process. This does not modify the state of the `this.handlers` set.
   * @returns {undefined}
   */
  unhandle() {
    if (this.catcher) {
      process.removeListener('unhandledRejection', this.catcher);
      this.catcher = false;

      Array.from(this.handlers.values()).forEach(wrapper =>
        this.logger.unpipe(wrapper)
      );
    }
  }

  /**
   * TODO: add method description
   * @param {Error} err - Error to get information about.
   * @returns {mixed} - TODO: add return description.
   */
  getAllInfo(err) {
    let message = null;
    if (err) {
      message = typeof err === 'string' ? err : err.message;
    }

    return {
      error: err,
      // TODO (indexzero): how do we configure this?
      level: 'error',
      message: [
        `unhandledRejection: ${message || '(no error message)'}`,
        err && err.stack || '  No stack trace'
      ].join('\n'),
      stack: err && err.stack,
      rejection: true,
      date: new Date().toString(),
      process: this.getProcessInfo(),
      os: this.getOsInfo(),
      trace: this.getTrace(err)
    };
  }

  /**
   * Gets all relevant process information for the currently running process.
   * @returns {mixed} - TODO: add return description.
   */
  getProcessInfo() {
    return {
      pid: process.pid,
      uid: process.getuid ? process.getuid() : null,
      gid: process.getgid ? process.getgid() : null,
      cwd: process.cwd(),
      execPath: process.execPath,
      version: process.version,
      argv: process.argv,
      memoryUsage: process.memoryUsage()
    };
  }

  /**
   * Gets all relevant OS information for the currently running process.
   * @returns {mixed} - TODO: add return description.
   */
  getOsInfo() {
    return {
      loadavg: os.loadavg(),
      uptime: os.uptime()
    };
  }

  /**
   * Gets a stack trace for the specified error.
   * @param {mixed} err - TODO: add param description.
   * @returns {mixed} - TODO: add return description.
   */
  getTrace(err) {
    const trace = err ? stackTrace.parse(err) : stackTrace.get();
    return trace.map(site => {
      return {
        column: site.getColumnNumber(),
        file: site.getFileName(),
        function: site.getFunctionName(),
        line: site.getLineNumber(),
        method: site.getMethodName(),
        native: site.isNative()
      };
    });
  }

  /**
   * Helper method to add a transport as an exception handler.
   * @param {Transport} handler - The transport to add as an exception handler.
   * @returns {void}
   */
  _addHandler(handler) {
    if (!this.handlers.has(handler)) {
      handler.handleRejections = true;
      const wrapper = new RejectionStream(handler);
      this.handlers.set(handler, wrapper);
      this.logger.pipe(wrapper);
    }
  }

  /**
   * Logs all relevant information around the `err` and exits the current
   * process.
   * @param {Error} err - Error to handle
   * @returns {mixed} - TODO: add return description.
   * @private
   */
  _unhandledRejection(err) {
    const info = this.getAllInfo(err);
    const handlers = this._getRejectionHandlers();
    // Calculate if we should exit on this error
    let doExit =
      typeof this.logger.exitOnError === 'function'
        ? this.logger.exitOnError(err)
        : this.logger.exitOnError;
    let timeout;

    if (!handlers.length && doExit) {
      // eslint-disable-next-line no-console
      console.warn('winston: exitOnError cannot be true with no rejection handlers.');
      // eslint-disable-next-line no-console
      console.warn('winston: not exiting process.');
      doExit = false;
    }

    function gracefulExit() {
      debug('doExit', doExit);
      debug('process._exiting', process._exiting);

      if (doExit && !process._exiting) {
        // Remark: Currently ignoring any rejections from transports when
        // catching unhandled rejections.
        if (timeout) {
          clearTimeout(timeout);
        }
        // eslint-disable-next-line no-process-exit
        process.exit(1);
      }
    }

    if (!handlers || handlers.length === 0) {
      return process.nextTick(gracefulExit);
    }

    // Log to all transports attempting to listen for when they are completed.
    asyncForEach(
      handlers,
      (handler, next) => {
        const done = once(next);
        const transport = handler.transport || handler;

        // Debug wrapping so that we can inspect what's going on under the covers.
        function onDone(event) {
          return () => {
            debug(event);
            done();
          };
        }

        transport._ending = true;
        transport.once('finish', onDone('finished'));
        transport.once('error', onDone('error'));
      },
      () => doExit && gracefulExit()
    );

    this.logger.log(info);

    // If exitOnError is true, then only allow the logging of exceptions to
    // take up to `3000ms`.
    if (doExit) {
      timeout = setTimeout(gracefulExit, 3000);
    }
  }

  /**
   * Returns the list of transports and exceptionHandlers for this instance.
   * @returns {Array} - List of transports and exceptionHandlers for this
   * instance.
   * @private
   */
  _getRejectionHandlers() {
    // Remark (indexzero): since `logger.transports` returns all of the pipes
    // from the _readableState of the stream we actually get the join of the
    // explicit handlers and the implicit transports with
    // `handleRejections: true`
    return this.logger.transports.filter(wrap => {
      const transport = wrap.transport || wrap;
      return transport.handleRejections;
    });
  }
};


/***/ }),

/***/ 93309:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";
/**
 * rejection-stream.js: TODO: add file header handler.
 *
 * (C) 2010 Charlie Robbins
 * MIT LICENCE
 */



const { Writable } = __nccwpck_require__(86131);

/**
 * TODO: add class description.
 * @type {RejectionStream}
 * @extends {Writable}
 */
module.exports = class RejectionStream extends Writable {
  /**
   * Constructor function for the RejectionStream responsible for wrapping a
   * TransportStream; only allowing writes of `info` objects with
   * `info.rejection` set to true.
   * @param {!TransportStream} transport - Stream to filter to rejections
   */
  constructor(transport) {
    super({ objectMode: true });

    if (!transport) {
      throw new Error('RejectionStream requires a TransportStream instance.');
    }

    this.handleRejections = true;
    this.transport = transport;
  }

  /**
   * Writes the info object to our transport instance if (and only if) the
   * `rejection` property is set on the info.
   * @param {mixed} info - TODO: add param description.
   * @param {mixed} enc - TODO: add param description.
   * @param {mixed} callback - TODO: add param description.
   * @returns {mixed} - TODO: add return description.
   * @private
   */
  _write(info, enc, callback) {
    if (info.rejection) {
      return this.transport.log(info, callback);
    }

    callback();
    return true;
  }
};


/***/ }),

/***/ 66516:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";
/**
 * tail-file.js: TODO: add file header description.
 *
 * (C) 2010 Charlie Robbins
 * MIT LICENCE
 */



const fs = __nccwpck_require__(79896);
const { StringDecoder } = __nccwpck_require__(13193);
const { Stream } = __nccwpck_require__(86131);

/**
 * Simple no-op function.
 * @returns {undefined}
 */
function noop() {}

/**
 * TODO: add function description.
 * @param {Object} options - Options for tail.
 * @param {function} iter - Iterator function to execute on every line.
* `tail -f` a file. Options must include file.
 * @returns {mixed} - TODO: add return description.
 */
module.exports = (options, iter) => {
  const buffer = Buffer.alloc(64 * 1024);
  const decode = new StringDecoder('utf8');
  const stream = new Stream();
  let buff = '';
  let pos = 0;
  let row = 0;

  if (options.start === -1) {
    delete options.start;
  }

  stream.readable = true;
  stream.destroy = () => {
    stream.destroyed = true;
    stream.emit('end');
    stream.emit('close');
  };

  fs.open(options.file, 'a+', '0644', (err, fd) => {
    if (err) {
      if (!iter) {
        stream.emit('error', err);
      } else {
        iter(err);
      }
      stream.destroy();
      return;
    }

    (function read() {
      if (stream.destroyed) {
        fs.close(fd, noop);
        return;
      }

      return fs.read(fd, buffer, 0, buffer.length, pos, (error, bytes) => {
        if (error) {
          if (!iter) {
            stream.emit('error', error);
          } else {
            iter(error);
          }
          stream.destroy();
          return;
        }

        if (!bytes) {
          if (buff) {
            // eslint-disable-next-line eqeqeq
            if (options.start == null || row > options.start) {
              if (!iter) {
                stream.emit('line', buff);
              } else {
                iter(null, buff);
              }
            }
            row++;
            buff = '';
          }
          return setTimeout(read, 1000);
        }

        let data = decode.write(buffer.slice(0, bytes));
        if (!iter) {
          stream.emit('data', data);
        }

        data = (buff + data).split(/\n+/);

        const l = data.length - 1;
        let i = 0;

        for (; i < l; i++) {
          // eslint-disable-next-line eqeqeq
          if (options.start == null || row > options.start) {
            if (!iter) {
              stream.emit('line', data[i]);
            } else {
              iter(null, data[i]);
            }
          }
          row++;
        }

        buff = data[l];
        pos += bytes;
        return read();
      });
    }());
  });

  if (!iter) {
    return stream;
  }

  return stream.destroy;
};


/***/ }),

/***/ 49543:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";
/* eslint-disable no-console */
/*
 * console.js: Transport for outputting to the console.
 *
 * (C) 2010 Charlie Robbins
 * MIT LICENCE
 */



const os = __nccwpck_require__(70857);
const { LEVEL, MESSAGE } = __nccwpck_require__(28836);
const TransportStream = __nccwpck_require__(3588);

/**
 * Transport for outputting to the console.
 * @type {Console}
 * @extends {TransportStream}
 */
module.exports = class Console extends TransportStream {
  /**
   * Constructor function for the Console transport object responsible for
   * persisting log messages and metadata to a terminal or TTY.
   * @param {!Object} [options={}] - Options for this instance.
   */
  constructor(options = {}) {
    super(options);

    // Expose the name of this Transport on the prototype
    this.name = options.name || 'console';
    this.stderrLevels = this._stringArrayToSet(options.stderrLevels);
    this.consoleWarnLevels = this._stringArrayToSet(options.consoleWarnLevels);
    this.eol = typeof options.eol === 'string' ? options.eol : os.EOL;
    this.forceConsole = options.forceConsole || false;

    // Keep a reference to the log, warn, and error console methods
    // in case they get redirected to this transport after the logger is
    // instantiated. This prevents a circular reference issue.
    this._consoleLog = console.log.bind(console);
    this._consoleWarn = console.warn.bind(console);
    this._consoleError = console.error.bind(console);

    this.setMaxListeners(30);
  }

  /**
   * Core logging method exposed to Winston.
   * @param {Object} info - TODO: add param description.
   * @param {Function} callback - TODO: add param description.
   * @returns {undefined}
   */
  log(info, callback) {
    setImmediate(() => this.emit('logged', info));

    // Remark: what if there is no raw...?
    if (this.stderrLevels[info[LEVEL]]) {
      if (console._stderr && !this.forceConsole) {
        // Node.js maps `process.stderr` to `console._stderr`.
        console._stderr.write(`${info[MESSAGE]}${this.eol}`);
      } else {
        // console.error adds a newline
        this._consoleError(info[MESSAGE]);
      }

      if (callback) {
        callback(); // eslint-disable-line callback-return
      }
      return;
    } else if (this.consoleWarnLevels[info[LEVEL]]) {
      if (console._stderr && !this.forceConsole) {
        // Node.js maps `process.stderr` to `console._stderr`.
        // in Node.js console.warn is an alias for console.error
        console._stderr.write(`${info[MESSAGE]}${this.eol}`);
      } else {
        // console.warn adds a newline
        this._consoleWarn(info[MESSAGE]);
      }

      if (callback) {
        callback(); // eslint-disable-line callback-return
      }
      return;
    }

    if (console._stdout && !this.forceConsole) {
      // Node.js maps `process.stdout` to `console._stdout`.
      console._stdout.write(`${info[MESSAGE]}${this.eol}`);
    } else {
      // console.log adds a newline.
      this._consoleLog(info[MESSAGE]);
    }

    if (callback) {
      callback(); // eslint-disable-line callback-return
    }
  }

  /**
   * Returns a Set-like object with strArray's elements as keys (each with the
   * value true).
   * @param {Array} strArray - Array of Set-elements as strings.
   * @param {?string} [errMsg] - Custom error message thrown on invalid input.
   * @returns {Object} - TODO: add return description.
   * @private
   */
  _stringArrayToSet(strArray, errMsg) {
    if (!strArray) return {};

    errMsg =
      errMsg || 'Cannot make set from type other than Array of string elements';

    if (!Array.isArray(strArray)) {
      throw new Error(errMsg);
    }

    return strArray.reduce((set, el) => {
      if (typeof el !== 'string') {
        throw new Error(errMsg);
      }
      set[el] = true;

      return set;
    }, {});
  }
};


/***/ }),

/***/ 5478:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";
/* eslint-disable complexity,max-statements */
/**
 * file.js: Transport for outputting to a local log file.
 *
 * (C) 2010 Charlie Robbins
 * MIT LICENCE
 */



const fs = __nccwpck_require__(79896);
const path = __nccwpck_require__(16928);
const asyncSeries = __nccwpck_require__(58719);
const zlib = __nccwpck_require__(43106);
const { MESSAGE } = __nccwpck_require__(28836);
const { Stream, PassThrough } = __nccwpck_require__(86131);
const TransportStream = __nccwpck_require__(3588);
const debug = __nccwpck_require__(1379)('winston:file');
const os = __nccwpck_require__(70857);
const tailFile = __nccwpck_require__(66516);

/**
 * Transport for outputting to a local log file.
 * @type {File}
 * @extends {TransportStream}
 */
module.exports = class File extends TransportStream {
  /**
   * Constructor function for the File transport object responsible for
   * persisting log messages and metadata to one or more files.
   * @param {Object} options - Options for this instance.
   */
  constructor(options = {}) {
    super(options);

    // Expose the name of this Transport on the prototype.
    this.name = options.name || 'file';

    // Helper function which throws an `Error` in the event that any of the
    // rest of the arguments is present in `options`.
    function throwIf(target, ...args) {
      args.slice(1).forEach(name => {
        if (options[name]) {
          throw new Error(`Cannot set ${name} and ${target} together`);
        }
      });
    }

    // Setup the base stream that always gets piped to to handle buffering.
    this._stream = new PassThrough();
    this._stream.setMaxListeners(30);

    // Bind this context for listener methods.
    this._onError = this._onError.bind(this);

    if (options.filename || options.dirname) {
      throwIf('filename or dirname', 'stream');
      this._basename = this.filename = options.filename
        ? path.basename(options.filename)
        : 'winston.log';

      this.dirname = options.dirname || path.dirname(options.filename);
      this.options = options.options || { flags: 'a' };
    } else if (options.stream) {
      // eslint-disable-next-line no-console
      console.warn('options.stream will be removed in winston@4. Use winston.transports.Stream');
      throwIf('stream', 'filename', 'maxsize');
      this._dest = this._stream.pipe(this._setupStream(options.stream));
      this.dirname = path.dirname(this._dest.path);
      // We need to listen for drain events when write() returns false. This
      // can make node mad at times.
    } else {
      throw new Error('Cannot log to file without filename or stream.');
    }

    this.maxsize = options.maxsize || null;
    this.rotationFormat = options.rotationFormat || false;
    this.zippedArchive = options.zippedArchive || false;
    this.maxFiles = options.maxFiles || null;
    this.eol = (typeof options.eol === 'string') ? options.eol : os.EOL;
    this.tailable = options.tailable || false;
    this.lazy = options.lazy || false;

    // Internal state variables representing the number of files this instance
    // has created and the current size (in bytes) of the current logfile.
    this._size = 0;
    this._pendingSize = 0;
    this._created = 0;
    this._drain = false;
    this._opening = false;
    this._ending = false;
    this._fileExist = false;

    if (this.dirname) this._createLogDirIfNotExist(this.dirname);
    if (!this.lazy) this.open();
  }

  finishIfEnding() {
    if (this._ending) {
      if (this._opening) {
        this.once('open', () => {
          this._stream.once('finish', () => this.emit('finish'));
          setImmediate(() => this._stream.end());
        });
      } else {
        this._stream.once('finish', () => this.emit('finish'));
        setImmediate(() => this._stream.end());
      }
    }
  }

  /**
   * Called by Node.js Writable stream before emitting 'finish'.
   * Ensures all buffered data is flushed to the underlying file stream
   * before the transport signals completion.
   * @param {Function} callback - Callback to signal completion.
   * @private
   */
  _final(callback) {
    // If still opening, wait for the file to be opened first
    if (this._opening) {
      this.once('open', () => this._final(callback));
      return;
    }

    // End the PassThrough stream
    this._stream.end();

    // No destination stream, call callback immediately
    if (!this._dest) {
      return callback();
    }

    // Destination is already finished
    if (this._dest.writableFinished) {
      return callback();
    }

    // Wait for destination stream to finish writing
    this._dest.once('finish', callback);
    this._dest.once('error', callback);
  }

  /**
   * Core logging method exposed to Winston. Metadata is optional.
   * @param {Object} info - TODO: add param description.
   * @param {Function} callback - TODO: add param description.
   * @returns {undefined}
   */
  log(info, callback = () => { }) {
    // Remark: (jcrugzz) What is necessary about this callback(null, true) now
    // when thinking about 3.x? Should silent be handled in the base
    // TransportStream _write method?
    if (this.silent) {
      callback();
      return true;
    }


    // Output stream buffer is full and has asked us to wait for the drain event
    if (this._drain) {
      this._stream.once('drain', () => {
        this._drain = false;
        this.log(info, callback);
      });
      return;
    }
    if (this._rotate) {
      this._stream.once('rotate', () => {
        this._rotate = false;
        this.log(info, callback);
      });
      return;
    }
    if (this.lazy) {
      if (!this._fileExist) {
        if (!this._opening) {
          this.open();
        }
        this.once('open', () => {
          this._fileExist = true;
          this.log(info, callback);
          return;
        });
        return;
      }
      if (this._needsNewFile(this._pendingSize)) {
        this._dest.once('close', () => {
          if (!this._opening) {
            this.open();
          }
          this.once('open', () => {
            this.log(info, callback);
            return;
          });
          return;
        });
        return;
      }
    }

    // Grab the raw string and append the expected EOL.
    const output = `${info[MESSAGE]}${this.eol}`;
    const bytes = Buffer.byteLength(output);

    // After we have written to the PassThrough check to see if we need
    // to rotate to the next file.
    //
    // Remark: This gets called too early and does not depict when data
    // has been actually flushed to disk.
    function logged() {
      this._size += bytes;
      this._pendingSize -= bytes;

      debug('logged %s %s', this._size, output);
      this.emit('logged', info);

      // Do not attempt to rotate files while rotating
      if (this._rotate) {
        return;
      }

      // Do not attempt to rotate files while opening
      if (this._opening) {
        return;
      }

      // Check to see if we need to end the stream and create a new one.
      if (!this._needsNewFile()) {
        return;
      }
      if (this.lazy) {
        this._endStream(() => {this.emit('fileclosed');});
        return;
      }

      // End the current stream, ensure it flushes and create a new one.
      // This could potentially be optimized to not run a stat call but its
      // the safest way since we are supporting `maxFiles`.
      this._rotate = true;
      this._endStream(() => this._rotateFile());
    }

    // Keep track of the pending bytes being written while files are opening
    // in order to properly rotate the PassThrough this._stream when the file
    // eventually does open.
    this._pendingSize += bytes;
    if (this._opening
      && !this.rotatedWhileOpening
      && this._needsNewFile(this._size + this._pendingSize)) {
      this.rotatedWhileOpening = true;
    }

    const written = this._stream.write(output, logged.bind(this));
    if (!written) {
      this._drain = true;
      this._stream.once('drain', () => {
        this._drain = false;
        callback();
      });
    } else {
      callback(); // eslint-disable-line callback-return
    }

    debug('written', written, this._drain);

    this.finishIfEnding();

    return written;
  }

  /**
   * Query the transport. Options object is optional.
   * @param {Object} options - Loggly-like query options for this instance.
   * @param {function} callback - Continuation to respond to when complete.
   * TODO: Refactor me.
   */
  query(options, callback) {
    if (typeof options === 'function') {
      callback = options;
      options = {};
    }

    options = normalizeQuery(options);
    const file = path.join(this.dirname, this.filename);
    let buff = '';
    let results = [];
    let row = 0;

    const stream = fs.createReadStream(file, {
      encoding: 'utf8'
    });

    stream.on('error', err => {
      if (stream.readable) {
        stream.destroy();
      }
      if (!callback) {
        return;
      }

      return err.code !== 'ENOENT' ? callback(err) : callback(null, results);
    });

    stream.on('data', data => {
      data = (buff + data).split(/\n+/);
      const l = data.length - 1;
      let i = 0;

      for (; i < l; i++) {
        if (!options.start || row >= options.start) {
          add(data[i]);
        }
        row++;
      }

      buff = data[l];
    });

    stream.on('close', () => {
      if (buff) {
        add(buff, true);
      }
      if (options.order === 'desc') {
        results = results.reverse();
      }

      // eslint-disable-next-line callback-return
      if (callback) callback(null, results);
    });

    function add(buff, attempt) {
      try {
        const log = JSON.parse(buff);
        if (check(log)) {
          push(log);
        }
      } catch (e) {
        if (!attempt) {
          stream.emit('error', e);
        }
      }
    }

    function push(log) {
      if (
        options.rows &&
        results.length >= options.rows &&
        options.order !== 'desc'
      ) {
        if (stream.readable) {
          stream.destroy();
        }
        return;
      }

      if (options.fields) {
        log = options.fields.reduce((obj, key) => {
          obj[key] = log[key];
          return obj;
        }, {});
      }

      if (options.order === 'desc') {
        if (results.length >= options.rows) {
          results.shift();
        }
      }
      results.push(log);
    }

    function check(log) {
      if (!log) {
        return;
      }

      if (typeof log !== 'object') {
        return;
      }

      const time = new Date(log.timestamp);
      if (
        (options.from && time < options.from) ||
        (options.until && time > options.until) ||
        (options.level && options.level !== log.level)
      ) {
        return;
      }

      return true;
    }

    function normalizeQuery(options) {
      options = options || {};

      // limit
      options.rows = options.rows || options.limit || 10;

      // starting row offset
      options.start = options.start || 0;

      // now
      options.until = options.until || new Date();
      if (typeof options.until !== 'object') {
        options.until = new Date(options.until);
      }

      // now - 24
      options.from = options.from || (options.until - (24 * 60 * 60 * 1000));
      if (typeof options.from !== 'object') {
        options.from = new Date(options.from);
      }

      // 'asc' or 'desc'
      options.order = options.order || 'desc';

      return options;
    }
  }

  /**
   * Returns a log stream for this transport. Options object is optional.
   * @param {Object} options - Stream options for this instance.
   * @returns {Stream} - TODO: add return description.
   * TODO: Refactor me.
   */
  stream(options = {}) {
    const file = path.join(this.dirname, this.filename);
    const stream = new Stream();
    const tail = {
      file,
      start: options.start
    };

    stream.destroy = tailFile(tail, (err, line) => {
      if (err) {
        return stream.emit('error', err);
      }

      try {
        stream.emit('data', line);
        line = JSON.parse(line);
        stream.emit('log', line);
      } catch (e) {
        stream.emit('error', e);
      }
    });

    return stream;
  }

  /**
   * Checks to see the filesize of.
   * @returns {undefined}
   */
  open() {
    // If we do not have a filename then we were passed a stream and
    // don't need to keep track of size.
    if (!this.filename) return;
    if (this._opening) return;

    this._opening = true;

    // Stat the target file to get the size and create the stream.
    this.stat((err, size) => {
      if (err) {
        return this.emit('error', err);
      }
      debug('stat done: %s { size: %s }', this.filename, size);
      this._size = size;
      this._dest = this._createStream(this._stream);
      this._opening = false;
      this.once('open', () => {
        if (!this._stream.emit('rotate')) {
          this._rotate = false;
        }
      });
    });
  }

  /**
   * Stat the file and assess information in order to create the proper stream.
   * @param {function} callback - TODO: add param description.
   * @returns {undefined}
   */
  stat(callback) {
    const target = this._getFile();
    const fullpath = path.join(this.dirname, target);

    fs.stat(fullpath, (err, stat) => {
      if (err && err.code === 'ENOENT') {
        debug('ENOENT¬†ok', fullpath);
        // Update internally tracked filename with the new target name.
        this.filename = target;
        return callback(null, 0);
      }

      if (err) {
        debug(`err ${err.code} ${fullpath}`);
        return callback(err);
      }

      if (!stat || this._needsNewFile(stat.size)) {
        // If `stats.size` is greater than the `maxsize` for this
        // instance then try again.
        return this._incFile(() => this.stat(callback));
      }

      // Once we have figured out what the filename is, set it
      // and return the size.
      this.filename = target;
      callback(null, stat.size);
    });
  }

  /**
   * Closes the stream associated with this instance.
   * @param {function} cb - TODO: add param description.
   * @returns {undefined}
   */
  close(cb) {
    if (!this._stream) {
      return;
    }

    this._stream.end(() => {
      if (cb) {
        cb(); // eslint-disable-line callback-return
      }
      this.emit('flush');
      this.emit('closed');
    });
  }

  /**
   * TODO: add method description.
   * @param {number} size - TODO: add param description.
   * @returns {undefined}
   */
  _needsNewFile(size) {
    size = size || this._size;
    return this.maxsize && size >= this.maxsize;
  }

  /**
   * TODO: add method description.
   * @param {Error} err - TODO: add param description.
   * @returns {undefined}
   */
  _onError(err) {
    this.emit('error', err);
  }

  /**
   * TODO: add method description.
   * @param {Stream} stream - TODO: add param description.
   * @returns {mixed} - TODO: add return description.
   */
  _setupStream(stream) {
    stream.on('error', this._onError);

    return stream;
  }

  /**
   * TODO: add method description.
   * @param {Stream} stream - TODO: add param description.
   * @returns {mixed} - TODO: add return description.
   */
  _cleanupStream(stream) {
    stream.removeListener('error', this._onError);
    stream.destroy();
    return stream;
  }

  /**
   * TODO: add method description.
   */
  _rotateFile() {
    this._incFile(() => this.open());
  }

  /**
   * Unpipe from the stream that has been marked as full and end it so it
   * flushes to disk.
   *
   * @param {function} callback - Callback for when the current file has closed.
   * @private
   */
  _endStream(callback = () => { }) {
    if (this._dest) {
      this._stream.unpipe(this._dest);
      this._dest.end(() => {
        this._cleanupStream(this._dest);
        callback();
      });
    } else {
      callback(); // eslint-disable-line callback-return
    }
  }

  /**
   * Returns the WritableStream for the active file on this instance. If we
   * should gzip the file then a zlib stream is returned.
   *
   * @param {ReadableStream} source ‚ÄìPassThrough to pipe to the file when open.
   * @returns {WritableStream} Stream that writes to disk for the active file.
   */
  _createStream(source) {
    const fullpath = path.join(this.dirname, this.filename);

    debug('create stream start', fullpath, this.options);
    const dest = fs.createWriteStream(fullpath, this.options)
      // TODO: What should we do with errors here?
      .on('error', err => debug(err))
      .on('close', () => debug('close', dest.path, dest.bytesWritten))
      .on('open', () => {
        debug('file open ok', fullpath);
        this.emit('open', fullpath);
        source.pipe(dest);

        // If rotation occured during the open operation then we immediately
        // start writing to a new PassThrough, begin opening the next file
        // and cleanup the previous source and dest once the source has drained.
        if (this.rotatedWhileOpening) {
          this._stream = new PassThrough();
          this._stream.setMaxListeners(30);
          this._rotateFile();
          this.rotatedWhileOpening = false;
          this._cleanupStream(dest);
          source.end();
        }
      });

    debug('create stream ok', fullpath);
    return dest;
  }

  /**
   * TODO: add method description.
   * @param {function} callback - TODO: add param description.
   * @returns {undefined}
   */
  _incFile(callback) {
    debug('_incFile', this.filename);
    const ext = path.extname(this._basename);
    const basename = path.basename(this._basename, ext);
    const tasks = [];

    if (this.zippedArchive) {
      tasks.push(
        function (cb) {
          const num = this._created > 0 && !this.tailable ? this._created : '';
          this._compressFile(
            path.join(this.dirname, `${basename}${num}${ext}`),
            path.join(this.dirname, `${basename}${num}${ext}.gz`),
            cb
          );
        }.bind(this)
      );
    }

    tasks.push(
      function (cb) {
        if (!this.tailable) {
          this._created += 1;
          this._checkMaxFilesIncrementing(ext, basename, cb);
        } else {
          this._checkMaxFilesTailable(ext, basename, cb);
        }
      }.bind(this)
    );

    asyncSeries(tasks, callback);
  }

  /**
   * Gets the next filename to use for this instance in the case that log
   * filesizes are being capped.
   * @returns {string} - TODO: add return description.
   * @private
   */
  _getFile() {
    const ext = path.extname(this._basename);
    const basename = path.basename(this._basename, ext);
    const isRotation = this.rotationFormat
      ? this.rotationFormat()
      : this._created;

    // Caveat emptor (indexzero): rotationFormat() was broken by design When
    // combined with max files because the set of files to unlink is never
    // stored.
    return !this.tailable && this._created
      ? `${basename}${isRotation}${ext}`
      : `${basename}${ext}`;
  }

  /**
   * Increment the number of files created or checked by this instance.
   * @param {mixed} ext - TODO: add param description.
   * @param {mixed} basename - TODO: add param description.
   * @param {mixed} callback - TODO: add param description.
   * @returns {undefined}
   * @private
   */
  _checkMaxFilesIncrementing(ext, basename, callback) {
    // Check for maxFiles option and delete file.
    if (!this.maxFiles || this._created < this.maxFiles) {
      return setImmediate(callback);
    }

    const oldest = this._created - this.maxFiles;
    const isOldest = oldest !== 0 ? oldest : '';
    const isZipped = this.zippedArchive ? '.gz' : '';
    const filePath = `${basename}${isOldest}${ext}${isZipped}`;
    const target = path.join(this.dirname, filePath);

    fs.unlink(target, callback);
  }

  /**
   * Roll files forward based on integer, up to maxFiles. e.g. if base if
   * file.log and it becomes oversized, roll to file1.log, and allow file.log
   * to be re-used. If file is oversized again, roll file1.log to file2.log,
   * roll file.log to file1.log, and so on.
   * @param {mixed} ext - TODO: add param description.
   * @param {mixed} basename - TODO: add param description.
   * @param {mixed} callback - TODO: add param description.
   * @returns {undefined}
   * @private
   */
  _checkMaxFilesTailable(ext, basename, callback) {
    const tasks = [];
    if (!this.maxFiles) {
      return;
    }

    // const isZipped = this.zippedArchive ? '.gz' : '';
    const isZipped = this.zippedArchive ? '.gz' : '';
    for (let x = this.maxFiles - 1; x > 1; x--) {
      tasks.push(function (i, cb) {
        let fileName = `${basename}${(i - 1)}${ext}${isZipped}`;
        const tmppath = path.join(this.dirname, fileName);

        fs.exists(tmppath, exists => {
          if (!exists) {
            return cb(null);
          }

          fileName = `${basename}${i}${ext}${isZipped}`;
          fs.rename(tmppath, path.join(this.dirname, fileName), cb);
        });
      }.bind(this, x));
    }

    asyncSeries(tasks, () => {
      fs.rename(
        path.join(this.dirname, `${basename}${ext}${isZipped}`),
        path.join(this.dirname, `${basename}1${ext}${isZipped}`),
        callback
      );
    });
  }

  /**
   * Compresses src to dest with gzip and unlinks src
   * @param {string} src - path to source file.
   * @param {string} dest - path to zipped destination file.
   * @param {Function} callback - callback called after file has been compressed.
   * @returns {undefined}
   * @private
   */
  _compressFile(src, dest, callback) {
    fs.access(src, fs.F_OK, (err) => {
      if (err) {
        return callback();
      }
      var gzip = zlib.createGzip();
      var inp = fs.createReadStream(src);
      var out = fs.createWriteStream(dest);
      out.on('finish', () => {
        fs.unlink(src, callback);
      });
      inp.pipe(gzip).pipe(out);
    });
  }

  _createLogDirIfNotExist(dirPath) {
    /* eslint-disable no-sync */
    if (!fs.existsSync(dirPath)) {
      fs.mkdirSync(dirPath, { recursive: true });
    }
    /* eslint-enable no-sync */
  }
};


/***/ }),

/***/ 70376:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";
/**
 * http.js: Transport for outputting to a json-rpcserver.
 *
 * (C) 2010 Charlie Robbins
 * MIT LICENCE
 */



const http = __nccwpck_require__(58611);
const https = __nccwpck_require__(65692);
const { Stream } = __nccwpck_require__(86131);
const TransportStream = __nccwpck_require__(3588);
const { configure } = __nccwpck_require__(37467);

/**
 * Transport for outputting to a json-rpc server.
 * @type {Stream}
 * @extends {TransportStream}
 */
module.exports = class Http extends TransportStream {
  /**
   * Constructor function for the Http transport object responsible for
   * persisting log messages and metadata to a terminal or TTY.
   * @param {!Object} [options={}] - Options for this instance.
   */
  // eslint-disable-next-line max-statements
  constructor(options = {}) {
    super(options);

    this.options = options;
    this.name = options.name || 'http';
    this.ssl = !!options.ssl;
    this.host = options.host || 'localhost';
    this.port = options.port;
    this.auth = options.auth;
    this.path = options.path || '';
    this.maximumDepth = options.maximumDepth;
    this.agent = options.agent;
    this.headers = options.headers || {};
    this.headers['content-type'] = 'application/json';
    this.batch = options.batch || false;
    this.batchInterval = options.batchInterval || 5000;
    this.batchCount = options.batchCount || 10;
    this.batchOptions = [];
    this.batchTimeoutID = -1;
    this.batchCallback = {};

    if (!this.port) {
      this.port = this.ssl ? 443 : 80;
    }
  }

  /**
   * Core logging method exposed to Winston.
   * @param {Object} info - TODO: add param description.
   * @param {function} callback - TODO: add param description.
   * @returns {undefined}
   */
  log(info, callback) {
    this._request(info, null, null, (err, res) => {
      if (res && res.statusCode !== 200) {
        err = new Error(`Invalid HTTP Status Code: ${res.statusCode}`);
      }

      if (err) {
        this.emit('warn', err);
      } else {
        this.emit('logged', info);
      }
    });

    // Remark: (jcrugzz) Fire and forget here so requests dont cause buffering
    // and block more requests from happening?
    if (callback) {
      setImmediate(callback);
    }
  }

  /**
   * Query the transport. Options object is optional.
   * @param {Object} options -  Loggly-like query options for this instance.
   * @param {function} callback - Continuation to respond to when complete.
   * @returns {undefined}
   */
  query(options, callback) {
    if (typeof options === 'function') {
      callback = options;
      options = {};
    }

    options = {
      method: 'query',
      params: this.normalizeQuery(options)
    };

    const auth = options.params.auth || null;
    delete options.params.auth;

    const path = options.params.path || null;
    delete options.params.path;

    this._request(options, auth, path, (err, res, body) => {
      if (res && res.statusCode !== 200) {
        err = new Error(`Invalid HTTP Status Code: ${res.statusCode}`);
      }

      if (err) {
        return callback(err);
      }

      if (typeof body === 'string') {
        try {
          body = JSON.parse(body);
        } catch (e) {
          return callback(e);
        }
      }

      callback(null, body);
    });
  }

  /**
   * Returns a log stream for this transport. Options object is optional.
   * @param {Object} options - Stream options for this instance.
   * @returns {Stream} - TODO: add return description
   */
  stream(options = {}) {
    const stream = new Stream();
    options = {
      method: 'stream',
      params: options
    };

    const path = options.params.path || null;
    delete options.params.path;

    const auth = options.params.auth || null;
    delete options.params.auth;

    let buff = '';
    const req = this._request(options, auth, path);

    stream.destroy = () => req.destroy();
    req.on('data', data => {
      data = (buff + data).split(/\n+/);
      const l = data.length - 1;

      let i = 0;
      for (; i < l; i++) {
        try {
          stream.emit('log', JSON.parse(data[i]));
        } catch (e) {
          stream.emit('error', e);
        }
      }

      buff = data[l];
    });
    req.on('error', err => stream.emit('error', err));

    return stream;
  }

  /**
   * Make a request to a winstond server or any http server which can
   * handle json-rpc.
   * @param {function} options - Options to sent the request.
   * @param {Object?} auth - authentication options
   * @param {string} path - request path
   * @param {function} callback - Continuation to respond to when complete.
   */
  _request(options, auth, path, callback) {
    options = options || {};

    auth = auth || this.auth;
    path = path || this.path || '';

    if (this.batch) {
      this._doBatch(options, callback, auth, path);
    } else {
      this._doRequest(options, callback, auth, path);
    }
  }

  /**
   * Send or memorize the options according to batch configuration
   * @param {function} options - Options to sent the request.
   * @param {function} callback - Continuation to respond to when complete.
   * @param {Object?} auth - authentication options
   * @param {string} path - request path
   */
  _doBatch(options, callback, auth, path) {
    this.batchOptions.push(options);
    if (this.batchOptions.length === 1) {
      // First message stored, it's time to start the timeout!
      const me = this;
      this.batchCallback = callback;
      this.batchTimeoutID = setTimeout(function () {
        // timeout is reached, send all messages to endpoint
        me.batchTimeoutID = -1;
        me._doBatchRequest(me.batchCallback, auth, path);
      }, this.batchInterval);
    }
    if (this.batchOptions.length === this.batchCount) {
      // max batch count is reached, send all messages to endpoint
      this._doBatchRequest(this.batchCallback, auth, path);
    }
  }

  /**
   * Initiate a request with the memorized batch options, stop the batch timeout
   * @param {function} callback - Continuation to respond to when complete.
   * @param {Object?} auth - authentication options
   * @param {string} path - request path
   */
  _doBatchRequest(callback, auth, path) {
    if (this.batchTimeoutID > 0) {
      clearTimeout(this.batchTimeoutID);
      this.batchTimeoutID = -1;
    }
    const batchOptionsCopy = this.batchOptions.slice();
    this.batchOptions = [];
    this._doRequest(batchOptionsCopy, callback, auth, path);
  }

  /**
   * Make a request to a winstond server or any http server which can
   * handle json-rpc.
   * @param {function} options - Options to sent the request.
   * @param {function} callback - Continuation to respond to when complete.
   * @param {Object?} auth - authentication options
   * @param {string} path - request path
   */
  _doRequest(options, callback, auth, path) {
    // Prepare options for outgoing HTTP request
    const headers = Object.assign({}, this.headers);
    if (auth && auth.bearer) {
      headers.Authorization = `Bearer ${auth.bearer}`;
    }
    const req = (this.ssl ? https : http).request({
      ...this.options,
      method: 'POST',
      host: this.host,
      port: this.port,
      path: `/${path.replace(/^\//, '')}`,
      headers: headers,
      auth: (auth && auth.username && auth.password) ? (`${auth.username}:${auth.password}`) : '',
      agent: this.agent
    });

    req.on('error', callback);
    req.on('response', res => (
      res.on('end', () => callback(null, res)).resume()
    ));
    const jsonStringify = configure({
      ...(this.maximumDepth && { maximumDepth: this.maximumDepth })
    });
    req.end(Buffer.from(jsonStringify(options, this.options.replacer), 'utf8'));
  }
};


/***/ }),

/***/ 27522:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";
/**
 * transports.js: Set of all transports Winston knows about.
 *
 * (C) 2010 Charlie Robbins
 * MIT LICENCE
 */



/**
 * TODO: add property description.
 * @type {Console}
 */
Object.defineProperty(exports, "Console", ({
  configurable: true,
  enumerable: true,
  get() {
    return __nccwpck_require__(49543);
  }
}));

/**
 * TODO: add property description.
 * @type {File}
 */
Object.defineProperty(exports, "File", ({
  configurable: true,
  enumerable: true,
  get() {
    return __nccwpck_require__(5478);
  }
}));

/**
 * TODO: add property description.
 * @type {Http}
 */
Object.defineProperty(exports, "Http", ({
  configurable: true,
  enumerable: true,
  get() {
    return __nccwpck_require__(70376);
  }
}));

/**
 * TODO: add property description.
 * @type {Stream}
 */
Object.defineProperty(exports, "Stream", ({
  configurable: true,
  enumerable: true,
  get() {
    return __nccwpck_require__(33464);
  }
}));


/***/ }),

/***/ 33464:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";
/**
 * stream.js: Transport for outputting to any arbitrary stream.
 *
 * (C) 2010 Charlie Robbins
 * MIT LICENCE
 */



const isStream = __nccwpck_require__(96543);
const { MESSAGE } = __nccwpck_require__(28836);
const os = __nccwpck_require__(70857);
const TransportStream = __nccwpck_require__(3588);

/**
 * Transport for outputting to any arbitrary stream.
 * @type {Stream}
 * @extends {TransportStream}
 */
module.exports = class Stream extends TransportStream {
  /**
   * Constructor function for the Console transport object responsible for
   * persisting log messages and metadata to a terminal or TTY.
   * @param {!Object} [options={}] - Options for this instance.
   */
  constructor(options = {}) {
    super(options);

    if (!options.stream || !isStream(options.stream)) {
      throw new Error('options.stream is required.');
    }

    // We need to listen for drain events when write() returns false. This can
    // make node mad at times.
    this._stream = options.stream;
    this._stream.setMaxListeners(Infinity);
    this.isObjectMode = options.stream._writableState.objectMode;
    this.eol = (typeof options.eol === 'string') ? options.eol : os.EOL;
  }

  /**
   * Core logging method exposed to Winston.
   * @param {Object} info - TODO: add param description.
   * @param {Function} callback - TODO: add param description.
   * @returns {undefined}
   */
  log(info, callback) {
    setImmediate(() => this.emit('logged', info));
    if (this.isObjectMode) {
      this._stream.write(info);
      if (callback) {
        callback(); // eslint-disable-line callback-return
      }
      return;
    }

    this._stream.write(`${info[MESSAGE]}${this.eol}`);
    if (callback) {
      callback(); // eslint-disable-line callback-return
    }
    return;
  }
};


/***/ }),

/***/ 80869:
/***/ ((module) => {

module.exports = extend

var hasOwnProperty = Object.prototype.hasOwnProperty;

function extend() {
    var target = {}

    for (var i = 0; i < arguments.length; i++) {
        var source = arguments[i]

        for (var key in source) {
            if (hasOwnProperty.call(source, key)) {
                target[key] = source[key]
            }
        }
    }

    return target
}


/***/ }),

/***/ 44671:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

// MySQL Database Configuration for Server
// This is a bridge between the main database config and the server

const mysqlConfig = __nccwpck_require__(55364);

// Re-export MySQL connection functions
const {
  getPool,
  query,
  queryOne,
  transaction,
  testConnection,
  closePool
} = mysqlConfig;

// Network paths (same as before)
const networkDataPath = mysqlConfig.networkDataPath;
const networkProjectsPath = mysqlConfig.networkProjectsPath;

// Database info for logging
const dbInfo = {
  type: 'MySQL',
  host: mysqlConfig.config.host,
  database: mysqlConfig.config.database,
  port: mysqlConfig.config.port
};

console.log('üóÑÔ∏è  Database Type: MySQL');
console.log(`üìä Database: ${dbInfo.database} @ ${dbInfo.host}:${dbInfo.port}`);

// Export for server use
module.exports = {
  // MySQL connection pool
  getPool,
  query,
  queryOne,
  transaction,
  testConnection,
  closePool,

  // Database info
  dbInfo,
  dbPath: `${dbInfo.host}:${dbInfo.port}/${dbInfo.database}`,

  // Network paths
  networkDataPath,
  networkProjectsPath,

  // Helper function for backward compatibility with SQLite code
  // Wraps callback-based code to use promises
  db: {
    run: async (sql, params, callback) => {
      try {
        const result = await query(sql, params || []);
        if (callback) {
          callback(null, result);
        }
        return result;
      } catch (error) {
        if (callback) {
          callback(error);
        } else {
          throw error;
        }
      }
    },

    get: async (sql, params, callback) => {
      try {
        const result = await queryOne(sql, params || []);
        if (callback) {
          callback(null, result);
        }
        return result;
      } catch (error) {
        if (callback) {
          callback(error);
        } else {
          throw error;
        }
      }
    },

    all: async (sql, params, callback) => {
      try {
        const results = await query(sql, params || []);
        if (callback) {
          callback(null, results);
        }
        return results;
      } catch (error) {
        if (callback) {
          callback(error);
        } else {
          throw error;
        }
      }
    },

    // Transaction support
    transaction
  }
};


/***/ }),

/***/ 5024:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

// Database Configuration - Supports both SQLite and MySQL
// Automatically uses MySQL if configured, falls back to SQLite

// Load environment variables FIRST
(__nccwpck_require__(18889).config)();

const path = __nccwpck_require__(16928);
const fs = __nccwpck_require__(79896);

// Check if we should use MySQL
const USE_MYSQL = process.env.USE_MYSQL === 'true' || process.env.DB_HOST;

let db, dbPath, networkDataPath, networkProjectsPath;

if (USE_MYSQL) {
  // ============================================================================
  // MySQL CONFIGURATION (Recommended for production)
  // ============================================================================
  console.log('üóÑÔ∏è  Using MySQL Database');

  try {
    const mysqlConfig = __nccwpck_require__(55364);

    // Export MySQL functions
    db = {
      query: mysqlConfig.query,
      queryOne: mysqlConfig.queryOne,
      transaction: mysqlConfig.transaction,

      // Backward compatibility with SQLite callback style
      run: async (sql, params, callback) => {
        try {
          const result = await mysqlConfig.query(sql, Array.isArray(params) ? params : []);
          if (callback) {
            // Call callback with this context having lastID for INSERT operations
            const context = {};
            if (result && typeof result.insertId !== 'undefined') {
              context.lastID = result.insertId;
            }
            callback.call(context, null, result);
          }
          return result;
        } catch (error) {
          if (callback) {
            callback(error);
          } else {
            throw error;
          }
        }
      },

      get: async (sql, params, callback) => {
        try {
          const result = await mysqlConfig.queryOne(sql, Array.isArray(params) ? params : []);
          if (callback) {
            callback(null, result);
          }
          return result;
        } catch (error) {
          if (callback) {
            callback(error);
          } else {
            throw error;
          }
        }
      },

      all: async (sql, params, callback) => {
        try {
          const results = await mysqlConfig.query(sql, Array.isArray(params) ? params : []);
          if (callback) {
            callback(null, results);
          }
          return results;
        } catch (error) {
          if (callback) {
            callback(error);
          } else {
            throw error;
          }
        }
      }
    };

    dbPath = `${mysqlConfig.config.host}:${mysqlConfig.config.port}/${mysqlConfig.config.database}`;
    networkDataPath = mysqlConfig.networkDataPath;
    networkProjectsPath = mysqlConfig.networkProjectsPath;

    console.log(`üìä MySQL: ${mysqlConfig.config.database} @ ${mysqlConfig.config.host}:${mysqlConfig.config.port}`);

  } catch (error) {
    console.error('‚ùå Failed to load MySQL configuration:', error.message);
    console.error('üí° Falling back to SQLite...\n');
    // Fall back to SQLite
    setupSQLite();
  }

} else {
  // ============================================================================
  // SQLITE CONFIGURATION (Legacy/Development)
  // ============================================================================
  setupSQLite();
}

function setupSQLite() {
  console.log('üóÑÔ∏è  Using SQLite Database');

  const sqlite3 = (__nccwpck_require__(38488).verbose)();

  // Check if we should use local storage (for testing/development)
  if (process.env.USE_LOCAL_STORAGE === 'true') {
    // Local Storage Configuration
    const projectRoot = path.join(__dirname, '..', '..');
    networkDataPath = path.join(projectRoot, 'uploads');
    networkProjectsPath = path.join(projectRoot, 'projects');
    dbPath = path.join(projectRoot, 'database.sqlite');

    // Create directories if they don't exist
    [networkDataPath, networkProjectsPath, path.join(networkDataPath, 'uploads')].forEach(dir => {
      if (!fs.existsSync(dir)) {
        fs.mkdirSync(dir, { recursive: true });
        console.log(`‚úÖ Created directory: ${dir}`);
      }
    });

    console.log('üè† Using LOCAL storage for uploads');
    console.log(`üìÅ Uploads directory: ${networkDataPath}`);
  }
  // Check if we're in local test mode
  else if (fs.existsSync(path.join(__dirname, '..', '..', 'local-test', 'data'))) {
    const localTestPath = path.join(__dirname, '..', '..', 'local-test', 'data');
    networkDataPath = localTestPath;
    networkProjectsPath = path.join(__dirname, '..', '..', 'local-test', 'PROJECTS');
    dbPath = path.join(networkDataPath, 'filemanagement.db');
    console.log('üè† Using local test database');
  }
  // Default: Network Database Configuration
  else {
    networkDataPath = '\\\\KMTI-NAS\\Shared\\data';
    networkProjectsPath = '\\\\KMTI-NAS\\Shared\\Public\\PROJECTS';
    dbPath = path.join(networkDataPath, 'filemanagement.db');
  }

  // Database setup with WAL mode for better write performance
  db = new sqlite3.Database(dbPath, (err) => {
    if (err) {
      console.error('‚ùå Error opening database:', err.message);
      console.error('üí° Path:', dbPath);
    } else {
      console.log('‚úÖ Connected to SQLite database:', dbPath);

      // Enable WAL mode for better concurrency
      db.run('PRAGMA journal_mode = WAL;', (err) => {
        if (err) {
          console.error('‚ùå Error enabling WAL mode:', err);
        } else {
          console.log('‚úÖ WAL mode enabled');
        }
      });

      // Set synchronous mode to NORMAL
      db.run('PRAGMA synchronous = NORMAL;', (err) => {
        if (err) {
          console.error('‚ùå Error setting synchronous mode:', err);
        } else {
          console.log('‚úÖ Synchronous mode: NORMAL');
        }
      });
    }
  });
}

// Graceful shutdown function
function closeDatabase() {
  if (USE_MYSQL) {
    const mysqlConfig = __nccwpck_require__(55364);
    return mysqlConfig.closePool();
  } else {
    return new Promise((resolve) => {
      if (db && db.close) {
        db.close((err) => {
          if (err) {
            console.error('Error closing database:', err);
          }
          resolve();
        });
      } else {
        resolve();
      }
    });
  }
}

module.exports = {
  db,
  dbPath,
  networkDataPath,
  networkProjectsPath,
  USE_MYSQL,
  closeDatabase
};


/***/ }),

/***/ 62489:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

const express = __nccwpck_require__(85152);
const cors = __nccwpck_require__(24085);
const multer = __nccwpck_require__(98013);
const path = __nccwpck_require__(16928);
const fs = __nccwpck_require__(79896);
const { networkDataPath } = __nccwpck_require__(5024);

// FIXED: Import async file utilities
const { moveToUserFolder: moveToUserFolderAsync } = __nccwpck_require__(43939);

// Network Uploads Configuration
const uploadsDir = path.join(networkDataPath, 'uploads');

// Ensure uploads directory exists with detailed error logging
if (!fs.existsSync(uploadsDir)) {
  try {
    fs.mkdirSync(uploadsDir, { recursive: true });
    console.log(`‚úÖ Created uploads directory: ${uploadsDir}`);
  } catch (mkdirError) {
    console.error('‚ùå CRITICAL: Cannot create uploads directory!');
    console.error('   Path:', uploadsDir);
    console.error('   Error:', mkdirError.message);
    console.error('   üí° Solution:');
    console.error('      1. Check network connection to NAS');
    console.error('      2. Verify folder permissions');
    console.error('      3. Or enable local storage: USE_LOCAL_STORAGE=true in .env');
    console.error('   ‚ö†Ô∏è  File uploads will FAIL until this is resolved!');
  }
} else {
  console.log(`‚úÖ Uploads directory ready: ${uploadsDir}`);

  // Test write permission
  const testFile = path.join(uploadsDir, '.test-write-' + Date.now());
  try {
    fs.writeFileSync(testFile, 'test');
    fs.unlinkSync(testFile);
    console.log('‚úÖ Uploads directory is writable');
  } catch (writeError) {
    console.error('‚ùå WARNING: Uploads directory exists but is NOT writable!');
    console.error('   Error:', writeError.message);
    console.error('   üí° Check folder permissions on the NAS');
  }
}

// Configure multer storage with optimizations for large files
const storage = multer.diskStorage({
  destination: function (req, file, cb) {
    // Save to uploads root first
    cb(null, uploadsDir);
  },
  filename: function (req, file, cb) {
    // Save with a simple temp name (no special characters)
    // We'll use the properly decoded name when moving to final location
    const timestamp = Date.now();
    const randomString = Math.random().toString(36).substring(7);
    cb(null, `temp_${timestamp}_${randomString}`);
  }
});

// Create multer upload middleware with optimizations
const upload = multer({
  storage: storage,
  // Optimized limits for better performance
  limits: {
    // No file size limit - set to undefined
    files: 1 // Only one file at a time
  }
});

function setupMiddleware(app) {
  // CORS configuration with UTF-8 support
  // CORS configuration with UTF-8 support
  app.use(cors({
    origin: function (origin, callback) {
      // Allow requests with no origin (like mobile apps, curl, or Electron file://)
      if (!origin) return callback(null, true);

      // Allow file:// protocol
      if (origin === 'file://') return callback(null, true);

      // Allow localhost and local network IPs
      const allowedOrigins = [
        'http://localhost:5173',
        'http://localhost:3001',
        process.env.CORS_ORIGIN,
        'http://192.168.200.105:3001' // Explicitly allow the server IP
      ].filter(Boolean);

      if (allowedOrigins.indexOf(origin) !== -1 || allowedOrigins.includes('*')) {
        return callback(null, true);
      }

      // Allow any 192.168.x.x origin (Local Network)
      if (origin.startsWith('http://192.168.') || origin.startsWith('https://192.168.')) {
        return callback(null, true);
      }

      // Default: Allow it anyway for this internal tool to prevent friction
      // (You can restrict this later if security is a concern)
      return callback(null, true);
    },
    credentials: true,
    exposedHeaders: ['Content-Disposition']
  }));

  // JSON parsing with extended options to handle UTF-8 special characters
  app.use(express.json({
    extended: true,
    limit: '50mb' // Increase limit for larger payloads
  }));

  app.use(express.urlencoded({
    extended: true,
    limit: '50mb',
    parameterLimit: 50000
  }));

  // Serve uploaded files - FORCE inline display (no downloads)
  app.use('/uploads', express.static(uploadsDir, {
    // Set headers to force inline display
    setHeaders: (res, filePath) => {
      // CRITICAL: Always use 'inline' to open in browser, never 'attachment'
      res.setHeader('Content-Disposition', 'inline');

      // Set proper MIME type for common file types
      const ext = path.extname(filePath).toLowerCase();
      const mimeTypes = {
        '.pdf': 'application/pdf',
        '.jpg': 'image/jpeg',
        '.jpeg': 'image/jpeg',
        '.png': 'image/png',
        '.gif': 'image/gif',
        '.txt': 'text/plain',
        '.html': 'text/html',
        '.json': 'application/json',
        '.xml': 'application/xml',
        '.mp4': 'video/mp4',
        '.mp3': 'audio/mpeg',
        '.zip': 'application/zip',
        '.doc': 'application/msword',
        '.docx': 'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
        '.xls': 'application/vnd.ms-excel',
        '.xlsx': 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
        '.ppt': 'application/vnd.ms-powerpoint',
        '.pptx': 'application/vnd.openxmlformats-officedocument.presentationml.presentation'
      };

      const mimeType = mimeTypes[ext] || 'application/octet-stream';
      res.setHeader('Content-Type', mimeType);

      // Disable download for all files
      res.setHeader('X-Content-Type-Options', 'nosniff');
    }
  }));
}

module.exports = {
  setupMiddleware,
  upload,
  uploadsDir,
  moveToUserFolder: moveToUserFolderAsync  // FIXED: Now exports async version
};


/***/ }),

/***/ 74279:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

const fs = (__nccwpck_require__(79896).promises);
const { db, USE_MYSQL } = __nccwpck_require__(5024);
const { uploadsDir } = __nccwpck_require__(62489);
const fileIndexer = __nccwpck_require__(26106);

// Async function to verify network uploads directory access
async function verifyUploadsDirectory() {
  try {
    await fs.access(uploadsDir);
    console.log('‚úÖ Network uploads directory found:', uploadsDir);
  } catch (err) {
    console.log('‚ö†Ô∏è Network uploads directory not found, attempting to create:', uploadsDir);
    try {
      await fs.mkdir(uploadsDir, { recursive: true });
      console.log('‚úÖ Created network uploads directory:', uploadsDir);
    } catch (mkdirErr) {
      console.error('‚ùå Failed to create network uploads directory:', mkdirErr.message);
      console.error('üí° Please ensure network path is accessible and has write permissions');
    }
  }
}

// Initialize database with async operations
async function initializeDatabase() {
  if (USE_MYSQL) {
    // ========================================================================
    // MySQL INITIALIZATION
    // ========================================================================
    console.log('üîß Initializing MySQL database...');

    try {
      const mysqlConfig = __nccwpck_require__(55364);

      // Test connection
      const connected = await mysqlConfig.testConnection();
      if (!connected) {
        throw new Error('Failed to connect to MySQL database');
      }

      // Check if tables exist
      const tables = await mysqlConfig.query('SHOW TABLES');

      if (tables.length === 0) {
        console.log('‚ö†Ô∏è  No tables found. Please run: npm run db:init');
        console.log('   This will create all required tables and initial data.');
      } else {
        console.log(`‚úÖ Found ${tables.length} tables in database`);

        // Verify required tables exist
        const tableNames = tables.map(t => Object.values(t)[0]);
        const requiredTables = ['users', 'teams', 'files', 'file_comments',
          'file_status_history', 'activity_logs'];
        const missingTables = requiredTables.filter(t => !tableNames.includes(t));

        if (missingTables.length > 0) {
          console.log('‚ö†Ô∏è  Missing tables:', missingTables.join(', '));
          console.log('   Run: npm run db:init');
        } else {
          console.log('‚úÖ All required tables present');
        }
      }

      console.log('üìÅ File approval system ready (MySQL)');
      console.log('‚úÖ Database initialized successfully');

      // Initialize file index table
      await fileIndexer.initializeIndexTable();

    } catch (error) {
      console.error('‚ùå MySQL initialization error:', error.message);
      console.error('üí° Please ensure:');
      console.error('   1. MySQL server is running');
      console.error('   2. Database credentials are correct in database/config.js');
      console.error('   3. Database has been initialized: npm run db:init');
      throw error;
    }

  } else {
    // ========================================================================
    // SQLITE INITIALIZATION
    // ========================================================================
    console.log('üîß Initializing SQLite database...');

    return new Promise((resolve, reject) => {
      // Create users table if it doesn't exist
      db.run(`CREATE TABLE IF NOT EXISTS users (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        fullName TEXT NOT NULL,
        username TEXT UNIQUE NOT NULL,
        email TEXT UNIQUE NOT NULL,
        password TEXT NOT NULL,
        role TEXT NOT NULL DEFAULT 'USER',
        team TEXT DEFAULT 'General',
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP
      )`, (err) => {
        if (err) {
          console.error('Error creating users table:', err);
          reject(err);
          return;
        }
        console.log('‚úÖ Users table created/verified');

        // Create activity_logs table
        db.run(`CREATE TABLE IF NOT EXISTS activity_logs (
          id INTEGER PRIMARY KEY AUTOINCREMENT,
          user_id INTEGER,
          username TEXT NOT NULL,
          role TEXT NOT NULL,
          team TEXT NOT NULL,
          activity TEXT NOT NULL,
          timestamp DATETIME DEFAULT CURRENT_TIMESTAMP,
          FOREIGN KEY (user_id) REFERENCES users (id)
        )`, (err) => {
          if (err) {
            console.error('Error creating activity_logs table:', err);
            reject(err);
            return;
          }
          console.log('‚úÖ Activity logs table created/verified');

          // Create files table for file approval system
          db.run(`CREATE TABLE IF NOT EXISTS files (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            filename TEXT NOT NULL,
            original_name TEXT NOT NULL,
            file_path TEXT NOT NULL,
            file_size INTEGER NOT NULL,
            file_type TEXT NOT NULL,
            mime_type TEXT NOT NULL,
            description TEXT,
            -- User Information
            user_id INTEGER NOT NULL,
            username TEXT NOT NULL,
            user_team TEXT NOT NULL,
            -- Workflow Status
            status TEXT NOT NULL DEFAULT 'uploaded',
            current_stage TEXT NOT NULL DEFAULT 'pending_team_leader',
            -- Team Leader Review
            team_leader_id INTEGER,
            team_leader_username TEXT,
            team_leader_reviewed_at DATETIME,
            team_leader_comments TEXT,
            -- Admin Review
            admin_id INTEGER,
            admin_username TEXT,
            admin_reviewed_at DATETIME,
            admin_comments TEXT,
            -- Public Network
            public_network_url TEXT,
            final_approved_at DATETIME,
            -- Rejection Information
            rejection_reason TEXT,
            rejected_by TEXT,
            rejected_at DATETIME,
            -- Timestamps
            uploaded_at DATETIME DEFAULT CURRENT_TIMESTAMP,
            updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
            FOREIGN KEY (user_id) REFERENCES users (id),
            FOREIGN KEY (team_leader_id) REFERENCES users (id),
            FOREIGN KEY (admin_id) REFERENCES users (id)
          )`, (err) => {
            if (err) {
              console.error('Error creating files table:', err);
              reject(err);
              return;
            }
            console.log('‚úÖ Files table created/verified');

            // Create file_comments table
            db.run(`CREATE TABLE IF NOT EXISTS file_comments (
              id INTEGER PRIMARY KEY AUTOINCREMENT,
              file_id INTEGER NOT NULL,
              user_id INTEGER NOT NULL,
              username TEXT NOT NULL,
              user_role TEXT NOT NULL,
              comment TEXT NOT NULL,
              comment_type TEXT NOT NULL DEFAULT 'general',
              created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
              FOREIGN KEY (file_id) REFERENCES files (id) ON DELETE CASCADE,
              FOREIGN KEY (user_id) REFERENCES users (id)
            )`, (err) => {
              if (err) {
                console.error('Error creating file_comments table:', err);
                reject(err);
                return;
              }
              console.log('‚úÖ File comments table created/verified');

              // Create file_status_history table
              db.run(`CREATE TABLE IF NOT EXISTS file_status_history (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                file_id INTEGER NOT NULL,
                old_status TEXT,
                new_status TEXT NOT NULL,
                old_stage TEXT,
                new_stage TEXT NOT NULL,
                changed_by_id INTEGER,
                changed_by_username TEXT NOT NULL,
                changed_by_role TEXT NOT NULL,
                reason TEXT,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (file_id) REFERENCES files (id) ON DELETE CASCADE,
                FOREIGN KEY (changed_by_id) REFERENCES users (id)
              )`, (err) => {
                if (err) {
                  console.error('Error creating file_status_history table:', err);
                  reject(err);
                  return;
                }
                console.log('‚úÖ File status history table created/verified');

                // Create teams table
                db.run(`CREATE TABLE IF NOT EXISTS teams (
                  id INTEGER PRIMARY KEY AUTOINCREMENT,
                  name TEXT UNIQUE NOT NULL,
                  description TEXT,
                  leader_id INTEGER,
                  leader_username TEXT,
                  color TEXT DEFAULT '#3B82F6',
                  is_active BOOLEAN DEFAULT 1,
                  created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                  updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                  FOREIGN KEY (leader_id) REFERENCES users (id)
                )`, (err) => {
                  if (err) {
                    console.error('Error creating teams table:', err);
                    reject(err);
                    return;
                  }
                  console.log('‚úÖ Teams table created/verified');

                  // Create assignments tables for Google Classroom-style functionality
                  db.run(`CREATE TABLE IF NOT EXISTS assignments (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    title TEXT NOT NULL,
                    description TEXT,
                    due_date DATETIME,
                    file_type_required TEXT,
                    assigned_to TEXT DEFAULT 'all',
                    max_file_size INTEGER DEFAULT 10485760,
                    team_leader_id INTEGER NOT NULL,
                    team_leader_username TEXT NOT NULL,
                    team TEXT NOT NULL,
                    status TEXT DEFAULT 'active',
                    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                    FOREIGN KEY (team_leader_id) REFERENCES users (id)
                  )`, (err) => {
                    if (err) {
                      console.error('Error creating assignments table:', err);
                      reject(err);
                      return;
                    }
                    console.log('‚úÖ Assignments table created/verified');

                    // Create assignment_members table
                    db.run(`CREATE TABLE IF NOT EXISTS assignment_members (
                      id INTEGER PRIMARY KEY AUTOINCREMENT,
                      assignment_id INTEGER NOT NULL,
                      user_id INTEGER NOT NULL,
                      status TEXT DEFAULT 'pending',
                      submitted_at DATETIME,
                      created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                      FOREIGN KEY (assignment_id) REFERENCES assignments (id) ON DELETE CASCADE,
                      FOREIGN KEY (user_id) REFERENCES users (id) ON DELETE CASCADE
                    )`, (err) => {
                      if (err) {
                        console.error('Error creating assignment_members table:', err);
                        reject(err);
                        return;
                      }
                      console.log('‚úÖ Assignment members table created/verified');

                      // Create assignment_submissions table
                      db.run(`CREATE TABLE IF NOT EXISTS assignment_submissions (
                        id INTEGER PRIMARY KEY AUTOINCREMENT,
                        assignment_id INTEGER NOT NULL,
                        file_id INTEGER NOT NULL,
                        user_id INTEGER NOT NULL,
                        submitted_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                        FOREIGN KEY (assignment_id) REFERENCES assignments (id) ON DELETE CASCADE,
                        FOREIGN KEY (file_id) REFERENCES files (id) ON DELETE CASCADE,
                        FOREIGN KEY (user_id) REFERENCES users (id) ON DELETE CASCADE
                      )`, (err) => {
                        if (err) {
                          console.error('Error creating assignment_submissions table:', err);
                          reject(err);
                          return;
                        }
                        console.log('‚úÖ Assignment submissions table created/verified');

                        // Create custom_tags table
                        db.run(`CREATE TABLE IF NOT EXISTS custom_tags (
                        id INTEGER PRIMARY KEY AUTOINCREMENT,
                          tag_name TEXT NOT NULL UNIQUE,
                          created_by INTEGER NOT NULL,
                        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                          FOREIGN KEY (created_by) REFERENCES users(id) ON DELETE CASCADE
                        )`, (err) => {
                          if (err) {
                          console.error('Error creating custom_tags table:', err);
                            reject(err);
                            return;
                        }
                        console.log('‚úÖ Custom tags table created/verified');

                        // Add database indexes
                        addDatabaseIndexes();

                        // Initialize file index table (async)
                        fileIndexer.initializeIndexTable().then(() => {
                          console.log('‚úÖ File index table initialized');
                        }).catch(err => {
                          console.error('‚ö†Ô∏è  Error initializing file index table:', err);
                        });

                        // Handle user table migration
                        handleUserTableMigration(resolve, reject);
                      });
                      });
                    });
                  });
                });
              });
            });
          });
        });
      });
    });
  }
}

// Add database indexes for frequently queried columns (SQLite only)
function addDatabaseIndexes() {
  const indexes = [
    'CREATE INDEX IF NOT EXISTS idx_users_email ON users(email)',
    'CREATE INDEX IF NOT EXISTS idx_users_username ON users(username)',
    'CREATE INDEX IF NOT EXISTS idx_users_team ON users(team)',
    'CREATE INDEX IF NOT EXISTS idx_files_user_id ON files(user_id)',
    'CREATE INDEX IF NOT EXISTS idx_files_user_team ON files(user_team)',
    'CREATE INDEX IF NOT EXISTS idx_files_current_stage ON files(current_stage)',
    'CREATE INDEX IF NOT EXISTS idx_files_uploaded_at ON files(uploaded_at)',
    'CREATE INDEX IF NOT EXISTS idx_activity_logs_timestamp ON activity_logs(timestamp)',
    'CREATE INDEX IF NOT EXISTS idx_activity_logs_user_id ON activity_logs(user_id)',
    'CREATE INDEX IF NOT EXISTS idx_file_comments_file_id ON file_comments(file_id)',
    'CREATE INDEX IF NOT EXISTS idx_custom_tags_name ON custom_tags(tag_name)',
    'CREATE INDEX IF NOT EXISTS idx_custom_tags_created_by ON custom_tags(created_by)'
  ];

  indexes.forEach(sql => {
    db.run(sql, (err) => {
      if (err) {
        console.error('‚ùå Error creating index:', err);
      }
    });
  });
}

// Handle user table migration (SQLite only)
function handleUserTableMigration(resolve, reject) {
  // Check table structure and add missing columns if needed
  db.all('PRAGMA table_info(users)', (err, columns) => {
    if (err) {
      console.error('Error getting table info:', err);
      reject(err);
      return;
    }
    const columnNames = columns.map(col => col.name);
    const hasFullName = columnNames.includes('fullName');
    const hasUsername = columnNames.includes('username');
    const hasRole = columnNames.includes('role');
    const hasTeam = columnNames.includes('team');

    // Add missing columns
    const alterPromises = [];
    if (!hasFullName) {
      alterPromises.push(new Promise((resolve, reject) => {
        db.run('ALTER TABLE users ADD COLUMN fullName TEXT DEFAULT "Unknown"', (err) => {
          if (err) {
            reject(err);
          } else {
            console.log('‚úÖ Added fullName column'); resolve();
          }
        });
      }));
    }
    if (!hasUsername) {
      alterPromises.push(new Promise((resolve, reject) => {
        db.run('ALTER TABLE users ADD COLUMN username TEXT', (err) => {
          if (err) {
            reject(err);
          } else {
            console.log('‚úÖ Added username column'); resolve();
          }
        });
      }));
    }
    if (!hasRole) {
      alterPromises.push(new Promise((resolve, reject) => {
        db.run('ALTER TABLE users ADD COLUMN role TEXT DEFAULT "USER"', (err) => {
          if (err) {
            reject(err);
          } else {
            console.log('‚úÖ Added role column'); resolve();
          }
        });
      }));
    }
    if (!hasTeam) {
      alterPromises.push(new Promise((resolve, reject) => {
        db.run('ALTER TABLE users ADD COLUMN team TEXT DEFAULT "General"', (err) => {
          if (err) {
            reject(err);
          } else {
            console.log('‚úÖ Added team column'); resolve();
          }
        });
      }));
    }

    Promise.all(alterPromises).then(() => {
      // Update existing records to have proper usernames if missing
      db.run(`UPDATE users SET username =
        CASE
          WHEN username IS NULL OR username = '' THEN
            SUBSTR(email, 1, INSTR(email, '@') - 1)
          ELSE username
        END
        WHERE username IS NULL OR username = ''`, (err) => {
        if (err) {
          console.error('Error updating usernames:', err);
        } else {
          console.log('‚úÖ Updated usernames for existing records');
        }
        // Database initialization complete
        console.log('üìÅ File approval system ready (SQLite)');
        console.log('‚úÖ Database initialized successfully');
        resolve();
      });
    }).catch(reject);
  });
}

module.exports = {
  initializeDatabase,
  verifyUploadsDirectory
};


/***/ }),

/***/ 59614:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

const express = __nccwpck_require__(85152);
const path = __nccwpck_require__(16928);
const fs = __nccwpck_require__(79896);
const { dbPath, networkDataPath, USE_MYSQL, closeDatabase } = __nccwpck_require__(5024);
const { setupMiddleware } = __nccwpck_require__(62489);
const { initializeDatabase, verifyUploadsDirectory } = __nccwpck_require__(74279);
const runMigrations = __nccwpck_require__(96706);
const { errorHandler, notFoundHandler, handleUnhandledRejection, handleUncaughtException } = __nccwpck_require__(5369);
const { logRequest, logInfo, logError } = __nccwpck_require__(46534);

// Hide console window on Windows when running as executable - MUST BE FIRST
if (process.platform === 'win32' && process.pkg) {
  // Execute immediately to hide console before any output
  try {
    const { execSync } = __nccwpck_require__(35317);
    // Use PowerShell to hide the current console window
    // eslint-disable-next-line no-useless-escape
    execSync('powershell -command "(Get-Process -Id $PID).MainWindowHandle | ForEach-Object { $hwnd = $_; Add-Type -TypeDefinition \'using System; using System.Runtime.InteropServices; public class Win32 { [DllImport(\\"user32.dll\\")] public static extern bool ShowWindow(IntPtr hWnd, int nCmdShow); }\'; [Win32]::ShowWindow($hwnd, 0) }" 2>nul', { stdio: 'ignore' });
  } catch (_e) {
    // If PowerShell method fails, try direct API calls
    try {
      const ffi = __nccwpck_require__(73941);
      const _ref = __nccwpck_require__(7919);

      const user32 = ffi.Library('user32', {
        'ShowWindow': ['bool', ['pointer', 'int32']],
        'GetConsoleWindow': ['pointer', []]
      });

      const kernel32 = ffi.Library('kernel32', {
        'FreeConsole': ['bool', []]
      });

      // Try to free console first
      kernel32.FreeConsole();

      // Then hide any remaining console window
      const SW_HIDE = 0;
      const consoleWindow = user32.GetConsoleWindow();
      if (consoleWindow && !consoleWindow.isNull()) {
        user32.ShowWindow(consoleWindow, SW_HIDE);
      }
    } catch (_e2) {
      // Continue silently
    }
  }
}

// Import routes
const authRoutes = __nccwpck_require__(38851);
const usersRoutes = __nccwpck_require__(30737);
const teamsRoutes = __nccwpck_require__(69915);
const activityLogsRoutes = __nccwpck_require__(70887);
const fileSystemRoutes = __nccwpck_require__(33162);
const filesRoutes = __nccwpck_require__(23490);
const dashboardRoutes = __nccwpck_require__(94049);
const settingsRoutes = __nccwpck_require__(52528);
const fileViewerRoutes = __nccwpck_require__(93925);
const { router: notificationsRoutes } = __nccwpck_require__(83565);
const assignmentsRoutes = __nccwpck_require__(20007);
const customTagsRoutes = __nccwpck_require__(15111);

const app = express();
const PORT = process.env.SERVER_PORT || 3001;

// Setup middleware
setupMiddleware(app);

// Add request logging
app.use(logRequest);

// Health check endpoint
app.get('/api/health', (req, res) => {
  res.status(200).json({
    status: 'healthy',
    timestamp: new Date().toISOString(),
    uptime: process.uptime()
  });
});

// Version endpoint - returns app version from package.json
app.get('/api/version', (req, res) => {
  try {
    const packageJsonPath = __nccwpck_require__.ab + "package.json";
    const packageJson = JSON.parse(fs.readFileSync(__nccwpck_require__.ab + "package.json", 'utf8'));
    res.status(200).json({
      success: true,
      version: packageJson.version,
      name: packageJson.name,
      description: packageJson.description
    });
  } catch (error) {
    logError(error, { context: 'version-endpoint' });
    res.status(500).json({
      success: false,
      error: 'Failed to retrieve version information'
    });
  }
});

// Register routes
app.use('/api/auth', authRoutes);
app.use('/api/users', usersRoutes);
app.use('/api/team-members', usersRoutes); // Alias for team members endpoint
app.use('/api/teams', teamsRoutes);
app.use('/api/activity-logs', activityLogsRoutes);
app.use('/api/file-system', fileSystemRoutes);
app.use('/api/files', filesRoutes);
app.use('/api/dashboard', dashboardRoutes);
app.use('/api/settings', settingsRoutes);
app.use('/api/file-viewer', fileViewerRoutes);
app.use('/api/notifications', notificationsRoutes);
app.use('/api/assignments', assignmentsRoutes);
app.use('/api/custom-tags', customTagsRoutes);

// Serve static files from the React app build directory
// In bundled mode, client files are in client-dist, otherwise in ../client/dist
const clientBuildPath = path.join(__dirname, 'client-dist');
const fallbackClientPath = __nccwpck_require__.ab + "dist";

// Check which path exists (bundled vs development)
const actualClientPath = fs.existsSync(clientBuildPath) ? clientBuildPath : fallbackClientPath;

if (fs.existsSync(actualClientPath)) {
  logInfo('Serving frontend', { path: actualClientPath });
  app.use(express.static(actualClientPath));

  // Catch all handler: send back React's index.html file for client-side routing
  app.get('*', (req, res) => {
    // Don't serve index.html for API routes
    if (req.path.startsWith('/api/')) {
      return res.status(404).json({ error: 'API endpoint not found' });
    }
    res.sendFile(path.join(actualClientPath, 'index.html'));
  });
} else {
  console.warn('‚ö†Ô∏è  Frontend build not found. Server will only serve API endpoints.');
}

// 404 handler for API routes
app.use('/api/*', notFoundHandler);

// Global error handler (must be last)
app.use(errorHandler);

// Setup global error handlers
handleUnhandledRejection();
handleUncaughtException();

// Start server
async function startServer() {
  try {
    await verifyUploadsDirectory();
    await initializeDatabase();

    // Run database migrations
    await runMigrations();

    app.listen(PORT, () => {
      console.log('\n' + '='.repeat(70));
      console.log(`üöÄ Express server running on http://localhost:${PORT}`);
      console.log(`üóÑÔ∏è  Database Type: ${USE_MYSQL ? 'MySQL' : 'SQLite'}`);
      console.log(`üìä Database: ${dbPath}`);
      console.log(`üåê Network Data Path: ${networkDataPath}`);
      console.log('='.repeat(70));
      console.log('\n‚úÖ Notifications API routes registered');
      console.log('\nüîÑ File Approval Workflow:');
      console.log('   1. User uploads file ‚Üí Pending Team Leader Review');
      console.log('   2. Team Leader approves ‚Üí Pending Admin Review');
      console.log('   3. Admin approves ‚Üí Published to Public Network');
      console.log('   ‚ùå Any stage can reject ‚Üí Back to User with comments');
      console.log('='.repeat(70));

      if (USE_MYSQL) {
        console.log('\n‚ú® MySQL Benefits:');
        console.log('   ‚Ä¢ Supports multiple concurrent users');
        console.log('   ‚Ä¢ No database corruption over network');
        console.log('   ‚Ä¢ Better performance and reliability');
        console.log('   ‚Ä¢ ACID compliant transactions\n');
      } else {
        console.log('\n‚ö†Ô∏è  Running with SQLite:');
        console.log('   ‚Ä¢ Limited to 1-2 concurrent users');
        console.log('   ‚Ä¢ Risk of corruption over network');
        console.log('   ‚Ä¢ Recommended: Switch to MySQL for production');
        console.log('   ‚Ä¢ To enable MySQL: Set USE_MYSQL=true or configure DB_HOST\n');
      }
    });
  } catch (error) {
    console.error('\n‚ùå Failed to start server:', error.message);
    console.error('Stack trace:', error.stack);

    if (USE_MYSQL) {
      console.error('\nüí° MySQL Troubleshooting:');
      console.error('   1. Ensure MySQL server is running');
      console.error('   2. Check credentials in database/config.js');
      console.error('   3. Verify database exists: npm run db:init');
      console.error('   4. Test connection: npm run db:test');
    }

    process.exit(1);
  }
}

startServer();

// Graceful shutdown
async function shutdown(signal) {
  console.log(`\n‚èπÔ∏è  Received ${signal}, shutting down gracefully...`);

  try {
    // Close database connection
    await closeDatabase();
    console.log('‚úÖ Database connection closed');

    // Exit successfully
    console.log('üëã Server stopped\n');
    process.exit(0);
  } catch (error) {
    console.error('‚ùå Error during shutdown:', error);
    process.exit(1);
  }
}

// Handle various shutdown signals
process.on('SIGINT', () => shutdown('SIGINT'));
process.on('SIGTERM', () => shutdown('SIGTERM'));

// Handle uncaught errors
process.on('uncaughtException', (error) => {
  console.error('‚ùå Uncaught Exception:', error);
  shutdown('UNCAUGHT_EXCEPTION');
});

process.on('unhandledRejection', (reason, promise) => {
  console.error('‚ùå Unhandled Rejection at:', promise, 'reason:', reason);
  shutdown('UNHANDLED_REJECTION');
});

module.exports = app;


/***/ }),

/***/ 5369:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

const { logError } = __nccwpck_require__(46534);

/**
 * Custom Application Error
 */
class AppError extends Error {
  constructor(message, statusCode = 500, isOperational = true) {
    super(message);
    this.statusCode = statusCode;
    this.isOperational = isOperational;
    this.timestamp = new Date().toISOString();

    Error.captureStackTrace(this, this.constructor);
  }
}

/**
 * Database Error
 */
class DatabaseError extends AppError {
  constructor(message, originalError = null) {
    super(message, 500, true);
    this.name = 'DatabaseError';
    this.originalError = originalError;
  }
}

/**
 * Validation Error
 */
class ValidationError extends AppError {
  constructor(message, errors = []) {
    super(message, 400, true);
    this.name = 'ValidationError';
    this.errors = errors;
  }
}

/**
 * Authentication Error
 */
class AuthenticationError extends AppError {
  constructor(message = 'Authentication failed') {
    super(message, 401, true);
    this.name = 'AuthenticationError';
  }
}

/**
 * Authorization Error
 */
class AuthorizationError extends AppError {
  constructor(message = 'Access denied') {
    super(message, 403, true);
    this.name = 'AuthorizationError';
  }
}

/**
 * Not Found Error
 */
class NotFoundError extends AppError {
  constructor(resource = 'Resource') {
    super(`${resource} not found`, 404, true);
    this.name = 'NotFoundError';
  }
}

/**
 * Centralized Error Handler Middleware
 */
const errorHandler = (err, req, res, _next) => {
  let error = err;

  // If it's not an AppError, convert it
  if (!(error instanceof AppError)) {
    const statusCode = error.statusCode || 500;
    const message = error.message || 'Internal server error';
    error = new AppError(message, statusCode, false);
  }

  // Log error
  logError(error, {
    url: req.originalUrl,
    method: req.method,
    ip: req.ip,
    userId: req.user?.id,
    body: req.body
  });

  // Prepare error response
  const response = {
    success: false,
    message: error.isOperational ? error.message : 'Internal server error',
    timestamp: error.timestamp || new Date().toISOString()
  };

  // Add validation errors if present
  if (error instanceof ValidationError && error.errors.length > 0) {
    response.errors = error.errors;
  }

  // Add stack trace in development
  if (process.env.NODE_ENV === 'development' && error.stack) {
    response.stack = error.stack;
  }

  // Send response
  res.status(error.statusCode).json(response);
};

/**
 * Async handler wrapper to catch errors in async route handlers
 */
const asyncHandler = (fn) => {
  return (req, res, next) => {
    Promise.resolve(fn(req, res, next)).catch(next);
  };
};

/**
 * 404 Not Found Handler
 */
const notFoundHandler = (req, res, next) => {
  const error = new NotFoundError(`Route ${req.originalUrl}`);
  next(error);
};

/**
 * Unhandled Rejection Handler
 */
const handleUnhandledRejection = () => {
  process.on('unhandledRejection', (reason, promise) => {
    console.error('‚ùå Unhandled Rejection at:', promise, 'reason:', reason);
    logError(new Error('Unhandled Rejection'), { reason, promise });
    // In production, you might want to gracefully shutdown
    // process.exit(1);
  });
};

/**
 * Uncaught Exception Handler
 */
const handleUncaughtException = () => {
  process.on('uncaughtException', (error) => {
    console.error('‚ùå Uncaught Exception:', error);
    logError(error, { type: 'uncaughtException' });
    // Exit process on uncaught exception
    process.exit(1);
  });
};

module.exports = {
  AppError,
  DatabaseError,
  ValidationError,
  AuthenticationError,
  AuthorizationError,
  NotFoundError,
  errorHandler,
  asyncHandler,
  notFoundHandler,
  handleUnhandledRejection,
  handleUncaughtException
};


/***/ }),

/***/ 17632:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

const Joi = __nccwpck_require__(81154);

/**
 * Validation Middleware
 * Validates request body against Joi schema
 */
const validate = (schema) => {
  return (req, res, next) => {
    const { error, value } = schema.validate(req.body, {
      abortEarly: false, // Return all errors, not just the first one
      stripUnknown: true // Remove unknown fields
    });

    if (error) {
      const errors = error.details.map(detail => ({
        field: detail.path.join('.'),
        message: detail.message.replace(/"/g, '') // Remove quotes from Joi messages
      }));

      // Create a user-friendly summary message
      const firstError = errors[0];
      let userMessage = 'Please check your input';

      if (firstError.field === 'password') {
        userMessage = firstError.message;
      } else if (errors.length === 1) {
        userMessage = firstError.message;
      } else {
        userMessage = `Please fix ${errors.length} validation errors`;
      }

      return res.status(400).json({
        success: false,
        message: userMessage,
        errors
      });
    }

    // Replace req.body with validated and sanitized value
    req.body = value;
    next();
  };
};

/**
 * Common validation schemas
 */
const schemas = {
  // User registration/creation
  createUser: Joi.object({
    fullName: Joi.string().min(2).max(100).required()
      .messages({
        'string.min': 'Full name must be at least 2 characters',
        'string.max': 'Full name cannot exceed 100 characters',
        'any.required': 'Full name is required'
      }),
    username: Joi.string().alphanum().min(3).max(30).required()
      .messages({
        'string.alphanum': 'Username must contain only letters and numbers',
        'string.min': 'Username must be at least 3 characters',
        'string.max': 'Username cannot exceed 30 characters',
        'any.required': 'Username is required'
      }),
    email: Joi.string().email().required()
      .messages({
        'string.email': 'Please provide a valid email address',
        'any.required': 'Email is required'
      }),
    password: Joi.string().min(8).max(100).required()
      .pattern(/^(?=.*[A-Za-z])(?=.*\d)/)
      .messages({
        'string.min': 'Password must be at least 8 characters long',
        'string.max': 'Password cannot exceed 100 characters',
        'string.pattern.base': 'Password must contain both letters and numbers',
        'any.required': 'Password is required'
      }),
    role: Joi.string().valid('USER', 'TEAM_LEADER', 'ADMIN').default('USER'),
    team: Joi.string().max(50).default('General'),
    // Admin info (for logging)
    adminId: Joi.number().optional(),
    adminUsername: Joi.string().optional(),
    adminRole: Joi.string().optional(),
    adminTeam: Joi.string().optional()
  }),

  // User login
  login: Joi.object({
    email: Joi.string().required()
      .messages({
        'any.required': 'Email or username is required'
      }),
    password: Joi.string().required()
      .messages({
        'any.required': 'Password is required'
      }),
    loginType: Joi.string().valid('user', 'admin').default('user')
  }),

  // Password reset
  resetPassword: Joi.object({
    password: Joi.string().min(8).max(100).required()
      .pattern(/^(?=.*[A-Za-z])(?=.*\d)/)
      .messages({
        'string.min': 'Password must be at least 8 characters long',
        'string.max': 'Password cannot exceed 100 characters',
        'string.pattern.base': 'Password must contain both letters and numbers',
        'any.required': 'Password is required'
      }),
    adminId: Joi.number().optional(),
    adminUsername: Joi.string().optional(),
    adminRole: Joi.string().optional(),
    adminTeam: Joi.string().optional()
  }),

  // Update user
  updateUser: Joi.object({
    fullName: Joi.string().min(2).max(100).optional(),
    username: Joi.string().alphanum().min(3).max(30).optional(),
    email: Joi.string().email().optional(),
    role: Joi.string().valid('USER', 'TEAM_LEADER', 'ADMIN').optional(),
    team: Joi.string().max(50).optional(),
    adminId: Joi.number().optional(),
    adminUsername: Joi.string().optional(),
    adminRole: Joi.string().optional(),
    adminTeam: Joi.string().optional()
  }).min(1), // At least one field must be provided

  // Forgot password
  forgotPassword: Joi.object({
    email: Joi.string().required()
      .messages({
        'any.required': 'Email or username is required'
      })
  }),

  // Reset password with token (self-service)
  resetPasswordWithToken: Joi.object({
    token: Joi.string().required()
      .messages({
        'any.required': 'Reset token is required'
      }),
    newPassword: Joi.string().min(8).max(100).required()
      .pattern(/^(?=.*[A-Za-z])(?=.*\d)/)
      .messages({
        'string.min': 'Password must be at least 8 characters long',
        'string.max': 'Password cannot exceed 100 characters',
        'string.pattern.base': 'Password must contain both letters and numbers',
        'any.required': 'Password is required'
      })
  }),

  // Team creation
  createTeam: Joi.object({
    name: Joi.string().min(2).max(50).required()
      .messages({
        'string.min': 'Team name must be at least 2 characters',
        'string.max': 'Team name cannot exceed 50 characters',
        'any.required': 'Team name is required'
      }),
    description: Joi.string().max(500).optional().allow(''),
    adminId: Joi.number().optional(),
    adminUsername: Joi.string().optional(),
    adminRole: Joi.string().optional(),
    adminTeam: Joi.string().optional()
  }),

  // File comment
  fileComment: Joi.object({
    comment: Joi.string().min(1).max(1000).required()
      .messages({
        'string.min': 'Comment cannot be empty',
        'string.max': 'Comment cannot exceed 1000 characters',
        'any.required': 'Comment is required'
      }),
    userId: Joi.number().optional(),
    username: Joi.string().optional(),
    role: Joi.string().optional(),
    team: Joi.string().optional()
  }),

  // Assignment
  createAssignment: Joi.object({
    title: Joi.string().min(3).max(200).required()
      .messages({
        'string.min': 'Title must be at least 3 characters',
        'string.max': 'Title cannot exceed 200 characters',
        'any.required': 'Title is required'
      }),
    description: Joi.string().max(2000).optional().allow(''),
    dueDate: Joi.date().iso().min('now').optional()
      .messages({
        'date.min': 'Due date cannot be in the past'
      }),
    assignedTo: Joi.number().required()
      .messages({
        'any.required': 'Assigned user is required'
      }),
    priority: Joi.string().valid('LOW', 'MEDIUM', 'HIGH').default('MEDIUM'),
    adminId: Joi.number().optional(),
    adminUsername: Joi.string().optional(),
    adminRole: Joi.string().optional(),
    adminTeam: Joi.string().optional()
  })
};

/**
 * Validate ID parameter
 */
const validateId = (paramName = 'id') => {
  return (req, res, next) => {
    const id = parseInt(req.params[paramName]);

    if (isNaN(id) || id <= 0) {
      return res.status(400).json({
        success: false,
        message: `Invalid ${paramName}. Must be a positive number.`
      });
    }

    req.params[paramName] = id;
    next();
  };
};

/**
 * Sanitize string to prevent XSS
 */
const sanitizeString = (str) => {
  if (typeof str !== 'string') {
    return str;
  }

  return str
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&#x27;')
    .replace(/\//g, '&#x2F;');
};

module.exports = {
  validate,
  schemas,
  validateId,
  sanitizeString
};


/***/ }),

/***/ 12229:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

const { USE_MYSQL } = __nccwpck_require__(5024);

async function migrate() {
    try {
        if (!USE_MYSQL) {
            // In SQLite, we handle this in initialize.js usually, but let's be safe
            return true;
        }

        const mysqlConfig = __nccwpck_require__(55364);

        // Check if tag column exists
        const columns = await mysqlConfig.query(`
      SELECT COLUMN_NAME 
      FROM INFORMATION_SCHEMA.COLUMNS 
      WHERE TABLE_SCHEMA = DATABASE() 
      AND TABLE_NAME = 'files' 
      AND COLUMN_NAME = 'tag'
    `);

        if (!columns || columns.length === 0) {
            console.log('üîÑ Adding tag column to files table...');
            await mysqlConfig.query('ALTER TABLE files ADD COLUMN tag VARCHAR(100)');
            console.log('‚úÖ Successfully added tag column');

            // Add index
            try {
                await mysqlConfig.query('CREATE INDEX idx_files_tag ON files(tag)');
                console.log('‚úÖ Successfully added index on tag column');
            } catch (error) {
                if (!error.message.includes('Duplicate key name')) {
                    console.warn('‚ö†Ô∏è Could not create index:', error.message);
                }
            }
        } else {
            // console.log('‚úÖ Tag column already exists');
        }

        return true;
    } catch (error) {
        console.error('‚ùå Migration 001 error:', error.message);
        return false;
    }
}

module.exports = migrate;


/***/ }),

/***/ 75203:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

/**
 * Migration: Add Database Indexes for Performance
 * 
 * This migration adds indexes to frequently queried columns to improve
 * query performance, especially for large datasets.
 * 
 * Tables affected:
 * - users: email, username, role, team
 * - files: user_id, status, uploaded_at, team
 * - assignments: assigned_to, status, due_date
 * - notifications: user_id, is_read, created_at
 * - activity_logs: user_id, timestamp
 */

const { USE_MYSQL } = __nccwpck_require__(5024);

async function up() {
    if (USE_MYSQL) {
        // MySQL indexes
        const { query } = __nccwpck_require__(55364);

        const indexes = [
            // Users table
            'CREATE INDEX IF NOT EXISTS idx_users_email ON users(email)',
            'CREATE INDEX IF NOT EXISTS idx_users_username ON users(username)',
            'CREATE INDEX IF NOT EXISTS idx_users_role ON users(role)',
            'CREATE INDEX IF NOT EXISTS idx_users_team ON users(team)',

            // Files table
            'CREATE INDEX IF NOT EXISTS idx_files_user_id ON files(user_id)',
            'CREATE INDEX IF NOT EXISTS idx_files_status ON files(status)',
            'CREATE INDEX IF NOT EXISTS idx_files_uploaded_at ON files(uploaded_at)',
            'CREATE INDEX IF NOT EXISTS idx_files_user_team ON files(user_team)',
            'CREATE INDEX IF NOT EXISTS idx_files_current_stage ON files(current_stage)',

            // Assignments table
            'CREATE INDEX IF NOT EXISTS idx_assignments_team_leader_id ON assignments(team_leader_id)',
            'CREATE INDEX IF NOT EXISTS idx_assignments_status ON assignments(status)',
            'CREATE INDEX IF NOT EXISTS idx_assignments_due_date ON assignments(due_date)',
            'CREATE INDEX IF NOT EXISTS idx_assignments_team ON assignments(team)',

            // Assignment members table
            'CREATE INDEX IF NOT EXISTS idx_assignment_members_user_id ON assignment_members(user_id)',
            'CREATE INDEX IF NOT EXISTS idx_assignment_members_assignment_id ON assignment_members(assignment_id)',
            'CREATE INDEX IF NOT EXISTS idx_assignment_members_status ON assignment_members(status)',

            // Notifications table (if exists)
            'CREATE INDEX IF NOT EXISTS idx_notifications_user_id ON notifications(user_id)',
            'CREATE INDEX IF NOT EXISTS idx_notifications_is_read ON notifications(is_read)',
            'CREATE INDEX IF NOT EXISTS idx_notifications_created_at ON notifications(created_at)',

            // Activity logs table
            'CREATE INDEX IF NOT EXISTS idx_activity_logs_user_id ON activity_logs(user_id)',
            'CREATE INDEX IF NOT EXISTS idx_activity_logs_timestamp ON activity_logs(timestamp)',

            // File comments table
            'CREATE INDEX IF NOT EXISTS idx_file_comments_file_id ON file_comments(file_id)',
            'CREATE INDEX IF NOT EXISTS idx_file_comments_user_id ON file_comments(user_id)',

            // File status history table
            'CREATE INDEX IF NOT EXISTS idx_file_status_history_file_id ON file_status_history(file_id)',
            'CREATE INDEX IF NOT EXISTS idx_file_status_history_changed_by_id ON file_status_history(changed_by_id)'
        ];

        console.log('üìä Adding database indexes for MySQL...');

        for (const sql of indexes) {
            try {
                await query(sql);
                const indexName = sql.match(/idx_\w+/)[0];
                console.log(`  ‚úÖ Created index: ${indexName}`);
            } catch (error) {
                // Ignore if index already exists
                if (!error.message.includes('Duplicate key name')) {
                    console.error(`  ‚ùå Error creating index: ${error.message}`);
                }
            }
        }

        console.log('‚úÖ MySQL indexes added successfully');

    } else {
        // SQLite indexes (already handled in initialize.js, but we can add more)
        const { db } = __nccwpck_require__(5024);

        const indexes = [
            // Additional indexes not in initialize.js
            'CREATE INDEX IF NOT EXISTS idx_users_role ON users(role)',
            'CREATE INDEX IF NOT EXISTS idx_files_status ON files(status)',
            'CREATE INDEX IF NOT EXISTS idx_assignments_status ON assignments(status)',
            'CREATE INDEX IF NOT EXISTS idx_assignments_due_date ON assignments(due_date)',
            'CREATE INDEX IF NOT EXISTS idx_assignment_members_status ON assignment_members(status)'
        ];

        console.log('üìä Adding additional database indexes for SQLite...');

        return new Promise((resolve, reject) => {
            let completed = 0;
            const total = indexes.length;

            indexes.forEach(sql => {
                db.run(sql, (err) => {
                    if (err && !err.message.includes('already exists')) {
                        console.error(`  ‚ùå Error creating index: ${err.message}`);
                    } else {
                        const indexName = sql.match(/idx_\w+/)[0];
                        console.log(`  ‚úÖ Created index: ${indexName}`);
                    }

                    completed++;
                    if (completed === total) {
                        console.log('‚úÖ SQLite indexes added successfully');
                        resolve();
                    }
                });
            });
        });
    }
}

async function down() {
    // Rollback: Drop indexes
    if (USE_MYSQL) {
        const { query } = __nccwpck_require__(55364);

        const indexes = [
            'DROP INDEX IF EXISTS idx_users_email ON users',
            'DROP INDEX IF EXISTS idx_users_username ON users',
            'DROP INDEX IF EXISTS idx_users_role ON users',
            'DROP INDEX IF EXISTS idx_users_team ON users',
            'DROP INDEX IF EXISTS idx_files_user_id ON files',
            'DROP INDEX IF EXISTS idx_files_status ON files',
            'DROP INDEX IF EXISTS idx_files_uploaded_at ON files',
            'DROP INDEX IF EXISTS idx_files_user_team ON files',
            'DROP INDEX IF EXISTS idx_files_current_stage ON files',
            'DROP INDEX IF EXISTS idx_assignments_team_leader_id ON assignments',
            'DROP INDEX IF EXISTS idx_assignments_status ON assignments',
            'DROP INDEX IF EXISTS idx_assignments_due_date ON assignments',
            'DROP INDEX IF EXISTS idx_assignments_team ON assignments',
            'DROP INDEX IF EXISTS idx_assignment_members_user_id ON assignment_members',
            'DROP INDEX IF EXISTS idx_assignment_members_assignment_id ON assignment_members',
            'DROP INDEX IF EXISTS idx_assignment_members_status ON assignment_members',
            'DROP INDEX IF EXISTS idx_notifications_user_id ON notifications',
            'DROP INDEX IF EXISTS idx_notifications_is_read ON notifications',
            'DROP INDEX IF EXISTS idx_notifications_created_at ON notifications',
            'DROP INDEX IF EXISTS idx_activity_logs_user_id ON activity_logs',
            'DROP INDEX IF EXISTS idx_activity_logs_timestamp ON activity_logs',
            'DROP INDEX IF EXISTS idx_file_comments_file_id ON file_comments',
            'DROP INDEX IF EXISTS idx_file_comments_user_id ON file_comments',
            'DROP INDEX IF EXISTS idx_file_status_history_file_id ON file_status_history',
            'DROP INDEX IF EXISTS idx_file_status_history_changed_by_id ON file_status_history'
        ];

        console.log('üóëÔ∏è  Dropping database indexes...');

        for (const sql of indexes) {
            try {
                await query(sql);
            } catch (error) {
                // Ignore errors during rollback
            }
        }

        console.log('‚úÖ Indexes dropped');
    } else {
        console.log('‚ö†Ô∏è  SQLite does not support DROP INDEX IF EXISTS easily. Manual cleanup may be required.');
    }
}

module.exports = { up, down };


/***/ }),

/***/ 96706:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

const { USE_MYSQL } = __nccwpck_require__(5024);

async function runMigrations() {
  try {
    console.log('üîÑ Checking database migrations...');

    // List of migrations to run in order
    const migrations = [
      { name: 'Add Tag Column', run: __nccwpck_require__(12229) },
      { name: 'Add Database Indexes', run: __nccwpck_require__(75203) }
    ];

    for (const migration of migrations) {
      console.log(`üöÄ Running migration: ${migration.name}...`);

      // Support both function exports and object exports with up() method
      let runFn = migration.run;
      if (typeof runFn !== 'function' && runFn && typeof runFn.up === 'function') {
        runFn = runFn.up;
      }

      const success = await runFn();
      if (success) {
        console.log(`‚úÖ Migration successful: ${migration.name}`);
      } else {
        console.warn(`‚ö†Ô∏è Migration failed or skipped: ${migration.name}`);
      }
    }

    console.log('‚úÖ All migrations check completed');
    return true;
  } catch (error) {
    console.error('‚ùå Migration runner error:', error);
    // Don't fail the server startup if migrations fail
    return false;
  }
}

module.exports = runMigrations;


/***/ }),

/***/ 70887:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

const express = __nccwpck_require__(85152);
const { db } = __nccwpck_require__(5024);
const { logActivity } = __nccwpck_require__(46534);

const router = express.Router();

// Activity Logs Endpoints with pagination
router.get('/', (req, res) => {
  const page = parseInt(req.query.page) || 1;
  const limit = parseInt(req.query.limit) || 50;
  const offset = (page - 1) * limit;

  console.log(`üìã Getting activity logs - Page ${page}, Limit ${limit}`);

  // Get total count
  db.get('SELECT COUNT(*) as total FROM activity_logs', [], (err, countResult) => {
    if (err) {
      console.error('‚ùå Database error getting activity logs count:', err);
      return res.status(500).json({ success: false, message: 'Failed to fetch activity logs' });
    }

    // Get paginated results
    db.all(
      'SELECT * FROM activity_logs ORDER BY timestamp DESC LIMIT ? OFFSET ?',
      [limit, offset],
      (err, logs) => {
        if (err) {
          console.error('‚ùå Database error getting activity logs:', err);
          return res.status(500).json({ success: false, message: 'Failed to fetch activity logs' });
        }

        console.log(`‚úÖ Retrieved ${logs.length} activity logs`);
        res.json({
          success: true,
          logs,
          pagination: {
            page,
            limit,
            total: countResult.total,
            pages: Math.ceil(countResult.total / limit)
          }
        });
      }
    );
  });
});

// Bulk delete activity logs (Admin only)
router.delete('/bulk-delete', (req, res) => {
  const { logIds } = req.body;
  console.log(`üóëÔ∏è Bulk deleting ${logIds?.length || 0} activity logs`);

  // Validation
  if (!logIds || !Array.isArray(logIds) || logIds.length === 0) {
    return res.status(400).json({
      success: false,
      message: 'Log IDs array is required and must not be empty'
    });
  }

  // Create placeholders for the SQL IN clause
  const placeholders = logIds.map(() => '?').join(',');

  // Get log details for logging purposes before deletion
  db.all(
    `SELECT id, username, activity FROM activity_logs WHERE id IN (${placeholders})`,
    logIds,
    (err, logsToDelete) => {
      if (err) {
        console.error('‚ùå Error fetching logs for deletion:', err);
        return res.status(500).json({
          success: false,
          message: 'Failed to fetch logs for deletion'
        });
      }
      if (logsToDelete.length === 0) {
        return res.status(404).json({
          success: false,
          message: 'No logs found with the provided IDs'
        });
      }

      // Delete the logs
      db.run(
        `DELETE FROM activity_logs WHERE id IN (${placeholders})`,
        logIds,
        function(err) {
          if (err) {
            console.error('‚ùå Error deleting activity logs:', err);
            return res.status(500).json({
              success: false,
              message: 'Failed to delete activity logs'
            });
          }
          const deletedCount = this.changes;
          console.log(`‚úÖ Successfully deleted ${deletedCount} activity logs`);

          // Log the bulk deletion activity
          logActivity(
            db,
            null,
            'System',
            'ADMIN',
            'System',
            `Bulk deletion: ${deletedCount} activity log(s) removed by administrator`
          );
          res.json({
            success: true,
            message: `Successfully deleted ${deletedCount} activity log(s)`,
            deletedCount: deletedCount,
            requestedCount: logIds.length
          });
        }
      );
    }
  );
});

module.exports = router;


/***/ }),

/***/ 20007:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

const express = __nccwpck_require__(85152);
const router = express.Router();
const { query, queryOne } = __nccwpck_require__(55364);
const multer = __nccwpck_require__(98013);
const path = __nccwpck_require__(16928);
const fs = __nccwpck_require__(79896);
const { uploadsDir, moveToUserFolder } = __nccwpck_require__(62489);

// Configure multer for file uploads using existing uploads directory
const storage = multer.diskStorage({
  destination: (req, file, cb) => {
    // Upload to temp location first, then move to user folder
    cb(null, uploadsDir);
  },
  filename: (req, file, cb) => {
    // Use temp filename like regular uploads
    const timestamp = Date.now();
    const randomString = Math.random().toString(36).substring(7);
    cb(null, `temp_${timestamp}_${randomString}`);
  }
});

const upload = multer({
  storage: storage,
  limits: {
    fileSize: 100 * 1024 * 1024 // 100MB limit
  }
});

router.get('/admin/all', async (req, res) => {
  try {
    console.log('üîç Admin assignments route called');
    const { cursor, limit = 20 } = req.query;
    const parsedLimit = parseInt(limit, 10);

    console.log('Admin fetching assignments with pagination:', { cursor, limit: parsedLimit });

    let queryStr = `
      SELECT
        a.*,
        COUNT(DISTINCT asub.id) as submission_count,
        COUNT(DISTINCT am.id) as assigned_members_count,
        COUNT(DISTINCT ac.id) as comment_count
      FROM assignments a
      LEFT JOIN assignment_members am ON a.id = am.assignment_id
      LEFT JOIN assignment_submissions asub ON a.id = asub.assignment_id
      LEFT JOIN assignment_comments ac ON a.id = ac.assignment_id
    `;

    const queryParams = [];
    const conditions = [];

    // Add cursor condition if provided
    if (cursor) {
      conditions.push('a.id < ?');
      queryParams.push(cursor);
    }

    // Add WHERE clause if there are conditions
    if (conditions.length > 0) {
      queryStr += ' WHERE ' + conditions.join(' AND ');
    }

    queryStr += `
      GROUP BY a.id
      ORDER BY a.created_at DESC, a.id DESC
      LIMIT ?
    `;
    queryParams.push(parsedLimit + 1); // Fetch one extra to check if there are more

    const assignments = await query(queryStr, queryParams);

    console.log(`Found ${assignments.length} assignments for this batch`);

    // Check if there are more results
    const hasMore = assignments.length > parsedLimit;
    const assignmentsToReturn = hasMore ? assignments.slice(0, parsedLimit) : assignments;
    const nextCursor = hasMore && assignmentsToReturn.length > 0
      ? assignmentsToReturn[assignmentsToReturn.length - 1].id
      : null;

    // Get additional details for each assignment
    for (const assignment of assignmentsToReturn) {
      // Get assigned member details
      const assignedMembers = await query(`
        SELECT u.id, u.username, u.fullName
        FROM assignment_members am
        JOIN users u ON am.user_id = u.id
        WHERE am.assignment_id = ?
      `, [assignment.id]);

      assignment.assigned_member_details = assignedMembers || [];

      // Get recent submissions from assignment_submissions table (includes ALL submitted files)
      const recentSubmissions = await query(`
        SELECT
          f.id,
          f.original_name,
          f.filename,
          f.file_type,
          f.file_path,
          f.file_size,
          f.tag,
          f.description,
          f.uploaded_at,
          f.status,
          u.username,
          u.fullName,
          asub.submitted_at,
          asub.submitted_at as created_at,
          asub.user_id
        FROM assignment_submissions asub
        JOIN files f ON asub.file_id = f.id
        JOIN users u ON asub.user_id = u.id
        WHERE asub.assignment_id = ?
        ORDER BY asub.submitted_at DESC
      `, [assignment.id]);

      assignment.recent_submissions = recentSubmissions || [];

      // Get team leader info
      const teamLeader = await queryOne(
        'SELECT fullName, username, email FROM users WHERE id = ?',
        [assignment.team_leader_id || assignment.teamLeaderId]
      );

      if (teamLeader) {
        assignment.team_leader_fullname = teamLeader.fullName;
        assignment.team_leader_username = teamLeader.username;
        assignment.team_leader_email = teamLeader.email;
      }
    }

    console.log(`Returning ${assignmentsToReturn.length} assignments to admin, hasMore: ${hasMore}`);

    // Debug: Check comment_count in assignments
    if (assignmentsToReturn.length > 0) {
      console.log('First assignment comment_count:', assignmentsToReturn[0].comment_count, 'type:', typeof assignmentsToReturn[0].comment_count);
      console.log('First assignment keys:', Object.keys(assignmentsToReturn[0]));
    }

    res.json({
      success: true,
      assignments: assignmentsToReturn || [],
      nextCursor,
      hasMore
    });
  } catch (error) {
    console.error('Error in admin all assignments route:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to fetch assignments',
      error: error.message
    });
  }
});

// Get all submitted files for file collection (Team Leader view)
router.get('/team-leader/:team/all-submissions', async (req, res) => {
  try {
    const { team } = req.params;
    console.log(`üîç DASHBOARD API: Fetching all submissions for team: ${team}`);

    const allSubmissions = await query(`
      SELECT
        f.id,
        f.original_name,
        f.filename,
        f.file_type,
        f.file_path,
        f.file_size,
        f.uploaded_at,
        f.status,
        u.username,
        u.fullName,
        asub.submitted_at,
        asub.submitted_at as created_at,
        a.id as assignment_id,
        a.title as assignment_title,
        a.due_date as assignment_due_date
      FROM assignment_submissions asub
      JOIN files f ON asub.file_id = f.id
      JOIN users u ON asub.user_id = u.id
      JOIN assignments a ON asub.assignment_id = a.id
      WHERE a.team = ?
      ORDER BY asub.submitted_at DESC
    `, [team]);

    console.log(`‚úÖ DASHBOARD API: Found ${allSubmissions?.length || 0} submissions for team ${team}`);

    res.json({
      success: true,
      submissions: allSubmissions || []
    });
  } catch (error) {
    console.error('‚ùå DASHBOARD API: Error fetching all submissions:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to fetch submissions',
      error: error.message
    });
  }
});

// Get all tasks for team members view (similar to admin view but filtered by team)
router.get('/team/:team/all-tasks', async (req, res) => {
  try {
    console.log('üîç Team tasks route called for team:', req.params.team);
    const { team } = req.params;
    const { cursor, limit = 20 } = req.query;
    const parsedLimit = parseInt(limit, 10);

    console.log('Fetching team tasks with pagination:', { team, cursor, limit: parsedLimit });

    let queryStr = `
      SELECT
        a.*,
        COUNT(DISTINCT CASE WHEN am.status = 'submitted' AND am.file_id IS NOT NULL THEN am.id END) as submission_count,
        COUNT(DISTINCT am.id) as assigned_members_count,
        COUNT(DISTINCT ac.id) as comment_count
      FROM assignments a
      LEFT JOIN assignment_members am ON a.id = am.assignment_id
      LEFT JOIN assignment_comments ac ON a.id = ac.assignment_id
      WHERE a.team = ?
    `;

    const queryParams = [team];

    // Add cursor condition if provided
    if (cursor) {
      queryStr += ' AND a.id < ?';
      queryParams.push(cursor);
    }

    queryStr += `
      GROUP BY a.id
      ORDER BY a.created_at DESC, a.id DESC
      LIMIT ?
    `;
    queryParams.push(parsedLimit + 1); // Fetch one extra to check if there are more

    const assignments = await query(queryStr, queryParams);

    console.log(`Found ${assignments.length} assignments for team ${team}`);

    // Check if there are more results
    const hasMore = assignments.length > parsedLimit;
    const assignmentsToReturn = hasMore ? assignments.slice(0, parsedLimit) : assignments;
    const nextCursor = hasMore && assignmentsToReturn.length > 0
      ? assignmentsToReturn[assignmentsToReturn.length - 1].id
      : null;

    // Get additional details for each assignment
    for (const assignment of assignmentsToReturn) {
      // Get assigned member details
      const assignedMembers = await query(`
        SELECT u.id, u.username, u.fullName
        FROM assignment_members am
        JOIN users u ON am.user_id = u.id
        WHERE am.assignment_id = ?
      `, [assignment.id]);

      assignment.assigned_member_details = assignedMembers || [];

      // Get recent submissions from assignment_submissions table (includes ALL submitted files)
      const recentSubmissions = await query(`
        SELECT
          f.id,
          f.original_name,
          f.filename,
          f.file_type,
          f.file_path,
          f.file_size,
          f.tag,
          f.description,
          f.uploaded_at,
          f.status,
          u.username,
          u.fullName,
          asub.submitted_at,
          asub.submitted_at as created_at
        FROM assignment_submissions asub
        JOIN files f ON asub.file_id = f.id
        JOIN users u ON asub.user_id = u.id
        WHERE asub.assignment_id = ?
        ORDER BY asub.submitted_at DESC
      `, [assignment.id]);

      assignment.recent_submissions = recentSubmissions || [];

      // Get team leader info
      const teamLeader = await queryOne(
        'SELECT fullName, username, email FROM users WHERE id = ?',
        [assignment.team_leader_id || assignment.teamLeaderId]
      );

      if (teamLeader) {
        assignment.team_leader_fullname = teamLeader.fullName;
        assignment.team_leader_username = teamLeader.username;
        assignment.team_leader_email = teamLeader.email;
      }
    }

    console.log(`Returning ${assignmentsToReturn.length} assignments to team view, hasMore: ${hasMore}`);

    res.json({
      success: true,
      assignments: assignmentsToReturn || [],
      nextCursor,
      hasMore
    });
  } catch (error) {
    console.error('Error in team all tasks route:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to fetch team tasks',
      error: error.message
    });
  }
});

// Get all assignments for a team leader
router.get('/team-leader/:team', async (req, res) => {
  try {
    const { team } = req.params;

    const assignments = await query(`
      SELECT
        a.*,
        COUNT(DISTINCT asub.id) as submission_count,
        COUNT(DISTINCT am.id) as assigned_members_count
      FROM assignments a
      LEFT JOIN assignment_members am ON a.id = am.assignment_id
      LEFT JOIN assignment_submissions asub ON a.id = asub.assignment_id
      WHERE a.team = ?
      GROUP BY a.id
      ORDER BY a.created_at DESC
    `, [team]);

    // Get recent submissions for each assignment
    for (const assignment of assignments) {
      // Get assigned member details
      const assignedMembers = await query(`
        SELECT u.id, u.username, u.fullName
        FROM assignment_members am
        JOIN users u ON am.user_id = u.id
        WHERE am.assignment_id = ?
      `, [assignment.id]);

      assignment.assigned_member_details = assignedMembers || [];

      // Get attachments for this assignment
      const attachments = await query(`
        SELECT id, original_name, filename, file_path, file_size, file_type, created_at
        FROM assignment_attachments
        WHERE assignment_id = ?
        ORDER BY created_at DESC
      `, [assignment.id]);

      assignment.attachments = attachments || [];

      // Get all submissions from assignment_submissions table (includes ALL submitted files)
      const recentSubmissions = await query(`
        SELECT
          f.id,
          f.original_name,
          f.filename,
          f.file_type,
          f.file_path,
          f.file_size,
          f.tag,
          f.description,
          f.uploaded_at,
          f.status,
          u.username,
          u.fullName,
          asub.submitted_at,
          asub.submitted_at as created_at,
          asub.user_id
        FROM assignment_submissions asub
        JOIN files f ON asub.file_id = f.id
        JOIN users u ON asub.user_id = u.id
        WHERE asub.assignment_id = ?
        ORDER BY asub.submitted_at DESC
      `, [assignment.id]);

      assignment.recent_submissions = recentSubmissions || [];

      // Get team leader info
      const teamLeader = await queryOne(
        'SELECT fullName, username, email FROM users WHERE id = ?',
        [assignment.team_leader_id || assignment.teamLeaderId]
      );

      if (teamLeader) {
        assignment.team_leader_fullname = teamLeader.fullName;
        assignment.team_leader_username = teamLeader.username;
        assignment.team_leader_email = teamLeader.email;
      }

      // Debug log
      if (assignment.submission_count > 0 && (!recentSubmissions || recentSubmissions.length === 0)) {
        console.log(`WARNING: Assignment ${assignment.id} has submission_count ${assignment.submission_count} but no recent_submissions`);
        // Try to debug what's in assignment_members
        const debugData = await query(
          'SELECT * FROM assignment_members WHERE assignment_id = ?',
          [assignment.id]
        );
        console.log(`Debug assignment_members for assignment ${assignment.id}:`, debugData);
      }
    }

    res.json({
      success: true,
      assignments: assignments || []
    });
  } catch (error) {
    console.error('Error in fetchAssignments route:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to fetch assignments',
      error: error.message
    });
  }
});

// Get assignment details with submissions
router.get('/:assignmentId/details', async (req, res) => {
  try {
    const { assignmentId } = req.params;

    // Get assignment details
    const assignment = await queryOne(
      'SELECT * FROM assignments WHERE id = ?',
      [assignmentId]
    );

    if (!assignment) {
      return res.status(404).json({
        success: false,
        message: 'Assignment not found'
      });
    }

    // Get assigned member details
    const memberDetails = await query(`
      SELECT u.id, u.username, u.fullName
      FROM assignment_members am
      JOIN users u ON am.user_id = u.id
      WHERE am.assignment_id = ?
    `, [assignmentId]);

    assignment.assigned_member_details = memberDetails || [];

    // Get submissions
    const submissions = await query(`
      SELECT 
        f.*,
        u.username,
        u.fullName,
        am.submitted_at,
        am.status as review_status,
        am.id as submission_id
      FROM assignment_members am
      JOIN files f ON am.file_id = f.id
      JOIN users u ON am.user_id = u.id
      WHERE am.assignment_id = ? AND am.file_id IS NOT NULL AND am.status = 'submitted'
      ORDER BY am.submitted_at DESC
    `, [assignmentId]);

    console.log(`Assignment ${assignmentId} details:`, {
      assignmentId,
      assignedMembersCount: memberDetails?.length || 0,
      submissionsCount: submissions?.length || 0,
      submissions: submissions
    });

    res.json({
      success: true,
      assignment,
      submissions: submissions || []
    });
  } catch (error) {
    console.error('Error in assignment details route:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to fetch assignment details',
      error: error.message
    });
  }
});

// Create new assignment with file attachments
router.post('/create', upload.array('attachments', 10), async (req, res) => {
  try {
    const {
      title,
      description,
      dueDate,
      due_date,
      fileTypeRequired,
      file_type_required,
      assignedTo,
      assigned_to,
      maxFileSize,
      max_file_size,
      assignedMembers,
      assigned_members,
      teamLeaderId,
      team_leader_id,
      teamLeaderUsername,
      team_leader_username,
      team
    } = req.body;

    // Support both camelCase and snake_case
    const finalDueDate = dueDate || due_date;
    const finalFileType = fileTypeRequired || file_type_required;
    const finalAssignedTo = assignedTo || assigned_to;
    const finalMaxSize = maxFileSize || max_file_size || 10485760;
    const finalMembers = typeof assignedMembers === 'string' ? JSON.parse(assignedMembers) : (assignedMembers || assigned_members);
    const finalTeamLeaderId = teamLeaderId || team_leader_id;
    const finalTeamLeaderUsername = teamLeaderUsername || team_leader_username;

    // Get uploaded files
    const uploadedFiles = req.files || [];

    // Validate required fields
    if (!title || !team || !finalTeamLeaderId) {
      return res.status(400).json({
        success: false,
        message: 'Missing required fields'
      });
    }

    // Insert assignment
    const assignmentResult = await query(`
      INSERT INTO assignments (
        title,
        description,
        due_date,
        file_type_required,
        assigned_to,
        max_file_size,
        team_leader_id,
        team_leader_username,
        team,
        created_at,
        status
      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, NOW(), 'active')
    `, [
      title,
      description || null,
      finalDueDate || null,
      finalFileType || null,
      finalAssignedTo,
      finalMaxSize,
      finalTeamLeaderId,
      finalTeamLeaderUsername,
      team
    ]);

    const assignmentId = assignmentResult.insertId;
    let membersAssigned = 0;
    let attachmentsCreated = 0;

    // Save attachment file records if any files were uploaded
    if (uploadedFiles.length > 0) {
      try {
        console.log(`üìé Saving ${uploadedFiles.length} attachment(s) for assignment ${assignmentId}`);

        for (const file of uploadedFiles) {
          // Move file from temp location to team leader's folder
          let finalPath;
          try {
            finalPath = await moveToUserFolder(file.path, finalTeamLeaderUsername, file.originalname);
            console.log(`‚úÖ Moved attachment to: ${finalPath}`);
          } catch (moveError) {
            console.error('‚ö†Ô∏è Failed to move attachment file:', moveError);
            // If move fails, use the original temp path
            finalPath = file.path;
          }

          await query(`
            INSERT INTO assignment_attachments (
              assignment_id,
              original_name,
              filename,
              file_path,
              file_size,
              file_type,
              uploaded_by_id,
              uploaded_by_username
            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?)
          `, [
            assignmentId,
            file.originalname,
            path.basename(finalPath),
            finalPath,
            file.size,
            file.mimetype,
            finalTeamLeaderId,
            finalTeamLeaderUsername
          ]);
          attachmentsCreated++;
        }

        console.log(`‚úÖ Saved ${attachmentsCreated} attachment(s) for assignment ${assignmentId}`);
      } catch (attachmentError) {
        console.error('‚ö†Ô∏è Failed to save attachments:', attachmentError);
        // Don't fail the request if attachments fail
      }
    }

    try {
      // Assign members
      if (finalAssignedTo === 'specific' && finalMembers && finalMembers.length > 0) {
        // Insert specific members using batch insert
        const memberValues = finalMembers.map(userId => [assignmentId, userId]);
        if (memberValues.length > 0) {
          const placeholders = memberValues.map(() => '(?, ?)').join(', ');
          const flattenedValues = memberValues.flat();

          await query(
            `INSERT INTO assignment_members (assignment_id, user_id) VALUES ${placeholders}`,
            flattenedValues
          );
          membersAssigned = finalMembers.length;
        }
      } else if (finalAssignedTo === 'all') {
        // Get all team members and assign
        const teamMembers = await query(
          'SELECT id FROM users WHERE team = ? AND role = ?',
          [team, 'USER']
        );

        if (teamMembers && teamMembers.length > 0) {
          const memberValues = teamMembers.map(member => [assignmentId, member.id]);
          const placeholders = memberValues.map(() => '(?, ?)').join(', ');
          const flattenedValues = memberValues.flat();

          await query(
            `INSERT INTO assignment_members (assignment_id, user_id) VALUES ${placeholders}`,
            flattenedValues
          );
          membersAssigned = teamMembers.length;
        }
      }

      // Log activity
      try {
        await query(`
          INSERT INTO activity_logs (
            user_id,
            username,
            role,
            team,
            activity
          ) VALUES (?, ?, ?, ?, ?)
        `, [
          finalTeamLeaderId,
          finalTeamLeaderUsername,
          'TEAM_LEADER',
          team,
          `Created assignment: ${title}`
        ]);
      } catch (logError) {
        console.warn('Activity log insertion failed:', logError.message);
      }

      // Create notifications for assigned members
      try {
        console.log('üîî Creating notifications for assignment:', assignmentId);
        console.log('Assigned to:', finalAssignedTo);
        console.log('Members:', finalMembers);
        console.log('Team:', team);
        console.log('Team Leader:', finalTeamLeaderUsername, '(ID:', finalTeamLeaderId, ')');

        if (finalAssignedTo === 'specific' && finalMembers && finalMembers.length > 0) {
          // Notify specific members
          console.log('Creating notifications for specific members:', finalMembers);
          for (const userId of finalMembers) {
            try {
              const notificationData = {
                user_id: userId,
                assignment_id: assignmentId,
                file_id: null,
                type: 'assignment',
                title: 'New Assignment',
                message: `${finalTeamLeaderUsername} assigned you a new task: "${title}"${finalDueDate ? ` - Due: ${new Date(finalDueDate).toLocaleDateString()}` : ''}`,
                action_by_id: finalTeamLeaderId,
                action_by_username: finalTeamLeaderUsername,
                action_by_role: 'TEAM_LEADER'
              };

              console.log('Inserting notification:', notificationData);

              await query(`
                INSERT INTO notifications (
                  user_id,
                  assignment_id,
                  file_id,
                  type,
                  title,
                  message,
                  action_by_id,
                  action_by_username,
                  action_by_role
                ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
              `, [
                notificationData.user_id,
                notificationData.assignment_id,
                notificationData.file_id,
                notificationData.type,
                notificationData.title,
                notificationData.message,
                notificationData.action_by_id,
                notificationData.action_by_username,
                notificationData.action_by_role
              ]);
              console.log(`‚úÖ Notification created successfully for user ${userId}`);
            } catch (err) {
              console.error(`‚ùå Failed to create notification for user ${userId}:`, err);
              console.error('Error details:', err.message);
              console.error('SQL State:', err.sqlState);
              console.error('SQL Message:', err.sqlMessage);
            }
          }
          console.log(`‚úÖ Completed creating ${finalMembers.length} notification(s) for specific members`);
        } else if (finalAssignedTo === 'all') {
          // Notify all team members
          console.log('Creating notifications for all team members in team:', team);
          const teamMembers = await query(
            'SELECT id FROM users WHERE team = ? AND role = ?',
            [team, 'USER']
          );

          console.log(`Found ${teamMembers.length} team members to notify`);
          for (const member of teamMembers) {
            try {
              const notificationData = {
                user_id: member.id,
                assignment_id: assignmentId,
                file_id: null,
                type: 'assignment',
                title: 'New Assignment',
                message: `${finalTeamLeaderUsername} assigned a new task to all team members: "${title}"${finalDueDate ? ` - Due: ${new Date(finalDueDate).toLocaleDateString()}` : ''}`,
                action_by_id: finalTeamLeaderId,
                action_by_username: finalTeamLeaderUsername,
                action_by_role: 'TEAM_LEADER'
              };

              console.log('Inserting notification for member:', member.id, notificationData);

              await query(`
                INSERT INTO notifications (
                  user_id,
                  assignment_id,
                  file_id,
                  type,
                  title,
                  message,
                  action_by_id,
                  action_by_username,
                  action_by_role
                ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
              `, [
                notificationData.user_id,
                notificationData.assignment_id,
                notificationData.file_id,
                notificationData.type,
                notificationData.title,
                notificationData.message,
                notificationData.action_by_id,
                notificationData.action_by_username,
                notificationData.action_by_role
              ]);
              console.log(`‚úÖ Notification created successfully for user ${member.id}`);
            } catch (err) {
              console.error(`‚ùå Failed to create notification for user ${member.id}:`, err);
              console.error('Error details:', err.message);
              console.error('SQL State:', err.sqlState);
              console.error('SQL Message:', err.sqlMessage);
            }
          }
          console.log(`‚úÖ Completed creating ${teamMembers.length} notification(s) for all team members`);
        }
      } catch (notificationError) {
        console.error('‚ö†Ô∏è Failed to create notifications:', notificationError.message);
        console.error('Full error:', notificationError);
        console.error('Stack:', notificationError.stack);
        // Don't fail the request if notifications fail
      }

      res.json({
        success: true,
        message: 'Assignment created successfully',
        assignmentId,
        membersAssigned,
        attachmentsCreated
      });

    } catch (memberError) {
      // If member assignment fails, we should still return success since the assignment was created
      console.error('Error assigning members:', memberError);
      res.json({
        success: true,
        message: 'Assignment created successfully',
        assignmentId,
        membersAssigned: 0,
        warning: 'Assignment created but member assignment failed'
      });
    }

  } catch (error) {
    console.error('Error creating assignment:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to create assignment',
      error: error.message
    });
  }
});

// Get assignments for a specific user with all submitted files
router.get('/user/:userId', async (req, res) => {
  try {
    const { userId } = req.params;

    // First get the current user's info
    const currentUser = await queryOne(
      'SELECT username, fullName, team FROM users WHERE id = ?',
      [userId]
    );

    if (!currentUser) {
      return res.status(404).json({
        success: false,
        message: 'User not found'
      });
    }

    console.log('Current user:', currentUser);

    const assignments = await query(`
      SELECT
        a.*,
        am.status as user_status,
        am.submitted_at as user_submitted_at,
        fs.original_name as submitted_file_name,
        fs.file_path as submitted_file_path,
        fs.id as submitted_file_id,
        fs.tag as submitted_file_tag,
        tl.fullName as team_leader_fullname,
        tl.username as team_leader_username,
        tl.role as team_leader_role,
        ? as assigned_user_fullname,
        ? as assigned_user_username
      FROM assignments a
      LEFT JOIN assignment_members am ON a.id = am.assignment_id AND am.user_id = ?
      LEFT JOIN files fs ON am.file_id = fs.id
      LEFT JOIN users tl ON a.team_leader_id = tl.id
      WHERE
        (a.assigned_to = 'all' AND a.team = ?)
        OR
        (a.assigned_to = 'specific' AND am.user_id = ?)
      ORDER BY a.created_at DESC
    `, [currentUser.fullName, currentUser.username, userId, currentUser.team, userId]);

    console.log('Assignments found:', assignments.length);
    if (assignments.length > 0) {
      console.log('First assignment:', assignments[0]);
    }

    // Fetch assigned member details and all submitted files for each assignment
    for (const assignment of assignments) {
      const memberDetails = await query(`
        SELECT u.id, u.username, u.fullName
        FROM assignment_members am
        JOIN users u ON am.user_id = u.id
        WHERE am.assignment_id = ?
      `, [assignment.id]);

      assignment.assigned_member_details = memberDetails || [];

      // Fetch ALL submitted files for this assignment by this user
      const submittedFiles = await query(`
        SELECT 
          f.id,
          f.original_name,
          f.filename,
          f.file_path,
          f.file_type,
          f.file_size,
          f.tag,
          f.description,
          f.status,
          asub.submitted_at,
          u.fullName as submitter_name,
          u.username as submitter_username
        FROM assignment_submissions asub
        JOIN files f ON asub.file_id = f.id
        JOIN users u ON asub.user_id = u.id
        WHERE asub.assignment_id = ? AND asub.user_id = ?
        ORDER BY asub.submitted_at DESC
      `, [assignment.id, userId]);

      assignment.submitted_files = submittedFiles || [];
      console.log(`Assignment ${assignment.id} has ${submittedFiles ? submittedFiles.length : 0} submitted file(s)`);
    }

    res.json({
      success: true,
      assignments: assignments || []
    });
  } catch (error) {
    console.error('Error in user assignments route:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to fetch assignments',
      error: error.message
    });
  }
});

// Submit assignment (supports multiple file submissions)
router.post('/submit', async (req, res) => {
  try {
    const { assignmentId, userId, fileId } = req.body;

    // Validate required fields
    if (!assignmentId || !userId || !fileId) {
      return res.status(400).json({
        success: false,
        message: 'Missing required fields'
      });
    }

    // Check if assignment exists and user is assigned
    const assignment = await queryOne(`
      SELECT a.*, am.user_id as assigned_user
      FROM assignments a
      LEFT JOIN assignment_members am ON a.id = am.assignment_id AND am.user_id = ?
      WHERE a.id = ?
    `, [userId, assignmentId]);

    if (!assignment) {
      return res.status(404).json({
        success: false,
        message: 'Assignment not found'
      });
    }

    // Check if user is assigned (either 'all' or specifically assigned)
    if (assignment.assigned_to === 'specific' && !assignment.assigned_user) {
      return res.status(403).json({
        success: false,
        message: 'You are not assigned to this assignment'
      });
    }

    // Check if this specific file has already been submitted for this assignment
    const existingFileSubmission = await queryOne(
      'SELECT * FROM assignment_submissions WHERE assignment_id = ? AND file_id = ?',
      [assignmentId, fileId]
    );

    if (existingFileSubmission) {
      return res.status(400).json({
        success: false,
        message: 'This file has already been submitted for this assignment'
      });
    }

    // Add submission to assignment_submissions table
    await query(
      'INSERT INTO assignment_submissions (assignment_id, file_id, user_id, submitted_at) VALUES (?, ?, ?, NOW())',
      [assignmentId, fileId, userId]
    );

    // Check if user has submitted before
    const hasSubmittedBefore = await queryOne(
      'SELECT * FROM assignment_members WHERE assignment_id = ? AND user_id = ?',
      [assignmentId, userId]
    );

    // Update assignment_members to mark as submitted (first submission)
    if (hasSubmittedBefore && hasSubmittedBefore.status !== 'submitted') {
      await query(
        'UPDATE assignment_members SET status = ?, submitted_at = NOW(), file_id = ? WHERE assignment_id = ? AND user_id = ?',
        ['submitted', fileId, assignmentId, userId]
      );
      console.log(`‚úÖ Assignment ${assignmentId} first submission by user ${userId} with file ${fileId}`);
    } else if (!hasSubmittedBefore) {
      // For 'all' assignments, create the assignment_members entry on first submission
      await query(
        'INSERT INTO assignment_members (assignment_id, user_id, status, submitted_at, file_id) VALUES (?, ?, ?, NOW(), ?)',
        [assignmentId, userId, 'submitted', fileId]
      );
      console.log(`‚úÖ Assignment ${assignmentId} first submission by user ${userId} (auto-created member entry)`);
    } else {
      console.log(`‚úÖ Assignment ${assignmentId} additional file submitted by user ${userId} with file ${fileId}`);
    }

    // Create notification for team leader about the submission
    try {
      console.log('üîî Creating submission notification for team leader');

      // Get user details for notification
      const submitter = await queryOne(
        'SELECT username, fullName FROM users WHERE id = ?',
        [userId]
      );

      // Get file details for notification
      const file = await queryOne(
        'SELECT original_name FROM files WHERE id = ?',
        [fileId]
      );

      const notificationData = {
        user_id: assignment.team_leader_id,
        assignment_id: assignmentId,
        file_id: fileId,
        type: 'submission',
        title: 'New File Submitted for Review',
        message: `${submitter.fullName} submitted "${file.original_name}" for the assignment "${assignment.title}"`,
        action_by_id: userId,
        action_by_username: submitter.username,
        action_by_role: 'USER'
      };

      console.log('Creating submission notification:', notificationData);

      await query(`
        INSERT INTO notifications (
          user_id,
          assignment_id,
          file_id,
          type,
          title,
          message,
          action_by_id,
          action_by_username,
          action_by_role
        ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
      `, [
        notificationData.user_id,
        notificationData.assignment_id,
        notificationData.file_id,
        notificationData.type,
        notificationData.title,
        notificationData.message,
        notificationData.action_by_id,
        notificationData.action_by_username,
        notificationData.action_by_role
      ]);

      console.log(`‚úÖ Submission notification created for team leader ${assignment.team_leader_id}`);
    } catch (notificationError) {
      console.error('‚ö†Ô∏è Failed to create submission notification:', notificationError);
    }

    res.json({
      success: true,
      message: 'File submitted successfully'
    });
  } catch (error) {
    console.error('Error submitting assignment:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to submit assignment',
      error: error.message
    });
  }
});

// Get comments for an assignment
router.get('/:assignmentId/comments', async (req, res) => {
  try {
    const { assignmentId } = req.params;

    // First get all comments for this assignment
    const comments = await query(`
      SELECT
        ac.*,
        u.fullName as user_fullname,
        u.role as user_role
      FROM assignment_comments ac
      JOIN users u ON ac.user_id = u.id
      WHERE ac.assignment_id = ?
      ORDER BY ac.created_at ASC
    `, [assignmentId]);

    // For each comment, get its replies
    for (const comment of comments) {
      const replies = await query(`
        SELECT
          cr.*,
          u.fullName as user_fullname,
          u.role as user_role
        FROM comment_replies cr
        JOIN users u ON cr.user_id = u.id
        WHERE cr.comment_id = ?
        ORDER BY cr.created_at ASC
      `, [comment.id]);

      comment.replies = replies || [];
    }

    console.log(`üìù Retrieved ${comments.length} comments for assignment ${assignmentId}`);

    res.json({
      success: true,
      comments: comments || []
    });
  } catch (error) {
    console.error('Error in get comments route:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to fetch comments',
      error: error.message
    });
  }
});

// Post a comment on an assignment
router.post('/:assignmentId/comments', async (req, res) => {
  try {
    const { assignmentId } = req.params;
    const { userId, username, comment } = req.body;

    if (!userId || !username || !comment) {
      return res.status(400).json({
        success: false,
        message: 'Missing required fields'
      });
    }

    // Get user's full name and role
    const user = await queryOne(
      'SELECT fullName, role FROM users WHERE id = ?',
      [userId]
    );

    if (!user) {
      return res.status(404).json({
        success: false,
        message: 'User not found'
      });
    }

    const result = await query(`
      INSERT INTO assignment_comments (
        assignment_id,
        user_id,
        username,
        user_fullname,
        user_role,
        comment
      ) VALUES (?, ?, ?, ?, ?, ?)
    `, [assignmentId, userId, username, user.fullName, user.role, comment]);

    // Fetch the newly created comment with full details
    const newComment = await queryOne(`
      SELECT 
        ac.*,
        u.fullName as user_fullname,
        u.role as user_role
      FROM assignment_comments ac
      JOIN users u ON ac.user_id = u.id
      WHERE ac.id = ?
    `, [result.insertId]);

    // Create notifications for assigned members
    try {
      console.log(` Comment posted by ${user.role}: ${user.fullName} (ID: ${userId})`);
      console.log(` Assignment ID: ${assignmentId}`);

      // Get assignment details
      const assignment = await queryOne(
        'SELECT title, team_leader_id FROM assignments WHERE id = ?',
        [assignmentId]
      );
      console.log(` Assignment title: ${assignment?.title}`);

      // Get all members assigned to this task (except the commenter)
      const assignedMembers = await query(
        'SELECT user_id FROM assignment_members WHERE assignment_id = ? AND user_id != ?',
        [assignmentId, userId]
      );

      console.log(` Found ${assignedMembers.length} assigned members (excluding commenter):`);
      console.log(assignedMembers);

      // If admin commented, notify both team leader AND assigned members
      if (user.role === 'ADMIN') {
        console.log('üèóÔ∏è Admin commented - notifying both team leader and assigned members');
        console.log('üìä Assignment details:', {
          assignmentId,
          team_leader_id: assignment.team_leader_id,
          teamLeaderId: assignment.teamLeaderId,
          userId,
          userRole: user.role,
          title: assignment.title
        });

        // Always notify the team leader if they exist (including if admin is also team leader)
        const teamLeaderId = assignment.team_leader_id || assignment.teamLeaderId;
        if (teamLeaderId) {
          console.log(`üì§ Creating notification for team leader ID: ${teamLeaderId}`);

          const teamLeaderNotification = await query(`
            INSERT INTO notifications (
              user_id,
              assignment_id,
              file_id,
              type,
              title,
              message,
              action_by_id,
              action_by_username,
              action_by_role
            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
          `, [
            assignment.team_leader_id,
            assignmentId,
            null,
            'comment',
            'New Admin Comment on Assignment',
            `Admin ${user.fullName} commented on "${assignment.title}": ${comment.substring(0, 100)}${comment.length > 100 ? '...' : ''}`,
            userId,
            username,
            user.role
          ]);

          console.log(` Notification created for team leader with ID: ${teamLeaderNotification.insertId}`);
        }

        // Then notify assigned members (except if any of them are team leaders who already got notified)
        if (assignedMembers.length === 0) {
          console.log(' No members to notify (either no one assigned or only commenter is assigned)');
        }

        // Create notification for each assigned member
        for (const member of assignedMembers) {
          console.log(` Creating notification for user ID: ${member.user_id}`);

          const notificationResult = await query(`
            INSERT INTO notifications (
              user_id,
              assignment_id,
              file_id,
              type,
              title,
              message,
              action_by_id,
              action_by_username,
              action_by_role
            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
          `, [
            member.user_id,
            assignmentId,
            null,
            'comment',
            'New Admin Comment on Assignment',
            `Admin ${user.fullName} commented on "${assignment.title}": ${comment.substring(0, 100)}${comment.length > 100 ? '...' : ''}`,
            userId,
            username,
            user.role
          ]);

          console.log(` Notification created with ID: ${notificationResult.insertId}`);
        }

        console.log(` Successfully created admin comment notifications for team leader + ${assignedMembers.length} member(s)`);
      }
      // If team leader commented, notify assigned members
      else if (user.role === 'TEAM_LEADER') {
        if (assignedMembers.length === 0) {
          console.log(' No members to notify (either no one assigned or only commenter is assigned)');
        }

        // Create notification for each assigned member
        for (const member of assignedMembers) {
          console.log(` Creating notification for user ID: ${member.user_id}`);

          const notificationResult = await query(`
            INSERT INTO notifications (
              user_id,
              assignment_id,
              file_id,
              type,
              title,
              message,
              action_by_id,
              action_by_username,
              action_by_role
            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
          `, [
            member.user_id,
            assignmentId,
            null,
            'comment',
            'New Comment on Assignment',
            `${user.fullName} commented on "${assignment.title}": ${comment.substring(0, 100)}${comment.length > 100 ? '...' : ''}`,
            userId,
            username,
            user.role
          ]);

          console.log(` Notification created with ID: ${notificationResult.insertId}`);
        }

        console.log(` Successfully created ${assignedMembers.length} comment notification(s)`);
      }
      // If regular user commented, notify team leader
      else if (user.role === 'USER' && assignment.team_leader_id && assignment.team_leader_id !== userId) {
        console.log(`üì§ Creating notification for team leader ID: ${assignment.team_leader_id}`);

        const notificationResult = await query(`
          INSERT INTO notifications (
            user_id,
            assignment_id,
            file_id,
            type,
            title,
            message,
            action_by_id,
            action_by_username,
            action_by_role
          ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
        `, [
          assignment.team_leader_id,
          assignmentId,
          null,
          'comment',
          'New Comment on Assignment',
          `${user.fullName} commented on "${assignment.title}": ${comment.substring(0, 100)}${comment.length > 100 ? '...' : ''}`,
          userId,
          username,
          user.role
        ]);

        console.log(` Notification created for team leader with ID: ${notificationResult.insertId}`);
      } else {
        console.log(`‚Ñπ User ${user.fullName} (${user.role}) posted comment - no additional notifications needed`);
      }
    } catch (notifError) {
      console.error('‚ö†Ô∏è Failed to create comment notifications:', notifError);
      console.error('Error stack:', notifError.stack);
      // Don't fail the request if notifications fail
    }

    res.json({
      success: true,
      message: 'Comment posted successfully',
      comment: newComment
    });
  } catch (error) {
    console.error('Error in post comment route:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to post comment',
      error: error.message
    });
  }
});

// Post a reply to a comment
router.post('/:assignmentId/comments/:commentId/reply', async (req, res) => {
  try {
    const { assignmentId, commentId } = req.params;
    const { userId, username, reply } = req.body;

    if (!userId || !username || !reply) {
      return res.status(400).json({
        success: false,
        message: 'Missing required fields'
      });
    }

    // Verify comment exists and belongs to the assignment
    const comment = await queryOne(
      'SELECT * FROM assignment_comments WHERE id = ? AND assignment_id = ?',
      [commentId, assignmentId]
    );

    if (!comment) {
      return res.status(404).json({
        success: false,
        message: 'Comment not found'
      });
    }

    // Get user's full name and role
    const user = await queryOne(
      'SELECT fullName, role FROM users WHERE id = ?',
      [userId]
    );

    if (!user) {
      return res.status(404).json({
        success: false,
        message: 'User not found'
      });
    }

    const result = await query(`
      INSERT INTO comment_replies (
        comment_id,
        user_id,
        username,
        user_fullname,
        user_role,
        reply
      ) VALUES (?, ?, ?, ?, ?, ?)
    `, [commentId, userId, username, user.fullName, user.role, reply]);

    // Fetch the newly created reply with full details
    const newReply = await queryOne(`
      SELECT 
        cr.*,
        u.fullName as user_fullname,
        u.role as user_role
      FROM comment_replies cr
      JOIN users u ON cr.user_id = u.id
      WHERE cr.id = ?
    `, [result.insertId]);

    // Create notification for the original comment author if different from replier
    if (comment.user_id !== userId) {
      try {
        // Get assignment details
        const assignment = await queryOne(
          'SELECT title FROM assignments WHERE id = ?',
          [assignmentId]
        );

        await query(`
          INSERT INTO notifications (
            user_id,
            assignment_id,
            file_id,
            type,
            title,
            message,
            action_by_id,
            action_by_username,
            action_by_role
          ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
        `, [
          comment.user_id,
          assignmentId,
          null,
          'comment',
          'New Reply on Assignment',
          `${user.fullName} replied to your comment on "${assignment.title}": ${reply.substring(0, 100)}${reply.length > 100 ? '...' : ''}`,
          userId,
          username,
          user.role
        ]);

        console.log(` Created reply notification for user ${comment.user_id}`);
      } catch (notifError) {
        console.error(' Failed to create reply notification:', notifError);
        // Don't fail the request if notifications fail
      }
    }

    res.json({
      success: true,
      message: 'Reply posted successfully',
      reply: newReply
    });
  } catch (error) {
    console.error('Error in post reply route:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to post reply',
      error: error.message
    });
  }
});

// Archive assignment (Admin only)
router.patch('/:assignmentId/archive', async (req, res) => {
  try {
    const { assignmentId } = req.params;

    // Verify assignment exists
    const assignment = await queryOne(
      'SELECT * FROM assignments WHERE id = ?',
      [assignmentId]
    );

    if (!assignment) {
      return res.status(404).json({
        success: false,
        message: 'Assignment not found'
      });
    }

    // Toggle archive status
    const newArchiveStatus = assignment.archived ? 0 : 1;
    await query(
      'UPDATE assignments SET archived = ?, archived_at = ? WHERE id = ?',
      [newArchiveStatus, newArchiveStatus === 1 ? new Date() : null, assignmentId]
    );

    res.json({
      success: true,
      message: newArchiveStatus === 1 ? 'Assignment archived successfully' : 'Assignment unarchived successfully',
      archived: newArchiveStatus === 1
    });
  } catch (error) {
    console.error('Error in archive assignment route:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to archive assignment',
      error: error.message
    });
  }
});

// Mark assignment as done (Team Leader only)
router.put('/:assignmentId/mark-done', async (req, res) => {
  try {
    const { assignmentId } = req.params;
    const { teamLeaderId, teamLeaderUsername, team } = req.body;

    console.log(`‚úÖ Marking assignment ${assignmentId} as completed by ${teamLeaderUsername}`);

    // Verify assignment exists
    const assignment = await queryOne(
      'SELECT * FROM assignments WHERE id = ?',
      [assignmentId]
    );

    if (!assignment) {
      return res.status(404).json({
        success: false,
        message: 'Assignment not found'
      });
    }

    // Update assignment status to completed
    const now = new Date().toISOString().slice(0, 19).replace('T', ' ');

    await query(
      'UPDATE assignments SET status = ?, updated_at = ? WHERE id = ?',
      ['completed', now, assignmentId]
    );

    console.log(`‚úÖ Assignment ${assignmentId} marked as completed`);

    res.json({
      success: true,
      message: 'Assignment marked as completed',
      assignment: {
        ...assignment,
        status: 'completed',
        updated_at: now
      }
    });
  } catch (error) {
    console.error('Error marking assignment as done:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to mark assignment as done',
      error: error.message
    });
  }
});

// Update assignment (Team Leader only)
router.put('/:assignmentId', async (req, res) => {
  try {
    const { assignmentId } = req.params;
    const {
      title,
      description,
      dueDate,
      fileTypeRequired,
      assignedMembers,
      teamLeaderId,
      teamLeaderUsername,
      team
    } = req.body;

    console.log(`‚úèÔ∏è Updating assignment ${assignmentId} by ${teamLeaderUsername}`);

    // Verify assignment exists
    const assignment = await queryOne(
      'SELECT * FROM assignments WHERE id = ?',
      [assignmentId]
    );

    if (!assignment) {
      return res.status(404).json({
        success: false,
        message: 'Assignment not found'
      });
    }

    // Update assignment details
    const now = new Date().toISOString().slice(0, 19).replace('T', ' ');

    await query(`
      UPDATE assignments
      SET
        title = ?,
        description = ?,
        due_date = ?,
        file_type_required = ?,
        updated_at = ?
      WHERE id = ?
    `, [
      title,
      description || null,
      dueDate || null,
      fileTypeRequired || null,
      now,
      assignmentId
    ]);

    console.log(`‚úÖ Assignment ${assignmentId} details updated`);

    // Update assigned members if provided
    if (assignedMembers && Array.isArray(assignedMembers)) {
      // Get current assigned members
      const currentMembers = await query(
        'SELECT user_id FROM assignment_members WHERE assignment_id = ?',
        [assignmentId]
      );

      const currentMemberIds = currentMembers.map(m => m.user_id);
      const newMemberIds = assignedMembers;

      // Find members to add and remove
      const membersToAdd = newMemberIds.filter(id => !currentMemberIds.includes(id));
      const membersToRemove = currentMemberIds.filter(id => !newMemberIds.includes(id));

      // Remove members that are no longer assigned
      if (membersToRemove.length > 0) {
        await query(
          `DELETE FROM assignment_members WHERE assignment_id = ? AND user_id IN (${membersToRemove.map(() => '?').join(',')})`,
          [assignmentId, ...membersToRemove]
        );
        console.log(`‚úÖ Removed ${membersToRemove.length} member(s) from assignment`);
      }

      // Add new members
      if (membersToAdd.length > 0) {
        const memberValues = membersToAdd.map(userId => [assignmentId, userId]);
        const placeholders = memberValues.map(() => '(?, ?)').join(', ');
        const flattenedValues = memberValues.flat();

        await query(
          `INSERT INTO assignment_members (assignment_id, user_id) VALUES ${placeholders}`,
          flattenedValues
        );
        console.log(`‚úÖ Added ${membersToAdd.length} new member(s) to assignment`);

        // Create notifications for newly added members
        try {
          for (const userId of membersToAdd) {
            await query(`
              INSERT INTO notifications (
                user_id,
                assignment_id,
                file_id,
                type,
                title,
                message,
                action_by_id,
                action_by_username,
                action_by_role
              ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
            `, [
              userId,
              assignmentId,
              null,
              'assignment',
              'Added to Assignment',
              `${teamLeaderUsername} added you to the task: "${title}"${dueDate ? ` - Due: ${new Date(dueDate).toLocaleDateString()}` : ''}`,
              teamLeaderId,
              teamLeaderUsername,
              'TEAM_LEADER'
            ]);
          }
          console.log(`‚úÖ Created notifications for ${membersToAdd.length} newly added member(s)`);
        } catch (notifError) {
          console.error('‚ö†Ô∏è Failed to create notifications for new members:', notifError);
        }
      }
    }

    // Log activity
    try {
      await query(`
        INSERT INTO activity_logs (
          user_id,
          username,
          role,
          team,
          activity
        ) VALUES (?, ?, ?, ?, ?)
      `, [
        teamLeaderId,
        teamLeaderUsername,
        'TEAM_LEADER',
        team,
        `Updated assignment: ${title}`
      ]);
    } catch (logError) {
      console.warn('Activity log insertion failed:', logError.message);
    }

    res.json({
      success: true,
      message: 'Assignment updated successfully'
    });
  } catch (error) {
    console.error('Error updating assignment:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to update assignment',
      error: error.message
    });
  }
});

// Delete assignment (Admin only - permanent delete)
router.delete('/:assignmentId', async (req, res) => {
  try {
    const { assignmentId } = req.params;

    // Verify assignment exists
    const assignment = await queryOne(
      'SELECT * FROM assignments WHERE id = ?',
      [assignmentId]
    );

    if (!assignment) {
      return res.status(404).json({
        success: false,
        message: 'Assignment not found'
      });
    }

    // Get all file IDs associated with this assignment
    const submittedFiles = await query(
      'SELECT file_id FROM assignment_submissions WHERE assignment_id = ?',
      [assignmentId]
    );

    console.log(`‚úÖ Assignment ${assignmentId} has ${submittedFiles ? submittedFiles.length : 0} submitted file(s)`);
    console.log('‚ÑπÔ∏è Files will be kept in database and NAS - they will return to users\' "My Files"');
    
    // ‚úÖ IMPORTANT: Do NOT delete files from the files table
    // Files should persist after assignment deletion so users can access them in "My Files"
    // Only delete the assignment_submissions links (done below via cascade)

    // Delete related records (replies will cascade delete when comments are deleted)
    await query('DELETE FROM assignment_submissions WHERE assignment_id = ?', [assignmentId]);
    await query('DELETE FROM assignment_members WHERE assignment_id = ?', [assignmentId]);
    await query('DELETE FROM assignment_comments WHERE assignment_id = ?', [assignmentId]);

    // Delete the assignment
    await query('DELETE FROM assignments WHERE id = ?', [assignmentId]);

    console.log(` Assignment ${assignmentId} deleted successfully with all related data`);

    res.json({
      success: true,
      message: 'Assignment and associated files deleted permanently',
      deletedFiles: submittedFiles ? submittedFiles.length : 0
    });
  } catch (error) {
    console.error('Error in delete assignment route:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to delete assignment',
      error: error.message
    });
  }
});

// Remove a submitted file from an assignment
router.delete('/:assignmentId/files/:fileId', async (req, res) => {
  try {
    const { assignmentId, fileId } = req.params;
    const { userId } = req.body;

    console.log(`üóëÔ∏è Removing file ${fileId} from assignment ${assignmentId} for user ${userId}`);

    // Verify the file belongs to this user and assignment
    const submission = await queryOne(
      'SELECT * FROM assignment_submissions WHERE assignment_id = ? AND file_id = ? AND user_id = ?',
      [assignmentId, fileId, userId]
    );

    if (!submission) {
      console.log('‚ùå Submission not found or user not authorized');
      return res.status(404).json({
        success: false,
        message: 'File not found or you are not authorized to remove it'
      });
    }

    // Get file info before deleting to get the physical file path
    const fileInfo = await queryOne(
      'SELECT file_path FROM files WHERE id = ?',
      [fileId]
    );

    // Delete from assignment_submissions table
    await query(
      'DELETE FROM assignment_submissions WHERE assignment_id = ? AND file_id = ? AND user_id = ?',
      [assignmentId, fileId, userId]
    );
    console.log('‚úÖ Removed from assignment_submissions');

    // Check if there are any remaining submissions for this assignment by this user
    const remainingSubmissions = await query(
      'SELECT * FROM assignment_submissions WHERE assignment_id = ? AND user_id = ?',
      [assignmentId, userId]
    );

    // If no more submissions, update assignment_members status to pending
    if (!remainingSubmissions || remainingSubmissions.length === 0) {
      await query(
        'UPDATE assignment_members SET status = ?, submitted_at = NULL, file_id = NULL WHERE assignment_id = ? AND user_id = ?',
        ['pending', assignmentId, userId]
      );
      console.log('‚úÖ Updated assignment_members status to pending (no more submissions)');
    } else {
      // If there are remaining submissions, update the file_id to the most recent one
      const mostRecentFile = remainingSubmissions[0];
      await query(
        'UPDATE assignment_members SET file_id = ?, submitted_at = ? WHERE assignment_id = ? AND user_id = ?',
        [mostRecentFile.file_id, mostRecentFile.submitted_at, assignmentId, userId]
      );
      console.log('‚úÖ Updated assignment_members to point to most recent submission');
    }

    // ‚úÖ IMPORTANT: Keep file record in database and physical file in NAS
    // This allows the file to reappear in "My Files" after being removed from assignment
    // Only the assignment_submissions link is removed above
    console.log('‚ÑπÔ∏è File record kept in database - file will return to "My Files"');
    console.log('‚ÑπÔ∏è Physical file kept in NAS at:', fileInfo?.file_path);

    res.json({
      success: true,
      message: 'File removed successfully'
    });

  } catch (error) {
    console.error('‚ùå Error removing submitted file:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to remove file',
      error: error.message
    });
  }
});

// Debug endpoint - Get raw assignment_members data
router.get('/debug/:assignmentId/members', async (req, res) => {
  try {
    const { assignmentId } = req.params;

    const members = await query(
      'SELECT * FROM assignment_members WHERE assignment_id = ?',
      [assignmentId]
    );

    const assignment = await queryOne(
      'SELECT * FROM assignments WHERE id = ?',
      [assignmentId]
    );

    res.json({
      success: true,
      assignment,
      members,
      membersCount: members?.length || 0
    });
  } catch (error) {
    console.error('Error in debug endpoint:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to fetch debug data',
      error: error.message
    });
  }
});

module.exports = router;


/***/ }),

/***/ 38851:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

const express = __nccwpck_require__(85152);
const bcrypt = __nccwpck_require__(11289);
const { db } = __nccwpck_require__(5024);
const { logActivity, logError, logInfo, logWarn } = __nccwpck_require__(46534);
const { createNotification } = __nccwpck_require__(83565);
const { validate, schemas } = __nccwpck_require__(17632);
const { asyncHandler, AuthenticationError } = __nccwpck_require__(5369);

const router = express.Router();

// Health check endpoint
router.get('/health', (req, res) => {
  res.json({ status: 'OK', message: 'Server is running' });
});

// Login endpoint
router.post('/login', validate(schemas.login), asyncHandler(async (req, res) => {
  const { email, password, loginType = 'user' } = req.body;

  logInfo('Login attempt', { email, loginType });

  // Find user by email OR username
  const query = email.includes('@')
    ? 'SELECT * FROM users WHERE email = ?'
    : 'SELECT * FROM users WHERE username = ?';

  const user = await new Promise((resolve, reject) => {
    db.get(query, [email], (err, row) => {
      if (err) {
        reject(err);
      } else {
        resolve(row);
      }
    });
  });

  if (!user) {
    logInfo('Login failed - user not found', { email });
    throw new AuthenticationError('Invalid email or password');
  }

  // Verify password
  const isValidPassword = bcrypt.compareSync(password, user.password);
  if (!isValidPassword) {
    logInfo('Login failed - invalid password', { email });
    throw new AuthenticationError('Invalid email or password');
  }

  logInfo('Password verified', { userId: user.id, role: user.role });

  // Role-based access control
  const rawRole = (user.role || '').toString().trim().toUpperCase();
  const normalizedRole = rawRole.replace(/\s+/g, '_');

  if (loginType === 'user') {
    // User window: USER and TEAM_LEADER can access. ADMIN must use Admin Login.
    if (normalizedRole === 'ADMIN') {
      logInfo('Admin attempted user window access', { userId: user.id });
      throw new AuthenticationError('Please switch to Admin Login to continue.');
    }
  } else if (loginType === 'admin') {
    // Admin window: TEAM_LEADER and ADMIN can access
    if (normalizedRole === 'USER') {
      logInfo('User attempted admin window access', { userId: user.id });
      throw new AuthenticationError('You do not have permission to access the Admin Login. Please use the User Login instead.');
    }
  }

  // Determine panel type based on role and login type
  let panelType;
  if (loginType === 'user') {
    panelType = 'user';
  } else if (loginType === 'admin') {
    if (normalizedRole === 'TEAM_LEADER') {
      panelType = 'teamleader';
    } else if (normalizedRole === 'ADMIN') {
      panelType = 'admin';
    }
  }

  logInfo('Login successful', { userId: user.id, role: user.role, panelType });

  // Log activity
  logActivity(
    db,
    user.id,
    user.username,
    user.role,
    user.team,
    `User logged in via ${loginType} portal`
  );

  // Remove password from user object before sending response
  const { password: _password, ...userWithoutPassword } = user;
  res.json({
    success: true,
    user: {
      ...userWithoutPassword,
      panelType
    },
    message: 'Login successful'
  });
}));

// Forgot password endpoint
router.post('/forgot-password', validate(schemas.forgotPassword), asyncHandler(async (req, res) => {
  const { email } = req.body;

  logInfo('Forgot password request', { email });

  // Always return success for security reasons (don't reveal if email exists)
  res.json({
    success: true,
    message: 'If the account exists, admin has been notified.'
  });

  try {
    // First, find the user who is requesting the reset (by email or username)
    const userQuery = email.includes('@')
      ? 'SELECT id, username, fullName, email, role FROM users WHERE email = ?'
      : 'SELECT id, username, fullName, email, role FROM users WHERE username = ?';

    const requestingUser = await new Promise((resolve, reject) => {
      db.get(userQuery, [email], (err, row) => {
        if (err) {
          reject(err);
        } else {
          resolve(row);
        }
      });
    });

    if (!requestingUser) {
      logInfo('Password reset - user not found', { email });
      return; // Still return success to client for security
    }

    logInfo('Password reset - user found', { userId: requestingUser.id, username: requestingUser.username });

    // Find all admin users to notify them
    const adminQuery = 'SELECT id, username, role FROM users WHERE role LIKE ?';
    const adminUsers = await new Promise((resolve, reject) => {
      db.all(adminQuery, ['%ADMIN%'], (err, rows) => {
        if (err) {
          reject(err);
        } else {
          resolve(rows || []);
        }
      });
    });

    logInfo('Password reset - notifying admins', { adminCount: adminUsers.length });

    // Create notification for each admin user
    const notificationPromises = adminUsers.map(async (admin) => {
      const notificationMessage = `${requestingUser.fullName || requestingUser.username} (${requestingUser.email}) has requested a password reset.`;

      // Create a notification with password_reset_request type
      await createNotification(
        admin.id,                    // userId (admin receiving notification)
        null,                        // fileId (explicitly null for password reset)
        'password_reset_request',    // type
        'Password Reset Request',    // title
        notificationMessage,         // message (contains requesting user info)
        requestingUser.id,           // actionById (user who requested reset)
        requestingUser.username,     // actionByUsername
        requestingUser.role || 'USER', // actionByRole (use actual role, not hardcoded)
        null                         // assignmentId (no assignment)
      );

      logInfo('Password reset notification created', { adminId: admin.id, adminUsername: admin.username });
    });

    await Promise.all(notificationPromises);


    logInfo('Password reset request completed', { email, notifiedAdmins: adminUsers.length });

  } catch (error) {
    logError(error, { context: 'forgot-password', email });
    // Don't send error to client for security
  }
}));

module.exports = router;


/***/ }),

/***/ 15111:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

const express = __nccwpck_require__(85152);
const { USE_MYSQL } = __nccwpck_require__(5024);

const router = express.Router();

// Get database connection based on mode
let db;
if (USE_MYSQL) {
  db = __nccwpck_require__(55364);
} else {
  db = (__nccwpck_require__(5024).db);
}

// Get all custom tags (shared across all users)
router.get('/', async (req, res) => {
  console.log('üìã Getting all custom tags');

  try {
    let tags;
    
    if (USE_MYSQL) {
      tags = await db.query(
        `SELECT id, tag_name, created_at, created_by 
         FROM custom_tags 
         ORDER BY tag_name ASC`
      );
    } else {
      tags = await new Promise((resolve, reject) => {
        db.all(
          `SELECT id, tag_name, created_at, created_by 
           FROM custom_tags 
           ORDER BY tag_name ASC`,
          [],
          (err, rows) => {
            if (err) reject(err);
            else resolve(rows);
          }
        );
      });
    }

    console.log(`‚úÖ Retrieved ${tags.length} custom tags`);
    res.json({
      success: true,
      tags: tags.map(tag => tag.tag_name) // Return just the tag names
    });
  } catch (err) {
    console.error('‚ùå Error fetching custom tags:', err);
    res.status(500).json({
      success: false,
      message: 'Failed to fetch custom tags'
    });
  }
});

// Add a new custom tag
router.post('/', async (req, res) => {
  const { tagName, userId } = req.body;

  if (!tagName || !tagName.trim()) {
    return res.status(400).json({
      success: false,
      message: 'Tag name is required'
    });
  }

  if (!userId) {
    return res.status(400).json({
      success: false,
      message: 'User ID is required'
    });
  }

  const trimmedTag = tagName.trim();
  console.log(`‚ûï Adding custom tag: "${trimmedTag}" by user ${userId}`);

  try {
    // Check if tag already exists
    let existingTag;
    
    if (USE_MYSQL) {
      const results = await db.query(
        'SELECT id FROM custom_tags WHERE tag_name = ?',
        [trimmedTag]
      );
      existingTag = results.length > 0 ? results[0] : null;
    } else {
      existingTag = await new Promise((resolve, reject) => {
        db.get(
          'SELECT id FROM custom_tags WHERE tag_name = ?',
          [trimmedTag],
          (err, row) => {
            if (err) reject(err);
            else resolve(row);
          }
        );
      });
    }

    if (existingTag) {
      console.log('‚ö†Ô∏è Tag already exists');
      return res.json({
        success: true,
        message: 'Tag already exists',
        tagExists: true
      });
    }

    // Insert new tag
    let result;
    
    if (USE_MYSQL) {
      result = await db.query(
        'INSERT INTO custom_tags (tag_name, created_by) VALUES (?, ?)',
        [trimmedTag, userId]
      );
      console.log(`‚úÖ Custom tag added with ID: ${result.insertId}`);
      res.json({
        success: true,
        message: 'Custom tag added successfully',
        tag: {
          id: result.insertId,
          tag_name: trimmedTag
        }
      });
    } else {
      result = await new Promise((resolve, reject) => {
        db.run(
          'INSERT INTO custom_tags (tag_name, created_by) VALUES (?, ?)',
          [trimmedTag, userId],
          function(err) {
            if (err) reject(err);
            else resolve({ lastID: this.lastID });
          }
        );
      });
      console.log(`‚úÖ Custom tag added with ID: ${result.lastID}`);
      res.json({
        success: true,
        message: 'Custom tag added successfully',
        tag: {
          id: result.lastID,
          tag_name: trimmedTag
        }
      });
    }
  } catch (err) {
    console.error('‚ùå Error adding custom tag:', err);
    res.status(500).json({
      success: false,
      message: 'Failed to add custom tag'
    });
  }
});

// Delete a custom tag (optional - for future use)
router.delete('/:tagId', async (req, res) => {
  const { tagId } = req.params;
  const { userId } = req.body;

  console.log(`üóëÔ∏è Deleting custom tag ${tagId} by user ${userId}`);

  try {
    let result;
    
    if (USE_MYSQL) {
      result = await db.query(
        'DELETE FROM custom_tags WHERE id = ?',
        [tagId]
      );
      
      if (result.affectedRows === 0) {
        return res.status(404).json({
          success: false,
          message: 'Tag not found'
        });
      }
    } else {
      result = await new Promise((resolve, reject) => {
        db.run(
          'DELETE FROM custom_tags WHERE id = ?',
          [tagId],
          function(err) {
            if (err) reject(err);
            else resolve({ changes: this.changes });
          }
        );
      });
      
      if (result.changes === 0) {
        return res.status(404).json({
          success: false,
          message: 'Tag not found'
        });
      }
    }

    console.log('‚úÖ Custom tag deleted');
    res.json({
      success: true,
      message: 'Custom tag deleted successfully'
    });
  } catch (err) {
    console.error('‚ùå Error deleting custom tag:', err);
    res.status(500).json({
      success: false,
      message: 'Failed to delete custom tag'
    });
  }
});

module.exports = router;


/***/ }),

/***/ 94049:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

const express = __nccwpck_require__(85152);
const { db } = __nccwpck_require__(5024);
const { categorizeFileTypes } = __nccwpck_require__(51099);

const router = express.Router();

// GET /api/dashboard/summary
// Returns aggregate counts and recent activity for admin dashboard
router.get('/summary', (req, res) => {
  const summary = {};

  // Total files
  db.get('SELECT COUNT(*) as total FROM files', [], (err, totalResult) => {
    if (err) {
      return res.status(500).json({ success: false, message: 'Failed to fetch total files' });
    }
    summary.totalFiles = totalResult.total || 0;

    // Approved (final_approved)
    db.get("SELECT COUNT(*) as approved FROM files WHERE status = 'final_approved'", [], (err, approvedResult) => {
      if (err) {
        return res.status(500).json({ success: false, message: 'Failed to fetch approved count' });
      }
      summary.approved = approvedResult.approved || 0;

      // Pending (not final_approved and not rejected)
      db.get("SELECT COUNT(*) as pending FROM files WHERE status NOT IN ('final_approved','rejected_by_admin','rejected_by_team_leader')", [], (err, pendingResult) => {
        if (err) {
          return res.status(500).json({ success: false, message: 'Failed to fetch pending count' });
        }
        summary.pending = pendingResult.pending || 0;

        // Rejected (any rejection status)
        db.get("SELECT COUNT(*) as rejected FROM files WHERE status LIKE 'rejected%'", [], (err, rejectedResult) => {
          if (err) {
            return res.status(500).json({ success: false, message: 'Failed to fetch rejected count' });
          }
          summary.rejected = rejectedResult.rejected || 0;

          // File types breakdown (group by file_type)
          db.all('SELECT file_type, COUNT(*) as count FROM files GROUP BY file_type ORDER BY count DESC', [], (err, types) => {
            if (err) {
              // non-fatal - continue without types
              summary.fileTypes = [];
            } else {
              // Categorize file types for better visualization
              summary.fileTypes = categorizeFileTypes(types || []);
            }

            // Recent activity logs
            db.all('SELECT id, username, role, team, activity, timestamp FROM activity_logs ORDER BY timestamp DESC LIMIT 6', [], (err, logs) => {
              if (err) {
                return res.status(500).json({ success: false, message: 'Failed to fetch activity logs' });
              }
              summary.recentActivity = logs || [];

              // Approval rate & simple stats (derived)
              const approvalRate = summary.totalFiles > 0 ? (summary.approved / summary.totalFiles) * 100 : 0;
              summary.approvalRate = Math.round(approvalRate * 10) / 10; // 1 decimal

              // Previous month statistics for comparison
              const now = new Date();
              const firstDayOfCurrentMonth = new Date(now.getFullYear(), now.getMonth(), 1);
              const firstDayOfPrevMonth = new Date(now.getFullYear(), now.getMonth() - 1, 1);

              db.get(
                'SELECT COUNT(*) as total FROM files WHERE uploaded_at >= ? AND uploaded_at < ?',
                [firstDayOfPrevMonth.toISOString(), firstDayOfCurrentMonth.toISOString()],
                (err, prevTotalResult) => {
                  const prevTotal = prevTotalResult ? prevTotalResult.total || 0 : 0;

                  db.get(
                    'SELECT COUNT(*) as approved FROM files WHERE status = \'final_approved\' AND uploaded_at >= ? AND uploaded_at < ?',
                    [firstDayOfPrevMonth.toISOString(), firstDayOfCurrentMonth.toISOString()],
                    (err, prevApprovedResult) => {
                      const prevApproved = prevApprovedResult ? prevApprovedResult.approved || 0 : 0;

                      db.get(
                        'SELECT COUNT(*) as pending FROM files WHERE status NOT IN (\'final_approved\',\'rejected_by_admin\',\'rejected_by_team_leader\') AND uploaded_at >= ? AND uploaded_at < ?',
                        [firstDayOfPrevMonth.toISOString(), firstDayOfCurrentMonth.toISOString()],
                        (err, prevPendingResult) => {
                          const prevPending = prevPendingResult ? prevPendingResult.pending || 0 : 0;

                          db.get(
                            'SELECT COUNT(*) as rejected FROM files WHERE status LIKE \'rejected%\' AND uploaded_at >= ? AND uploaded_at < ?',
                            [firstDayOfPrevMonth.toISOString(), firstDayOfCurrentMonth.toISOString()],
                            (err, prevRejectedResult) => {
                              const prevRejected = prevRejectedResult ? prevRejectedResult.rejected || 0 : 0;

                              summary.previousMonth = {
                                totalFiles: prevTotal,
                                approved: prevApproved,
                                pending: prevPending,
                                rejected: prevRejected
                              };

                              // Approval trends - Last 30 days of daily approval/rejection activity
                              db.all(
                                `SELECT 
                                  DATE(uploaded_at) as date,
                                  SUM(CASE WHEN status = 'final_approved' OR current_stage = 'published_to_public' THEN 1 ELSE 0 END) as approved,
                                  SUM(CASE WHEN status LIKE 'rejected%' OR current_stage LIKE 'rejected%' THEN 1 ELSE 0 END) as rejected
                                FROM files
                                WHERE uploaded_at >= DATE_SUB(CURDATE(), INTERVAL 30 DAY)
                                GROUP BY DATE(uploaded_at)
                                ORDER BY date ASC`,
                                [],
                                (err, trends) => {
                                  if (err) {
                                    console.error('Error fetching approval trends:', err);
                                    summary.approvalTrends = [];
                                  } else {
                                    // Format dates for display (e.g., "Oct 1", "Oct 2")
                                    summary.approvalTrends = (trends || []).map(t => {
                                      const d = new Date(t.date);
                                      const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
                                      return {
                                        day: `${monthNames[d.getMonth()]} ${d.getDate()}`,
                                        date: t.date,
                                        approved: t.approved || 0,
                                        rejected: t.rejected || 0
                                      };
                                    });
                                  }

                                  res.json({ success: true, summary });
                                }
                              );
                            }
                          );
                        }
                      );
                    }
                  );
                }
              );
            });
          });
        });
      });
    });
  });
});

// GET /api/dashboard/team/:teamName
// Returns team-specific analytics for team leader dashboard
router.get('/team/:teamName', (req, res) => {
  const { teamName } = req.params;
  console.log(`üìä Getting analytics for team: ${teamName}`);

  const analytics = {};

  // Total files for team
  db.get('SELECT COUNT(*) as total FROM files WHERE user_team = ?', [teamName], (err, totalResult) => {
    if (err) {
      console.error('‚ùå Error getting team total files:', err);
      return res.status(500).json({ success: false, message: 'Failed to fetch analytics' });
    }
    analytics.totalFiles = totalResult.total || 0;

    // Approved files
    db.get("SELECT COUNT(*) as approved FROM files WHERE user_team = ? AND status = 'final_approved'", [teamName], (err, approvedResult) => {
      if (err) {
        console.error('‚ùå Error getting team approved files:', err);
        return res.status(500).json({ success: false, message: 'Failed to fetch analytics' });
      }
      analytics.approvedFiles = approvedResult.approved || 0;

      // Pending team leader review
      db.get("SELECT COUNT(*) as pending FROM files WHERE user_team = ? AND current_stage = 'pending_team_leader'", [teamName], (err, pendingTLResult) => {
        if (err) {
          console.error('‚ùå Error getting pending TL files:', err);
          return res.status(500).json({ success: false, message: 'Failed to fetch analytics' });
        }
        analytics.pendingTeamLeaderReview = pendingTLResult.pending || 0;

        // Pending admin review
        db.get("SELECT COUNT(*) as pending FROM files WHERE user_team = ? AND current_stage = 'pending_admin'", [teamName], (err, pendingAdminResult) => {
          if (err) {
            console.error('‚ùå Error getting pending admin files:', err);
            return res.status(500).json({ success: false, message: 'Failed to fetch analytics' });
          }
          analytics.pendingAdminReview = pendingAdminResult.pending || 0;

          // Rejected files
          db.get("SELECT COUNT(*) as rejected FROM files WHERE user_team = ? AND current_stage LIKE 'rejected%'", [teamName], (err, rejectedResult) => {
            if (err) {
              console.error('‚ùå Error getting rejected files:', err);
              return res.status(500).json({ success: false, message: 'Failed to fetch analytics' });
            }
            analytics.rejectedFiles = rejectedResult.rejected || 0;

            // Team members count
            db.get('SELECT COUNT(*) as total FROM users WHERE team = ? AND role != ?', [teamName, 'TEAM LEADER'], (err, membersResult) => {
              if (err) {
                console.error('‚ùå Error getting team members count:', err);
                return res.status(500).json({ success: false, message: 'Failed to fetch analytics' });
              }
              analytics.teamMembers = membersResult.total || 0;

              // File types breakdown for team
              db.all('SELECT file_type, COUNT(*) as count FROM files WHERE user_team = ? GROUP BY file_type ORDER BY count DESC', [teamName], (err, fileTypes) => {
                if (err) {
                  console.error('‚ùå Error getting file types:', err);
                  analytics.fileTypes = [];
                } else {
                  // Categorize file types for better visualization
                  analytics.fileTypes = categorizeFileTypes(fileTypes || []);
                }

                // Top contributors (members with most files)
                db.all(
                  `SELECT u.id, u.fullName, u.username, COUNT(f.id) as fileCount
                   FROM users u
                   LEFT JOIN files f ON u.id = f.user_id
                   WHERE u.team = ? AND u.role != ?
                   GROUP BY u.id, u.fullName, u.username
                   ORDER BY fileCount DESC
                   LIMIT 5`,
                  [teamName, 'TEAM LEADER'],
                  (err, topContributors) => {
                    if (err) {
                      console.error('‚ùå Error getting top contributors:', err);
                      analytics.topContributors = [];
                    } else {
                      analytics.topContributors = topContributors || [];
                    }

                    // Approval rate
                    const approvalRate = analytics.totalFiles > 0
                      ? (analytics.approvedFiles / analytics.totalFiles) * 100
                      : 0;
                    analytics.approvalRate = Math.round(approvalRate * 10) / 10;

                    // Average review time (in days)
                    db.get(
                      `SELECT AVG(DATEDIFF(team_leader_reviewed_at, uploaded_at)) as avgDays
                       FROM files
                       WHERE user_team = ? AND team_leader_reviewed_at IS NOT NULL`,
                      [teamName],
                      (err, avgTimeResult) => {
                        if (err) {
                          console.error('‚ùå Error getting average review time:', err);
                          analytics.avgReviewTime = 0;
                        } else {
                          analytics.avgReviewTime = avgTimeResult.avgDays ? Math.round(avgTimeResult.avgDays * 10) / 10 : 0;
                        }

                        // Files by stage (for pie chart)
                        db.all(
                          'SELECT current_stage, COUNT(*) as count FROM files WHERE user_team = ? GROUP BY current_stage',
                          [teamName],
                          (err, stageBreakdown) => {
                            if (err) {
                              console.error('‚ùå Error getting stage breakdown:', err);
                              analytics.stageBreakdown = [];
                            } else {
                              analytics.stageBreakdown = stageBreakdown || [];
                            }

                            // Recent activity for team
                            db.all(
                              `SELECT username, role, activity, timestamp FROM activity_logs
                               WHERE team = ? ORDER BY timestamp DESC LIMIT 10`,
                              [teamName],
                              (err, recentActivity) => {
                                if (err) {
                                  console.error('‚ùå Error getting recent activity:', err);
                                  analytics.recentActivity = [];
                                } else {
                                  analytics.recentActivity = recentActivity || [];
                                }

                                console.log(`‚úÖ Retrieved analytics for team ${teamName}`);
                                res.json({ success: true, analytics });
                              }
                            );
                          }
                        );
                      }
                    );
                  }
                );
              });
            });
          });
        });
      });
    });
  });
});

module.exports = router;


/***/ }),

/***/ 33162:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

const express = __nccwpck_require__(85152);
const fs = (__nccwpck_require__(79896).promises);
const path = __nccwpck_require__(16928);
const { truncateName, formatFileSize, getParentPath } = __nccwpck_require__(41987);
const { db, USE_MYSQL } = __nccwpck_require__(5024);

const router = express.Router();

// Default network projects directory
const networkProjectsPath = '\\\\KMTI-NAS\\Shared\\Public\\PROJECTS';

// Function to get current root directory from settings
async function getRootDirectory() {
  try {
    if (USE_MYSQL) {
      const settings = await db.query(
        'SELECT setting_value FROM settings WHERE setting_key = ?',
        ['root_directory']
      );
      if (settings && settings.length > 0 && settings[0].setting_value) {
        return settings[0].setting_value;
      }
    } else {
      const setting = await new Promise((resolve, reject) => {
        db.get(
          'SELECT setting_value FROM settings WHERE setting_key = ?',
          ['root_directory'],
          (err, row) => {
            if (err) {
              reject(err);
            } else {
              resolve(row);
            }
          }
        );
      });
      if (setting && setting.setting_value) {
        return setting.setting_value;
      }
    }
  } catch (error) {
    console.error('Error fetching root directory from settings:', error);
  }
  // Return default if not found
  return networkProjectsPath;
}

// Browse network project directory - ASYNC
router.get('/browse', async (req, res) => {
  const requestPath = req.query.path || '/';

  console.log(`üìÅ Browsing network directory: ${requestPath}`);

  try {
    // Get the current root directory from settings
    const rootDirectory = await getRootDirectory();
    console.log(`üìÇ Using root directory: ${rootDirectory}`);

    let fullPath;
    if (requestPath === '/') {
      fullPath = rootDirectory;
    } else {
      // Remove leading slash and join with network path
      const relativePath = requestPath.startsWith('/') ? requestPath.slice(1) : requestPath;
      fullPath = path.join(rootDirectory, relativePath);
    }
    console.log(`üîç Reading directory: ${fullPath}`);

    // Check if directory exists using async
    const exists = await fs.access(fullPath).then(() => true).catch(() => false);
    if (!exists) {
      console.log('‚ùå Directory not found:', fullPath);
      return res.status(404).json({
        success: false,
        message: 'Directory not found',
        path: requestPath
      });
    }

    // Check if it's actually a directory using async
    const stats = await fs.stat(fullPath);
    if (!stats.isDirectory()) {
      return res.status(400).json({
        success: false,
        message: 'Path is not a directory',
        path: requestPath
      });
    }

    // Read directory contents using async
    const items = await fs.readdir(fullPath);
    const fileSystemItems = [];

    // Add parent directory if not at root
    if (requestPath !== '/') {
      fileSystemItems.push({
        id: 'parent',
        name: '..',
        displayName: '..',
        type: 'folder',
        path: getParentPath(requestPath),
        size: null,
        modified: null,
        isParent: true
      });
    }

    // Process each item in the directory with async operations
    // Use Promise.all to process all items concurrently, which is much faster than sequential sync calls
    const processPromises = items.map(async (item, index) => {
      try {
        const itemPath = path.join(fullPath, item);
        const itemStats = await fs.stat(itemPath);
        const isDirectory = itemStats.isDirectory();

        // Skip hidden files/folders
        if (item.startsWith('.')) {
          return null;
        }

        const truncatedName = truncateName(item);
        const itemRequestPath = requestPath === '/' ? `/${item}` : `${requestPath}/${item}`;
        const fileSystemItem = {
          id: `${isDirectory ? 'folder' : 'file'}-${index}`,
          name: item,
          displayName: truncatedName,
          type: isDirectory ? 'folder' : 'file',
          path: itemRequestPath,
          size: isDirectory ? null : formatFileSize(itemStats.size),
          modified: itemStats.mtime,
          isParent: false
        };

        // Add file type for files
        if (!isDirectory) {
          const extension = path.extname(item).toLowerCase().slice(1);
          fileSystemItem.fileType = extension || 'unknown';
        }

        return fileSystemItem;
      } catch (itemError) {
        console.error(`‚ùå Error processing item ${item}:`, itemError.message);
        // Skip items that can't be processed
        return null;
      }
    });

    const processedItems = (await Promise.all(processPromises)).filter(item => item !== null);
    fileSystemItems.push(...processedItems);

    // Sort items: folders first, then files, alphabetically
    fileSystemItems.sort((a, b) => {
      if (a.isParent) {
        return -1;
      }
      if (b.isParent) {
        return 1;
      }
      if (a.type !== b.type) {
        return a.type === 'folder' ? -1 : 1;
      }
      return a.name.localeCompare(b.name, undefined, { numeric: true, sensitivity: 'base' });
    });

    console.log(`‚úÖ Found ${fileSystemItems.length} items in ${requestPath}`);
    res.json({
      success: true,
      items: fileSystemItems,
      path: requestPath,
      networkPath: fullPath
    });
  } catch (error) {
    console.error('‚ùå Error browsing network directory:', error);
    let errorMessage = 'Failed to browse directory';
    if (error.code === 'ENOENT') {
      errorMessage = 'Network directory not accessible. Please check VPN connection and permissions.';
    } else if (error.code === 'EACCES') {
      errorMessage = 'Access denied. Please check directory permissions.';
    }
    res.status(500).json({
      success: false,
      message: errorMessage,
      path: requestPath,
      error: error.code || error.message
    });
  }
});

// Get network directory info - ASYNC
router.get('/info', async (req, res) => {
  try {
    // Get the current root directory from settings
    const rootDirectory = await getRootDirectory();

    const exists = await fs.access(rootDirectory).then(() => true).catch(() => false);
    if (exists) {
      const stats = await fs.stat(rootDirectory);
      res.json({
        success: true,
        accessible: true,
        path: rootDirectory,
        modified: stats.mtime,
        message: 'Network directory accessible'
      });
    } else {
      res.json({
        success: false,
        accessible: false,
        path: rootDirectory,
        message: 'Network directory not accessible'
      });
    }
  } catch (error) {
    const rootDirectory = await getRootDirectory();
    res.status(500).json({
      success: false,
      accessible: false,
      path: rootDirectory,
      message: 'Error accessing network directory',
      error: error.message
    });
  }
});

// Serve individual file - ASYNC
router.get('/file', async (req, res) => {
  const requestPath = req.query.path;

  if (!requestPath) {
    return res.status(400).json({
      success: false,
      message: 'File path is required'
    });
  }

  console.log(`üìÑ Serving file: ${requestPath}`);

  try {
    // Get the current root directory from settings
    const rootDirectory = await getRootDirectory();
    console.log(`üìÇ Using root directory: ${rootDirectory}`);

    // Remove leading slash and join with network path
    const relativePath = requestPath.startsWith('/') ? requestPath.slice(1) : requestPath;
    const fullPath = path.join(rootDirectory, relativePath);
    console.log(`üîç Full file path: ${fullPath}`);

    // Check if file exists
    const exists = await fs.access(fullPath).then(() => true).catch(() => false);
    if (!exists) {
      console.log('‚ùå File not found:', fullPath);
      return res.status(404).json({
        success: false,
        message: 'File not found',
        path: requestPath
      });
    }

    // Check if it's actually a file
    const stats = await fs.stat(fullPath);
    if (!stats.isFile()) {
      return res.status(400).json({
        success: false,
        message: 'Path is not a file',
        path: requestPath
      });
    }

    // Get file extension and set appropriate content type
    const ext = path.extname(fullPath).toLowerCase();
    const contentTypes = {
      // Documents
      '.pdf': 'application/pdf',
      '.doc': 'application/msword',
      '.docx': 'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
      '.xls': 'application/vnd.ms-excel',
      '.xlsx': 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
      '.ppt': 'application/vnd.ms-powerpoint',
      '.pptx': 'application/vnd.openxmlformats-officedocument.presentationml.presentation',
      '.txt': 'text/plain',
      '.rtf': 'application/rtf',
      '.csv': 'text/csv',

      // Images
      '.jpg': 'image/jpeg',
      '.jpeg': 'image/jpeg',
      '.png': 'image/png',
      '.gif': 'image/gif',
      '.bmp': 'image/bmp',
      '.webp': 'image/webp',
      '.svg': 'image/svg+xml',
      '.ico': 'image/x-icon',

      // Videos
      '.mp4': 'video/mp4',
      '.webm': 'video/webm',
      '.avi': 'video/x-msvideo',
      '.mov': 'video/quicktime',
      '.wmv': 'video/x-ms-wmv',
      '.flv': 'video/x-flv',
      '.mkv': 'video/x-matroska',

      // Audio
      '.mp3': 'audio/mpeg',
      '.wav': 'audio/wav',
      '.ogg': 'audio/ogg',
      '.m4a': 'audio/mp4',
      '.flac': 'audio/flac',

      // Web
      '.html': 'text/html',
      '.htm': 'text/html',
      '.css': 'text/css',
      '.js': 'application/javascript',
      '.json': 'application/json',
      '.xml': 'application/xml',

      // Archives
      '.zip': 'application/zip',
      '.rar': 'application/x-rar-compressed',
      '.7z': 'application/x-7z-compressed',
      '.tar': 'application/x-tar',
      '.gz': 'application/gzip'
    };

    const contentType = contentTypes[ext] || 'application/octet-stream';
    const fileName = path.basename(fullPath);

    // Set headers for inline display (not download)
    res.setHeader('Content-Type', contentType);
    res.setHeader('Content-Disposition', `inline; filename="${encodeURIComponent(fileName)}"`);
    res.setHeader('Content-Length', stats.size);
    res.setHeader('Cache-Control', 'public, max-age=3600'); // Cache for 1 hour
    res.setHeader('X-Content-Type-Options', 'nosniff'); // Security header

    // Stream the file
    const fileStream = (__nccwpck_require__(79896).createReadStream)(fullPath);
    fileStream.pipe(res);

    fileStream.on('error', (error) => {
      console.error('‚ùå Error streaming file:', error);
      if (!res.headersSent) {
        res.status(500).json({
          success: false,
          message: 'Error reading file',
          error: error.message
        });
      }
    });

    console.log(`‚úÖ Serving file: ${fileName}`);
  } catch (error) {
    console.error('‚ùå Error serving file:', error);
    let errorMessage = 'Failed to serve file';
    if (error.code === 'ENOENT') {
      errorMessage = 'File not found';
    } else if (error.code === 'EACCES') {
      errorMessage = 'Access denied. Please check file permissions.';
    }
    res.status(500).json({
      success: false,
      message: errorMessage,
      path: requestPath,
      error: error.code || error.message
    });
  }
});

// Global search - recursively search through directories
router.get('/search', async (req, res) => {
  const searchQuery = req.query.query;
  const searchPath = req.query.path || '/';

  if (!searchQuery) {
    return res.status(400).json({
      success: false,
      message: 'Search query is required'
    });
  }

  console.log(`üîç Global search for: "${searchQuery}" starting from: ${searchPath}`);

  try {
    const rootDirectory = await getRootDirectory();
    const searchRoot = searchPath === '/' ? rootDirectory : path.join(rootDirectory, searchPath.slice(1));

    const results = [];
    const searchLower = searchQuery.toLowerCase();

    // Recursive function to search through directories
    async function searchDirectory(dirPath, relativePath) {
      try {
        const items = await fs.readdir(dirPath);

        for (const item of items) {
          // Skip hidden files/folders
          if (item.startsWith('.')) {
            continue;
          }

          const fullPath = path.join(dirPath, item);
          const itemRelativePath = relativePath === '/' ? `/${item}` : `${relativePath}/${item}`;

          try {
            const stats = await fs.stat(fullPath);
            const isDirectory = stats.isDirectory();

            // Check if item name matches search query
            if (item.toLowerCase().includes(searchLower)) {
              const truncatedName = truncateName(item);
              results.push({
                id: `${isDirectory ? 'folder' : 'file'}-${results.length}`,
                name: item,
                displayName: truncatedName,
                type: isDirectory ? 'folder' : 'file',
                path: itemRelativePath,
                size: isDirectory ? null : formatFileSize(stats.size),
                modified: stats.mtime,
                parentPath: relativePath,
                fileType: isDirectory ? null : path.extname(item).toLowerCase().slice(1) || 'unknown'
              });
            }

            // Recursively search subdirectories (limit depth to prevent infinite loops)
            if (isDirectory && results.length < 500) {
              await searchDirectory(fullPath, itemRelativePath);
            }
          } catch (itemError) {
            // Skip items that can't be accessed
            console.error(`Error accessing ${item}:`, itemError.message);
          }
        }
      } catch (dirError) {
        console.error(`Error reading directory ${dirPath}:`, dirError.message);
      }
    }

    await searchDirectory(searchRoot, searchPath);

    // Sort results: folders first, then files
    results.sort((a, b) => {
      if (a.type !== b.type) {
        return a.type === 'folder' ? -1 : 1;
      }
      return a.name.localeCompare(b.name, undefined, { numeric: true, sensitivity: 'base' });
    });

    console.log(`‚úÖ Found ${results.length} results for "${searchQuery}"`);
    res.json({
      success: true,
      results: results,
      query: searchQuery,
      searchPath: searchPath,
      count: results.length
    });
  } catch (error) {
    console.error('‚ùå Error performing global search:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to perform search',
      error: error.message
    });
  }
});

// Get full system path for a file (for Electron to open)
router.get('/filepath', async (req, res) => {
  const requestPath = req.query.path;

  if (!requestPath) {
    return res.status(400).json({
      success: false,
      message: 'File path is required'
    });
  }

  try {
    const rootDirectory = await getRootDirectory();
    const relativePath = requestPath.startsWith('/') ? requestPath.slice(1) : requestPath;
    const fullPath = path.join(rootDirectory, relativePath);

    // Check if file exists
    const exists = await fs.access(fullPath).then(() => true).catch(() => false);
    if (!exists) {
      return res.status(404).json({
        success: false,
        message: 'File not found'
      });
    }

    // Get file extension
    const ext = path.extname(fullPath).toLowerCase().slice(1);

    res.json({
      success: true,
      fullPath: fullPath,
      fileName: path.basename(fullPath),
      fileType: ext || 'unknown'
    });
  } catch (error) {
    console.error('‚ùå Error getting file path:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to get file path',
      error: error.message
    });
  }
});

module.exports = router;


/***/ }),

/***/ 93925:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

const express = __nccwpck_require__(85152);
const path = __nccwpck_require__(16928);
const fs = __nccwpck_require__(79896);
const { uploadsDir } = __nccwpck_require__(62489);

const router = express.Router();

// View file inline (forces browser to display, not download)
router.get('/view/*', (req, res) => {
  try {
    // Get the file path from the URL
    let filePath = req.params[0]; // Everything after /view/

    // Remove leading /uploads/ or uploads/ prefix if present to avoid double uploads path
    if (filePath.startsWith('/uploads/')) {
      filePath = filePath.substring('/uploads/'.length);
    } else if (filePath.startsWith('uploads/')) {
      filePath = filePath.substring('uploads/'.length);
    }

    const fullPath = path.join(uploadsDir, filePath);

    console.log('üìÇ File view request:', filePath);
    console.log('üìÇ Full path:', fullPath);

    // Check if file exists
    if (!fs.existsSync(fullPath)) {
      console.error('‚ùå File not found:', fullPath);
      return res.status(404).send('File not found');
    }

    // Get file stats
    const stat = fs.statSync(fullPath);

    // Get file extension
    const ext = path.extname(fullPath).toLowerCase();
    const filename = path.basename(fullPath);

    // Set appropriate content type based on file extension
    const contentTypes = {
      '.pdf': 'application/pdf',
      '.jpg': 'image/jpeg',
      '.jpeg': 'image/jpeg',
      '.png': 'image/png',
      '.gif': 'image/gif',
      '.svg': 'image/svg+xml',
      '.webp': 'image/webp',
      '.txt': 'text/plain',
      '.html': 'text/html',
      '.css': 'text/css',
      '.js': 'text/javascript',
      '.json': 'application/json',
      '.xml': 'application/xml',
      '.doc': 'application/msword',
      '.docx': 'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
      '.xls': 'application/vnd.ms-excel',
      '.xlsx': 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
      '.ppt': 'application/vnd.ms-powerpoint',
      '.pptx': 'application/vnd.openxmlformats-officedocument.presentationml.presentation',
      '.zip': 'application/zip',
      '.rar': 'application/x-rar-compressed',
      '.7z': 'application/x-7z-compressed',
      '.mp4': 'video/mp4',
      '.mp3': 'audio/mpeg',
      '.wav': 'audio/wav',
      '.avi': 'video/x-msvideo',
      '.mov': 'video/quicktime'
    };

    const contentType = contentTypes[ext] || 'application/octet-stream';

    // CRITICAL: Force inline display for ALL files
    // Use filename* (RFC 5987) for better compatibility with special characters
    res.setHeader('Content-Type', contentType);
    res.setHeader('Content-Length', stat.size);
    res.setHeader('Content-Disposition', `inline; filename="${filename}"; filename*=UTF-8''${encodeURIComponent(filename)}`);
    res.setHeader('Cache-Control', 'no-cache, no-store, must-revalidate');
    res.setHeader('Pragma', 'no-cache');
    res.setHeader('Expires', '0');
    res.setHeader('X-Content-Type-Options', 'nosniff');

    console.log('‚úÖ File serving as inline:', filePath);
    console.log('‚úÖ Content-Type:', contentType);
    console.log('‚úÖ Content-Disposition: inline');

    // Stream the file with proper error handling
    const readStream = fs.createReadStream(fullPath);

    readStream.on('error', (error) => {
      console.error('‚ùå Stream error:', error);
      if (!res.headersSent) {
        res.status(500).send('Error reading file');
      }
    });

    readStream.pipe(res);

  } catch (error) {
    console.error('‚ùå Error serving file:', error);
    res.status(500).send('Error serving file');
  }
});

// Download file (forces download with original filename)
router.get('/download/*', (req, res) => {
  try {
    let filePath = req.params[0];

    // Remove leading /uploads/ or uploads/ prefix if present to avoid double uploads path
    if (filePath.startsWith('/uploads/')) {
      filePath = filePath.substring('/uploads/'.length);
    } else if (filePath.startsWith('uploads/')) {
      filePath = filePath.substring('uploads/'.length);
    }

    const fullPath = path.join(uploadsDir, filePath);

    console.log('üíæ File download request:', filePath);

    if (!fs.existsSync(fullPath)) {
      console.error('‚ùå File not found:', fullPath);
      return res.status(404).send('File not found');
    }

    const filename = path.basename(fullPath);

    // Force download with original filename using RFC 5987 format
    res.setHeader('Content-Disposition', `attachment; filename="${filename}"; filename*=UTF-8''${encodeURIComponent(filename)}`);
    res.setHeader('Content-Type', 'application/octet-stream');
    res.setHeader('Cache-Control', 'no-cache, no-store, must-revalidate');

    console.log('‚úÖ File download starting:', filename);

    res.download(fullPath, filename, (err) => {
      if (err) {
        console.error('‚ùå Download error:', err);
      } else {
        console.log('‚úÖ File download completed:', filename);
      }
    });

  } catch (error) {
    console.error('‚ùå Error downloading file:', error);
    res.status(500).send('Error downloading file');
  }
});

module.exports = router;


/***/ }),

/***/ 23490:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

const express = __nccwpck_require__(85152);
const fs = (__nccwpck_require__(79896).promises);
const path = __nccwpck_require__(16928);
const { exec } = __nccwpck_require__(35317);
const { db } = __nccwpck_require__(5024);
const { upload, uploadsDir, moveToUserFolder } = __nccwpck_require__(62489);
const { logActivity, logFileStatusChange } = __nccwpck_require__(46534);
const { getFileTypeDescription } = __nccwpck_require__(41987);
const { safeDeleteFile } = __nccwpck_require__(43939);
const { createNotification } = __nccwpck_require__(83565);

const router = express.Router();

// Check for duplicate file names
router.post('/check-duplicate', (req, res) => {
  const { originalName, userId } = req.body;
  console.log(`üîç Checking for duplicate file: ${originalName} by user ${userId}`);

  db.get('SELECT * FROM files WHERE original_name = ? AND user_id = ?', [originalName, userId], (err, existingFile) => {
    if (err) {
      console.error('‚ùå Error checking for duplicate file:', err);
      return res.status(500).json({
        success: false,
        message: 'Failed to check for duplicate files'
      });
    }
    res.json({
      success: true,
      isDuplicate: !!existingFile,
      existingFile: existingFile || null
    });
  });
});

// Upload file (User only)
router.post('/upload', upload.single('file'), async (req, res) => {
  try {
    const { description, userId, username, userTeam, tag, replaceExisting, isRevision } = req.body;
    if (!req.file) {
      return res.status(400).json({
        success: false,
        message: 'No file uploaded'
      });
    }

    // Get the original filename and ensure proper UTF-8 encoding
    let originalFilename = req.file.originalname;

    // Fix common UTF-8 encoding issues (garbled Japanese/Chinese characters)
    try {
      // Check if the filename contains typical garbled UTF-8 patterns
      if (/[√É¬¢√¢¬¨√¢¬¢√É¬§√Ç¬∏√¢‚Äö¬¨√É¬¶√¢‚Ç¨"‚Ä°√É¬®√Ç¬±√Ç¬°]/.test(originalFilename)) {
        // The filename was decoded as latin1/binary instead of utf8
        // Re-encode as binary bytes, then decode as utf8
        const buffer = Buffer.from(originalFilename, 'binary');
        originalFilename = buffer.toString('utf8');
        console.log('üìù Fixed UTF-8 encoding for filename:', originalFilename);
      }
    } catch (e) {
      console.warn('‚ö†Ô∏è Could not decode filename, using original:', originalFilename);
    }

    console.log(`üìÅ File upload by ${username} from ${userTeam} team:`, originalFilename);
    if (isRevision === 'true') {
      console.log('üìù This is a REVISION file (replacing rejected)');
    }

    // Move file from temp location to user folder
    // FIXED: Now async - doesn't block server during large file moves
    console.log(`üì¶ Moving file from temp to user folder...`);
    console.log(`   Temp path: ${req.file.path}`);
    console.log(`   Username: ${username}`);
    console.log(`   Original filename: ${originalFilename}`);
    console.log(`   File mimetype: ${req.file.mimetype}`);
    
    try {
      const finalPath = await moveToUserFolder(req.file.path, username, originalFilename);
      req.file.path = finalPath;
      req.file.filename = originalFilename; // Use decoded original filename
      req.file.originalname = originalFilename; // Update originalname with decoded version
      console.log(`‚úÖ File organized successfully to: ${finalPath}`);
      console.log(`‚úÖ File should now be visible at: ${finalPath}`);
      
      // CRITICAL: Verify file actually exists at final location
      const fs = __nccwpck_require__(79896);
      if (!fs.existsSync(finalPath)) {
        console.error('‚ùå CRITICAL: File was not found at final path after move!');
        console.error(`   Expected at: ${finalPath}`);
        throw new Error('File verification failed - file not found at destination');
      }
      console.log('‚úÖ File existence verified at final path');
      
    } catch (moveError) {
      console.error('‚ùå Error organizing file details:', {
        error: moveError.message,
        tempPath: req.file.path,
        username: username,
        originalFilename: originalFilename,
        stack: moveError.stack
      });
      // Safely delete the temp file if it exists
      await safeDeleteFile(req.file.path);
      return res.status(500).json({
        success: false,
        message: 'Failed to organize uploaded file: ' + moveError.message,
        debug: moveError.message
      });
    }

    // Check for duplicate file if replaceExisting is not explicitly set
    if (replaceExisting !== 'true') {
      db.get('SELECT * FROM files WHERE original_name = ? AND user_id = ?', [req.file.originalname, userId], async (err, existingFile) => {
        if (err) {
          console.error('‚ùå Error checking for duplicate:', err);
          await safeDeleteFile(req.file.path);
          return res.status(500).json({
            success: false,
            message: 'Failed to check for duplicate files'
          });
        }
        if (existingFile) {
          // Delete the newly uploaded file since we found a duplicate
          await safeDeleteFile(req.file.path);
          return res.status(409).json({
            success: false,
            isDuplicate: true,
            message: 'File with this name already exists',
            existingFile: {
              id: existingFile.id,
              original_name: existingFile.original_name,
              uploaded_at: existingFile.uploaded_at,
              status: existingFile.status
            }
          });
        }

        // No duplicate found, proceed with upload
        insertFileRecord();
      });
    } else {
      // Replace existing file - UPDATE the record instead of deleting it
      db.get('SELECT * FROM files WHERE original_name = ? AND user_id = ?', [req.file.originalname, userId], async (err, existingFile) => {
        if (existingFile) {
          console.log('üìù Found existing file, will UPDATE instead of delete+create');
          console.log(`   Old file ID: ${existingFile.id}`);
          console.log(`   Old file path: ${existingFile.file_path}`);
          
          // Delete old physical file only
          const oldRelativePath = existingFile.file_path.startsWith('/uploads/') ? existingFile.file_path.substring(8) : existingFile.file_path;
          const oldFilePath = path.join(uploadsDir, oldRelativePath);
          await safeDeleteFile(oldFilePath);

          // Get the relative path for the new file
          const relativePath = path.relative(uploadsDir, req.file.path).replace(/\\/g, '/');
          const initialStatus = (isRevision === 'true') ? 'under_revision' : 'uploaded';
          
          // UPDATE the existing database record instead of deleting it
          db.run(`UPDATE files SET 
            filename = ?,
            file_path = ?,
            file_size = ?,
            file_type = ?,
            mime_type = ?,
            description = ?,
            tag = ?,
            status = ?,
            current_stage = ?,
            uploaded_at = CURRENT_TIMESTAMP
          WHERE id = ?`,
          [
            req.file.filename,
            `/uploads/${relativePath}`,
            req.file.size,
            getFileTypeDescription(req.file.mimetype, req.file.originalname),
            req.file.mimetype,
            description || '',
            tag || '',
            initialStatus,
            'pending_team_leader',
            existingFile.id  // Keep the same ID!
          ], async function(updateErr) {
            if (updateErr) {
              console.error('‚ùå Error updating file record:', updateErr);
              await safeDeleteFile(req.file.path);
              return res.status(500).json({
                success: false,
                message: 'Failed to update file information'
              });
            }
            
            const fileId = existingFile.id; // Use the same ID

            // Log the file replacement
            const action = isRevision === 'true' ? 'revised' : 'replaced';
            logActivity(db, userId, username, 'USER', userTeam, `File ${action}: ${req.file.originalname}`);

            // Log status history
            logFileStatusChange(
              db,
              fileId,
              existingFile.status,
              initialStatus,
              existingFile.current_stage,
              'pending_team_leader',
              userId,
              username,
              'USER',
              `File ${action} by user${isRevision === 'true' ? ' (revision of rejected file)' : ''}`
            );

            console.log(`‚úÖ File ${action} successfully with ID: ${fileId}${isRevision === 'true' ? ' (marked as REVISED)' : ''}`);
            console.log(`‚úÖ File record UPDATED (not deleted) - will stay in My Files!`);
            res.json({
              success: true,
              message: `File ${action} successfully`,
              file: {
                id: fileId,
                filename: req.file.filename,
                original_name: req.file.originalname,
                file_size: req.file.size,
                file_type: getFileTypeDescription(req.file.mimetype, req.file.originalname),
                description: description || '',
                status: initialStatus,
                current_stage: 'pending_team_leader',
                uploaded_at: new Date()
              },
              replaced: true,
              isRevision: isRevision === 'true'
            });
          });
        } else {
          // No existing file, create new one
          insertFileRecord();
        }
      });
    }

    function insertFileRecord() {
      // Get the relative path from the uploadsDir
      const relativePath = path.relative(uploadsDir, req.file.path).replace(/\\/g, '/');
      
      console.log('üíæ Database storage info:');
      console.log(`   Full path: ${req.file.path}`);
      console.log(`   Relative path: ${relativePath}`);
      console.log(`   Will be stored as: /uploads/${relativePath}`);

      // Determine initial status based on whether this is a revision
      const initialStatus = (isRevision === 'true') ? 'under_revision' : 'uploaded';
      
      // Insert file record into database
      db.run(`INSERT INTO files (
        filename, original_name, file_path, file_size, file_type, mime_type, description, tag,
        user_id, username, user_team, status, current_stage
      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,
      [
        req.file.filename,
        req.file.originalname,
        `/uploads/${relativePath}`,
        req.file.size,
        getFileTypeDescription(req.file.mimetype, req.file.originalname),
        req.file.mimetype,
        description || '',
        tag || '',
        userId,
        username,
        userTeam,
        initialStatus,
        'pending_team_leader'
      ], async function(err) {
        if (err) {
          console.error('‚ùå Error saving file to database:', err);
          // Delete the uploaded file if database save fails
          await safeDeleteFile(req.file.path);
          return res.status(500).json({
            success: false,
            message: 'Failed to save file information'
          });
        }
        const fileId = this.lastID;

        // Log the file upload
        const action = replaceExisting === 'true' ? 'replaced' : (isRevision === 'true' ? 'revised' : 'uploaded');
        logActivity(db, userId, username, 'USER', userTeam, `File ${action}: ${req.file.originalname}`);

        // Log status history
        logFileStatusChange(
          db,
          fileId,
          null,
          initialStatus,
          null,
          'pending_team_leader',
          userId,
          username,
          'USER',
          `File ${action} by user${isRevision === 'true' ? ' (revision of rejected file)' : ''}`
        );

        console.log(`‚úÖ File ${action} successfully with ID: ${fileId}${isRevision === 'true' ? ' (marked as REVISED)' : ''}`);
        res.json({
          success: true,
          message: `File ${action} successfully`,
          file: {
            id: fileId,
            filename: req.file.filename,
            original_name: req.file.originalname,
            file_size: req.file.size,
            file_type: getFileTypeDescription(req.file.mimetype, req.file.originalname),
            description: description || '',
            status: initialStatus,
            current_stage: 'pending_team_leader',
            uploaded_at: new Date()
          },
          replaced: replaceExisting === 'true',
          isRevision: isRevision === 'true'
        });
      });
    }
  } catch (error) {
    console.error('‚ùå Error handling file upload:', error);
    res.status(500).json({
      success: false,
      message: 'File upload failed'
    });
  }
});

// Get files for a specific team member (Team Leader only)
router.get('/member/:memberId', (req, res) => {
  const { memberId } = req.params;
  console.log(`üìÑ Getting files for team member ${memberId}`);

  db.all(
    `SELECT f.*, fc.comment as latest_comment
     FROM files f
     LEFT JOIN file_comments fc ON f.id = fc.file_id AND fc.id = (
       SELECT MAX(id) FROM file_comments WHERE file_id = f.id
     )
     WHERE f.user_id = ?
     ORDER BY f.uploaded_at DESC`,
    [memberId],
    (err, files) => {
      if (err) {
        console.error('‚ùå Error getting member files:', err);
        return res.status(500).json({
          success: false,
          message: 'Failed to fetch member files'
        });
      }
      console.log(`‚úÖ Retrieved ${files.length} files for member ${memberId}`);
      res.json({
        success: true,
        files
      });
    }
  );
});

// Get files for user (User only - their own files) with pagination
router.get('/user/:userId', (req, res) => {
  const { userId } = req.params;
  const page = parseInt(req.query.page) || 1;
  const limit = parseInt(req.query.limit) || 50;
  const offset = (page - 1) * limit;

  console.log(`üìÅ Getting files for user ${userId} - Page ${page}, Limit ${limit}`);

  // Get total count
  db.get('SELECT COUNT(*) as total FROM files WHERE user_id = ?', [userId], (err, countResult) => {
    if (err) {
      console.error('‚ùå Error getting user file count:', err);
      return res.status(500).json({
        success: false,
        message: 'Failed to fetch files'
      });
    }

    db.all(
      `SELECT f.*, fc.comment as latest_comment
       FROM files f
       LEFT JOIN file_comments fc ON f.id = fc.file_id AND fc.id = (
         SELECT MAX(id) FROM file_comments WHERE file_id = f.id
       )
       WHERE f.user_id = ?
       ORDER BY f.uploaded_at DESC LIMIT ? OFFSET ?`,
      [userId, limit, offset],
      (err, files) => {
        if (err) {
          console.error('‚ùå Error getting user files:', err);
          return res.status(500).json({
            success: false,
            message: 'Failed to fetch files'
          });
        }
        console.log(`‚úÖ Retrieved ${files.length} files for user ${userId}`);
        res.json({
          success: true,
          files,
          pagination: {
            page,
            limit,
            total: countResult.total,
            pages: Math.ceil(countResult.total / limit)
          }
        });
      }
    );
  });
});

// Get pending files for user (files that are not final_approved) with pagination
router.get('/user/:userId/pending', (req, res) => {
  const { userId } = req.params;
  const page = parseInt(req.query.page) || 1;
  const limit = parseInt(req.query.limit) || 50;
  const offset = (page - 1) * limit;

  console.log(`üìÅ Getting pending files for user ${userId} - Page ${page}, Limit ${limit}`);

  // Get total count
  db.get('SELECT COUNT(*) as total FROM files WHERE user_id = ? AND status != ?', [userId, 'final_approved'], (err, countResult) => {
    if (err) {
      console.error('‚ùå Error getting user pending file count:', err);
      return res.status(500).json({
        success: false,
        message: 'Failed to fetch pending files'
      });
    }

    db.all(
      `SELECT f.*,
              GROUP_CONCAT(fc.comment, ' | ') as comments
       FROM files f
       LEFT JOIN file_comments fc ON f.id = fc.file_id
       WHERE f.user_id = ? AND f.status != 'final_approved'
       GROUP BY f.id
       ORDER BY f.uploaded_at DESC LIMIT ? OFFSET ?`,
      [userId, limit, offset],
      (err, files) => {
        if (err) {
          console.error('‚ùå Error getting user pending files:', err);
          return res.status(500).json({
            success: false,
            message: 'Failed to fetch pending files'
          });
        }

        // Process the files to include comments as an array
        const processedFiles = files.map(file => {
          const comments = file.comments ?
            file.comments.split(' | ').map(comment => ({ comment })) : [];
          return {
            ...file,
            comments
          };
        });

        console.log(`‚úÖ Retrieved ${processedFiles.length} pending files for user ${userId}`);
        res.json({
          success: true,
          files: processedFiles,
          pagination: {
            page,
            limit,
            total: countResult.total,
            pages: Math.ceil(countResult.total / limit)
          }
        });
      }
    );
  });
});

// Get files for team leader review (Team Leader only) with pagination
router.get('/team-leader/:team', (req, res) => {
  const { team } = req.params;
  const page = parseInt(req.query.page) || 1;
  const limit = parseInt(req.query.limit) || 50;
  const offset = (page - 1) * limit;

  console.log(`üìÅ Getting files for team leader review: ${team} team - Page ${page}, Limit ${limit}`);

  // Get total count
  db.get('SELECT COUNT(*) as total FROM files WHERE user_team = ? AND current_stage = ?', [team, 'pending_team_leader'], (err, countResult) => {
    if (err) {
      console.error('‚ùå Error getting team leader file count:', err);
      return res.status(500).json({
        success: false,
        message: 'Failed to fetch files for review'
      });
    }

    db.all(
      `SELECT f.*, fc.comment as latest_comment
       FROM files f
       LEFT JOIN file_comments fc ON f.id = fc.file_id AND fc.id = (
         SELECT MAX(id) FROM file_comments WHERE file_id = f.id
       )
       WHERE f.user_team = ? AND f.current_stage = 'pending_team_leader'
       ORDER BY f.uploaded_at DESC LIMIT ? OFFSET ?`,
      [team, limit, offset],
      (err, files) => {
        if (err) {
          console.error('‚ùå Error getting team leader files:', err);
          return res.status(500).json({
            success: false,
            message: 'Failed to fetch files for review'
          });
        }
        console.log(`‚úÖ Retrieved ${files.length} files for ${team} team leader review`);
        res.json({
          success: true,
          files,
          pagination: {
            page,
            limit,
            total: countResult.total,
            pages: Math.ceil(countResult.total / limit)
          }
        });
      }
    );
  });
});

// Get files for admin review (Admin only) with pagination
router.get('/admin', (req, res) => {
  const page = parseInt(req.query.page) || 1;
  const limit = parseInt(req.query.limit) || 50;
  const offset = (page - 1) * limit;

  console.log(`üìÅ Getting files for admin review - Page ${page}, Limit ${limit}`);

  // Get total count
  db.get('SELECT COUNT(*) as total FROM files WHERE current_stage = ?', ['pending_admin'], (err, countResult) => {
    if (err) {
      console.error('‚ùå Error getting admin file count:', err);
      return res.status(500).json({
        success: false,
        message: 'Failed to fetch files for admin review'
      });
    }

    db.all(
      `SELECT f.*, fc.comment as latest_comment
       FROM files f
       LEFT JOIN file_comments fc ON f.id = fc.file_id AND fc.id = (
         SELECT MAX(id) FROM file_comments WHERE file_id = f.id
       )
       WHERE f.current_stage = 'pending_admin'
       ORDER BY f.uploaded_at DESC LIMIT ? OFFSET ?`,
      [limit, offset],
      (err, files) => {
        if (err) {
          console.error('‚ùå Error getting admin files:', err);
          return res.status(500).json({
            success: false,
            message: 'Failed to fetch files for admin review'
          });
        }
        console.log(`‚úÖ Retrieved ${files.length} files for admin review`);
        res.json({
          success: true,
          files,
          pagination: {
            page,
            limit,
            total: countResult.total,
            pages: Math.ceil(countResult.total / limit)
          }
        });
      }
    );
  });
});

// Get all files (Admin only - for comprehensive view) with pagination
router.get('/all', (req, res) => {
  const page = parseInt(req.query.page) || 1;
  const limit = parseInt(req.query.limit) || 50;
  const offset = (page - 1) * limit;

  console.log(`üìÅ Getting all files (admin view) - Page ${page}, Limit ${limit}`);

  // Get total count
  db.get('SELECT COUNT(*) as total FROM files', [], (err, countResult) => {
    if (err) {
      console.error('‚ùå Error getting all file count:', err);
      return res.status(500).json({
        success: false,
        message: 'Failed to fetch all files'
      });
    }

    db.all(
      `SELECT f.*, fc.comment as latest_comment
       FROM files f
       LEFT JOIN file_comments fc ON f.id = fc.file_id AND fc.id = (
         SELECT MAX(id) FROM file_comments WHERE file_id = f.id
       )
       ORDER BY f.uploaded_at DESC LIMIT ? OFFSET ?`,
      [limit, offset],
      (err, files) => {
        if (err) {
          console.error('‚ùå Error getting all files:', err);
          return res.status(500).json({
            success: false,
            message: 'Failed to fetch all files'
          });
        }
        console.log(`‚úÖ Retrieved ${files.length} files (all files view)`);
        res.json({
          success: true,
          files,
          pagination: {
            page,
            limit,
            total: countResult.total,
            pages: Math.ceil(countResult.total / limit)
          }
        });
      }
    );
  });
});

// Team leader approve/reject file
router.post('/:fileId/team-leader-review', (req, res) => {
  const { fileId } = req.params;
  const { action, comments, teamLeaderId, teamLeaderUsername, teamLeaderRole, team } = req.body;
  console.log(`üìã Team leader ${action} for file ${fileId} by ${teamLeaderUsername}`);

  if (!['approve', 'reject'].includes(action)) {
    return res.status(400).json({
      success: false,
      message: 'Invalid action. Must be approve or reject'
    });
  }

  // Get current file status
  db.get('SELECT * FROM files WHERE id = ?', [fileId], (err, file) => {
    if (err) {
      console.error('‚ùå Error getting file:', err);
      return res.status(500).json({
        success: false,
        message: 'Failed to fetch file'
      });
    }

    if (!file) {
      return res.status(404).json({
        success: false,
        message: 'File not found'
      });
    }

    if (file.current_stage !== 'pending_team_leader') {
      return res.status(400).json({
        success: false,
        message: 'File is not in pending team leader review stage'
      });
    }

    // Use MySQL-friendly DATETIME format: YYYY-MM-DD HH:MM:SS
    const now = new Date();
    const nowSql = now.toISOString().slice(0,19).replace('T', ' ');
    let newStatus, newStage;
    if (action === 'approve') {
      newStatus = 'team_leader_approved';
      newStage = 'pending_admin';
    } else {
      newStatus = 'rejected_by_team_leader';
      newStage = 'rejected_by_team_leader';
    }

    // Update file status - build SQL and params so we can log them for debugging
    const tlSql = `UPDATE files SET
      status = ?,
      current_stage = ?,
      team_leader_id = ?,
      team_leader_username = ?,
      team_leader_reviewed_at = ?,
      team_leader_comments = ?${action === 'reject' ? ', rejection_reason = ?, rejected_by = ?, rejected_at = ?' : ''}
    WHERE id = ?`;

    const tlParams = action === 'reject' ? [
      newStatus, newStage, teamLeaderId, teamLeaderUsername, nowSql, comments,
      comments, teamLeaderUsername, nowSql, fileId
    ] : [
      newStatus, newStage, teamLeaderId, teamLeaderUsername, nowSql, comments, fileId
    ];

    console.log('DEBUG: Executing SQL (team-leader):', tlSql.replace(/\s+/g,' '));
    console.log('DEBUG: Params (team-leader):', tlParams);

    db.run(tlSql, tlParams, function(err) {
      if (err) {
        console.error('‚ùå Error updating file status:', err);
        // Return DB error message to client in dev for easier debugging
        return res.status(500).json({
          success: false,
          message: 'Failed to update file status',
          error: err.message
        });
      }

      // Add comment if provided AND create notification for it
      if (comments) {
        const commentType = action === 'approve' ? 'approval' : 'rejection';
        db.run(
          'INSERT INTO file_comments (file_id, user_id, username, user_role, comment, comment_type) VALUES (?, ?, ?, ?, ?, ?)',
          [fileId, teamLeaderId, teamLeaderUsername, teamLeaderRole, comments, commentType],
          (err) => {
            if (err) {
              console.error('‚ùå Error adding team leader comment:', err);
              console.error('Comment details:', { fileId, teamLeaderId, teamLeaderUsername, teamLeaderRole, comments, commentType });
            } else {
              console.log('‚úÖ Team leader comment added successfully');

              // Create a separate notification for the comment itself
              const commentNotifTitle = `Team Leader ${action === 'approve' ? 'Approved' : 'Rejected'} with Comments`;
              const commentNotifMessage = `${teamLeaderUsername} left ${commentType} comments on your file: "${comments.substring(0, 150)}${comments.length > 150 ? '...' : ''}"`.replace(/\\"/g, '"');

              createNotification(
                file.user_id,
                fileId,
                'comment',
                commentNotifTitle,
                commentNotifMessage,
                teamLeaderId,
                teamLeaderUsername,
                teamLeaderRole
              ).catch(err => {
                console.error('‚ùå Failed to create comment notification:', err);
              });
            }
          }
        );
      }

      // Log activity
      logActivity(
        db,
        teamLeaderId,
        teamLeaderUsername,
        teamLeaderRole,
        team,
        `File ${action}d: ${file.filename} (Team Leader Review)`
      );

      // Log status history
      logFileStatusChange(
        db,
        fileId,
        file.status,
        newStatus,
        file.current_stage,
        newStage,
        teamLeaderId,
        teamLeaderUsername,
        teamLeaderRole,
        `Team leader ${action}: ${comments || 'No comments'}`
      );

      // Create notification for the file owner
      const notificationType = action === 'approve' ? 'approval' : 'rejection';
      const notificationTitle = action === 'approve'
        ? 'File Approved by Team Leader'
        : 'File Rejected by Team Leader';
      const notificationMessage = action === 'approve'
        ? `Your file "${file.original_name}" has been approved by ${teamLeaderUsername} and is now pending admin review.`
        : `Your file "${file.original_name}" has been rejected by ${teamLeaderUsername}. ${comments ? 'Reason: ' + comments : 'Please review and resubmit.'}`;

      createNotification(
        file.user_id,
        fileId,
        notificationType,
        notificationTitle,
        notificationMessage,
        teamLeaderId,
        teamLeaderUsername,
        teamLeaderRole
      ).catch(err => {
        console.error('Failed to create notification:', err);
      });

      console.log(`‚úÖ File ${action}d by team leader: ${file.filename}`);
      res.json({
        success: true,
        message: `File ${action}d successfully`,
        file: {
          ...file,
          status: newStatus,
          current_stage: newStage,
          team_leader_reviewed_at: nowSql,
          team_leader_comments: comments
        }
      });
    });
  });
});

// Move approved file to network projects path
router.post('/:fileId/move-to-projects', async (req, res) => {
  const { fileId } = req.params;
  const { destinationPath, adminId, adminUsername, adminRole, team, deleteFromUploads } = req.body;
  console.log(`üì¶ Moving file ${fileId} to destination: ${destinationPath}`);

  try {
    // Get file info
    const file = await new Promise((resolve, reject) => {
      db.get('SELECT * FROM files WHERE id = ?', [fileId], (err, row) => {
        if (err) {
          reject(err);
        } else {
          resolve(row);
        }
      });
    });

    if (!file) {
      return res.status(404).json({
        success: false,
        message: 'File not found'
      });
    }

    // Get source file path
    const relativePath = file.file_path.startsWith('/uploads/') ? file.file_path.substring(8) : file.file_path;
    const sourcePath = path.join(uploadsDir, relativePath);

    // Check if source file exists
    const sourceExists = await fs.access(sourcePath).then(() => true).catch(() => false);
    if (!sourceExists) {
      console.error('‚ùå Source file not found:', sourcePath);
      return res.status(404).json({
        success: false,
        message: 'Source file not found'
      });
    }

    // destinationPath now comes as full Windows path from file picker
    // e.g., "C:\\Users\\...\\PROJECTS\\Engineering\\2025"
    // or "\\\\KMTI-NAS\\Shared\\Public\\PROJECTS\\Engineering\\2025"
    const fullDestinationPath = destinationPath;

    console.log('üìÇ Destination path:', fullDestinationPath);

    // Ensure destination directory exists
    await fs.mkdir(fullDestinationPath, { recursive: true });

    // Construct destination file path with original name
    const destinationFilePath = path.join(fullDestinationPath, file.original_name);

    // Check if destination file already exists
    const destExists = await fs.access(destinationFilePath).then(() => true).catch(() => false);
    if (destExists) {
      return res.status(409).json({
        success: false,
        message: 'File already exists in destination',
        existingPath: destinationFilePath
      });
    }

    // Copy file to destination
    await fs.copyFile(sourcePath, destinationFilePath);
    console.log('‚úÖ File copied to:', destinationFilePath);

    // Delete file from uploads folder if requested
    if (deleteFromUploads) {
      const deleteResult = await safeDeleteFile(sourcePath);
      if (deleteResult.success) {
        console.log('‚úÖ File deleted from uploads folder:', sourcePath);
      } else {
        console.warn('‚ö†Ô∏è Could not delete file from uploads folder:', deleteResult.message);
      }
    }

    // Update database with new path
    await new Promise((resolve, reject) => {
      db.run(
        'UPDATE files SET public_network_url = ? WHERE id = ?',
        [destinationFilePath, fileId],
        (err) => {
          if (err) {
            reject(err);
          } else {
            resolve();
          }
        }
      );
    });

    // Log activity
    logActivity(
      db,
      adminId,
      adminUsername,
      adminRole,
      team,
      `File moved to projects: ${file.original_name} -> ${fullDestinationPath}${deleteFromUploads ? ' (deleted from uploads)' : ''}`
    );

    console.log(`‚úÖ File moved successfully: ${file.original_name}`);
    res.json({
      success: true,
      message: 'File moved to projects directory successfully',
      destinationPath: destinationFilePath
    });
  } catch (error) {
    console.error('‚ùå Error moving file to projects:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to move file to projects directory',
      error: error.message
    });
  }
});

// Admin approve/reject file (Final approval)
router.post('/:fileId/admin-review', async (req, res) => {
  const { fileId } = req.params;
  const { action, comments, adminId, adminUsername, adminRole, team } = req.body;
  console.log(`üìã Admin ${action} for file ${fileId} by ${adminUsername}`);

  if (!['approve', 'reject'].includes(action)) {
    return res.status(400).json({
      success: false,
      message: 'Invalid action. Must be approve or reject'
    });
  }

  // Get current file status
  db.get('SELECT * FROM files WHERE id = ?', [fileId], (err, file) => {
    if (err || !file) {
      return res.status(404).json({
        success: false,
        message: 'File not found'
      });
    }
    // Admin can approve files in both 'uploaded' (Pending Team Leader) and 'team_leader_approved' (Pending Admin) status
    const canApprove = file.status === 'uploaded' || file.status === 'team_leader_approved';
    if (!canApprove && action === 'approve') {
      return res.status(400).json({
        success: false,
        message: 'File is not in a state that can be approved by admin'
      });
    }
    console.log(`Current stage: ${file.current_stage}, Status: ${file.status}, Can approve: ${canApprove}`);

    // Use MySQL-friendly DATETIME format
    const now = new Date();
    const nowSql = now.toISOString().slice(0,19).replace('T', ' ');
    let newStatus, newStage, publicNetworkUrl = null;
    if (action === 'approve') {
      newStatus = 'final_approved';
      newStage = 'published_to_public';
      // Only set public network URL if not already set by move-to-projects
      // (e.g., if files were approved without moving, but in practice they are moved first)
      publicNetworkUrl = file.public_network_url || `https://public-network.example.com/files/${file.filename}`;
    } else {
      newStatus = 'rejected_by_admin';
      newStage = 'rejected_by_admin';
    }

    // Update file status - build SQL and params so we can log them for debugging
    const adminSql = `UPDATE files SET
      status = ?,
      current_stage = ?,
      admin_id = ?,
      admin_username = ?,
      admin_reviewed_at = ?,
      admin_comments = ?${action === 'approve' ? ', final_approved_at = ?' : ''}${action === 'reject' ? ', rejection_reason = ?, rejected_by = ?, rejected_at = ?' : ''}
    WHERE id = ?`;

    const adminParams = action === 'approve' ? [
      newStatus, newStage, adminId, adminUsername, nowSql, comments,
      nowSql, fileId
    ] : action === 'reject' ? [
      newStatus, newStage, adminId, adminUsername, nowSql, comments,
      comments, adminUsername, nowSql, fileId
    ] : [
      newStatus, newStage, adminId, adminUsername, nowSql, comments, fileId
    ];

    console.log('DEBUG: Executing SQL (admin):', adminSql.replace(/\s+/g,' '));
    console.log('DEBUG: Params (admin):', adminParams);

    db.run(adminSql, adminParams, function(err) {
      if (err) {
        console.error('‚ùå Error updating file status (admin):', err);
        return res.status(500).json({
          success: false,
          message: 'Failed to update file status',
          error: err.message
        });
      }

      console.log(`‚úÖ Database updated successfully. Rows affected: ${this.changes}`);

      // Add comment if provided
      if (comments) {
        const commentType = action === 'approve' ? 'approval' : 'rejection';
        db.run(
          'INSERT INTO file_comments (file_id, user_id, username, user_role, comment, comment_type) VALUES (?, ?, ?, ?, ?, ?)',
          [fileId, adminId, adminUsername, adminRole, comments, commentType],
          (err) => {
            if (err) {
              console.error('‚ùå Error adding admin comment:', err);
              console.error('Comment details:', { fileId, adminId, adminUsername, adminRole, comments, commentType });
            } else {
              console.log('‚úÖ Admin comment added successfully');

              // Create a separate notification for the admin comment
              const commentNotifTitle = `Admin ${action === 'approve' ? 'Approved' : 'Rejected'} with Comments`;
              const commentNotifMessage = `${adminUsername} (Admin) left ${commentType} comments on your file: "${comments.substring(0, 150)}${comments.length > 150 ? '...' : ''}"`;

              createNotification(
                file.user_id,
                fileId,
                'comment',
                commentNotifTitle,
                commentNotifMessage,
                adminId,
                adminUsername,
                adminRole
              ).catch(err => {
                console.error('‚ùå Failed to create admin comment notification:', err);
              });
            }
          }
        );
      }

      // Log activity
      logActivity(
        db,
        adminId,
        adminUsername,
        adminRole,
        team,
        `File ${action}d: ${file.filename} (Admin Final Review)${action === 'approve' ? ' - Published to Public Network' : ''}`
      );

      // Log status history
      logFileStatusChange(
        db,
        fileId,
        file.status,
        newStatus,
        file.current_stage,
        newStage,
        adminId,
        adminUsername,
        adminRole,
        `Admin ${action}: ${comments || 'No comments'}${action === 'approve' ? ' - Published to Public Network' : ''}`
      );

      // Create notification for the file owner
      const notificationType = action === 'approve' ? 'final_approval' : 'final_rejection';
      const notificationTitle = action === 'approve'
        ? 'File Final Approved'
        : 'File Rejected by Admin';
      const notificationMessage = action === 'approve'
        ? `Your file "${file.original_name}" has been final approved by ${adminUsername} and published to the public network!`
        : `Your file "${file.original_name}" has been rejected by ${adminUsername}. ${comments ? 'Reason: ' + comments : 'Please review and resubmit.'}`;

      createNotification(
        file.user_id,
        fileId,
        notificationType,
        notificationTitle,
        notificationMessage,
        adminId,
        adminUsername,
        adminRole
      ).catch(err => {
        console.error('Failed to create notification:', err);
      });

      // Create notification for team leader about admin action
      function sendTeamLeaderNotification(teamLeaderId) {
        if (teamLeaderId && teamLeaderId !== adminId) {
          const tlNotificationTitle = action === 'approve'
            ? 'File Approved by Admin'
            : 'File Rejected by Admin';
          const tlNotificationMessage = action === 'approve'
            ? `Admin ${adminUsername} has approved file "${file.original_name}" submitted by ${file.username}`
            : `Admin ${adminUsername} has rejected file "${file.original_name}" submitted by ${file.username}. ${comments ? 'Reason: ' + comments : ''}`;

          createNotification(
            teamLeaderId,
            fileId,
            notificationType,
            tlNotificationTitle,
            tlNotificationMessage,
            adminId,
            adminUsername,
            adminRole
          ).catch(err => {
            console.error('Failed to create team leader notification:', err);
          });
          console.log(`üìß Created admin ${action} notification for team leader ID: ${teamLeaderId}`);
        }
      }

      let teamLeaderId = file.team_leader_id;

      // If team_leader_id is not set, try to get it from assignment submissions or team
      if (!teamLeaderId) {
        // Check if file is from an assignment submission
        db.get(
          `SELECT a.team_leader_id FROM assignment_submissions asub
           JOIN assignments a ON asub.assignment_id = a.id
           WHERE asub.file_id = ? LIMIT 1`,
          [fileId],
          (err, assignmentSubmission) => {
            if (!err && assignmentSubmission && assignmentSubmission.team_leader_id) {
              teamLeaderId = assignmentSubmission.team_leader_id;
              sendTeamLeaderNotification(teamLeaderId);
            } else {
              // Get team leader from user's team
              db.get(
                'SELECT id FROM users WHERE team = ? AND role = ? LIMIT 1',
                [file.user_team, 'TEAM_LEADER'],
                (err, teamLeader) => {
                  if (!err && teamLeader) {
                    teamLeaderId = teamLeader.id;
                  }
                  sendTeamLeaderNotification(teamLeaderId);
                }
              );
            }
          }
        );
      } else {
        sendTeamLeaderNotification(teamLeaderId);
      }

      console.log(`‚úÖ File ${action}d by admin: ${file.filename}${action === 'approve' ? ' - Published to Public Network' : ''}`);
      res.json({
        success: true,
        message: `File ${action}d successfully${action === 'approve' ? ' and published to Public Network' : ''}`,
        file: {
          ...file,
          status: newStatus,
          current_stage: newStage,
          admin_reviewed_at: now,
          admin_comments: comments,
          ...(action === 'approve' && { public_network_url: publicNetworkUrl, final_approved_at: now })
        }
      });
    });
  });
});

// Get single file details
router.get('/:fileId', (req, res) => {
  const { fileId } = req.params;

  db.get('SELECT * FROM files WHERE id = ?', [fileId], (err, file) => {
    if (err) {
      console.error('‚ùå Error getting file:', err);
      return res.status(500).json({
        success: false,
        message: 'Failed to fetch file'
      });
    }
    if (!file) {
      return res.status(404).json({
        success: false,
        message: 'File not found'
      });
    }

    res.json({
      success: true,
      file
    });
  });
});

// Get file system path for Electron to open with default app
router.get('/:fileId/path', (req, res) => {
  const { fileId } = req.params;

  db.get('SELECT * FROM files WHERE id = ?', [fileId], (err, file) => {
    if (err || !file) {
      return res.status(404).json({
        success: false,
        message: 'File not found'
      });
    }

    // For approved files that have been moved to projects, use the public_network_url
    // For pending/rejected files, use the original file_path
    let filePath;
    if (file.status === 'final_approved' && file.public_network_url) {
      // File has been moved to projects directory
      filePath = file.public_network_url;
      console.log(`üìÇ Using moved file path for approved file ${fileId}: ${filePath}`);
    } else {
      // File is still in uploads directory
      if (file.file_path.startsWith('/uploads/')) {
        const relativePath = file.file_path.substring('/uploads/'.length);
        filePath = path.join(uploadsDir, relativePath);
      } else {
        filePath = path.join(uploadsDir, path.basename(file.file_path));
      }
      console.log(`üìÇ Using uploads file path for ${fileId}: ${filePath}`);
    }

    // Normalize path for Windows
    filePath = path.normalize(filePath);

    res.json({
      success: true,
      filePath: filePath
    });
  });
});

// Get file comments
router.get('/:fileId/comments', (req, res) => {
  const { fileId } = req.params;
  db.all(
    'SELECT * FROM file_comments WHERE file_id = ? ORDER BY created_at DESC',
    [fileId],
    (err, comments) => {
      if (err) {
        console.error('‚ùå Error getting file comments:', err);
        return res.status(500).json({
          success: false,
          message: 'Failed to fetch comments'
        });
      }
      res.json({
        success: true,
        comments
      });
    }
  );
});

// Add comment to file
router.post('/:fileId/comments', (req, res) => {
  const { fileId } = req.params;
  const { comment, userId, username, userRole } = req.body;
  if (!comment || !comment.trim()) {
    return res.status(400).json({
      success: false,
      message: 'Comment cannot be empty'
    });
  }

  // Get file info to send notification to owner
  db.get('SELECT * FROM files WHERE id = ?', [fileId], (err, file) => {
    if (err || !file) {
      return res.status(404).json({
        success: false,
        message: 'File not found'
      });
    }

    db.run(
      'INSERT INTO file_comments (file_id, user_id, username, user_role, comment) VALUES (?, ?, ?, ?, ?)',
      [fileId, userId, username, userRole, comment.trim()],
      function(err) {
        if (err) {
          console.error('‚ùå Error adding comment:', err);
          return res.status(500).json({
            success: false,
            message: 'Failed to add comment'
          });
        }

        // Create notification for the file owner (if comment is not by the owner)
        if (userId !== file.user_id) {
          const notificationTitle = 'New Comment on Your File';
          const notificationMessage = `${username} commented on your file "${file.original_name}": ${comment.trim().substring(0, 100)}${comment.trim().length > 100 ? '...' : ''}`;

          createNotification(
            file.user_id,
            fileId,
            'comment',
            notificationTitle,
            notificationMessage,
            userId,
            username,
            userRole
          ).catch(err => {
            console.error('Failed to create notification for comment:', err);
          });
        }

        res.json({
          success: true,
          message: 'Comment added successfully',
          comment: {
            id: this.lastID,
            file_id: fileId,
            user_id: userId,
            username: username,
            user_role: userRole,
            comment: comment.trim(),
            created_at: new Date()
          }
        });
      }
    );
  });
});

// Get file status history
router.get('/:fileId/history', (req, res) => {
  const { fileId } = req.params;
  db.all(
    'SELECT * FROM file_status_history WHERE file_id = ? ORDER BY created_at DESC',
    [fileId],
    (err, history) => {
      if (err) {
        console.error('‚ùå Error getting file history:', err);
        return res.status(500).json({
          success: false,
          message: 'Failed to fetch file history'
        });
      }
      res.json({
        success: true,
        history
      });
    }
  );
});

// Delete file (Admin only)
router.delete('/:fileId', async (req, res) => {
  const { fileId } = req.params;
  const { adminId, adminUsername, adminRole, team } = req.body;
  console.log(`üóëÔ∏è Deleting file ${fileId} by admin ${adminUsername}`);

  try {
    // Get file info first
    const file = await new Promise((resolve, reject) => {
      db.get('SELECT * FROM files WHERE id = ?', [fileId], (err, row) => {
        if (err) {
          reject(err);
        } else {
          resolve(row);
        }
      });
    });

    if (!file) {
      return res.status(404).json({
        success: false,
        message: 'File not found'
      });
    }

    // IMPORTANT: Clear assignment submissions that reference this file
    // This allows users to resubmit the task
    try {
      await new Promise((resolve, reject) => {
        db.run(
          'UPDATE assignment_members SET file_id = NULL, status = NULL, submitted_at = NULL WHERE file_id = ?',
          [fileId],
          function(err) {
            if (err) {
              console.error('‚ùå Error clearing assignment submissions:', err);
              reject(err);
            } else {
              if (this.changes > 0) {
                console.log(`‚úÖ Cleared ${this.changes} assignment submission(s) for file ${fileId}`);
                console.log('   User can now resubmit the assignment');
              }
              resolve();
            }
          }
        );
      });
    } catch (clearError) {
      console.error('‚ö†Ô∏è CRITICAL: Failed to clear assignment submissions:', clearError.message);
      // This is critical - return error instead of continuing
      return res.status(500).json({
        success: false,
        message: 'Failed to clear assignment references. File cannot be deleted.',
        error: clearError.message
      });
    }

    // Delete file from filesystem
    // First, properly resolve the file path using stored information
    let filePath;

    if (file.file_path) {
      // For paths stored in database, we need to handle user subdirectories
      if (file.file_path.startsWith('/uploads/')) {
        // Check if the path already includes the username directory
        const relativePath = file.file_path.substring('/uploads/'.length);

        if (relativePath.includes('/')) {
          // Already has subdirectory - use as is
          filePath = path.join(uploadsDir, relativePath);
        } else {
          // Try to find in user's directory
          filePath = path.join(uploadsDir, file.username, path.basename(file.file_path));

          // If not found in user directory, fallback to direct location
          try {
            await fs.access(filePath);
          } catch (e) {
            filePath = path.join(uploadsDir, path.basename(file.file_path));
          }
        }
      } else {
        // Direct path or already absolute
        filePath = await resolveFilePath(file.file_path, file.username);
      }
    } else {
      // Fallback to basic resolution
      filePath = path.join(uploadsDir, path.basename(file.file_path || ''));
    }

    console.log(`üóëÔ∏è Attempting to delete file at: ${filePath}`);
    const deleteResult = await safeDeleteFile(filePath);

    if (!deleteResult.success && !deleteResult.notFound) {
      console.warn(`‚ö†Ô∏è Physical file deletion issue: ${deleteResult.message}`);
    }

    // Delete file record from database
    await new Promise((resolve, reject) => {
      db.run('DELETE FROM files WHERE id = ?', [fileId], function(err) {
        if (err) {
          reject(err);
        } else {
          resolve();
        }
      });
    });

    // Log activity
    logActivity(
      db,
      adminId,
      adminUsername,
      adminRole,
      team,
      `File deleted: ${file.filename} (Admin Action) - Assignment submissions cleared`
    );

    console.log(`‚úÖ File deleted: ${file.filename}`);
    res.json({
      success: true,
      message: 'File deleted successfully. Assignment submissions have been cleared and can be resubmitted.'
    });
  } catch (error) {
    console.error('‚ùå Error deleting file:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to delete file',
      error: error.message
    });
  }
});

// Helper: convert stored file_path to a filesystem path the server can unlink
async function resolveFilePath(storedPath, username = null) {
  if (!storedPath) {
    return null;
  }

  // If UNC path (\\server\share...) or absolute Windows (C:\...) or POSIX absolute (/..), return as-is
  if (/^\\\\/.test(storedPath) || path.isAbsolute(storedPath)) {
    return storedPath;
  }

  // Handle paths stored as relative URLs with /uploads/ prefix
  if (storedPath.startsWith('/uploads/')) {
    const relativePath = storedPath.substring('/uploads/'.length);

    // Check if this is a username path format like 'username/filename.ext'
    if (relativePath.includes('/')) {
      // This is likely a username/filename path
      return path.join(uploadsDir, relativePath);
    }
    // If username is provided, check if the file exists in that user's directory
    else if (username) {
      // Try the username directory first
      const userPath = path.join(uploadsDir, username, path.basename(storedPath));
      try {
        await fs.access(userPath);
        return userPath;
      } catch (e) {
        // File not found in user directory
      }
    }

    // Default to direct file in uploads dir
    return path.join(uploadsDir, relativePath);
  }

  // For paths without /uploads/ prefix, try various locations
  // First check if it exists directly in uploads folder
  const directPath = path.join(uploadsDir, path.basename(storedPath));

  // If username is provided, also check in user's folder
  if (username) {
    const userPath = path.join(uploadsDir, username, path.basename(storedPath));
    try {
      await fs.access(userPath);
      return userPath;
    } catch (e) {
      // File not found in user directory
    }
  }

  // Final fallback - direct join with uploads dir
  return directPath;
}

// POST /api/files/:id/delete-file
// Attempt to delete the physical file from disk/network.
// For approved files that have been moved, delete from the public_network_url location
// For pending/rejected files, delete from uploads
// Body optionally contains admin info for audit (adminId, adminUsername, ...)
router.post('/:id/delete-file', async (req, res) => {
  const id = req.params.id;
  try {
    // Use callback-based db.get to match existing pattern
    db.get('SELECT * FROM files WHERE id = ?', [id], async (err, file) => {
      if (err || !file) {
        return res.status(404).json({ success: false, message: 'File record not found' });
      }

      let resolved;

      // Check if file has been moved to projects (approved files)
      if (file.public_network_url) {
        resolved = file.public_network_url;
        console.log(`üóëÔ∏è File has been moved to projects, deleting from: ${resolved}`);
      }
      // For non-approved files or old records, try to resolve from uploads
      else {
        const storedPath = file.file_path || file.storage_path || file.filepath || file.path;

        // Try to properly resolve the file path using stored information
        if (storedPath) {
          if (storedPath.startsWith('/uploads/')) {
            // Handle paths stored as relative URLs with /uploads/ prefix
            const relativePath = storedPath.substring('/uploads/'.length);

            if (relativePath.includes('/')) {
              // Already has subdirectory - use as is
              resolved = path.join(uploadsDir, relativePath);
            } else {
              // Try to find in user's directory
              const userPath = path.join(uploadsDir, file.username, path.basename(storedPath));

              // Check if file exists in user folder
              try {
                await fs.access(userPath);
                resolved = userPath;
              } catch (e) {
                // Not found in user directory, fallback to direct location
                resolved = path.join(uploadsDir, path.basename(storedPath));
              }
            }
          } else {
            // Direct path or already absolute
            resolved = await resolveFilePath(storedPath, file.username);
          }
        }
      }

      if (!resolved) {
        return res.status(400).json({ success: false, message: 'No file path available to delete' });
      }

      console.log(`üóëÔ∏è Attempting to delete physical file: ${resolved}`);

      const deleteResult = await safeDeleteFile(resolved);

      if (deleteResult.success) {
        if (deleteResult.notFound) {
          console.log(`‚ÑπÔ∏è Physical file not found (already removed): ${resolved}`);
          return res.json({ success: true, message: 'Physical file not found (already removed)' });
        }

        console.log(`‚úÖ Physical file deleted successfully: ${resolved}`);
        return res.json({ success: true, message: 'Physical file deleted' });
      } else {
        console.error('‚ùå Error deleting physical file:', resolved, deleteResult.error);
        return res.status(500).json({
          success: false,
          message: 'Failed to delete physical file',
          detail: deleteResult.message
        });
      }
    });
  } catch (err) {
    console.error('‚ùå delete-file error:', err);
    return res.status(500).json({ success: false, message: 'Server error', detail: err.message });
  }
});

// DELETE /api/files/:id
// Delete DB record. Expect admin audit info in body optionally.
router.delete('/:id', async (req, res) => {
  const id = req.params.id;
  try {
    const result = await db.query('DELETE FROM files WHERE id = ?', [id]);
    // mysql2 returns affectedRows in result. If using query that returns array, handle gracefully.
    // For compatibility, check result.affectedRows or affectedRows in returned object.
    const affected = (result && result.affectedRows) || (Array.isArray(result) && result[0] && result[0].affectedRows) || null;
    // best-effort: consider success if no error thrown
    return res.json({ success: true, message: 'File record deleted' });
  } catch (err) {
    console.error('Error deleting DB record:', err);
    return res.status(500).json({ success: false, message: 'Failed to delete file record', detail: err.message });
  }
});

// REMOVED: Duplicate admin-review endpoint that was conflicting with the main one above

// HIGH PRIORITY FEATURE: Bulk Actions - Approve/Reject multiple files
router.post('/bulk-action', (req, res) => {
  const { fileIds, action, comments, reviewerId, reviewerUsername, reviewerRole, team } = req.body;

  if (!fileIds || !Array.isArray(fileIds) || fileIds.length === 0) {
    return res.status(400).json({
      success: false,
      message: 'File IDs array is required'
    });
  }

  if (!['approve', 'reject'].includes(action)) {
    return res.status(400).json({
      success: false,
      message: 'Invalid action. Must be approve or reject'
    });
  }

  console.log(`üìã Bulk ${action} for ${fileIds.length} files by ${reviewerUsername}`);

  const now = new Date();
  const nowSql = now.toISOString().slice(0,19).replace('T', ' ');
  const results = { success: [], failed: [] };
  let processed = 0;

  fileIds.forEach(fileId => {
    db.get('SELECT * FROM files WHERE id = ?', [fileId], (err, file) => {
      if (err || !file) {
        results.failed.push({ fileId, reason: 'File not found' });
        processed++;
        checkComplete();
        return;
      }

      const isTeamLeader = reviewerRole === 'team_leader';
      const isAdmin = reviewerRole === 'admin';
      const correctStage = (isTeamLeader && file.current_stage === 'pending_team_leader') ||
                          (isAdmin && file.current_stage === 'pending_admin');

      if (!correctStage) {
        results.failed.push({ fileId, reason: 'Incorrect review stage', fileName: file.original_name });
        processed++;
        checkComplete();
        return;
      }

      let newStatus, newStage;
      if (isTeamLeader) {
        newStatus = action === 'approve' ? 'team_leader_approved' : 'rejected_by_team_leader';
        newStage = action === 'approve' ? 'pending_admin' : 'rejected_by_team_leader';
      } else {
        newStatus = action === 'approve' ? 'final_approved' : 'rejected_by_admin';
        newStage = action === 'approve' ? 'published_to_public' : 'rejected_by_admin';
      }

      const updateSql = isTeamLeader ?
        `UPDATE files SET status = ?, current_stage = ?, team_leader_id = ?, team_leader_username = ?, 
         team_leader_reviewed_at = ?, team_leader_comments = ?${action === 'reject' ? ', rejection_reason = ?, rejected_by = ?, rejected_at = ?' : ''} 
         WHERE id = ?` :
        `UPDATE files SET status = ?, current_stage = ?, admin_id = ?, admin_username = ?, 
         admin_reviewed_at = ?, admin_comments = ?${action === 'approve' ? ', public_network_url = ?, final_approved_at = ?' : ''}${action === 'reject' ? ', rejection_reason = ?, rejected_by = ?, rejected_at = ?' : ''} 
         WHERE id = ?`;

      const publicNetworkUrl = (isAdmin && action === 'approve') ? `https://public-network.example.com/files/${file.filename}` : null;

      const updateParams = isTeamLeader ?
        (action === 'reject' ?
          [newStatus, newStage, reviewerId, reviewerUsername, nowSql, comments, comments, reviewerUsername, nowSql, fileId] :
          [newStatus, newStage, reviewerId, reviewerUsername, nowSql, comments, fileId]) :
        (action === 'approve' ?
          [newStatus, newStage, reviewerId, reviewerUsername, nowSql, comments, publicNetworkUrl, nowSql, fileId] :
          action === 'reject' ?
            [newStatus, newStage, reviewerId, reviewerUsername, nowSql, comments, comments, reviewerUsername, nowSql, fileId] :
            [newStatus, newStage, reviewerId, reviewerUsername, nowSql, comments, fileId]);

      db.run(updateSql, updateParams, function(err) {
        if (err) {
          console.error(`‚ùå Error updating file ${fileId}:`, err);
          results.failed.push({ fileId, reason: err.message, fileName: file.original_name });
          processed++;
          checkComplete();
          return;
        }

        // Add comment
        if (comments) {
          db.run(
            'INSERT INTO file_comments (file_id, user_id, username, user_role, comment, comment_type) VALUES (?, ?, ?, ?, ?, ?)',
            [fileId, reviewerId, reviewerUsername, reviewerRole, comments, action],
            () => {}
          );
        }

        // Log status change
        logFileStatusChange(
          db, fileId, file.status, newStatus, file.current_stage, newStage,
          reviewerId, reviewerUsername, reviewerRole, `Bulk ${action}: ${comments || 'No comments'}`
        );

        results.success.push({ fileId, fileName: file.original_name, newStatus, newStage });
        processed++;
        checkComplete();
      });
    });
  });

  function checkComplete() {
    if (processed === fileIds.length) {
      // Log activity
      logActivity(
        db, reviewerId, reviewerUsername, reviewerRole, team,
        `Bulk ${action}: ${results.success.length} files ${action}d, ${results.failed.length} failed`
      );

      console.log(`‚úÖ Bulk action complete: ${results.success.length} succeeded, ${results.failed.length} failed`);
      res.json({
        success: true,
        message: `Bulk action completed: ${results.success.length} files ${action}d, ${results.failed.length} failed`,
        results
      });
    }
  }
});

// HIGH PRIORITY FEATURE: Advanced Filtering & Sorting
router.post('/team-leader/:team/filter', (req, res) => {
  const { team } = req.params;
  const { filters, sort, page = 1, limit = 50 } = req.body;
  const offset = (page - 1) * limit;

  console.log(`üîç Filtering files for team ${team}:`, filters);

  const whereClauses = ['user_team = ?', 'current_stage = ?'];
  const params = [team, 'pending_team_leader'];

  // Build WHERE clauses based on filters
  if (filters) {
    if (filters.fileType && filters.fileType.length > 0) {
      const placeholders = filters.fileType.map(() => '?').join(',');
      whereClauses.push(`file_type IN (${placeholders})`);
      params.push(...filters.fileType);
    }

    if (filters.submittedBy && filters.submittedBy.length > 0) {
      const placeholders = filters.submittedBy.map(() => '?').join(',');
      whereClauses.push(`user_id IN (${placeholders})`);
      params.push(...filters.submittedBy);
    }

    if (filters.dateFrom) {
      whereClauses.push('uploaded_at >= ?');
      params.push(filters.dateFrom);
    }

    if (filters.dateTo) {
      whereClauses.push('uploaded_at <= ?');
      params.push(filters.dateTo);
    }

    if (filters.priority) {
      whereClauses.push('priority = ?');
      params.push(filters.priority);
    }

    if (filters.hasDeadline) {
      whereClauses.push('due_date IS NOT NULL');
    }

    if (filters.isOverdue) {
      whereClauses.push('due_date < ?');
      params.push(new Date().toISOString());
    }
  }

  // Build ORDER BY clause
  let orderBy = 'uploaded_at DESC';
  if (sort) {
    const sortField = sort.field || 'uploaded_at';
    const sortDir = sort.direction || 'DESC';
    const allowedFields = ['uploaded_at', 'original_name', 'file_size', 'priority', 'due_date'];
    if (allowedFields.includes(sortField)) {
      orderBy = `${sortField} ${sortDir}`;
    }
  }

  const whereClause = whereClauses.join(' AND ');
  const countSql = `SELECT COUNT(*) as total FROM files WHERE ${whereClause}`;
  const dataSql = `SELECT f.*, fc.comment as latest_comment FROM files f 
                   LEFT JOIN file_comments fc ON f.id = fc.file_id AND fc.id = (SELECT MAX(id) FROM file_comments WHERE file_id = f.id) 
                   WHERE ${whereClause} ORDER BY ${orderBy} LIMIT ? OFFSET ?`;

  db.get(countSql, params, (err, countResult) => {
    if (err) {
      console.error('‚ùå Error counting filtered files:', err);
      return res.status(500).json({ success: false, message: 'Failed to filter files' });
    }

    db.all(dataSql, [...params, limit, offset], (err, files) => {
      if (err) {
        console.error('‚ùå Error getting filtered files:', err);
        return res.status(500).json({ success: false, message: 'Failed to filter files' });
      }

      console.log(`‚úÖ Retrieved ${files.length} filtered files`);
      res.json({
        success: true,
        files,
        pagination: {
          page,
          limit,
          total: countResult.total,
          pages: Math.ceil(countResult.total / limit)
        }
      });
    });
  });
});

// HIGH PRIORITY FEATURE: Set file priority and due date
router.patch('/:fileId/priority', (req, res) => {
  const { fileId } = req.params;
  const { priority, dueDate, reviewerId, reviewerUsername } = req.body;

  console.log(`üéØ Setting priority for file ${fileId}: ${priority}, due: ${dueDate}`);

  const updates = [];
  const params = [];

  if (priority !== undefined) {
    updates.push('priority = ?');
    params.push(priority);
  }

  if (dueDate !== undefined) {
    updates.push('due_date = ?');
    params.push(dueDate);
  }

  if (updates.length === 0) {
    return res.status(400).json({ success: false, message: 'No updates provided' });
  }

  params.push(fileId);
  const sql = `UPDATE files SET ${updates.join(', ')} WHERE id = ?`;

  db.run(sql, params, function(err) {
    if (err) {
      console.error('‚ùå Error updating file priority:', err);
      return res.status(500).json({ success: false, message: 'Failed to update priority' });
    }

    // Log activity
    const changes = [];
    if (priority !== undefined) {
      changes.push(`priority: ${priority}`);
    }
    if (dueDate !== undefined) {
      changes.push(`due date: ${dueDate}`);
    }

    db.get('SELECT * FROM files WHERE id = ?', [fileId], (err, file) => {
      if (file) {
        logActivity(
          db, reviewerId, reviewerUsername, 'team_leader', file.user_team,
          `Updated file ${file.original_name} - ${changes.join(', ')}`
        );
      }
    });

    console.log('‚úÖ File priority updated');
    res.json({ success: true, message: 'Priority updated successfully' });
  });
});

// HIGH PRIORITY FEATURE: Get notification/alert data
router.get('/notifications/:team', (req, res) => {
  const { team } = req.params;
  console.log(`üîî Getting notifications for team ${team}`);

  const now = new Date().toISOString();

  db.all(
    `SELECT id, original_name, uploaded_at, priority, due_date, username 
     FROM files 
     WHERE user_team = ? AND current_stage = 'pending_team_leader' 
     ORDER BY 
       CASE 
         WHEN due_date IS NOT NULL AND due_date < ? THEN 1
         WHEN priority = 'urgent' THEN 2
         WHEN priority = 'high' THEN 3
         ELSE 4
       END,
       uploaded_at ASC 
     LIMIT 10`,
    [team, now],
    (err, files) => {
      if (err) {
        console.error('‚ùå Error getting notifications:', err);
        return res.status(500).json({ success: false, message: 'Failed to get notifications' });
      }

      const notifications = files.map(file => {
        const isOverdue = file.due_date && new Date(file.due_date) < new Date();
        const isUrgent = file.priority === 'urgent' || file.priority === 'high';

        return {
          id: file.id,
          fileName: file.original_name,
          submitter: file.username,
          uploadedAt: file.uploaded_at,
          priority: file.priority || 'normal',
          dueDate: file.due_date,
          isOverdue,
          isUrgent,
          type: isOverdue ? 'overdue' : isUrgent ? 'urgent' : 'pending',
          message: isOverdue ?
            `Overdue: ${file.original_name} was due ${new Date(file.due_date).toLocaleDateString()}` :
            isUrgent ?
              `${file.priority.toUpperCase()}: ${file.original_name} needs review` :
              `New file: ${file.original_name} awaiting review`
        };
      });

      console.log(`‚úÖ Retrieved ${notifications.length} notifications`);
      res.json({
        success: true,
        notifications,
        counts: {
          overdue: notifications.filter(n => n.isOverdue).length,
          urgent: notifications.filter(n => n.isUrgent && !n.isOverdue).length,
          pending: notifications.filter(n => !n.isOverdue && !n.isUrgent).length
        }
      });
    }
  );
});

// Get files by status for a team (for analytics modal)
router.get('/team/:team/status/:status', (req, res) => {
  const { team, status } = req.params;
  console.log(`üìä Getting ${status} files for team ${team}`);

  let whereClause = 'user_team = ?';
  const params = [team];

  // Map status to database values
  if (status === 'approved') {
    whereClause += ' AND (status = ? OR status = ?)';
    params.push('team_leader_approved', 'final_approved');
  } else if (status === 'pending') {
    whereClause += ' AND (current_stage = ? OR current_stage = ?)';
    params.push('pending_team_leader', 'pending_admin');
  } else if (status === 'rejected') {
    whereClause += ' AND (status = ? OR status = ?)';
    params.push('rejected_by_team_leader', 'rejected_by_admin');
  } else {
    return res.status(400).json({
      success: false,
      message: 'Invalid status. Must be approved, pending, or rejected'
    });
  }

  db.all(
    `SELECT f.*, fc.comment as latest_comment
     FROM files f
     LEFT JOIN file_comments fc ON f.id = fc.file_id AND fc.id = (
       SELECT MAX(id) FROM file_comments WHERE file_id = f.id
     )
     WHERE ${whereClause}
     ORDER BY f.uploaded_at DESC`,
    params,
    (err, files) => {
      if (err) {
        console.error(`‚ùå Error getting ${status} files:`, err);
        return res.status(500).json({
          success: false,
          message: `Failed to fetch ${status} files`
        });
      }
      console.log(`‚úÖ Retrieved ${files.length} ${status} files for team ${team}`);
      res.json({
        success: true,
        files
      });
    }
  );
});

// Open file with system's default application
router.post('/open-file', async (req, res) => {
  const { filePath } = req.body;
  console.log(`üìÇ Opening file with default application: ${filePath}`);

  try {
    // Resolve the file path
    let resolvedPath = filePath;

    // If it's a relative path starting with /uploads/, resolve it
    if (filePath.startsWith('/uploads/')) {
      const relativePath = filePath.substring(8);
      resolvedPath = path.join(uploadsDir, relativePath);
    }

    // Normalize path for Windows
    resolvedPath = path.normalize(resolvedPath);

    // Check if file exists
    try {
      await fs.access(resolvedPath);
    } catch (error) {
      console.error('‚ùå File not found:', resolvedPath);
      return res.status(404).json({
        success: false,
        message: 'File not found'
      });
    }

    // Platform-specific command to open file with default application
    let command;
    if (process.platform === 'win32') {
      // Windows: use start command
      command = `start "" "${resolvedPath}"`;
    } else if (process.platform === 'darwin') {
      // macOS: use open command
      command = `open "${resolvedPath}"`;
    } else {
      // Linux: use xdg-open command
      command = `xdg-open "${resolvedPath}"`;
    }

    // Execute the command
    exec(command, (error) => {
      if (error) {
        console.error('‚ùå Error opening file:', error);
        return res.status(500).json({
          success: false,
          message: 'Failed to open file',
          error: error.message
        });
      }

      console.log('‚úÖ File opened successfully with default application');
      res.json({
        success: true,
        message: 'File opened successfully'
      });
    });
  } catch (error) {
    console.error('‚ùå Error processing file open request:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to open file',
      error: error.message
    });
  }
});

// Get file path by ID (for Electron to open files) - MUST BE BEFORE /:fileId
router.get('/:fileId/path', (req, res) => {
  const { fileId } = req.params;
  console.log(`üìç Getting file path for ID: ${fileId}`);

  db.get('SELECT file_path, original_name FROM files WHERE id = ?', [fileId], (err, file) => {
    if (err) {
      console.error('‚ùå Error getting file path:', err);
      return res.status(500).json({
        success: false,
        message: 'Failed to get file path'
      });
    }

    if (!file) {
      console.log('‚ùå File not found:', fileId);
      return res.status(404).json({
        success: false,
        message: 'File not found'
      });
    }

    // Convert relative path to absolute path
    let filePath = file.file_path;
    
    // If it's a relative path starting with /uploads/, resolve it
    if (filePath.startsWith('/uploads/')) {
      const relativePath = filePath.substring(8);
      filePath = path.join(uploadsDir, relativePath);
    }

    // Normalize path for Windows
    filePath = path.normalize(filePath);

    console.log('‚úÖ File path resolved:', filePath);
    res.json({
      success: true,
      filePath,
      fileName: file.original_name
    });
  });
});

// Get file details by ID (for opening files) - CATCH-ALL, MUST BE LAST
router.get('/:fileId', (req, res) => {
  const { fileId } = req.params;
  
  // Skip if not a numeric ID (avoid catching other routes)
  if (!/^\d+$/.test(fileId)) {
    return res.status(400).json({
      success: false,
      message: 'Invalid file ID'
    });
  }
  
  console.log(`üìù Getting file details for ID: ${fileId}`);

  db.get('SELECT * FROM files WHERE id = ?', [fileId], (err, file) => {
    if (err) {
      console.error('‚ùå Error getting file:', err);
      return res.status(500).json({
        success: false,
        message: 'Failed to get file details'
      });
    }

    if (!file) {
      console.log('‚ùå File not found:', fileId);
      return res.status(404).json({
        success: false,
        message: 'File not found'
      });
    }

    console.log('‚úÖ File found:', file.original_name);
    res.json({
      success: true,
      file
    });
  });
});

module.exports = router;

/***/ }),

/***/ 83565:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

const express = __nccwpck_require__(85152);
const { query, queryOne } = __nccwpck_require__(44671);

const router = express.Router();

// Helper function to create a notification (supports both file and assignment notifications)
const createNotification = async (userId, fileId, type, title, message, actionById, actionByUsername, actionByRole, assignmentId = null) => {
  try {
    console.log('üîî Creating notification:', { userId, fileId, assignmentId, type, title });

    const result = await query(
      `INSERT INTO notifications (
        user_id, file_id, type, title, message, assignment_id,
        action_by_id, action_by_username, action_by_role
      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)`,
      [userId, fileId, type, title, message, assignmentId, actionById, actionByUsername, actionByRole]
    );

    console.log(`‚úÖ Notification created for user ${userId}: ${title}`);
    return result.insertId;
  } catch (error) {
    console.error('‚ùå Error creating notification:', error);
    console.error('Details:', { userId, fileId, assignmentId, type, title, message });
    throw error;
  }
};

// Get all notifications for a user with pagination
router.get('/user/:userId', async (req, res) => {
  try {
    const { userId } = req.params;
    const { unreadOnly, page = 1, limit = 20 } = req.query;

    const pageNum = parseInt(page);
    const limitNum = parseInt(limit);
    const offset = (pageNum - 1) * limitNum;

    console.log(`üì¨ Fetching notifications for user ${userId}, page: ${pageNum}, limit: ${limitNum}`);

    // Get total count
    let countQuery = 'SELECT COUNT(*) as total FROM notifications WHERE user_id = ?';
    if (unreadOnly === 'true') {
      countQuery += ' AND is_read = 0';
    }
    const countResult = await queryOne(countQuery, [userId]);
    const totalCount = countResult?.total || 0;

    // Get paginated notifications
    let queryStr = `
      SELECT 
        n.*, 
        f.original_name as file_name, 
        f.status as file_status,
        a.title as assignment_title,
        a.due_date as assignment_due_date,
        ac.id as comment_id
      FROM notifications n
      LEFT JOIN files f ON n.file_id = f.id
      LEFT JOIN assignments a ON n.assignment_id = a.id
      LEFT JOIN assignment_comments ac ON n.assignment_id = ac.assignment_id 
        AND n.type = 'comment' 
        AND n.created_at <= DATE_ADD(ac.created_at, INTERVAL 1 SECOND)
        AND n.created_at >= DATE_SUB(ac.created_at, INTERVAL 1 SECOND)
      WHERE n.user_id = ?
    `;

    if (unreadOnly === 'true') {
      queryStr += ' AND n.is_read = 0';
    }

    queryStr += ` ORDER BY n.created_at DESC LIMIT ${limitNum} OFFSET ${offset}`;

    const notifications = await query(queryStr, [userId]);

    console.log(`‚úÖ Found ${notifications.length} notifications for user ${userId} (page ${pageNum})`);

    // Count unread notifications (total, not just in this page)
    const unreadCountResult = await queryOne(
      'SELECT COUNT(*) as count FROM notifications WHERE user_id = ? AND is_read = 0',
      [userId]
    );
    const unreadCount = unreadCountResult?.count || 0;

    // Calculate if there are more pages
    const hasMore = offset + notifications.length < totalCount;

    res.json({
      success: true,
      notifications: notifications || [],
      unreadCount: unreadCount,
      totalCount: totalCount,
      page: pageNum,
      limit: limitNum,
      hasMore: hasMore
    });
  } catch (error) {
    console.error('‚ùå Error fetching notifications:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to fetch notifications',
      error: error.message
    });
  }
});

// Get unread notification count
router.get('/user/:userId/unread-count', async (req, res) => {
  try {
    const { userId } = req.params;

    const result = await queryOne(
      'SELECT COUNT(*) as count FROM notifications WHERE user_id = ? AND is_read = 0',
      [userId]
    );

    res.json({
      success: true,
      count: result?.count || 0
    });
  } catch (error) {
    console.error('‚ùå Error getting unread count:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to get unread count'
    });
  }
});

// Mark notification as read
router.put('/:notificationId/read', async (req, res) => {
  try {
    const { notificationId } = req.params;
    const now = new Date().toISOString().slice(0, 19).replace('T', ' ');

    await query(
      'UPDATE notifications SET is_read = 1, read_at = ? WHERE id = ?',
      [now, notificationId]
    );

    console.log(`‚úÖ Notification ${notificationId} marked as read`);

    res.json({
      success: true,
      message: 'Notification marked as read'
    });
  } catch (error) {
    console.error('‚ùå Error marking notification as read:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to mark notification as read'
    });
  }
});

// Mark all notifications as read for a user
router.put('/user/:userId/read-all', async (req, res) => {
  try {
    const { userId } = req.params;
    const now = new Date().toISOString().slice(0, 19).replace('T', ' ');

    const result = await query(
      'UPDATE notifications SET is_read = 1, read_at = ? WHERE user_id = ? AND is_read = 0',
      [now, userId]
    );

    console.log(`‚úÖ Marked all notifications as read for user ${userId}`);

    res.json({
      success: true,
      message: 'All notifications marked as read',
      count: result.affectedRows || 0
    });
  } catch (error) {
    console.error('‚ùå Error marking all notifications as read:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to mark all notifications as read'
    });
  }
});

// Delete a notification
router.delete('/:notificationId', async (req, res) => {
  try {
    const { notificationId } = req.params;

    await query(
      'DELETE FROM notifications WHERE id = ?',
      [notificationId]
    );

    console.log(`‚úÖ Notification ${notificationId} deleted`);

    res.json({
      success: true,
      message: 'Notification deleted'
    });
  } catch (error) {
    console.error('‚ùå Error deleting notification:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to delete notification'
    });
  }
});

// Delete all notifications for a user
router.delete('/user/:userId/delete-all', async (req, res) => {
  try {
    const { userId } = req.params;

    console.log(`üóëÔ∏è Deleting all notifications for user ${userId}`);

    const result = await query(
      'DELETE FROM notifications WHERE user_id = ?',
      [userId]
    );

    console.log(`‚úÖ Deleted ${result.affectedRows || 0} notifications for user ${userId}`);

    res.json({
      success: true,
      message: 'All notifications deleted',
      count: result.affectedRows || 0
    });
  } catch (error) {
    console.error('‚ùå Error deleting all notifications:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to delete all notifications'
    });
  }
});

// Export both the router and the helper function
module.exports = {
  router,
  createNotification
};


/***/ }),

/***/ 52528:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

const express = __nccwpck_require__(85152);
const router = express.Router();
const { db, USE_MYSQL } = __nccwpck_require__(5024);
const { logActivity } = __nccwpck_require__(46534);

// Initialize settings table if it doesn't exist
const initializeSettingsTable = async () => {
  try {
    if (USE_MYSQL) {
      await db.query(`
        CREATE TABLE IF NOT EXISTS settings (
          id INT PRIMARY KEY AUTO_INCREMENT,
          setting_key VARCHAR(255) UNIQUE NOT NULL,
          setting_value TEXT,
          description TEXT,
          updated_by VARCHAR(255),
          updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
        )
      `);

      // Insert default settings if not exists
      await db.query(`
        INSERT IGNORE INTO settings (setting_key, setting_value, description)
        VALUES ('root_directory', '/home/admin/files', 'Root directory for file management system')
      `);
    } else {
      await new Promise((resolve, reject) => {
        db.run(`
          CREATE TABLE IF NOT EXISTS settings (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            setting_key TEXT UNIQUE NOT NULL,
            setting_value TEXT,
            description TEXT,
            updated_by TEXT,
            updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
          )
        `, (err) => {
          if (err) {
            reject(err);
          } else {
            // Insert default settings
            db.run(`
              INSERT OR IGNORE INTO settings (setting_key, setting_value, description)
              VALUES ('root_directory', '/home/admin/files', 'Root directory for file management system')
            `, (err) => {
              if (err) {
                reject(err);
              } else {
                resolve();
              }
            });
          }
        });
      });
    }
  } catch (error) {
    console.error('Error initializing settings table:', error);
  }
};

// Initialize on module load
initializeSettingsTable();

// GET all settings
router.get('/', async (req, res) => {
  try {
    if (USE_MYSQL) {
      const settings = await db.query('SELECT * FROM settings');

      // Convert array to object for easier access
      const settingsObj = {};
      settings.forEach(setting => {
        settingsObj[setting.setting_key] = {
          value: setting.setting_value,
          description: setting.description,
          updated_by: setting.updated_by,
          updated_at: setting.updated_at
        };
      });

      res.json({ success: true, settings: settingsObj });
    } else {
      db.all('SELECT * FROM settings', [], (err, settings) => {
        if (err) {
          console.error('Error fetching settings:', err);
          return res.status(500).json({ success: false, message: 'Failed to fetch settings' });
        }

        // Convert array to object
        const settingsObj = {};
        settings.forEach(setting => {
          settingsObj[setting.setting_key] = {
            value: setting.setting_value,
            description: setting.description,
            updated_by: setting.updated_by,
            updated_at: setting.updated_at
          };
        });

        res.json({ success: true, settings: settingsObj });
      });
    }
  } catch (error) {
    console.error('Error fetching settings:', error);
    res.status(500).json({ success: false, message: 'Failed to fetch settings' });
  }
});

// GET specific setting by key
router.get('/:key', async (req, res) => {
  const { key } = req.params;

  try {
    if (USE_MYSQL) {
      const settings = await db.query(
        'SELECT * FROM settings WHERE setting_key = ?',
        [key]
      );

      if (settings.length === 0) {
        return res.status(404).json({ success: false, message: 'Setting not found' });
      }

      res.json({
        success: true,
        setting: {
          key: settings[0].setting_key,
          value: settings[0].setting_value,
          description: settings[0].description,
          updated_by: settings[0].updated_by,
          updated_at: settings[0].updated_at
        }
      });
    } else {
      db.get(
        'SELECT * FROM settings WHERE setting_key = ?',
        [key],
        (err, setting) => {
          if (err) {
            console.error('Error fetching setting:', err);
            return res.status(500).json({ success: false, message: 'Failed to fetch setting' });
          }

          if (!setting) {
            return res.status(404).json({ success: false, message: 'Setting not found' });
          }

          res.json({
            success: true,
            setting: {
              key: setting.setting_key,
              value: setting.setting_value,
              description: setting.description,
              updated_by: setting.updated_by,
              updated_at: setting.updated_at
            }
          });
        }
      );
    }
  } catch (error) {
    console.error('Error fetching setting:', error);
    res.status(500).json({ success: false, message: 'Failed to fetch setting' });
  }
});

// PUT update setting
router.put('/:key', async (req, res) => {
  const { key } = req.params;
  const { value, updated_by } = req.body;

  if (!value) {
    return res.status(400).json({ success: false, message: 'Setting value is required' });
  }

  try {
    if (USE_MYSQL) {
      const result = await db.query(
        `UPDATE settings 
         SET setting_value = ?, updated_by = ?, updated_at = CURRENT_TIMESTAMP
         WHERE setting_key = ?`,
        [value, updated_by || 'system', key]
      );

      if (result.affectedRows === 0) {
        // Setting doesn't exist, insert it
        await db.query(
          `INSERT INTO settings (setting_key, setting_value, updated_by)
           VALUES (?, ?, ?)`,
          [key, value, updated_by || 'system']
        );
      }

      // Log activity
      if (updated_by) {
        logActivity(
          db,
          null,
          updated_by,
          'ADMIN',
          'General',
          `Updated setting: ${key} = ${value}`
        );
      }

      res.json({ success: true, message: 'Setting updated successfully' });
    } else {
      db.run(
        `INSERT OR REPLACE INTO settings (setting_key, setting_value, updated_by, updated_at)
         VALUES (?, ?, ?, CURRENT_TIMESTAMP)`,
        [key, value, updated_by || 'system'],
        function(err) {
          if (err) {
            console.error('Error updating setting:', err);
            return res.status(500).json({ success: false, message: 'Failed to update setting' });
          }

          // Log activity
          if (updated_by) {
            logActivity(
              db,
              null,
              updated_by,
              'ADMIN',
              'General',
              `Updated setting: ${key} = ${value}`
            );
          }

          res.json({ success: true, message: 'Setting updated successfully' });
        }
      );
    }
  } catch (error) {
    console.error('Error updating setting:', error);
    res.status(500).json({ success: false, message: 'Failed to update setting' });
  }
});

module.exports = router;


/***/ }),

/***/ 69915:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

const express = __nccwpck_require__(85152);
const { db } = __nccwpck_require__(5024);
const { logActivity } = __nccwpck_require__(46534);

const router = express.Router();

// Get all teams (Admin only)
router.get('/', (req, res) => {
  console.log('üè¢ Getting all teams...');
  db.all('SELECT * FROM teams ORDER BY created_at DESC', [], (err, teams) => {
    if (err) {
      console.error('‚ùå Database error getting teams:', err);
      return res.status(500).json({
        success: false,
        message: 'Failed to fetch teams'
      });
    }
    console.log(`‚úÖ Retrieved ${teams.length} teams`);
    res.json({
      success: true,
      teams
    });
  });
});

// Create new team (Admin only)
router.post('/', (req, res) => {
  const { name, description, leaderId, leaderUsername, color = '#3B82F6' } = req.body;
  console.log('üè¢ Creating new team:', { name, description, leaderId, leaderUsername, color });

  // Validation
  if (!name || name.trim() === '') {
    return res.status(400).json({
      success: false,
      message: 'Team name is required'
    });
  }

  const now = new Date().toISOString();
  db.run(
    'INSERT INTO teams (name, description, leader_id, leader_username, color, created_at, updated_at) VALUES (?, ?, ?, ?, ?, ?, ?)',
    [name.trim(), description || null, leaderId || null, leaderUsername || null, color, now, now],
    function(err) {
      if (err) {
        console.error('‚ùå Error creating team:', err);
        if (err.code === 'ER_DUP_ENTRY' || err.code === 'SQLITE_CONSTRAINT') {
          return res.status(409).json({
            success: false,
            message: 'Team name already exists'
          });
        }
        return res.status(500).json({
          success: false,
          message: 'Failed to create team'
        });
      }
      console.log(`‚úÖ Team created with ID: ${this.lastID}`);

      // Log activity
      logActivity(
        db,
        null,
        'System',
        'ADMIN',
        'System',
        `Team created: ${name} (ID: ${this.lastID})`
      );
      res.status(201).json({
        success: true,
        message: 'Team created successfully',
        teamId: this.lastID,
        team: {
          id: this.lastID,
          name: name.trim(),
          description: description || null,
          leader_id: leaderId || null,
          leader_username: leaderUsername || null,
          color: color,
          is_active: 1,
          created_at: now,
          updated_at: now
        }
      });
    }
  );
});

// Update team (Admin only)
router.put('/:id', (req, res) => {
  const teamId = req.params.id;
  const { name, description, leaderId, leaderUsername, color, isActive } = req.body;
  console.log(`‚úèÔ∏è Updating team ${teamId}:`, { name, description, leaderId, leaderUsername, color, isActive });

  // Validation
  if (!name || name.trim() === '') {
    return res.status(400).json({
      success: false,
      message: 'Team name is required'
    });
  }

  const now = new Date().toISOString();
  const activeStatus = isActive !== undefined ? (isActive ? 1 : 0) : 1;
  db.run(
    'UPDATE teams SET name = ?, description = ?, leader_id = ?, leader_username = ?, color = ?, is_active = ?, updated_at = ? WHERE id = ?',
    [name.trim(), description || null, leaderId || null, leaderUsername || null, color || '#3B82F6', activeStatus, now, teamId],
    function(err) {
      if (err) {
        console.error('‚ùå Error updating team:', err);
        if (err.code === 'ER_DUP_ENTRY' || err.code === 'SQLITE_CONSTRAINT') {
          return res.status(409).json({
            success: false,
            message: 'Team name already exists'
          });
        }
        return res.status(500).json({
          success: false,
          message: 'Failed to update team'
        });
      }
      if (this.changes === 0) {
        return res.status(404).json({
          success: false,
          message: 'Team not found'
        });
      }
      console.log(`‚úÖ Team ${teamId} updated successfully`);

      // Log activity
      logActivity(
        db,
        null,
        'System',
        'ADMIN',
        'System',
        `Team updated: ${name} (ID: ${teamId})`
      );
      res.json({
        success: true,
        message: 'Team updated successfully'
      });
    }
  );
});

// Delete team (Admin only)
router.delete('/:id', (req, res) => {
  const teamId = req.params.id;
  console.log(`üóëÔ∏è Deleting team ${teamId}`);

  // First check if team exists and get info
  db.get('SELECT name FROM teams WHERE id = ?', [teamId], (err, team) => {
    if (err) {
      console.error('‚ùå Error checking team:', err);
      return res.status(500).json({
        success: false,
        message: 'Failed to delete team'
      });
    }
    if (!team) {
      return res.status(404).json({
        success: false,
        message: 'Team not found'
      });
    }

    // Check if team has users assigned
    db.get('SELECT COUNT(*) as count FROM users WHERE team = ?', [team.name], (err, result) => {
      if (err) {
        console.error('‚ùå Error checking team users:', err);
        return res.status(500).json({
          success: false,
          message: 'Failed to delete team'
        });
      }
      if (result.count > 0) {
        return res.status(409).json({
          success: false,
          message: `Cannot delete team '${team.name}' because it has ${result.count} user(s) assigned. Please reassign users to other teams first.`
        });
      }

      // Delete the team
      db.run('DELETE FROM teams WHERE id = ?', [teamId], function(err) {
        if (err) {
          console.error('‚ùå Error deleting team:', err);
          return res.status(500).json({
            success: false,
            message: 'Failed to delete team'
          });
        }
        console.log(`‚úÖ Team deleted: ${team.name}`);

        // Log activity
        logActivity(
          db,
          null,
          'System',
          'ADMIN',
          'System',
          `Team deleted: ${team.name} (ID: ${teamId})`
        );
        res.json({
          success: true,
          message: `Team '${team.name}' deleted successfully`
        });
      });
    });
  });
});

// Get team by name (for user assignment validation)
router.get('/name/:name', (req, res) => {
  const { name } = req.params;
  db.get('SELECT * FROM teams WHERE name = ? AND is_active = 1', [name], (err, team) => {
    if (err) {
      console.error('‚ùå Error getting team by name:', err);
      return res.status(500).json({
        success: false,
        message: 'Failed to fetch team'
      });
    }
    res.json({
      success: true,
      team: team || null,
      exists: !!team
    });
  });
});

module.exports = router;


/***/ }),

/***/ 30737:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

const express = __nccwpck_require__(85152);
const bcrypt = __nccwpck_require__(11289);
const { db } = __nccwpck_require__(5024);
const { logActivity, logInfo, logWarn } = __nccwpck_require__(46534);
const { getCache, setCache, clearCache } = __nccwpck_require__(22686);
const { validate, schemas, validateId } = __nccwpck_require__(17632);
const { asyncHandler, DatabaseError, NotFoundError } = __nccwpck_require__(5369);

const router = express.Router();

// Get all users (Admin only) with caching
router.get('/', (req, res) => {
  const cacheKey = 'all_users';
  const cachedUsers = getCache(cacheKey);

  if (cachedUsers) {
    console.log('‚úÖ Retrieved users from cache');
    return res.json({ success: true, users: cachedUsers });
  }

  console.log('üìà Getting all users...');
  db.all('SELECT id, fullName, username, email, role, team, created_at FROM users ORDER BY created_at DESC', [], (err, users) => {
    if (err) {
      console.error('‚ùå Database error getting users:', err);
      return res.status(500).json({
        success: false,
        message: 'Failed to fetch users'
      });
    }
    console.log(`‚úÖ Retrieved ${users.length} users`);
    setCache(cacheKey, users);
    res.json({
      success: true,
      users
    });
  });
});

// Create new user (Admin only)
router.post('/', validate(schemas.createUser), asyncHandler(async (req, res) => {
  let { fullName, username, email, password, role = 'USER', team = 'General', adminId, adminUsername, adminRole, adminTeam } = req.body;
  // Normalize role and team
  role = (role || 'USER').toString().trim().toUpperCase();
  team = (team || 'General').toString().trim();
  logInfo('Creating new user', { fullName, username, email, role, team });

  // Hash password
  const hashedPassword = bcrypt.hashSync(password, 10);
  db.run(
    'INSERT INTO users (fullName, username, email, password, role, team) VALUES (?, ?, ?, ?, ?, ?)',
    [fullName, username, email, hashedPassword, role, team],
    function (err, result) {
      if (err) {
        console.error('‚ùå Error creating user:', err);
        if (err.code === 'ER_DUP_ENTRY' || err.code === 'SQLITE_CONSTRAINT') {
          return res.status(409).json({
            success: false,
            message: 'Username or email already exists'
          });
        }
        return res.status(500).json({
          success: false,
          message: 'Failed to create user'
        });
      }
      // For SQLite callback style, result may be undefined and 'this' contains lastID. For MySQL, result.insertId is available.
      const newUserId = (result && (result.insertId || result.insert_id)) || (this && this.lastID) || null;
      console.log(`‚úÖ User created with ID: ${newUserId}`);

      // Clear cache since users list changed
      clearCache('all_users');

      // Log activity using admin's information
      logActivity(
        db,
        adminId || null,
        adminUsername || 'Administrator',
        adminRole || 'ADMIN',
        adminTeam || 'System',
        `User account created by administrator: ${fullName} (${username})`
      );

      // If the new user is a Team Leader and a team is specified, set the team's leader
      if (role === 'TEAM LEADER' && team) {
        db.get('SELECT id FROM teams WHERE name = ?', [team], (err, teamRow) => {
          if (!err && teamRow) {
            db.run('UPDATE teams SET leader_id = ?, leader_username = ? WHERE id = ?', [newUserId, username, teamRow.id], (err) => {
              if (err) {
                console.error('‚ùå Error assigning team leader to team:', err);
              } else {
                console.log(`‚úÖ Assigned ${username} (ID: ${newUserId}) as leader for team '${team}'`);
              }
            });
          } else {
            console.log(`‚ö†Ô∏è Team '${team}' not found; skipping leader assignment`);
          }
        });
      }

      res.status(201).json({
        success: true,
        message: 'User created successfully',
        userId: newUserId
      });
    }
  );
}));

// Update user (Admin only)
router.put('/:id', (req, res) => {
  const userId = req.params.id;
  let { fullName, username, email, role, team, adminId, adminUsername, adminRole, adminTeam } = req.body;
  // Normalize role and team
  role = (role || '').toString().trim().toUpperCase();
  team = (team || 'General').toString().trim();
  console.log(`‚úèÔ∏è Updating user ${userId}:`, { fullName, username, email, role, team });

  // Validation
  if (!fullName || !username || !email || !role) {
    return res.status(400).json({
      success: false,
      message: 'Full name, username, email, and role are required'
    });
  }

  // First, check if user exists and get current data
  db.get('SELECT * FROM users WHERE id = ?', [userId], (err, currentUser) => {
    if (err) {
      console.error('‚ùå Error fetching user:', err);
      return res.status(500).json({
        success: false,
        message: 'Failed to fetch user data'
      });
    }
    if (!currentUser) {
      return res.status(404).json({
        success: false,
        message: 'User not found'
      });
    }

    // Perform a single UPDATE (no explicit SQL transaction; helper transaction is available)
    db.run(
      'UPDATE users SET fullName = ?, username = ?, email = ?, role = ?, team = ? WHERE id = ?',
      [fullName, username, email, role, team || 'General', userId],
      function (err, result) {
        if (err) {
          console.error('‚ùå Error updating user:', err);
          if (err.code === 'ER_DUP_ENTRY' || err.code === 'SQLITE_CONSTRAINT') {
            return res.status(409).json({
              success: false,
              message: 'Username or email already exists'
            });
          }
          return res.status(500).json({
            success: false,
            message: 'Failed to update user'
          });
        }

        // Determine affected rows for SQLite (this.changes) or MySQL (result.affectedRows)
        const rowsAffected = (result && (result.affectedRows || result.affected_rows || result.length)) || (this && this.changes) || 0;
        if (!rowsAffected) {
          return res.status(404).json({
            success: false,
            message: 'User not found or no changes made'
          });
        }

        // Clear cache since users list changed
        clearCache('all_users');

        console.log(`‚úÖ User ${userId} updated successfully - ${rowsAffected} row(s) affected`);
        console.log(`   Old values: ${currentUser.fullName} (${currentUser.username}) - ${currentUser.role} - ${currentUser.team}`);
        console.log(`   New values: ${fullName} (${username}) - ${role} - ${team || 'General'}`);

        // If role changed to TEAM LEADER, assign to team; if role changed away from TEAM LEADER, clear previous team leader entries
        try {
          if (role === 'TEAM LEADER') {
            db.get('SELECT id FROM teams WHERE name = ?', [team], (err, teamRow) => {
              if (!err && teamRow) {
                db.run('UPDATE teams SET leader_id = ?, leader_username = ? WHERE id = ?', [userId, username, teamRow.id], (err) => {
                  if (err) {
                    console.error('‚ùå Error assigning team leader during user update:', err);
                  } else {
                    console.log(`‚úÖ Assigned ${username} (ID: ${userId}) as leader for team '${team}'`);
                  }
                });
              } else {
                console.log(`‚ö†Ô∏è Team '${team}' not found; skipping leader assignment`);
              }
            });
          }

          if (currentUser.role === 'TEAM LEADER' && role !== 'TEAM LEADER') {
            db.run('UPDATE teams SET leader_id = NULL, leader_username = NULL WHERE leader_id = ?', [userId], (err) => {
              if (err) {
                console.error('‚ùå Error clearing leader assignment:', err);
              } else {
                console.log(`‚úÖ Cleared leader assignment for user ID ${userId}`);
              }
            });
          }
        } catch (err) {
          console.error('‚ùå Error handling team leader assignment during user update:', err);
        }

        // Log activity using admin's information
        logActivity(
          db,
          adminId || null,
          adminUsername || 'Administrator',
          adminRole || 'ADMIN',
          adminTeam || 'System',
          `User profile updated by administrator (Name: ${fullName}, Role: ${role}, Team: ${team || 'General'})`
        );

        res.json({
          success: true,
          message: 'User updated successfully',
          updatedUser: {
            id: userId,
            fullName,
            username,
            email,
            role,
            team: team || 'General'
          }
        });
      }
    );
  });
});

// Reset user password (Admin only)
router.put('/:id/password', validateId(), validate(schemas.resetPassword), asyncHandler(async (req, res) => {
  const userId = req.params.id;
  const { password, adminId, adminUsername, adminRole, adminTeam } = req.body;
  logInfo('Resetting password for user', { userId });

  const hashedPassword = bcrypt.hashSync(password, 10);

  await new Promise((resolve, reject) => {
    db.run(
      'UPDATE users SET password = ? WHERE id = ?',
      [hashedPassword, userId],
      function (err) {
        if (err) {
          reject(new DatabaseError('Failed to reset password', err));
        }
        if (this.changes === 0) {
          reject(new NotFoundError('User'));
        }
        resolve();
      }
    );
  });

  logInfo('Password reset successful', { userId });

  // Get user details for logging, notification, and email
  const userDetails = await new Promise((resolve, reject) => {
    db.get('SELECT username, fullName, email FROM users WHERE id = ?', [userId], (err, row) => {
      if (err) {
        reject(err);
      } else {
        resolve(row);
      }
    });
  });

  if (userDetails) {
    // Log activity using admin's information
    logActivity(
      db,
      adminId || null,
      adminUsername || 'Administrator',
      adminRole || 'ADMIN',
      adminTeam || 'System',
      `Password reset by administrator for user: ${userDetails.fullName} (${userDetails.username})`
    );

    // Create in-app notification for the user
    try {
      const { createNotification } = __nccwpck_require__(83565);
      const notificationMessage = `Your password has been reset by ${adminUsername || 'Administrator'}. You can now log in with your new password.`;

      await createNotification(
        userId,                          // userId (user whose password was reset)
        null,                            // fileId (no file associated)
        'password_reset_complete',       // type
        'Password Reset Complete',       // title
        notificationMessage,             // message
        adminId || null,                 // actionById (admin who reset the password)
        adminUsername || 'Administrator', // actionByUsername
        adminRole || 'ADMIN',            // actionByRole
        null                             // assignmentId (no assignment)
      );

      logInfo('Password reset notification sent to user', { userId, username: userDetails.username });
    } catch (notifError) {
      // Log error but don't fail the password reset
      console.error('‚ùå Failed to create password reset notification:', notifError);
    }

    // Send email notification to user
    try {
      const { sendPasswordResetEmail } = __nccwpck_require__(72572);

      const emailResult = await sendPasswordResetEmail(
        userDetails.email,
        userDetails.fullName || userDetails.username,
        adminUsername || 'Administrator'
      );

      if (emailResult.success) {
        logInfo('Password reset email sent', { userId, email: userDetails.email });
      } else {
        logWarn('Failed to send password reset email', { userId, reason: emailResult.message || emailResult.error });
      }
    } catch (emailError) {
      // Log error but don't fail the password reset
      console.error('‚ùå Failed to send password reset email:', emailError);
      logWarn('Password reset email failed', { userId, error: emailError.message });
    }
  }

  res.json({
    success: true,
    message: 'Password reset successfully'
  });
}));

// Delete user (Admin only)
router.delete('/:id', (req, res) => {
  const userId = req.params.id;
  const { adminId, adminUsername, adminRole, adminTeam } = req.body;
  console.log(`üóëÔ∏è Deleting user ${userId}`);

  // First check if user exists and get their info
  db.get('SELECT fullName, email FROM users WHERE id = ?', [userId], (err, user) => {
    if (err) {
      console.error('‚ùå Error checking user:', err);
      return res.status(500).json({
        success: false,
        message: 'Failed to delete user'
      });
    }
    if (!user) {
      return res.status(404).json({
        success: false,
        message: 'User not found'
      });
    }

    // Delete the user
    db.run('DELETE FROM users WHERE id = ?', [userId], function (err) {
      if (err) {
        console.error('‚ùå Error deleting user:', err);
        return res.status(500).json({
          success: false,
          message: 'Failed to delete user'
        });
      }

      // Clear cache since users list changed
      clearCache('all_users');

      console.log(`‚úÖ User deleted: ${user.fullName} (${user.email})`);

      // Log activity using admin's information
      logActivity(
        db,
        adminId || null,
        adminUsername || 'Administrator',
        adminRole || 'ADMIN',
        adminTeam || 'System',
        `User account deleted by administrator: ${user.fullName} (${user.email})`
      );
      res.json({
        success: true,
        message: `User ${user.fullName} deleted successfully`
      });
    });
  });
});

// Get team members (Team Leader only)
router.get('/team/:teamName', (req, res) => {
  const { teamName } = req.params;
  console.log(`üë• Getting team members for team: ${teamName}`);

  db.all(
    'SELECT id, fullName, username, email, role, team, created_at FROM users WHERE team = ? AND role != ? ORDER BY fullName',
    [teamName, 'TEAM LEADER'],
    (err, members) => {
      if (err) {
        console.error('‚ùå Error getting team members:', err);
        return res.status(500).json({
          success: false,
          message: 'Failed to fetch team members'
        });
      }
      console.log(`‚úÖ Retrieved ${members.length} members for team ${teamName}`);

      // Get file counts for each member
      const memberPromises = members.map(member => {
        return new Promise((resolve) => {
          db.get(
            'SELECT COUNT(*) as totalFiles FROM files WHERE user_id = ?',
            [member.id],
            (err, result) => {
              if (!err && result) {
                member.totalFiles = result.totalFiles || 0;
              } else {
                member.totalFiles = 0;
              }
              resolve(member);
            }
          );
        });
      });

      Promise.all(memberPromises).then(membersWithFiles => {
        res.json({
          success: true,
          members: membersWithFiles
        });
      });
    }
  );
});

// Search users (Admin only)
router.get('/search', (req, res) => {
  const { q } = req.query;
  if (!q || q.trim() === '') {
    return res.status(400).json({
      success: false,
      message: 'Search query is required'
    });
  }
  console.log(`üîç Searching users with query: ${q}`);
  const searchPattern = `%${q}%`;
  db.all(
    `SELECT id, fullName, username, email, role, team, created_at
     FROM users
     WHERE fullName LIKE ? OR username LIKE ? OR email LIKE ? OR role LIKE ? OR team LIKE ?
     ORDER BY fullName`,
    [searchPattern, searchPattern, searchPattern, searchPattern, searchPattern],
    (err, users) => {
      if (err) {
        console.error('‚ùå Error searching users:', err);
        return res.status(500).json({
          success: false,
          message: 'Search failed'
        });
      }
      console.log(`‚úÖ Found ${users.length} users matching '${q}'`);
      res.json({
        success: true,
        users
      });
    }
  );
});

// Get team members - Direct route (supports /api/team-members/:teamName)
// IMPORTANT: This must be LAST to avoid conflicts with other routes
router.get('/:teamName', (req, res) => {
  const { teamName } = req.params;
  console.log(`üë• Getting team members for team: ${teamName}`);

  db.all(
    'SELECT id, fullName, username, email, role, team, created_at FROM users WHERE team = ? AND role != ? ORDER BY fullName',
    [teamName, 'TEAM LEADER'],
    (err, members) => {
      if (err) {
        console.error('‚ùå Error getting team members:', err);
        return res.status(500).json({
          success: false,
          message: 'Failed to fetch team members'
        });
      }
      console.log(`‚úÖ Retrieved ${members.length} members for team ${teamName}`);

      // Get file counts for each member
      const memberPromises = members.map(member => {
        return new Promise((resolve) => {
          db.get(
            'SELECT COUNT(*) as totalFiles FROM files WHERE user_id = ?',
            [member.id],
            (err, result) => {
              if (!err && result) {
                member.totalFiles = result.totalFiles || 0;
              } else {
                member.totalFiles = 0;
              }
              resolve(member);
            }
          );
        });
      });

      Promise.all(memberPromises).then(membersWithFiles => {
        res.json({
          success: true,
          members: membersWithFiles
        });
      });
    }
  );
});

module.exports = router;


/***/ }),

/***/ 26106:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

const fs = (__nccwpck_require__(79896).promises);
const path = __nccwpck_require__(16928);
const { db, USE_MYSQL } = __nccwpck_require__(5024);

/**
 * File System Indexer Service
 * Builds and maintains a searchable index of all files in the root directory
 */

class FileIndexer {
  constructor() {
    this.isIndexing = false;
    this.indexProgress = { current: 0, total: 0, currentPath: '' };
  }

  /**
   * Initialize the file_index table
   */
  async initializeIndexTable() {
    console.log('üîß Initializing file_index table...');

    if (USE_MYSQL) {
      // --- CORRECTED SQL: Changed TIMESTAMP, CHARSET, COLLATE, and removed FULLTEXT INDEX ---
      const createTableSQL = `
        CREATE TABLE IF NOT EXISTS file_index (
          id INT PRIMARY KEY AUTO_INCREMENT,
          file_name VARCHAR(500) NOT NULL,
          file_path TEXT NOT NULL,
          parent_path TEXT NOT NULL,
          full_path TEXT NOT NULL,
          file_type VARCHAR(50),
          is_directory BOOLEAN NOT NULL,
          file_size BIGINT,
          modified_date DATETIME,
          indexed_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP, -- Changed DATETIME to TIMESTAMP
          INDEX idx_file_name (file_name),
          INDEX idx_parent_path (parent_path(255)),
          INDEX idx_file_type (file_type),
          INDEX idx_is_directory (is_directory)
          -- FULLTEXT INDEX idx_fulltext_name (file_name) -- Removed for older MySQL compatibility
        ) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci -- Changed from utf8mb4
      `;

      await db.query(createTableSQL);
      console.log('‚úÖ MySQL file_index table created/verified');

    } else {
      const createTableSQL = `
        CREATE TABLE IF NOT EXISTS file_index (
          id INTEGER PRIMARY KEY AUTOINCREMENT,
          file_name TEXT NOT NULL,
          file_path TEXT NOT NULL,
          parent_path TEXT NOT NULL,
          full_path TEXT NOT NULL,
          file_type TEXT,
          is_directory INTEGER NOT NULL,
          file_size INTEGER,
          modified_date DATETIME,
          indexed_at DATETIME DEFAULT CURRENT_TIMESTAMP
        )
      `;

      await new Promise((resolve, reject) => {
        db.run(createTableSQL, (err) => {
          if (err) {
            reject(err);
          } else {
            resolve();
          }
        });
      });

      // Create indexes
      const indexes = [
        'CREATE INDEX IF NOT EXISTS idx_file_name ON file_index(file_name)',
        'CREATE INDEX IF NOT EXISTS idx_parent_path ON file_index(parent_path)',
        'CREATE INDEX IF NOT EXISTS idx_file_type ON file_index(file_type)',
        'CREATE INDEX IF NOT EXISTS idx_is_directory ON file_index(is_directory)'
      ];

      for (const indexSQL of indexes) {
        await new Promise((resolve, reject) => {
          db.run(indexSQL, (err) => {
            if (err) {
              reject(err);
            } else {
              resolve();
            }
          });
        });
      }

      console.log('‚úÖ SQLite file_index table created/verified');
    }
  }

  /**
   * Clear all entries from the file index
   */
  async clearIndex() {
    console.log('üóëÔ∏è  Clearing file index...');

    if (USE_MYSQL) {
      await db.query('DELETE FROM file_index');
    } else {
      await new Promise((resolve, reject) => {
        db.run('DELETE FROM file_index', (err) => {
          if (err) {
            reject(err);
          } else {
            resolve();
          }
        });
      });
    }

    console.log('‚úÖ File index cleared');
  }

  /**
   * Build complete index of the root directory
   */
  async buildIndex(rootDirectory) {
    if (this.isIndexing) {
      throw new Error('Indexing is already in progress');
    }

    this.isIndexing = true;
    this.indexProgress = { current: 0, total: 0, currentPath: '' };

    console.log('üìÅ Starting file system indexing...');
    console.log('üìÇ Root directory:', rootDirectory);

    const startTime = Date.now();

    try {
      // Clear existing index
      await this.clearIndex();

      // Count total items first (for progress tracking)
      this.indexProgress.total = await this.countItems(rootDirectory);
      console.log(`üìä Total items to index: ${this.indexProgress.total}`);

      // Build the index
      await this.indexDirectory(rootDirectory, rootDirectory, '/');

      const duration = ((Date.now() - startTime) / 1000).toFixed(2);
      console.log(`‚úÖ Indexing complete! Indexed ${this.indexProgress.current} items in ${duration}s`);

      return {
        success: true,
        itemsIndexed: this.indexProgress.current,
        duration: duration
      };

    } catch (error) {
      console.error('‚ùå Error during indexing:', error);
      throw error;
    } finally {
      this.isIndexing = false;
    }
  }

  /**
   * Count total items in directory (for progress tracking)
   */
  async countItems(dirPath) {
    let count = 0;

    try {
      const items = await fs.readdir(dirPath);
      count += items.length;

      for (const item of items) {
        if (item.startsWith('.')) {
          continue;
        }

        try {
          const fullPath = path.join(dirPath, item);
          const stats = await fs.stat(fullPath);

          if (stats.isDirectory()) {
            count += await this.countItems(fullPath);
          }
        } catch (err) {
          // Skip inaccessible items
        }
      }
    } catch (err) {
      // Skip inaccessible directories
    }

    return count;
  }

  /**
   * Recursively index a directory
   */
  async indexDirectory(rootDirectory, currentPath, relativePath) {
    try {
      const items = await fs.readdir(currentPath);

      for (const item of items) {
        // Skip hidden files
        if (item.startsWith('.')) {
          continue;
        }

        try {
          const fullPath = path.join(currentPath, item);
          const stats = await fs.stat(fullPath);
          const isDirectory = stats.isDirectory();

          // Build relative path
          const itemRelativePath = relativePath === '/' ? `/${item}` : `${relativePath}/${item}`;

          // Insert into database
          await this.insertIndexEntry({
            fileName: item,
            filePath: itemRelativePath,
            parentPath: relativePath,
            fullPath: fullPath,
            fileType: isDirectory ? null : path.extname(item).toLowerCase().slice(1) || 'unknown',
            isDirectory: isDirectory,
            fileSize: isDirectory ? null : stats.size,
            modifiedDate: stats.mtime
          });

          this.indexProgress.current++;
          this.indexProgress.currentPath = itemRelativePath;

          // Log progress every 100 items
          if (this.indexProgress.current % 100 === 0) {
            console.log(`üìä Progress: ${this.indexProgress.current}/${this.indexProgress.total} - ${itemRelativePath}`);
          }

          // Recursively index subdirectories
          if (isDirectory) {
            await this.indexDirectory(rootDirectory, fullPath, itemRelativePath);
          }

        } catch (itemError) {
          console.error(`‚ö†Ô∏è  Error indexing ${item}:`, itemError.message);
          // Continue with next item
        }
      }
    } catch (dirError) {
      console.error(`‚ö†Ô∏è  Error reading directory ${currentPath}:`, dirError.message);
    }
  }

  /**
   * Insert a single entry into the index
   */
  async insertIndexEntry(entry) {
    if (USE_MYSQL) {
      await db.query(
        `INSERT INTO file_index 
         (file_name, file_path, parent_path, full_path, file_type, is_directory, file_size, modified_date)
         VALUES (?, ?, ?, ?, ?, ?, ?, ?)`,
        [
          entry.fileName,
          entry.filePath,
          entry.parentPath,
          entry.fullPath,
          entry.fileType,
          entry.isDirectory ? 1 : 0,
          entry.fileSize,
          entry.modifiedDate
        ]
      );
    } else {
      await new Promise((resolve, reject) => {
        db.run(
          `INSERT INTO file_index 
           (file_name, file_path, parent_path, full_path, file_type, is_directory, file_size, modified_date)
           VALUES (?, ?, ?, ?, ?, ?, ?, ?)`,
          [
            entry.fileName,
            entry.filePath,
            entry.parentPath,
            entry.fullPath,
            entry.fileType,
            entry.isDirectory ? 1 : 0,
            entry.fileSize,
            entry.modifiedDate
          ],
          (err) => {
            if (err) {
              reject(err);
            } else {
              resolve();
            }
          }
        );
      });
    }
  }

  /**
   * Search the index
   */
  async search(searchQuery, searchPath = '/') {
    const searchLower = searchQuery.toLowerCase();

    if (USE_MYSQL) {
      // MySQL with LIKE search (fallback due to removed FULLTEXT index for older MySQL)
      const results = await db.query(
        `SELECT * FROM file_index 
         WHERE file_name LIKE ?
         AND (parent_path = ? OR parent_path LIKE ?)
         ORDER BY 
           CASE WHEN is_directory = 1 THEN 0 ELSE 1 END,
           file_name
         LIMIT 500`,
        [`%${searchQuery}%`, searchPath, `${searchPath}/%`]
      );
      return results;

    } else {
      // SQLite with LIKE search
      return new Promise((resolve, reject) => {
        db.all(
          `SELECT * FROM file_index 
           WHERE LOWER(file_name) LIKE ?
           AND (parent_path = ? OR parent_path LIKE ?)
           ORDER BY 
             CASE WHEN is_directory = 1 THEN 0 ELSE 1 END,
             file_name
           LIMIT 500`,
          [`%${searchLower}%`, searchPath, `${searchPath}/%`],
          (err, rows) => {
            if (err) {
              reject(err);
            } else {
              resolve(rows);
            }
          }
        );
      });
    }
  }

  /**
   * Get indexing progress
   */
  getProgress() {
    return {
      isIndexing: this.isIndexing,
      progress: this.indexProgress
    };
  }

  /**
   * Get index statistics
   */
  async getStats() {
    if (USE_MYSQL) {
      const result = await db.query(
        `SELECT 
           COUNT(*) as total_items,
           SUM(CASE WHEN is_directory = 1 THEN 1 ELSE 0 END) as total_directories,
           SUM(CASE WHEN is_directory = 0 THEN 1 ELSE 0 END) as total_files,
           MAX(indexed_at) as last_indexed
         FROM file_index`
      );
      return result[0];

    } else {
      return new Promise((resolve, reject) => {
        db.get(
          `SELECT 
             COUNT(*) as total_items,
             SUM(CASE WHEN is_directory = 1 THEN 1 ELSE 0 END) as total_directories,
             SUM(CASE WHEN is_directory = 0 THEN 1 ELSE 0 END) as total_files,
             MAX(indexed_at) as last_indexed
           FROM file_index`,
          (err, row) => {
            if (err) {
              reject(err);
            } else {
              resolve(row || { total_items: 0, total_directories: 0, total_files: 0, last_indexed: null });
            }
          }
        );
      });
    }
  }
}

// Export singleton instance
module.exports = new FileIndexer();

/***/ }),

/***/ 22686:
/***/ ((module) => {

// In-memory cache with TTL
const cache = new Map();
const CACHE_TTL = 5 * 60 * 1000; // 5 minutes

function setCache(key, value) {
  cache.set(key, { value, timestamp: Date.now() });
}

function getCache(key) {
  const item = cache.get(key);
  if (item && (Date.now() - item.timestamp) < CACHE_TTL) {
    return item.value;
  }
  cache.delete(key);
  return null;
}

function clearCache(key) {
  if (key) {
    cache.delete(key);
  } else {
    cache.clear();
  }
}

module.exports = {
  setCache,
  getCache,
  clearCache
};


/***/ }),

/***/ 72572:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

const nodemailer = __nccwpck_require__(44329);

// Email configuration
const emailConfig = {
  host: process.env.EMAIL_HOST || 'smtp.gmail.com',
  port: process.env.EMAIL_PORT || 587,
  secure: false, // true for 465, false for other ports
  auth: {
    user: process.env.EMAIL_USER,
    pass: process.env.EMAIL_PASSWORD
  }
};

// Create reusable transporter
let transporter = null;

function getTransporter() {
  if (!transporter) {
    transporter = nodemailer.createTransport(emailConfig);
  }
  return transporter;
}

/**
 * Send password reset confirmation email to user
 * @param {string} userEmail - User's email address
 * @param {string} userName - User's full name
 * @param {string} adminName - Admin who reset the password
 */
async function sendPasswordResetEmail(userEmail, userName, adminName) {
  try {
    // Check if email is configured
    if (!process.env.EMAIL_USER || !process.env.EMAIL_PASSWORD) {
      console.log('‚ö†Ô∏è Email not configured - skipping email notification');
      return { success: false, message: 'Email not configured' };
    }

    const mailOptions = {
      from: `"KMTI File Management System" <${process.env.EMAIL_USER}>`,
      to: userEmail,
      subject: 'Your Password Has Been Reset',
      html: `
        <!DOCTYPE html>
        <html>
        <head>
          <style>
            body { font-family: Arial, sans-serif; line-height: 1.6; color: #333; }
            .container { max-width: 600px; margin: 0 auto; padding: 20px; }
            .header { background: #3b82f6; color: white; padding: 20px; text-align: center; border-radius: 8px 8px 0 0; }
            .content { background: #f9fafb; padding: 30px; border-radius: 0 0 8px 8px; }
            .button { display: inline-block; background: #3b82f6; color: white; padding: 12px 24px; text-decoration: none; border-radius: 6px; margin: 20px 0; }
            .footer { text-align: center; margin-top: 20px; color: #6b7280; font-size: 12px; }
          </style>
        </head>
        <body>
          <div class="container">
            <div class="header">
              <h1>üîê Password Reset Confirmation</h1>
            </div>
            <div class="content">
              <p>Hello ${userName},</p>
              
              <p>Your password has been successfully reset by <strong>${adminName}</strong>.</p>
              
              <p>You can now log in to the KMTI File Management System with your new password.</p>
              
              <p><strong>Important Security Notes:</strong></p>
              <ul>
                <li>If you did not request this password reset, please contact your administrator immediately.</li>
                <li>We recommend changing your password after logging in.</li>
                <li>Never share your password with anyone.</li>
              </ul>
              
              <p>If you have any questions or concerns, please contact your system administrator.</p>
              
              <p>Best regards,<br>KMTI File Management System</p>
            </div>
            <div class="footer">
              <p>This is an automated message. Please do not reply to this email.</p>
            </div>
          </div>
        </body>
        </html>
      `,
      text: `
Hello ${userName},

Your password has been successfully reset by ${adminName}.

You can now log in to the KMTI File Management System with your new password.

Important Security Notes:
- If you did not request this password reset, please contact your administrator immediately.
- We recommend changing your password after logging in.
- Never share your password with anyone.

If you have any questions or concerns, please contact your system administrator.

Best regards,
KMTI File Management System

---
This is an automated message. Please do not reply to this email.
      `
    };

    const info = await getTransporter().sendMail(mailOptions);
    console.log('‚úÖ Password reset email sent:', info.messageId);
    return { success: true, messageId: info.messageId };

  } catch (error) {
    console.error('‚ùå Error sending password reset email:', error.message);
    return { success: false, error: error.message };
  }
}

/**
 * Send password reset link email to user (self-service)
 * @param {string} userEmail - User's email address
 * @param {string} userName - User's full name
 * @param {string} resetToken - Password reset token
 */
async function sendPasswordResetLinkEmail(userEmail, userName, resetToken) {
  try {
    // Check if email is configured
    if (!process.env.EMAIL_USER || !process.env.EMAIL_PASSWORD) {
      console.log('‚ö†Ô∏è Email not configured - skipping reset link email');
      return { success: false, message: 'Email not configured' };
    }

    const resetLink = `http://localhost:5173/#/reset-password?token=${resetToken}`;

    const mailOptions = {
      from: `"KMTI File Management System" <${process.env.EMAIL_USER}>`,
      to: userEmail,
      subject: 'Reset Your Password - KMTI File Management',
      html: `
        <!DOCTYPE html>
        <html>
        <head>
          <style>
            body { font-family: Arial, sans-serif; line-height: 1.6; color: #333; }
            .container { max-width: 600px; margin: 0 auto; padding: 20px; }
            .header { background: #3b82f6; color: white; padding: 20px; text-align: center; border-radius: 8px 8px 0 0; }
            .content { background: #f9fafb; padding: 30px; border-radius: 0 0 8px 8px; }
            .button { display: inline-block; background: #3b82f6; color: white; padding: 14px 28px; text-decoration: none; border-radius: 6px; margin: 20px 0; font-weight: bold; }
            .button:hover { background: #2563eb; }
            .footer { text-align: center; margin-top: 20px; color: #6b7280; font-size: 12px; }
            .warning { background: #fef3c7; border-left: 4px solid #f59e0b; padding: 12px; margin: 20px 0; }
            .code { background: #f3f4f6; padding: 8px 12px; border-radius: 4px; font-family: monospace; display: inline-block; margin: 10px 0; }
          </style>
        </head>
        <body>
          <div class="container">
            <div class="header">
              <h1>üîê Reset Your Password</h1>
            </div>
            <div class="content">
              <p>Hello ${userName},</p>
              
              <p>We received a request to reset your password for the KMTI File Management System.</p>
              
              <p>Click the button below to reset your password:</p>
              
              <p style="text-align: center;">
                <a href="${resetLink}" class="button">Reset Password</a>
              </p>
              
              <p>Or copy and paste this link into your browser:</p>
              <div class="code">${resetLink}</div>
              
              <div class="warning">
                <strong>‚ö†Ô∏è Important:</strong>
                <ul style="margin: 8px 0;">
                  <li>This link will expire in <strong>1 hour</strong></li>
                  <li>This link can only be used <strong>once</strong></li>
                  <li>If you didn't request this, please ignore this email or contact your administrator</li>
                </ul>
              </div>
              
              <p><strong>Alternative:</strong> If you prefer, you can also contact your administrator to reset your password manually.</p>
              
              <p>Best regards,<br>KMTI File Management System</p>
            </div>
            <div class="footer">
              <p>This is an automated message. Please do not reply to this email.</p>
              <p>If you have any questions, please contact your system administrator.</p>
            </div>
          </div>
        </body>
        </html>
      `,
      text: `
Hello ${userName},

We received a request to reset your password for the KMTI File Management System.

Click this link to reset your password:
${resetLink}

IMPORTANT:
- This link will expire in 1 hour
- This link can only be used once
- If you didn't request this, please ignore this email or contact your administrator

Alternative: If you prefer, you can also contact your administrator to reset your password manually.

Best regards,
KMTI File Management System

---
This is an automated message. Please do not reply to this email.
If you have any questions, please contact your system administrator.
      `
    };

    const info = await getTransporter().sendMail(mailOptions);
    console.log('‚úÖ Password reset link email sent:', info.messageId);
    return { success: true, messageId: info.messageId };

  } catch (error) {
    console.error('‚ùå Error sending password reset link email:', error.message);
    return { success: false, error: error.message };
  }
}

/**
 * Test email configuration
 */
async function testEmailConfig() {
  try {
    await getTransporter().verify();
    console.log('‚úÖ Email server is ready');
    return true;
  } catch (error) {
    console.error('‚ùå Email server error:', error.message);
    return false;
  }
}

module.exports = {
  sendPasswordResetEmail,
  sendPasswordResetLinkEmail,
  testEmailConfig
};


/***/ }),

/***/ 41987:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

const path = __nccwpck_require__(16928);
const { categorizeFileType } = __nccwpck_require__(51099);

// Helper function to get parent path
function getParentPath(currentPath) {
  const parts = currentPath.split('/').filter(p => p);
  if (parts.length <= 1) {
    return '/';
  }
  return '/' + parts.slice(0, -1).join('/');
}

// Helper function to format file size
function formatFileSize(bytes) {
  if (bytes === 0) {
    return '0 B';
  }
  const k = 1024;
  const sizes = ['B', 'KB', 'MB', 'GB', 'TB'];
  const i = Math.floor(Math.log(bytes) / Math.log(k));
  return parseFloat((bytes / Math.pow(k, i)).toFixed(1)) + ' ' + sizes[i];
}

// Function to truncate names to prevent UI misalignment
function truncateName(name, maxLength = 50) {
  if (name.length <= maxLength) {
    return name;
  }
  const extension = path.extname(name);
  const nameWithoutExt = path.basename(name, extension);
  const truncatedName = nameWithoutExt.slice(0, maxLength - extension.length - 3);
  return truncatedName + '...' + extension;
}

// Get file type description based on mime type or file extension
function getFileTypeDescription(mimeType, filename = '') {
  // First, try to get extension from filename if provided
  let extension = '';
  if (filename) {
    extension = path.extname(filename).replace(/^\./,  '').toLowerCase();
  }

  // If we have a valid extension, use our categorization system
  if (extension) {
    const category = categorizeFileType(extension);
    // Return the category unless it's just the uppercase extension (unknown type)
    if (category !== extension.toUpperCase()) {
      return category;
    }
  }

  // Fallback to MIME type mapping for common types
  const types = {
    'application/pdf': 'PDF Document',
    'application/msword': 'Word Document',
    'application/vnd.openxmlformats-officedocument.wordprocessingml.document': 'Word Document',
    'application/vnd.ms-excel': 'Excel Spreadsheet',
    'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet': 'Excel Spreadsheet',
    'text/plain': 'Text File',
    'image/jpeg': 'JPEG Image',
    'image/png': 'PNG Image',
    'application/zip': 'ZIP Archive'
  };

  if (types[mimeType]) {
    return types[mimeType];
  }

  // If we still don't have a match, return the extension in a readable format
  if (extension) {
    return `${extension.toUpperCase()} File`;
  }

  return 'Unknown File Type';
}

module.exports = {
  getParentPath,
  formatFileSize,
  truncateName,
  getFileTypeDescription
};


/***/ }),

/***/ 51099:
/***/ ((module) => {

/**
 * File Type Categorization Utility
 * Categorizes file extensions into meaningful groups for dashboard charts
 */

/**
 * Get the category for a file type/extension
 * @param {string} fileType - File extension (with or without dot)
 * @returns {string} - Category name
 */
function categorizeFileType(fileType) {
  if (!fileType) {
    return 'Unknown';
  }

  // Normalize: remove leading dot and convert to lowercase
  const ext = fileType.replace(/^\./, '').toLowerCase().trim();

  // Document files
  const documents = ['pdf', 'doc', 'docx', 'txt', 'rtf', 'odt', 'pages'];
  if (documents.includes(ext)) {
    return 'Documents';
  }

  // Spreadsheets
  const spreadsheets = ['xls', 'xlsx', 'csv', 'ods', 'numbers'];
  if (spreadsheets.includes(ext)) {
    return 'Spreadsheets';
  }

  // Presentations
  const presentations = ['ppt', 'pptx', 'key', 'odp'];
  if (presentations.includes(ext)) {
    return 'Presentations';
  }

  // Images
  const images = ['jpg', 'jpeg', 'png', 'gif', 'bmp', 'svg', 'webp', 'tiff', 'tif', 'ico', 'heic', 'heif'];
  if (images.includes(ext)) {
    return 'Images';
  }

  // Videos
  const videos = ['mp4', 'avi', 'mov', 'wmv', 'flv', 'mkv', 'webm', 'mpeg', 'mpg', 'm4v'];
  if (videos.includes(ext)) {
    return 'Videos';
  }

  // Audio
  const audio = ['mp3', 'wav', 'flac', 'aac', 'ogg', 'wma', 'm4a', 'opus'];
  if (audio.includes(ext)) {
    return 'Audio';
  }

  // CAD & 3D Design Files
  const cad = [
    'dwg',      // AutoCAD Drawing
    'dxf',      // Drawing Exchange Format
    'dwf',      // Design Web Format
    'dwt',      // AutoCAD Template
    'sldprt',   // SolidWorks Part
    'sldasm',   // SolidWorks Assembly
    'slddrw',   // SolidWorks Drawing
    'step',     // STEP 3D Model
    'stp',      // STEP 3D Model
    'iges',     // IGES 3D Model
    'igs',      // IGES 3D Model
    'stl',      // Stereolithography
    'obj',      // Wavefront OBJ
    'fbx',      // Autodesk FBX
    '3ds',      // 3D Studio
    'sat',      // ACIS SAT
    'ipt',      // Autodesk Inventor Part
    'iam',      // Autodesk Inventor Assembly
    'idw',      // Autodesk Inventor Drawing
    'prt',      // Pro/ENGINEER Part
    'asm',      // Pro/ENGINEER Assembly
    'drw',      // Pro/ENGINEER Drawing
    'catpart',  // CATIA Part
    'catproduct', // CATIA Product
    'catdrawing', // CATIA Drawing
    'x_t',      // Parasolid
    'x_b'       // Parasolid Binary
  ];
  if (cad.includes(ext)) {
    return 'CAD/3D Files';
  }

  // Engineering Files
  const engineering = [
    'icd',      // Interface Control Document
    'bom',      // Bill of Materials
    'sch',      // Schematic
    'pcb',      // PCB Design
    'gerber',   // Gerber files
    'gbr',      // Gerber files
    'cam',      // CAM files
    'nc',       // CNC files
    'gcode',    // G-code
    'plt',      // HPGL Plot file
    'dxp',      // Altium Designer
    'schdoc',   // Altium Schematic
    'pcbdoc',   // Altium PCB
    'brd',      // Eagle Board
    'lib',      // Library files
    'mod',      // Module files
    'kicad_pcb', // KiCad PCB
    'kicad_sch', // KiCad Schematic
    'kicad_mod', // KiCad Module
    'pro'       // Project files
  ];
  if (engineering.includes(ext)) {
    return 'Engineering Files';
  }

  // Archives
  const archives = ['zip', 'rar', '7z', 'tar', 'gz', 'bz2', 'xz', 'iso'];
  if (archives.includes(ext)) {
    return 'Archives';
  }

  // Code files
  const code = [
    'js', 'jsx', 'ts', 'tsx', 'py', 'java', 'cpp', 'c', 'h', 'cs',
    'php', 'rb', 'go', 'rs', 'swift', 'kt', 'scala', 'r', 'm', 'sh',
    'html', 'css', 'scss', 'sass', 'less', 'json', 'xml', 'yaml', 'yml',
    'sql', 'md', 'markdown'
  ];
  if (code.includes(ext)) {
    return 'Code';
  }

  // Executables & Binaries
  const executables = ['exe', 'dll', 'so', 'dylib', 'app', 'dmg', 'pkg', 'deb', 'rpm', 'msi'];
  if (executables.includes(ext)) {
    return 'Executables';
  }

  // If no match found, return the extension itself (capitalized)
  return ext.toUpperCase();
}

/**
 * Process file types array from database and categorize them
 * @param {Array} fileTypes - Array of {file_type, count} objects
 * @returns {Array} - Array of {file_type (category), count} objects
 */
function categorizeFileTypes(fileTypes) {
  if (!Array.isArray(fileTypes) || fileTypes.length === 0) {
    return [];
  }

  // Create a map to aggregate counts by category
  const categoryMap = new Map();

  fileTypes.forEach(item => {
    const category = categorizeFileType(item.file_type);
    const currentCount = categoryMap.get(category) || 0;
    categoryMap.set(category, currentCount + (item.count || 0));
  });

  // Convert map back to array and sort by count descending
  return Array.from(categoryMap.entries())
    .map(([file_type, count]) => ({ file_type, count }))
    .sort((a, b) => b.count - a.count);
}

module.exports = {
  categorizeFileType,
  categorizeFileTypes
};


/***/ }),

/***/ 43939:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

const fs = (__nccwpck_require__(79896).promises);
const path = __nccwpck_require__(16928);

/**
 * Safely move uploaded file to user folder with proper error handling
 * Handles race conditions, cross-device moves, and async operations
 * FIXED: Now async, no blocking, handles race conditions
 */
async function moveToUserFolder(tempPath, username, originalFilename) {
  console.log('üì¶ moveToUserFolder called with:');
  console.log('   tempPath:', tempPath);
  console.log('   username:', username);
  console.log('   originalFilename:', originalFilename);

  const { uploadsDir } = __nccwpck_require__(62489);
  const userDir = path.join(uploadsDir, username);
  console.log('   uploadsDir:', uploadsDir);
  console.log('   userDir:', userDir);

  // CRITICAL FIX: recursive: true handles race condition
  // If folder already exists from parallel request, this won't throw
  try {
    await fs.mkdir(userDir, { recursive: true });
    console.log(`‚úÖ User folder created/verified: ${userDir}`);
  } catch (mkdirError) {
    console.error('‚ùå Failed to create user folder:', mkdirError);
    throw new Error(`Failed to create user folder: ${mkdirError.message}`);
  }

  // Decode and sanitize filename
  let decodedFilename = originalFilename;
  try {
    // Check for garbled UTF-8 patterns
    if (/[√É¬¢√¢¬¨√¢¬¢√É¬§√Ç¬∏√¢‚Äö¬¨√É¬¶√¢‚Ç¨"‚Ä°√É¬®√Ç¬±√Ç¬°]/.test(originalFilename)) {
      const buffer = Buffer.from(originalFilename, 'binary');
      decodedFilename = buffer.toString('utf8');
      console.log('üìù Fixed UTF-8:', originalFilename, '->', decodedFilename);
    }
  } catch (e) {
    console.warn('‚ö†Ô∏è Could not decode filename:', e.message);
  }

  // Sanitize for Windows
  const sanitizedFilename = sanitizeFilename(decodedFilename);
  const finalPath = path.join(userDir, sanitizedFilename);
  console.log('üìç Final target path:', finalPath);

  // Verify source exists
  console.log('üîç Checking if temp file exists...');
  try {
    await fs.access(tempPath);
    console.log('‚úÖ Temp file exists');
    
    // Get file stats for debugging
    const stats = await fs.stat(tempPath);
    console.log(`   File size: ${stats.size} bytes`);
    console.log(`   Is file: ${stats.isFile()}`);
  } catch (error) {
    console.error('‚ùå Temp file not found at:', tempPath);
    throw new Error(`Temp file not found: ${tempPath}`);
  }

  // CRITICAL FIX: Async move with fallback for cross-device
  console.log('üöö Attempting to move file...');
  try {
    // Try rename first (fast, atomic on same filesystem)
    await fs.rename(tempPath, finalPath);
    console.log(`‚úÖ Moved via rename: ${finalPath}`);
  } catch (renameError) {
    console.log('‚ö†Ô∏è Rename failed:', renameError.code, renameError.message);
    // Handle cross-device link error (EXDEV)
    if (renameError.code === 'EXDEV') {
      console.log('üîÑ Cross-device detected, using copy+delete');
      try {
        await fs.copyFile(tempPath, finalPath);
        console.log('‚úÖ Copy successful');
        await fs.unlink(tempPath);
        console.log('‚úÖ Temp file deleted');
        console.log(`‚úÖ Moved via copy: ${finalPath}`);
      } catch (copyError) {
        console.error('‚ùå Copy failed:', copyError);
        throw new Error(`Failed to copy file: ${copyError.message}`);
      }
    } else {
      console.error('‚ùå Rename failed with unexpected error:', renameError);
      throw new Error(`Failed to move file: ${renameError.message}`);
    }
  }

  // Final verification
  console.log('üîç Verifying file exists at final location...');
  try {
    await fs.access(finalPath);
    const stats = await fs.stat(finalPath);
    console.log('‚úÖ File verified at final location');
    console.log(`   Final file size: ${stats.size} bytes`);
  } catch (verifyError) {
    console.error('‚ùå CRITICAL: File not found after move operation!');
    console.error('   Expected at:', finalPath);
    throw new Error('File verification failed after move');
  }

  return finalPath;
}

/**
 * Sanitize filename for Windows filesystem
 * Removes forbidden characters and prevents path traversal
 */
function sanitizeFilename(filename) {
  // Windows forbidden: < > : " / \ | ? *
  // Control chars: 0x00-0x1F
  const sanitized = filename
    .replace(/[<>:"/\\|?*\x00-\x1F]/g, '_')
    .replace(/^\.+|\.+$/g, '_')  // No leading/trailing dots
    .trim();

  return sanitized || 'unnamed_file';
}

/**
 * Safely delete file with verification
 * FIXED: Now async, doesn't block event loop
 * Returns object with success status and additional info
 */
async function safeDeleteFile(filePath) {
  try {
    await fs.access(filePath);
    await fs.unlink(filePath);
    console.log(`‚úÖ Deleted: ${filePath}`);
    return { success: true, message: 'File deleted successfully' };
  } catch (error) {
    if (error.code === 'ENOENT') {
      console.log(`‚ÑπÔ∏è File already deleted or not found: ${filePath}`);
      return { success: true, notFound: true, message: 'File not found (already deleted)' };
    }
    console.error(`‚ùå Failed to delete ${filePath}:`, error);
    return { success: false, error: error, message: error.message };
  }
}

/**
 * Check if directory exists (async)
 */
async function directoryExists(dirPath) {
  try {
    const stats = await fs.stat(dirPath);
    return stats.isDirectory();
  } catch (error) {
    return false;
  }
}

/**
 * Ensure directory exists, create if needed (async, race-safe)
 */
async function ensureDirectory(dirPath) {
  try {
    await fs.mkdir(dirPath, { recursive: true });
    return true;
  } catch (error) {
    console.error(`Failed to ensure directory ${dirPath}:`, error);
    return false;
  }
}

module.exports = {
  moveToUserFolder,
  sanitizeFilename,
  safeDeleteFile,
  directoryExists,
  ensureDirectory
};


/***/ }),

/***/ 46534:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

const winston = __nccwpck_require__(34240);
const path = __nccwpck_require__(16928);

// Define log levels
const levels = {
  error: 0,
  warn: 1,
  info: 2,
  http: 3,
  debug: 4
};

// Define colors for each level
const colors = {
  error: 'red',
  warn: 'yellow',
  info: 'green',
  http: 'magenta',
  debug: 'blue'
};

winston.addColors(colors);

// Determine log level based on environment
const level = () => {
  const env = process.env.NODE_ENV || 'development';
  const isDevelopment = env === 'development';
  return isDevelopment ? 'debug' : 'info';
};

// Define log format
const format = winston.format.combine(
  winston.format.timestamp({ format: 'YYYY-MM-DD HH:mm:ss' }),
  winston.format.errors({ stack: true }),
  winston.format.splat(),
  winston.format.json()
);

// Console format with colors
const consoleFormat = winston.format.combine(
  winston.format.colorize({ all: true }),
  winston.format.timestamp({ format: 'YYYY-MM-DD HH:mm:ss' }),
  winston.format.printf(
    (info) => `${info.timestamp} [${info.level}]: ${info.message}${info.stack ? '\n' + info.stack : ''}`
  )
);

// Define transports
const transports = [
  // Console transport
  new winston.transports.Console({
    format: consoleFormat
  }),

  // Error log file
  new winston.transports.File({
    filename: __nccwpck_require__.ab + "error.log",
    level: 'error',
    format,
    maxsize: 5242880, // 5MB
    maxFiles: 5
  }),

  // Combined log file
  new winston.transports.File({
    filename: __nccwpck_require__.ab + "combined.log",
    format,
    maxsize: 5242880, // 5MB
    maxFiles: 5
  })
];

// Create logger instance
const logger = winston.createLogger({
  level: level(),
  levels,
  format,
  transports,
  exitOnError: false
});

// Create logs directory if it doesn't exist
const fs = __nccwpck_require__(79896);
const logsDir = __nccwpck_require__.ab + "logs";
if (!fs.existsSync(__nccwpck_require__.ab + "logs")) {
  fs.mkdirSync(__nccwpck_require__.ab + "logs", { recursive: true });
}

/**
 * Log activity to database (backward compatibility)
 * @param {Object} db - Database instance
 * @param {number} userId - User ID
 * @param {string} username - Username
 * @param {string} role - User role
 * @param {string} team - User team
 * @param {string} action - Action description
 */
function logActivity(db, userId, username, role, team, action) {
  const timestamp = new Date().toISOString();

  // Log to Winston
  logger.info('Activity', {
    userId,
    username,
    role,
    team,
    action,
    timestamp
  });

  // Log to database
  const query = `
    INSERT INTO activity_logs (user_id, username, role, team, activity, timestamp)
    VALUES (?, ?, ?, ?, ?, ?)
  `;
  // Check if we're using MySQL or SQLite
  const USE_MYSQL = (__nccwpck_require__(5024).USE_MYSQL);

  if (USE_MYSQL) {
    // MySQL: Use activity column instead of action
    const mysqlDb = __nccwpck_require__(55364);
    mysqlDb.query(
      'INSERT INTO activity_logs (user_id, username, role, team, activity, timestamp) VALUES (?, ?, ?, ?, ?, ?)',
      [userId, username, role, team, action, timestamp]
    ).catch(err => {
      logger.error('Failed to log activity to MySQL database', {
        error: err.message,
        userId,
        action
      });
    });
  } else {
    // SQLite: Use action column
    const query = `
      INSERT INTO activity_logs (user_id, username, role, team, action, timestamp)
      VALUES (?, ?, ?, ?, ?, ?)
    `;

    db.run(query, [userId, username, role, team, action, timestamp], (err) => {
      if (err) {
        logger.error('Failed to log activity to database', {
          error: err.message,
          userId,
          action
        });
      }
    });
  }
}

/**
 * Log HTTP request
 */
function logRequest(req, res, next) {
  const start = Date.now();

  res.on('finish', () => {
    const duration = Date.now() - start;
    const message = `${req.method} ${req.originalUrl} ${res.statusCode} - ${duration}ms`;

    if (res.statusCode >= 500) {
      logger.error(message, {
        method: req.method,
        url: req.originalUrl,
        status: res.statusCode,
        duration,
        ip: req.ip,
        userAgent: req.get('user-agent')
      });
    } else if (res.statusCode >= 400) {
      logger.warn(message, {
        method: req.method,
        url: req.originalUrl,
        status: res.statusCode,
        duration,
        ip: req.ip
      });
    } else {
      logger.http(message, {
        method: req.method,
        url: req.originalUrl,
        status: res.statusCode,
        duration
      });
    }
  });

  next();
}

/**
 * Log error with context
 */
function logError(error, context = {}) {
  logger.error(error.message, {
    error: error.message,
    stack: error.stack,
    ...context
  });
}

/**
 * Log info message
 */
function logInfo(message, meta = {}) {
  logger.info(message, meta);
}

/**
 * Log warning message
 */
function logWarn(message, meta = {}) {
  logger.warn(message, meta);
}

/**
 * Log debug message
 */
function logDebug(message, meta = {}) {
  logger.debug(message, meta);
}

/**
 * Log file status change to database
 * @param {Object} db - Database instance
 * @param {number} fileId - File ID
 * @param {string} oldStatus - Old status
 * @param {string} newStatus - New status
 * @param {string} oldStage - Old stage
 * @param {string} newStage - New stage
 * @param {number} userId - User ID
 * @param {string} username - Username
 * @param {string} role - User role
 * @param {string} comment - Optional comment
 */
function logFileStatusChange(db, fileId, oldStatus, newStatus, oldStage, newStage, userId, username, role, comment = '') {
  const timestamp = new Date().toISOString();

  // Log to Winston
  logger.info('File status change', {
    fileId,
    oldStatus,
    newStatus,
    oldStage,
    newStage,
    userId,
    username,
    role,
    comment,
    timestamp
  });

  // Check if we're using MySQL or SQLite
  const USE_MYSQL = (__nccwpck_require__(5024).USE_MYSQL);

  if (USE_MYSQL) {
    // MySQL
    const mysqlDb = __nccwpck_require__(55364);
    mysqlDb.query(
      'INSERT INTO file_status_history (file_id, old_status, new_status, old_stage, new_stage, changed_by_id, changed_by_username, changed_by_role, comment, changed_at) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)',
      [fileId, oldStatus, newStatus, oldStage, newStage, userId, username, role, comment, timestamp]
    ).catch(err => {
      logger.error('Failed to log file status change to MySQL database', {
        error: err.message,
        fileId,
        newStatus
      });
    });
  } else {
    // SQLite
    const query = `
      INSERT INTO file_status_history (file_id, old_status, new_status, old_stage, new_stage, changed_by_id, changed_by_username, changed_by_role, comment, changed_at)
      VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
    `;

    db.run(query, [fileId, oldStatus, newStatus, oldStage, newStage, userId, username, role, comment, timestamp], (err) => {
      if (err) {
        logger.error('Failed to log file status change to database', {
          error: err.message,
          fileId,
          newStatus
        });
      }
    });
  }
}

module.exports = {
  logger,
  logActivity,
  logFileStatusChange,
  logFileStatusChange,
  logRequest,
  logError,
  logInfo,
  logWarn,
  logDebug,
  logFileStatusChange
};


/***/ }),

/***/ 15633:
/***/ ((module) => {

module.exports = eval("require")("cardinal");


/***/ }),

/***/ 73941:
/***/ ((module) => {

module.exports = eval("require")("ffi-napi");


/***/ }),

/***/ 44329:
/***/ ((module) => {

module.exports = eval("require")("nodemailer");


/***/ }),

/***/ 7919:
/***/ ((module) => {

module.exports = eval("require")("ref-napi");


/***/ }),

/***/ 90290:
/***/ ((module) => {

"use strict";
module.exports = require("async_hooks");

/***/ }),

/***/ 20181:
/***/ ((module) => {

"use strict";
module.exports = require("buffer");

/***/ }),

/***/ 35317:
/***/ ((module) => {

"use strict";
module.exports = require("child_process");

/***/ }),

/***/ 76982:
/***/ ((module) => {

"use strict";
module.exports = require("crypto");

/***/ }),

/***/ 24434:
/***/ ((module) => {

"use strict";
module.exports = require("events");

/***/ }),

/***/ 79896:
/***/ ((module) => {

"use strict";
module.exports = require("fs");

/***/ }),

/***/ 58611:
/***/ ((module) => {

"use strict";
module.exports = require("http");

/***/ }),

/***/ 65692:
/***/ ((module) => {

"use strict";
module.exports = require("https");

/***/ }),

/***/ 69278:
/***/ ((module) => {

"use strict";
module.exports = require("net");

/***/ }),

/***/ 70857:
/***/ ((module) => {

"use strict";
module.exports = require("os");

/***/ }),

/***/ 16928:
/***/ ((module) => {

"use strict";
module.exports = require("path");

/***/ }),

/***/ 932:
/***/ ((module) => {

"use strict";
module.exports = require("process");

/***/ }),

/***/ 83480:
/***/ ((module) => {

"use strict";
module.exports = require("querystring");

/***/ }),

/***/ 2203:
/***/ ((module) => {

"use strict";
module.exports = require("stream");

/***/ }),

/***/ 13193:
/***/ ((module) => {

"use strict";
module.exports = require("string_decoder");

/***/ }),

/***/ 53557:
/***/ ((module) => {

"use strict";
module.exports = require("timers");

/***/ }),

/***/ 64756:
/***/ ((module) => {

"use strict";
module.exports = require("tls");

/***/ }),

/***/ 52018:
/***/ ((module) => {

"use strict";
module.exports = require("tty");

/***/ }),

/***/ 87016:
/***/ ((module) => {

"use strict";
module.exports = require("url");

/***/ }),

/***/ 39023:
/***/ ((module) => {

"use strict";
module.exports = require("util");

/***/ }),

/***/ 43106:
/***/ ((module) => {

"use strict";
module.exports = require("zlib");

/***/ }),

/***/ 33397:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.tlds = void 0;
const tlds_js_1 = __nccwpck_require__(22996);
exports.tlds = new Set(tlds_js_1.TLDS.map((tld) => tld.toLowerCase()));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 22996:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// https://data.iana.org/TLD/tlds-alpha-by-domain.txt
// # Version 2025102200, Last Updated Wed Oct 22 07:07:01 2025 UTC
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TLDS = void 0;
exports.TLDS = [
    'AAA',
    'AARP',
    'ABB',
    'ABBOTT',
    'ABBVIE',
    'ABC',
    'ABLE',
    'ABOGADO',
    'ABUDHABI',
    'AC',
    'ACADEMY',
    'ACCENTURE',
    'ACCOUNTANT',
    'ACCOUNTANTS',
    'ACO',
    'ACTOR',
    'AD',
    'ADS',
    'ADULT',
    'AE',
    'AEG',
    'AERO',
    'AETNA',
    'AF',
    'AFL',
    'AFRICA',
    'AG',
    'AGAKHAN',
    'AGENCY',
    'AI',
    'AIG',
    'AIRBUS',
    'AIRFORCE',
    'AIRTEL',
    'AKDN',
    'AL',
    'ALIBABA',
    'ALIPAY',
    'ALLFINANZ',
    'ALLSTATE',
    'ALLY',
    'ALSACE',
    'ALSTOM',
    'AM',
    'AMAZON',
    'AMERICANEXPRESS',
    'AMERICANFAMILY',
    'AMEX',
    'AMFAM',
    'AMICA',
    'AMSTERDAM',
    'ANALYTICS',
    'ANDROID',
    'ANQUAN',
    'ANZ',
    'AO',
    'AOL',
    'APARTMENTS',
    'APP',
    'APPLE',
    'AQ',
    'AQUARELLE',
    'AR',
    'ARAB',
    'ARAMCO',
    'ARCHI',
    'ARMY',
    'ARPA',
    'ART',
    'ARTE',
    'AS',
    'ASDA',
    'ASIA',
    'ASSOCIATES',
    'AT',
    'ATHLETA',
    'ATTORNEY',
    'AU',
    'AUCTION',
    'AUDI',
    'AUDIBLE',
    'AUDIO',
    'AUSPOST',
    'AUTHOR',
    'AUTO',
    'AUTOS',
    'AW',
    'AWS',
    'AX',
    'AXA',
    'AZ',
    'AZURE',
    'BA',
    'BABY',
    'BAIDU',
    'BANAMEX',
    'BAND',
    'BANK',
    'BAR',
    'BARCELONA',
    'BARCLAYCARD',
    'BARCLAYS',
    'BAREFOOT',
    'BARGAINS',
    'BASEBALL',
    'BASKETBALL',
    'BAUHAUS',
    'BAYERN',
    'BB',
    'BBC',
    'BBT',
    'BBVA',
    'BCG',
    'BCN',
    'BD',
    'BE',
    'BEATS',
    'BEAUTY',
    'BEER',
    'BERLIN',
    'BEST',
    'BESTBUY',
    'BET',
    'BF',
    'BG',
    'BH',
    'BHARTI',
    'BI',
    'BIBLE',
    'BID',
    'BIKE',
    'BING',
    'BINGO',
    'BIO',
    'BIZ',
    'BJ',
    'BLACK',
    'BLACKFRIDAY',
    'BLOCKBUSTER',
    'BLOG',
    'BLOOMBERG',
    'BLUE',
    'BM',
    'BMS',
    'BMW',
    'BN',
    'BNPPARIBAS',
    'BO',
    'BOATS',
    'BOEHRINGER',
    'BOFA',
    'BOM',
    'BOND',
    'BOO',
    'BOOK',
    'BOOKING',
    'BOSCH',
    'BOSTIK',
    'BOSTON',
    'BOT',
    'BOUTIQUE',
    'BOX',
    'BR',
    'BRADESCO',
    'BRIDGESTONE',
    'BROADWAY',
    'BROKER',
    'BROTHER',
    'BRUSSELS',
    'BS',
    'BT',
    'BUILD',
    'BUILDERS',
    'BUSINESS',
    'BUY',
    'BUZZ',
    'BV',
    'BW',
    'BY',
    'BZ',
    'BZH',
    'CA',
    'CAB',
    'CAFE',
    'CAL',
    'CALL',
    'CALVINKLEIN',
    'CAM',
    'CAMERA',
    'CAMP',
    'CANON',
    'CAPETOWN',
    'CAPITAL',
    'CAPITALONE',
    'CAR',
    'CARAVAN',
    'CARDS',
    'CARE',
    'CAREER',
    'CAREERS',
    'CARS',
    'CASA',
    'CASE',
    'CASH',
    'CASINO',
    'CAT',
    'CATERING',
    'CATHOLIC',
    'CBA',
    'CBN',
    'CBRE',
    'CC',
    'CD',
    'CENTER',
    'CEO',
    'CERN',
    'CF',
    'CFA',
    'CFD',
    'CG',
    'CH',
    'CHANEL',
    'CHANNEL',
    'CHARITY',
    'CHASE',
    'CHAT',
    'CHEAP',
    'CHINTAI',
    'CHRISTMAS',
    'CHROME',
    'CHURCH',
    'CI',
    'CIPRIANI',
    'CIRCLE',
    'CISCO',
    'CITADEL',
    'CITI',
    'CITIC',
    'CITY',
    'CK',
    'CL',
    'CLAIMS',
    'CLEANING',
    'CLICK',
    'CLINIC',
    'CLINIQUE',
    'CLOTHING',
    'CLOUD',
    'CLUB',
    'CLUBMED',
    'CM',
    'CN',
    'CO',
    'COACH',
    'CODES',
    'COFFEE',
    'COLLEGE',
    'COLOGNE',
    'COM',
    'COMMBANK',
    'COMMUNITY',
    'COMPANY',
    'COMPARE',
    'COMPUTER',
    'COMSEC',
    'CONDOS',
    'CONSTRUCTION',
    'CONSULTING',
    'CONTACT',
    'CONTRACTORS',
    'COOKING',
    'COOL',
    'COOP',
    'CORSICA',
    'COUNTRY',
    'COUPON',
    'COUPONS',
    'COURSES',
    'CPA',
    'CR',
    'CREDIT',
    'CREDITCARD',
    'CREDITUNION',
    'CRICKET',
    'CROWN',
    'CRS',
    'CRUISE',
    'CRUISES',
    'CU',
    'CUISINELLA',
    'CV',
    'CW',
    'CX',
    'CY',
    'CYMRU',
    'CYOU',
    'CZ',
    'DAD',
    'DANCE',
    'DATA',
    'DATE',
    'DATING',
    'DATSUN',
    'DAY',
    'DCLK',
    'DDS',
    'DE',
    'DEAL',
    'DEALER',
    'DEALS',
    'DEGREE',
    'DELIVERY',
    'DELL',
    'DELOITTE',
    'DELTA',
    'DEMOCRAT',
    'DENTAL',
    'DENTIST',
    'DESI',
    'DESIGN',
    'DEV',
    'DHL',
    'DIAMONDS',
    'DIET',
    'DIGITAL',
    'DIRECT',
    'DIRECTORY',
    'DISCOUNT',
    'DISCOVER',
    'DISH',
    'DIY',
    'DJ',
    'DK',
    'DM',
    'DNP',
    'DO',
    'DOCS',
    'DOCTOR',
    'DOG',
    'DOMAINS',
    'DOT',
    'DOWNLOAD',
    'DRIVE',
    'DTV',
    'DUBAI',
    'DUPONT',
    'DURBAN',
    'DVAG',
    'DVR',
    'DZ',
    'EARTH',
    'EAT',
    'EC',
    'ECO',
    'EDEKA',
    'EDU',
    'EDUCATION',
    'EE',
    'EG',
    'EMAIL',
    'EMERCK',
    'ENERGY',
    'ENGINEER',
    'ENGINEERING',
    'ENTERPRISES',
    'EPSON',
    'EQUIPMENT',
    'ER',
    'ERICSSON',
    'ERNI',
    'ES',
    'ESQ',
    'ESTATE',
    'ET',
    'EU',
    'EUROVISION',
    'EUS',
    'EVENTS',
    'EXCHANGE',
    'EXPERT',
    'EXPOSED',
    'EXPRESS',
    'EXTRASPACE',
    'FAGE',
    'FAIL',
    'FAIRWINDS',
    'FAITH',
    'FAMILY',
    'FAN',
    'FANS',
    'FARM',
    'FARMERS',
    'FASHION',
    'FAST',
    'FEDEX',
    'FEEDBACK',
    'FERRARI',
    'FERRERO',
    'FI',
    'FIDELITY',
    'FIDO',
    'FILM',
    'FINAL',
    'FINANCE',
    'FINANCIAL',
    'FIRE',
    'FIRESTONE',
    'FIRMDALE',
    'FISH',
    'FISHING',
    'FIT',
    'FITNESS',
    'FJ',
    'FK',
    'FLICKR',
    'FLIGHTS',
    'FLIR',
    'FLORIST',
    'FLOWERS',
    'FLY',
    'FM',
    'FO',
    'FOO',
    'FOOD',
    'FOOTBALL',
    'FORD',
    'FOREX',
    'FORSALE',
    'FORUM',
    'FOUNDATION',
    'FOX',
    'FR',
    'FREE',
    'FRESENIUS',
    'FRL',
    'FROGANS',
    'FRONTIER',
    'FTR',
    'FUJITSU',
    'FUN',
    'FUND',
    'FURNITURE',
    'FUTBOL',
    'FYI',
    'GA',
    'GAL',
    'GALLERY',
    'GALLO',
    'GALLUP',
    'GAME',
    'GAMES',
    'GAP',
    'GARDEN',
    'GAY',
    'GB',
    'GBIZ',
    'GD',
    'GDN',
    'GE',
    'GEA',
    'GENT',
    'GENTING',
    'GEORGE',
    'GF',
    'GG',
    'GGEE',
    'GH',
    'GI',
    'GIFT',
    'GIFTS',
    'GIVES',
    'GIVING',
    'GL',
    'GLASS',
    'GLE',
    'GLOBAL',
    'GLOBO',
    'GM',
    'GMAIL',
    'GMBH',
    'GMO',
    'GMX',
    'GN',
    'GODADDY',
    'GOLD',
    'GOLDPOINT',
    'GOLF',
    'GOO',
    'GOODYEAR',
    'GOOG',
    'GOOGLE',
    'GOP',
    'GOT',
    'GOV',
    'GP',
    'GQ',
    'GR',
    'GRAINGER',
    'GRAPHICS',
    'GRATIS',
    'GREEN',
    'GRIPE',
    'GROCERY',
    'GROUP',
    'GS',
    'GT',
    'GU',
    'GUCCI',
    'GUGE',
    'GUIDE',
    'GUITARS',
    'GURU',
    'GW',
    'GY',
    'HAIR',
    'HAMBURG',
    'HANGOUT',
    'HAUS',
    'HBO',
    'HDFC',
    'HDFCBANK',
    'HEALTH',
    'HEALTHCARE',
    'HELP',
    'HELSINKI',
    'HERE',
    'HERMES',
    'HIPHOP',
    'HISAMITSU',
    'HITACHI',
    'HIV',
    'HK',
    'HKT',
    'HM',
    'HN',
    'HOCKEY',
    'HOLDINGS',
    'HOLIDAY',
    'HOMEDEPOT',
    'HOMEGOODS',
    'HOMES',
    'HOMESENSE',
    'HONDA',
    'HORSE',
    'HOSPITAL',
    'HOST',
    'HOSTING',
    'HOT',
    'HOTELS',
    'HOTMAIL',
    'HOUSE',
    'HOW',
    'HR',
    'HSBC',
    'HT',
    'HU',
    'HUGHES',
    'HYATT',
    'HYUNDAI',
    'IBM',
    'ICBC',
    'ICE',
    'ICU',
    'ID',
    'IE',
    'IEEE',
    'IFM',
    'IKANO',
    'IL',
    'IM',
    'IMAMAT',
    'IMDB',
    'IMMO',
    'IMMOBILIEN',
    'IN',
    'INC',
    'INDUSTRIES',
    'INFINITI',
    'INFO',
    'ING',
    'INK',
    'INSTITUTE',
    'INSURANCE',
    'INSURE',
    'INT',
    'INTERNATIONAL',
    'INTUIT',
    'INVESTMENTS',
    'IO',
    'IPIRANGA',
    'IQ',
    'IR',
    'IRISH',
    'IS',
    'ISMAILI',
    'IST',
    'ISTANBUL',
    'IT',
    'ITAU',
    'ITV',
    'JAGUAR',
    'JAVA',
    'JCB',
    'JE',
    'JEEP',
    'JETZT',
    'JEWELRY',
    'JIO',
    'JLL',
    'JM',
    'JMP',
    'JNJ',
    'JO',
    'JOBS',
    'JOBURG',
    'JOT',
    'JOY',
    'JP',
    'JPMORGAN',
    'JPRS',
    'JUEGOS',
    'JUNIPER',
    'KAUFEN',
    'KDDI',
    'KE',
    'KERRYHOTELS',
    'KERRYPROPERTIES',
    'KFH',
    'KG',
    'KH',
    'KI',
    'KIA',
    'KIDS',
    'KIM',
    'KINDLE',
    'KITCHEN',
    'KIWI',
    'KM',
    'KN',
    'KOELN',
    'KOMATSU',
    'KOSHER',
    'KP',
    'KPMG',
    'KPN',
    'KR',
    'KRD',
    'KRED',
    'KUOKGROUP',
    'KW',
    'KY',
    'KYOTO',
    'KZ',
    'LA',
    'LACAIXA',
    'LAMBORGHINI',
    'LAMER',
    'LAND',
    'LANDROVER',
    'LANXESS',
    'LASALLE',
    'LAT',
    'LATINO',
    'LATROBE',
    'LAW',
    'LAWYER',
    'LB',
    'LC',
    'LDS',
    'LEASE',
    'LECLERC',
    'LEFRAK',
    'LEGAL',
    'LEGO',
    'LEXUS',
    'LGBT',
    'LI',
    'LIDL',
    'LIFE',
    'LIFEINSURANCE',
    'LIFESTYLE',
    'LIGHTING',
    'LIKE',
    'LILLY',
    'LIMITED',
    'LIMO',
    'LINCOLN',
    'LINK',
    'LIVE',
    'LIVING',
    'LK',
    'LLC',
    'LLP',
    'LOAN',
    'LOANS',
    'LOCKER',
    'LOCUS',
    'LOL',
    'LONDON',
    'LOTTE',
    'LOTTO',
    'LOVE',
    'LPL',
    'LPLFINANCIAL',
    'LR',
    'LS',
    'LT',
    'LTD',
    'LTDA',
    'LU',
    'LUNDBECK',
    'LUXE',
    'LUXURY',
    'LV',
    'LY',
    'MA',
    'MADRID',
    'MAIF',
    'MAISON',
    'MAKEUP',
    'MAN',
    'MANAGEMENT',
    'MANGO',
    'MAP',
    'MARKET',
    'MARKETING',
    'MARKETS',
    'MARRIOTT',
    'MARSHALLS',
    'MATTEL',
    'MBA',
    'MC',
    'MCKINSEY',
    'MD',
    'ME',
    'MED',
    'MEDIA',
    'MEET',
    'MELBOURNE',
    'MEME',
    'MEMORIAL',
    'MEN',
    'MENU',
    'MERCKMSD',
    'MG',
    'MH',
    'MIAMI',
    'MICROSOFT',
    'MIL',
    'MINI',
    'MINT',
    'MIT',
    'MITSUBISHI',
    'MK',
    'ML',
    'MLB',
    'MLS',
    'MM',
    'MMA',
    'MN',
    'MO',
    'MOBI',
    'MOBILE',
    'MODA',
    'MOE',
    'MOI',
    'MOM',
    'MONASH',
    'MONEY',
    'MONSTER',
    'MORMON',
    'MORTGAGE',
    'MOSCOW',
    'MOTO',
    'MOTORCYCLES',
    'MOV',
    'MOVIE',
    'MP',
    'MQ',
    'MR',
    'MS',
    'MSD',
    'MT',
    'MTN',
    'MTR',
    'MU',
    'MUSEUM',
    'MUSIC',
    'MV',
    'MW',
    'MX',
    'MY',
    'MZ',
    'NA',
    'NAB',
    'NAGOYA',
    'NAME',
    'NAVY',
    'NBA',
    'NC',
    'NE',
    'NEC',
    'NET',
    'NETBANK',
    'NETFLIX',
    'NETWORK',
    'NEUSTAR',
    'NEW',
    'NEWS',
    'NEXT',
    'NEXTDIRECT',
    'NEXUS',
    'NF',
    'NFL',
    'NG',
    'NGO',
    'NHK',
    'NI',
    'NICO',
    'NIKE',
    'NIKON',
    'NINJA',
    'NISSAN',
    'NISSAY',
    'NL',
    'NO',
    'NOKIA',
    'NORTON',
    'NOW',
    'NOWRUZ',
    'NOWTV',
    'NP',
    'NR',
    'NRA',
    'NRW',
    'NTT',
    'NU',
    'NYC',
    'NZ',
    'OBI',
    'OBSERVER',
    'OFFICE',
    'OKINAWA',
    'OLAYAN',
    'OLAYANGROUP',
    'OLLO',
    'OM',
    'OMEGA',
    'ONE',
    'ONG',
    'ONL',
    'ONLINE',
    'OOO',
    'OPEN',
    'ORACLE',
    'ORANGE',
    'ORG',
    'ORGANIC',
    'ORIGINS',
    'OSAKA',
    'OTSUKA',
    'OTT',
    'OVH',
    'PA',
    'PAGE',
    'PANASONIC',
    'PARIS',
    'PARS',
    'PARTNERS',
    'PARTS',
    'PARTY',
    'PAY',
    'PCCW',
    'PE',
    'PET',
    'PF',
    'PFIZER',
    'PG',
    'PH',
    'PHARMACY',
    'PHD',
    'PHILIPS',
    'PHONE',
    'PHOTO',
    'PHOTOGRAPHY',
    'PHOTOS',
    'PHYSIO',
    'PICS',
    'PICTET',
    'PICTURES',
    'PID',
    'PIN',
    'PING',
    'PINK',
    'PIONEER',
    'PIZZA',
    'PK',
    'PL',
    'PLACE',
    'PLAY',
    'PLAYSTATION',
    'PLUMBING',
    'PLUS',
    'PM',
    'PN',
    'PNC',
    'POHL',
    'POKER',
    'POLITIE',
    'PORN',
    'POST',
    'PR',
    'PRAXI',
    'PRESS',
    'PRIME',
    'PRO',
    'PROD',
    'PRODUCTIONS',
    'PROF',
    'PROGRESSIVE',
    'PROMO',
    'PROPERTIES',
    'PROPERTY',
    'PROTECTION',
    'PRU',
    'PRUDENTIAL',
    'PS',
    'PT',
    'PUB',
    'PW',
    'PWC',
    'PY',
    'QA',
    'QPON',
    'QUEBEC',
    'QUEST',
    'RACING',
    'RADIO',
    'RE',
    'READ',
    'REALESTATE',
    'REALTOR',
    'REALTY',
    'RECIPES',
    'RED',
    'REDUMBRELLA',
    'REHAB',
    'REISE',
    'REISEN',
    'REIT',
    'RELIANCE',
    'REN',
    'RENT',
    'RENTALS',
    'REPAIR',
    'REPORT',
    'REPUBLICAN',
    'REST',
    'RESTAURANT',
    'REVIEW',
    'REVIEWS',
    'REXROTH',
    'RICH',
    'RICHARDLI',
    'RICOH',
    'RIL',
    'RIO',
    'RIP',
    'RO',
    'ROCKS',
    'RODEO',
    'ROGERS',
    'ROOM',
    'RS',
    'RSVP',
    'RU',
    'RUGBY',
    'RUHR',
    'RUN',
    'RW',
    'RWE',
    'RYUKYU',
    'SA',
    'SAARLAND',
    'SAFE',
    'SAFETY',
    'SAKURA',
    'SALE',
    'SALON',
    'SAMSCLUB',
    'SAMSUNG',
    'SANDVIK',
    'SANDVIKCOROMANT',
    'SANOFI',
    'SAP',
    'SARL',
    'SAS',
    'SAVE',
    'SAXO',
    'SB',
    'SBI',
    'SBS',
    'SC',
    'SCB',
    'SCHAEFFLER',
    'SCHMIDT',
    'SCHOLARSHIPS',
    'SCHOOL',
    'SCHULE',
    'SCHWARZ',
    'SCIENCE',
    'SCOT',
    'SD',
    'SE',
    'SEARCH',
    'SEAT',
    'SECURE',
    'SECURITY',
    'SEEK',
    'SELECT',
    'SENER',
    'SERVICES',
    'SEVEN',
    'SEW',
    'SEX',
    'SEXY',
    'SFR',
    'SG',
    'SH',
    'SHANGRILA',
    'SHARP',
    'SHELL',
    'SHIA',
    'SHIKSHA',
    'SHOES',
    'SHOP',
    'SHOPPING',
    'SHOUJI',
    'SHOW',
    'SI',
    'SILK',
    'SINA',
    'SINGLES',
    'SITE',
    'SJ',
    'SK',
    'SKI',
    'SKIN',
    'SKY',
    'SKYPE',
    'SL',
    'SLING',
    'SM',
    'SMART',
    'SMILE',
    'SN',
    'SNCF',
    'SO',
    'SOCCER',
    'SOCIAL',
    'SOFTBANK',
    'SOFTWARE',
    'SOHU',
    'SOLAR',
    'SOLUTIONS',
    'SONG',
    'SONY',
    'SOY',
    'SPA',
    'SPACE',
    'SPORT',
    'SPOT',
    'SR',
    'SRL',
    'SS',
    'ST',
    'STADA',
    'STAPLES',
    'STAR',
    'STATEBANK',
    'STATEFARM',
    'STC',
    'STCGROUP',
    'STOCKHOLM',
    'STORAGE',
    'STORE',
    'STREAM',
    'STUDIO',
    'STUDY',
    'STYLE',
    'SU',
    'SUCKS',
    'SUPPLIES',
    'SUPPLY',
    'SUPPORT',
    'SURF',
    'SURGERY',
    'SUZUKI',
    'SV',
    'SWATCH',
    'SWISS',
    'SX',
    'SY',
    'SYDNEY',
    'SYSTEMS',
    'SZ',
    'TAB',
    'TAIPEI',
    'TALK',
    'TAOBAO',
    'TARGET',
    'TATAMOTORS',
    'TATAR',
    'TATTOO',
    'TAX',
    'TAXI',
    'TC',
    'TCI',
    'TD',
    'TDK',
    'TEAM',
    'TECH',
    'TECHNOLOGY',
    'TEL',
    'TEMASEK',
    'TENNIS',
    'TEVA',
    'TF',
    'TG',
    'TH',
    'THD',
    'THEATER',
    'THEATRE',
    'TIAA',
    'TICKETS',
    'TIENDA',
    'TIPS',
    'TIRES',
    'TIROL',
    'TJ',
    'TJMAXX',
    'TJX',
    'TK',
    'TKMAXX',
    'TL',
    'TM',
    'TMALL',
    'TN',
    'TO',
    'TODAY',
    'TOKYO',
    'TOOLS',
    'TOP',
    'TORAY',
    'TOSHIBA',
    'TOTAL',
    'TOURS',
    'TOWN',
    'TOYOTA',
    'TOYS',
    'TR',
    'TRADE',
    'TRADING',
    'TRAINING',
    'TRAVEL',
    'TRAVELERS',
    'TRAVELERSINSURANCE',
    'TRUST',
    'TRV',
    'TT',
    'TUBE',
    'TUI',
    'TUNES',
    'TUSHU',
    'TV',
    'TVS',
    'TW',
    'TZ',
    'UA',
    'UBANK',
    'UBS',
    'UG',
    'UK',
    'UNICOM',
    'UNIVERSITY',
    'UNO',
    'UOL',
    'UPS',
    'US',
    'UY',
    'UZ',
    'VA',
    'VACATIONS',
    'VANA',
    'VANGUARD',
    'VC',
    'VE',
    'VEGAS',
    'VENTURES',
    'VERISIGN',
    'VERSICHERUNG',
    'VET',
    'VG',
    'VI',
    'VIAJES',
    'VIDEO',
    'VIG',
    'VIKING',
    'VILLAS',
    'VIN',
    'VIP',
    'VIRGIN',
    'VISA',
    'VISION',
    'VIVA',
    'VIVO',
    'VLAANDEREN',
    'VN',
    'VODKA',
    'VOLVO',
    'VOTE',
    'VOTING',
    'VOTO',
    'VOYAGE',
    'VU',
    'WALES',
    'WALMART',
    'WALTER',
    'WANG',
    'WANGGOU',
    'WATCH',
    'WATCHES',
    'WEATHER',
    'WEATHERCHANNEL',
    'WEBCAM',
    'WEBER',
    'WEBSITE',
    'WED',
    'WEDDING',
    'WEIBO',
    'WEIR',
    'WF',
    'WHOSWHO',
    'WIEN',
    'WIKI',
    'WILLIAMHILL',
    'WIN',
    'WINDOWS',
    'WINE',
    'WINNERS',
    'WME',
    'WOLTERSKLUWER',
    'WOODSIDE',
    'WORK',
    'WORKS',
    'WORLD',
    'WOW',
    'WS',
    'WTC',
    'WTF',
    'XBOX',
    'XEROX',
    'XIHUAN',
    'XIN',
    'XN--11B4C3D',
    'XN--1CK2E1B',
    'XN--1QQW23A',
    'XN--2SCRJ9C',
    'XN--30RR7Y',
    'XN--3BST00M',
    'XN--3DS443G',
    'XN--3E0B707E',
    'XN--3HCRJ9C',
    'XN--3PXU8K',
    'XN--42C2D9A',
    'XN--45BR5CYL',
    'XN--45BRJ9C',
    'XN--45Q11C',
    'XN--4DBRK0CE',
    'XN--4GBRIM',
    'XN--54B7FTA0CC',
    'XN--55QW42G',
    'XN--55QX5D',
    'XN--5SU34J936BGSG',
    'XN--5TZM5G',
    'XN--6FRZ82G',
    'XN--6QQ986B3XL',
    'XN--80ADXHKS',
    'XN--80AO21A',
    'XN--80AQECDR1A',
    'XN--80ASEHDB',
    'XN--80ASWG',
    'XN--8Y0A063A',
    'XN--90A3AC',
    'XN--90AE',
    'XN--90AIS',
    'XN--9DBQ2A',
    'XN--9ET52U',
    'XN--9KRT00A',
    'XN--B4W605FERD',
    'XN--BCK1B9A5DRE4C',
    'XN--C1AVG',
    'XN--C2BR7G',
    'XN--CCK2B3B',
    'XN--CCKWCXETD',
    'XN--CG4BKI',
    'XN--CLCHC0EA0B2G2A9GCD',
    'XN--CZR694B',
    'XN--CZRS0T',
    'XN--CZRU2D',
    'XN--D1ACJ3B',
    'XN--D1ALF',
    'XN--E1A4C',
    'XN--ECKVDTC9D',
    'XN--EFVY88H',
    'XN--FCT429K',
    'XN--FHBEI',
    'XN--FIQ228C5HS',
    'XN--FIQ64B',
    'XN--FIQS8S',
    'XN--FIQZ9S',
    'XN--FJQ720A',
    'XN--FLW351E',
    'XN--FPCRJ9C3D',
    'XN--FZC2C9E2C',
    'XN--FZYS8D69UVGM',
    'XN--G2XX48C',
    'XN--GCKR3F0F',
    'XN--GECRJ9C',
    'XN--GK3AT1E',
    'XN--H2BREG3EVE',
    'XN--H2BRJ9C',
    'XN--H2BRJ9C8C',
    'XN--HXT814E',
    'XN--I1B6B1A6A2E',
    'XN--IMR513N',
    'XN--IO0A7I',
    'XN--J1AEF',
    'XN--J1AMH',
    'XN--J6W193G',
    'XN--JLQ480N2RG',
    'XN--JVR189M',
    'XN--KCRX77D1X4A',
    'XN--KPRW13D',
    'XN--KPRY57D',
    'XN--KPUT3I',
    'XN--L1ACC',
    'XN--LGBBAT1AD8J',
    'XN--MGB9AWBF',
    'XN--MGBA3A3EJT',
    'XN--MGBA3A4F16A',
    'XN--MGBA7C0BBN0A',
    'XN--MGBAAM7A8H',
    'XN--MGBAB2BD',
    'XN--MGBAH1A3HJKRD',
    'XN--MGBAI9AZGQP6J',
    'XN--MGBAYH7GPA',
    'XN--MGBBH1A',
    'XN--MGBBH1A71E',
    'XN--MGBC0A9AZCG',
    'XN--MGBCA7DZDO',
    'XN--MGBCPQ6GPA1A',
    'XN--MGBERP4A5D4AR',
    'XN--MGBGU82A',
    'XN--MGBI4ECEXP',
    'XN--MGBPL2FH',
    'XN--MGBT3DHD',
    'XN--MGBTX2B',
    'XN--MGBX4CD0AB',
    'XN--MIX891F',
    'XN--MK1BU44C',
    'XN--MXTQ1M',
    'XN--NGBC5AZD',
    'XN--NGBE9E0A',
    'XN--NGBRX',
    'XN--NODE',
    'XN--NQV7F',
    'XN--NQV7FS00EMA',
    'XN--NYQY26A',
    'XN--O3CW4H',
    'XN--OGBPF8FL',
    'XN--OTU796D',
    'XN--P1ACF',
    'XN--P1AI',
    'XN--PGBS0DH',
    'XN--PSSY2U',
    'XN--Q7CE6A',
    'XN--Q9JYB4C',
    'XN--QCKA1PMC',
    'XN--QXA6A',
    'XN--QXAM',
    'XN--RHQV96G',
    'XN--ROVU88B',
    'XN--RVC1E0AM3E',
    'XN--S9BRJ9C',
    'XN--SES554G',
    'XN--T60B56A',
    'XN--TCKWE',
    'XN--TIQ49XQYJ',
    'XN--UNUP4Y',
    'XN--VERMGENSBERATER-CTB',
    'XN--VERMGENSBERATUNG-PWB',
    'XN--VHQUV',
    'XN--VUQ861B',
    'XN--W4R85EL8FHU5DNRA',
    'XN--W4RS40L',
    'XN--WGBH1C',
    'XN--WGBL6A',
    'XN--XHQ521B',
    'XN--XKC2AL3HYE2A',
    'XN--XKC2DL3A5EE0H',
    'XN--Y9A3AQ',
    'XN--YFRO4I67O',
    'XN--YGBI2AMMX',
    'XN--ZFR164B',
    'XXX',
    'XYZ',
    'YACHTS',
    'YAHOO',
    'YAMAXUN',
    'YANDEX',
    'YE',
    'YODOBASHI',
    'YOGA',
    'YOKOHAMA',
    'YOU',
    'YOUTUBE',
    'YT',
    'YUN',
    'ZA',
    'ZAPPOS',
    'ZARA',
    'ZERO',
    'ZIP',
    'ZM',
    'ZONE',
    'ZUERICH',
    'ZW',
];
//# sourceMappingURL=tlds.js.map

/***/ }),

/***/ 66390:
/***/ (function(module, exports) {

// GENERATED FILE. DO NOT EDIT.
(function (global, factory) {
  function preferDefault(exports) {
    return exports.default || exports;
  }
  if (typeof define === "function" && define.amd) {
    define([], function () {
      var exports = {};
      factory(exports);
      return preferDefault(exports);
    });
  } else if (true) {
    factory(exports);
    if (true) module.exports = preferDefault(exports);
  } else {}
})(
  typeof globalThis !== "undefined"
    ? globalThis
    : typeof self !== "undefined"
      ? self
      : this,
  function (_exports) {
    "use strict";

    Object.defineProperty(_exports, "__esModule", {
      value: true,
    });
    _exports.default = void 0;
    /**
     * @license
     * Copyright 2009 The Closure Library Authors
     * Copyright 2020 Daniel Wirtz / The long.js Authors.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *     http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     *
     * SPDX-License-Identifier: Apache-2.0
     */

    // WebAssembly optimizations to do native i64 multiplication and divide
    var wasm = null;
    try {
      wasm = new WebAssembly.Instance(
        new WebAssembly.Module(
          new Uint8Array([
            // \0asm
            0, 97, 115, 109,
            // version 1
            1, 0, 0, 0,
            // section "type"
            1, 13, 2,
            // 0, () => i32
            96, 0, 1, 127,
            // 1, (i32, i32, i32, i32) => i32
            96, 4, 127, 127, 127, 127, 1, 127,
            // section "function"
            3, 7, 6,
            // 0, type 0
            0,
            // 1, type 1
            1,
            // 2, type 1
            1,
            // 3, type 1
            1,
            // 4, type 1
            1,
            // 5, type 1
            1,
            // section "global"
            6, 6, 1,
            // 0, "high", mutable i32
            127, 1, 65, 0, 11,
            // section "export"
            7, 50, 6,
            // 0, "mul"
            3, 109, 117, 108, 0, 1,
            // 1, "div_s"
            5, 100, 105, 118, 95, 115, 0, 2,
            // 2, "div_u"
            5, 100, 105, 118, 95, 117, 0, 3,
            // 3, "rem_s"
            5, 114, 101, 109, 95, 115, 0, 4,
            // 4, "rem_u"
            5, 114, 101, 109, 95, 117, 0, 5,
            // 5, "get_high"
            8, 103, 101, 116, 95, 104, 105, 103, 104, 0, 0,
            // section "code"
            10, 191, 1, 6,
            // 0, "get_high"
            4, 0, 35, 0, 11,
            // 1, "mul"
            36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173,
            32, 3, 173, 66, 32, 134, 132, 126, 34, 4, 66, 32, 135, 167, 36, 0,
            32, 4, 167, 11,
            // 2, "div_s"
            36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173,
            32, 3, 173, 66, 32, 134, 132, 127, 34, 4, 66, 32, 135, 167, 36, 0,
            32, 4, 167, 11,
            // 3, "div_u"
            36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173,
            32, 3, 173, 66, 32, 134, 132, 128, 34, 4, 66, 32, 135, 167, 36, 0,
            32, 4, 167, 11,
            // 4, "rem_s"
            36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173,
            32, 3, 173, 66, 32, 134, 132, 129, 34, 4, 66, 32, 135, 167, 36, 0,
            32, 4, 167, 11,
            // 5, "rem_u"
            36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173,
            32, 3, 173, 66, 32, 134, 132, 130, 34, 4, 66, 32, 135, 167, 36, 0,
            32, 4, 167, 11,
          ]),
        ),
        {},
      ).exports;
    } catch {
      // no wasm support :(
    }

    /**
     * Constructs a 64 bit two's-complement integer, given its low and high 32 bit values as *signed* integers.
     *  See the from* functions below for more convenient ways of constructing Longs.
     * @exports Long
     * @class A Long class for representing a 64 bit two's-complement integer value.
     * @param {number} low The low (signed) 32 bits of the long
     * @param {number} high The high (signed) 32 bits of the long
     * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
     * @constructor
     */
    function Long(low, high, unsigned) {
      /**
       * The low 32 bits as a signed value.
       * @type {number}
       */
      this.low = low | 0;

      /**
       * The high 32 bits as a signed value.
       * @type {number}
       */
      this.high = high | 0;

      /**
       * Whether unsigned or not.
       * @type {boolean}
       */
      this.unsigned = !!unsigned;
    }

    // The internal representation of a long is the two given signed, 32-bit values.
    // We use 32-bit pieces because these are the size of integers on which
    // Javascript performs bit-operations.  For operations like addition and
    // multiplication, we split each number into 16 bit pieces, which can easily be
    // multiplied within Javascript's floating-point representation without overflow
    // or change in sign.
    //
    // In the algorithms below, we frequently reduce the negative case to the
    // positive case by negating the input(s) and then post-processing the result.
    // Note that we must ALWAYS check specially whether those values are MIN_VALUE
    // (-2^63) because -MIN_VALUE == MIN_VALUE (since 2^63 cannot be represented as
    // a positive number, it overflows back into a negative).  Not handling this
    // case would often result in infinite recursion.
    //
    // Common constant values ZERO, ONE, NEG_ONE, etc. are defined below the from*
    // methods on which they depend.

    /**
     * An indicator used to reliably determine if an object is a Long or not.
     * @type {boolean}
     * @const
     * @private
     */
    Long.prototype.__isLong__;
    Object.defineProperty(Long.prototype, "__isLong__", {
      value: true,
    });

    /**
     * @function
     * @param {*} obj Object
     * @returns {boolean}
     * @inner
     */
    function isLong(obj) {
      return (obj && obj["__isLong__"]) === true;
    }

    /**
     * @function
     * @param {*} value number
     * @returns {number}
     * @inner
     */
    function ctz32(value) {
      var c = Math.clz32(value & -value);
      return value ? 31 - c : c;
    }

    /**
     * Tests if the specified object is a Long.
     * @function
     * @param {*} obj Object
     * @returns {boolean}
     */
    Long.isLong = isLong;

    /**
     * A cache of the Long representations of small integer values.
     * @type {!Object}
     * @inner
     */
    var INT_CACHE = {};

    /**
     * A cache of the Long representations of small unsigned integer values.
     * @type {!Object}
     * @inner
     */
    var UINT_CACHE = {};

    /**
     * @param {number} value
     * @param {boolean=} unsigned
     * @returns {!Long}
     * @inner
     */
    function fromInt(value, unsigned) {
      var obj, cachedObj, cache;
      if (unsigned) {
        value >>>= 0;
        if ((cache = 0 <= value && value < 256)) {
          cachedObj = UINT_CACHE[value];
          if (cachedObj) return cachedObj;
        }
        obj = fromBits(value, 0, true);
        if (cache) UINT_CACHE[value] = obj;
        return obj;
      } else {
        value |= 0;
        if ((cache = -128 <= value && value < 128)) {
          cachedObj = INT_CACHE[value];
          if (cachedObj) return cachedObj;
        }
        obj = fromBits(value, value < 0 ? -1 : 0, false);
        if (cache) INT_CACHE[value] = obj;
        return obj;
      }
    }

    /**
     * Returns a Long representing the given 32 bit integer value.
     * @function
     * @param {number} value The 32 bit integer in question
     * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
     * @returns {!Long} The corresponding Long value
     */
    Long.fromInt = fromInt;

    /**
     * @param {number} value
     * @param {boolean=} unsigned
     * @returns {!Long}
     * @inner
     */
    function fromNumber(value, unsigned) {
      if (isNaN(value)) return unsigned ? UZERO : ZERO;
      if (unsigned) {
        if (value < 0) return UZERO;
        if (value >= TWO_PWR_64_DBL) return MAX_UNSIGNED_VALUE;
      } else {
        if (value <= -TWO_PWR_63_DBL) return MIN_VALUE;
        if (value + 1 >= TWO_PWR_63_DBL) return MAX_VALUE;
      }
      if (value < 0) return fromNumber(-value, unsigned).neg();
      return fromBits(
        value % TWO_PWR_32_DBL | 0,
        (value / TWO_PWR_32_DBL) | 0,
        unsigned,
      );
    }

    /**
     * Returns a Long representing the given value, provided that it is a finite number. Otherwise, zero is returned.
     * @function
     * @param {number} value The number in question
     * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
     * @returns {!Long} The corresponding Long value
     */
    Long.fromNumber = fromNumber;

    /**
     * @param {number} lowBits
     * @param {number} highBits
     * @param {boolean=} unsigned
     * @returns {!Long}
     * @inner
     */
    function fromBits(lowBits, highBits, unsigned) {
      return new Long(lowBits, highBits, unsigned);
    }

    /**
     * Returns a Long representing the 64 bit integer that comes by concatenating the given low and high bits. Each is
     *  assumed to use 32 bits.
     * @function
     * @param {number} lowBits The low 32 bits
     * @param {number} highBits The high 32 bits
     * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
     * @returns {!Long} The corresponding Long value
     */
    Long.fromBits = fromBits;

    /**
     * @function
     * @param {number} base
     * @param {number} exponent
     * @returns {number}
     * @inner
     */
    var pow_dbl = Math.pow; // Used 4 times (4*8 to 15+4)

    /**
     * @param {string} str
     * @param {(boolean|number)=} unsigned
     * @param {number=} radix
     * @returns {!Long}
     * @inner
     */
    function fromString(str, unsigned, radix) {
      if (str.length === 0) throw Error("empty string");
      if (typeof unsigned === "number") {
        // For goog.math.long compatibility
        radix = unsigned;
        unsigned = false;
      } else {
        unsigned = !!unsigned;
      }
      if (
        str === "NaN" ||
        str === "Infinity" ||
        str === "+Infinity" ||
        str === "-Infinity"
      )
        return unsigned ? UZERO : ZERO;
      radix = radix || 10;
      if (radix < 2 || 36 < radix) throw RangeError("radix");
      var p;
      if ((p = str.indexOf("-")) > 0) throw Error("interior hyphen");
      else if (p === 0) {
        return fromString(str.substring(1), unsigned, radix).neg();
      }

      // Do several (8) digits each time through the loop, so as to
      // minimize the calls to the very expensive emulated div.
      var radixToPower = fromNumber(pow_dbl(radix, 8));
      var result = ZERO;
      for (var i = 0; i < str.length; i += 8) {
        var size = Math.min(8, str.length - i),
          value = parseInt(str.substring(i, i + size), radix);
        if (size < 8) {
          var power = fromNumber(pow_dbl(radix, size));
          result = result.mul(power).add(fromNumber(value));
        } else {
          result = result.mul(radixToPower);
          result = result.add(fromNumber(value));
        }
      }
      result.unsigned = unsigned;
      return result;
    }

    /**
     * Returns a Long representation of the given string, written using the specified radix.
     * @function
     * @param {string} str The textual representation of the Long
     * @param {(boolean|number)=} unsigned Whether unsigned or not, defaults to signed
     * @param {number=} radix The radix in which the text is written (2-36), defaults to 10
     * @returns {!Long} The corresponding Long value
     */
    Long.fromString = fromString;

    /**
     * @function
     * @param {!Long|number|string|!{low: number, high: number, unsigned: boolean}} val
     * @param {boolean=} unsigned
     * @returns {!Long}
     * @inner
     */
    function fromValue(val, unsigned) {
      if (typeof val === "number") return fromNumber(val, unsigned);
      if (typeof val === "string") return fromString(val, unsigned);
      // Throws for non-objects, converts non-instanceof Long:
      return fromBits(
        val.low,
        val.high,
        typeof unsigned === "boolean" ? unsigned : val.unsigned,
      );
    }

    /**
     * Converts the specified value to a Long using the appropriate from* function for its type.
     * @function
     * @param {!Long|number|bigint|string|!{low: number, high: number, unsigned: boolean}} val Value
     * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
     * @returns {!Long}
     */
    Long.fromValue = fromValue;

    // NOTE: the compiler should inline these constant values below and then remove these variables, so there should be
    // no runtime penalty for these.

    /**
     * @type {number}
     * @const
     * @inner
     */
    var TWO_PWR_16_DBL = 1 << 16;

    /**
     * @type {number}
     * @const
     * @inner
     */
    var TWO_PWR_24_DBL = 1 << 24;

    /**
     * @type {number}
     * @const
     * @inner
     */
    var TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;

    /**
     * @type {number}
     * @const
     * @inner
     */
    var TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;

    /**
     * @type {number}
     * @const
     * @inner
     */
    var TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;

    /**
     * @type {!Long}
     * @const
     * @inner
     */
    var TWO_PWR_24 = fromInt(TWO_PWR_24_DBL);

    /**
     * @type {!Long}
     * @inner
     */
    var ZERO = fromInt(0);

    /**
     * Signed zero.
     * @type {!Long}
     */
    Long.ZERO = ZERO;

    /**
     * @type {!Long}
     * @inner
     */
    var UZERO = fromInt(0, true);

    /**
     * Unsigned zero.
     * @type {!Long}
     */
    Long.UZERO = UZERO;

    /**
     * @type {!Long}
     * @inner
     */
    var ONE = fromInt(1);

    /**
     * Signed one.
     * @type {!Long}
     */
    Long.ONE = ONE;

    /**
     * @type {!Long}
     * @inner
     */
    var UONE = fromInt(1, true);

    /**
     * Unsigned one.
     * @type {!Long}
     */
    Long.UONE = UONE;

    /**
     * @type {!Long}
     * @inner
     */
    var NEG_ONE = fromInt(-1);

    /**
     * Signed negative one.
     * @type {!Long}
     */
    Long.NEG_ONE = NEG_ONE;

    /**
     * @type {!Long}
     * @inner
     */
    var MAX_VALUE = fromBits(0xffffffff | 0, 0x7fffffff | 0, false);

    /**
     * Maximum signed value.
     * @type {!Long}
     */
    Long.MAX_VALUE = MAX_VALUE;

    /**
     * @type {!Long}
     * @inner
     */
    var MAX_UNSIGNED_VALUE = fromBits(0xffffffff | 0, 0xffffffff | 0, true);

    /**
     * Maximum unsigned value.
     * @type {!Long}
     */
    Long.MAX_UNSIGNED_VALUE = MAX_UNSIGNED_VALUE;

    /**
     * @type {!Long}
     * @inner
     */
    var MIN_VALUE = fromBits(0, 0x80000000 | 0, false);

    /**
     * Minimum signed value.
     * @type {!Long}
     */
    Long.MIN_VALUE = MIN_VALUE;

    /**
     * @alias Long.prototype
     * @inner
     */
    var LongPrototype = Long.prototype;

    /**
     * Converts the Long to a 32 bit integer, assuming it is a 32 bit integer.
     * @this {!Long}
     * @returns {number}
     */
    LongPrototype.toInt = function toInt() {
      return this.unsigned ? this.low >>> 0 : this.low;
    };

    /**
     * Converts the Long to a the nearest floating-point representation of this value (double, 53 bit mantissa).
     * @this {!Long}
     * @returns {number}
     */
    LongPrototype.toNumber = function toNumber() {
      if (this.unsigned)
        return (this.high >>> 0) * TWO_PWR_32_DBL + (this.low >>> 0);
      return this.high * TWO_PWR_32_DBL + (this.low >>> 0);
    };

    /**
     * Converts the Long to a string written in the specified radix.
     * @this {!Long}
     * @param {number=} radix Radix (2-36), defaults to 10
     * @returns {string}
     * @override
     * @throws {RangeError} If `radix` is out of range
     */
    LongPrototype.toString = function toString(radix) {
      radix = radix || 10;
      if (radix < 2 || 36 < radix) throw RangeError("radix");
      if (this.isZero()) return "0";
      if (this.isNegative()) {
        // Unsigned Longs are never negative
        if (this.eq(MIN_VALUE)) {
          // We need to change the Long value before it can be negated, so we remove
          // the bottom-most digit in this base and then recurse to do the rest.
          var radixLong = fromNumber(radix),
            div = this.div(radixLong),
            rem1 = div.mul(radixLong).sub(this);
          return div.toString(radix) + rem1.toInt().toString(radix);
        } else return "-" + this.neg().toString(radix);
      }

      // Do several (6) digits each time through the loop, so as to
      // minimize the calls to the very expensive emulated div.
      var radixToPower = fromNumber(pow_dbl(radix, 6), this.unsigned),
        rem = this;
      var result = "";
      while (true) {
        var remDiv = rem.div(radixToPower),
          intval = rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0,
          digits = intval.toString(radix);
        rem = remDiv;
        if (rem.isZero()) return digits + result;
        else {
          while (digits.length < 6) digits = "0" + digits;
          result = "" + digits + result;
        }
      }
    };

    /**
     * Gets the high 32 bits as a signed integer.
     * @this {!Long}
     * @returns {number} Signed high bits
     */
    LongPrototype.getHighBits = function getHighBits() {
      return this.high;
    };

    /**
     * Gets the high 32 bits as an unsigned integer.
     * @this {!Long}
     * @returns {number} Unsigned high bits
     */
    LongPrototype.getHighBitsUnsigned = function getHighBitsUnsigned() {
      return this.high >>> 0;
    };

    /**
     * Gets the low 32 bits as a signed integer.
     * @this {!Long}
     * @returns {number} Signed low bits
     */
    LongPrototype.getLowBits = function getLowBits() {
      return this.low;
    };

    /**
     * Gets the low 32 bits as an unsigned integer.
     * @this {!Long}
     * @returns {number} Unsigned low bits
     */
    LongPrototype.getLowBitsUnsigned = function getLowBitsUnsigned() {
      return this.low >>> 0;
    };

    /**
     * Gets the number of bits needed to represent the absolute value of this Long.
     * @this {!Long}
     * @returns {number}
     */
    LongPrototype.getNumBitsAbs = function getNumBitsAbs() {
      if (this.isNegative())
        // Unsigned Longs are never negative
        return this.eq(MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();
      var val = this.high != 0 ? this.high : this.low;
      for (var bit = 31; bit > 0; bit--) if ((val & (1 << bit)) != 0) break;
      return this.high != 0 ? bit + 33 : bit + 1;
    };

    /**
     * Tests if this Long can be safely represented as a JavaScript number.
     * @this {!Long}
     * @returns {boolean}
     */
    LongPrototype.isSafeInteger = function isSafeInteger() {
      // 2^53-1 is the maximum safe value
      var top11Bits = this.high >> 21;
      // [0, 2^53-1]
      if (!top11Bits) return true;
      // > 2^53-1
      if (this.unsigned) return false;
      // [-2^53, -1] except -2^53
      return top11Bits === -1 && !(this.low === 0 && this.high === -0x200000);
    };

    /**
     * Tests if this Long's value equals zero.
     * @this {!Long}
     * @returns {boolean}
     */
    LongPrototype.isZero = function isZero() {
      return this.high === 0 && this.low === 0;
    };

    /**
     * Tests if this Long's value equals zero. This is an alias of {@link Long#isZero}.
     * @returns {boolean}
     */
    LongPrototype.eqz = LongPrototype.isZero;

    /**
     * Tests if this Long's value is negative.
     * @this {!Long}
     * @returns {boolean}
     */
    LongPrototype.isNegative = function isNegative() {
      return !this.unsigned && this.high < 0;
    };

    /**
     * Tests if this Long's value is positive or zero.
     * @this {!Long}
     * @returns {boolean}
     */
    LongPrototype.isPositive = function isPositive() {
      return this.unsigned || this.high >= 0;
    };

    /**
     * Tests if this Long's value is odd.
     * @this {!Long}
     * @returns {boolean}
     */
    LongPrototype.isOdd = function isOdd() {
      return (this.low & 1) === 1;
    };

    /**
     * Tests if this Long's value is even.
     * @this {!Long}
     * @returns {boolean}
     */
    LongPrototype.isEven = function isEven() {
      return (this.low & 1) === 0;
    };

    /**
     * Tests if this Long's value equals the specified's.
     * @this {!Long}
     * @param {!Long|number|bigint|string} other Other value
     * @returns {boolean}
     */
    LongPrototype.equals = function equals(other) {
      if (!isLong(other)) other = fromValue(other);
      if (
        this.unsigned !== other.unsigned &&
        this.high >>> 31 === 1 &&
        other.high >>> 31 === 1
      )
        return false;
      return this.high === other.high && this.low === other.low;
    };

    /**
     * Tests if this Long's value equals the specified's. This is an alias of {@link Long#equals}.
     * @function
     * @param {!Long|number|bigint|string} other Other value
     * @returns {boolean}
     */
    LongPrototype.eq = LongPrototype.equals;

    /**
     * Tests if this Long's value differs from the specified's.
     * @this {!Long}
     * @param {!Long|number|bigint|string} other Other value
     * @returns {boolean}
     */
    LongPrototype.notEquals = function notEquals(other) {
      return !this.eq(/* validates */ other);
    };

    /**
     * Tests if this Long's value differs from the specified's. This is an alias of {@link Long#notEquals}.
     * @function
     * @param {!Long|number|bigint|string} other Other value
     * @returns {boolean}
     */
    LongPrototype.neq = LongPrototype.notEquals;

    /**
     * Tests if this Long's value differs from the specified's. This is an alias of {@link Long#notEquals}.
     * @function
     * @param {!Long|number|bigint|string} other Other value
     * @returns {boolean}
     */
    LongPrototype.ne = LongPrototype.notEquals;

    /**
     * Tests if this Long's value is less than the specified's.
     * @this {!Long}
     * @param {!Long|number|bigint|string} other Other value
     * @returns {boolean}
     */
    LongPrototype.lessThan = function lessThan(other) {
      return this.comp(/* validates */ other) < 0;
    };

    /**
     * Tests if this Long's value is less than the specified's. This is an alias of {@link Long#lessThan}.
     * @function
     * @param {!Long|number|bigint|string} other Other value
     * @returns {boolean}
     */
    LongPrototype.lt = LongPrototype.lessThan;

    /**
     * Tests if this Long's value is less than or equal the specified's.
     * @this {!Long}
     * @param {!Long|number|bigint|string} other Other value
     * @returns {boolean}
     */
    LongPrototype.lessThanOrEqual = function lessThanOrEqual(other) {
      return this.comp(/* validates */ other) <= 0;
    };

    /**
     * Tests if this Long's value is less than or equal the specified's. This is an alias of {@link Long#lessThanOrEqual}.
     * @function
     * @param {!Long|number|bigint|string} other Other value
     * @returns {boolean}
     */
    LongPrototype.lte = LongPrototype.lessThanOrEqual;

    /**
     * Tests if this Long's value is less than or equal the specified's. This is an alias of {@link Long#lessThanOrEqual}.
     * @function
     * @param {!Long|number|bigint|string} other Other value
     * @returns {boolean}
     */
    LongPrototype.le = LongPrototype.lessThanOrEqual;

    /**
     * Tests if this Long's value is greater than the specified's.
     * @this {!Long}
     * @param {!Long|number|bigint|string} other Other value
     * @returns {boolean}
     */
    LongPrototype.greaterThan = function greaterThan(other) {
      return this.comp(/* validates */ other) > 0;
    };

    /**
     * Tests if this Long's value is greater than the specified's. This is an alias of {@link Long#greaterThan}.
     * @function
     * @param {!Long|number|bigint|string} other Other value
     * @returns {boolean}
     */
    LongPrototype.gt = LongPrototype.greaterThan;

    /**
     * Tests if this Long's value is greater than or equal the specified's.
     * @this {!Long}
     * @param {!Long|number|bigint|string} other Other value
     * @returns {boolean}
     */
    LongPrototype.greaterThanOrEqual = function greaterThanOrEqual(other) {
      return this.comp(/* validates */ other) >= 0;
    };

    /**
     * Tests if this Long's value is greater than or equal the specified's. This is an alias of {@link Long#greaterThanOrEqual}.
     * @function
     * @param {!Long|number|bigint|string} other Other value
     * @returns {boolean}
     */
    LongPrototype.gte = LongPrototype.greaterThanOrEqual;

    /**
     * Tests if this Long's value is greater than or equal the specified's. This is an alias of {@link Long#greaterThanOrEqual}.
     * @function
     * @param {!Long|number|bigint|string} other Other value
     * @returns {boolean}
     */
    LongPrototype.ge = LongPrototype.greaterThanOrEqual;

    /**
     * Compares this Long's value with the specified's.
     * @this {!Long}
     * @param {!Long|number|bigint|string} other Other value
     * @returns {number} 0 if they are the same, 1 if the this is greater and -1
     *  if the given one is greater
     */
    LongPrototype.compare = function compare(other) {
      if (!isLong(other)) other = fromValue(other);
      if (this.eq(other)) return 0;
      var thisNeg = this.isNegative(),
        otherNeg = other.isNegative();
      if (thisNeg && !otherNeg) return -1;
      if (!thisNeg && otherNeg) return 1;
      // At this point the sign bits are the same
      if (!this.unsigned) return this.sub(other).isNegative() ? -1 : 1;
      // Both are positive if at least one is unsigned
      return other.high >>> 0 > this.high >>> 0 ||
        (other.high === this.high && other.low >>> 0 > this.low >>> 0)
        ? -1
        : 1;
    };

    /**
     * Compares this Long's value with the specified's. This is an alias of {@link Long#compare}.
     * @function
     * @param {!Long|number|bigint|string} other Other value
     * @returns {number} 0 if they are the same, 1 if the this is greater and -1
     *  if the given one is greater
     */
    LongPrototype.comp = LongPrototype.compare;

    /**
     * Negates this Long's value.
     * @this {!Long}
     * @returns {!Long} Negated Long
     */
    LongPrototype.negate = function negate() {
      if (!this.unsigned && this.eq(MIN_VALUE)) return MIN_VALUE;
      return this.not().add(ONE);
    };

    /**
     * Negates this Long's value. This is an alias of {@link Long#negate}.
     * @function
     * @returns {!Long} Negated Long
     */
    LongPrototype.neg = LongPrototype.negate;

    /**
     * Returns the sum of this and the specified Long.
     * @this {!Long}
     * @param {!Long|number|bigint|string} addend Addend
     * @returns {!Long} Sum
     */
    LongPrototype.add = function add(addend) {
      if (!isLong(addend)) addend = fromValue(addend);

      // Divide each number into 4 chunks of 16 bits, and then sum the chunks.

      var a48 = this.high >>> 16;
      var a32 = this.high & 0xffff;
      var a16 = this.low >>> 16;
      var a00 = this.low & 0xffff;
      var b48 = addend.high >>> 16;
      var b32 = addend.high & 0xffff;
      var b16 = addend.low >>> 16;
      var b00 = addend.low & 0xffff;
      var c48 = 0,
        c32 = 0,
        c16 = 0,
        c00 = 0;
      c00 += a00 + b00;
      c16 += c00 >>> 16;
      c00 &= 0xffff;
      c16 += a16 + b16;
      c32 += c16 >>> 16;
      c16 &= 0xffff;
      c32 += a32 + b32;
      c48 += c32 >>> 16;
      c32 &= 0xffff;
      c48 += a48 + b48;
      c48 &= 0xffff;
      return fromBits((c16 << 16) | c00, (c48 << 16) | c32, this.unsigned);
    };

    /**
     * Returns the difference of this and the specified Long.
     * @this {!Long}
     * @param {!Long|number|bigint|string} subtrahend Subtrahend
     * @returns {!Long} Difference
     */
    LongPrototype.subtract = function subtract(subtrahend) {
      if (!isLong(subtrahend)) subtrahend = fromValue(subtrahend);
      return this.add(subtrahend.neg());
    };

    /**
     * Returns the difference of this and the specified Long. This is an alias of {@link Long#subtract}.
     * @function
     * @param {!Long|number|bigint|string} subtrahend Subtrahend
     * @returns {!Long} Difference
     */
    LongPrototype.sub = LongPrototype.subtract;

    /**
     * Returns the product of this and the specified Long.
     * @this {!Long}
     * @param {!Long|number|bigint|string} multiplier Multiplier
     * @returns {!Long} Product
     */
    LongPrototype.multiply = function multiply(multiplier) {
      if (this.isZero()) return this;
      if (!isLong(multiplier)) multiplier = fromValue(multiplier);

      // use wasm support if present
      if (wasm) {
        var low = wasm["mul"](
          this.low,
          this.high,
          multiplier.low,
          multiplier.high,
        );
        return fromBits(low, wasm["get_high"](), this.unsigned);
      }
      if (multiplier.isZero()) return this.unsigned ? UZERO : ZERO;
      if (this.eq(MIN_VALUE)) return multiplier.isOdd() ? MIN_VALUE : ZERO;
      if (multiplier.eq(MIN_VALUE)) return this.isOdd() ? MIN_VALUE : ZERO;
      if (this.isNegative()) {
        if (multiplier.isNegative()) return this.neg().mul(multiplier.neg());
        else return this.neg().mul(multiplier).neg();
      } else if (multiplier.isNegative())
        return this.mul(multiplier.neg()).neg();

      // If both longs are small, use float multiplication
      if (this.lt(TWO_PWR_24) && multiplier.lt(TWO_PWR_24))
        return fromNumber(
          this.toNumber() * multiplier.toNumber(),
          this.unsigned,
        );

      // Divide each long into 4 chunks of 16 bits, and then add up 4x4 products.
      // We can skip products that would overflow.

      var a48 = this.high >>> 16;
      var a32 = this.high & 0xffff;
      var a16 = this.low >>> 16;
      var a00 = this.low & 0xffff;
      var b48 = multiplier.high >>> 16;
      var b32 = multiplier.high & 0xffff;
      var b16 = multiplier.low >>> 16;
      var b00 = multiplier.low & 0xffff;
      var c48 = 0,
        c32 = 0,
        c16 = 0,
        c00 = 0;
      c00 += a00 * b00;
      c16 += c00 >>> 16;
      c00 &= 0xffff;
      c16 += a16 * b00;
      c32 += c16 >>> 16;
      c16 &= 0xffff;
      c16 += a00 * b16;
      c32 += c16 >>> 16;
      c16 &= 0xffff;
      c32 += a32 * b00;
      c48 += c32 >>> 16;
      c32 &= 0xffff;
      c32 += a16 * b16;
      c48 += c32 >>> 16;
      c32 &= 0xffff;
      c32 += a00 * b32;
      c48 += c32 >>> 16;
      c32 &= 0xffff;
      c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
      c48 &= 0xffff;
      return fromBits((c16 << 16) | c00, (c48 << 16) | c32, this.unsigned);
    };

    /**
     * Returns the product of this and the specified Long. This is an alias of {@link Long#multiply}.
     * @function
     * @param {!Long|number|bigint|string} multiplier Multiplier
     * @returns {!Long} Product
     */
    LongPrototype.mul = LongPrototype.multiply;

    /**
     * Returns this Long divided by the specified. The result is signed if this Long is signed or
     *  unsigned if this Long is unsigned.
     * @this {!Long}
     * @param {!Long|number|bigint|string} divisor Divisor
     * @returns {!Long} Quotient
     */
    LongPrototype.divide = function divide(divisor) {
      if (!isLong(divisor)) divisor = fromValue(divisor);
      if (divisor.isZero()) throw Error("division by zero");

      // use wasm support if present
      if (wasm) {
        // guard against signed division overflow: the largest
        // negative number / -1 would be 1 larger than the largest
        // positive number, due to two's complement.
        if (
          !this.unsigned &&
          this.high === -0x80000000 &&
          divisor.low === -1 &&
          divisor.high === -1
        ) {
          // be consistent with non-wasm code path
          return this;
        }
        var low = (this.unsigned ? wasm["div_u"] : wasm["div_s"])(
          this.low,
          this.high,
          divisor.low,
          divisor.high,
        );
        return fromBits(low, wasm["get_high"](), this.unsigned);
      }
      if (this.isZero()) return this.unsigned ? UZERO : ZERO;
      var approx, rem, res;
      if (!this.unsigned) {
        // This section is only relevant for signed longs and is derived from the
        // closure library as a whole.
        if (this.eq(MIN_VALUE)) {
          if (divisor.eq(ONE) || divisor.eq(NEG_ONE))
            return MIN_VALUE; // recall that -MIN_VALUE == MIN_VALUE
          else if (divisor.eq(MIN_VALUE)) return ONE;
          else {
            // At this point, we have |other| >= 2, so |this/other| < |MIN_VALUE|.
            var halfThis = this.shr(1);
            approx = halfThis.div(divisor).shl(1);
            if (approx.eq(ZERO)) {
              return divisor.isNegative() ? ONE : NEG_ONE;
            } else {
              rem = this.sub(divisor.mul(approx));
              res = approx.add(rem.div(divisor));
              return res;
            }
          }
        } else if (divisor.eq(MIN_VALUE)) return this.unsigned ? UZERO : ZERO;
        if (this.isNegative()) {
          if (divisor.isNegative()) return this.neg().div(divisor.neg());
          return this.neg().div(divisor).neg();
        } else if (divisor.isNegative()) return this.div(divisor.neg()).neg();
        res = ZERO;
      } else {
        // The algorithm below has not been made for unsigned longs. It's therefore
        // required to take special care of the MSB prior to running it.
        if (!divisor.unsigned) divisor = divisor.toUnsigned();
        if (divisor.gt(this)) return UZERO;
        if (divisor.gt(this.shru(1)))
          // 15 >>> 1 = 7 ; with divisor = 8 ; true
          return UONE;
        res = UZERO;
      }

      // Repeat the following until the remainder is less than other:  find a
      // floating-point that approximates remainder / other *from below*, add this
      // into the result, and subtract it from the remainder.  It is critical that
      // the approximate value is less than or equal to the real value so that the
      // remainder never becomes negative.
      rem = this;
      while (rem.gte(divisor)) {
        // Approximate the result of division. This may be a little greater or
        // smaller than the actual value.
        approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber()));

        // We will tweak the approximate result by changing it in the 48-th digit or
        // the smallest non-fractional digit, whichever is larger.
        var log2 = Math.ceil(Math.log(approx) / Math.LN2),
          delta = log2 <= 48 ? 1 : pow_dbl(2, log2 - 48),
          // Decrease the approximation until it is smaller than the remainder.  Note
          // that if it is too large, the product overflows and is negative.
          approxRes = fromNumber(approx),
          approxRem = approxRes.mul(divisor);
        while (approxRem.isNegative() || approxRem.gt(rem)) {
          approx -= delta;
          approxRes = fromNumber(approx, this.unsigned);
          approxRem = approxRes.mul(divisor);
        }

        // We know the answer can't be zero... and actually, zero would cause
        // infinite recursion since we would make no progress.
        if (approxRes.isZero()) approxRes = ONE;
        res = res.add(approxRes);
        rem = rem.sub(approxRem);
      }
      return res;
    };

    /**
     * Returns this Long divided by the specified. This is an alias of {@link Long#divide}.
     * @function
     * @param {!Long|number|bigint|string} divisor Divisor
     * @returns {!Long} Quotient
     */
    LongPrototype.div = LongPrototype.divide;

    /**
     * Returns this Long modulo the specified.
     * @this {!Long}
     * @param {!Long|number|bigint|string} divisor Divisor
     * @returns {!Long} Remainder
     */
    LongPrototype.modulo = function modulo(divisor) {
      if (!isLong(divisor)) divisor = fromValue(divisor);

      // use wasm support if present
      if (wasm) {
        var low = (this.unsigned ? wasm["rem_u"] : wasm["rem_s"])(
          this.low,
          this.high,
          divisor.low,
          divisor.high,
        );
        return fromBits(low, wasm["get_high"](), this.unsigned);
      }
      return this.sub(this.div(divisor).mul(divisor));
    };

    /**
     * Returns this Long modulo the specified. This is an alias of {@link Long#modulo}.
     * @function
     * @param {!Long|number|bigint|string} divisor Divisor
     * @returns {!Long} Remainder
     */
    LongPrototype.mod = LongPrototype.modulo;

    /**
     * Returns this Long modulo the specified. This is an alias of {@link Long#modulo}.
     * @function
     * @param {!Long|number|bigint|string} divisor Divisor
     * @returns {!Long} Remainder
     */
    LongPrototype.rem = LongPrototype.modulo;

    /**
     * Returns the bitwise NOT of this Long.
     * @this {!Long}
     * @returns {!Long}
     */
    LongPrototype.not = function not() {
      return fromBits(~this.low, ~this.high, this.unsigned);
    };

    /**
     * Returns count leading zeros of this Long.
     * @this {!Long}
     * @returns {!number}
     */
    LongPrototype.countLeadingZeros = function countLeadingZeros() {
      return this.high ? Math.clz32(this.high) : Math.clz32(this.low) + 32;
    };

    /**
     * Returns count leading zeros. This is an alias of {@link Long#countLeadingZeros}.
     * @function
     * @param {!Long}
     * @returns {!number}
     */
    LongPrototype.clz = LongPrototype.countLeadingZeros;

    /**
     * Returns count trailing zeros of this Long.
     * @this {!Long}
     * @returns {!number}
     */
    LongPrototype.countTrailingZeros = function countTrailingZeros() {
      return this.low ? ctz32(this.low) : ctz32(this.high) + 32;
    };

    /**
     * Returns count trailing zeros. This is an alias of {@link Long#countTrailingZeros}.
     * @function
     * @param {!Long}
     * @returns {!number}
     */
    LongPrototype.ctz = LongPrototype.countTrailingZeros;

    /**
     * Returns the bitwise AND of this Long and the specified.
     * @this {!Long}
     * @param {!Long|number|bigint|string} other Other Long
     * @returns {!Long}
     */
    LongPrototype.and = function and(other) {
      if (!isLong(other)) other = fromValue(other);
      return fromBits(
        this.low & other.low,
        this.high & other.high,
        this.unsigned,
      );
    };

    /**
     * Returns the bitwise OR of this Long and the specified.
     * @this {!Long}
     * @param {!Long|number|bigint|string} other Other Long
     * @returns {!Long}
     */
    LongPrototype.or = function or(other) {
      if (!isLong(other)) other = fromValue(other);
      return fromBits(
        this.low | other.low,
        this.high | other.high,
        this.unsigned,
      );
    };

    /**
     * Returns the bitwise XOR of this Long and the given one.
     * @this {!Long}
     * @param {!Long|number|bigint|string} other Other Long
     * @returns {!Long}
     */
    LongPrototype.xor = function xor(other) {
      if (!isLong(other)) other = fromValue(other);
      return fromBits(
        this.low ^ other.low,
        this.high ^ other.high,
        this.unsigned,
      );
    };

    /**
     * Returns this Long with bits shifted to the left by the given amount.
     * @this {!Long}
     * @param {number|!Long} numBits Number of bits
     * @returns {!Long} Shifted Long
     */
    LongPrototype.shiftLeft = function shiftLeft(numBits) {
      if (isLong(numBits)) numBits = numBits.toInt();
      if ((numBits &= 63) === 0) return this;
      else if (numBits < 32)
        return fromBits(
          this.low << numBits,
          (this.high << numBits) | (this.low >>> (32 - numBits)),
          this.unsigned,
        );
      else return fromBits(0, this.low << (numBits - 32), this.unsigned);
    };

    /**
     * Returns this Long with bits shifted to the left by the given amount. This is an alias of {@link Long#shiftLeft}.
     * @function
     * @param {number|!Long} numBits Number of bits
     * @returns {!Long} Shifted Long
     */
    LongPrototype.shl = LongPrototype.shiftLeft;

    /**
     * Returns this Long with bits arithmetically shifted to the right by the given amount.
     * @this {!Long}
     * @param {number|!Long} numBits Number of bits
     * @returns {!Long} Shifted Long
     */
    LongPrototype.shiftRight = function shiftRight(numBits) {
      if (isLong(numBits)) numBits = numBits.toInt();
      if ((numBits &= 63) === 0) return this;
      else if (numBits < 32)
        return fromBits(
          (this.low >>> numBits) | (this.high << (32 - numBits)),
          this.high >> numBits,
          this.unsigned,
        );
      else
        return fromBits(
          this.high >> (numBits - 32),
          this.high >= 0 ? 0 : -1,
          this.unsigned,
        );
    };

    /**
     * Returns this Long with bits arithmetically shifted to the right by the given amount. This is an alias of {@link Long#shiftRight}.
     * @function
     * @param {number|!Long} numBits Number of bits
     * @returns {!Long} Shifted Long
     */
    LongPrototype.shr = LongPrototype.shiftRight;

    /**
     * Returns this Long with bits logically shifted to the right by the given amount.
     * @this {!Long}
     * @param {number|!Long} numBits Number of bits
     * @returns {!Long} Shifted Long
     */
    LongPrototype.shiftRightUnsigned = function shiftRightUnsigned(numBits) {
      if (isLong(numBits)) numBits = numBits.toInt();
      if ((numBits &= 63) === 0) return this;
      if (numBits < 32)
        return fromBits(
          (this.low >>> numBits) | (this.high << (32 - numBits)),
          this.high >>> numBits,
          this.unsigned,
        );
      if (numBits === 32) return fromBits(this.high, 0, this.unsigned);
      return fromBits(this.high >>> (numBits - 32), 0, this.unsigned);
    };

    /**
     * Returns this Long with bits logically shifted to the right by the given amount. This is an alias of {@link Long#shiftRightUnsigned}.
     * @function
     * @param {number|!Long} numBits Number of bits
     * @returns {!Long} Shifted Long
     */
    LongPrototype.shru = LongPrototype.shiftRightUnsigned;

    /**
     * Returns this Long with bits logically shifted to the right by the given amount. This is an alias of {@link Long#shiftRightUnsigned}.
     * @function
     * @param {number|!Long} numBits Number of bits
     * @returns {!Long} Shifted Long
     */
    LongPrototype.shr_u = LongPrototype.shiftRightUnsigned;

    /**
     * Returns this Long with bits rotated to the left by the given amount.
     * @this {!Long}
     * @param {number|!Long} numBits Number of bits
     * @returns {!Long} Rotated Long
     */
    LongPrototype.rotateLeft = function rotateLeft(numBits) {
      var b;
      if (isLong(numBits)) numBits = numBits.toInt();
      if ((numBits &= 63) === 0) return this;
      if (numBits === 32) return fromBits(this.high, this.low, this.unsigned);
      if (numBits < 32) {
        b = 32 - numBits;
        return fromBits(
          (this.low << numBits) | (this.high >>> b),
          (this.high << numBits) | (this.low >>> b),
          this.unsigned,
        );
      }
      numBits -= 32;
      b = 32 - numBits;
      return fromBits(
        (this.high << numBits) | (this.low >>> b),
        (this.low << numBits) | (this.high >>> b),
        this.unsigned,
      );
    };
    /**
     * Returns this Long with bits rotated to the left by the given amount. This is an alias of {@link Long#rotateLeft}.
     * @function
     * @param {number|!Long} numBits Number of bits
     * @returns {!Long} Rotated Long
     */
    LongPrototype.rotl = LongPrototype.rotateLeft;

    /**
     * Returns this Long with bits rotated to the right by the given amount.
     * @this {!Long}
     * @param {number|!Long} numBits Number of bits
     * @returns {!Long} Rotated Long
     */
    LongPrototype.rotateRight = function rotateRight(numBits) {
      var b;
      if (isLong(numBits)) numBits = numBits.toInt();
      if ((numBits &= 63) === 0) return this;
      if (numBits === 32) return fromBits(this.high, this.low, this.unsigned);
      if (numBits < 32) {
        b = 32 - numBits;
        return fromBits(
          (this.high << b) | (this.low >>> numBits),
          (this.low << b) | (this.high >>> numBits),
          this.unsigned,
        );
      }
      numBits -= 32;
      b = 32 - numBits;
      return fromBits(
        (this.low << b) | (this.high >>> numBits),
        (this.high << b) | (this.low >>> numBits),
        this.unsigned,
      );
    };
    /**
     * Returns this Long with bits rotated to the right by the given amount. This is an alias of {@link Long#rotateRight}.
     * @function
     * @param {number|!Long} numBits Number of bits
     * @returns {!Long} Rotated Long
     */
    LongPrototype.rotr = LongPrototype.rotateRight;

    /**
     * Converts this Long to signed.
     * @this {!Long}
     * @returns {!Long} Signed long
     */
    LongPrototype.toSigned = function toSigned() {
      if (!this.unsigned) return this;
      return fromBits(this.low, this.high, false);
    };

    /**
     * Converts this Long to unsigned.
     * @this {!Long}
     * @returns {!Long} Unsigned long
     */
    LongPrototype.toUnsigned = function toUnsigned() {
      if (this.unsigned) return this;
      return fromBits(this.low, this.high, true);
    };

    /**
     * Converts this Long to its byte representation.
     * @param {boolean=} le Whether little or big endian, defaults to big endian
     * @this {!Long}
     * @returns {!Array.<number>} Byte representation
     */
    LongPrototype.toBytes = function toBytes(le) {
      return le ? this.toBytesLE() : this.toBytesBE();
    };

    /**
     * Converts this Long to its little endian byte representation.
     * @this {!Long}
     * @returns {!Array.<number>} Little endian byte representation
     */
    LongPrototype.toBytesLE = function toBytesLE() {
      var hi = this.high,
        lo = this.low;
      return [
        lo & 0xff,
        (lo >>> 8) & 0xff,
        (lo >>> 16) & 0xff,
        lo >>> 24,
        hi & 0xff,
        (hi >>> 8) & 0xff,
        (hi >>> 16) & 0xff,
        hi >>> 24,
      ];
    };

    /**
     * Converts this Long to its big endian byte representation.
     * @this {!Long}
     * @returns {!Array.<number>} Big endian byte representation
     */
    LongPrototype.toBytesBE = function toBytesBE() {
      var hi = this.high,
        lo = this.low;
      return [
        hi >>> 24,
        (hi >>> 16) & 0xff,
        (hi >>> 8) & 0xff,
        hi & 0xff,
        lo >>> 24,
        (lo >>> 16) & 0xff,
        (lo >>> 8) & 0xff,
        lo & 0xff,
      ];
    };

    /**
     * Creates a Long from its byte representation.
     * @param {!Array.<number>} bytes Byte representation
     * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
     * @param {boolean=} le Whether little or big endian, defaults to big endian
     * @returns {Long} The corresponding Long value
     */
    Long.fromBytes = function fromBytes(bytes, unsigned, le) {
      return le
        ? Long.fromBytesLE(bytes, unsigned)
        : Long.fromBytesBE(bytes, unsigned);
    };

    /**
     * Creates a Long from its little endian byte representation.
     * @param {!Array.<number>} bytes Little endian byte representation
     * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
     * @returns {Long} The corresponding Long value
     */
    Long.fromBytesLE = function fromBytesLE(bytes, unsigned) {
      return new Long(
        bytes[0] | (bytes[1] << 8) | (bytes[2] << 16) | (bytes[3] << 24),
        bytes[4] | (bytes[5] << 8) | (bytes[6] << 16) | (bytes[7] << 24),
        unsigned,
      );
    };

    /**
     * Creates a Long from its big endian byte representation.
     * @param {!Array.<number>} bytes Big endian byte representation
     * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
     * @returns {Long} The corresponding Long value
     */
    Long.fromBytesBE = function fromBytesBE(bytes, unsigned) {
      return new Long(
        (bytes[4] << 24) | (bytes[5] << 16) | (bytes[6] << 8) | bytes[7],
        (bytes[0] << 24) | (bytes[1] << 16) | (bytes[2] << 8) | bytes[3],
        unsigned,
      );
    };

    // Support conversion to/from BigInt where available
    if (typeof BigInt === "function") {
      /**
       * Returns a Long representing the given big integer.
       * @function
       * @param {number} value The big integer value
       * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
       * @returns {!Long} The corresponding Long value
       */
      Long.fromBigInt = function fromBigInt(value, unsigned) {
        var lowBits = Number(BigInt.asIntN(32, value));
        var highBits = Number(BigInt.asIntN(32, value >> BigInt(32)));
        return fromBits(lowBits, highBits, unsigned);
      };

      // Override
      Long.fromValue = function fromValueWithBigInt(value, unsigned) {
        if (typeof value === "bigint") return Long.fromBigInt(value, unsigned);
        return fromValue(value, unsigned);
      };

      /**
       * Converts the Long to its big integer representation.
       * @this {!Long}
       * @returns {bigint}
       */
      LongPrototype.toBigInt = function toBigInt() {
        var lowBigInt = BigInt(this.low >>> 0);
        var highBigInt = BigInt(this.unsigned ? this.high >>> 0 : this.high);
        return (highBigInt << BigInt(32)) | lowBigInt;
      };
    }
    var _default = (_exports.default = Long);
  },
);


/***/ }),

/***/ 8789:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


/*
4.1 authentication: (http://bazaar.launchpad.net/~mysql/mysql-server/5.5/view/head:/sql/password.c)

  SERVER:  public_seed=create_random_string()
           send(public_seed)

  CLIENT:  recv(public_seed)
           hash_stage1=sha1("password")
           hash_stage2=sha1(hash_stage1)
           reply=xor(hash_stage1, sha1(public_seed,hash_stage2)

           // this three steps are done in scramble()

           send(reply)


  SERVER:  recv(reply)
           hash_stage1=xor(reply, sha1(public_seed,hash_stage2))
           candidate_hash2=sha1(hash_stage1)
           check(candidate_hash2==hash_stage2)

server stores sha1(sha1(password)) ( hash_stag2)
*/

const crypto = __nccwpck_require__(76982);

function sha1(msg, msg1, msg2) {
  const hash = crypto.createHash('sha1');
  hash.update(msg);
  if (msg1) {
    hash.update(msg1);
  }

  if (msg2) {
    hash.update(msg2);
  }

  return hash.digest();
}

function xor(a, b) {
  const result = Buffer.allocUnsafe(a.length);
  for (let i = 0; i < a.length; i++) {
    result[i] = a[i] ^ b[i];
  }
  return result;
}

exports.xor = xor;

function token(password, scramble1, scramble2) {
  if (!password) {
    return Buffer.alloc(0);
  }
  const stage1 = sha1(password);
  return exports.calculateTokenFromPasswordSha(stage1, scramble1, scramble2);
}

exports.calculateTokenFromPasswordSha = function (
  passwordSha,
  scramble1,
  scramble2
) {
  // we use AUTH 41 here, and we need only the bytes we just need.
  const authPluginData1 = scramble1.slice(0, 8);
  const authPluginData2 = scramble2.slice(0, 12);
  const stage2 = sha1(passwordSha);
  const stage3 = sha1(authPluginData1, authPluginData2, stage2);
  return xor(stage3, passwordSha);
};

exports.calculateToken = token;

exports.verifyToken = function (publicSeed1, publicSeed2, token, doubleSha) {
  const hashStage1 = xor(token, sha1(publicSeed1, publicSeed2, doubleSha));
  const candidateHash2 = sha1(hashStage1);
  return candidateHash2.compare(doubleSha) === 0;
};

exports.doubleSha1 = function (password) {
  return sha1(sha1(password));
};

function xorRotating(a, seed) {
  const result = Buffer.allocUnsafe(a.length);
  const seedLen = seed.length;

  for (let i = 0; i < a.length; i++) {
    result[i] = a[i] ^ seed[i % seedLen];
  }
  return result;
}
exports.xorRotating = xorRotating;


/***/ }),

/***/ 49049:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


// https://mysqlserverteam.com/mysql-8-0-4-new-default-authentication-plugin-caching_sha2_password/

const PLUGIN_NAME = 'caching_sha2_password';
const crypto = __nccwpck_require__(76982);
const { xor, xorRotating } = __nccwpck_require__(8789);

const REQUEST_SERVER_KEY_PACKET = Buffer.from([2]);
const FAST_AUTH_SUCCESS_PACKET = Buffer.from([3]);
const PERFORM_FULL_AUTHENTICATION_PACKET = Buffer.from([4]);

const STATE_INITIAL = 0;
const STATE_TOKEN_SENT = 1;
const STATE_WAIT_SERVER_KEY = 2;
const STATE_FINAL = -1;

function sha256(msg) {
  const hash = crypto.createHash('sha256');
  hash.update(msg);
  return hash.digest();
}

function calculateToken(password, scramble) {
  if (!password) {
    return Buffer.alloc(0);
  }
  const stage1 = sha256(Buffer.from(password));
  const stage2 = sha256(stage1);
  const stage3 = sha256(Buffer.concat([stage2, scramble]));
  return xor(stage1, stage3);
}

function encrypt(password, scramble, key) {
  const stage1 = xorRotating(Buffer.from(`${password}\0`, 'utf8'), scramble);
  return crypto.publicEncrypt(
    {
      key,
      padding: crypto.constants.RSA_PKCS1_OAEP_PADDING,
    },
    stage1
  );
}

module.exports =
  (pluginOptions = {}) =>
  ({ connection }) => {
    let state = 0;
    let scramble = null;

    const password = connection.config.password;

    const authWithKey = (serverKey) => {
      const _password = encrypt(password, scramble, serverKey);
      state = STATE_FINAL;
      return _password;
    };

    return (data) => {
      switch (state) {
        case STATE_INITIAL:
          scramble = data.slice(0, 20);
          state = STATE_TOKEN_SENT;
          return calculateToken(password, scramble);

        case STATE_TOKEN_SENT:
          if (FAST_AUTH_SUCCESS_PACKET.equals(data)) {
            state = STATE_FINAL;
            return null;
          }

          if (PERFORM_FULL_AUTHENTICATION_PACKET.equals(data)) {
            const isSecureConnection =
              typeof pluginOptions.overrideIsSecure === 'undefined'
                ? connection.config.ssl || connection.config.socketPath
                : pluginOptions.overrideIsSecure;
            if (isSecureConnection) {
              state = STATE_FINAL;
              return Buffer.from(`${password}\0`, 'utf8');
            }

            // if client provides key we can save one extra roundrip on first connection
            if (pluginOptions.serverPublicKey) {
              return authWithKey(pluginOptions.serverPublicKey);
            }

            state = STATE_WAIT_SERVER_KEY;
            return REQUEST_SERVER_KEY_PACKET;
          }
          throw new Error(
            `Invalid AuthMoreData packet received by ${PLUGIN_NAME} plugin in STATE_TOKEN_SENT state.`
          );
        case STATE_WAIT_SERVER_KEY:
          if (pluginOptions.onServerPublicKey) {
            pluginOptions.onServerPublicKey(data);
          }
          return authWithKey(data);
        case STATE_FINAL:
          throw new Error(
            `Unexpected data in AuthMoreData packet received by ${PLUGIN_NAME} plugin in STATE_FINAL state.`
          );
      }

      throw new Error(
        `Unexpected data in AuthMoreData packet received by ${PLUGIN_NAME} plugin in state ${state}`
      );
    };
  };


/***/ }),

/***/ 96531:
/***/ ((module) => {

"use strict";


function bufferFromStr(str) {
  return Buffer.from(`${str}\0`);
}

const create_mysql_clear_password_plugin = (pluginOptions) =>
  function mysql_clear_password_plugin({ connection, command }) {
    const password =
      command.password || pluginOptions.password || connection.config.password;

    return function (/* pluginData */) {
      return bufferFromStr(password);
    };
  };

module.exports = create_mysql_clear_password_plugin;


/***/ }),

/***/ 19423:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


//const PLUGIN_NAME = 'mysql_native_password';
const auth41 = __nccwpck_require__(8789);

module.exports =
  (pluginOptions) =>
  ({ connection, command }) => {
    const password =
      command.password || pluginOptions.password || connection.config.password;
    const passwordSha1 =
      command.passwordSha1 ||
      pluginOptions.passwordSha1 ||
      connection.config.passwordSha1;
    return (data) => {
      const authPluginData1 = data.slice(0, 8);
      const authPluginData2 = data.slice(8, 20);
      let authToken;
      if (passwordSha1) {
        authToken = auth41.calculateTokenFromPasswordSha(
          passwordSha1,
          authPluginData1,
          authPluginData2
        );
      } else {
        authToken = auth41.calculateToken(
          password,
          authPluginData1,
          authPluginData2
        );
      }
      return authToken;
    };
  };


/***/ }),

/***/ 87482:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


const PLUGIN_NAME = 'sha256_password';
const crypto = __nccwpck_require__(76982);
const { xorRotating } = __nccwpck_require__(8789);

const REQUEST_SERVER_KEY_PACKET = Buffer.from([1]);

const STATE_INITIAL = 0;
const STATE_WAIT_SERVER_KEY = 1;
const STATE_FINAL = -1;

function encrypt(password, scramble, key) {
  const stage1 = xorRotating(Buffer.from(`${password}\0`, 'utf8'), scramble);
  return crypto.publicEncrypt(key, stage1);
}

module.exports =
  (pluginOptions = {}) =>
  ({ connection }) => {
    let state = 0;
    let scramble = null;

    const password = connection.config.password;

    const authWithKey = (serverKey) => {
      const _password = encrypt(password, scramble, serverKey);
      state = STATE_FINAL;
      return _password;
    };

    return (data) => {
      switch (state) {
        case STATE_INITIAL:
          scramble = data.slice(0, 20);
          // if client provides key we can save one extra roundrip on first connection
          if (pluginOptions.serverPublicKey) {
            return authWithKey(pluginOptions.serverPublicKey);
          }

          state = STATE_WAIT_SERVER_KEY;
          return REQUEST_SERVER_KEY_PACKET;

        case STATE_WAIT_SERVER_KEY:
          if (pluginOptions.onServerPublicKey) {
            pluginOptions.onServerPublicKey(data);
          }
          return authWithKey(data);
        case STATE_FINAL:
          throw new Error(
            `Unexpected data in AuthMoreData packet received by ${PLUGIN_NAME} plugin in STATE_FINAL state.`
          );
      }

      throw new Error(
        `Unexpected data in AuthMoreData packet received by ${PLUGIN_NAME} plugin in state ${state}`
      );
    };
  };


/***/ }),

/***/ 15851:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";
// This file was modified by Oracle on June 1, 2021.
// The changes involve new logic to handle an additional ERR Packet sent by
// the MySQL server when the connection is closed unexpectedly.
// Modifications copyright (c) 2021, Oracle and/or its affiliates.

// This file was modified by Oracle on June 17, 2021.
// The changes involve logic to ensure the socket connection is closed when
// there is a fatal error.
// Modifications copyright (c) 2021, Oracle and/or its affiliates.

// This file was modified by Oracle on September 21, 2021.
// The changes involve passing additional authentication factor passwords
// to the ChangeUser Command instance.
// Modifications copyright (c) 2021, Oracle and/or its affiliates.



const Net = __nccwpck_require__(69278);
const Tls = __nccwpck_require__(64756);
const Timers = __nccwpck_require__(53557);
const EventEmitter = (__nccwpck_require__(24434).EventEmitter);
const Readable = (__nccwpck_require__(2203).Readable);
const Queue = __nccwpck_require__(19036);
const SqlString = __nccwpck_require__(16921);
const { createLRU } = __nccwpck_require__(46963);
const PacketParser = __nccwpck_require__(61379);
const Packets = __nccwpck_require__(17355);
const Commands = __nccwpck_require__(51900);
const ConnectionConfig = __nccwpck_require__(6566);
const CharsetToEncoding = __nccwpck_require__(89998);

let _connectionId = 0;

let convertNamedPlaceholders = null;

class BaseConnection extends EventEmitter {
  constructor(opts) {
    super();
    this.config = opts.config;
    // TODO: fill defaults
    // if no params, connect to /var/lib/mysql/mysql.sock ( /tmp/mysql.sock on OSX )
    // if host is given, connect to host:3306
    // TODO: use `/usr/local/mysql/bin/mysql_config --socket` output? as default socketPath
    // if there is no host/port and no socketPath parameters?
    if (!opts.config.stream) {
      if (opts.config.socketPath) {
        this.stream = Net.connect(opts.config.socketPath);
      } else {
        this.stream = Net.connect(opts.config.port, opts.config.host);

        // Optionally enable keep-alive on the socket.
        if (this.config.enableKeepAlive) {
          this.stream.on('connect', () => {
            this.stream.setKeepAlive(true, this.config.keepAliveInitialDelay);
          });
        }

        // Enable TCP_NODELAY flag. This is needed so that the network packets
        // are sent immediately to the server
        this.stream.setNoDelay(true);
      }
      // if stream is a function, treat it as "stream agent / factory"
    } else if (typeof opts.config.stream === 'function') {
      this.stream = opts.config.stream(opts);
    } else {
      this.stream = opts.config.stream;
    }

    this._internalId = _connectionId++;
    this._commands = new Queue();
    this._command = null;
    this._paused = false;
    this._paused_packets = new Queue();
    this._statements = createLRU({
      max: this.config.maxPreparedStatements,
      onEviction: function (_, statement) {
        statement.close();
      },
    });
    this.serverCapabilityFlags = 0;
    this.authorized = false;
    this.sequenceId = 0;
    this.compressedSequenceId = 0;
    this.threadId = null;
    this._handshakePacket = null;
    this._fatalError = null;
    this._protocolError = null;
    this._outOfOrderPackets = [];
    this.clientEncoding = CharsetToEncoding[this.config.charsetNumber];
    this.stream.on('error', this._handleNetworkError.bind(this));
    // see https://gist.github.com/khoomeister/4985691#use-that-instead-of-bind
    this.packetParser = new PacketParser((p) => {
      this.handlePacket(p);
    });
    this.stream.on('data', (data) => {
      if (this.connectTimeout) {
        Timers.clearTimeout(this.connectTimeout);
        this.connectTimeout = null;
      }
      this.packetParser.execute(data);
    });
    this.stream.on('end', () => {
      // emit the end event so that the pooled connection can close the connection
      this.emit('end');
    });
    this.stream.on('close', () => {
      // we need to set this flag everywhere where we want connection to close
      if (this._closing) {
        return;
      }
      if (!this._protocolError) {
        // no particular error message before disconnect
        this._protocolError = new Error(
          'Connection lost: The server closed the connection.'
        );
        this._protocolError.fatal = true;
        this._protocolError.code = 'PROTOCOL_CONNECTION_LOST';
      }
      this._notifyError(this._protocolError);
    });
    let handshakeCommand;
    if (!this.config.isServer) {
      handshakeCommand = new Commands.ClientHandshake(this.config.clientFlags);
      handshakeCommand.on('end', () => {
        // this happens when handshake finishes early either because there was
        // some fatal error or the server sent an error packet instead of
        // an hello packet (for example, 'Too many connections' error)
        if (
          !handshakeCommand.handshake ||
          this._fatalError ||
          this._protocolError
        ) {
          return;
        }
        this._handshakePacket = handshakeCommand.handshake;
        this.threadId = handshakeCommand.handshake.connectionId;
        this.emit('connect', handshakeCommand.handshake);
      });
      handshakeCommand.on('error', (err) => {
        this._closing = true;
        this._notifyError(err);
      });
      this.addCommand(handshakeCommand);
    }
    // in case there was no initial handshake but we need to read sting, assume it utf-8
    // most common example: "Too many connections" error ( packet is sent immediately on connection attempt, we don't know server encoding yet)
    // will be overwritten with actual encoding value as soon as server handshake packet is received
    this.serverEncoding = 'utf8';
    if (this.config.connectTimeout) {
      const timeoutHandler = this._handleTimeoutError.bind(this);
      this.connectTimeout = Timers.setTimeout(
        timeoutHandler,
        this.config.connectTimeout
      );
    }
  }

  _addCommandClosedState(cmd) {
    const err = new Error(
      "Can't add new command when connection is in closed state"
    );
    err.fatal = true;
    if (cmd.onResult) {
      cmd.onResult(err);
    } else {
      this.emit('error', err);
    }
  }

  _handleFatalError(err) {
    err.fatal = true;
    // stop receiving packets
    this.stream.removeAllListeners('data');
    this.addCommand = this._addCommandClosedState;
    this.write = () => {
      this.emit('error', new Error("Can't write in closed state"));
    };
    this._notifyError(err);
    this._fatalError = err;
  }

  _handleNetworkError(err) {
    if (this.connectTimeout) {
      Timers.clearTimeout(this.connectTimeout);
      this.connectTimeout = null;
    }
    // Do not throw an error when a connection ends with a RST,ACK packet
    if (err.code === 'ECONNRESET' && this._closing) {
      return;
    }
    this._handleFatalError(err);
  }

  _handleTimeoutError() {
    if (this.connectTimeout) {
      Timers.clearTimeout(this.connectTimeout);
      this.connectTimeout = null;
    }
    this.stream.destroy && this.stream.destroy();
    const err = new Error('connect ETIMEDOUT');
    err.errorno = 'ETIMEDOUT';
    err.code = 'ETIMEDOUT';
    err.syscall = 'connect';
    this._handleNetworkError(err);
  }

  // notify all commands in the queue and bubble error as connection "error"
  // called on stream error or unexpected termination
  _notifyError(err) {
    if (this.connectTimeout) {
      Timers.clearTimeout(this.connectTimeout);
      this.connectTimeout = null;
    }
    // prevent from emitting 'PROTOCOL_CONNECTION_LOST' after EPIPE or ECONNRESET
    if (this._fatalError) {
      return;
    }
    let command;
    // if there is no active command, notify connection
    // if there are commands and all of them have callbacks, pass error via callback
    let bubbleErrorToConnection = !this._command;
    if (this._command && this._command.onResult) {
      this._command.onResult(err);
      this._command = null;
      // connection handshake is special because we allow it to be implicit
      // if error happened during handshake, but there are others commands in queue
      // then bubble error to other commands and not to connection
    } else if (
      !(
        this._command &&
        this._command.constructor === Commands.ClientHandshake &&
        this._commands.length > 0
      )
    ) {
      bubbleErrorToConnection = true;
    }
    while ((command = this._commands.shift())) {
      if (command.onResult) {
        command.onResult(err);
      } else {
        bubbleErrorToConnection = true;
      }
    }
    // notify connection if some comands in the queue did not have callbacks
    // or if this is pool connection ( so it can be removed from pool )
    if (bubbleErrorToConnection || this._pool) {
      this.emit('error', err);
    }
    // close connection after emitting the event in case of a fatal error
    if (err.fatal) {
      this.close();
    }
  }

  write(buffer) {
    const result = this.stream.write(buffer, (err) => {
      if (err) {
        this._handleNetworkError(err);
      }
    });

    if (!result) {
      this.stream.emit('pause');
    }
  }

  // http://dev.mysql.com/doc/internals/en/sequence-id.html
  //
  // The sequence-id is incremented with each packet and may wrap around.
  // It starts at 0 and is reset to 0 when a new command
  // begins in the Command Phase.
  // http://dev.mysql.com/doc/internals/en/example-several-mysql-packets.html
  _resetSequenceId() {
    this.sequenceId = 0;
    this.compressedSequenceId = 0;
  }

  _bumpCompressedSequenceId(numPackets) {
    this.compressedSequenceId += numPackets;
    this.compressedSequenceId %= 256;
  }

  _bumpSequenceId(numPackets) {
    this.sequenceId += numPackets;
    this.sequenceId %= 256;
  }

  writePacket(packet) {
    const MAX_PACKET_LENGTH = 16777215;
    const length = packet.length();
    let chunk, offset, header;
    if (length < MAX_PACKET_LENGTH) {
      packet.writeHeader(this.sequenceId);
      if (this.config.debug) {
        console.log(
          `${this._internalId} ${this.connectionId} <== ${this._command._commandName}#${this._command.stateName()}(${[this.sequenceId, packet._name, packet.length()].join(',')})`
        );
        console.log(
          `${this._internalId} ${this.connectionId} <== ${packet.buffer.toString('hex')}`
        );
      }
      this._bumpSequenceId(1);
      this.write(packet.buffer);
    } else {
      if (this.config.debug) {
        console.log(
          `${this._internalId} ${this.connectionId} <== Writing large packet, raw content not written:`
        );
        console.log(
          `${this._internalId} ${this.connectionId} <== ${this._command._commandName}#${this._command.stateName()}(${[this.sequenceId, packet._name, packet.length()].join(',')})`
        );
      }
      for (offset = 4; offset < 4 + length; offset += MAX_PACKET_LENGTH) {
        chunk = packet.buffer.slice(offset, offset + MAX_PACKET_LENGTH);
        if (chunk.length === MAX_PACKET_LENGTH) {
          header = Buffer.from([0xff, 0xff, 0xff, this.sequenceId]);
        } else {
          header = Buffer.from([
            chunk.length & 0xff,
            (chunk.length >> 8) & 0xff,
            (chunk.length >> 16) & 0xff,
            this.sequenceId,
          ]);
        }
        this._bumpSequenceId(1);
        this.write(header);
        this.write(chunk);
      }
    }
  }

  // 0.11+ environment
  startTLS(onSecure) {
    if (this.config.debug) {
      console.log('Upgrading connection to TLS');
    }
    const secureContext = Tls.createSecureContext({
      ca: this.config.ssl.ca,
      cert: this.config.ssl.cert,
      ciphers: this.config.ssl.ciphers,
      key: this.config.ssl.key,
      passphrase: this.config.ssl.passphrase,
      minVersion: this.config.ssl.minVersion,
      maxVersion: this.config.ssl.maxVersion,
    });
    const rejectUnauthorized = this.config.ssl.rejectUnauthorized;
    const verifyIdentity = this.config.ssl.verifyIdentity;
    const servername = this.config.host;

    let secureEstablished = false;
    this.stream.removeAllListeners('data');
    const secureSocket = Tls.connect(
      {
        rejectUnauthorized,
        requestCert: rejectUnauthorized,
        checkServerIdentity: verifyIdentity
          ? Tls.checkServerIdentity
          : function () {
              return undefined;
            },
        secureContext,
        isServer: false,
        socket: this.stream,
        servername,
      },
      () => {
        secureEstablished = true;
        if (rejectUnauthorized) {
          if (typeof servername === 'string' && verifyIdentity) {
            const cert = secureSocket.getPeerCertificate(true);
            const serverIdentityCheckError = Tls.checkServerIdentity(
              servername,
              cert
            );
            if (serverIdentityCheckError) {
              onSecure(serverIdentityCheckError);
              return;
            }
          }
        }
        onSecure();
      }
    );
    // error handler for secure socket
    secureSocket.on('error', (err) => {
      if (secureEstablished) {
        this._handleNetworkError(err);
      } else {
        onSecure(err);
      }
    });
    secureSocket.on('data', (data) => {
      this.packetParser.execute(data);
    });
    this.stream = secureSocket;
  }

  protocolError(message, code) {
    // Starting with MySQL 8.0.24, if the client closes the connection
    // unexpectedly, the server will send a last ERR Packet, which we can
    // safely ignore.
    // https://dev.mysql.com/worklog/task/?id=12999
    if (this._closing) {
      return;
    }

    const err = new Error(message);
    err.fatal = true;
    err.code = code || 'PROTOCOL_ERROR';
    this.emit('error', err);
  }

  get fatalError() {
    return this._fatalError;
  }

  handlePacket(packet) {
    if (this._paused) {
      this._paused_packets.push(packet);
      return;
    }
    if (this.config.debug) {
      if (packet) {
        console.log(
          ` raw: ${packet.buffer
            .slice(packet.offset, packet.offset + packet.length())
            .toString('hex')}`
        );
        console.trace();
        const commandName = this._command
          ? this._command._commandName
          : '(no command)';
        const stateName = this._command
          ? this._command.stateName()
          : '(no command)';
        console.log(
          `${this._internalId} ${this.connectionId} ==> ${commandName}#${stateName}(${[packet.sequenceId, packet.type(), packet.length()].join(',')})`
        );
      }
    }
    if (!this._command) {
      const marker = packet.peekByte();
      // If it's an Err Packet, we should use it.
      if (marker === 0xff) {
        const error = Packets.Error.fromPacket(packet);
        this.protocolError(error.message, error.code);
      } else {
        // Otherwise, it means it's some other unexpected packet.
        this.protocolError(
          'Unexpected packet while no commands in the queue',
          'PROTOCOL_UNEXPECTED_PACKET'
        );
      }
      this.close();
      return;
    }
    if (packet) {
      // Note: when server closes connection due to inactivity, Err packet ER_CLIENT_INTERACTION_TIMEOUT from MySQL 8.0.24, sequenceId will be 0
      if (this.sequenceId !== packet.sequenceId) {
        const err = new Error(
          `Warning: got packets out of order. Expected ${this.sequenceId} but received ${packet.sequenceId}`
        );
        err.expected = this.sequenceId;
        err.received = packet.sequenceId;
        this.emit('warn', err); // REVIEW
        console.error(err.message);
      }
      this._bumpSequenceId(packet.numPackets);
    }
    try {
      if (this._fatalError) {
        // skip remaining packets after client is in the error state
        return;
      }
      const done = this._command.execute(packet, this);
      if (done) {
        this._command = this._commands.shift();
        if (this._command) {
          this.sequenceId = 0;
          this.compressedSequenceId = 0;
          this.handlePacket();
        }
      }
    } catch (err) {
      this._handleFatalError(err);
      this.stream.destroy();
    }
  }

  addCommand(cmd) {
    // this.compressedSequenceId = 0;
    // this.sequenceId = 0;
    if (this.config.debug) {
      const commandName = cmd.constructor.name;
      console.log(`Add command: ${commandName}`);
      cmd._commandName = commandName;
    }
    if (!this._command) {
      this._command = cmd;
      this.handlePacket();
    } else {
      this._commands.push(cmd);
    }
    return cmd;
  }

  format(sql, values) {
    if (typeof this.config.queryFormat === 'function') {
      return this.config.queryFormat.call(
        this,
        sql,
        values,
        this.config.timezone
      );
    }
    const opts = {
      sql: sql,
      values: values,
    };
    this._resolveNamedPlaceholders(opts);
    return SqlString.format(
      opts.sql,
      opts.values,
      this.config.stringifyObjects,
      this.config.timezone
    );
  }

  escape(value) {
    return SqlString.escape(value, false, this.config.timezone);
  }

  escapeId(value) {
    return SqlString.escapeId(value, false);
  }

  raw(sql) {
    return SqlString.raw(sql);
  }

  _resolveNamedPlaceholders(options) {
    let unnamed;
    if (this.config.namedPlaceholders || options.namedPlaceholders) {
      if (Array.isArray(options.values)) {
        // if an array is provided as the values, assume the conversion is not necessary.
        // this allows the usage of unnamed placeholders even if the namedPlaceholders flag is enabled.
        return;
      }
      if (convertNamedPlaceholders === null) {
        convertNamedPlaceholders = __nccwpck_require__(83154)();
      }
      unnamed = convertNamedPlaceholders(options.sql, options.values);
      options.sql = unnamed[0];
      options.values = unnamed[1];
    }
  }

  query(sql, values, cb) {
    let cmdQuery;
    if (sql.constructor === Commands.Query) {
      cmdQuery = sql;
    } else {
      cmdQuery = BaseConnection.createQuery(sql, values, cb, this.config);
    }
    this._resolveNamedPlaceholders(cmdQuery);
    const rawSql = this.format(
      cmdQuery.sql,
      cmdQuery.values !== undefined ? cmdQuery.values : []
    );
    cmdQuery.sql = rawSql;
    return this.addCommand(cmdQuery);
  }

  pause() {
    this._paused = true;
    this.stream.pause();
  }

  resume() {
    let packet;
    this._paused = false;
    while ((packet = this._paused_packets.shift())) {
      this.handlePacket(packet);
      // don't resume if packet handler paused connection
      if (this._paused) {
        return;
      }
    }
    this.stream.resume();
  }

  // TODO: named placeholders support
  prepare(options, cb) {
    if (typeof options === 'string') {
      options = { sql: options };
    }
    return this.addCommand(new Commands.Prepare(options, cb));
  }

  unprepare(sql) {
    let options = {};
    if (typeof sql === 'object') {
      options = sql;
    } else {
      options.sql = sql;
    }
    const key = BaseConnection.statementKey(options);
    const stmt = this._statements.get(key);
    if (stmt) {
      this._statements.delete(key);
      stmt.close();
    }
    return stmt;
  }

  execute(sql, values, cb) {
    let options = {
      infileStreamFactory: this.config.infileStreamFactory,
    };
    if (typeof sql === 'object') {
      // execute(options, cb)
      options = {
        ...options,
        ...sql,
        sql: sql.sql,
        values: sql.values,
      };
      if (typeof values === 'function') {
        cb = values;
      } else {
        options.values = options.values || values;
      }
    } else if (typeof values === 'function') {
      // execute(sql, cb)
      cb = values;
      options.sql = sql;
      options.values = undefined;
    } else {
      // execute(sql, values, cb)
      options.sql = sql;
      options.values = values;
    }
    this._resolveNamedPlaceholders(options);
    // check for values containing undefined
    if (options.values) {
      //If namedPlaceholder is not enabled and object is passed as bind parameters
      if (!Array.isArray(options.values)) {
        throw new TypeError(
          'Bind parameters must be array if namedPlaceholders parameter is not enabled'
        );
      }
      options.values.forEach((val) => {
        //If namedPlaceholder is not enabled and object is passed as bind parameters
        if (!Array.isArray(options.values)) {
          throw new TypeError(
            'Bind parameters must be array if namedPlaceholders parameter is not enabled'
          );
        }
        if (val === undefined) {
          throw new TypeError(
            'Bind parameters must not contain undefined. To pass SQL NULL specify JS null'
          );
        }
        if (typeof val === 'function') {
          throw new TypeError(
            'Bind parameters must not contain function(s). To pass the body of a function as a string call .toString() first'
          );
        }
      });
    }
    const executeCommand = new Commands.Execute(options, cb);
    const prepareCommand = new Commands.Prepare(options, (err, stmt) => {
      if (err) {
        // skip execute command if prepare failed, we have main
        // combined callback here
        executeCommand.start = function () {
          return null;
        };
        if (cb) {
          cb(err);
        } else {
          executeCommand.emit('error', err);
        }
        executeCommand.emit('end');
        return;
      }
      executeCommand.statement = stmt;
    });
    this.addCommand(prepareCommand);
    this.addCommand(executeCommand);
    return executeCommand;
  }

  changeUser(options, callback) {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = {};
    }
    const charsetNumber = options.charset
      ? ConnectionConfig.getCharsetNumber(options.charset)
      : this.config.charsetNumber;
    return this.addCommand(
      new Commands.ChangeUser(
        {
          user: options.user || this.config.user,
          // for the purpose of multi-factor authentication, or not, the main
          // password (used for the 1st authentication factor) can also be
          // provided via the "password1" option
          password:
            options.password ||
            options.password1 ||
            this.config.password ||
            this.config.password1,
          password2: options.password2 || this.config.password2,
          password3: options.password3 || this.config.password3,
          passwordSha1: options.passwordSha1 || this.config.passwordSha1,
          database: options.database || this.config.database,
          timeout: options.timeout,
          charsetNumber: charsetNumber,
          currentConfig: this.config,
        },
        (err) => {
          if (err) {
            err.fatal = true;
          }
          if (callback) {
            callback(err);
          }
        }
      )
    );
  }

  // transaction helpers
  beginTransaction(cb) {
    return this.query('START TRANSACTION', cb);
  }

  commit(cb) {
    return this.query('COMMIT', cb);
  }

  rollback(cb) {
    return this.query('ROLLBACK', cb);
  }

  ping(cb) {
    return this.addCommand(new Commands.Ping(cb));
  }

  _registerSlave(opts, cb) {
    return this.addCommand(new Commands.RegisterSlave(opts, cb));
  }

  _binlogDump(opts, cb) {
    return this.addCommand(new Commands.BinlogDump(opts, cb));
  }

  // currently just alias to close
  destroy() {
    this.close();
  }

  close() {
    if (this.connectTimeout) {
      Timers.clearTimeout(this.connectTimeout);
      this.connectTimeout = null;
    }
    this._closing = true;
    this.stream.end();
    this.addCommand = this._addCommandClosedState;
  }

  createBinlogStream(opts) {
    // TODO: create proper stream class
    // TODO: use through2
    let test = 1;
    const stream = new Readable({ objectMode: true });
    stream._read = function () {
      return {
        data: test++,
      };
    };
    this._registerSlave(opts, () => {
      const dumpCmd = this._binlogDump(opts);
      dumpCmd.on('event', (ev) => {
        stream.push(ev);
      });
      dumpCmd.on('eof', () => {
        stream.push(null);
        // if non-blocking, then close stream to prevent errors
        if (opts.flags && opts.flags & 0x01) {
          this.close();
        }
      });
      // TODO: pipe errors as well
    });
    return stream;
  }

  connect(cb) {
    if (!cb) {
      return;
    }
    if (this._fatalError || this._protocolError) {
      return cb(this._fatalError || this._protocolError);
    }
    if (this._handshakePacket) {
      return cb(null, this);
    }
    let connectCalled = 0;
    function callbackOnce(isErrorHandler) {
      return function (param) {
        if (!connectCalled) {
          if (isErrorHandler) {
            cb(param);
          } else {
            cb(null, param);
          }
        }
        connectCalled = 1;
      };
    }
    this.once('error', callbackOnce(true));
    this.once('connect', callbackOnce(false));
  }

  // ===================================
  // outgoing server connection methods
  // ===================================
  writeColumns(columns) {
    this.writePacket(Packets.ResultSetHeader.toPacket(columns.length));
    columns.forEach((column) => {
      this.writePacket(
        Packets.ColumnDefinition.toPacket(column, this.serverConfig.encoding)
      );
    });
    this.writeEof();
  }

  // row is array of columns, not hash
  writeTextRow(column) {
    this.writePacket(
      Packets.TextRow.toPacket(column, this.serverConfig.encoding)
    );
  }

  writeBinaryRow(column) {
    this.writePacket(
      Packets.BinaryRow.toPacket(column, this.serverConfig.encoding)
    );
  }

  writeTextResult(rows, columns, binary = false) {
    this.writeColumns(columns);
    rows.forEach((row) => {
      const arrayRow = new Array(columns.length);
      columns.forEach((column) => {
        arrayRow.push(row[column.name]);
      });
      if (binary) {
        this.writeBinaryRow(arrayRow);
      } else this.writeTextRow(arrayRow);
    });
    this.writeEof();
  }

  writeEof(warnings, statusFlags) {
    this.writePacket(Packets.EOF.toPacket(warnings, statusFlags));
  }

  writeOk(args) {
    if (!args) {
      args = { affectedRows: 0 };
    }
    this.writePacket(Packets.OK.toPacket(args, this.serverConfig.encoding));
  }

  writeError(args) {
    // if we want to send error before initial hello was sent, use default encoding
    const encoding = this.serverConfig ? this.serverConfig.encoding : 'cesu8';
    this.writePacket(Packets.Error.toPacket(args, encoding));
  }

  serverHandshake(args) {
    this.serverConfig = args;
    this.serverConfig.encoding =
      CharsetToEncoding[this.serverConfig.characterSet];
    return this.addCommand(new Commands.ServerHandshake(args));
  }

  // ===============================================================
  end(callback) {
    if (this.config.isServer) {
      this._closing = true;
      const quitCmd = new EventEmitter();
      setImmediate(() => {
        this.stream.end();
        quitCmd.emit('end');
      });
      return quitCmd;
    }
    // trigger error if more commands enqueued after end command
    const quitCmd = this.addCommand(new Commands.Quit(callback));
    this.addCommand = this._addCommandClosedState;
    return quitCmd;
  }

  static createQuery(sql, values, cb, config) {
    let options = {
      rowsAsArray: config.rowsAsArray,
      infileStreamFactory: config.infileStreamFactory,
    };
    if (typeof sql === 'object') {
      // query(options, cb)
      options = {
        ...options,
        ...sql,
        sql: sql.sql,
        values: sql.values,
      };
      if (typeof values === 'function') {
        cb = values;
      } else if (values !== undefined) {
        options.values = values;
      }
    } else if (typeof values === 'function') {
      // query(sql, cb)
      cb = values;
      options.sql = sql;
      options.values = undefined;
    } else {
      // query(sql, values, cb)
      options.sql = sql;
      options.values = values;
    }
    return new Commands.Query(options, cb);
  }

  static statementKey(options) {
    return `${typeof options.nestTables}/${options.nestTables}/${options.rowsAsArray}${options.sql}`;
  }
}

module.exports = BaseConnection;


/***/ }),

/***/ 80605:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


const process = __nccwpck_require__(932);
const SqlString = __nccwpck_require__(16921);
const EventEmitter = (__nccwpck_require__(24434).EventEmitter);
const PoolConnection = __nccwpck_require__(42062);
const Queue = __nccwpck_require__(19036);
const BaseConnection = __nccwpck_require__(15851);

function spliceConnection(queue, connection) {
  const len = queue.length;
  for (let i = 0; i < len; i++) {
    if (queue.get(i) === connection) {
      queue.removeOne(i);
      break;
    }
  }
}

class BasePool extends EventEmitter {
  constructor(options) {
    super();
    this.config = options.config;
    this.config.connectionConfig.pool = this;
    this._allConnections = new Queue();
    this._freeConnections = new Queue();
    this._connectionQueue = new Queue();
    this._closed = false;
    if (this.config.maxIdle < this.config.connectionLimit) {
      // create idle connection timeout automatically release job
      this._removeIdleTimeoutConnections();
    }
  }

  getConnection(cb) {
    if (this._closed) {
      return process.nextTick(() => cb(new Error('Pool is closed.')));
    }
    let connection;
    if (this._freeConnections.length > 0) {
      connection = this._freeConnections.pop();
      this.emit('acquire', connection);
      return process.nextTick(() => cb(null, connection));
    }
    if (
      this.config.connectionLimit === 0 ||
      this._allConnections.length < this.config.connectionLimit
    ) {
      connection = new PoolConnection(this, {
        config: this.config.connectionConfig,
      });
      this._allConnections.push(connection);
      return connection.connect((err) => {
        if (this._closed) {
          return cb(new Error('Pool is closed.'));
        }
        if (err) {
          return cb(err);
        }
        this.emit('connection', connection);
        this.emit('acquire', connection);
        return cb(null, connection);
      });
    }
    if (!this.config.waitForConnections) {
      return process.nextTick(() => cb(new Error('No connections available.')));
    }
    if (
      this.config.queueLimit &&
      this._connectionQueue.length >= this.config.queueLimit
    ) {
      return cb(new Error('Queue limit reached.'));
    }
    this.emit('enqueue');
    return this._connectionQueue.push(cb);
  }

  releaseConnection(connection) {
    let cb;
    if (!connection._pool) {
      // The connection has been removed from the pool and is no longer good.
      if (this._connectionQueue.length) {
        cb = this._connectionQueue.shift();
        process.nextTick(this.getConnection.bind(this, cb));
      }
    } else if (this._connectionQueue.length) {
      cb = this._connectionQueue.shift();
      process.nextTick(cb.bind(null, null, connection));
    } else {
      this._freeConnections.push(connection);
      this.emit('release', connection);
    }
  }

  end(cb) {
    this._closed = true;
    clearTimeout(this._removeIdleTimeoutConnectionsTimer);
    if (typeof cb !== 'function') {
      cb = function (err) {
        if (err) {
          throw err;
        }
      };
    }
    let calledBack = false;
    let closedConnections = 0;
    let connection;
    const endCB = function (err) {
      if (calledBack) {
        return;
      }
      if (err || ++closedConnections >= this._allConnections.length) {
        calledBack = true;
        cb(err);
        return;
      }
    }.bind(this);
    if (this._allConnections.length === 0) {
      endCB();
      return;
    }
    for (let i = 0; i < this._allConnections.length; i++) {
      connection = this._allConnections.get(i);
      connection._realEnd(endCB);
    }
  }

  query(sql, values, cb) {
    const cmdQuery = BaseConnection.createQuery(
      sql,
      values,
      cb,
      this.config.connectionConfig
    );
    if (typeof cmdQuery.namedPlaceholders === 'undefined') {
      cmdQuery.namedPlaceholders =
        this.config.connectionConfig.namedPlaceholders;
    }
    this.getConnection((err, conn) => {
      if (err) {
        if (typeof cmdQuery.onResult === 'function') {
          cmdQuery.onResult(err);
        } else {
          cmdQuery.emit('error', err);
        }
        return;
      }
      try {
        conn.query(cmdQuery).once('end', () => {
          conn.release();
        });
      } catch (e) {
        conn.release();
        throw e;
      }
    });
    return cmdQuery;
  }

  execute(sql, values, cb) {
    // TODO construct execute command first here and pass it to connection.execute
    // so that polymorphic arguments logic is there in one place
    if (typeof values === 'function') {
      cb = values;
      values = [];
    }
    this.getConnection((err, conn) => {
      if (err) {
        return cb(err);
      }
      try {
        conn.execute(sql, values, cb).once('end', () => {
          conn.release();
        });
      } catch (e) {
        conn.release();
        return cb(e);
      }
    });
  }

  _removeConnection(connection) {
    // Remove connection from all connections
    spliceConnection(this._allConnections, connection);
    // Remove connection from free connections
    spliceConnection(this._freeConnections, connection);
    this.releaseConnection(connection);
  }

  _removeIdleTimeoutConnections() {
    if (this._removeIdleTimeoutConnectionsTimer) {
      clearTimeout(this._removeIdleTimeoutConnectionsTimer);
    }

    this._removeIdleTimeoutConnectionsTimer = setTimeout(() => {
      try {
        while (
          this._freeConnections.length > this.config.maxIdle ||
          (this._freeConnections.length > 0 &&
            Date.now() - this._freeConnections.get(0).lastActiveTime >
              this.config.idleTimeout)
        ) {
          if (this.config.connectionConfig.gracefulEnd) {
            this._freeConnections.get(0).end();
          } else {
            this._freeConnections.get(0).destroy();
          }
        }
      } finally {
        this._removeIdleTimeoutConnections();
      }
    }, 1000);
  }

  format(sql, values) {
    return SqlString.format(
      sql,
      values,
      this.config.connectionConfig.stringifyObjects,
      this.config.connectionConfig.timezone
    );
  }

  escape(value) {
    return SqlString.escape(
      value,
      this.config.connectionConfig.stringifyObjects,
      this.config.connectionConfig.timezone
    );
  }

  escapeId(value) {
    return SqlString.escapeId(value, false);
  }
}

module.exports = BasePool;


/***/ }),

/***/ 49612:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


const BaseConnection = __nccwpck_require__(15851);

class BasePoolConnection extends BaseConnection {
  constructor(pool, options) {
    super(options);
    this._pool = pool;
    // The last active time of this connection
    this.lastActiveTime = Date.now();
    // When a fatal error occurs the connection's protocol ends, which will cause
    // the connection to end as well, thus we only need to watch for the end event
    // and we will be notified of disconnects.
    // REVIEW: Moved to `once`
    this.once('end', () => {
      this._removeFromPool();
    });
    this.once('error', () => {
      this._removeFromPool();
    });
  }

  release() {
    if (!this._pool || this._pool._closed) {
      return;
    }
    // update last active time
    this.lastActiveTime = Date.now();
    this._pool.releaseConnection(this);
  }

  end() {
    if (this.config.gracefulEnd) {
      this._removeFromPool();
      super.end();

      return;
    }

    const err = new Error(
      'Calling conn.end() to release a pooled connection is ' +
        'deprecated. In next version calling conn.end() will be ' +
        'restored to default conn.end() behavior. Use ' +
        'conn.release() instead.'
    );
    this.emit('warn', err);
    console.warn(err.message);
    this.release();
  }

  destroy() {
    this._removeFromPool();
    super.destroy();
  }

  _removeFromPool() {
    if (!this._pool || this._pool._closed) {
      return;
    }
    const pool = this._pool;
    this._pool = null;
    pool._removeConnection(this);
  }
}

BasePoolConnection.statementKey = BaseConnection.statementKey;
module.exports = BasePoolConnection;

// TODO: Remove this when we are removing PoolConnection#end
BasePoolConnection.prototype._realEnd = BaseConnection.prototype.end;


/***/ }),

/***/ 35423:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";
// This file was modified by Oracle on July 5, 2021.
// Errors generated by asynchronous authentication plugins are now being
// handled and subsequently emitted at the command level.
// Modifications copyright (c) 2021, Oracle and/or its affiliates.



const Packets = __nccwpck_require__(17355);
const sha256_password = __nccwpck_require__(87482);
const caching_sha2_password = __nccwpck_require__(49049);
const mysql_native_password = __nccwpck_require__(19423);
const mysql_clear_password = __nccwpck_require__(96531);

const standardAuthPlugins = {
  sha256_password: sha256_password({}),
  caching_sha2_password: caching_sha2_password({}),
  mysql_native_password: mysql_native_password({}),
  mysql_clear_password: mysql_clear_password({}),
};

function warnLegacyAuthSwitch() {
  console.warn(
    'WARNING! authSwitchHandler api is deprecated, please use new authPlugins api'
  );
}

function authSwitchPluginError(error, command) {
  // Authentication errors are fatal
  error.code = 'AUTH_SWITCH_PLUGIN_ERROR';
  error.fatal = true;

  command.emit('error', error);
}

function authSwitchRequest(packet, connection, command) {
  const { pluginName, pluginData } =
    Packets.AuthSwitchRequest.fromPacket(packet);
  let authPlugin =
    connection.config.authPlugins && connection.config.authPlugins[pluginName];

  // legacy plugin api don't allow to override mysql_native_password
  // if pluginName is mysql_native_password it's using standard auth4.1 auth
  if (
    connection.config.authSwitchHandler &&
    pluginName !== 'mysql_native_password'
  ) {
    const legacySwitchHandler = connection.config.authSwitchHandler;
    warnLegacyAuthSwitch();
    legacySwitchHandler({ pluginName, pluginData }, (err, data) => {
      if (err) {
        return authSwitchPluginError(err, command);
      }
      connection.writePacket(new Packets.AuthSwitchResponse(data).toPacket());
    });
    return;
  }
  if (!authPlugin) {
    authPlugin = standardAuthPlugins[pluginName];
  }
  if (!authPlugin) {
    throw new Error(
      `Server requests authentication using unknown plugin ${pluginName}. See ${'TODO: add plugins doco here'} on how to configure or author authentication plugins.`
    );
  }
  connection._authPlugin = authPlugin({ connection, command });
  Promise.resolve(connection._authPlugin(pluginData))
    .then((data) => {
      if (data) {
        connection.writePacket(new Packets.AuthSwitchResponse(data).toPacket());
      }
    })
    .catch((err) => {
      authSwitchPluginError(err, command);
    });
}

function authSwitchRequestMoreData(packet, connection, command) {
  const { data } = Packets.AuthSwitchRequestMoreData.fromPacket(packet);

  if (connection.config.authSwitchHandler) {
    const legacySwitchHandler = connection.config.authSwitchHandler;
    warnLegacyAuthSwitch();
    legacySwitchHandler({ pluginData: data }, (err, data) => {
      if (err) {
        return authSwitchPluginError(err, command);
      }
      connection.writePacket(new Packets.AuthSwitchResponse(data).toPacket());
    });
    return;
  }

  if (!connection._authPlugin) {
    throw new Error(
      'AuthPluginMoreData received but no auth plugin instance found'
    );
  }
  Promise.resolve(connection._authPlugin(data))
    .then((data) => {
      if (data) {
        connection.writePacket(new Packets.AuthSwitchResponse(data).toPacket());
      }
    })
    .catch((err) => {
      authSwitchPluginError(err, command);
    });
}

module.exports = {
  authSwitchRequest,
  authSwitchRequestMoreData,
};


/***/ }),

/***/ 96604:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


const Command = __nccwpck_require__(49009);
const Packets = __nccwpck_require__(17355);

const eventParsers = [];

class BinlogEventHeader {
  constructor(packet) {
    this.timestamp = packet.readInt32();
    this.eventType = packet.readInt8();
    this.serverId = packet.readInt32();
    this.eventSize = packet.readInt32();
    this.logPos = packet.readInt32();
    this.flags = packet.readInt16();
  }
}

class BinlogDump extends Command {
  constructor(opts) {
    super();
    // this.onResult = callback;
    this.opts = opts;
  }

  start(packet, connection) {
    const newPacket = new Packets.BinlogDump(this.opts);
    connection.writePacket(newPacket.toPacket(1));
    return BinlogDump.prototype.binlogData;
  }

  binlogData(packet) {
    // ok - continue consuming events
    // error - error
    // eof - end of binlog
    if (packet.isEOF()) {
      this.emit('eof');
      return null;
    }
    // binlog event header
    packet.readInt8();
    const header = new BinlogEventHeader(packet);
    const EventParser = eventParsers[header.eventType];
    let event;
    if (EventParser) {
      event = new EventParser(packet);
    } else {
      event = {
        name: 'UNKNOWN',
      };
    }
    event.header = header;
    this.emit('event', event);
    return BinlogDump.prototype.binlogData;
  }
}

class RotateEvent {
  constructor(packet) {
    this.pposition = packet.readInt32();
    // TODO: read uint64 here
    packet.readInt32(); // positionDword2
    this.nextBinlog = packet.readString();
    this.name = 'RotateEvent';
  }
}

class FormatDescriptionEvent {
  constructor(packet) {
    this.binlogVersion = packet.readInt16();
    this.serverVersion = packet.readString(50).replace(/\u0000.*/, ''); // eslint-disable-line no-control-regex
    this.createTimestamp = packet.readInt32();
    this.eventHeaderLength = packet.readInt8(); // should be 19
    this.eventsLength = packet.readBuffer();
    this.name = 'FormatDescriptionEvent';
  }
}

class QueryEvent {
  constructor(packet) {
    const parseStatusVars = __nccwpck_require__(81232);
    this.slaveProxyId = packet.readInt32();
    this.executionTime = packet.readInt32();
    const schemaLength = packet.readInt8();
    this.errorCode = packet.readInt16();
    const statusVarsLength = packet.readInt16();
    const statusVars = packet.readBuffer(statusVarsLength);
    this.schema = packet.readString(schemaLength);
    packet.readInt8(); // should be zero
    this.statusVars = parseStatusVars(statusVars);
    this.query = packet.readString();
    this.name = 'QueryEvent';
  }
}

class XidEvent {
  constructor(packet) {
    this.binlogVersion = packet.readInt16();
    this.xid = packet.readInt64();
    this.name = 'XidEvent';
  }
}

eventParsers[2] = QueryEvent;
eventParsers[4] = RotateEvent;
eventParsers[15] = FormatDescriptionEvent;
eventParsers[16] = XidEvent;

module.exports = BinlogDump;


/***/ }),

/***/ 52750:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";
// This file was modified by Oracle on September 21, 2021.
// The changes involve saving additional authentication factor passwords
// in the command scope and enabling multi-factor authentication in the
// client-side when the server supports it.
// Modifications copyright (c) 2021, Oracle and/or its affiliates.



const Command = __nccwpck_require__(49009);
const Packets = __nccwpck_require__(17355);
const ClientConstants = __nccwpck_require__(70060);
const ClientHandshake = __nccwpck_require__(31495);
const CharsetToEncoding = __nccwpck_require__(89998);

class ChangeUser extends Command {
  constructor(options, callback) {
    super();
    this.onResult = callback;
    this.user = options.user;
    this.password = options.password;
    // "password1" is an alias of "password"
    this.password1 = options.password;
    this.password2 = options.password2;
    this.password3 = options.password3;
    this.database = options.database;
    this.passwordSha1 = options.passwordSha1;
    this.charsetNumber = options.charsetNumber;
    this.currentConfig = options.currentConfig;
    this.authenticationFactor = 0;
  }
  start(packet, connection) {
    const newPacket = new Packets.ChangeUser({
      flags: connection.config.clientFlags,
      user: this.user,
      database: this.database,
      charsetNumber: this.charsetNumber,
      password: this.password,
      passwordSha1: this.passwordSha1,
      authPluginData1: connection._handshakePacket.authPluginData1,
      authPluginData2: connection._handshakePacket.authPluginData2,
    });
    this.currentConfig.user = this.user;
    this.currentConfig.password = this.password;
    this.currentConfig.database = this.database;
    this.currentConfig.charsetNumber = this.charsetNumber;
    connection.clientEncoding = CharsetToEncoding[this.charsetNumber];
    // clear prepared statements cache as all statements become invalid after changeUser
    connection._statements.clear();
    connection.writePacket(newPacket.toPacket());
    // check if the server supports multi-factor authentication
    const multiFactorAuthentication =
      connection.serverCapabilityFlags &
      ClientConstants.MULTI_FACTOR_AUTHENTICATION;
    if (multiFactorAuthentication) {
      // if the server supports multi-factor authentication, we enable it in
      // the client
      this.authenticationFactor = 1;
    }
    return ChangeUser.prototype.handshakeResult;
  }
}

ChangeUser.prototype.handshakeResult =
  ClientHandshake.prototype.handshakeResult;
ChangeUser.prototype.calculateNativePasswordAuthToken =
  ClientHandshake.prototype.calculateNativePasswordAuthToken;

module.exports = ChangeUser;


/***/ }),

/***/ 31495:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";
// This file was modified by Oracle on June 17, 2021.
// Handshake errors are now maked as fatal and the corresponding events are
// emitted in the command instance itself.
// Modifications copyright (c) 2021, Oracle and/or its affiliates.

// This file was modified by Oracle on September 21, 2021.
// Handshake workflow now supports additional authentication factors requested
// by the server.
// Modifications copyright (c) 2021, Oracle and/or its affiliates.



const Command = __nccwpck_require__(49009);
const Packets = __nccwpck_require__(17355);
const ClientConstants = __nccwpck_require__(70060);
const CharsetToEncoding = __nccwpck_require__(89998);
const auth41 = __nccwpck_require__(8789);

function flagNames(flags) {
  const res = [];
  for (const c in ClientConstants) {
    if (flags & ClientConstants[c]) {
      res.push(c.replace(/_/g, ' ').toLowerCase());
    }
  }
  return res;
}

class ClientHandshake extends Command {
  constructor(clientFlags) {
    super();
    this.handshake = null;
    this.clientFlags = clientFlags;
    this.authenticationFactor = 0;
  }

  start() {
    return ClientHandshake.prototype.handshakeInit;
  }

  sendSSLRequest(connection) {
    const sslRequest = new Packets.SSLRequest(
      this.clientFlags,
      connection.config.charsetNumber
    );
    connection.writePacket(sslRequest.toPacket());
  }

  sendCredentials(connection) {
    if (connection.config.debug) {
      // eslint-disable-next-line
      console.log(
        'Sending handshake packet: flags:%d=(%s)',
        this.clientFlags,
        flagNames(this.clientFlags).join(', ')
      );
    }
    this.user = connection.config.user;
    this.password = connection.config.password;
    // "password1" is an alias to the original "password" value
    // to make it easier to integrate multi-factor authentication
    this.password1 = connection.config.password;
    // "password2" and "password3" are the 2nd and 3rd factor authentication
    // passwords, which can be undefined depending on the authentication
    // plugin being used
    this.password2 = connection.config.password2;
    this.password3 = connection.config.password3;
    this.passwordSha1 = connection.config.passwordSha1;
    this.database = connection.config.database;
    this.authPluginName = this.handshake.authPluginName;
    const handshakeResponse = new Packets.HandshakeResponse({
      flags: this.clientFlags,
      user: this.user,
      database: this.database,
      password: this.password,
      passwordSha1: this.passwordSha1,
      charsetNumber: connection.config.charsetNumber,
      authPluginData1: this.handshake.authPluginData1,
      authPluginData2: this.handshake.authPluginData2,
      compress: connection.config.compress,
      connectAttributes: connection.config.connectAttributes,
    });
    connection.writePacket(handshakeResponse.toPacket());
  }

  calculateNativePasswordAuthToken(authPluginData) {
    // TODO: dont split into authPluginData1 and authPluginData2, instead join when 1 & 2 received
    const authPluginData1 = authPluginData.slice(0, 8);
    const authPluginData2 = authPluginData.slice(8, 20);
    let authToken;
    if (this.passwordSha1) {
      authToken = auth41.calculateTokenFromPasswordSha(
        this.passwordSha1,
        authPluginData1,
        authPluginData2
      );
    } else {
      authToken = auth41.calculateToken(
        this.password,
        authPluginData1,
        authPluginData2
      );
    }
    return authToken;
  }

  handshakeInit(helloPacket, connection) {
    this.on('error', (e) => {
      connection._fatalError = e;
      connection._protocolError = e;
    });
    this.handshake = Packets.Handshake.fromPacket(helloPacket);
    if (connection.config.debug) {
      // eslint-disable-next-line
      console.log(
        'Server hello packet: capability flags:%d=(%s)',
        this.handshake.capabilityFlags,
        flagNames(this.handshake.capabilityFlags).join(', ')
      );
    }
    connection.serverCapabilityFlags = this.handshake.capabilityFlags;
    connection.serverEncoding = CharsetToEncoding[this.handshake.characterSet];
    connection.connectionId = this.handshake.connectionId;
    const serverSSLSupport =
      this.handshake.capabilityFlags & ClientConstants.SSL;
    // multi factor authentication is enabled with the
    // "MULTI_FACTOR_AUTHENTICATION" capability and should only be used if it
    // is supported by the server
    const multiFactorAuthentication =
      this.handshake.capabilityFlags &
      ClientConstants.MULTI_FACTOR_AUTHENTICATION;
    this.clientFlags = this.clientFlags | multiFactorAuthentication;
    // use compression only if requested by client and supported by server
    connection.config.compress =
      connection.config.compress &&
      this.handshake.capabilityFlags & ClientConstants.COMPRESS;
    this.clientFlags = this.clientFlags | connection.config.compress;
    if (connection.config.ssl) {
      // client requires SSL but server does not support it
      if (!serverSSLSupport) {
        const err = new Error('Server does not support secure connection');
        err.code = 'HANDSHAKE_NO_SSL_SUPPORT';
        err.fatal = true;
        this.emit('error', err);
        return false;
      }
      // send ssl upgrade request and immediately upgrade connection to secure
      this.clientFlags |= ClientConstants.SSL;
      this.sendSSLRequest(connection);
      connection.startTLS((err) => {
        // after connection is secure
        if (err) {
          // SSL negotiation error are fatal
          err.code = 'HANDSHAKE_SSL_ERROR';
          err.fatal = true;
          this.emit('error', err);
          return;
        }
        // rest of communication is encrypted
        this.sendCredentials(connection);
      });
    } else {
      this.sendCredentials(connection);
    }
    if (multiFactorAuthentication) {
      // if the server supports multi-factor authentication, we enable it in
      // the client
      this.authenticationFactor = 1;
    }
    return ClientHandshake.prototype.handshakeResult;
  }

  handshakeResult(packet, connection) {
    const marker = packet.peekByte();
    // packet can be OK_Packet, ERR_Packet, AuthSwitchRequest, AuthNextFactor
    // or AuthMoreData
    if (marker === 0xfe || marker === 1 || marker === 0x02) {
      const authSwitch = __nccwpck_require__(35423);
      try {
        if (marker === 1) {
          authSwitch.authSwitchRequestMoreData(packet, connection, this);
        } else {
          // if authenticationFactor === 0, it means the server does not support
          // the multi-factor authentication capability
          if (this.authenticationFactor !== 0) {
            // if we are past the first authentication factor, we should use the
            // corresponding password (if there is one)
            connection.config.password =
              this[`password${this.authenticationFactor}`];
            // update the current authentication factor
            this.authenticationFactor += 1;
          }
          // if marker === 0x02, it means it is an AuthNextFactor packet,
          // which is similar in structure to an AuthSwitchRequest packet,
          // so, we can use it directly
          authSwitch.authSwitchRequest(packet, connection, this);
        }
        return ClientHandshake.prototype.handshakeResult;
      } catch (err) {
        // Authentication errors are fatal
        err.code = 'AUTH_SWITCH_PLUGIN_ERROR';
        err.fatal = true;

        if (this.onResult) {
          this.onResult(err);
        } else {
          this.emit('error', err);
        }
        return null;
      }
    }
    if (marker !== 0) {
      const err = new Error('Unexpected packet during handshake phase');
      // Unknown handshake errors are fatal
      err.code = 'HANDSHAKE_UNKNOWN_ERROR';
      err.fatal = true;

      if (this.onResult) {
        this.onResult(err);
      } else {
        this.emit('error', err);
      }
      return null;
    }
    // this should be called from ClientHandshake command only
    // and skipped when called from ChangeUser command
    if (!connection.authorized) {
      connection.authorized = true;
      if (connection.config.compress) {
        const enableCompression =
          (__nccwpck_require__(3475).enableCompression);
        enableCompression(connection);
      }
    }
    if (this.onResult) {
      this.onResult(null);
    }
    return null;
  }
}
module.exports = ClientHandshake;


/***/ }),

/***/ 42374:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


const Command = __nccwpck_require__(49009);
const Packets = __nccwpck_require__(17355);

class CloseStatement extends Command {
  constructor(id) {
    super();
    this.id = id;
  }

  start(packet, connection) {
    connection.writePacket(new Packets.CloseStatement(this.id).toPacket(1));
    return null;
  }
}

module.exports = CloseStatement;


/***/ }),

/***/ 49009:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


const EventEmitter = (__nccwpck_require__(24434).EventEmitter);
const Timers = __nccwpck_require__(53557);

class Command extends EventEmitter {
  constructor() {
    super();
    this.next = null;
  }

  // slow. debug only
  stateName() {
    const state = this.next;
    for (const i in this) {
      if (this[i] === state && i !== 'next') {
        return i;
      }
    }
    return 'unknown name';
  }

  execute(packet, connection) {
    if (!this.next) {
      this.next = this.start;
      connection._resetSequenceId();
    }
    if (packet && packet.isError()) {
      const err = packet.asError(connection.clientEncoding);
      err.sql = this.sql || this.query;
      if (this.queryTimeout) {
        Timers.clearTimeout(this.queryTimeout);
        this.queryTimeout = null;
      }
      if (this.onResult) {
        this.onResult(err);
        this.emit('end');
      } else {
        this.emit('error', err);
        this.emit('end');
      }
      return true;
    }
    // TODO: don't return anything from execute, it's ugly and error-prone. Listen for 'end' event in connection
    this.next = this.next(packet, connection);
    if (this.next) {
      return false;
    }
    this.emit('end');
    return true;
  }
}

module.exports = Command;


/***/ }),

/***/ 27683:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


const Command = __nccwpck_require__(49009);
const Query = __nccwpck_require__(83156);
const Packets = __nccwpck_require__(17355);

const getBinaryParser = __nccwpck_require__(28835);
const getStaticBinaryParser = __nccwpck_require__(67640);

class Execute extends Command {
  constructor(options, callback) {
    super();
    this.statement = options.statement;
    this.sql = options.sql;
    this.values = options.values;
    this.onResult = callback;
    this.parameters = options.values;
    this.insertId = 0;
    this.timeout = options.timeout;
    this.queryTimeout = null;
    this._rows = [];
    this._fields = [];
    this._result = [];
    this._fieldCount = 0;
    this._rowParser = null;
    this._executeOptions = options;
    this._resultIndex = 0;
    this._localStream = null;
    this._unpipeStream = function () {};
    this._streamFactory = options.infileStreamFactory;
    this._connection = null;
  }

  buildParserFromFields(fields, connection) {
    if (this.options.disableEval) {
      return getStaticBinaryParser(fields, this.options, connection.config);
    }

    return getBinaryParser(fields, this.options, connection.config);
  }

  start(packet, connection) {
    this._connection = connection;
    this.options = Object.assign({}, connection.config, this._executeOptions);
    this._setTimeout();
    const executePacket = new Packets.Execute(
      this.statement.id,
      this.parameters,
      connection.config.charsetNumber,
      connection.config.timezone
    );
    //For reasons why this try-catch is here, please see
    // https://github.com/sidorares/node-mysql2/pull/689
    //For additional discussion, see
    // 1. https://github.com/sidorares/node-mysql2/issues/493
    // 2. https://github.com/sidorares/node-mysql2/issues/187
    // 3. https://github.com/sidorares/node-mysql2/issues/480
    try {
      connection.writePacket(executePacket.toPacket(1));
    } catch (error) {
      this.onResult(error);
    }
    return Execute.prototype.resultsetHeader;
  }

  readField(packet, connection) {
    let fields;
    // disabling for now, but would be great to find reliable way to parse fields only once
    // fields reported by prepare can be empty at all or just incorrect - see #169
    //
    // perfomance optimisation: if we already have this field parsed in statement header, use one from header
    // const field = this.statement.columns.length == this._fieldCount ?
    //  this.statement.columns[this._receivedFieldsCount] : new Packets.ColumnDefinition(packet);
    const field = new Packets.ColumnDefinition(
      packet,
      connection.clientEncoding
    );
    this._receivedFieldsCount++;
    this._fields[this._resultIndex].push(field);
    if (this._receivedFieldsCount === this._fieldCount) {
      fields = this._fields[this._resultIndex];
      this.emit('fields', fields, this._resultIndex);
      return Execute.prototype.fieldsEOF;
    }
    return Execute.prototype.readField;
  }

  fieldsEOF(packet, connection) {
    // check EOF
    if (!packet.isEOF()) {
      return connection.protocolError('Expected EOF packet');
    }
    this._rowParser = new (this.buildParserFromFields(
      this._fields[this._resultIndex],
      connection
    ))();
    return Execute.prototype.row;
  }
}

Execute.prototype.done = Query.prototype.done;
Execute.prototype.doneInsert = Query.prototype.doneInsert;
Execute.prototype.resultsetHeader = Query.prototype.resultsetHeader;
Execute.prototype._findOrCreateReadStream =
  Query.prototype._findOrCreateReadStream;
Execute.prototype._streamLocalInfile = Query.prototype._streamLocalInfile;
Execute.prototype._setTimeout = Query.prototype._setTimeout;
Execute.prototype._handleTimeoutError = Query.prototype._handleTimeoutError;
Execute.prototype.row = Query.prototype.row;
Execute.prototype.stream = Query.prototype.stream;

module.exports = Execute;


/***/ }),

/***/ 51900:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


const ClientHandshake = __nccwpck_require__(31495);
const ServerHandshake = __nccwpck_require__(84419);
const Query = __nccwpck_require__(83156);
const Prepare = __nccwpck_require__(88575);
const CloseStatement = __nccwpck_require__(42374);
const Execute = __nccwpck_require__(27683);
const Ping = __nccwpck_require__(8350);
const RegisterSlave = __nccwpck_require__(5491);
const BinlogDump = __nccwpck_require__(96604);
const ChangeUser = __nccwpck_require__(52750);
const Quit = __nccwpck_require__(69533);

module.exports = {
  ClientHandshake,
  ServerHandshake,
  Query,
  Prepare,
  CloseStatement,
  Execute,
  Ping,
  RegisterSlave,
  BinlogDump,
  ChangeUser,
  Quit,
};


/***/ }),

/***/ 8350:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


const Command = __nccwpck_require__(49009);
const CommandCode = __nccwpck_require__(17361);
const Packet = __nccwpck_require__(43743);

// TODO: time statistics?
// usefull for queue size and network latency monitoring
// store created,sent,reply timestamps
class Ping extends Command {
  constructor(callback) {
    super();
    this.onResult = callback;
  }

  start(packet, connection) {
    const ping = new Packet(
      0,
      Buffer.from([1, 0, 0, 0, CommandCode.PING]),
      0,
      5
    );
    connection.writePacket(ping);
    return Ping.prototype.pingResponse;
  }

  pingResponse() {
    // TODO: check it's OK packet. error check already done in caller
    if (this.onResult) {
      process.nextTick(this.onResult.bind(this));
    }
    return null;
  }
}

module.exports = Ping;


/***/ }),

/***/ 88575:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


const Packets = __nccwpck_require__(17355);
const Command = __nccwpck_require__(49009);
const CloseStatement = __nccwpck_require__(42374);
const Execute = __nccwpck_require__(27683);

class PreparedStatementInfo {
  constructor(query, id, columns, parameters, connection) {
    this.query = query;
    this.id = id;
    this.columns = columns;
    this.parameters = parameters;
    this.rowParser = null;
    this._connection = connection;
  }

  close() {
    return this._connection.addCommand(new CloseStatement(this.id));
  }

  execute(parameters, callback) {
    if (typeof parameters === 'function') {
      callback = parameters;
      parameters = [];
    }
    return this._connection.addCommand(
      new Execute({ statement: this, values: parameters }, callback)
    );
  }
}

class Prepare extends Command {
  constructor(options, callback) {
    super();
    this.query = options.sql;
    this.onResult = callback;
    this.id = 0;
    this.fieldCount = 0;
    this.parameterCount = 0;
    this.fields = [];
    this.parameterDefinitions = [];
    this.options = options;
  }

  start(packet, connection) {
    const Connection = connection.constructor;
    this.key = Connection.statementKey(this.options);
    const statement = connection._statements.get(this.key);
    if (statement) {
      if (this.onResult) {
        this.onResult(null, statement);
      }
      return null;
    }
    const cmdPacket = new Packets.PrepareStatement(
      this.query,
      connection.config.charsetNumber,
      this.options.values
    );
    connection.writePacket(cmdPacket.toPacket(1));
    return Prepare.prototype.prepareHeader;
  }

  prepareHeader(packet, connection) {
    const header = new Packets.PreparedStatementHeader(packet);
    this.id = header.id;
    this.fieldCount = header.fieldCount;
    this.parameterCount = header.parameterCount;
    if (this.parameterCount > 0) {
      return Prepare.prototype.readParameter;
    }
    if (this.fieldCount > 0) {
      return Prepare.prototype.readField;
    }
    return this.prepareDone(connection);
  }

  readParameter(packet, connection) {
    // there might be scenarios when mysql server reports more parameters than
    // are actually present in the array of parameter definitions.
    // if EOF packet is received we switch to "read fields" state if there are
    // any fields reported by the server, otherwise we finish the command.
    if (packet.isEOF()) {
      if (this.fieldCount > 0) {
        return Prepare.prototype.readField;
      }
      return this.prepareDone(connection);
    }
    const def = new Packets.ColumnDefinition(packet, connection.clientEncoding);
    this.parameterDefinitions.push(def);
    if (this.parameterDefinitions.length === this.parameterCount) {
      return Prepare.prototype.parametersEOF;
    }
    return this.readParameter;
  }

  readField(packet, connection) {
    if (packet.isEOF()) {
      return this.prepareDone(connection);
    }
    const def = new Packets.ColumnDefinition(packet, connection.clientEncoding);
    this.fields.push(def);
    if (this.fields.length === this.fieldCount) {
      return Prepare.prototype.fieldsEOF;
    }
    return Prepare.prototype.readField;
  }

  parametersEOF(packet, connection) {
    if (!packet.isEOF()) {
      return connection.protocolError('Expected EOF packet after parameters');
    }
    if (this.fieldCount > 0) {
      return Prepare.prototype.readField;
    }
    return this.prepareDone(connection);
  }

  fieldsEOF(packet, connection) {
    if (!packet.isEOF()) {
      return connection.protocolError('Expected EOF packet after fields');
    }
    return this.prepareDone(connection);
  }

  prepareDone(connection) {
    const statement = new PreparedStatementInfo(
      this.query,
      this.id,
      this.fields,
      this.parameterDefinitions,
      connection
    );
    connection._statements.set(this.key, statement);
    if (this.onResult) {
      this.onResult(null, statement);
    }
    return null;
  }
}

module.exports = Prepare;


/***/ }),

/***/ 83156:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


const process = __nccwpck_require__(932);
const Timers = __nccwpck_require__(53557);

const Readable = (__nccwpck_require__(2203).Readable);

const Command = __nccwpck_require__(49009);
const Packets = __nccwpck_require__(17355);
const getTextParser = __nccwpck_require__(50265);
const staticParser = __nccwpck_require__(70454);
const ServerStatus = __nccwpck_require__(92609);

const EmptyPacket = new Packets.Packet(0, Buffer.allocUnsafe(4), 0, 4);

// http://dev.mysql.com/doc/internals/en/com-query.html
class Query extends Command {
  constructor(options, callback) {
    super();
    this.sql = options.sql;
    this.values = options.values;
    this._queryOptions = options;
    this.namedPlaceholders = options.namedPlaceholders || false;
    this.onResult = callback;
    this.timeout = options.timeout;
    this.queryTimeout = null;
    this._fieldCount = 0;
    this._rowParser = null;
    this._fields = [];
    this._rows = [];
    this._receivedFieldsCount = 0;
    this._resultIndex = 0;
    this._localStream = null;
    this._unpipeStream = function () {};
    this._streamFactory = options.infileStreamFactory;
    this._connection = null;
  }

  then() {
    const err =
      "You have tried to call .then(), .catch(), or invoked await on the result of query that is not a promise, which is a programming error. Try calling con.promise().query(), or require('mysql2/promise') instead of 'mysql2' for a promise-compatible version of the query interface. To learn how to use async/await or Promises check out documentation at https://sidorares.github.io/node-mysql2/docs#using-promise-wrapper, or the mysql2 documentation at https://sidorares.github.io/node-mysql2/docs/documentation/promise-wrapper";
    // eslint-disable-next-line
    console.log(err);
    throw new Error(err);
  }

  /* eslint no-unused-vars: ["error", { "argsIgnorePattern": "^_" }] */
  start(_packet, connection) {
    if (connection.config.debug) {
      // eslint-disable-next-line
      console.log('        Sending query command: %s', this.sql);
    }
    this._connection = connection;
    this.options = Object.assign({}, connection.config, this._queryOptions);
    this._setTimeout();

    const cmdPacket = new Packets.Query(
      this.sql,
      connection.config.charsetNumber
    );
    connection.writePacket(cmdPacket.toPacket(1));
    return Query.prototype.resultsetHeader;
  }

  done() {
    this._unpipeStream();
    // if all ready timeout, return null directly
    if (this.timeout && !this.queryTimeout) {
      return null;
    }
    // else clear timer
    if (this.queryTimeout) {
      Timers.clearTimeout(this.queryTimeout);
      this.queryTimeout = null;
    }
    if (this.onResult) {
      let rows, fields;
      if (this._resultIndex === 0) {
        rows = this._rows[0];
        fields = this._fields[0];
      } else {
        rows = this._rows;
        fields = this._fields;
      }
      if (fields) {
        process.nextTick(() => {
          this.onResult(null, rows, fields);
        });
      } else {
        process.nextTick(() => {
          this.onResult(null, rows);
        });
      }
    }
    return null;
  }

  doneInsert(rs) {
    if (this._localStreamError) {
      if (this.onResult) {
        this.onResult(this._localStreamError, rs);
      } else {
        this.emit('error', this._localStreamError);
      }
      return null;
    }
    this._rows.push(rs);
    this._fields.push(void 0);
    this.emit('fields', void 0);
    this.emit('result', rs);
    if (rs.serverStatus & ServerStatus.SERVER_MORE_RESULTS_EXISTS) {
      this._resultIndex++;
      return this.resultsetHeader;
    }
    return this.done();
  }

  resultsetHeader(packet, connection) {
    const rs = new Packets.ResultSetHeader(packet, connection);
    this._fieldCount = rs.fieldCount;
    if (connection.config.debug) {
      // eslint-disable-next-line
      console.log(
        `        Resultset header received, expecting ${rs.fieldCount} column definition packets`
      );
    }
    if (this._fieldCount === 0) {
      return this.doneInsert(rs);
    }
    if (this._fieldCount === null) {
      return this._streamLocalInfile(connection, rs.infileName);
    }
    this._receivedFieldsCount = 0;
    this._rows.push([]);
    this._fields.push([]);
    return this.readField;
  }

  _streamLocalInfile(connection, path) {
    if (this._streamFactory) {
      this._localStream = this._streamFactory(path);
    } else {
      this._localStreamError = new Error(
        `As a result of LOCAL INFILE command server wants to read ${path} file, but as of v2.0 you must provide streamFactory option returning ReadStream.`
      );
      connection.writePacket(EmptyPacket);
      return this.infileOk;
    }

    const onConnectionError = () => {
      this._unpipeStream();
    };
    const onDrain = () => {
      this._localStream.resume();
    };
    const onPause = () => {
      this._localStream.pause();
    };
    const onData = function (data) {
      const dataWithHeader = Buffer.allocUnsafe(data.length + 4);
      data.copy(dataWithHeader, 4);
      connection.writePacket(
        new Packets.Packet(0, dataWithHeader, 0, dataWithHeader.length)
      );
    };
    const onEnd = () => {
      connection.removeListener('error', onConnectionError);
      connection.writePacket(EmptyPacket);
    };
    const onError = (err) => {
      this._localStreamError = err;
      connection.removeListener('error', onConnectionError);
      connection.writePacket(EmptyPacket);
    };
    this._unpipeStream = () => {
      connection.stream.removeListener('pause', onPause);
      connection.stream.removeListener('drain', onDrain);
      this._localStream.removeListener('data', onData);
      this._localStream.removeListener('end', onEnd);
      this._localStream.removeListener('error', onError);
    };
    connection.stream.on('pause', onPause);
    connection.stream.on('drain', onDrain);
    this._localStream.on('data', onData);
    this._localStream.on('end', onEnd);
    this._localStream.on('error', onError);
    connection.once('error', onConnectionError);
    return this.infileOk;
  }

  readField(packet, connection) {
    this._receivedFieldsCount++;
    // Often there is much more data in the column definition than in the row itself
    // If you set manually _fields[0] to array of ColumnDefinition's (from previous call)
    // you can 'cache' result of parsing. Field packets still received, but ignored in that case
    // this is the reason _receivedFieldsCount exist (otherwise we could just use current length of fields array)
    if (this._fields[this._resultIndex].length !== this._fieldCount) {
      const field = new Packets.ColumnDefinition(
        packet,
        connection.clientEncoding
      );
      this._fields[this._resultIndex].push(field);
      if (connection.config.debug) {
        /* eslint-disable no-console */
        console.log('        Column definition:');
        console.log(`          name: ${field.name}`);
        console.log(`          type: ${field.columnType}`);
        console.log(`         flags: ${field.flags}`);
        /* eslint-enable no-console */
      }
    }
    // last field received
    if (this._receivedFieldsCount === this._fieldCount) {
      const fields = this._fields[this._resultIndex];
      this.emit('fields', fields);
      if (this.options.disableEval) {
        this._rowParser = staticParser(fields, this.options, connection.config);
      } else {
        this._rowParser = new (getTextParser(
          fields,
          this.options,
          connection.config
        ))(fields);
      }
      return Query.prototype.fieldsEOF;
    }
    return Query.prototype.readField;
  }

  fieldsEOF(packet, connection) {
    // check EOF
    if (!packet.isEOF()) {
      return connection.protocolError('Expected EOF packet');
    }
    return this.row;
  }

  /* eslint no-unused-vars: ["error", { "argsIgnorePattern": "^_" }] */
  row(packet, _connection) {
    if (packet.isEOF()) {
      const status = packet.eofStatusFlags();
      const moreResults = status & ServerStatus.SERVER_MORE_RESULTS_EXISTS;
      if (moreResults) {
        this._resultIndex++;
        return Query.prototype.resultsetHeader;
      }
      return this.done();
    }
    let row;
    try {
      row = this._rowParser.next(
        packet,
        this._fields[this._resultIndex],
        this.options
      );
    } catch (err) {
      this._localStreamError = err;
      return this.doneInsert(null);
    }
    if (this.onResult) {
      this._rows[this._resultIndex].push(row);
    } else {
      this.emit('result', row, this._resultIndex);
    }
    return Query.prototype.row;
  }

  infileOk(packet, connection) {
    const rs = new Packets.ResultSetHeader(packet, connection);
    return this.doneInsert(rs);
  }

  stream(options) {
    options = options || Object.create(null);
    options.objectMode = true;

    const stream = new Readable({
      ...options,
      emitClose: true,
      autoDestroy: true,
      read: () => {
        this._connection && this._connection.resume();
      },
    });

    // Prevent a breaking change for users that rely on `end` event
    stream.once('close', () => {
      if (!stream.readableEnded) {
        stream.emit('end');
      }
    });

    const onResult = (row, index) => {
      if (stream.destroyed) return;

      if (!stream.push(row)) {
        this._connection && this._connection.pause();
      }

      stream.emit('result', row, index); // replicate old emitter
    };

    const onFields = (fields) => {
      if (stream.destroyed) return;

      stream.emit('fields', fields); // replicate old emitter
    };

    const onEnd = () => {
      if (stream.destroyed) return;

      stream.push(null); // pushing null, indicating EOF
    };

    const onError = (err) => {
      stream.destroy(err);
    };

    stream._destroy = (err, cb) => {
      this._connection && this._connection.resume();

      this.removeListener('result', onResult);
      this.removeListener('fields', onFields);
      this.removeListener('end', onEnd);
      this.removeListener('error', onError);

      cb(err); // Pass on any errors
    };

    this.on('result', onResult);
    this.on('fields', onFields);
    this.on('end', onEnd);
    this.on('error', onError);

    return stream;
  }

  _setTimeout() {
    if (this.timeout) {
      const timeoutHandler = this._handleTimeoutError.bind(this);
      this.queryTimeout = Timers.setTimeout(timeoutHandler, this.timeout);
    }
  }

  _handleTimeoutError() {
    if (this.queryTimeout) {
      Timers.clearTimeout(this.queryTimeout);
      this.queryTimeout = null;
    }

    const err = new Error('Query inactivity timeout');
    err.errorno = 'PROTOCOL_SEQUENCE_TIMEOUT';
    err.code = 'PROTOCOL_SEQUENCE_TIMEOUT';
    err.syscall = 'query';

    if (this.onResult) {
      this.onResult(err);
    } else {
      this.emit('error', err);
    }
  }
}

Query.prototype.catch = Query.prototype.then;

module.exports = Query;


/***/ }),

/***/ 69533:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


const Command = __nccwpck_require__(49009);
const CommandCode = __nccwpck_require__(17361);
const Packet = __nccwpck_require__(43743);

class Quit extends Command {
  constructor(callback) {
    super();
    this.onResult = callback;
  }

  start(packet, connection) {
    connection._closing = true;
    const quit = new Packet(
      0,
      Buffer.from([1, 0, 0, 0, CommandCode.QUIT]),
      0,
      5
    );
    if (this.onResult) {
      this.onResult();
    }
    connection.writePacket(quit);
    return null;
  }
}

module.exports = Quit;


/***/ }),

/***/ 5491:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


const Command = __nccwpck_require__(49009);
const Packets = __nccwpck_require__(17355);

class RegisterSlave extends Command {
  constructor(opts, callback) {
    super();
    this.onResult = callback;
    this.opts = opts;
  }

  start(packet, connection) {
    const newPacket = new Packets.RegisterSlave(this.opts);
    connection.writePacket(newPacket.toPacket(1));
    return RegisterSlave.prototype.registerResponse;
  }

  registerResponse() {
    if (this.onResult) {
      process.nextTick(this.onResult.bind(this));
    }
    return null;
  }
}

module.exports = RegisterSlave;


/***/ }),

/***/ 84419:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


const CommandCode = __nccwpck_require__(17361);
const Errors = __nccwpck_require__(89228);

const Command = __nccwpck_require__(49009);
const Packets = __nccwpck_require__(17355);

class ServerHandshake extends Command {
  constructor(args) {
    super();
    this.args = args;
    /*
    this.protocolVersion = args.protocolVersion || 10;
    this.serverVersion   = args.serverVersion;
    this.connectionId    = args.connectionId,
    this.statusFlags     = args.statusFlags,
    this.characterSet    = args.characterSet,
    this.capabilityFlags = args.capabilityFlags || 512;
    */
  }

  start(packet, connection) {
    const serverHelloPacket = new Packets.Handshake(this.args);
    this.serverHello = serverHelloPacket;
    serverHelloPacket.setScrambleData((err) => {
      if (err) {
        connection.emit('error', new Error('Error generating random bytes'));
        return;
      }
      connection.writePacket(serverHelloPacket.toPacket(0));
    });
    return ServerHandshake.prototype.readClientReply;
  }

  readClientReply(packet, connection) {
    // check auth here
    const clientHelloReply = Packets.HandshakeResponse.fromPacket(packet);
    // TODO check we don't have something similar already
    connection.clientHelloReply = clientHelloReply;
    if (this.args.authCallback) {
      this.args.authCallback(
        {
          user: clientHelloReply.user,
          database: clientHelloReply.database,
          address: connection.stream.remoteAddress,
          authPluginData1: this.serverHello.authPluginData1,
          authPluginData2: this.serverHello.authPluginData2,
          authToken: clientHelloReply.authToken,
        },
        (err, mysqlError) => {
          // if (err)
          if (!mysqlError) {
            connection.writeOk();
          } else {
            // TODO create constants / errorToCode
            // 1045 = ER_ACCESS_DENIED_ERROR
            connection.writeError({
              message: mysqlError.message || '',
              code: mysqlError.code || 1045,
            });
            connection.close();
          }
        }
      );
    } else {
      connection.writeOk();
    }
    return ServerHandshake.prototype.dispatchCommands;
  }

  _isStatement(query, name) {
    const firstWord = query.split(' ')[0].toUpperCase();
    return firstWord === name;
  }

  dispatchCommands(packet, connection) {
    // command from client to server
    let knownCommand = true;
    const encoding = connection.clientHelloReply.encoding;
    const commandCode = packet.readInt8();
    switch (commandCode) {
      case CommandCode.STMT_PREPARE:
        if (connection.listeners('stmt_prepare').length) {
          const query = packet.readString(undefined, encoding);
          connection.emit('stmt_prepare', query);
        } else {
          connection.writeError({
            code: Errors.HA_ERR_INTERNAL_ERROR,
            message: 'No query handler for prepared statements.',
          });
        }
        break;
      case CommandCode.STMT_EXECUTE:
        if (connection.listeners('stmt_execute').length) {
          const { stmtId, flags, iterationCount, values } =
            Packets.Execute.fromPacket(packet, encoding);
          connection.emit(
            'stmt_execute',
            stmtId,
            flags,
            iterationCount,
            values
          );
        } else {
          connection.writeError({
            code: Errors.HA_ERR_INTERNAL_ERROR,
            message: 'No query handler for execute statements.',
          });
        }
        break;
      case CommandCode.QUIT:
        if (connection.listeners('quit').length) {
          connection.emit('quit');
        } else {
          connection.stream.end();
        }
        break;
      case CommandCode.INIT_DB:
        if (connection.listeners('init_db').length) {
          const schemaName = packet.readString(undefined, encoding);
          connection.emit('init_db', schemaName);
        } else {
          connection.writeOk();
        }
        break;
      case CommandCode.QUERY:
        if (connection.listeners('query').length) {
          const query = packet.readString(undefined, encoding);
          if (
            this._isStatement(query, 'PREPARE') ||
            this._isStatement(query, 'SET')
          ) {
            connection.emit('stmt_prepare', query);
          } else if (this._isStatement(query, 'EXECUTE')) {
            connection.emit('stmt_execute', null, null, null, null, query);
          } else connection.emit('query', query);
        } else {
          connection.writeError({
            code: Errors.HA_ERR_INTERNAL_ERROR,
            message: 'No query handler',
          });
        }
        break;
      case CommandCode.FIELD_LIST:
        if (connection.listeners('field_list').length) {
          const table = packet.readNullTerminatedString(encoding);
          const fields = packet.readString(undefined, encoding);
          connection.emit('field_list', table, fields);
        } else {
          connection.writeError({
            code: Errors.ER_WARN_DEPRECATED_SYNTAX,
            message:
              'As of MySQL 5.7.11, COM_FIELD_LIST is deprecated and will be removed in a future version of MySQL.',
          });
        }
        break;
      case CommandCode.PING:
        if (connection.listeners('ping').length) {
          connection.emit('ping');
        } else {
          connection.writeOk();
        }
        break;
      default:
        knownCommand = false;
    }
    if (connection.listeners('packet').length) {
      connection.emit('packet', packet.clone(), knownCommand, commandCode);
    } else if (!knownCommand) {
      // eslint-disable-next-line no-console
      console.log('Unknown command:', commandCode);
    }
    return ServerHandshake.prototype.dispatchCommands;
  }
}

module.exports = ServerHandshake;

// TODO: implement server-side 4.1 authentication
/*
4.1 authentication: (http://bazaar.launchpad.net/~mysql/mysql-server/5.5/view/head:/sql/password.c)

  SERVER:  public_seed=create_random_string()
           send(public_seed)

  CLIENT:  recv(public_seed)
           hash_stage1=sha1("password")
           hash_stage2=sha1(hash_stage1)
           reply=xor(hash_stage1, sha1(public_seed,hash_stage2)

           // this three steps are done in scramble()

           send(reply)


  SERVER:  recv(reply)
           hash_stage1=xor(reply, sha1(public_seed,hash_stage2))
           candidate_hash2=sha1(hash_stage1)
           check(candidate_hash2==hash_stage2)

server stores sha1(sha1(password)) ( hash_stag2)
*/


/***/ }),

/***/ 3475:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


// connection mixins
// implementation of http://dev.mysql.com/doc/internals/en/compression.html

const zlib = __nccwpck_require__(43106);
const PacketParser = __nccwpck_require__(61379);

function handleCompressedPacket(packet) {
  // eslint-disable-next-line consistent-this, no-invalid-this
  const connection = this;
  const deflatedLength = packet.readInt24();
  const body = packet.readBuffer();

  if (deflatedLength !== 0) {
    connection.inflateQueue.push((task) => {
      zlib.inflate(body, (err, data) => {
        if (err) {
          connection._handleNetworkError(err);
          return;
        }
        connection._bumpCompressedSequenceId(packet.numPackets);
        connection._inflatedPacketsParser.execute(data);
        task.done();
      });
    });
  } else {
    connection.inflateQueue.push((task) => {
      connection._bumpCompressedSequenceId(packet.numPackets);
      connection._inflatedPacketsParser.execute(body);
      task.done();
    });
  }
}

function writeCompressed(buffer) {
  // http://dev.mysql.com/doc/internals/en/example-several-mysql-packets.html
  // note: sending a MySQL Packet of the size 2^24‚àí5 to 2^24‚àí1 via compression
  // leads to at least one extra compressed packet.
  // (this is because "length of the packet before compression" need to fit
  // into 3 byte unsigned int. "length of the packet before compression" includes
  // 4 byte packet header, hence 2^24‚àí5)
  const MAX_COMPRESSED_LENGTH = 16777210;
  let start;
  if (buffer.length > MAX_COMPRESSED_LENGTH) {
    for (start = 0; start < buffer.length; start += MAX_COMPRESSED_LENGTH) {
      writeCompressed.call(
        // eslint-disable-next-line no-invalid-this
        this,
        buffer.slice(start, start + MAX_COMPRESSED_LENGTH)
      );
    }
    return;
  }

  // eslint-disable-next-line no-invalid-this, consistent-this
  const connection = this;

  let packetLen = buffer.length;
  const compressHeader = Buffer.allocUnsafe(7);

  // seqqueue is used here because zlib async execution is routed via thread pool
  // internally and when we have multiple compressed packets arriving we need
  // to assemble uncompressed result sequentially
  (function (seqId) {
    connection.deflateQueue.push((task) => {
      zlib.deflate(buffer, (err, compressed) => {
        if (err) {
          connection._handleFatalError(err);
          return;
        }
        let compressedLength = compressed.length;

        if (compressedLength < packetLen) {
          compressHeader.writeUInt8(compressedLength & 0xff, 0);
          compressHeader.writeUInt16LE(compressedLength >> 8, 1);
          compressHeader.writeUInt8(seqId, 3);
          compressHeader.writeUInt8(packetLen & 0xff, 4);
          compressHeader.writeUInt16LE(packetLen >> 8, 5);
          connection.writeUncompressed(compressHeader);
          connection.writeUncompressed(compressed);
        } else {
          // http://dev.mysql.com/doc/internals/en/uncompressed-payload.html
          // To send an uncompressed payload:
          //   - set length of payload before compression to 0
          //   - the compressed payload contains the uncompressed payload instead.
          compressedLength = packetLen;
          packetLen = 0;
          compressHeader.writeUInt8(compressedLength & 0xff, 0);
          compressHeader.writeUInt16LE(compressedLength >> 8, 1);
          compressHeader.writeUInt8(seqId, 3);
          compressHeader.writeUInt8(packetLen & 0xff, 4);
          compressHeader.writeUInt16LE(packetLen >> 8, 5);
          connection.writeUncompressed(compressHeader);
          connection.writeUncompressed(buffer);
        }
        task.done();
      });
    });
  })(connection.compressedSequenceId);
  connection._bumpCompressedSequenceId(1);
}

function enableCompression(connection) {
  connection._lastWrittenPacketId = 0;
  connection._lastReceivedPacketId = 0;

  connection._handleCompressedPacket = handleCompressedPacket;
  connection._inflatedPacketsParser = new PacketParser((p) => {
    connection.handlePacket(p);
  }, 4);
  connection._inflatedPacketsParser._lastPacket = 0;
  connection.packetParser = new PacketParser((packet) => {
    connection._handleCompressedPacket(packet);
  }, 7);

  connection.writeUncompressed = connection.write;
  connection.write = writeCompressed;

  const seqqueue = __nccwpck_require__(99221);
  connection.inflateQueue = seqqueue.createQueue();
  connection.deflateQueue = seqqueue.createQueue();
}

module.exports = {
  enableCompression: enableCompression,
};


/***/ }),

/***/ 58661:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


const BaseConnection = __nccwpck_require__(15851);

class Connection extends BaseConnection {
  promise(promiseImpl) {
    const PromiseConnection = __nccwpck_require__(52079);
    return new PromiseConnection(this, promiseImpl);
  }
}

module.exports = Connection;


/***/ }),

/***/ 6566:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";
// This file was modified by Oracle on September 21, 2021.
// New connection options for additional authentication factors were
// introduced.
// Multi-factor authentication capability is now enabled if one of these
// options is used.
// Modifications copyright (c) 2021, Oracle and/or its affiliates.



const { URL } = __nccwpck_require__(87016);
const ClientConstants = __nccwpck_require__(70060);
const Charsets = __nccwpck_require__(33286);
const { version } = __nccwpck_require__(87466);
let SSLProfiles = null;

const validOptions = {
  authPlugins: 1,
  authSwitchHandler: 1,
  bigNumberStrings: 1,
  charset: 1,
  charsetNumber: 1,
  compress: 1,
  connectAttributes: 1,
  connectTimeout: 1,
  database: 1,
  dateStrings: 1,
  debug: 1,
  decimalNumbers: 1,
  enableKeepAlive: 1,
  flags: 1,
  host: 1,
  insecureAuth: 1,
  infileStreamFactory: 1,
  isServer: 1,
  keepAliveInitialDelay: 1,
  localAddress: 1,
  maxPreparedStatements: 1,
  multipleStatements: 1,
  namedPlaceholders: 1,
  nestTables: 1,
  password: 1,
  // with multi-factor authentication, the main password (used for the first
  // authentication factor) can be provided via password1
  password1: 1,
  password2: 1,
  password3: 1,
  passwordSha1: 1,
  pool: 1,
  port: 1,
  queryFormat: 1,
  rowsAsArray: 1,
  socketPath: 1,
  ssl: 1,
  stream: 1,
  stringifyObjects: 1,
  supportBigNumbers: 1,
  timezone: 1,
  trace: 1,
  typeCast: 1,
  uri: 1,
  user: 1,
  disableEval: 1,
  // These options are used for Pool
  connectionLimit: 1,
  maxIdle: 1,
  idleTimeout: 1,
  Promise: 1,
  queueLimit: 1,
  waitForConnections: 1,
  jsonStrings: 1,
  gracefulEnd: 1,
};

class ConnectionConfig {
  constructor(options) {
    if (typeof options === 'string') {
      options = ConnectionConfig.parseUrl(options);
    } else if (options && options.uri) {
      const uriOptions = ConnectionConfig.parseUrl(options.uri);
      for (const key in uriOptions) {
        if (!Object.prototype.hasOwnProperty.call(uriOptions, key)) continue;
        if (options[key]) continue;
        options[key] = uriOptions[key];
      }
    }
    for (const key in options) {
      if (!Object.prototype.hasOwnProperty.call(options, key)) continue;
      if (validOptions[key] !== 1) {
        // REVIEW: Should this be emitted somehow?
        // eslint-disable-next-line no-console
        console.error(
          `Ignoring invalid configuration option passed to Connection: ${key}. This is currently a warning, but in future versions of MySQL2, an error will be thrown if you pass an invalid configuration option to a Connection`
        );
      }
    }
    this.isServer = options.isServer;
    this.stream = options.stream;
    this.host = options.host || 'localhost';
    this.port =
      (typeof options.port === 'string'
        ? parseInt(options.port, 10)
        : options.port) || 3306;
    this.localAddress = options.localAddress;
    this.socketPath = options.socketPath;
    this.user = options.user || undefined;
    // for the purpose of multi-factor authentication, or not, the main
    // password (used for the 1st authentication factor) can also be
    // provided via the "password1" option
    this.password = options.password || options.password1 || undefined;
    this.password2 = options.password2 || undefined;
    this.password3 = options.password3 || undefined;
    this.passwordSha1 = options.passwordSha1 || undefined;
    this.database = options.database;
    this.connectTimeout = isNaN(options.connectTimeout)
      ? 10 * 1000
      : options.connectTimeout;
    this.insecureAuth = options.insecureAuth || false;
    this.infileStreamFactory = options.infileStreamFactory || undefined;
    this.supportBigNumbers = options.supportBigNumbers || false;
    this.bigNumberStrings = options.bigNumberStrings || false;
    this.decimalNumbers = options.decimalNumbers || false;
    this.dateStrings = options.dateStrings || false;
    this.debug = options.debug;
    this.trace = options.trace !== false;
    this.stringifyObjects = options.stringifyObjects || false;
    this.enableKeepAlive = options.enableKeepAlive !== false;
    this.keepAliveInitialDelay = options.keepAliveInitialDelay;
    if (
      options.timezone &&
      !/^(?:local|Z|[ +-]\d\d:\d\d)$/.test(options.timezone)
    ) {
      // strictly supports timezones specified by mysqljs/mysql:
      // https://github.com/mysqljs/mysql#user-content-connection-options
      // eslint-disable-next-line no-console
      console.error(
        `Ignoring invalid timezone passed to Connection: ${options.timezone}. This is currently a warning, but in future versions of MySQL2, an error will be thrown if you pass an invalid configuration option to a Connection`
      );
      // SqlStrings falls back to UTC on invalid timezone
      this.timezone = 'Z';
    } else {
      this.timezone = options.timezone || 'local';
    }
    this.queryFormat = options.queryFormat;
    this.pool = options.pool || undefined;
    this.ssl =
      typeof options.ssl === 'string'
        ? ConnectionConfig.getSSLProfile(options.ssl)
        : options.ssl || false;
    this.multipleStatements = options.multipleStatements || false;
    this.rowsAsArray = options.rowsAsArray || false;
    this.namedPlaceholders = options.namedPlaceholders || false;
    this.nestTables =
      options.nestTables === undefined ? undefined : options.nestTables;
    this.typeCast = options.typeCast === undefined ? true : options.typeCast;
    this.disableEval = Boolean(options.disableEval);
    if (this.timezone[0] === ' ') {
      // "+" is a url encoded char for space so it
      // gets translated to space when giving a
      // connection string..
      this.timezone = `+${this.timezone.slice(1)}`;
    }
    if (this.ssl) {
      if (typeof this.ssl !== 'object') {
        throw new TypeError(
          `SSL profile must be an object, instead it's a ${typeof this.ssl}`
        );
      }
      // Default rejectUnauthorized to true
      this.ssl.rejectUnauthorized = this.ssl.rejectUnauthorized !== false;
    }
    this.maxPacketSize = 0;
    this.charsetNumber = options.charset
      ? ConnectionConfig.getCharsetNumber(options.charset)
      : options.charsetNumber || Charsets.UTF8MB4_UNICODE_CI;
    this.compress = options.compress || false;
    this.authPlugins = options.authPlugins;
    this.authSwitchHandler = options.authSwitchHandler;
    this.clientFlags = ConnectionConfig.mergeFlags(
      ConnectionConfig.getDefaultFlags(options),
      options.flags || ''
    );
    // Default connection attributes
    // https://dev.mysql.com/doc/refman/8.0/en/performance-schema-connection-attribute-tables.html
    const defaultConnectAttributes = {
      _client_name: 'Node-MySQL-2',
      _client_version: version,
    };
    this.connectAttributes = {
      ...defaultConnectAttributes,
      ...(options.connectAttributes || {}),
    };
    this.maxPreparedStatements = options.maxPreparedStatements || 16000;
    this.jsonStrings = options.jsonStrings || false;
    this.gracefulEnd = options.gracefulEnd || false;
  }

  static mergeFlags(default_flags, user_flags) {
    let flags = 0x0,
      i;
    if (!Array.isArray(user_flags)) {
      user_flags = String(user_flags || '')
        .toUpperCase()
        .split(/\s*,+\s*/);
    }
    // add default flags unless "blacklisted"
    for (i in default_flags) {
      if (user_flags.indexOf(`-${default_flags[i]}`) >= 0) {
        continue;
      }
      flags |= ClientConstants[default_flags[i]] || 0x0;
    }
    // add user flags unless already already added
    for (i in user_flags) {
      if (user_flags[i][0] === '-') {
        continue;
      }
      if (default_flags.indexOf(user_flags[i]) >= 0) {
        continue;
      }
      flags |= ClientConstants[user_flags[i]] || 0x0;
    }
    return flags;
  }

  static getDefaultFlags(options) {
    const defaultFlags = [
      'LONG_PASSWORD',
      'FOUND_ROWS',
      'LONG_FLAG',
      'CONNECT_WITH_DB',
      'ODBC',
      'LOCAL_FILES',
      'IGNORE_SPACE',
      'PROTOCOL_41',
      'IGNORE_SIGPIPE',
      'TRANSACTIONS',
      'RESERVED',
      'SECURE_CONNECTION',
      'MULTI_RESULTS',
      'TRANSACTIONS',
      'SESSION_TRACK',
      'CONNECT_ATTRS',
    ];
    if (options && options.multipleStatements) {
      defaultFlags.push('MULTI_STATEMENTS');
    }
    defaultFlags.push('PLUGIN_AUTH');
    defaultFlags.push('PLUGIN_AUTH_LENENC_CLIENT_DATA');

    return defaultFlags;
  }

  static getCharsetNumber(charset) {
    const num = Charsets[charset.toUpperCase()];
    if (num === undefined) {
      throw new TypeError(`Unknown charset '${charset}'`);
    }
    return num;
  }

  static getSSLProfile(name) {
    if (!SSLProfiles) {
      SSLProfiles = __nccwpck_require__(3830);
    }
    const ssl = SSLProfiles[name];
    if (ssl === undefined) {
      throw new TypeError(`Unknown SSL profile '${name}'`);
    }
    return ssl;
  }

  static parseUrl(url) {
    const parsedUrl = new URL(url);
    const options = {
      host: decodeURIComponent(parsedUrl.hostname),
      port: parseInt(parsedUrl.port, 10),
      database: decodeURIComponent(parsedUrl.pathname.slice(1)),
      user: decodeURIComponent(parsedUrl.username),
      password: decodeURIComponent(parsedUrl.password),
    };
    parsedUrl.searchParams.forEach((value, key) => {
      try {
        // Try to parse this as a JSON expression first
        options[key] = JSON.parse(value);
      } catch (err) {
        // Otherwise assume it is a plain string
        options[key] = value;
      }
    });
    return options;
  }
}

module.exports = ConnectionConfig;


/***/ }),

/***/ 89998:
/***/ ((module) => {

"use strict";


// see tools/generate-charset-mapping.js
// basicalliy result of "SHOW COLLATION" query

module.exports = [
  'utf8',
  'big5',
  'latin2',
  'dec8',
  'cp850',
  'latin1',
  'hp8',
  'koi8r',
  'latin1',
  'latin2',
  'swe7',
  'ascii',
  'eucjp',
  'sjis',
  'cp1251',
  'latin1',
  'hebrew',
  'utf8',
  'tis620',
  'euckr',
  'latin7',
  'latin2',
  'koi8u',
  'cp1251',
  'gb2312',
  'greek',
  'cp1250',
  'latin2',
  'gbk',
  'cp1257',
  'latin5',
  'latin1',
  'armscii8',
  'cesu8',
  'cp1250',
  'ucs2',
  'cp866',
  'keybcs2',
  'macintosh',
  'macroman',
  'cp852',
  'latin7',
  'latin7',
  'macintosh',
  'cp1250',
  'utf8',
  'utf8',
  'latin1',
  'latin1',
  'latin1',
  'cp1251',
  'cp1251',
  'cp1251',
  'macroman',
  'utf16',
  'utf16',
  'utf16-le',
  'cp1256',
  'cp1257',
  'cp1257',
  'utf32',
  'utf32',
  'utf16-le',
  'binary',
  'armscii8',
  'ascii',
  'cp1250',
  'cp1256',
  'cp866',
  'dec8',
  'greek',
  'hebrew',
  'hp8',
  'keybcs2',
  'koi8r',
  'koi8u',
  'cesu8',
  'latin2',
  'latin5',
  'latin7',
  'cp850',
  'cp852',
  'swe7',
  'cesu8',
  'big5',
  'euckr',
  'gb2312',
  'gbk',
  'sjis',
  'tis620',
  'ucs2',
  'eucjp',
  'geostd8',
  'geostd8',
  'latin1',
  'cp932',
  'cp932',
  'eucjpms',
  'eucjpms',
  'cp1250',
  'utf16',
  'utf16',
  'utf16',
  'utf16',
  'utf16',
  'utf16',
  'utf16',
  'utf16',
  'utf16',
  'utf16',
  'utf16',
  'utf16',
  'utf16',
  'utf16',
  'utf16',
  'utf16',
  'utf16',
  'utf16',
  'utf16',
  'utf16',
  'utf16',
  'utf16',
  'utf16',
  'utf16',
  'utf16',
  'utf8',
  'utf8',
  'utf8',
  'ucs2',
  'ucs2',
  'ucs2',
  'ucs2',
  'ucs2',
  'ucs2',
  'ucs2',
  'ucs2',
  'ucs2',
  'ucs2',
  'ucs2',
  'ucs2',
  'ucs2',
  'ucs2',
  'ucs2',
  'ucs2',
  'ucs2',
  'ucs2',
  'ucs2',
  'ucs2',
  'ucs2',
  'ucs2',
  'ucs2',
  'ucs2',
  'utf8',
  'utf8',
  'utf8',
  'utf8',
  'utf8',
  'utf8',
  'utf8',
  'ucs2',
  'utf32',
  'utf32',
  'utf32',
  'utf32',
  'utf32',
  'utf32',
  'utf32',
  'utf32',
  'utf32',
  'utf32',
  'utf32',
  'utf32',
  'utf32',
  'utf32',
  'utf32',
  'utf32',
  'utf32',
  'utf32',
  'utf32',
  'utf32',
  'utf32',
  'utf32',
  'utf32',
  'utf32',
  'utf8',
  'utf8',
  'utf8',
  'utf8',
  'utf8',
  'utf8',
  'utf8',
  'utf8',
  'cesu8',
  'cesu8',
  'cesu8',
  'cesu8',
  'cesu8',
  'cesu8',
  'cesu8',
  'cesu8',
  'cesu8',
  'cesu8',
  'cesu8',
  'cesu8',
  'cesu8',
  'cesu8',
  'cesu8',
  'cesu8',
  'cesu8',
  'cesu8',
  'cesu8',
  'cesu8',
  'cesu8',
  'cesu8',
  'cesu8',
  'cesu8',
  'utf8',
  'utf8',
  'utf8',
  'utf8',
  'utf8',
  'utf8',
  'utf8',
  'cesu8',
  'utf8',
  'utf8',
  'utf8',
  'utf8',
  'utf8',
  'utf8',
  'utf8',
  'utf8',
  'utf8',
  'utf8',
  'utf8',
  'utf8',
  'utf8',
  'utf8',
  'utf8',
  'utf8',
  'utf8',
  'utf8',
  'utf8',
  'utf8',
  'utf8',
  'utf8',
  'utf8',
  'utf8',
  'gb18030',
  'gb18030',
  'gb18030',
  'utf8',
  'utf8',
  'utf8',
  'utf8',
  'utf8',
  'utf8',
  'utf8',
  'utf8',
  'utf8',
  'utf8',
  'utf8',
  'utf8',
  'utf8',
  'utf8',
  'utf8',
  'utf8',
  'utf8',
  'utf8',
  'utf8',
  'utf8',
  'utf8',
  'utf8',
  'utf8',
  'utf8',
  'utf8',
  'utf8',
  'utf8',
  'utf8',
  'utf8',
  'utf8',
  'utf8',
  'utf8',
  'utf8',
  'utf8',
  'utf8',
  'utf8',
  'utf8',
  'utf8',
  'utf8',
  'utf8',
  'utf8',
  'utf8',
  'utf8',
  'utf8',
  'utf8',
  'utf8',
  'utf8',
  'utf8',
  'utf8',
  'utf8',
  'utf8',
  'utf8',
  'utf8',
  'utf8',
  'utf8',
  'utf8',
  'utf8',
  'utf8',
];


/***/ }),

/***/ 33286:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


exports.BIG5_CHINESE_CI = 1;
exports.LATIN2_CZECH_CS = 2;
exports.DEC8_SWEDISH_CI = 3;
exports.CP850_GENERAL_CI = 4;
exports.LATIN1_GERMAN1_CI = 5;
exports.HP8_ENGLISH_CI = 6;
exports.KOI8R_GENERAL_CI = 7;
exports.LATIN1_SWEDISH_CI = 8;
exports.LATIN2_GENERAL_CI = 9;
exports.SWE7_SWEDISH_CI = 10;
exports.ASCII_GENERAL_CI = 11;
exports.UJIS_JAPANESE_CI = 12;
exports.SJIS_JAPANESE_CI = 13;
exports.CP1251_BULGARIAN_CI = 14;
exports.LATIN1_DANISH_CI = 15;
exports.HEBREW_GENERAL_CI = 16;
exports.TIS620_THAI_CI = 18;
exports.EUCKR_KOREAN_CI = 19;
exports.LATIN7_ESTONIAN_CS = 20;
exports.LATIN2_HUNGARIAN_CI = 21;
exports.KOI8U_GENERAL_CI = 22;
exports.CP1251_UKRAINIAN_CI = 23;
exports.GB2312_CHINESE_CI = 24;
exports.GREEK_GENERAL_CI = 25;
exports.CP1250_GENERAL_CI = 26;
exports.LATIN2_CROATIAN_CI = 27;
exports.GBK_CHINESE_CI = 28;
exports.CP1257_LITHUANIAN_CI = 29;
exports.LATIN5_TURKISH_CI = 30;
exports.LATIN1_GERMAN2_CI = 31;
exports.ARMSCII8_GENERAL_CI = 32;
exports.UTF8_GENERAL_CI = 33;
exports.CP1250_CZECH_CS = 34;
exports.UCS2_GENERAL_CI = 35;
exports.CP866_GENERAL_CI = 36;
exports.KEYBCS2_GENERAL_CI = 37;
exports.MACCE_GENERAL_CI = 38;
exports.MACROMAN_GENERAL_CI = 39;
exports.CP852_GENERAL_CI = 40;
exports.LATIN7_GENERAL_CI = 41;
exports.LATIN7_GENERAL_CS = 42;
exports.MACCE_BIN = 43;
exports.CP1250_CROATIAN_CI = 44;
exports.UTF8MB4_GENERAL_CI = 45;
exports.UTF8MB4_BIN = 46;
exports.LATIN1_BIN = 47;
exports.LATIN1_GENERAL_CI = 48;
exports.LATIN1_GENERAL_CS = 49;
exports.CP1251_BIN = 50;
exports.CP1251_GENERAL_CI = 51;
exports.CP1251_GENERAL_CS = 52;
exports.MACROMAN_BIN = 53;
exports.UTF16_GENERAL_CI = 54;
exports.UTF16_BIN = 55;
exports.UTF16LE_GENERAL_CI = 56;
exports.CP1256_GENERAL_CI = 57;
exports.CP1257_BIN = 58;
exports.CP1257_GENERAL_CI = 59;
exports.UTF32_GENERAL_CI = 60;
exports.UTF32_BIN = 61;
exports.UTF16LE_BIN = 62;
exports.BINARY = 63;
exports.ARMSCII8_BIN = 64;
exports.ASCII_BIN = 65;
exports.CP1250_BIN = 66;
exports.CP1256_BIN = 67;
exports.CP866_BIN = 68;
exports.DEC8_BIN = 69;
exports.GREEK_BIN = 70;
exports.HEBREW_BIN = 71;
exports.HP8_BIN = 72;
exports.KEYBCS2_BIN = 73;
exports.KOI8R_BIN = 74;
exports.KOI8U_BIN = 75;
exports.UTF8_TOLOWER_CI = 76;
exports.LATIN2_BIN = 77;
exports.LATIN5_BIN = 78;
exports.LATIN7_BIN = 79;
exports.CP850_BIN = 80;
exports.CP852_BIN = 81;
exports.SWE7_BIN = 82;
exports.UTF8_BIN = 83;
exports.BIG5_BIN = 84;
exports.EUCKR_BIN = 85;
exports.GB2312_BIN = 86;
exports.GBK_BIN = 87;
exports.SJIS_BIN = 88;
exports.TIS620_BIN = 89;
exports.UCS2_BIN = 90;
exports.UJIS_BIN = 91;
exports.GEOSTD8_GENERAL_CI = 92;
exports.GEOSTD8_BIN = 93;
exports.LATIN1_SPANISH_CI = 94;
exports.CP932_JAPANESE_CI = 95;
exports.CP932_BIN = 96;
exports.EUCJPMS_JAPANESE_CI = 97;
exports.EUCJPMS_BIN = 98;
exports.CP1250_POLISH_CI = 99;
exports.UTF16_UNICODE_CI = 101;
exports.UTF16_ICELANDIC_CI = 102;
exports.UTF16_LATVIAN_CI = 103;
exports.UTF16_ROMANIAN_CI = 104;
exports.UTF16_SLOVENIAN_CI = 105;
exports.UTF16_POLISH_CI = 106;
exports.UTF16_ESTONIAN_CI = 107;
exports.UTF16_SPANISH_CI = 108;
exports.UTF16_SWEDISH_CI = 109;
exports.UTF16_TURKISH_CI = 110;
exports.UTF16_CZECH_CI = 111;
exports.UTF16_DANISH_CI = 112;
exports.UTF16_LITHUANIAN_CI = 113;
exports.UTF16_SLOVAK_CI = 114;
exports.UTF16_SPANISH2_CI = 115;
exports.UTF16_ROMAN_CI = 116;
exports.UTF16_PERSIAN_CI = 117;
exports.UTF16_ESPERANTO_CI = 118;
exports.UTF16_HUNGARIAN_CI = 119;
exports.UTF16_SINHALA_CI = 120;
exports.UTF16_GERMAN2_CI = 121;
exports.UTF16_CROATIAN_CI = 122;
exports.UTF16_UNICODE_520_CI = 123;
exports.UTF16_VIETNAMESE_CI = 124;
exports.UCS2_UNICODE_CI = 128;
exports.UCS2_ICELANDIC_CI = 129;
exports.UCS2_LATVIAN_CI = 130;
exports.UCS2_ROMANIAN_CI = 131;
exports.UCS2_SLOVENIAN_CI = 132;
exports.UCS2_POLISH_CI = 133;
exports.UCS2_ESTONIAN_CI = 134;
exports.UCS2_SPANISH_CI = 135;
exports.UCS2_SWEDISH_CI = 136;
exports.UCS2_TURKISH_CI = 137;
exports.UCS2_CZECH_CI = 138;
exports.UCS2_DANISH_CI = 139;
exports.UCS2_LITHUANIAN_CI = 140;
exports.UCS2_SLOVAK_CI = 141;
exports.UCS2_SPANISH2_CI = 142;
exports.UCS2_ROMAN_CI = 143;
exports.UCS2_PERSIAN_CI = 144;
exports.UCS2_ESPERANTO_CI = 145;
exports.UCS2_HUNGARIAN_CI = 146;
exports.UCS2_SINHALA_CI = 147;
exports.UCS2_GERMAN2_CI = 148;
exports.UCS2_CROATIAN_CI = 149;
exports.UCS2_UNICODE_520_CI = 150;
exports.UCS2_VIETNAMESE_CI = 151;
exports.UCS2_GENERAL_MYSQL500_CI = 159;
exports.UTF32_UNICODE_CI = 160;
exports.UTF32_ICELANDIC_CI = 161;
exports.UTF32_LATVIAN_CI = 162;
exports.UTF32_ROMANIAN_CI = 163;
exports.UTF32_SLOVENIAN_CI = 164;
exports.UTF32_POLISH_CI = 165;
exports.UTF32_ESTONIAN_CI = 166;
exports.UTF32_SPANISH_CI = 167;
exports.UTF32_SWEDISH_CI = 168;
exports.UTF32_TURKISH_CI = 169;
exports.UTF32_CZECH_CI = 170;
exports.UTF32_DANISH_CI = 171;
exports.UTF32_LITHUANIAN_CI = 172;
exports.UTF32_SLOVAK_CI = 173;
exports.UTF32_SPANISH2_CI = 174;
exports.UTF32_ROMAN_CI = 175;
exports.UTF32_PERSIAN_CI = 176;
exports.UTF32_ESPERANTO_CI = 177;
exports.UTF32_HUNGARIAN_CI = 178;
exports.UTF32_SINHALA_CI = 179;
exports.UTF32_GERMAN2_CI = 180;
exports.UTF32_CROATIAN_CI = 181;
exports.UTF32_UNICODE_520_CI = 182;
exports.UTF32_VIETNAMESE_CI = 183;
exports.UTF8_UNICODE_CI = 192;
exports.UTF8_ICELANDIC_CI = 193;
exports.UTF8_LATVIAN_CI = 194;
exports.UTF8_ROMANIAN_CI = 195;
exports.UTF8_SLOVENIAN_CI = 196;
exports.UTF8_POLISH_CI = 197;
exports.UTF8_ESTONIAN_CI = 198;
exports.UTF8_SPANISH_CI = 199;
exports.UTF8_SWEDISH_CI = 200;
exports.UTF8_TURKISH_CI = 201;
exports.UTF8_CZECH_CI = 202;
exports.UTF8_DANISH_CI = 203;
exports.UTF8_LITHUANIAN_CI = 204;
exports.UTF8_SLOVAK_CI = 205;
exports.UTF8_SPANISH2_CI = 206;
exports.UTF8_ROMAN_CI = 207;
exports.UTF8_PERSIAN_CI = 208;
exports.UTF8_ESPERANTO_CI = 209;
exports.UTF8_HUNGARIAN_CI = 210;
exports.UTF8_SINHALA_CI = 211;
exports.UTF8_GERMAN2_CI = 212;
exports.UTF8_CROATIAN_CI = 213;
exports.UTF8_UNICODE_520_CI = 214;
exports.UTF8_VIETNAMESE_CI = 215;
exports.UTF8_GENERAL_MYSQL500_CI = 223;
exports.UTF8MB4_UNICODE_CI = 224;
exports.UTF8MB4_ICELANDIC_CI = 225;
exports.UTF8MB4_LATVIAN_CI = 226;
exports.UTF8MB4_ROMANIAN_CI = 227;
exports.UTF8MB4_SLOVENIAN_CI = 228;
exports.UTF8MB4_POLISH_CI = 229;
exports.UTF8MB4_ESTONIAN_CI = 230;
exports.UTF8MB4_SPANISH_CI = 231;
exports.UTF8MB4_SWEDISH_CI = 232;
exports.UTF8MB4_TURKISH_CI = 233;
exports.UTF8MB4_CZECH_CI = 234;
exports.UTF8MB4_DANISH_CI = 235;
exports.UTF8MB4_LITHUANIAN_CI = 236;
exports.UTF8MB4_SLOVAK_CI = 237;
exports.UTF8MB4_SPANISH2_CI = 238;
exports.UTF8MB4_ROMAN_CI = 239;
exports.UTF8MB4_PERSIAN_CI = 240;
exports.UTF8MB4_ESPERANTO_CI = 241;
exports.UTF8MB4_HUNGARIAN_CI = 242;
exports.UTF8MB4_SINHALA_CI = 243;
exports.UTF8MB4_GERMAN2_CI = 244;
exports.UTF8MB4_CROATIAN_CI = 245;
exports.UTF8MB4_UNICODE_520_CI = 246;
exports.UTF8MB4_VIETNAMESE_CI = 247;
exports.GB18030_CHINESE_CI = 248;
exports.GB18030_BIN = 249;
exports.GB18030_UNICODE_520_CI = 250;
exports.UTF8_GENERAL50_CI = 253; // deprecated
exports.UTF8MB4_0900_AI_CI = 255;
exports.UTF8MB4_DE_PB_0900_AI_CI = 256;
exports.UTF8MB4_IS_0900_AI_CI = 257;
exports.UTF8MB4_LV_0900_AI_CI = 258;
exports.UTF8MB4_RO_0900_AI_CI = 259;
exports.UTF8MB4_SL_0900_AI_CI = 260;
exports.UTF8MB4_PL_0900_AI_CI = 261;
exports.UTF8MB4_ET_0900_AI_CI = 262;
exports.UTF8MB4_ES_0900_AI_CI = 263;
exports.UTF8MB4_SV_0900_AI_CI = 264;
exports.UTF8MB4_TR_0900_AI_CI = 265;
exports.UTF8MB4_CS_0900_AI_CI = 266;
exports.UTF8MB4_DA_0900_AI_CI = 267;
exports.UTF8MB4_LT_0900_AI_CI = 268;
exports.UTF8MB4_SK_0900_AI_CI = 269;
exports.UTF8MB4_ES_TRAD_0900_AI_CI = 270;
exports.UTF8MB4_LA_0900_AI_CI = 271;
exports.UTF8MB4_EO_0900_AI_CI = 273;
exports.UTF8MB4_HU_0900_AI_CI = 274;
exports.UTF8MB4_HR_0900_AI_CI = 275;
exports.UTF8MB4_VI_0900_AI_CI = 277;
exports.UTF8MB4_0900_AS_CS = 278;
exports.UTF8MB4_DE_PB_0900_AS_CS = 279;
exports.UTF8MB4_IS_0900_AS_CS = 280;
exports.UTF8MB4_LV_0900_AS_CS = 281;
exports.UTF8MB4_RO_0900_AS_CS = 282;
exports.UTF8MB4_SL_0900_AS_CS = 283;
exports.UTF8MB4_PL_0900_AS_CS = 284;
exports.UTF8MB4_ET_0900_AS_CS = 285;
exports.UTF8MB4_ES_0900_AS_CS = 286;
exports.UTF8MB4_SV_0900_AS_CS = 287;
exports.UTF8MB4_TR_0900_AS_CS = 288;
exports.UTF8MB4_CS_0900_AS_CS = 289;
exports.UTF8MB4_DA_0900_AS_CS = 290;
exports.UTF8MB4_LT_0900_AS_CS = 291;
exports.UTF8MB4_SK_0900_AS_CS = 292;
exports.UTF8MB4_ES_TRAD_0900_AS_CS = 293;
exports.UTF8MB4_LA_0900_AS_CS = 294;
exports.UTF8MB4_EO_0900_AS_CS = 296;
exports.UTF8MB4_HU_0900_AS_CS = 297;
exports.UTF8MB4_HR_0900_AS_CS = 298;
exports.UTF8MB4_VI_0900_AS_CS = 300;
exports.UTF8MB4_JA_0900_AS_CS = 303;
exports.UTF8MB4_JA_0900_AS_CS_KS = 304;
exports.UTF8MB4_0900_AS_CI = 305;
exports.UTF8MB4_RU_0900_AI_CI = 306;
exports.UTF8MB4_RU_0900_AS_CS = 307;
exports.UTF8MB4_ZH_0900_AS_CS = 308;
exports.UTF8MB4_0900_BIN = 309;

// short aliases
exports.BIG5 = exports.BIG5_CHINESE_CI;
exports.DEC8 = exports.DEC8_SWEDISH_CI;
exports.CP850 = exports.CP850_GENERAL_CI;
exports.HP8 = exports.HP8_ENGLISH_CI;
exports.KOI8R = exports.KOI8R_GENERAL_CI;
exports.LATIN1 = exports.LATIN1_SWEDISH_CI;
exports.LATIN2 = exports.LATIN2_GENERAL_CI;
exports.SWE7 = exports.SWE7_SWEDISH_CI;
exports.ASCII = exports.ASCII_GENERAL_CI;
exports.UJIS = exports.UJIS_JAPANESE_CI;
exports.SJIS = exports.SJIS_JAPANESE_CI;
exports.HEBREW = exports.HEBREW_GENERAL_CI;
exports.TIS620 = exports.TIS620_THAI_CI;
exports.EUCKR = exports.EUCKR_KOREAN_CI;
exports.KOI8U = exports.KOI8U_GENERAL_CI;
exports.GB2312 = exports.GB2312_CHINESE_CI;
exports.GREEK = exports.GREEK_GENERAL_CI;
exports.CP1250 = exports.CP1250_GENERAL_CI;
exports.GBK = exports.GBK_CHINESE_CI;
exports.LATIN5 = exports.LATIN5_TURKISH_CI;
exports.ARMSCII8 = exports.ARMSCII8_GENERAL_CI;
exports.UTF8 = exports.UTF8_GENERAL_CI;
exports.UCS2 = exports.UCS2_GENERAL_CI;
exports.CP866 = exports.CP866_GENERAL_CI;
exports.KEYBCS2 = exports.KEYBCS2_GENERAL_CI;
exports.MACCE = exports.MACCE_GENERAL_CI;
exports.MACROMAN = exports.MACROMAN_GENERAL_CI;
exports.CP852 = exports.CP852_GENERAL_CI;
exports.LATIN7 = exports.LATIN7_GENERAL_CI;
exports.UTF8MB4 = exports.UTF8MB4_GENERAL_CI;
exports.CP1251 = exports.CP1251_GENERAL_CI;
exports.UTF16 = exports.UTF16_GENERAL_CI;
exports.UTF16LE = exports.UTF16LE_GENERAL_CI;
exports.CP1256 = exports.CP1256_GENERAL_CI;
exports.CP1257 = exports.CP1257_GENERAL_CI;
exports.UTF32 = exports.UTF32_GENERAL_CI;
exports.CP932 = exports.CP932_JAPANESE_CI;
exports.EUCJPMS = exports.EUCJPMS_JAPANESE_CI;
exports.GB18030 = exports.GB18030_CHINESE_CI;
exports.GEOSTD8 = exports.GEOSTD8_GENERAL_CI;


/***/ }),

/***/ 70060:
/***/ ((__unused_webpack_module, exports) => {

"use strict";
// This file was modified by Oracle on September 21, 2021.
// New capability for multi-factor authentication based on mandatory session
// trackers, that are signaled with an extra single-byte prefix on new
// versions of the MySQL server.
// Modifications copyright (c) 2021, Oracle and/or its affiliates.



// Manually extracted from mysql-5.5.23/include/mysql_com.h
exports.LONG_PASSWORD = 0x00000001; /* new more secure passwords */
exports.FOUND_ROWS = 0x00000002; /* found instead of affected rows */
exports.LONG_FLAG = 0x00000004; /* get all column flags */
exports.CONNECT_WITH_DB = 0x00000008; /* one can specify db on connect */
exports.NO_SCHEMA = 0x00000010; /* don't allow database.table.column */
exports.COMPRESS = 0x00000020; /* can use compression protocol */
exports.ODBC = 0x00000040; /* odbc client */
exports.LOCAL_FILES = 0x00000080; /* can use LOAD DATA LOCAL */
exports.IGNORE_SPACE = 0x00000100; /* ignore spaces before '' */
exports.PROTOCOL_41 = 0x00000200; /* new 4.1 protocol */
exports.INTERACTIVE = 0x00000400; /* this is an interactive client */
exports.SSL = 0x00000800; /* switch to ssl after handshake */
exports.IGNORE_SIGPIPE = 0x00001000; /* IGNORE sigpipes */
exports.TRANSACTIONS = 0x00002000; /* client knows about transactions */
exports.RESERVED = 0x00004000; /* old flag for 4.1 protocol  */
exports.SECURE_CONNECTION = 0x00008000; /* new 4.1 authentication */
exports.MULTI_STATEMENTS = 0x00010000; /* enable/disable multi-stmt support */
exports.MULTI_RESULTS = 0x00020000; /* enable/disable multi-results */
exports.PS_MULTI_RESULTS = 0x00040000; /* multi-results in ps-protocol */
exports.PLUGIN_AUTH = 0x00080000; /* client supports plugin authentication */
exports.CONNECT_ATTRS = 0x00100000; /* permits connection attributes */
exports.PLUGIN_AUTH_LENENC_CLIENT_DATA = 0x00200000; /* Understands length-encoded integer for auth response data in Protocol::HandshakeResponse41. */
exports.CAN_HANDLE_EXPIRED_PASSWORDS = 0x00400000; /* Announces support for expired password extension. */
exports.SESSION_TRACK = 0x00800000; /* Can set SERVER_SESSION_STATE_CHANGED in the Status Flags and send session-state change data after a OK packet. */
exports.DEPRECATE_EOF = 0x01000000; /* Can send OK after a Text Resultset. */

exports.SSL_VERIFY_SERVER_CERT = 0x40000000;
exports.REMEMBER_OPTIONS = 0x80000000;

exports.MULTI_FACTOR_AUTHENTICATION = 0x10000000; /* multi-factor authentication */


/***/ }),

/***/ 17361:
/***/ ((module) => {

"use strict";


module.exports = {
  SLEEP: 0x00, // deprecated
  QUIT: 0x01,
  INIT_DB: 0x02,
  QUERY: 0x03,
  FIELD_LIST: 0x04,
  CREATE_DB: 0x05,
  DROP_DB: 0x06,
  REFRESH: 0x07,
  SHUTDOWN: 0x08,
  STATISTICS: 0x09,
  PROCESS_INFO: 0x0a, // deprecated
  CONNECT: 0x0b, // deprecated
  PROCESS_KILL: 0x0c,
  DEBUG: 0x0d,
  PING: 0x0e,
  TIME: 0x0f, // deprecated
  DELAYED_INSERT: 0x10, // deprecated
  CHANGE_USER: 0x11,
  BINLOG_DUMP: 0x12,
  TABLE_DUMP: 0x13,
  CONNECT_OUT: 0x14,
  REGISTER_SLAVE: 0x15,
  STMT_PREPARE: 0x16,
  STMT_EXECUTE: 0x17,
  STMT_SEND_LONG_DATA: 0x18,
  STMT_CLOSE: 0x19,
  STMT_RESET: 0x1a,
  SET_OPTION: 0x1b,
  STMT_FETCH: 0x1c,
  DAEMON: 0x1d, // deprecated
  BINLOG_DUMP_GTID: 0x1e,
  UNKNOWN: 0xff, // bad!
};


/***/ }),

/***/ 63493:
/***/ ((module) => {

"use strict";


module.exports = {
  NO_CURSOR: 0,
  READ_ONLY: 1,
  FOR_UPDATE: 2,
  SCROLLABLE: 3,
};


/***/ }),

/***/ 2197:
/***/ ((module) => {

"use strict";


// inverse of charset_encodings
// given encoding, get matching mysql charset number

module.exports = {
  big5: 1,
  latin2: 2,
  dec8: 3,
  cp850: 4,
  latin1: 5,
  hp8: 6,
  koi8r: 7,
  swe7: 10,
  ascii: 11,
  eucjp: 12,
  sjis: 13,
  cp1251: 14,
  hebrew: 16,
  tis620: 18,
  euckr: 19,
  latin7: 20,
  koi8u: 22,
  gb2312: 24,
  greek: 25,
  cp1250: 26,
  gbk: 28,
  cp1257: 29,
  latin5: 30,
  armscii8: 32,
  cesu8: 33,
  ucs2: 35,
  cp866: 36,
  keybcs2: 37,
  macintosh: 38,
  macroman: 39,
  cp852: 40,
  utf8: 45,
  utf8mb4: 45,
  utf16: 54,
  utf16le: 56,
  cp1256: 57,
  utf32: 60,
  binary: 63,
  geostd8: 92,
  cp932: 95,
  eucjpms: 97,
  gb18030: 248,
  utf8mb3: 192,
};


/***/ }),

/***/ 89228:
/***/ ((__unused_webpack_module, exports) => {

"use strict";
// This file was modified by Oracle on June 1, 2021.
// An entry was created for a new error reported by the MySQL server due to
// client inactivity.
// Modifications copyright (c) 2021, Oracle and/or its affiliates.



// originally copied from https://raw.githubusercontent.com/mysqljs/mysql/7770ee5bb13260c56a160b91fe480d9165dbeeba/lib/protocol/constants/errors.js
// (c) node-mysql authors

// updated to contain error codes as is contained in MySQL 8.0
// by adapting node-mysql: /.../generate-error-constants.js

/**
 * MySQL error constants
 *
 * Extracted from version 8.0.33
 *
 * !! Generated by generate-error-constants.js, do not modify by hand !!
 */

exports.EE_CANTCREATEFILE = 1;
exports.EE_READ = 2;
exports.EE_WRITE = 3;
exports.EE_BADCLOSE = 4;
exports.EE_OUTOFMEMORY = 5;
exports.EE_DELETE = 6;
exports.EE_LINK = 7;
exports.EE_EOFERR = 9;
exports.EE_CANTLOCK = 10;
exports.EE_CANTUNLOCK = 11;
exports.EE_DIR = 12;
exports.EE_STAT = 13;
exports.EE_CANT_CHSIZE = 14;
exports.EE_CANT_OPEN_STREAM = 15;
exports.EE_GETWD = 16;
exports.EE_SETWD = 17;
exports.EE_LINK_WARNING = 18;
exports.EE_OPEN_WARNING = 19;
exports.EE_DISK_FULL = 20;
exports.EE_CANT_MKDIR = 21;
exports.EE_UNKNOWN_CHARSET = 22;
exports.EE_OUT_OF_FILERESOURCES = 23;
exports.EE_CANT_READLINK = 24;
exports.EE_CANT_SYMLINK = 25;
exports.EE_REALPATH = 26;
exports.EE_SYNC = 27;
exports.EE_UNKNOWN_COLLATION = 28;
exports.EE_FILENOTFOUND = 29;
exports.EE_FILE_NOT_CLOSED = 30;
exports.EE_CHANGE_OWNERSHIP = 31;
exports.EE_CHANGE_PERMISSIONS = 32;
exports.EE_CANT_SEEK = 33;
exports.EE_CAPACITY_EXCEEDED = 34;
exports.EE_DISK_FULL_WITH_RETRY_MSG = 35;
exports.EE_FAILED_TO_CREATE_TIMER = 36;
exports.EE_FAILED_TO_DELETE_TIMER = 37;
exports.EE_FAILED_TO_CREATE_TIMER_QUEUE = 38;
exports.EE_FAILED_TO_START_TIMER_NOTIFY_THREAD = 39;
exports.EE_FAILED_TO_CREATE_TIMER_NOTIFY_THREAD_INTERRUPT_EVENT = 40;
exports.EE_EXITING_TIMER_NOTIFY_THREAD = 41;
exports.EE_WIN_LIBRARY_LOAD_FAILED = 42;
exports.EE_WIN_RUN_TIME_ERROR_CHECK = 43;
exports.EE_FAILED_TO_DETERMINE_LARGE_PAGE_SIZE = 44;
exports.EE_FAILED_TO_KILL_ALL_THREADS = 45;
exports.EE_FAILED_TO_CREATE_IO_COMPLETION_PORT = 46;
exports.EE_FAILED_TO_OPEN_DEFAULTS_FILE = 47;
exports.EE_FAILED_TO_HANDLE_DEFAULTS_FILE = 48;
exports.EE_WRONG_DIRECTIVE_IN_CONFIG_FILE = 49;
exports.EE_SKIPPING_DIRECTIVE_DUE_TO_MAX_INCLUDE_RECURSION = 50;
exports.EE_INCORRECT_GRP_DEFINITION_IN_CONFIG_FILE = 51;
exports.EE_OPTION_WITHOUT_GRP_IN_CONFIG_FILE = 52;
exports.EE_CONFIG_FILE_PERMISSION_ERROR = 53;
exports.EE_IGNORE_WORLD_WRITABLE_CONFIG_FILE = 54;
exports.EE_USING_DISABLED_OPTION = 55;
exports.EE_USING_DISABLED_SHORT_OPTION = 56;
exports.EE_USING_PASSWORD_ON_CLI_IS_INSECURE = 57;
exports.EE_UNKNOWN_SUFFIX_FOR_VARIABLE = 58;
exports.EE_SSL_ERROR_FROM_FILE = 59;
exports.EE_SSL_ERROR = 60;
exports.EE_NET_SEND_ERROR_IN_BOOTSTRAP = 61;
exports.EE_PACKETS_OUT_OF_ORDER = 62;
exports.EE_UNKNOWN_PROTOCOL_OPTION = 63;
exports.EE_FAILED_TO_LOCATE_SERVER_PUBLIC_KEY = 64;
exports.EE_PUBLIC_KEY_NOT_IN_PEM_FORMAT = 65;
exports.EE_DEBUG_INFO = 66;
exports.EE_UNKNOWN_VARIABLE = 67;
exports.EE_UNKNOWN_OPTION = 68;
exports.EE_UNKNOWN_SHORT_OPTION = 69;
exports.EE_OPTION_WITHOUT_ARGUMENT = 70;
exports.EE_OPTION_REQUIRES_ARGUMENT = 71;
exports.EE_SHORT_OPTION_REQUIRES_ARGUMENT = 72;
exports.EE_OPTION_IGNORED_DUE_TO_INVALID_VALUE = 73;
exports.EE_OPTION_WITH_EMPTY_VALUE = 74;
exports.EE_FAILED_TO_ASSIGN_MAX_VALUE_TO_OPTION = 75;
exports.EE_INCORRECT_BOOLEAN_VALUE_FOR_OPTION = 76;
exports.EE_FAILED_TO_SET_OPTION_VALUE = 77;
exports.EE_INCORRECT_INT_VALUE_FOR_OPTION = 78;
exports.EE_INCORRECT_UINT_VALUE_FOR_OPTION = 79;
exports.EE_ADJUSTED_SIGNED_VALUE_FOR_OPTION = 80;
exports.EE_ADJUSTED_UNSIGNED_VALUE_FOR_OPTION = 81;
exports.EE_ADJUSTED_ULONGLONG_VALUE_FOR_OPTION = 82;
exports.EE_ADJUSTED_DOUBLE_VALUE_FOR_OPTION = 83;
exports.EE_INVALID_DECIMAL_VALUE_FOR_OPTION = 84;
exports.EE_COLLATION_PARSER_ERROR = 85;
exports.EE_FAILED_TO_RESET_BEFORE_PRIMARY_IGNORABLE_CHAR = 86;
exports.EE_FAILED_TO_RESET_BEFORE_TERTIARY_IGNORABLE_CHAR = 87;
exports.EE_SHIFT_CHAR_OUT_OF_RANGE = 88;
exports.EE_RESET_CHAR_OUT_OF_RANGE = 89;
exports.EE_UNKNOWN_LDML_TAG = 90;
exports.EE_FAILED_TO_RESET_BEFORE_SECONDARY_IGNORABLE_CHAR = 91;
exports.EE_FAILED_PROCESSING_DIRECTIVE = 92;
exports.EE_PTHREAD_KILL_FAILED = 93;
exports.HA_ERR_KEY_NOT_FOUND = 120;
exports.HA_ERR_FOUND_DUPP_KEY = 121;
exports.HA_ERR_INTERNAL_ERROR = 122;
exports.HA_ERR_RECORD_CHANGED = 123;
exports.HA_ERR_WRONG_INDEX = 124;
exports.HA_ERR_ROLLED_BACK = 125;
exports.HA_ERR_CRASHED = 126;
exports.HA_ERR_WRONG_IN_RECORD = 127;
exports.HA_ERR_OUT_OF_MEM = 128;
exports.HA_ERR_NOT_A_TABLE = 130;
exports.HA_ERR_WRONG_COMMAND = 131;
exports.HA_ERR_OLD_FILE = 132;
exports.HA_ERR_NO_ACTIVE_RECORD = 133;
exports.HA_ERR_RECORD_DELETED = 134;
exports.HA_ERR_RECORD_FILE_FULL = 135;
exports.HA_ERR_INDEX_FILE_FULL = 136;
exports.HA_ERR_END_OF_FILE = 137;
exports.HA_ERR_UNSUPPORTED = 138;
exports.HA_ERR_TOO_BIG_ROW = 139;
exports.HA_WRONG_CREATE_OPTION = 140;
exports.HA_ERR_FOUND_DUPP_UNIQUE = 141;
exports.HA_ERR_UNKNOWN_CHARSET = 142;
exports.HA_ERR_WRONG_MRG_TABLE_DEF = 143;
exports.HA_ERR_CRASHED_ON_REPAIR = 144;
exports.HA_ERR_CRASHED_ON_USAGE = 145;
exports.HA_ERR_LOCK_WAIT_TIMEOUT = 146;
exports.HA_ERR_LOCK_TABLE_FULL = 147;
exports.HA_ERR_READ_ONLY_TRANSACTION = 148;
exports.HA_ERR_LOCK_DEADLOCK = 149;
exports.HA_ERR_CANNOT_ADD_FOREIGN = 150;
exports.HA_ERR_NO_REFERENCED_ROW = 151;
exports.HA_ERR_ROW_IS_REFERENCED = 152;
exports.HA_ERR_NO_SAVEPOINT = 153;
exports.HA_ERR_NON_UNIQUE_BLOCK_SIZE = 154;
exports.HA_ERR_NO_SUCH_TABLE = 155;
exports.HA_ERR_TABLE_EXIST = 156;
exports.HA_ERR_NO_CONNECTION = 157;
exports.HA_ERR_NULL_IN_SPATIAL = 158;
exports.HA_ERR_TABLE_DEF_CHANGED = 159;
exports.HA_ERR_NO_PARTITION_FOUND = 160;
exports.HA_ERR_RBR_LOGGING_FAILED = 161;
exports.HA_ERR_DROP_INDEX_FK = 162;
exports.HA_ERR_FOREIGN_DUPLICATE_KEY = 163;
exports.HA_ERR_TABLE_NEEDS_UPGRADE = 164;
exports.HA_ERR_TABLE_READONLY = 165;
exports.HA_ERR_AUTOINC_READ_FAILED = 166;
exports.HA_ERR_AUTOINC_ERANGE = 167;
exports.HA_ERR_GENERIC = 168;
exports.HA_ERR_RECORD_IS_THE_SAME = 169;
exports.HA_ERR_LOGGING_IMPOSSIBLE = 170;
exports.HA_ERR_CORRUPT_EVENT = 171;
exports.HA_ERR_NEW_FILE = 172;
exports.HA_ERR_ROWS_EVENT_APPLY = 173;
exports.HA_ERR_INITIALIZATION = 174;
exports.HA_ERR_FILE_TOO_SHORT = 175;
exports.HA_ERR_WRONG_CRC = 176;
exports.HA_ERR_TOO_MANY_CONCURRENT_TRXS = 177;
exports.HA_ERR_NOT_IN_LOCK_PARTITIONS = 178;
exports.HA_ERR_INDEX_COL_TOO_LONG = 179;
exports.HA_ERR_INDEX_CORRUPT = 180;
exports.HA_ERR_UNDO_REC_TOO_BIG = 181;
exports.HA_FTS_INVALID_DOCID = 182;
exports.HA_ERR_TABLE_IN_FK_CHECK = 183;
exports.HA_ERR_TABLESPACE_EXISTS = 184;
exports.HA_ERR_TOO_MANY_FIELDS = 185;
exports.HA_ERR_ROW_IN_WRONG_PARTITION = 186;
exports.HA_ERR_INNODB_READ_ONLY = 187;
exports.HA_ERR_FTS_EXCEED_RESULT_CACHE_LIMIT = 188;
exports.HA_ERR_TEMP_FILE_WRITE_FAILURE = 189;
exports.HA_ERR_INNODB_FORCED_RECOVERY = 190;
exports.HA_ERR_FTS_TOO_MANY_WORDS_IN_PHRASE = 191;
exports.HA_ERR_FK_DEPTH_EXCEEDED = 192;
exports.HA_MISSING_CREATE_OPTION = 193;
exports.HA_ERR_SE_OUT_OF_MEMORY = 194;
exports.HA_ERR_TABLE_CORRUPT = 195;
exports.HA_ERR_QUERY_INTERRUPTED = 196;
exports.HA_ERR_TABLESPACE_MISSING = 197;
exports.HA_ERR_TABLESPACE_IS_NOT_EMPTY = 198;
exports.HA_ERR_WRONG_FILE_NAME = 199;
exports.HA_ERR_NOT_ALLOWED_COMMAND = 200;
exports.HA_ERR_COMPUTE_FAILED = 201;
exports.HA_ERR_ROW_FORMAT_CHANGED = 202;
exports.HA_ERR_NO_WAIT_LOCK = 203;
exports.HA_ERR_DISK_FULL_NOWAIT = 204;
exports.HA_ERR_NO_SESSION_TEMP = 205;
exports.HA_ERR_WRONG_TABLE_NAME = 206;
exports.HA_ERR_TOO_LONG_PATH = 207;
exports.HA_ERR_SAMPLING_INIT_FAILED = 208;
exports.HA_ERR_FTS_TOO_MANY_NESTED_EXP = 209;
exports.ER_HASHCHK = 1000;
exports.ER_NISAMCHK = 1001;
exports.ER_NO = 1002;
exports.ER_YES = 1003;
exports.ER_CANT_CREATE_FILE = 1004;
exports.ER_CANT_CREATE_TABLE = 1005;
exports.ER_CANT_CREATE_DB = 1006;
exports.ER_DB_CREATE_EXISTS = 1007;
exports.ER_DB_DROP_EXISTS = 1008;
exports.ER_DB_DROP_DELETE = 1009;
exports.ER_DB_DROP_RMDIR = 1010;
exports.ER_CANT_DELETE_FILE = 1011;
exports.ER_CANT_FIND_SYSTEM_REC = 1012;
exports.ER_CANT_GET_STAT = 1013;
exports.ER_CANT_GET_WD = 1014;
exports.ER_CANT_LOCK = 1015;
exports.ER_CANT_OPEN_FILE = 1016;
exports.ER_FILE_NOT_FOUND = 1017;
exports.ER_CANT_READ_DIR = 1018;
exports.ER_CANT_SET_WD = 1019;
exports.ER_CHECKREAD = 1020;
exports.ER_DISK_FULL = 1021;
exports.ER_DUP_KEY = 1022;
exports.ER_ERROR_ON_CLOSE = 1023;
exports.ER_ERROR_ON_READ = 1024;
exports.ER_ERROR_ON_RENAME = 1025;
exports.ER_ERROR_ON_WRITE = 1026;
exports.ER_FILE_USED = 1027;
exports.ER_FILSORT_ABORT = 1028;
exports.ER_FORM_NOT_FOUND = 1029;
exports.ER_GET_ERRNO = 1030;
exports.ER_ILLEGAL_HA = 1031;
exports.ER_KEY_NOT_FOUND = 1032;
exports.ER_NOT_FORM_FILE = 1033;
exports.ER_NOT_KEYFILE = 1034;
exports.ER_OLD_KEYFILE = 1035;
exports.ER_OPEN_AS_READONLY = 1036;
exports.ER_OUTOFMEMORY = 1037;
exports.ER_OUT_OF_SORTMEMORY = 1038;
exports.ER_UNEXPECTED_EOF = 1039;
exports.ER_CON_COUNT_ERROR = 1040;
exports.ER_OUT_OF_RESOURCES = 1041;
exports.ER_BAD_HOST_ERROR = 1042;
exports.ER_HANDSHAKE_ERROR = 1043;
exports.ER_DBACCESS_DENIED_ERROR = 1044;
exports.ER_ACCESS_DENIED_ERROR = 1045;
exports.ER_NO_DB_ERROR = 1046;
exports.ER_UNKNOWN_COM_ERROR = 1047;
exports.ER_BAD_NULL_ERROR = 1048;
exports.ER_BAD_DB_ERROR = 1049;
exports.ER_TABLE_EXISTS_ERROR = 1050;
exports.ER_BAD_TABLE_ERROR = 1051;
exports.ER_NON_UNIQ_ERROR = 1052;
exports.ER_SERVER_SHUTDOWN = 1053;
exports.ER_BAD_FIELD_ERROR = 1054;
exports.ER_WRONG_FIELD_WITH_GROUP = 1055;
exports.ER_WRONG_GROUP_FIELD = 1056;
exports.ER_WRONG_SUM_SELECT = 1057;
exports.ER_WRONG_VALUE_COUNT = 1058;
exports.ER_TOO_LONG_IDENT = 1059;
exports.ER_DUP_FIELDNAME = 1060;
exports.ER_DUP_KEYNAME = 1061;
exports.ER_DUP_ENTRY = 1062;
exports.ER_WRONG_FIELD_SPEC = 1063;
exports.ER_PARSE_ERROR = 1064;
exports.ER_EMPTY_QUERY = 1065;
exports.ER_NONUNIQ_TABLE = 1066;
exports.ER_INVALID_DEFAULT = 1067;
exports.ER_MULTIPLE_PRI_KEY = 1068;
exports.ER_TOO_MANY_KEYS = 1069;
exports.ER_TOO_MANY_KEY_PARTS = 1070;
exports.ER_TOO_LONG_KEY = 1071;
exports.ER_KEY_COLUMN_DOES_NOT_EXITS = 1072;
exports.ER_BLOB_USED_AS_KEY = 1073;
exports.ER_TOO_BIG_FIELDLENGTH = 1074;
exports.ER_WRONG_AUTO_KEY = 1075;
exports.ER_READY = 1076;
exports.ER_NORMAL_SHUTDOWN = 1077;
exports.ER_GOT_SIGNAL = 1078;
exports.ER_SHUTDOWN_COMPLETE = 1079;
exports.ER_FORCING_CLOSE = 1080;
exports.ER_IPSOCK_ERROR = 1081;
exports.ER_NO_SUCH_INDEX = 1082;
exports.ER_WRONG_FIELD_TERMINATORS = 1083;
exports.ER_BLOBS_AND_NO_TERMINATED = 1084;
exports.ER_TEXTFILE_NOT_READABLE = 1085;
exports.ER_FILE_EXISTS_ERROR = 1086;
exports.ER_LOAD_INFO = 1087;
exports.ER_ALTER_INFO = 1088;
exports.ER_WRONG_SUB_KEY = 1089;
exports.ER_CANT_REMOVE_ALL_FIELDS = 1090;
exports.ER_CANT_DROP_FIELD_OR_KEY = 1091;
exports.ER_INSERT_INFO = 1092;
exports.ER_UPDATE_TABLE_USED = 1093;
exports.ER_NO_SUCH_THREAD = 1094;
exports.ER_KILL_DENIED_ERROR = 1095;
exports.ER_NO_TABLES_USED = 1096;
exports.ER_TOO_BIG_SET = 1097;
exports.ER_NO_UNIQUE_LOGFILE = 1098;
exports.ER_TABLE_NOT_LOCKED_FOR_WRITE = 1099;
exports.ER_TABLE_NOT_LOCKED = 1100;
exports.ER_BLOB_CANT_HAVE_DEFAULT = 1101;
exports.ER_WRONG_DB_NAME = 1102;
exports.ER_WRONG_TABLE_NAME = 1103;
exports.ER_TOO_BIG_SELECT = 1104;
exports.ER_UNKNOWN_ERROR = 1105;
exports.ER_UNKNOWN_PROCEDURE = 1106;
exports.ER_WRONG_PARAMCOUNT_TO_PROCEDURE = 1107;
exports.ER_WRONG_PARAMETERS_TO_PROCEDURE = 1108;
exports.ER_UNKNOWN_TABLE = 1109;
exports.ER_FIELD_SPECIFIED_TWICE = 1110;
exports.ER_INVALID_GROUP_FUNC_USE = 1111;
exports.ER_UNSUPPORTED_EXTENSION = 1112;
exports.ER_TABLE_MUST_HAVE_COLUMNS = 1113;
exports.ER_RECORD_FILE_FULL = 1114;
exports.ER_UNKNOWN_CHARACTER_SET = 1115;
exports.ER_TOO_MANY_TABLES = 1116;
exports.ER_TOO_MANY_FIELDS = 1117;
exports.ER_TOO_BIG_ROWSIZE = 1118;
exports.ER_STACK_OVERRUN = 1119;
exports.ER_WRONG_OUTER_JOIN = 1120;
exports.ER_NULL_COLUMN_IN_INDEX = 1121;
exports.ER_CANT_FIND_UDF = 1122;
exports.ER_CANT_INITIALIZE_UDF = 1123;
exports.ER_UDF_NO_PATHS = 1124;
exports.ER_UDF_EXISTS = 1125;
exports.ER_CANT_OPEN_LIBRARY = 1126;
exports.ER_CANT_FIND_DL_ENTRY = 1127;
exports.ER_FUNCTION_NOT_DEFINED = 1128;
exports.ER_HOST_IS_BLOCKED = 1129;
exports.ER_HOST_NOT_PRIVILEGED = 1130;
exports.ER_PASSWORD_ANONYMOUS_USER = 1131;
exports.ER_PASSWORD_NOT_ALLOWED = 1132;
exports.ER_PASSWORD_NO_MATCH = 1133;
exports.ER_UPDATE_INFO = 1134;
exports.ER_CANT_CREATE_THREAD = 1135;
exports.ER_WRONG_VALUE_COUNT_ON_ROW = 1136;
exports.ER_CANT_REOPEN_TABLE = 1137;
exports.ER_INVALID_USE_OF_NULL = 1138;
exports.ER_REGEXP_ERROR = 1139;
exports.ER_MIX_OF_GROUP_FUNC_AND_FIELDS = 1140;
exports.ER_NONEXISTING_GRANT = 1141;
exports.ER_TABLEACCESS_DENIED_ERROR = 1142;
exports.ER_COLUMNACCESS_DENIED_ERROR = 1143;
exports.ER_ILLEGAL_GRANT_FOR_TABLE = 1144;
exports.ER_GRANT_WRONG_HOST_OR_USER = 1145;
exports.ER_NO_SUCH_TABLE = 1146;
exports.ER_NONEXISTING_TABLE_GRANT = 1147;
exports.ER_NOT_ALLOWED_COMMAND = 1148;
exports.ER_SYNTAX_ERROR = 1149;
exports.ER_UNUSED1 = 1150;
exports.ER_UNUSED2 = 1151;
exports.ER_ABORTING_CONNECTION = 1152;
exports.ER_NET_PACKET_TOO_LARGE = 1153;
exports.ER_NET_READ_ERROR_FROM_PIPE = 1154;
exports.ER_NET_FCNTL_ERROR = 1155;
exports.ER_NET_PACKETS_OUT_OF_ORDER = 1156;
exports.ER_NET_UNCOMPRESS_ERROR = 1157;
exports.ER_NET_READ_ERROR = 1158;
exports.ER_NET_READ_INTERRUPTED = 1159;
exports.ER_NET_ERROR_ON_WRITE = 1160;
exports.ER_NET_WRITE_INTERRUPTED = 1161;
exports.ER_TOO_LONG_STRING = 1162;
exports.ER_TABLE_CANT_HANDLE_BLOB = 1163;
exports.ER_TABLE_CANT_HANDLE_AUTO_INCREMENT = 1164;
exports.ER_UNUSED3 = 1165;
exports.ER_WRONG_COLUMN_NAME = 1166;
exports.ER_WRONG_KEY_COLUMN = 1167;
exports.ER_WRONG_MRG_TABLE = 1168;
exports.ER_DUP_UNIQUE = 1169;
exports.ER_BLOB_KEY_WITHOUT_LENGTH = 1170;
exports.ER_PRIMARY_CANT_HAVE_NULL = 1171;
exports.ER_TOO_MANY_ROWS = 1172;
exports.ER_REQUIRES_PRIMARY_KEY = 1173;
exports.ER_NO_RAID_COMPILED = 1174;
exports.ER_UPDATE_WITHOUT_KEY_IN_SAFE_MODE = 1175;
exports.ER_KEY_DOES_NOT_EXITS = 1176;
exports.ER_CHECK_NO_SUCH_TABLE = 1177;
exports.ER_CHECK_NOT_IMPLEMENTED = 1178;
exports.ER_CANT_DO_THIS_DURING_AN_TRANSACTION = 1179;
exports.ER_ERROR_DURING_COMMIT = 1180;
exports.ER_ERROR_DURING_ROLLBACK = 1181;
exports.ER_ERROR_DURING_FLUSH_LOGS = 1182;
exports.ER_ERROR_DURING_CHECKPOINT = 1183;
exports.ER_NEW_ABORTING_CONNECTION = 1184;
exports.ER_DUMP_NOT_IMPLEMENTED = 1185;
exports.ER_FLUSH_MASTER_BINLOG_CLOSED = 1186;
exports.ER_INDEX_REBUILD = 1187;
exports.ER_SOURCE = 1188;
exports.ER_SOURCE_NET_READ = 1189;
exports.ER_SOURCE_NET_WRITE = 1190;
exports.ER_FT_MATCHING_KEY_NOT_FOUND = 1191;
exports.ER_LOCK_OR_ACTIVE_TRANSACTION = 1192;
exports.ER_UNKNOWN_SYSTEM_VARIABLE = 1193;
exports.ER_CRASHED_ON_USAGE = 1194;
exports.ER_CRASHED_ON_REPAIR = 1195;
exports.ER_WARNING_NOT_COMPLETE_ROLLBACK = 1196;
exports.ER_TRANS_CACHE_FULL = 1197;
exports.ER_SLAVE_MUST_STOP = 1198;
exports.ER_REPLICA_NOT_RUNNING = 1199;
exports.ER_BAD_REPLICA = 1200;
exports.ER_CONNECTION_METADATA = 1201;
exports.ER_REPLICA_THREAD = 1202;
exports.ER_TOO_MANY_USER_CONNECTIONS = 1203;
exports.ER_SET_CONSTANTS_ONLY = 1204;
exports.ER_LOCK_WAIT_TIMEOUT = 1205;
exports.ER_LOCK_TABLE_FULL = 1206;
exports.ER_READ_ONLY_TRANSACTION = 1207;
exports.ER_DROP_DB_WITH_READ_LOCK = 1208;
exports.ER_CREATE_DB_WITH_READ_LOCK = 1209;
exports.ER_WRONG_ARGUMENTS = 1210;
exports.ER_NO_PERMISSION_TO_CREATE_USER = 1211;
exports.ER_UNION_TABLES_IN_DIFFERENT_DIR = 1212;
exports.ER_LOCK_DEADLOCK = 1213;
exports.ER_TABLE_CANT_HANDLE_FT = 1214;
exports.ER_CANNOT_ADD_FOREIGN = 1215;
exports.ER_NO_REFERENCED_ROW = 1216;
exports.ER_ROW_IS_REFERENCED = 1217;
exports.ER_CONNECT_TO_SOURCE = 1218;
exports.ER_QUERY_ON_MASTER = 1219;
exports.ER_ERROR_WHEN_EXECUTING_COMMAND = 1220;
exports.ER_WRONG_USAGE = 1221;
exports.ER_WRONG_NUMBER_OF_COLUMNS_IN_SELECT = 1222;
exports.ER_CANT_UPDATE_WITH_READLOCK = 1223;
exports.ER_MIXING_NOT_ALLOWED = 1224;
exports.ER_DUP_ARGUMENT = 1225;
exports.ER_USER_LIMIT_REACHED = 1226;
exports.ER_SPECIFIC_ACCESS_DENIED_ERROR = 1227;
exports.ER_LOCAL_VARIABLE = 1228;
exports.ER_GLOBAL_VARIABLE = 1229;
exports.ER_NO_DEFAULT = 1230;
exports.ER_WRONG_VALUE_FOR_VAR = 1231;
exports.ER_WRONG_TYPE_FOR_VAR = 1232;
exports.ER_VAR_CANT_BE_READ = 1233;
exports.ER_CANT_USE_OPTION_HERE = 1234;
exports.ER_NOT_SUPPORTED_YET = 1235;
exports.ER_SOURCE_FATAL_ERROR_READING_BINLOG = 1236;
exports.ER_REPLICA_IGNORED_TABLE = 1237;
exports.ER_INCORRECT_GLOBAL_LOCAL_VAR = 1238;
exports.ER_WRONG_FK_DEF = 1239;
exports.ER_KEY_REF_DO_NOT_MATCH_TABLE_REF = 1240;
exports.ER_OPERAND_COLUMNS = 1241;
exports.ER_SUBQUERY_NO_1_ROW = 1242;
exports.ER_UNKNOWN_STMT_HANDLER = 1243;
exports.ER_CORRUPT_HELP_DB = 1244;
exports.ER_CYCLIC_REFERENCE = 1245;
exports.ER_AUTO_CONVERT = 1246;
exports.ER_ILLEGAL_REFERENCE = 1247;
exports.ER_DERIVED_MUST_HAVE_ALIAS = 1248;
exports.ER_SELECT_REDUCED = 1249;
exports.ER_TABLENAME_NOT_ALLOWED_HERE = 1250;
exports.ER_NOT_SUPPORTED_AUTH_MODE = 1251;
exports.ER_SPATIAL_CANT_HAVE_NULL = 1252;
exports.ER_COLLATION_CHARSET_MISMATCH = 1253;
exports.ER_SLAVE_WAS_RUNNING = 1254;
exports.ER_SLAVE_WAS_NOT_RUNNING = 1255;
exports.ER_TOO_BIG_FOR_UNCOMPRESS = 1256;
exports.ER_ZLIB_Z_MEM_ERROR = 1257;
exports.ER_ZLIB_Z_BUF_ERROR = 1258;
exports.ER_ZLIB_Z_DATA_ERROR = 1259;
exports.ER_CUT_VALUE_GROUP_CONCAT = 1260;
exports.ER_WARN_TOO_FEW_RECORDS = 1261;
exports.ER_WARN_TOO_MANY_RECORDS = 1262;
exports.ER_WARN_NULL_TO_NOTNULL = 1263;
exports.ER_WARN_DATA_OUT_OF_RANGE = 1264;
exports.WARN_DATA_TRUNCATED = 1265;
exports.ER_WARN_USING_OTHER_HANDLER = 1266;
exports.ER_CANT_AGGREGATE_2COLLATIONS = 1267;
exports.ER_DROP_USER = 1268;
exports.ER_REVOKE_GRANTS = 1269;
exports.ER_CANT_AGGREGATE_3COLLATIONS = 1270;
exports.ER_CANT_AGGREGATE_NCOLLATIONS = 1271;
exports.ER_VARIABLE_IS_NOT_STRUCT = 1272;
exports.ER_UNKNOWN_COLLATION = 1273;
exports.ER_REPLICA_IGNORED_SSL_PARAMS = 1274;
exports.ER_SERVER_IS_IN_SECURE_AUTH_MODE = 1275;
exports.ER_WARN_FIELD_RESOLVED = 1276;
exports.ER_BAD_REPLICA_UNTIL_COND = 1277;
exports.ER_MISSING_SKIP_REPLICA = 1278;
exports.ER_UNTIL_COND_IGNORED = 1279;
exports.ER_WRONG_NAME_FOR_INDEX = 1280;
exports.ER_WRONG_NAME_FOR_CATALOG = 1281;
exports.ER_WARN_QC_RESIZE = 1282;
exports.ER_BAD_FT_COLUMN = 1283;
exports.ER_UNKNOWN_KEY_CACHE = 1284;
exports.ER_WARN_HOSTNAME_WONT_WORK = 1285;
exports.ER_UNKNOWN_STORAGE_ENGINE = 1286;
exports.ER_WARN_DEPRECATED_SYNTAX = 1287;
exports.ER_NON_UPDATABLE_TABLE = 1288;
exports.ER_FEATURE_DISABLED = 1289;
exports.ER_OPTION_PREVENTS_STATEMENT = 1290;
exports.ER_DUPLICATED_VALUE_IN_TYPE = 1291;
exports.ER_TRUNCATED_WRONG_VALUE = 1292;
exports.ER_TOO_MUCH_AUTO_TIMESTAMP_COLS = 1293;
exports.ER_INVALID_ON_UPDATE = 1294;
exports.ER_UNSUPPORTED_PS = 1295;
exports.ER_GET_ERRMSG = 1296;
exports.ER_GET_TEMPORARY_ERRMSG = 1297;
exports.ER_UNKNOWN_TIME_ZONE = 1298;
exports.ER_WARN_INVALID_TIMESTAMP = 1299;
exports.ER_INVALID_CHARACTER_STRING = 1300;
exports.ER_WARN_ALLOWED_PACKET_OVERFLOWED = 1301;
exports.ER_CONFLICTING_DECLARATIONS = 1302;
exports.ER_SP_NO_RECURSIVE_CREATE = 1303;
exports.ER_SP_ALREADY_EXISTS = 1304;
exports.ER_SP_DOES_NOT_EXIST = 1305;
exports.ER_SP_DROP_FAILED = 1306;
exports.ER_SP_STORE_FAILED = 1307;
exports.ER_SP_LILABEL_MISMATCH = 1308;
exports.ER_SP_LABEL_REDEFINE = 1309;
exports.ER_SP_LABEL_MISMATCH = 1310;
exports.ER_SP_UNINIT_VAR = 1311;
exports.ER_SP_BADSELECT = 1312;
exports.ER_SP_BADRETURN = 1313;
exports.ER_SP_BADSTATEMENT = 1314;
exports.ER_UPDATE_LOG_DEPRECATED_IGNORED = 1315;
exports.ER_UPDATE_LOG_DEPRECATED_TRANSLATED = 1316;
exports.ER_QUERY_INTERRUPTED = 1317;
exports.ER_SP_WRONG_NO_OF_ARGS = 1318;
exports.ER_SP_COND_MISMATCH = 1319;
exports.ER_SP_NORETURN = 1320;
exports.ER_SP_NORETURNEND = 1321;
exports.ER_SP_BAD_CURSOR_QUERY = 1322;
exports.ER_SP_BAD_CURSOR_SELECT = 1323;
exports.ER_SP_CURSOR_MISMATCH = 1324;
exports.ER_SP_CURSOR_ALREADY_OPEN = 1325;
exports.ER_SP_CURSOR_NOT_OPEN = 1326;
exports.ER_SP_UNDECLARED_VAR = 1327;
exports.ER_SP_WRONG_NO_OF_FETCH_ARGS = 1328;
exports.ER_SP_FETCH_NO_DATA = 1329;
exports.ER_SP_DUP_PARAM = 1330;
exports.ER_SP_DUP_VAR = 1331;
exports.ER_SP_DUP_COND = 1332;
exports.ER_SP_DUP_CURS = 1333;
exports.ER_SP_CANT_ALTER = 1334;
exports.ER_SP_SUBSELECT_NYI = 1335;
exports.ER_STMT_NOT_ALLOWED_IN_SF_OR_TRG = 1336;
exports.ER_SP_VARCOND_AFTER_CURSHNDLR = 1337;
exports.ER_SP_CURSOR_AFTER_HANDLER = 1338;
exports.ER_SP_CASE_NOT_FOUND = 1339;
exports.ER_FPARSER_TOO_BIG_FILE = 1340;
exports.ER_FPARSER_BAD_HEADER = 1341;
exports.ER_FPARSER_EOF_IN_COMMENT = 1342;
exports.ER_FPARSER_ERROR_IN_PARAMETER = 1343;
exports.ER_FPARSER_EOF_IN_UNKNOWN_PARAMETER = 1344;
exports.ER_VIEW_NO_EXPLAIN = 1345;
exports.ER_FRM_UNKNOWN_TYPE = 1346;
exports.ER_WRONG_OBJECT = 1347;
exports.ER_NONUPDATEABLE_COLUMN = 1348;
exports.ER_VIEW_SELECT_DERIVED = 1349;
exports.ER_VIEW_SELECT_CLAUSE = 1350;
exports.ER_VIEW_SELECT_VARIABLE = 1351;
exports.ER_VIEW_SELECT_TMPTABLE = 1352;
exports.ER_VIEW_WRONG_LIST = 1353;
exports.ER_WARN_VIEW_MERGE = 1354;
exports.ER_WARN_VIEW_WITHOUT_KEY = 1355;
exports.ER_VIEW_INVALID = 1356;
exports.ER_SP_NO_DROP_SP = 1357;
exports.ER_SP_GOTO_IN_HNDLR = 1358;
exports.ER_TRG_ALREADY_EXISTS = 1359;
exports.ER_TRG_DOES_NOT_EXIST = 1360;
exports.ER_TRG_ON_VIEW_OR_TEMP_TABLE = 1361;
exports.ER_TRG_CANT_CHANGE_ROW = 1362;
exports.ER_TRG_NO_SUCH_ROW_IN_TRG = 1363;
exports.ER_NO_DEFAULT_FOR_FIELD = 1364;
exports.ER_DIVISION_BY_ZERO = 1365;
exports.ER_TRUNCATED_WRONG_VALUE_FOR_FIELD = 1366;
exports.ER_ILLEGAL_VALUE_FOR_TYPE = 1367;
exports.ER_VIEW_NONUPD_CHECK = 1368;
exports.ER_VIEW_CHECK_FAILED = 1369;
exports.ER_PROCACCESS_DENIED_ERROR = 1370;
exports.ER_RELAY_LOG_FAIL = 1371;
exports.ER_PASSWD_LENGTH = 1372;
exports.ER_UNKNOWN_TARGET_BINLOG = 1373;
exports.ER_IO_ERR_LOG_INDEX_READ = 1374;
exports.ER_BINLOG_PURGE_PROHIBITED = 1375;
exports.ER_FSEEK_FAIL = 1376;
exports.ER_BINLOG_PURGE_FATAL_ERR = 1377;
exports.ER_LOG_IN_USE = 1378;
exports.ER_LOG_PURGE_UNKNOWN_ERR = 1379;
exports.ER_RELAY_LOG_INIT = 1380;
exports.ER_NO_BINARY_LOGGING = 1381;
exports.ER_RESERVED_SYNTAX = 1382;
exports.ER_WSAS_FAILED = 1383;
exports.ER_DIFF_GROUPS_PROC = 1384;
exports.ER_NO_GROUP_FOR_PROC = 1385;
exports.ER_ORDER_WITH_PROC = 1386;
exports.ER_LOGGING_PROHIBIT_CHANGING_OF = 1387;
exports.ER_NO_FILE_MAPPING = 1388;
exports.ER_WRONG_MAGIC = 1389;
exports.ER_PS_MANY_PARAM = 1390;
exports.ER_KEY_PART_0 = 1391;
exports.ER_VIEW_CHECKSUM = 1392;
exports.ER_VIEW_MULTIUPDATE = 1393;
exports.ER_VIEW_NO_INSERT_FIELD_LIST = 1394;
exports.ER_VIEW_DELETE_MERGE_VIEW = 1395;
exports.ER_CANNOT_USER = 1396;
exports.ER_XAER_NOTA = 1397;
exports.ER_XAER_INVAL = 1398;
exports.ER_XAER_RMFAIL = 1399;
exports.ER_XAER_OUTSIDE = 1400;
exports.ER_XAER_RMERR = 1401;
exports.ER_XA_RBROLLBACK = 1402;
exports.ER_NONEXISTING_PROC_GRANT = 1403;
exports.ER_PROC_AUTO_GRANT_FAIL = 1404;
exports.ER_PROC_AUTO_REVOKE_FAIL = 1405;
exports.ER_DATA_TOO_LONG = 1406;
exports.ER_SP_BAD_SQLSTATE = 1407;
exports.ER_STARTUP = 1408;
exports.ER_LOAD_FROM_FIXED_SIZE_ROWS_TO_VAR = 1409;
exports.ER_CANT_CREATE_USER_WITH_GRANT = 1410;
exports.ER_WRONG_VALUE_FOR_TYPE = 1411;
exports.ER_TABLE_DEF_CHANGED = 1412;
exports.ER_SP_DUP_HANDLER = 1413;
exports.ER_SP_NOT_VAR_ARG = 1414;
exports.ER_SP_NO_RETSET = 1415;
exports.ER_CANT_CREATE_GEOMETRY_OBJECT = 1416;
exports.ER_FAILED_ROUTINE_BREAK_BINLOG = 1417;
exports.ER_BINLOG_UNSAFE_ROUTINE = 1418;
exports.ER_BINLOG_CREATE_ROUTINE_NEED_SUPER = 1419;
exports.ER_EXEC_STMT_WITH_OPEN_CURSOR = 1420;
exports.ER_STMT_HAS_NO_OPEN_CURSOR = 1421;
exports.ER_COMMIT_NOT_ALLOWED_IN_SF_OR_TRG = 1422;
exports.ER_NO_DEFAULT_FOR_VIEW_FIELD = 1423;
exports.ER_SP_NO_RECURSION = 1424;
exports.ER_TOO_BIG_SCALE = 1425;
exports.ER_TOO_BIG_PRECISION = 1426;
exports.ER_M_BIGGER_THAN_D = 1427;
exports.ER_WRONG_LOCK_OF_SYSTEM_TABLE = 1428;
exports.ER_CONNECT_TO_FOREIGN_DATA_SOURCE = 1429;
exports.ER_QUERY_ON_FOREIGN_DATA_SOURCE = 1430;
exports.ER_FOREIGN_DATA_SOURCE_DOESNT_EXIST = 1431;
exports.ER_FOREIGN_DATA_STRING_INVALID_CANT_CREATE = 1432;
exports.ER_FOREIGN_DATA_STRING_INVALID = 1433;
exports.ER_CANT_CREATE_FEDERATED_TABLE = 1434;
exports.ER_TRG_IN_WRONG_SCHEMA = 1435;
exports.ER_STACK_OVERRUN_NEED_MORE = 1436;
exports.ER_TOO_LONG_BODY = 1437;
exports.ER_WARN_CANT_DROP_DEFAULT_KEYCACHE = 1438;
exports.ER_TOO_BIG_DISPLAYWIDTH = 1439;
exports.ER_XAER_DUPID = 1440;
exports.ER_DATETIME_FUNCTION_OVERFLOW = 1441;
exports.ER_CANT_UPDATE_USED_TABLE_IN_SF_OR_TRG = 1442;
exports.ER_VIEW_PREVENT_UPDATE = 1443;
exports.ER_PS_NO_RECURSION = 1444;
exports.ER_SP_CANT_SET_AUTOCOMMIT = 1445;
exports.ER_MALFORMED_DEFINER = 1446;
exports.ER_VIEW_FRM_NO_USER = 1447;
exports.ER_VIEW_OTHER_USER = 1448;
exports.ER_NO_SUCH_USER = 1449;
exports.ER_FORBID_SCHEMA_CHANGE = 1450;
exports.ER_ROW_IS_REFERENCED_2 = 1451;
exports.ER_NO_REFERENCED_ROW_2 = 1452;
exports.ER_SP_BAD_VAR_SHADOW = 1453;
exports.ER_TRG_NO_DEFINER = 1454;
exports.ER_OLD_FILE_FORMAT = 1455;
exports.ER_SP_RECURSION_LIMIT = 1456;
exports.ER_SP_PROC_TABLE_CORRUPT = 1457;
exports.ER_SP_WRONG_NAME = 1458;
exports.ER_TABLE_NEEDS_UPGRADE = 1459;
exports.ER_SP_NO_AGGREGATE = 1460;
exports.ER_MAX_PREPARED_STMT_COUNT_REACHED = 1461;
exports.ER_VIEW_RECURSIVE = 1462;
exports.ER_NON_GROUPING_FIELD_USED = 1463;
exports.ER_TABLE_CANT_HANDLE_SPKEYS = 1464;
exports.ER_NO_TRIGGERS_ON_SYSTEM_SCHEMA = 1465;
exports.ER_REMOVED_SPACES = 1466;
exports.ER_AUTOINC_READ_FAILED = 1467;
exports.ER_USERNAME = 1468;
exports.ER_HOSTNAME = 1469;
exports.ER_WRONG_STRING_LENGTH = 1470;
exports.ER_NON_INSERTABLE_TABLE = 1471;
exports.ER_ADMIN_WRONG_MRG_TABLE = 1472;
exports.ER_TOO_HIGH_LEVEL_OF_NESTING_FOR_SELECT = 1473;
exports.ER_NAME_BECOMES_EMPTY = 1474;
exports.ER_AMBIGUOUS_FIELD_TERM = 1475;
exports.ER_FOREIGN_SERVER_EXISTS = 1476;
exports.ER_FOREIGN_SERVER_DOESNT_EXIST = 1477;
exports.ER_ILLEGAL_HA_CREATE_OPTION = 1478;
exports.ER_PARTITION_REQUIRES_VALUES_ERROR = 1479;
exports.ER_PARTITION_WRONG_VALUES_ERROR = 1480;
exports.ER_PARTITION_MAXVALUE_ERROR = 1481;
exports.ER_PARTITION_SUBPARTITION_ERROR = 1482;
exports.ER_PARTITION_SUBPART_MIX_ERROR = 1483;
exports.ER_PARTITION_WRONG_NO_PART_ERROR = 1484;
exports.ER_PARTITION_WRONG_NO_SUBPART_ERROR = 1485;
exports.ER_WRONG_EXPR_IN_PARTITION_FUNC_ERROR = 1486;
exports.ER_NO_CONST_EXPR_IN_RANGE_OR_LIST_ERROR = 1487;
exports.ER_FIELD_NOT_FOUND_PART_ERROR = 1488;
exports.ER_LIST_OF_FIELDS_ONLY_IN_HASH_ERROR = 1489;
exports.ER_INCONSISTENT_PARTITION_INFO_ERROR = 1490;
exports.ER_PARTITION_FUNC_NOT_ALLOWED_ERROR = 1491;
exports.ER_PARTITIONS_MUST_BE_DEFINED_ERROR = 1492;
exports.ER_RANGE_NOT_INCREASING_ERROR = 1493;
exports.ER_INCONSISTENT_TYPE_OF_FUNCTIONS_ERROR = 1494;
exports.ER_MULTIPLE_DEF_CONST_IN_LIST_PART_ERROR = 1495;
exports.ER_PARTITION_ENTRY_ERROR = 1496;
exports.ER_MIX_HANDLER_ERROR = 1497;
exports.ER_PARTITION_NOT_DEFINED_ERROR = 1498;
exports.ER_TOO_MANY_PARTITIONS_ERROR = 1499;
exports.ER_SUBPARTITION_ERROR = 1500;
exports.ER_CANT_CREATE_HANDLER_FILE = 1501;
exports.ER_BLOB_FIELD_IN_PART_FUNC_ERROR = 1502;
exports.ER_UNIQUE_KEY_NEED_ALL_FIELDS_IN_PF = 1503;
exports.ER_NO_PARTS_ERROR = 1504;
exports.ER_PARTITION_MGMT_ON_NONPARTITIONED = 1505;
exports.ER_FOREIGN_KEY_ON_PARTITIONED = 1506;
exports.ER_DROP_PARTITION_NON_EXISTENT = 1507;
exports.ER_DROP_LAST_PARTITION = 1508;
exports.ER_COALESCE_ONLY_ON_HASH_PARTITION = 1509;
exports.ER_REORG_HASH_ONLY_ON_SAME_NO = 1510;
exports.ER_REORG_NO_PARAM_ERROR = 1511;
exports.ER_ONLY_ON_RANGE_LIST_PARTITION = 1512;
exports.ER_ADD_PARTITION_SUBPART_ERROR = 1513;
exports.ER_ADD_PARTITION_NO_NEW_PARTITION = 1514;
exports.ER_COALESCE_PARTITION_NO_PARTITION = 1515;
exports.ER_REORG_PARTITION_NOT_EXIST = 1516;
exports.ER_SAME_NAME_PARTITION = 1517;
exports.ER_NO_BINLOG_ERROR = 1518;
exports.ER_CONSECUTIVE_REORG_PARTITIONS = 1519;
exports.ER_REORG_OUTSIDE_RANGE = 1520;
exports.ER_PARTITION_FUNCTION_FAILURE = 1521;
exports.ER_PART_STATE_ERROR = 1522;
exports.ER_LIMITED_PART_RANGE = 1523;
exports.ER_PLUGIN_IS_NOT_LOADED = 1524;
exports.ER_WRONG_VALUE = 1525;
exports.ER_NO_PARTITION_FOR_GIVEN_VALUE = 1526;
exports.ER_FILEGROUP_OPTION_ONLY_ONCE = 1527;
exports.ER_CREATE_FILEGROUP_FAILED = 1528;
exports.ER_DROP_FILEGROUP_FAILED = 1529;
exports.ER_TABLESPACE_AUTO_EXTEND_ERROR = 1530;
exports.ER_WRONG_SIZE_NUMBER = 1531;
exports.ER_SIZE_OVERFLOW_ERROR = 1532;
exports.ER_ALTER_FILEGROUP_FAILED = 1533;
exports.ER_BINLOG_ROW_LOGGING_FAILED = 1534;
exports.ER_BINLOG_ROW_WRONG_TABLE_DEF = 1535;
exports.ER_BINLOG_ROW_RBR_TO_SBR = 1536;
exports.ER_EVENT_ALREADY_EXISTS = 1537;
exports.ER_EVENT_STORE_FAILED = 1538;
exports.ER_EVENT_DOES_NOT_EXIST = 1539;
exports.ER_EVENT_CANT_ALTER = 1540;
exports.ER_EVENT_DROP_FAILED = 1541;
exports.ER_EVENT_INTERVAL_NOT_POSITIVE_OR_TOO_BIG = 1542;
exports.ER_EVENT_ENDS_BEFORE_STARTS = 1543;
exports.ER_EVENT_EXEC_TIME_IN_THE_PAST = 1544;
exports.ER_EVENT_OPEN_TABLE_FAILED = 1545;
exports.ER_EVENT_NEITHER_M_EXPR_NOR_M_AT = 1546;
exports.ER_COL_COUNT_DOESNT_MATCH_CORRUPTED = 1547;
exports.ER_CANNOT_LOAD_FROM_TABLE = 1548;
exports.ER_EVENT_CANNOT_DELETE = 1549;
exports.ER_EVENT_COMPILE_ERROR = 1550;
exports.ER_EVENT_SAME_NAME = 1551;
exports.ER_EVENT_DATA_TOO_LONG = 1552;
exports.ER_DROP_INDEX_FK = 1553;
exports.ER_WARN_DEPRECATED_SYNTAX_WITH_VER = 1554;
exports.ER_CANT_WRITE_LOCK_LOG_TABLE = 1555;
exports.ER_CANT_LOCK_LOG_TABLE = 1556;
exports.ER_FOREIGN_DUPLICATE_KEY = 1557;
exports.ER_COL_COUNT_DOESNT_MATCH_PLEASE_UPDATE = 1558;
exports.ER_TEMP_TABLE_PREVENTS_SWITCH_OUT_OF_RBR = 1559;
exports.ER_STORED_FUNCTION_PREVENTS_SWITCH_BINLOG_FORMAT = 1560;
exports.ER_NDB_CANT_SWITCH_BINLOG_FORMAT = 1561;
exports.ER_PARTITION_NO_TEMPORARY = 1562;
exports.ER_PARTITION_CONST_DOMAIN_ERROR = 1563;
exports.ER_PARTITION_FUNCTION_IS_NOT_ALLOWED = 1564;
exports.ER_DDL_LOG_ERROR = 1565;
exports.ER_NULL_IN_VALUES_LESS_THAN = 1566;
exports.ER_WRONG_PARTITION_NAME = 1567;
exports.ER_CANT_CHANGE_TX_CHARACTERISTICS = 1568;
exports.ER_DUP_ENTRY_AUTOINCREMENT_CASE = 1569;
exports.ER_EVENT_MODIFY_QUEUE_ERROR = 1570;
exports.ER_EVENT_SET_VAR_ERROR = 1571;
exports.ER_PARTITION_MERGE_ERROR = 1572;
exports.ER_CANT_ACTIVATE_LOG = 1573;
exports.ER_RBR_NOT_AVAILABLE = 1574;
exports.ER_BASE64_DECODE_ERROR = 1575;
exports.ER_EVENT_RECURSION_FORBIDDEN = 1576;
exports.ER_EVENTS_DB_ERROR = 1577;
exports.ER_ONLY_INTEGERS_ALLOWED = 1578;
exports.ER_UNSUPORTED_LOG_ENGINE = 1579;
exports.ER_BAD_LOG_STATEMENT = 1580;
exports.ER_CANT_RENAME_LOG_TABLE = 1581;
exports.ER_WRONG_PARAMCOUNT_TO_NATIVE_FCT = 1582;
exports.ER_WRONG_PARAMETERS_TO_NATIVE_FCT = 1583;
exports.ER_WRONG_PARAMETERS_TO_STORED_FCT = 1584;
exports.ER_NATIVE_FCT_NAME_COLLISION = 1585;
exports.ER_DUP_ENTRY_WITH_KEY_NAME = 1586;
exports.ER_BINLOG_PURGE_EMFILE = 1587;
exports.ER_EVENT_CANNOT_CREATE_IN_THE_PAST = 1588;
exports.ER_EVENT_CANNOT_ALTER_IN_THE_PAST = 1589;
exports.ER_SLAVE_INCIDENT = 1590;
exports.ER_NO_PARTITION_FOR_GIVEN_VALUE_SILENT = 1591;
exports.ER_BINLOG_UNSAFE_STATEMENT = 1592;
exports.ER_BINLOG_FATAL_ERROR = 1593;
exports.ER_SLAVE_RELAY_LOG_READ_FAILURE = 1594;
exports.ER_SLAVE_RELAY_LOG_WRITE_FAILURE = 1595;
exports.ER_SLAVE_CREATE_EVENT_FAILURE = 1596;
exports.ER_SLAVE_MASTER_COM_FAILURE = 1597;
exports.ER_BINLOG_LOGGING_IMPOSSIBLE = 1598;
exports.ER_VIEW_NO_CREATION_CTX = 1599;
exports.ER_VIEW_INVALID_CREATION_CTX = 1600;
exports.ER_SR_INVALID_CREATION_CTX = 1601;
exports.ER_TRG_CORRUPTED_FILE = 1602;
exports.ER_TRG_NO_CREATION_CTX = 1603;
exports.ER_TRG_INVALID_CREATION_CTX = 1604;
exports.ER_EVENT_INVALID_CREATION_CTX = 1605;
exports.ER_TRG_CANT_OPEN_TABLE = 1606;
exports.ER_CANT_CREATE_SROUTINE = 1607;
exports.ER_NEVER_USED = 1608;
exports.ER_NO_FORMAT_DESCRIPTION_EVENT_BEFORE_BINLOG_STATEMENT = 1609;
exports.ER_REPLICA_CORRUPT_EVENT = 1610;
exports.ER_LOAD_DATA_INVALID_COLUMN = 1611;
exports.ER_LOG_PURGE_NO_FILE = 1612;
exports.ER_XA_RBTIMEOUT = 1613;
exports.ER_XA_RBDEADLOCK = 1614;
exports.ER_NEED_REPREPARE = 1615;
exports.ER_DELAYED_NOT_SUPPORTED = 1616;
exports.WARN_NO_CONNECTION_METADATA = 1617;
exports.WARN_OPTION_IGNORED = 1618;
exports.ER_PLUGIN_DELETE_BUILTIN = 1619;
exports.WARN_PLUGIN_BUSY = 1620;
exports.ER_VARIABLE_IS_READONLY = 1621;
exports.ER_WARN_ENGINE_TRANSACTION_ROLLBACK = 1622;
exports.ER_SLAVE_HEARTBEAT_FAILURE = 1623;
exports.ER_REPLICA_HEARTBEAT_VALUE_OUT_OF_RANGE = 1624;
exports.ER_NDB_REPLICATION_SCHEMA_ERROR = 1625;
exports.ER_CONFLICT_FN_PARSE_ERROR = 1626;
exports.ER_EXCEPTIONS_WRITE_ERROR = 1627;
exports.ER_TOO_LONG_TABLE_COMMENT = 1628;
exports.ER_TOO_LONG_FIELD_COMMENT = 1629;
exports.ER_FUNC_INEXISTENT_NAME_COLLISION = 1630;
exports.ER_DATABASE_NAME = 1631;
exports.ER_TABLE_NAME = 1632;
exports.ER_PARTITION_NAME = 1633;
exports.ER_SUBPARTITION_NAME = 1634;
exports.ER_TEMPORARY_NAME = 1635;
exports.ER_RENAMED_NAME = 1636;
exports.ER_TOO_MANY_CONCURRENT_TRXS = 1637;
exports.WARN_NON_ASCII_SEPARATOR_NOT_IMPLEMENTED = 1638;
exports.ER_DEBUG_SYNC_TIMEOUT = 1639;
exports.ER_DEBUG_SYNC_HIT_LIMIT = 1640;
exports.ER_DUP_SIGNAL_SET = 1641;
exports.ER_SIGNAL_WARN = 1642;
exports.ER_SIGNAL_NOT_FOUND = 1643;
exports.ER_SIGNAL_EXCEPTION = 1644;
exports.ER_RESIGNAL_WITHOUT_ACTIVE_HANDLER = 1645;
exports.ER_SIGNAL_BAD_CONDITION_TYPE = 1646;
exports.WARN_COND_ITEM_TRUNCATED = 1647;
exports.ER_COND_ITEM_TOO_LONG = 1648;
exports.ER_UNKNOWN_LOCALE = 1649;
exports.ER_REPLICA_IGNORE_SERVER_IDS = 1650;
exports.ER_QUERY_CACHE_DISABLED = 1651;
exports.ER_SAME_NAME_PARTITION_FIELD = 1652;
exports.ER_PARTITION_COLUMN_LIST_ERROR = 1653;
exports.ER_WRONG_TYPE_COLUMN_VALUE_ERROR = 1654;
exports.ER_TOO_MANY_PARTITION_FUNC_FIELDS_ERROR = 1655;
exports.ER_MAXVALUE_IN_VALUES_IN = 1656;
exports.ER_TOO_MANY_VALUES_ERROR = 1657;
exports.ER_ROW_SINGLE_PARTITION_FIELD_ERROR = 1658;
exports.ER_FIELD_TYPE_NOT_ALLOWED_AS_PARTITION_FIELD = 1659;
exports.ER_PARTITION_FIELDS_TOO_LONG = 1660;
exports.ER_BINLOG_ROW_ENGINE_AND_STMT_ENGINE = 1661;
exports.ER_BINLOG_ROW_MODE_AND_STMT_ENGINE = 1662;
exports.ER_BINLOG_UNSAFE_AND_STMT_ENGINE = 1663;
exports.ER_BINLOG_ROW_INJECTION_AND_STMT_ENGINE = 1664;
exports.ER_BINLOG_STMT_MODE_AND_ROW_ENGINE = 1665;
exports.ER_BINLOG_ROW_INJECTION_AND_STMT_MODE = 1666;
exports.ER_BINLOG_MULTIPLE_ENGINES_AND_SELF_LOGGING_ENGINE = 1667;
exports.ER_BINLOG_UNSAFE_LIMIT = 1668;
exports.ER_UNUSED4 = 1669;
exports.ER_BINLOG_UNSAFE_SYSTEM_TABLE = 1670;
exports.ER_BINLOG_UNSAFE_AUTOINC_COLUMNS = 1671;
exports.ER_BINLOG_UNSAFE_UDF = 1672;
exports.ER_BINLOG_UNSAFE_SYSTEM_VARIABLE = 1673;
exports.ER_BINLOG_UNSAFE_SYSTEM_FUNCTION = 1674;
exports.ER_BINLOG_UNSAFE_NONTRANS_AFTER_TRANS = 1675;
exports.ER_MESSAGE_AND_STATEMENT = 1676;
exports.ER_SLAVE_CONVERSION_FAILED = 1677;
exports.ER_REPLICA_CANT_CREATE_CONVERSION = 1678;
exports.ER_INSIDE_TRANSACTION_PREVENTS_SWITCH_BINLOG_FORMAT = 1679;
exports.ER_PATH_LENGTH = 1680;
exports.ER_WARN_DEPRECATED_SYNTAX_NO_REPLACEMENT = 1681;
exports.ER_WRONG_NATIVE_TABLE_STRUCTURE = 1682;
exports.ER_WRONG_PERFSCHEMA_USAGE = 1683;
exports.ER_WARN_I_S_SKIPPED_TABLE = 1684;
exports.ER_INSIDE_TRANSACTION_PREVENTS_SWITCH_BINLOG_DIRECT = 1685;
exports.ER_STORED_FUNCTION_PREVENTS_SWITCH_BINLOG_DIRECT = 1686;
exports.ER_SPATIAL_MUST_HAVE_GEOM_COL = 1687;
exports.ER_TOO_LONG_INDEX_COMMENT = 1688;
exports.ER_LOCK_ABORTED = 1689;
exports.ER_DATA_OUT_OF_RANGE = 1690;
exports.ER_WRONG_SPVAR_TYPE_IN_LIMIT = 1691;
exports.ER_BINLOG_UNSAFE_MULTIPLE_ENGINES_AND_SELF_LOGGING_ENGINE = 1692;
exports.ER_BINLOG_UNSAFE_MIXED_STATEMENT = 1693;
exports.ER_INSIDE_TRANSACTION_PREVENTS_SWITCH_SQL_LOG_BIN = 1694;
exports.ER_STORED_FUNCTION_PREVENTS_SWITCH_SQL_LOG_BIN = 1695;
exports.ER_FAILED_READ_FROM_PAR_FILE = 1696;
exports.ER_VALUES_IS_NOT_INT_TYPE_ERROR = 1697;
exports.ER_ACCESS_DENIED_NO_PASSWORD_ERROR = 1698;
exports.ER_SET_PASSWORD_AUTH_PLUGIN = 1699;
exports.ER_GRANT_PLUGIN_USER_EXISTS = 1700;
exports.ER_TRUNCATE_ILLEGAL_FK = 1701;
exports.ER_PLUGIN_IS_PERMANENT = 1702;
exports.ER_REPLICA_HEARTBEAT_VALUE_OUT_OF_RANGE_MIN = 1703;
exports.ER_REPLICA_HEARTBEAT_VALUE_OUT_OF_RANGE_MAX = 1704;
exports.ER_STMT_CACHE_FULL = 1705;
exports.ER_MULTI_UPDATE_KEY_CONFLICT = 1706;
exports.ER_TABLE_NEEDS_REBUILD = 1707;
exports.WARN_OPTION_BELOW_LIMIT = 1708;
exports.ER_INDEX_COLUMN_TOO_LONG = 1709;
exports.ER_ERROR_IN_TRIGGER_BODY = 1710;
exports.ER_ERROR_IN_UNKNOWN_TRIGGER_BODY = 1711;
exports.ER_INDEX_CORRUPT = 1712;
exports.ER_UNDO_RECORD_TOO_BIG = 1713;
exports.ER_BINLOG_UNSAFE_INSERT_IGNORE_SELECT = 1714;
exports.ER_BINLOG_UNSAFE_INSERT_SELECT_UPDATE = 1715;
exports.ER_BINLOG_UNSAFE_REPLACE_SELECT = 1716;
exports.ER_BINLOG_UNSAFE_CREATE_IGNORE_SELECT = 1717;
exports.ER_BINLOG_UNSAFE_CREATE_REPLACE_SELECT = 1718;
exports.ER_BINLOG_UNSAFE_UPDATE_IGNORE = 1719;
exports.ER_PLUGIN_NO_UNINSTALL = 1720;
exports.ER_PLUGIN_NO_INSTALL = 1721;
exports.ER_BINLOG_UNSAFE_WRITE_AUTOINC_SELECT = 1722;
exports.ER_BINLOG_UNSAFE_CREATE_SELECT_AUTOINC = 1723;
exports.ER_BINLOG_UNSAFE_INSERT_TWO_KEYS = 1724;
exports.ER_TABLE_IN_FK_CHECK = 1725;
exports.ER_UNSUPPORTED_ENGINE = 1726;
exports.ER_BINLOG_UNSAFE_AUTOINC_NOT_FIRST = 1727;
exports.ER_CANNOT_LOAD_FROM_TABLE_V2 = 1728;
exports.ER_SOURCE_DELAY_VALUE_OUT_OF_RANGE = 1729;
exports.ER_ONLY_FD_AND_RBR_EVENTS_ALLOWED_IN_BINLOG_STATEMENT = 1730;
exports.ER_PARTITION_EXCHANGE_DIFFERENT_OPTION = 1731;
exports.ER_PARTITION_EXCHANGE_PART_TABLE = 1732;
exports.ER_PARTITION_EXCHANGE_TEMP_TABLE = 1733;
exports.ER_PARTITION_INSTEAD_OF_SUBPARTITION = 1734;
exports.ER_UNKNOWN_PARTITION = 1735;
exports.ER_TABLES_DIFFERENT_METADATA = 1736;
exports.ER_ROW_DOES_NOT_MATCH_PARTITION = 1737;
exports.ER_BINLOG_CACHE_SIZE_GREATER_THAN_MAX = 1738;
exports.ER_WARN_INDEX_NOT_APPLICABLE = 1739;
exports.ER_PARTITION_EXCHANGE_FOREIGN_KEY = 1740;
exports.ER_NO_SUCH_KEY_VALUE = 1741;
exports.ER_RPL_INFO_DATA_TOO_LONG = 1742;
exports.ER_NETWORK_READ_EVENT_CHECKSUM_FAILURE = 1743;
exports.ER_BINLOG_READ_EVENT_CHECKSUM_FAILURE = 1744;
exports.ER_BINLOG_STMT_CACHE_SIZE_GREATER_THAN_MAX = 1745;
exports.ER_CANT_UPDATE_TABLE_IN_CREATE_TABLE_SELECT = 1746;
exports.ER_PARTITION_CLAUSE_ON_NONPARTITIONED = 1747;
exports.ER_ROW_DOES_NOT_MATCH_GIVEN_PARTITION_SET = 1748;
exports.ER_NO_SUCH_PARTITION = 1749;
exports.ER_CHANGE_RPL_INFO_REPOSITORY_FAILURE = 1750;
exports.ER_WARNING_NOT_COMPLETE_ROLLBACK_WITH_CREATED_TEMP_TABLE = 1751;
exports.ER_WARNING_NOT_COMPLETE_ROLLBACK_WITH_DROPPED_TEMP_TABLE = 1752;
exports.ER_MTA_FEATURE_IS_NOT_SUPPORTED = 1753;
exports.ER_MTA_UPDATED_DBS_GREATER_MAX = 1754;
exports.ER_MTA_CANT_PARALLEL = 1755;
exports.ER_MTA_INCONSISTENT_DATA = 1756;
exports.ER_FULLTEXT_NOT_SUPPORTED_WITH_PARTITIONING = 1757;
exports.ER_DA_INVALID_CONDITION_NUMBER = 1758;
exports.ER_INSECURE_PLAIN_TEXT = 1759;
exports.ER_INSECURE_CHANGE_SOURCE = 1760;
exports.ER_FOREIGN_DUPLICATE_KEY_WITH_CHILD_INFO = 1761;
exports.ER_FOREIGN_DUPLICATE_KEY_WITHOUT_CHILD_INFO = 1762;
exports.ER_SQLTHREAD_WITH_SECURE_REPLICA = 1763;
exports.ER_TABLE_HAS_NO_FT = 1764;
exports.ER_VARIABLE_NOT_SETTABLE_IN_SF_OR_TRIGGER = 1765;
exports.ER_VARIABLE_NOT_SETTABLE_IN_TRANSACTION = 1766;
exports.ER_GTID_NEXT_IS_NOT_IN_GTID_NEXT_LIST = 1767;
exports.ER_CANT_CHANGE_GTID_NEXT_IN_TRANSACTION = 1768;
exports.ER_SET_STATEMENT_CANNOT_INVOKE_FUNCTION = 1769;
exports.ER_GTID_NEXT_CANT_BE_AUTOMATIC_IF_GTID_NEXT_LIST_IS_NON_NULL = 1770;
exports.ER_SKIPPING_LOGGED_TRANSACTION = 1771;
exports.ER_MALFORMED_GTID_SET_SPECIFICATION = 1772;
exports.ER_MALFORMED_GTID_SET_ENCODING = 1773;
exports.ER_MALFORMED_GTID_SPECIFICATION = 1774;
exports.ER_GNO_EXHAUSTED = 1775;
exports.ER_BAD_REPLICA_AUTO_POSITION = 1776;
exports.ER_AUTO_POSITION_REQUIRES_GTID_MODE_NOT_OFF = 1777;
exports.ER_CANT_DO_IMPLICIT_COMMIT_IN_TRX_WHEN_GTID_NEXT_IS_SET = 1778;
exports.ER_GTID_MODE_ON_REQUIRES_ENFORCE_GTID_CONSISTENCY_ON = 1779;
exports.ER_GTID_MODE_REQUIRES_BINLOG = 1780;
exports.ER_CANT_SET_GTID_NEXT_TO_GTID_WHEN_GTID_MODE_IS_OFF = 1781;
exports.ER_CANT_SET_GTID_NEXT_TO_ANONYMOUS_WHEN_GTID_MODE_IS_ON = 1782;
exports.ER_CANT_SET_GTID_NEXT_LIST_TO_NON_NULL_WHEN_GTID_MODE_IS_OFF = 1783;
exports.ER_FOUND_GTID_EVENT_WHEN_GTID_MODE_IS_OFF = 1784;
exports.ER_GTID_UNSAFE_NON_TRANSACTIONAL_TABLE = 1785;
exports.ER_GTID_UNSAFE_CREATE_SELECT = 1786;
exports.ER_GTID_UNSAFE_CREATE_DROP_TEMP_TABLE_IN_TRANSACTION = 1787;
exports.ER_GTID_MODE_CAN_ONLY_CHANGE_ONE_STEP_AT_A_TIME = 1788;
exports.ER_SOURCE_HAS_PURGED_REQUIRED_GTIDS = 1789;
exports.ER_CANT_SET_GTID_NEXT_WHEN_OWNING_GTID = 1790;
exports.ER_UNKNOWN_EXPLAIN_FORMAT = 1791;
exports.ER_CANT_EXECUTE_IN_READ_ONLY_TRANSACTION = 1792;
exports.ER_TOO_LONG_TABLE_PARTITION_COMMENT = 1793;
exports.ER_REPLICA_CONFIGURATION = 1794;
exports.ER_INNODB_FT_LIMIT = 1795;
exports.ER_INNODB_NO_FT_TEMP_TABLE = 1796;
exports.ER_INNODB_FT_WRONG_DOCID_COLUMN = 1797;
exports.ER_INNODB_FT_WRONG_DOCID_INDEX = 1798;
exports.ER_INNODB_ONLINE_LOG_TOO_BIG = 1799;
exports.ER_UNKNOWN_ALTER_ALGORITHM = 1800;
exports.ER_UNKNOWN_ALTER_LOCK = 1801;
exports.ER_MTA_CHANGE_SOURCE_CANT_RUN_WITH_GAPS = 1802;
exports.ER_MTA_RECOVERY_FAILURE = 1803;
exports.ER_MTA_RESET_WORKERS = 1804;
exports.ER_COL_COUNT_DOESNT_MATCH_CORRUPTED_V2 = 1805;
exports.ER_REPLICA_SILENT_RETRY_TRANSACTION = 1806;
exports.ER_DISCARD_FK_CHECKS_RUNNING = 1807;
exports.ER_TABLE_SCHEMA_MISMATCH = 1808;
exports.ER_TABLE_IN_SYSTEM_TABLESPACE = 1809;
exports.ER_IO_READ_ERROR = 1810;
exports.ER_IO_WRITE_ERROR = 1811;
exports.ER_TABLESPACE_MISSING = 1812;
exports.ER_TABLESPACE_EXISTS = 1813;
exports.ER_TABLESPACE_DISCARDED = 1814;
exports.ER_INTERNAL_ERROR = 1815;
exports.ER_INNODB_IMPORT_ERROR = 1816;
exports.ER_INNODB_INDEX_CORRUPT = 1817;
exports.ER_INVALID_YEAR_COLUMN_LENGTH = 1818;
exports.ER_NOT_VALID_PASSWORD = 1819;
exports.ER_MUST_CHANGE_PASSWORD = 1820;
exports.ER_FK_NO_INDEX_CHILD = 1821;
exports.ER_FK_NO_INDEX_PARENT = 1822;
exports.ER_FK_FAIL_ADD_SYSTEM = 1823;
exports.ER_FK_CANNOT_OPEN_PARENT = 1824;
exports.ER_FK_INCORRECT_OPTION = 1825;
exports.ER_FK_DUP_NAME = 1826;
exports.ER_PASSWORD_FORMAT = 1827;
exports.ER_FK_COLUMN_CANNOT_DROP = 1828;
exports.ER_FK_COLUMN_CANNOT_DROP_CHILD = 1829;
exports.ER_FK_COLUMN_NOT_NULL = 1830;
exports.ER_DUP_INDEX = 1831;
exports.ER_FK_COLUMN_CANNOT_CHANGE = 1832;
exports.ER_FK_COLUMN_CANNOT_CHANGE_CHILD = 1833;
exports.ER_UNUSED5 = 1834;
exports.ER_MALFORMED_PACKET = 1835;
exports.ER_READ_ONLY_MODE = 1836;
exports.ER_GTID_NEXT_TYPE_UNDEFINED_GTID = 1837;
exports.ER_VARIABLE_NOT_SETTABLE_IN_SP = 1838;
exports.ER_CANT_SET_GTID_PURGED_WHEN_GTID_MODE_IS_OFF = 1839;
exports.ER_CANT_SET_GTID_PURGED_WHEN_GTID_EXECUTED_IS_NOT_EMPTY = 1840;
exports.ER_CANT_SET_GTID_PURGED_WHEN_OWNED_GTIDS_IS_NOT_EMPTY = 1841;
exports.ER_GTID_PURGED_WAS_CHANGED = 1842;
exports.ER_GTID_EXECUTED_WAS_CHANGED = 1843;
exports.ER_BINLOG_STMT_MODE_AND_NO_REPL_TABLES = 1844;
exports.ER_ALTER_OPERATION_NOT_SUPPORTED = 1845;
exports.ER_ALTER_OPERATION_NOT_SUPPORTED_REASON = 1846;
exports.ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_COPY = 1847;
exports.ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_PARTITION = 1848;
exports.ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_FK_RENAME = 1849;
exports.ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_COLUMN_TYPE = 1850;
exports.ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_FK_CHECK = 1851;
exports.ER_UNUSED6 = 1852;
exports.ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_NOPK = 1853;
exports.ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_AUTOINC = 1854;
exports.ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_HIDDEN_FTS = 1855;
exports.ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_CHANGE_FTS = 1856;
exports.ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_FTS = 1857;
exports.ER_SQL_REPLICA_SKIP_COUNTER_NOT_SETTABLE_IN_GTID_MODE = 1858;
exports.ER_DUP_UNKNOWN_IN_INDEX = 1859;
exports.ER_IDENT_CAUSES_TOO_LONG_PATH = 1860;
exports.ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_NOT_NULL = 1861;
exports.ER_MUST_CHANGE_PASSWORD_LOGIN = 1862;
exports.ER_ROW_IN_WRONG_PARTITION = 1863;
exports.ER_MTA_EVENT_BIGGER_PENDING_JOBS_SIZE_MAX = 1864;
exports.ER_INNODB_NO_FT_USES_PARSER = 1865;
exports.ER_BINLOG_LOGICAL_CORRUPTION = 1866;
exports.ER_WARN_PURGE_LOG_IN_USE = 1867;
exports.ER_WARN_PURGE_LOG_IS_ACTIVE = 1868;
exports.ER_AUTO_INCREMENT_CONFLICT = 1869;
exports.WARN_ON_BLOCKHOLE_IN_RBR = 1870;
exports.ER_REPLICA_CM_INIT_REPOSITORY = 1871;
exports.ER_REPLICA_AM_INIT_REPOSITORY = 1872;
exports.ER_ACCESS_DENIED_CHANGE_USER_ERROR = 1873;
exports.ER_INNODB_READ_ONLY = 1874;
exports.ER_STOP_REPLICA_SQL_THREAD_TIMEOUT = 1875;
exports.ER_STOP_REPLICA_IO_THREAD_TIMEOUT = 1876;
exports.ER_TABLE_CORRUPT = 1877;
exports.ER_TEMP_FILE_WRITE_FAILURE = 1878;
exports.ER_INNODB_FT_AUX_NOT_HEX_ID = 1879;
exports.ER_OLD_TEMPORALS_UPGRADED = 1880;
exports.ER_INNODB_FORCED_RECOVERY = 1881;
exports.ER_AES_INVALID_IV = 1882;
exports.ER_PLUGIN_CANNOT_BE_UNINSTALLED = 1883;
exports.ER_GTID_UNSAFE_BINLOG_SPLITTABLE_STATEMENT_AND_ASSIGNED_GTID = 1884;
exports.ER_REPLICA_HAS_MORE_GTIDS_THAN_SOURCE = 1885;
exports.ER_MISSING_KEY = 1886;
exports.WARN_NAMED_PIPE_ACCESS_EVERYONE = 1887;
exports.ER_FILE_CORRUPT = 3000;
exports.ER_ERROR_ON_SOURCE = 3001;
exports.ER_INCONSISTENT_ERROR = 3002;
exports.ER_STORAGE_ENGINE_NOT_LOADED = 3003;
exports.ER_GET_STACKED_DA_WITHOUT_ACTIVE_HANDLER = 3004;
exports.ER_WARN_LEGACY_SYNTAX_CONVERTED = 3005;
exports.ER_BINLOG_UNSAFE_FULLTEXT_PLUGIN = 3006;
exports.ER_CANNOT_DISCARD_TEMPORARY_TABLE = 3007;
exports.ER_FK_DEPTH_EXCEEDED = 3008;
exports.ER_COL_COUNT_DOESNT_MATCH_PLEASE_UPDATE_V2 = 3009;
exports.ER_WARN_TRIGGER_DOESNT_HAVE_CREATED = 3010;
exports.ER_REFERENCED_TRG_DOES_NOT_EXIST = 3011;
exports.ER_EXPLAIN_NOT_SUPPORTED = 3012;
exports.ER_INVALID_FIELD_SIZE = 3013;
exports.ER_MISSING_HA_CREATE_OPTION = 3014;
exports.ER_ENGINE_OUT_OF_MEMORY = 3015;
exports.ER_PASSWORD_EXPIRE_ANONYMOUS_USER = 3016;
exports.ER_REPLICA_SQL_THREAD_MUST_STOP = 3017;
exports.ER_NO_FT_MATERIALIZED_SUBQUERY = 3018;
exports.ER_INNODB_UNDO_LOG_FULL = 3019;
exports.ER_INVALID_ARGUMENT_FOR_LOGARITHM = 3020;
exports.ER_REPLICA_CHANNEL_IO_THREAD_MUST_STOP = 3021;
exports.ER_WARN_OPEN_TEMP_TABLES_MUST_BE_ZERO = 3022;
exports.ER_WARN_ONLY_SOURCE_LOG_FILE_NO_POS = 3023;
exports.ER_QUERY_TIMEOUT = 3024;
exports.ER_NON_RO_SELECT_DISABLE_TIMER = 3025;
exports.ER_DUP_LIST_ENTRY = 3026;
exports.ER_SQL_MODE_NO_EFFECT = 3027;
exports.ER_AGGREGATE_ORDER_FOR_UNION = 3028;
exports.ER_AGGREGATE_ORDER_NON_AGG_QUERY = 3029;
exports.ER_REPLICA_WORKER_STOPPED_PREVIOUS_THD_ERROR = 3030;
exports.ER_DONT_SUPPORT_REPLICA_PRESERVE_COMMIT_ORDER = 3031;
exports.ER_SERVER_OFFLINE_MODE = 3032;
exports.ER_GIS_DIFFERENT_SRIDS = 3033;
exports.ER_GIS_UNSUPPORTED_ARGUMENT = 3034;
exports.ER_GIS_UNKNOWN_ERROR = 3035;
exports.ER_GIS_UNKNOWN_EXCEPTION = 3036;
exports.ER_GIS_INVALID_DATA = 3037;
exports.ER_BOOST_GEOMETRY_EMPTY_INPUT_EXCEPTION = 3038;
exports.ER_BOOST_GEOMETRY_CENTROID_EXCEPTION = 3039;
exports.ER_BOOST_GEOMETRY_OVERLAY_INVALID_INPUT_EXCEPTION = 3040;
exports.ER_BOOST_GEOMETRY_TURN_INFO_EXCEPTION = 3041;
exports.ER_BOOST_GEOMETRY_SELF_INTERSECTION_POINT_EXCEPTION = 3042;
exports.ER_BOOST_GEOMETRY_UNKNOWN_EXCEPTION = 3043;
exports.ER_STD_BAD_ALLOC_ERROR = 3044;
exports.ER_STD_DOMAIN_ERROR = 3045;
exports.ER_STD_LENGTH_ERROR = 3046;
exports.ER_STD_INVALID_ARGUMENT = 3047;
exports.ER_STD_OUT_OF_RANGE_ERROR = 3048;
exports.ER_STD_OVERFLOW_ERROR = 3049;
exports.ER_STD_RANGE_ERROR = 3050;
exports.ER_STD_UNDERFLOW_ERROR = 3051;
exports.ER_STD_LOGIC_ERROR = 3052;
exports.ER_STD_RUNTIME_ERROR = 3053;
exports.ER_STD_UNKNOWN_EXCEPTION = 3054;
exports.ER_GIS_DATA_WRONG_ENDIANESS = 3055;
exports.ER_CHANGE_SOURCE_PASSWORD_LENGTH = 3056;
exports.ER_USER_LOCK_WRONG_NAME = 3057;
exports.ER_USER_LOCK_DEADLOCK = 3058;
exports.ER_REPLACE_INACCESSIBLE_ROWS = 3059;
exports.ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_GIS = 3060;
exports.ER_ILLEGAL_USER_VAR = 3061;
exports.ER_GTID_MODE_OFF = 3062;
exports.ER_UNSUPPORTED_BY_REPLICATION_THREAD = 3063;
exports.ER_INCORRECT_TYPE = 3064;
exports.ER_FIELD_IN_ORDER_NOT_SELECT = 3065;
exports.ER_AGGREGATE_IN_ORDER_NOT_SELECT = 3066;
exports.ER_INVALID_RPL_WILD_TABLE_FILTER_PATTERN = 3067;
exports.ER_NET_OK_PACKET_TOO_LARGE = 3068;
exports.ER_INVALID_JSON_DATA = 3069;
exports.ER_INVALID_GEOJSON_MISSING_MEMBER = 3070;
exports.ER_INVALID_GEOJSON_WRONG_TYPE = 3071;
exports.ER_INVALID_GEOJSON_UNSPECIFIED = 3072;
exports.ER_DIMENSION_UNSUPPORTED = 3073;
exports.ER_REPLICA_CHANNEL_DOES_NOT_EXIST = 3074;
exports.ER_SLAVE_MULTIPLE_CHANNELS_HOST_PORT = 3075;
exports.ER_REPLICA_CHANNEL_NAME_INVALID_OR_TOO_LONG = 3076;
exports.ER_REPLICA_NEW_CHANNEL_WRONG_REPOSITORY = 3077;
exports.ER_SLAVE_CHANNEL_DELETE = 3078;
exports.ER_REPLICA_MULTIPLE_CHANNELS_CMD = 3079;
exports.ER_REPLICA_MAX_CHANNELS_EXCEEDED = 3080;
exports.ER_REPLICA_CHANNEL_MUST_STOP = 3081;
exports.ER_REPLICA_CHANNEL_NOT_RUNNING = 3082;
exports.ER_REPLICA_CHANNEL_WAS_RUNNING = 3083;
exports.ER_REPLICA_CHANNEL_WAS_NOT_RUNNING = 3084;
exports.ER_REPLICA_CHANNEL_SQL_THREAD_MUST_STOP = 3085;
exports.ER_REPLICA_CHANNEL_SQL_SKIP_COUNTER = 3086;
exports.ER_WRONG_FIELD_WITH_GROUP_V2 = 3087;
exports.ER_MIX_OF_GROUP_FUNC_AND_FIELDS_V2 = 3088;
exports.ER_WARN_DEPRECATED_SYSVAR_UPDATE = 3089;
exports.ER_WARN_DEPRECATED_SQLMODE = 3090;
exports.ER_CANNOT_LOG_PARTIAL_DROP_DATABASE_WITH_GTID = 3091;
exports.ER_GROUP_REPLICATION_CONFIGURATION = 3092;
exports.ER_GROUP_REPLICATION_RUNNING = 3093;
exports.ER_GROUP_REPLICATION_APPLIER_INIT_ERROR = 3094;
exports.ER_GROUP_REPLICATION_STOP_APPLIER_THREAD_TIMEOUT = 3095;
exports.ER_GROUP_REPLICATION_COMMUNICATION_LAYER_SESSION_ERROR = 3096;
exports.ER_GROUP_REPLICATION_COMMUNICATION_LAYER_JOIN_ERROR = 3097;
exports.ER_BEFORE_DML_VALIDATION_ERROR = 3098;
exports.ER_PREVENTS_VARIABLE_WITHOUT_RBR = 3099;
exports.ER_RUN_HOOK_ERROR = 3100;
exports.ER_TRANSACTION_ROLLBACK_DURING_COMMIT = 3101;
exports.ER_GENERATED_COLUMN_FUNCTION_IS_NOT_ALLOWED = 3102;
exports.ER_UNSUPPORTED_ALTER_INPLACE_ON_VIRTUAL_COLUMN = 3103;
exports.ER_WRONG_FK_OPTION_FOR_GENERATED_COLUMN = 3104;
exports.ER_NON_DEFAULT_VALUE_FOR_GENERATED_COLUMN = 3105;
exports.ER_UNSUPPORTED_ACTION_ON_GENERATED_COLUMN = 3106;
exports.ER_GENERATED_COLUMN_NON_PRIOR = 3107;
exports.ER_DEPENDENT_BY_GENERATED_COLUMN = 3108;
exports.ER_GENERATED_COLUMN_REF_AUTO_INC = 3109;
exports.ER_FEATURE_NOT_AVAILABLE = 3110;
exports.ER_CANT_SET_GTID_MODE = 3111;
exports.ER_CANT_USE_AUTO_POSITION_WITH_GTID_MODE_OFF = 3112;
exports.ER_CANT_REPLICATE_ANONYMOUS_WITH_AUTO_POSITION = 3113;
exports.ER_CANT_REPLICATE_ANONYMOUS_WITH_GTID_MODE_ON = 3114;
exports.ER_CANT_REPLICATE_GTID_WITH_GTID_MODE_OFF = 3115;
exports.ER_CANT_ENFORCE_GTID_CONSISTENCY_WITH_ONGOING_GTID_VIOLATING_TX = 3116;
exports.ER_ENFORCE_GTID_CONSISTENCY_WARN_WITH_ONGOING_GTID_VIOLATING_TX = 3117;
exports.ER_ACCOUNT_HAS_BEEN_LOCKED = 3118;
exports.ER_WRONG_TABLESPACE_NAME = 3119;
exports.ER_TABLESPACE_IS_NOT_EMPTY = 3120;
exports.ER_WRONG_FILE_NAME = 3121;
exports.ER_BOOST_GEOMETRY_INCONSISTENT_TURNS_EXCEPTION = 3122;
exports.ER_WARN_OPTIMIZER_HINT_SYNTAX_ERROR = 3123;
exports.ER_WARN_BAD_MAX_EXECUTION_TIME = 3124;
exports.ER_WARN_UNSUPPORTED_MAX_EXECUTION_TIME = 3125;
exports.ER_WARN_CONFLICTING_HINT = 3126;
exports.ER_WARN_UNKNOWN_QB_NAME = 3127;
exports.ER_UNRESOLVED_HINT_NAME = 3128;
exports.ER_WARN_ON_MODIFYING_GTID_EXECUTED_TABLE = 3129;
exports.ER_PLUGGABLE_PROTOCOL_COMMAND_NOT_SUPPORTED = 3130;
exports.ER_LOCKING_SERVICE_WRONG_NAME = 3131;
exports.ER_LOCKING_SERVICE_DEADLOCK = 3132;
exports.ER_LOCKING_SERVICE_TIMEOUT = 3133;
exports.ER_GIS_MAX_POINTS_IN_GEOMETRY_OVERFLOWED = 3134;
exports.ER_SQL_MODE_MERGED = 3135;
exports.ER_VTOKEN_PLUGIN_TOKEN_MISMATCH = 3136;
exports.ER_VTOKEN_PLUGIN_TOKEN_NOT_FOUND = 3137;
exports.ER_CANT_SET_VARIABLE_WHEN_OWNING_GTID = 3138;
exports.ER_REPLICA_CHANNEL_OPERATION_NOT_ALLOWED = 3139;
exports.ER_INVALID_JSON_TEXT = 3140;
exports.ER_INVALID_JSON_TEXT_IN_PARAM = 3141;
exports.ER_INVALID_JSON_BINARY_DATA = 3142;
exports.ER_INVALID_JSON_PATH = 3143;
exports.ER_INVALID_JSON_CHARSET = 3144;
exports.ER_INVALID_JSON_CHARSET_IN_FUNCTION = 3145;
exports.ER_INVALID_TYPE_FOR_JSON = 3146;
exports.ER_INVALID_CAST_TO_JSON = 3147;
exports.ER_INVALID_JSON_PATH_CHARSET = 3148;
exports.ER_INVALID_JSON_PATH_WILDCARD = 3149;
exports.ER_JSON_VALUE_TOO_BIG = 3150;
exports.ER_JSON_KEY_TOO_BIG = 3151;
exports.ER_JSON_USED_AS_KEY = 3152;
exports.ER_JSON_VACUOUS_PATH = 3153;
exports.ER_JSON_BAD_ONE_OR_ALL_ARG = 3154;
exports.ER_NUMERIC_JSON_VALUE_OUT_OF_RANGE = 3155;
exports.ER_INVALID_JSON_VALUE_FOR_CAST = 3156;
exports.ER_JSON_DOCUMENT_TOO_DEEP = 3157;
exports.ER_JSON_DOCUMENT_NULL_KEY = 3158;
exports.ER_SECURE_TRANSPORT_REQUIRED = 3159;
exports.ER_NO_SECURE_TRANSPORTS_CONFIGURED = 3160;
exports.ER_DISABLED_STORAGE_ENGINE = 3161;
exports.ER_USER_DOES_NOT_EXIST = 3162;
exports.ER_USER_ALREADY_EXISTS = 3163;
exports.ER_AUDIT_API_ABORT = 3164;
exports.ER_INVALID_JSON_PATH_ARRAY_CELL = 3165;
exports.ER_BUFPOOL_RESIZE_INPROGRESS = 3166;
exports.ER_FEATURE_DISABLED_SEE_DOC = 3167;
exports.ER_SERVER_ISNT_AVAILABLE = 3168;
exports.ER_SESSION_WAS_KILLED = 3169;
exports.ER_CAPACITY_EXCEEDED = 3170;
exports.ER_CAPACITY_EXCEEDED_IN_RANGE_OPTIMIZER = 3171;
exports.ER_TABLE_NEEDS_UPG_PART = 3172;
exports.ER_CANT_WAIT_FOR_EXECUTED_GTID_SET_WHILE_OWNING_A_GTID = 3173;
exports.ER_CANNOT_ADD_FOREIGN_BASE_COL_VIRTUAL = 3174;
exports.ER_CANNOT_CREATE_VIRTUAL_INDEX_CONSTRAINT = 3175;
exports.ER_ERROR_ON_MODIFYING_GTID_EXECUTED_TABLE = 3176;
exports.ER_LOCK_REFUSED_BY_ENGINE = 3177;
exports.ER_UNSUPPORTED_ALTER_ONLINE_ON_VIRTUAL_COLUMN = 3178;
exports.ER_MASTER_KEY_ROTATION_NOT_SUPPORTED_BY_SE = 3179;
exports.ER_MASTER_KEY_ROTATION_ERROR_BY_SE = 3180;
exports.ER_MASTER_KEY_ROTATION_BINLOG_FAILED = 3181;
exports.ER_MASTER_KEY_ROTATION_SE_UNAVAILABLE = 3182;
exports.ER_TABLESPACE_CANNOT_ENCRYPT = 3183;
exports.ER_INVALID_ENCRYPTION_OPTION = 3184;
exports.ER_CANNOT_FIND_KEY_IN_KEYRING = 3185;
exports.ER_CAPACITY_EXCEEDED_IN_PARSER = 3186;
exports.ER_UNSUPPORTED_ALTER_ENCRYPTION_INPLACE = 3187;
exports.ER_KEYRING_UDF_KEYRING_SERVICE_ERROR = 3188;
exports.ER_USER_COLUMN_OLD_LENGTH = 3189;
exports.ER_CANT_RESET_SOURCE = 3190;
exports.ER_GROUP_REPLICATION_MAX_GROUP_SIZE = 3191;
exports.ER_CANNOT_ADD_FOREIGN_BASE_COL_STORED = 3192;
exports.ER_TABLE_REFERENCED = 3193;
exports.ER_PARTITION_ENGINE_DEPRECATED_FOR_TABLE = 3194;
exports.ER_WARN_USING_GEOMFROMWKB_TO_SET_SRID_ZERO = 3195;
exports.ER_WARN_USING_GEOMFROMWKB_TO_SET_SRID = 3196;
exports.ER_XA_RETRY = 3197;
exports.ER_KEYRING_AWS_UDF_AWS_KMS_ERROR = 3198;
exports.ER_BINLOG_UNSAFE_XA = 3199;
exports.ER_UDF_ERROR = 3200;
exports.ER_KEYRING_MIGRATION_FAILURE = 3201;
exports.ER_KEYRING_ACCESS_DENIED_ERROR = 3202;
exports.ER_KEYRING_MIGRATION_STATUS = 3203;
exports.ER_PLUGIN_FAILED_TO_OPEN_TABLES = 3204;
exports.ER_PLUGIN_FAILED_TO_OPEN_TABLE = 3205;
exports.ER_AUDIT_LOG_NO_KEYRING_PLUGIN_INSTALLED = 3206;
exports.ER_AUDIT_LOG_ENCRYPTION_PASSWORD_HAS_NOT_BEEN_SET = 3207;
exports.ER_AUDIT_LOG_COULD_NOT_CREATE_AES_KEY = 3208;
exports.ER_AUDIT_LOG_ENCRYPTION_PASSWORD_CANNOT_BE_FETCHED = 3209;
exports.ER_AUDIT_LOG_JSON_FILTERING_NOT_ENABLED = 3210;
exports.ER_AUDIT_LOG_UDF_INSUFFICIENT_PRIVILEGE = 3211;
exports.ER_AUDIT_LOG_SUPER_PRIVILEGE_REQUIRED = 3212;
exports.ER_COULD_NOT_REINITIALIZE_AUDIT_LOG_FILTERS = 3213;
exports.ER_AUDIT_LOG_UDF_INVALID_ARGUMENT_TYPE = 3214;
exports.ER_AUDIT_LOG_UDF_INVALID_ARGUMENT_COUNT = 3215;
exports.ER_AUDIT_LOG_HAS_NOT_BEEN_INSTALLED = 3216;
exports.ER_AUDIT_LOG_UDF_READ_INVALID_MAX_ARRAY_LENGTH_ARG_TYPE = 3217;
exports.ER_AUDIT_LOG_UDF_READ_INVALID_MAX_ARRAY_LENGTH_ARG_VALUE = 3218;
exports.ER_AUDIT_LOG_JSON_FILTER_PARSING_ERROR = 3219;
exports.ER_AUDIT_LOG_JSON_FILTER_NAME_CANNOT_BE_EMPTY = 3220;
exports.ER_AUDIT_LOG_JSON_USER_NAME_CANNOT_BE_EMPTY = 3221;
exports.ER_AUDIT_LOG_JSON_FILTER_DOES_NOT_EXISTS = 3222;
exports.ER_AUDIT_LOG_USER_FIRST_CHARACTER_MUST_BE_ALPHANUMERIC = 3223;
exports.ER_AUDIT_LOG_USER_NAME_INVALID_CHARACTER = 3224;
exports.ER_AUDIT_LOG_HOST_NAME_INVALID_CHARACTER = 3225;
exports.WARN_DEPRECATED_MAXDB_SQL_MODE_FOR_TIMESTAMP = 3226;
exports.ER_XA_REPLICATION_FILTERS = 3227;
exports.ER_CANT_OPEN_ERROR_LOG = 3228;
exports.ER_GROUPING_ON_TIMESTAMP_IN_DST = 3229;
exports.ER_CANT_START_SERVER_NAMED_PIPE = 3230;
exports.ER_WRITE_SET_EXCEEDS_LIMIT = 3231;
exports.ER_DEPRECATED_TLS_VERSION_SESSION_57 = 3232;
exports.ER_WARN_DEPRECATED_TLS_VERSION_57 = 3233;
exports.ER_WARN_WRONG_NATIVE_TABLE_STRUCTURE = 3234;
exports.ER_AES_INVALID_KDF_NAME = 3235;
exports.ER_AES_INVALID_KDF_ITERATIONS = 3236;
exports.WARN_AES_KEY_SIZE = 3237;
exports.ER_AES_INVALID_KDF_OPTION_SIZE = 3238;
exports.ER_UNSUPPORT_COMPRESSED_TEMPORARY_TABLE = 3500;
exports.ER_ACL_OPERATION_FAILED = 3501;
exports.ER_UNSUPPORTED_INDEX_ALGORITHM = 3502;
exports.ER_NO_SUCH_DB = 3503;
exports.ER_TOO_BIG_ENUM = 3504;
exports.ER_TOO_LONG_SET_ENUM_VALUE = 3505;
exports.ER_INVALID_DD_OBJECT = 3506;
exports.ER_UPDATING_DD_TABLE = 3507;
exports.ER_INVALID_DD_OBJECT_ID = 3508;
exports.ER_INVALID_DD_OBJECT_NAME = 3509;
exports.ER_TABLESPACE_MISSING_WITH_NAME = 3510;
exports.ER_TOO_LONG_ROUTINE_COMMENT = 3511;
exports.ER_SP_LOAD_FAILED = 3512;
exports.ER_INVALID_BITWISE_OPERANDS_SIZE = 3513;
exports.ER_INVALID_BITWISE_AGGREGATE_OPERANDS_SIZE = 3514;
exports.ER_WARN_UNSUPPORTED_HINT = 3515;
exports.ER_UNEXPECTED_GEOMETRY_TYPE = 3516;
exports.ER_SRS_PARSE_ERROR = 3517;
exports.ER_SRS_PROJ_PARAMETER_MISSING = 3518;
exports.ER_WARN_SRS_NOT_FOUND = 3519;
exports.ER_SRS_NOT_CARTESIAN = 3520;
exports.ER_SRS_NOT_CARTESIAN_UNDEFINED = 3521;
exports.ER_PK_INDEX_CANT_BE_INVISIBLE = 3522;
exports.ER_UNKNOWN_AUTHID = 3523;
exports.ER_FAILED_ROLE_GRANT = 3524;
exports.ER_OPEN_ROLE_TABLES = 3525;
exports.ER_FAILED_DEFAULT_ROLES = 3526;
exports.ER_COMPONENTS_NO_SCHEME = 3527;
exports.ER_COMPONENTS_NO_SCHEME_SERVICE = 3528;
exports.ER_COMPONENTS_CANT_LOAD = 3529;
exports.ER_ROLE_NOT_GRANTED = 3530;
exports.ER_FAILED_REVOKE_ROLE = 3531;
exports.ER_RENAME_ROLE = 3532;
exports.ER_COMPONENTS_CANT_ACQUIRE_SERVICE_IMPLEMENTATION = 3533;
exports.ER_COMPONENTS_CANT_SATISFY_DEPENDENCY = 3534;
exports.ER_COMPONENTS_LOAD_CANT_REGISTER_SERVICE_IMPLEMENTATION = 3535;
exports.ER_COMPONENTS_LOAD_CANT_INITIALIZE = 3536;
exports.ER_COMPONENTS_UNLOAD_NOT_LOADED = 3537;
exports.ER_COMPONENTS_UNLOAD_CANT_DEINITIALIZE = 3538;
exports.ER_COMPONENTS_CANT_RELEASE_SERVICE = 3539;
exports.ER_COMPONENTS_UNLOAD_CANT_UNREGISTER_SERVICE = 3540;
exports.ER_COMPONENTS_CANT_UNLOAD = 3541;
exports.ER_WARN_UNLOAD_THE_NOT_PERSISTED = 3542;
exports.ER_COMPONENT_TABLE_INCORRECT = 3543;
exports.ER_COMPONENT_MANIPULATE_ROW_FAILED = 3544;
exports.ER_COMPONENTS_UNLOAD_DUPLICATE_IN_GROUP = 3545;
exports.ER_CANT_SET_GTID_PURGED_DUE_SETS_CONSTRAINTS = 3546;
exports.ER_CANNOT_LOCK_USER_MANAGEMENT_CACHES = 3547;
exports.ER_SRS_NOT_FOUND = 3548;
exports.ER_VARIABLE_NOT_PERSISTED = 3549;
exports.ER_IS_QUERY_INVALID_CLAUSE = 3550;
exports.ER_UNABLE_TO_STORE_STATISTICS = 3551;
exports.ER_NO_SYSTEM_SCHEMA_ACCESS = 3552;
exports.ER_NO_SYSTEM_TABLESPACE_ACCESS = 3553;
exports.ER_NO_SYSTEM_TABLE_ACCESS = 3554;
exports.ER_NO_SYSTEM_TABLE_ACCESS_FOR_DICTIONARY_TABLE = 3555;
exports.ER_NO_SYSTEM_TABLE_ACCESS_FOR_SYSTEM_TABLE = 3556;
exports.ER_NO_SYSTEM_TABLE_ACCESS_FOR_TABLE = 3557;
exports.ER_INVALID_OPTION_KEY = 3558;
exports.ER_INVALID_OPTION_VALUE = 3559;
exports.ER_INVALID_OPTION_KEY_VALUE_PAIR = 3560;
exports.ER_INVALID_OPTION_START_CHARACTER = 3561;
exports.ER_INVALID_OPTION_END_CHARACTER = 3562;
exports.ER_INVALID_OPTION_CHARACTERS = 3563;
exports.ER_DUPLICATE_OPTION_KEY = 3564;
exports.ER_WARN_SRS_NOT_FOUND_AXIS_ORDER = 3565;
exports.ER_NO_ACCESS_TO_NATIVE_FCT = 3566;
exports.ER_RESET_SOURCE_TO_VALUE_OUT_OF_RANGE = 3567;
exports.ER_UNRESOLVED_TABLE_LOCK = 3568;
exports.ER_DUPLICATE_TABLE_LOCK = 3569;
exports.ER_BINLOG_UNSAFE_SKIP_LOCKED = 3570;
exports.ER_BINLOG_UNSAFE_NOWAIT = 3571;
exports.ER_LOCK_NOWAIT = 3572;
exports.ER_CTE_RECURSIVE_REQUIRES_UNION = 3573;
exports.ER_CTE_RECURSIVE_REQUIRES_NONRECURSIVE_FIRST = 3574;
exports.ER_CTE_RECURSIVE_FORBIDS_AGGREGATION = 3575;
exports.ER_CTE_RECURSIVE_FORBIDDEN_JOIN_ORDER = 3576;
exports.ER_CTE_RECURSIVE_REQUIRES_SINGLE_REFERENCE = 3577;
exports.ER_SWITCH_TMP_ENGINE = 3578;
exports.ER_WINDOW_NO_SUCH_WINDOW = 3579;
exports.ER_WINDOW_CIRCULARITY_IN_WINDOW_GRAPH = 3580;
exports.ER_WINDOW_NO_CHILD_PARTITIONING = 3581;
exports.ER_WINDOW_NO_INHERIT_FRAME = 3582;
exports.ER_WINDOW_NO_REDEFINE_ORDER_BY = 3583;
exports.ER_WINDOW_FRAME_START_ILLEGAL = 3584;
exports.ER_WINDOW_FRAME_END_ILLEGAL = 3585;
exports.ER_WINDOW_FRAME_ILLEGAL = 3586;
exports.ER_WINDOW_RANGE_FRAME_ORDER_TYPE = 3587;
exports.ER_WINDOW_RANGE_FRAME_TEMPORAL_TYPE = 3588;
exports.ER_WINDOW_RANGE_FRAME_NUMERIC_TYPE = 3589;
exports.ER_WINDOW_RANGE_BOUND_NOT_CONSTANT = 3590;
exports.ER_WINDOW_DUPLICATE_NAME = 3591;
exports.ER_WINDOW_ILLEGAL_ORDER_BY = 3592;
exports.ER_WINDOW_INVALID_WINDOW_FUNC_USE = 3593;
exports.ER_WINDOW_INVALID_WINDOW_FUNC_ALIAS_USE = 3594;
exports.ER_WINDOW_NESTED_WINDOW_FUNC_USE_IN_WINDOW_SPEC = 3595;
exports.ER_WINDOW_ROWS_INTERVAL_USE = 3596;
exports.ER_WINDOW_NO_GROUP_ORDER = 3597;
exports.ER_WINDOW_EXPLAIN_JSON = 3598;
exports.ER_WINDOW_FUNCTION_IGNORES_FRAME = 3599;
exports.ER_WL9236_NOW = 3600;
exports.ER_INVALID_NO_OF_ARGS = 3601;
exports.ER_FIELD_IN_GROUPING_NOT_GROUP_BY = 3602;
exports.ER_TOO_LONG_TABLESPACE_COMMENT = 3603;
exports.ER_ENGINE_CANT_DROP_TABLE = 3604;
exports.ER_ENGINE_CANT_DROP_MISSING_TABLE = 3605;
exports.ER_TABLESPACE_DUP_FILENAME = 3606;
exports.ER_DB_DROP_RMDIR2 = 3607;
exports.ER_IMP_NO_FILES_MATCHED = 3608;
exports.ER_IMP_SCHEMA_DOES_NOT_EXIST = 3609;
exports.ER_IMP_TABLE_ALREADY_EXISTS = 3610;
exports.ER_IMP_INCOMPATIBLE_MYSQLD_VERSION = 3611;
exports.ER_IMP_INCOMPATIBLE_DD_VERSION = 3612;
exports.ER_IMP_INCOMPATIBLE_SDI_VERSION = 3613;
exports.ER_WARN_INVALID_HINT = 3614;
exports.ER_VAR_DOES_NOT_EXIST = 3615;
exports.ER_LONGITUDE_OUT_OF_RANGE = 3616;
exports.ER_LATITUDE_OUT_OF_RANGE = 3617;
exports.ER_NOT_IMPLEMENTED_FOR_GEOGRAPHIC_SRS = 3618;
exports.ER_ILLEGAL_PRIVILEGE_LEVEL = 3619;
exports.ER_NO_SYSTEM_VIEW_ACCESS = 3620;
exports.ER_COMPONENT_FILTER_FLABBERGASTED = 3621;
exports.ER_PART_EXPR_TOO_LONG = 3622;
exports.ER_UDF_DROP_DYNAMICALLY_REGISTERED = 3623;
exports.ER_UNABLE_TO_STORE_COLUMN_STATISTICS = 3624;
exports.ER_UNABLE_TO_UPDATE_COLUMN_STATISTICS = 3625;
exports.ER_UNABLE_TO_DROP_COLUMN_STATISTICS = 3626;
exports.ER_UNABLE_TO_BUILD_HISTOGRAM = 3627;
exports.ER_MANDATORY_ROLE = 3628;
exports.ER_MISSING_TABLESPACE_FILE = 3629;
exports.ER_PERSIST_ONLY_ACCESS_DENIED_ERROR = 3630;
exports.ER_CMD_NEED_SUPER = 3631;
exports.ER_PATH_IN_DATADIR = 3632;
exports.ER_CLONE_DDL_IN_PROGRESS = 3633;
exports.ER_CLONE_TOO_MANY_CONCURRENT_CLONES = 3634;
exports.ER_APPLIER_LOG_EVENT_VALIDATION_ERROR = 3635;
exports.ER_CTE_MAX_RECURSION_DEPTH = 3636;
exports.ER_NOT_HINT_UPDATABLE_VARIABLE = 3637;
exports.ER_CREDENTIALS_CONTRADICT_TO_HISTORY = 3638;
exports.ER_WARNING_PASSWORD_HISTORY_CLAUSES_VOID = 3639;
exports.ER_CLIENT_DOES_NOT_SUPPORT = 3640;
exports.ER_I_S_SKIPPED_TABLESPACE = 3641;
exports.ER_TABLESPACE_ENGINE_MISMATCH = 3642;
exports.ER_WRONG_SRID_FOR_COLUMN = 3643;
exports.ER_CANNOT_ALTER_SRID_DUE_TO_INDEX = 3644;
exports.ER_WARN_BINLOG_PARTIAL_UPDATES_DISABLED = 3645;
exports.ER_WARN_BINLOG_V1_ROW_EVENTS_DISABLED = 3646;
exports.ER_WARN_BINLOG_PARTIAL_UPDATES_SUGGESTS_PARTIAL_IMAGES = 3647;
exports.ER_COULD_NOT_APPLY_JSON_DIFF = 3648;
exports.ER_CORRUPTED_JSON_DIFF = 3649;
exports.ER_RESOURCE_GROUP_EXISTS = 3650;
exports.ER_RESOURCE_GROUP_NOT_EXISTS = 3651;
exports.ER_INVALID_VCPU_ID = 3652;
exports.ER_INVALID_VCPU_RANGE = 3653;
exports.ER_INVALID_THREAD_PRIORITY = 3654;
exports.ER_DISALLOWED_OPERATION = 3655;
exports.ER_RESOURCE_GROUP_BUSY = 3656;
exports.ER_RESOURCE_GROUP_DISABLED = 3657;
exports.ER_FEATURE_UNSUPPORTED = 3658;
exports.ER_ATTRIBUTE_IGNORED = 3659;
exports.ER_INVALID_THREAD_ID = 3660;
exports.ER_RESOURCE_GROUP_BIND_FAILED = 3661;
exports.ER_INVALID_USE_OF_FORCE_OPTION = 3662;
exports.ER_GROUP_REPLICATION_COMMAND_FAILURE = 3663;
exports.ER_SDI_OPERATION_FAILED = 3664;
exports.ER_MISSING_JSON_TABLE_VALUE = 3665;
exports.ER_WRONG_JSON_TABLE_VALUE = 3666;
exports.ER_TF_MUST_HAVE_ALIAS = 3667;
exports.ER_TF_FORBIDDEN_JOIN_TYPE = 3668;
exports.ER_JT_VALUE_OUT_OF_RANGE = 3669;
exports.ER_JT_MAX_NESTED_PATH = 3670;
exports.ER_PASSWORD_EXPIRATION_NOT_SUPPORTED_BY_AUTH_METHOD = 3671;
exports.ER_INVALID_GEOJSON_CRS_NOT_TOP_LEVEL = 3672;
exports.ER_BAD_NULL_ERROR_NOT_IGNORED = 3673;
exports.WARN_USELESS_SPATIAL_INDEX = 3674;
exports.ER_DISK_FULL_NOWAIT = 3675;
exports.ER_PARSE_ERROR_IN_DIGEST_FN = 3676;
exports.ER_UNDISCLOSED_PARSE_ERROR_IN_DIGEST_FN = 3677;
exports.ER_SCHEMA_DIR_EXISTS = 3678;
exports.ER_SCHEMA_DIR_MISSING = 3679;
exports.ER_SCHEMA_DIR_CREATE_FAILED = 3680;
exports.ER_SCHEMA_DIR_UNKNOWN = 3681;
exports.ER_ONLY_IMPLEMENTED_FOR_SRID_0_AND_4326 = 3682;
exports.ER_BINLOG_EXPIRE_LOG_DAYS_AND_SECS_USED_TOGETHER = 3683;
exports.ER_REGEXP_BUFFER_OVERFLOW = 3684;
exports.ER_REGEXP_ILLEGAL_ARGUMENT = 3685;
exports.ER_REGEXP_INDEX_OUTOFBOUNDS_ERROR = 3686;
exports.ER_REGEXP_INTERNAL_ERROR = 3687;
exports.ER_REGEXP_RULE_SYNTAX = 3688;
exports.ER_REGEXP_BAD_ESCAPE_SEQUENCE = 3689;
exports.ER_REGEXP_UNIMPLEMENTED = 3690;
exports.ER_REGEXP_MISMATCHED_PAREN = 3691;
exports.ER_REGEXP_BAD_INTERVAL = 3692;
exports.ER_REGEXP_MAX_LT_MIN = 3693;
exports.ER_REGEXP_INVALID_BACK_REF = 3694;
exports.ER_REGEXP_LOOK_BEHIND_LIMIT = 3695;
exports.ER_REGEXP_MISSING_CLOSE_BRACKET = 3696;
exports.ER_REGEXP_INVALID_RANGE = 3697;
exports.ER_REGEXP_STACK_OVERFLOW = 3698;
exports.ER_REGEXP_TIME_OUT = 3699;
exports.ER_REGEXP_PATTERN_TOO_BIG = 3700;
exports.ER_CANT_SET_ERROR_LOG_SERVICE = 3701;
exports.ER_EMPTY_PIPELINE_FOR_ERROR_LOG_SERVICE = 3702;
exports.ER_COMPONENT_FILTER_DIAGNOSTICS = 3703;
exports.ER_NOT_IMPLEMENTED_FOR_CARTESIAN_SRS = 3704;
exports.ER_NOT_IMPLEMENTED_FOR_PROJECTED_SRS = 3705;
exports.ER_NONPOSITIVE_RADIUS = 3706;
exports.ER_RESTART_SERVER_FAILED = 3707;
exports.ER_SRS_MISSING_MANDATORY_ATTRIBUTE = 3708;
exports.ER_SRS_MULTIPLE_ATTRIBUTE_DEFINITIONS = 3709;
exports.ER_SRS_NAME_CANT_BE_EMPTY_OR_WHITESPACE = 3710;
exports.ER_SRS_ORGANIZATION_CANT_BE_EMPTY_OR_WHITESPACE = 3711;
exports.ER_SRS_ID_ALREADY_EXISTS = 3712;
exports.ER_WARN_SRS_ID_ALREADY_EXISTS = 3713;
exports.ER_CANT_MODIFY_SRID_0 = 3714;
exports.ER_WARN_RESERVED_SRID_RANGE = 3715;
exports.ER_CANT_MODIFY_SRS_USED_BY_COLUMN = 3716;
exports.ER_SRS_INVALID_CHARACTER_IN_ATTRIBUTE = 3717;
exports.ER_SRS_ATTRIBUTE_STRING_TOO_LONG = 3718;
exports.ER_DEPRECATED_UTF8_ALIAS = 3719;
exports.ER_DEPRECATED_NATIONAL = 3720;
exports.ER_INVALID_DEFAULT_UTF8MB4_COLLATION = 3721;
exports.ER_UNABLE_TO_COLLECT_LOG_STATUS = 3722;
exports.ER_RESERVED_TABLESPACE_NAME = 3723;
exports.ER_UNABLE_TO_SET_OPTION = 3724;
exports.ER_REPLICA_POSSIBLY_DIVERGED_AFTER_DDL = 3725;
exports.ER_SRS_NOT_GEOGRAPHIC = 3726;
exports.ER_POLYGON_TOO_LARGE = 3727;
exports.ER_SPATIAL_UNIQUE_INDEX = 3728;
exports.ER_INDEX_TYPE_NOT_SUPPORTED_FOR_SPATIAL_INDEX = 3729;
exports.ER_FK_CANNOT_DROP_PARENT = 3730;
exports.ER_GEOMETRY_PARAM_LONGITUDE_OUT_OF_RANGE = 3731;
exports.ER_GEOMETRY_PARAM_LATITUDE_OUT_OF_RANGE = 3732;
exports.ER_FK_CANNOT_USE_VIRTUAL_COLUMN = 3733;
exports.ER_FK_NO_COLUMN_PARENT = 3734;
exports.ER_CANT_SET_ERROR_SUPPRESSION_LIST = 3735;
exports.ER_SRS_GEOGCS_INVALID_AXES = 3736;
exports.ER_SRS_INVALID_SEMI_MAJOR_AXIS = 3737;
exports.ER_SRS_INVALID_INVERSE_FLATTENING = 3738;
exports.ER_SRS_INVALID_ANGULAR_UNIT = 3739;
exports.ER_SRS_INVALID_PRIME_MERIDIAN = 3740;
exports.ER_TRANSFORM_SOURCE_SRS_NOT_SUPPORTED = 3741;
exports.ER_TRANSFORM_TARGET_SRS_NOT_SUPPORTED = 3742;
exports.ER_TRANSFORM_SOURCE_SRS_MISSING_TOWGS84 = 3743;
exports.ER_TRANSFORM_TARGET_SRS_MISSING_TOWGS84 = 3744;
exports.ER_TEMP_TABLE_PREVENTS_SWITCH_SESSION_BINLOG_FORMAT = 3745;
exports.ER_TEMP_TABLE_PREVENTS_SWITCH_GLOBAL_BINLOG_FORMAT = 3746;
exports.ER_RUNNING_APPLIER_PREVENTS_SWITCH_GLOBAL_BINLOG_FORMAT = 3747;
exports.ER_CLIENT_GTID_UNSAFE_CREATE_DROP_TEMP_TABLE_IN_TRX_IN_SBR = 3748;
exports.ER_XA_CANT_CREATE_MDL_BACKUP = 3749;
exports.ER_TABLE_WITHOUT_PK = 3750;
exports.ER_WARN_DATA_TRUNCATED_FUNCTIONAL_INDEX = 3751;
exports.ER_WARN_DATA_OUT_OF_RANGE_FUNCTIONAL_INDEX = 3752;
exports.ER_FUNCTIONAL_INDEX_ON_JSON_OR_GEOMETRY_FUNCTION = 3753;
exports.ER_FUNCTIONAL_INDEX_REF_AUTO_INCREMENT = 3754;
exports.ER_CANNOT_DROP_COLUMN_FUNCTIONAL_INDEX = 3755;
exports.ER_FUNCTIONAL_INDEX_PRIMARY_KEY = 3756;
exports.ER_FUNCTIONAL_INDEX_ON_LOB = 3757;
exports.ER_FUNCTIONAL_INDEX_FUNCTION_IS_NOT_ALLOWED = 3758;
exports.ER_FULLTEXT_FUNCTIONAL_INDEX = 3759;
exports.ER_SPATIAL_FUNCTIONAL_INDEX = 3760;
exports.ER_WRONG_KEY_COLUMN_FUNCTIONAL_INDEX = 3761;
exports.ER_FUNCTIONAL_INDEX_ON_FIELD = 3762;
exports.ER_GENERATED_COLUMN_NAMED_FUNCTION_IS_NOT_ALLOWED = 3763;
exports.ER_GENERATED_COLUMN_ROW_VALUE = 3764;
exports.ER_GENERATED_COLUMN_VARIABLES = 3765;
exports.ER_DEPENDENT_BY_DEFAULT_GENERATED_VALUE = 3766;
exports.ER_DEFAULT_VAL_GENERATED_NON_PRIOR = 3767;
exports.ER_DEFAULT_VAL_GENERATED_REF_AUTO_INC = 3768;
exports.ER_DEFAULT_VAL_GENERATED_FUNCTION_IS_NOT_ALLOWED = 3769;
exports.ER_DEFAULT_VAL_GENERATED_NAMED_FUNCTION_IS_NOT_ALLOWED = 3770;
exports.ER_DEFAULT_VAL_GENERATED_ROW_VALUE = 3771;
exports.ER_DEFAULT_VAL_GENERATED_VARIABLES = 3772;
exports.ER_DEFAULT_AS_VAL_GENERATED = 3773;
exports.ER_UNSUPPORTED_ACTION_ON_DEFAULT_VAL_GENERATED = 3774;
exports.ER_GTID_UNSAFE_ALTER_ADD_COL_WITH_DEFAULT_EXPRESSION = 3775;
exports.ER_FK_CANNOT_CHANGE_ENGINE = 3776;
exports.ER_WARN_DEPRECATED_USER_SET_EXPR = 3777;
exports.ER_WARN_DEPRECATED_UTF8MB3_COLLATION = 3778;
exports.ER_WARN_DEPRECATED_NESTED_COMMENT_SYNTAX = 3779;
exports.ER_FK_INCOMPATIBLE_COLUMNS = 3780;
exports.ER_GR_HOLD_WAIT_TIMEOUT = 3781;
exports.ER_GR_HOLD_KILLED = 3782;
exports.ER_GR_HOLD_MEMBER_STATUS_ERROR = 3783;
exports.ER_RPL_ENCRYPTION_FAILED_TO_FETCH_KEY = 3784;
exports.ER_RPL_ENCRYPTION_KEY_NOT_FOUND = 3785;
exports.ER_RPL_ENCRYPTION_KEYRING_INVALID_KEY = 3786;
exports.ER_RPL_ENCRYPTION_HEADER_ERROR = 3787;
exports.ER_RPL_ENCRYPTION_FAILED_TO_ROTATE_LOGS = 3788;
exports.ER_RPL_ENCRYPTION_KEY_EXISTS_UNEXPECTED = 3789;
exports.ER_RPL_ENCRYPTION_FAILED_TO_GENERATE_KEY = 3790;
exports.ER_RPL_ENCRYPTION_FAILED_TO_STORE_KEY = 3791;
exports.ER_RPL_ENCRYPTION_FAILED_TO_REMOVE_KEY = 3792;
exports.ER_RPL_ENCRYPTION_UNABLE_TO_CHANGE_OPTION = 3793;
exports.ER_RPL_ENCRYPTION_MASTER_KEY_RECOVERY_FAILED = 3794;
exports.ER_SLOW_LOG_MODE_IGNORED_WHEN_NOT_LOGGING_TO_FILE = 3795;
exports.ER_GRP_TRX_CONSISTENCY_NOT_ALLOWED = 3796;
exports.ER_GRP_TRX_CONSISTENCY_BEFORE = 3797;
exports.ER_GRP_TRX_CONSISTENCY_AFTER_ON_TRX_BEGIN = 3798;
exports.ER_GRP_TRX_CONSISTENCY_BEGIN_NOT_ALLOWED = 3799;
exports.ER_FUNCTIONAL_INDEX_ROW_VALUE_IS_NOT_ALLOWED = 3800;
exports.ER_RPL_ENCRYPTION_FAILED_TO_ENCRYPT = 3801;
exports.ER_PAGE_TRACKING_NOT_STARTED = 3802;
exports.ER_PAGE_TRACKING_RANGE_NOT_TRACKED = 3803;
exports.ER_PAGE_TRACKING_CANNOT_PURGE = 3804;
exports.ER_RPL_ENCRYPTION_CANNOT_ROTATE_BINLOG_MASTER_KEY = 3805;
exports.ER_BINLOG_MASTER_KEY_RECOVERY_OUT_OF_COMBINATION = 3806;
exports.ER_BINLOG_MASTER_KEY_ROTATION_FAIL_TO_OPERATE_KEY = 3807;
exports.ER_BINLOG_MASTER_KEY_ROTATION_FAIL_TO_ROTATE_LOGS = 3808;
exports.ER_BINLOG_MASTER_KEY_ROTATION_FAIL_TO_REENCRYPT_LOG = 3809;
exports.ER_BINLOG_MASTER_KEY_ROTATION_FAIL_TO_CLEANUP_UNUSED_KEYS = 3810;
exports.ER_BINLOG_MASTER_KEY_ROTATION_FAIL_TO_CLEANUP_AUX_KEY = 3811;
exports.ER_NON_BOOLEAN_EXPR_FOR_CHECK_CONSTRAINT = 3812;
exports.ER_COLUMN_CHECK_CONSTRAINT_REFERENCES_OTHER_COLUMN = 3813;
exports.ER_CHECK_CONSTRAINT_NAMED_FUNCTION_IS_NOT_ALLOWED = 3814;
exports.ER_CHECK_CONSTRAINT_FUNCTION_IS_NOT_ALLOWED = 3815;
exports.ER_CHECK_CONSTRAINT_VARIABLES = 3816;
exports.ER_CHECK_CONSTRAINT_ROW_VALUE = 3817;
exports.ER_CHECK_CONSTRAINT_REFERS_AUTO_INCREMENT_COLUMN = 3818;
exports.ER_CHECK_CONSTRAINT_VIOLATED = 3819;
exports.ER_CHECK_CONSTRAINT_REFERS_UNKNOWN_COLUMN = 3820;
exports.ER_CHECK_CONSTRAINT_NOT_FOUND = 3821;
exports.ER_CHECK_CONSTRAINT_DUP_NAME = 3822;
exports.ER_CHECK_CONSTRAINT_CLAUSE_USING_FK_REFER_ACTION_COLUMN = 3823;
exports.WARN_UNENCRYPTED_TABLE_IN_ENCRYPTED_DB = 3824;
exports.ER_INVALID_ENCRYPTION_REQUEST = 3825;
exports.ER_CANNOT_SET_TABLE_ENCRYPTION = 3826;
exports.ER_CANNOT_SET_DATABASE_ENCRYPTION = 3827;
exports.ER_CANNOT_SET_TABLESPACE_ENCRYPTION = 3828;
exports.ER_TABLESPACE_CANNOT_BE_ENCRYPTED = 3829;
exports.ER_TABLESPACE_CANNOT_BE_DECRYPTED = 3830;
exports.ER_TABLESPACE_TYPE_UNKNOWN = 3831;
exports.ER_TARGET_TABLESPACE_UNENCRYPTED = 3832;
exports.ER_CANNOT_USE_ENCRYPTION_CLAUSE = 3833;
exports.ER_INVALID_MULTIPLE_CLAUSES = 3834;
exports.ER_UNSUPPORTED_USE_OF_GRANT_AS = 3835;
exports.ER_UKNOWN_AUTH_ID_OR_ACCESS_DENIED_FOR_GRANT_AS = 3836;
exports.ER_DEPENDENT_BY_FUNCTIONAL_INDEX = 3837;
exports.ER_PLUGIN_NOT_EARLY = 3838;
exports.ER_INNODB_REDO_LOG_ARCHIVE_START_SUBDIR_PATH = 3839;
exports.ER_INNODB_REDO_LOG_ARCHIVE_START_TIMEOUT = 3840;
exports.ER_INNODB_REDO_LOG_ARCHIVE_DIRS_INVALID = 3841;
exports.ER_INNODB_REDO_LOG_ARCHIVE_LABEL_NOT_FOUND = 3842;
exports.ER_INNODB_REDO_LOG_ARCHIVE_DIR_EMPTY = 3843;
exports.ER_INNODB_REDO_LOG_ARCHIVE_NO_SUCH_DIR = 3844;
exports.ER_INNODB_REDO_LOG_ARCHIVE_DIR_CLASH = 3845;
exports.ER_INNODB_REDO_LOG_ARCHIVE_DIR_PERMISSIONS = 3846;
exports.ER_INNODB_REDO_LOG_ARCHIVE_FILE_CREATE = 3847;
exports.ER_INNODB_REDO_LOG_ARCHIVE_ACTIVE = 3848;
exports.ER_INNODB_REDO_LOG_ARCHIVE_INACTIVE = 3849;
exports.ER_INNODB_REDO_LOG_ARCHIVE_FAILED = 3850;
exports.ER_INNODB_REDO_LOG_ARCHIVE_SESSION = 3851;
exports.ER_STD_REGEX_ERROR = 3852;
exports.ER_INVALID_JSON_TYPE = 3853;
exports.ER_CANNOT_CONVERT_STRING = 3854;
exports.ER_DEPENDENT_BY_PARTITION_FUNC = 3855;
exports.ER_WARN_DEPRECATED_FLOAT_AUTO_INCREMENT = 3856;
exports.ER_RPL_CANT_STOP_REPLICA_WHILE_LOCKED_BACKUP = 3857;
exports.ER_WARN_DEPRECATED_FLOAT_DIGITS = 3858;
exports.ER_WARN_DEPRECATED_FLOAT_UNSIGNED = 3859;
exports.ER_WARN_DEPRECATED_INTEGER_DISPLAY_WIDTH = 3860;
exports.ER_WARN_DEPRECATED_ZEROFILL = 3861;
exports.ER_CLONE_DONOR = 3862;
exports.ER_CLONE_PROTOCOL = 3863;
exports.ER_CLONE_DONOR_VERSION = 3864;
exports.ER_CLONE_OS = 3865;
exports.ER_CLONE_PLATFORM = 3866;
exports.ER_CLONE_CHARSET = 3867;
exports.ER_CLONE_CONFIG = 3868;
exports.ER_CLONE_SYS_CONFIG = 3869;
exports.ER_CLONE_PLUGIN_MATCH = 3870;
exports.ER_CLONE_LOOPBACK = 3871;
exports.ER_CLONE_ENCRYPTION = 3872;
exports.ER_CLONE_DISK_SPACE = 3873;
exports.ER_CLONE_IN_PROGRESS = 3874;
exports.ER_CLONE_DISALLOWED = 3875;
exports.ER_CANNOT_GRANT_ROLES_TO_ANONYMOUS_USER = 3876;
exports.ER_SECONDARY_ENGINE_PLUGIN = 3877;
exports.ER_SECOND_PASSWORD_CANNOT_BE_EMPTY = 3878;
exports.ER_DB_ACCESS_DENIED = 3879;
exports.ER_DA_AUTH_ID_WITH_SYSTEM_USER_PRIV_IN_MANDATORY_ROLES = 3880;
exports.ER_DA_RPL_GTID_TABLE_CANNOT_OPEN = 3881;
exports.ER_GEOMETRY_IN_UNKNOWN_LENGTH_UNIT = 3882;
exports.ER_DA_PLUGIN_INSTALL_ERROR = 3883;
exports.ER_NO_SESSION_TEMP = 3884;
exports.ER_DA_UNKNOWN_ERROR_NUMBER = 3885;
exports.ER_COLUMN_CHANGE_SIZE = 3886;
exports.ER_REGEXP_INVALID_CAPTURE_GROUP_NAME = 3887;
exports.ER_DA_SSL_LIBRARY_ERROR = 3888;
exports.ER_SECONDARY_ENGINE = 3889;
exports.ER_SECONDARY_ENGINE_DDL = 3890;
exports.ER_INCORRECT_CURRENT_PASSWORD = 3891;
exports.ER_MISSING_CURRENT_PASSWORD = 3892;
exports.ER_CURRENT_PASSWORD_NOT_REQUIRED = 3893;
exports.ER_PASSWORD_CANNOT_BE_RETAINED_ON_PLUGIN_CHANGE = 3894;
exports.ER_CURRENT_PASSWORD_CANNOT_BE_RETAINED = 3895;
exports.ER_PARTIAL_REVOKES_EXIST = 3896;
exports.ER_CANNOT_GRANT_SYSTEM_PRIV_TO_MANDATORY_ROLE = 3897;
exports.ER_XA_REPLICATION_FILTERS = 3898;
exports.ER_UNSUPPORTED_SQL_MODE = 3899;
exports.ER_REGEXP_INVALID_FLAG = 3900;
exports.ER_PARTIAL_REVOKE_AND_DB_GRANT_BOTH_EXISTS = 3901;
exports.ER_UNIT_NOT_FOUND = 3902;
exports.ER_INVALID_JSON_VALUE_FOR_FUNC_INDEX = 3903;
exports.ER_JSON_VALUE_OUT_OF_RANGE_FOR_FUNC_INDEX = 3904;
exports.ER_EXCEEDED_MV_KEYS_NUM = 3905;
exports.ER_EXCEEDED_MV_KEYS_SPACE = 3906;
exports.ER_FUNCTIONAL_INDEX_DATA_IS_TOO_LONG = 3907;
exports.ER_WRONG_MVI_VALUE = 3908;
exports.ER_WARN_FUNC_INDEX_NOT_APPLICABLE = 3909;
exports.ER_GRP_RPL_UDF_ERROR = 3910;
exports.ER_UPDATE_GTID_PURGED_WITH_GR = 3911;
exports.ER_GROUPING_ON_TIMESTAMP_IN_DST = 3912;
exports.ER_TABLE_NAME_CAUSES_TOO_LONG_PATH = 3913;
exports.ER_AUDIT_LOG_INSUFFICIENT_PRIVILEGE = 3914;
exports.ER_AUDIT_LOG_PASSWORD_HAS_BEEN_COPIED = 3915;
exports.ER_DA_GRP_RPL_STARTED_AUTO_REJOIN = 3916;
exports.ER_SYSVAR_CHANGE_DURING_QUERY = 3917;
exports.ER_GLOBSTAT_CHANGE_DURING_QUERY = 3918;
exports.ER_GRP_RPL_MESSAGE_SERVICE_INIT_FAILURE = 3919;
exports.ER_CHANGE_SOURCE_WRONG_COMPRESSION_ALGORITHM_CLIENT = 3920;
exports.ER_CHANGE_SOURCE_WRONG_COMPRESSION_LEVEL_CLIENT = 3921;
exports.ER_WRONG_COMPRESSION_ALGORITHM_CLIENT = 3922;
exports.ER_WRONG_COMPRESSION_LEVEL_CLIENT = 3923;
exports.ER_CHANGE_SOURCE_WRONG_COMPRESSION_ALGORITHM_LIST_CLIENT = 3924;
exports.ER_CLIENT_PRIVILEGE_CHECKS_USER_CANNOT_BE_ANONYMOUS = 3925;
exports.ER_CLIENT_PRIVILEGE_CHECKS_USER_DOES_NOT_EXIST = 3926;
exports.ER_CLIENT_PRIVILEGE_CHECKS_USER_CORRUPT = 3927;
exports.ER_CLIENT_PRIVILEGE_CHECKS_USER_NEEDS_RPL_APPLIER_PRIV = 3928;
exports.ER_WARN_DA_PRIVILEGE_NOT_REGISTERED = 3929;
exports.ER_CLIENT_KEYRING_UDF_KEY_INVALID = 3930;
exports.ER_CLIENT_KEYRING_UDF_KEY_TYPE_INVALID = 3931;
exports.ER_CLIENT_KEYRING_UDF_KEY_TOO_LONG = 3932;
exports.ER_CLIENT_KEYRING_UDF_KEY_TYPE_TOO_LONG = 3933;
exports.ER_JSON_SCHEMA_VALIDATION_ERROR_WITH_DETAILED_REPORT = 3934;
exports.ER_DA_UDF_INVALID_CHARSET_SPECIFIED = 3935;
exports.ER_DA_UDF_INVALID_CHARSET = 3936;
exports.ER_DA_UDF_INVALID_COLLATION = 3937;
exports.ER_DA_UDF_INVALID_EXTENSION_ARGUMENT_TYPE = 3938;
exports.ER_MULTIPLE_CONSTRAINTS_WITH_SAME_NAME = 3939;
exports.ER_CONSTRAINT_NOT_FOUND = 3940;
exports.ER_ALTER_CONSTRAINT_ENFORCEMENT_NOT_SUPPORTED = 3941;
exports.ER_TABLE_VALUE_CONSTRUCTOR_MUST_HAVE_COLUMNS = 3942;
exports.ER_TABLE_VALUE_CONSTRUCTOR_CANNOT_HAVE_DEFAULT = 3943;
exports.ER_CLIENT_QUERY_FAILURE_INVALID_NON_ROW_FORMAT = 3944;
exports.ER_REQUIRE_ROW_FORMAT_INVALID_VALUE = 3945;
exports.ER_FAILED_TO_DETERMINE_IF_ROLE_IS_MANDATORY = 3946;
exports.ER_FAILED_TO_FETCH_MANDATORY_ROLE_LIST = 3947;
exports.ER_CLIENT_LOCAL_FILES_DISABLED = 3948;
exports.ER_IMP_INCOMPATIBLE_CFG_VERSION = 3949;
exports.ER_DA_OOM = 3950;
exports.ER_DA_UDF_INVALID_ARGUMENT_TO_SET_CHARSET = 3951;
exports.ER_DA_UDF_INVALID_RETURN_TYPE_TO_SET_CHARSET = 3952;
exports.ER_MULTIPLE_INTO_CLAUSES = 3953;
exports.ER_MISPLACED_INTO = 3954;
exports.ER_USER_ACCESS_DENIED_FOR_USER_ACCOUNT_BLOCKED_BY_PASSWORD_LOCK = 3955;
exports.ER_WARN_DEPRECATED_YEAR_UNSIGNED = 3956;
exports.ER_CLONE_NETWORK_PACKET = 3957;
exports.ER_SDI_OPERATION_FAILED_MISSING_RECORD = 3958;
exports.ER_DEPENDENT_BY_CHECK_CONSTRAINT = 3959;
exports.ER_GRP_OPERATION_NOT_ALLOWED_GR_MUST_STOP = 3960;
exports.ER_WARN_DEPRECATED_JSON_TABLE_ON_ERROR_ON_EMPTY = 3961;
exports.ER_WARN_DEPRECATED_INNER_INTO = 3962;
exports.ER_WARN_DEPRECATED_VALUES_FUNCTION_ALWAYS_NULL = 3963;
exports.ER_WARN_DEPRECATED_SQL_CALC_FOUND_ROWS = 3964;
exports.ER_WARN_DEPRECATED_FOUND_ROWS = 3965;
exports.ER_MISSING_JSON_VALUE = 3966;
exports.ER_MULTIPLE_JSON_VALUES = 3967;
exports.ER_HOSTNAME_TOO_LONG = 3968;
exports.ER_WARN_CLIENT_DEPRECATED_PARTITION_PREFIX_KEY = 3969;
exports.ER_GROUP_REPLICATION_USER_EMPTY_MSG = 3970;
exports.ER_GROUP_REPLICATION_USER_MANDATORY_MSG = 3971;
exports.ER_GROUP_REPLICATION_PASSWORD_LENGTH = 3972;
exports.ER_SUBQUERY_TRANSFORM_REJECTED = 3973;
exports.ER_DA_GRP_RPL_RECOVERY_ENDPOINT_FORMAT = 3974;
exports.ER_DA_GRP_RPL_RECOVERY_ENDPOINT_INVALID = 3975;
exports.ER_WRONG_VALUE_FOR_VAR_PLUS_ACTIONABLE_PART = 3976;
exports.ER_STATEMENT_NOT_ALLOWED_AFTER_START_TRANSACTION = 3977;
exports.ER_FOREIGN_KEY_WITH_ATOMIC_CREATE_SELECT = 3978;
exports.ER_NOT_ALLOWED_WITH_START_TRANSACTION = 3979;
exports.ER_INVALID_JSON_ATTRIBUTE = 3980;
exports.ER_ENGINE_ATTRIBUTE_NOT_SUPPORTED = 3981;
exports.ER_INVALID_USER_ATTRIBUTE_JSON = 3982;
exports.ER_INNODB_REDO_DISABLED = 3983;
exports.ER_INNODB_REDO_ARCHIVING_ENABLED = 3984;
exports.ER_MDL_OUT_OF_RESOURCES = 3985;
exports.ER_IMPLICIT_COMPARISON_FOR_JSON = 3986;
exports.ER_FUNCTION_DOES_NOT_SUPPORT_CHARACTER_SET = 3987;
exports.ER_IMPOSSIBLE_STRING_CONVERSION = 3988;
exports.ER_SCHEMA_READ_ONLY = 3989;
exports.ER_RPL_ASYNC_RECONNECT_GTID_MODE_OFF = 3990;
exports.ER_RPL_ASYNC_RECONNECT_AUTO_POSITION_OFF = 3991;
exports.ER_DISABLE_GTID_MODE_REQUIRES_ASYNC_RECONNECT_OFF = 3992;
exports.ER_DISABLE_AUTO_POSITION_REQUIRES_ASYNC_RECONNECT_OFF = 3993;
exports.ER_INVALID_PARAMETER_USE = 3994;
exports.ER_CHARACTER_SET_MISMATCH = 3995;
exports.ER_WARN_VAR_VALUE_CHANGE_NOT_SUPPORTED = 3996;
exports.ER_INVALID_TIME_ZONE_INTERVAL = 3997;
exports.ER_INVALID_CAST = 3998;
exports.ER_HYPERGRAPH_NOT_SUPPORTED_YET = 3999;
exports.ER_WARN_HYPERGRAPH_EXPERIMENTAL = 4000;
exports.ER_DA_NO_ERROR_LOG_PARSER_CONFIGURED = 4001;
exports.ER_DA_ERROR_LOG_TABLE_DISABLED = 4002;
exports.ER_DA_ERROR_LOG_MULTIPLE_FILTERS = 4003;
exports.ER_DA_CANT_OPEN_ERROR_LOG = 4004;
exports.ER_USER_REFERENCED_AS_DEFINER = 4005;
exports.ER_CANNOT_USER_REFERENCED_AS_DEFINER = 4006;
exports.ER_REGEX_NUMBER_TOO_BIG = 4007;
exports.ER_SPVAR_NONINTEGER_TYPE = 4008;
exports.WARN_UNSUPPORTED_ACL_TABLES_READ = 4009;
exports.ER_BINLOG_UNSAFE_ACL_TABLE_READ_IN_DML_DDL = 4010;
exports.ER_STOP_REPLICA_MONITOR_IO_THREAD_TIMEOUT = 4011;
exports.ER_STARTING_REPLICA_MONITOR_IO_THREAD = 4012;
exports.ER_CANT_USE_ANONYMOUS_TO_GTID_WITH_GTID_MODE_NOT_ON = 4013;
exports.ER_CANT_COMBINE_ANONYMOUS_TO_GTID_AND_AUTOPOSITION = 4014;
exports.ER_ASSIGN_GTIDS_TO_ANONYMOUS_TRANSACTIONS_REQUIRES_GTID_MODE_ON = 4015;
exports.ER_SQL_REPLICA_SKIP_COUNTER_USED_WITH_GTID_MODE_ON = 4016;
exports.ER_USING_ASSIGN_GTIDS_TO_ANONYMOUS_TRANSACTIONS_AS_LOCAL_OR_UUID = 4017;
exports.ER_CANT_SET_ANONYMOUS_TO_GTID_AND_WAIT_UNTIL_SQL_THD_AFTER_GTIDS = 4018;
exports.ER_CANT_SET_SQL_AFTER_OR_BEFORE_GTIDS_WITH_ANONYMOUS_TO_GTID = 4019;
exports.ER_ANONYMOUS_TO_GTID_UUID_SAME_AS_GROUP_NAME = 4020;
exports.ER_CANT_USE_SAME_UUID_AS_GROUP_NAME = 4021;
exports.ER_GRP_RPL_RECOVERY_CHANNEL_STILL_RUNNING = 4022;
exports.ER_INNODB_INVALID_AUTOEXTEND_SIZE_VALUE = 4023;
exports.ER_INNODB_INCOMPATIBLE_WITH_TABLESPACE = 4024;
exports.ER_INNODB_AUTOEXTEND_SIZE_OUT_OF_RANGE = 4025;
exports.ER_CANNOT_USE_AUTOEXTEND_SIZE_CLAUSE = 4026;
exports.ER_ROLE_GRANTED_TO_ITSELF = 4027;
exports.ER_TABLE_MUST_HAVE_A_VISIBLE_COLUMN = 4028;
exports.ER_INNODB_COMPRESSION_FAILURE = 4029;
exports.ER_WARN_ASYNC_CONN_FAILOVER_NETWORK_NAMESPACE = 4030;
exports.ER_CLIENT_INTERACTION_TIMEOUT = 4031;
exports.ER_INVALID_CAST_TO_GEOMETRY = 4032;
exports.ER_INVALID_CAST_POLYGON_RING_DIRECTION = 4033;
exports.ER_GIS_DIFFERENT_SRIDS_AGGREGATION = 4034;
exports.ER_RELOAD_KEYRING_FAILURE = 4035;
exports.ER_SDI_GET_KEYS_INVALID_TABLESPACE = 4036;
exports.ER_CHANGE_RPL_SRC_WRONG_COMPRESSION_ALGORITHM_SIZE = 4037;
exports.ER_WARN_DEPRECATED_TLS_VERSION_FOR_CHANNEL_CLI = 4038;
exports.ER_CANT_USE_SAME_UUID_AS_VIEW_CHANGE_UUID = 4039;
exports.ER_ANONYMOUS_TO_GTID_UUID_SAME_AS_VIEW_CHANGE_UUID = 4040;
exports.ER_GRP_RPL_VIEW_CHANGE_UUID_FAIL_GET_VARIABLE = 4041;
exports.ER_WARN_ADUIT_LOG_MAX_SIZE_AND_PRUNE_SECONDS = 4042;
exports.ER_WARN_ADUIT_LOG_MAX_SIZE_CLOSE_TO_ROTATE_ON_SIZE = 4043;
exports.ER_KERBEROS_CREATE_USER = 4044;
exports.ER_INSTALL_PLUGIN_CONFLICT_CLIENT = 4045;
exports.ER_DA_ERROR_LOG_COMPONENT_FLUSH_FAILED = 4046;
exports.ER_WARN_SQL_AFTER_MTS_GAPS_GAP_NOT_CALCULATED = 4047;
exports.ER_INVALID_ASSIGNMENT_TARGET = 4048;
exports.ER_OPERATION_NOT_ALLOWED_ON_GR_SECONDARY = 4049;
exports.ER_GRP_RPL_FAILOVER_CHANNEL_STATUS_PROPAGATION = 4050;
exports.ER_WARN_AUDIT_LOG_FORMAT_UNIX_TIMESTAMP_ONLY_WHEN_JSON = 4051;
exports.ER_INVALID_MFA_PLUGIN_SPECIFIED = 4052;
exports.ER_IDENTIFIED_BY_UNSUPPORTED = 4053;
exports.ER_INVALID_PLUGIN_FOR_REGISTRATION = 4054;
exports.ER_PLUGIN_REQUIRES_REGISTRATION = 4055;
exports.ER_MFA_METHOD_EXISTS = 4056;
exports.ER_MFA_METHOD_NOT_EXISTS = 4057;
exports.ER_AUTHENTICATION_POLICY_MISMATCH = 4058;
exports.ER_PLUGIN_REGISTRATION_DONE = 4059;
exports.ER_INVALID_USER_FOR_REGISTRATION = 4060;
exports.ER_USER_REGISTRATION_FAILED = 4061;
exports.ER_MFA_METHODS_INVALID_ORDER = 4062;
exports.ER_MFA_METHODS_IDENTICAL = 4063;
exports.ER_INVALID_MFA_OPERATIONS_FOR_PASSWORDLESS_USER = 4064;
exports.ER_CHANGE_REPLICATION_SOURCE_NO_OPTIONS_FOR_GTID_ONLY = 4065;
exports.ER_CHANGE_REP_SOURCE_CANT_DISABLE_REQ_ROW_FORMAT_WITH_GTID_ONLY = 4066;
exports.ER_CHANGE_REP_SOURCE_CANT_DISABLE_AUTO_POSITION_WITH_GTID_ONLY = 4067;
exports.ER_CHANGE_REP_SOURCE_CANT_DISABLE_GTID_ONLY_WITHOUT_POSITIONS = 4068;
exports.ER_CHANGE_REP_SOURCE_CANT_DISABLE_AUTO_POS_WITHOUT_POSITIONS = 4069;
exports.ER_CHANGE_REP_SOURCE_GR_CHANNEL_WITH_GTID_MODE_NOT_ON = 4070;
exports.ER_CANT_USE_GTID_ONLY_WITH_GTID_MODE_NOT_ON = 4071;
exports.ER_WARN_C_DISABLE_GTID_ONLY_WITH_SOURCE_AUTO_POS_INVALID_POS = 4072;
exports.ER_DA_SSL_FIPS_MODE_ERROR = 4073;
exports.ER_VALUE_OUT_OF_RANGE = 4074;
exports.ER_FULLTEXT_WITH_ROLLUP = 4075;
exports.ER_REGEXP_MISSING_RESOURCE = 4076;
exports.ER_WARN_REGEXP_USING_DEFAULT = 4077;
exports.ER_REGEXP_MISSING_FILE = 4078;
exports.ER_WARN_DEPRECATED_COLLATION = 4079;
exports.ER_CONCURRENT_PROCEDURE_USAGE = 4080;
exports.ER_DA_GLOBAL_CONN_LIMIT = 4081;
exports.ER_DA_CONN_LIMIT = 4082;
exports.ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_COLUMN_TYPE_INSTANT = 4083;
exports.ER_WARN_SF_UDF_NAME_COLLISION = 4084;
exports.ER_CANNOT_PURGE_BINLOG_WITH_BACKUP_LOCK = 4085;
exports.ER_TOO_MANY_WINDOWS = 4086;
exports.ER_MYSQLBACKUP_CLIENT_MSG = 4087;
exports.ER_COMMENT_CONTAINS_INVALID_STRING = 4088;
exports.ER_DEFINITION_CONTAINS_INVALID_STRING = 4089;
exports.ER_CANT_EXECUTE_COMMAND_WITH_ASSIGNED_GTID_NEXT = 4090;
exports.ER_XA_TEMP_TABLE = 4091;
exports.ER_INNODB_MAX_ROW_VERSION = 4092;
exports.ER_INNODB_INSTANT_ADD_NOT_SUPPORTED_MAX_SIZE = 4093;
exports.ER_OPERATION_NOT_ALLOWED_WHILE_PRIMARY_CHANGE_IS_RUNNING = 4094;
exports.ER_WARN_DEPRECATED_DATETIME_DELIMITER = 4095;
exports.ER_WARN_DEPRECATED_SUPERFLUOUS_DELIMITER = 4096;
exports.ER_CANNOT_PERSIST_SENSITIVE_VARIABLES = 4097;
exports.ER_WARN_CANNOT_SECURELY_PERSIST_SENSITIVE_VARIABLES = 4098;
exports.ER_WARN_TRG_ALREADY_EXISTS = 4099;
exports.ER_IF_NOT_EXISTS_UNSUPPORTED_TRG_EXISTS_ON_DIFFERENT_TABLE = 4100;
exports.ER_IF_NOT_EXISTS_UNSUPPORTED_UDF_NATIVE_FCT_NAME_COLLISION = 4101;
exports.ER_SET_PASSWORD_AUTH_PLUGIN_ERROR = 4102;
exports.ER_REDUCED_DBLWR_FILE_CORRUPTED = 4103;
exports.ER_REDUCED_DBLWR_PAGE_FOUND = 4104;
exports.ER_SRS_INVALID_LATITUDE_OF_ORIGIN = 4105;
exports.ER_SRS_INVALID_LONGITUDE_OF_ORIGIN = 4106;
exports.ER_SRS_UNUSED_PROJ_PARAMETER_PRESENT = 4107;
exports.ER_GIPK_COLUMN_EXISTS = 4108;
exports.ER_GIPK_FAILED_AUTOINC_COLUMN_EXISTS = 4109;
exports.ER_GIPK_COLUMN_ALTER_NOT_ALLOWED = 4110;
exports.ER_DROP_PK_COLUMN_TO_DROP_GIPK = 4111;
exports.ER_CREATE_SELECT_WITH_GIPK_DISALLOWED_IN_SBR = 4112;
exports.ER_DA_EXPIRE_LOGS_DAYS_IGNORED = 4113;
exports.ER_CTE_RECURSIVE_NOT_UNION = 4114;
exports.ER_COMMAND_BACKEND_FAILED_TO_FETCH_SECURITY_CTX = 4115;
exports.ER_COMMAND_SERVICE_BACKEND_FAILED = 4116;
exports.ER_CLIENT_FILE_PRIVILEGE_FOR_REPLICATION_CHECKS = 4117;
exports.ER_GROUP_REPLICATION_FORCE_MEMBERS_COMMAND_FAILURE = 4118;
exports.ER_WARN_DEPRECATED_IDENT = 4119;
exports.ER_INTERSECT_ALL_MAX_DUPLICATES_EXCEEDED = 4120;
exports.ER_TP_QUERY_THRS_PER_GRP_EXCEEDS_TXN_THR_LIMIT = 4121;
exports.ER_BAD_TIMESTAMP_FORMAT = 4122;
exports.ER_SHAPE_PRIDICTION_UDF = 4123;
exports.ER_SRS_INVALID_HEIGHT = 4124;
exports.ER_SRS_INVALID_SCALING = 4125;
exports.ER_SRS_INVALID_ZONE_WIDTH = 4126;
exports.ER_SRS_INVALID_LATITUDE_POLAR_STERE_VAR_A = 4127;
exports.ER_WARN_DEPRECATED_CLIENT_NO_SCHEMA_OPTION = 4128;
exports.ER_TABLE_NOT_EMPTY = 4129;
exports.ER_TABLE_NO_PRIMARY_KEY = 4130;
exports.ER_TABLE_IN_SHARED_TABLESPACE = 4131;
exports.ER_INDEX_OTHER_THAN_PK = 4132;
exports.ER_LOAD_BULK_DATA_UNSORTED = 4133;
exports.ER_BULK_EXECUTOR_ERROR = 4134;
exports.ER_BULK_READER_LIBCURL_INIT_FAILED = 4135;
exports.ER_BULK_READER_LIBCURL_ERROR = 4136;
exports.ER_BULK_READER_SERVER_ERROR = 4137;
exports.ER_BULK_READER_COMMUNICATION_ERROR = 4138;
exports.ER_BULK_LOAD_DATA_FAILED = 4139;
exports.ER_BULK_LOADER_COLUMN_TOO_BIG_FOR_LEFTOVER_BUFFER = 4140;
exports.ER_BULK_LOADER_COMPONENT_ERROR = 4141;
exports.ER_BULK_LOADER_FILE_CONTAINS_LESS_LINES_THAN_IGNORE_CLAUSE = 4142;
exports.ER_BULK_PARSER_MISSING_ENCLOSED_BY = 4143;
exports.ER_BULK_PARSER_ROW_BUFFER_MAX_TOTAL_COLS_EXCEEDED = 4144;
exports.ER_BULK_PARSER_COPY_BUFFER_SIZE_EXCEEDED = 4145;
exports.ER_BULK_PARSER_UNEXPECTED_END_OF_INPUT = 4146;
exports.ER_BULK_PARSER_UNEXPECTED_ROW_TERMINATOR = 4147;
exports.ER_BULK_PARSER_UNEXPECTED_CHAR_AFTER_ENDING_ENCLOSED_BY = 4148;
exports.ER_BULK_PARSER_UNEXPECTED_CHAR_AFTER_NULL_ESCAPE = 4149;
exports.ER_BULK_PARSER_UNEXPECTED_CHAR_AFTER_COLUMN_TERMINATOR = 4150;
exports.ER_BULK_PARSER_INCOMPLETE_ESCAPE_SEQUENCE = 4151;
exports.ER_LOAD_BULK_DATA_FAILED = 4152;
exports.ER_LOAD_BULK_DATA_WRONG_VALUE_FOR_FIELD = 4153;
exports.ER_LOAD_BULK_DATA_WARN_NULL_TO_NOTNULL = 4154;
exports.ER_REQUIRE_TABLE_PRIMARY_KEY_CHECK_GENERATE_WITH_GR = 4155;
exports.ER_CANT_CHANGE_SYS_VAR_IN_READ_ONLY_MODE = 4156;
exports.ER_INNODB_INSTANT_ADD_DROP_NOT_SUPPORTED_MAX_SIZE = 4157;
exports.ER_INNODB_INSTANT_ADD_NOT_SUPPORTED_MAX_FIELDS = 4158;
exports.ER_CANT_SET_PERSISTED = 4159;
exports.ER_INSTALL_COMPONENT_SET_NULL_VALUE = 4160;
exports.ER_INSTALL_COMPONENT_SET_UNUSED_VALUE = 4161;
exports.ER_WARN_DEPRECATED_USER_DEFINED_COLLATIONS = 4162;

// Lookup-by-number table
exports[1] = 'EE_CANTCREATEFILE';
exports[2] = 'EE_READ';
exports[3] = 'EE_WRITE';
exports[4] = 'EE_BADCLOSE';
exports[5] = 'EE_OUTOFMEMORY';
exports[6] = 'EE_DELETE';
exports[7] = 'EE_LINK';
exports[9] = 'EE_EOFERR';
exports[10] = 'EE_CANTLOCK';
exports[11] = 'EE_CANTUNLOCK';
exports[12] = 'EE_DIR';
exports[13] = 'EE_STAT';
exports[14] = 'EE_CANT_CHSIZE';
exports[15] = 'EE_CANT_OPEN_STREAM';
exports[16] = 'EE_GETWD';
exports[17] = 'EE_SETWD';
exports[18] = 'EE_LINK_WARNING';
exports[19] = 'EE_OPEN_WARNING';
exports[20] = 'EE_DISK_FULL';
exports[21] = 'EE_CANT_MKDIR';
exports[22] = 'EE_UNKNOWN_CHARSET';
exports[23] = 'EE_OUT_OF_FILERESOURCES';
exports[24] = 'EE_CANT_READLINK';
exports[25] = 'EE_CANT_SYMLINK';
exports[26] = 'EE_REALPATH';
exports[27] = 'EE_SYNC';
exports[28] = 'EE_UNKNOWN_COLLATION';
exports[29] = 'EE_FILENOTFOUND';
exports[30] = 'EE_FILE_NOT_CLOSED';
exports[31] = 'EE_CHANGE_OWNERSHIP';
exports[32] = 'EE_CHANGE_PERMISSIONS';
exports[33] = 'EE_CANT_SEEK';
exports[34] = 'EE_CAPACITY_EXCEEDED';
exports[35] = 'EE_DISK_FULL_WITH_RETRY_MSG';
exports[36] = 'EE_FAILED_TO_CREATE_TIMER';
exports[37] = 'EE_FAILED_TO_DELETE_TIMER';
exports[38] = 'EE_FAILED_TO_CREATE_TIMER_QUEUE';
exports[39] = 'EE_FAILED_TO_START_TIMER_NOTIFY_THREAD';
exports[40] = 'EE_FAILED_TO_CREATE_TIMER_NOTIFY_THREAD_INTERRUPT_EVENT';
exports[41] = 'EE_EXITING_TIMER_NOTIFY_THREAD';
exports[42] = 'EE_WIN_LIBRARY_LOAD_FAILED';
exports[43] = 'EE_WIN_RUN_TIME_ERROR_CHECK';
exports[44] = 'EE_FAILED_TO_DETERMINE_LARGE_PAGE_SIZE';
exports[45] = 'EE_FAILED_TO_KILL_ALL_THREADS';
exports[46] = 'EE_FAILED_TO_CREATE_IO_COMPLETION_PORT';
exports[47] = 'EE_FAILED_TO_OPEN_DEFAULTS_FILE';
exports[48] = 'EE_FAILED_TO_HANDLE_DEFAULTS_FILE';
exports[49] = 'EE_WRONG_DIRECTIVE_IN_CONFIG_FILE';
exports[50] = 'EE_SKIPPING_DIRECTIVE_DUE_TO_MAX_INCLUDE_RECURSION';
exports[51] = 'EE_INCORRECT_GRP_DEFINITION_IN_CONFIG_FILE';
exports[52] = 'EE_OPTION_WITHOUT_GRP_IN_CONFIG_FILE';
exports[53] = 'EE_CONFIG_FILE_PERMISSION_ERROR';
exports[54] = 'EE_IGNORE_WORLD_WRITABLE_CONFIG_FILE';
exports[55] = 'EE_USING_DISABLED_OPTION';
exports[56] = 'EE_USING_DISABLED_SHORT_OPTION';
exports[57] = 'EE_USING_PASSWORD_ON_CLI_IS_INSECURE';
exports[58] = 'EE_UNKNOWN_SUFFIX_FOR_VARIABLE';
exports[59] = 'EE_SSL_ERROR_FROM_FILE';
exports[60] = 'EE_SSL_ERROR';
exports[61] = 'EE_NET_SEND_ERROR_IN_BOOTSTRAP';
exports[62] = 'EE_PACKETS_OUT_OF_ORDER';
exports[63] = 'EE_UNKNOWN_PROTOCOL_OPTION';
exports[64] = 'EE_FAILED_TO_LOCATE_SERVER_PUBLIC_KEY';
exports[65] = 'EE_PUBLIC_KEY_NOT_IN_PEM_FORMAT';
exports[66] = 'EE_DEBUG_INFO';
exports[67] = 'EE_UNKNOWN_VARIABLE';
exports[68] = 'EE_UNKNOWN_OPTION';
exports[69] = 'EE_UNKNOWN_SHORT_OPTION';
exports[70] = 'EE_OPTION_WITHOUT_ARGUMENT';
exports[71] = 'EE_OPTION_REQUIRES_ARGUMENT';
exports[72] = 'EE_SHORT_OPTION_REQUIRES_ARGUMENT';
exports[73] = 'EE_OPTION_IGNORED_DUE_TO_INVALID_VALUE';
exports[74] = 'EE_OPTION_WITH_EMPTY_VALUE';
exports[75] = 'EE_FAILED_TO_ASSIGN_MAX_VALUE_TO_OPTION';
exports[76] = 'EE_INCORRECT_BOOLEAN_VALUE_FOR_OPTION';
exports[77] = 'EE_FAILED_TO_SET_OPTION_VALUE';
exports[78] = 'EE_INCORRECT_INT_VALUE_FOR_OPTION';
exports[79] = 'EE_INCORRECT_UINT_VALUE_FOR_OPTION';
exports[80] = 'EE_ADJUSTED_SIGNED_VALUE_FOR_OPTION';
exports[81] = 'EE_ADJUSTED_UNSIGNED_VALUE_FOR_OPTION';
exports[82] = 'EE_ADJUSTED_ULONGLONG_VALUE_FOR_OPTION';
exports[83] = 'EE_ADJUSTED_DOUBLE_VALUE_FOR_OPTION';
exports[84] = 'EE_INVALID_DECIMAL_VALUE_FOR_OPTION';
exports[85] = 'EE_COLLATION_PARSER_ERROR';
exports[86] = 'EE_FAILED_TO_RESET_BEFORE_PRIMARY_IGNORABLE_CHAR';
exports[87] = 'EE_FAILED_TO_RESET_BEFORE_TERTIARY_IGNORABLE_CHAR';
exports[88] = 'EE_SHIFT_CHAR_OUT_OF_RANGE';
exports[89] = 'EE_RESET_CHAR_OUT_OF_RANGE';
exports[90] = 'EE_UNKNOWN_LDML_TAG';
exports[91] = 'EE_FAILED_TO_RESET_BEFORE_SECONDARY_IGNORABLE_CHAR';
exports[92] = 'EE_FAILED_PROCESSING_DIRECTIVE';
exports[93] = 'EE_PTHREAD_KILL_FAILED';
exports[120] = 'HA_ERR_KEY_NOT_FOUND';
exports[121] = 'HA_ERR_FOUND_DUPP_KEY';
exports[122] = 'HA_ERR_INTERNAL_ERROR';
exports[123] = 'HA_ERR_RECORD_CHANGED';
exports[124] = 'HA_ERR_WRONG_INDEX';
exports[125] = 'HA_ERR_ROLLED_BACK';
exports[126] = 'HA_ERR_CRASHED';
exports[127] = 'HA_ERR_WRONG_IN_RECORD';
exports[128] = 'HA_ERR_OUT_OF_MEM';
exports[130] = 'HA_ERR_NOT_A_TABLE';
exports[131] = 'HA_ERR_WRONG_COMMAND';
exports[132] = 'HA_ERR_OLD_FILE';
exports[133] = 'HA_ERR_NO_ACTIVE_RECORD';
exports[134] = 'HA_ERR_RECORD_DELETED';
exports[135] = 'HA_ERR_RECORD_FILE_FULL';
exports[136] = 'HA_ERR_INDEX_FILE_FULL';
exports[137] = 'HA_ERR_END_OF_FILE';
exports[138] = 'HA_ERR_UNSUPPORTED';
exports[139] = 'HA_ERR_TOO_BIG_ROW';
exports[140] = 'HA_WRONG_CREATE_OPTION';
exports[141] = 'HA_ERR_FOUND_DUPP_UNIQUE';
exports[142] = 'HA_ERR_UNKNOWN_CHARSET';
exports[143] = 'HA_ERR_WRONG_MRG_TABLE_DEF';
exports[144] = 'HA_ERR_CRASHED_ON_REPAIR';
exports[145] = 'HA_ERR_CRASHED_ON_USAGE';
exports[146] = 'HA_ERR_LOCK_WAIT_TIMEOUT';
exports[147] = 'HA_ERR_LOCK_TABLE_FULL';
exports[148] = 'HA_ERR_READ_ONLY_TRANSACTION';
exports[149] = 'HA_ERR_LOCK_DEADLOCK';
exports[150] = 'HA_ERR_CANNOT_ADD_FOREIGN';
exports[151] = 'HA_ERR_NO_REFERENCED_ROW';
exports[152] = 'HA_ERR_ROW_IS_REFERENCED';
exports[153] = 'HA_ERR_NO_SAVEPOINT';
exports[154] = 'HA_ERR_NON_UNIQUE_BLOCK_SIZE';
exports[155] = 'HA_ERR_NO_SUCH_TABLE';
exports[156] = 'HA_ERR_TABLE_EXIST';
exports[157] = 'HA_ERR_NO_CONNECTION';
exports[158] = 'HA_ERR_NULL_IN_SPATIAL';
exports[159] = 'HA_ERR_TABLE_DEF_CHANGED';
exports[160] = 'HA_ERR_NO_PARTITION_FOUND';
exports[161] = 'HA_ERR_RBR_LOGGING_FAILED';
exports[162] = 'HA_ERR_DROP_INDEX_FK';
exports[163] = 'HA_ERR_FOREIGN_DUPLICATE_KEY';
exports[164] = 'HA_ERR_TABLE_NEEDS_UPGRADE';
exports[165] = 'HA_ERR_TABLE_READONLY';
exports[166] = 'HA_ERR_AUTOINC_READ_FAILED';
exports[167] = 'HA_ERR_AUTOINC_ERANGE';
exports[168] = 'HA_ERR_GENERIC';
exports[169] = 'HA_ERR_RECORD_IS_THE_SAME';
exports[170] = 'HA_ERR_LOGGING_IMPOSSIBLE';
exports[171] = 'HA_ERR_CORRUPT_EVENT';
exports[172] = 'HA_ERR_NEW_FILE';
exports[173] = 'HA_ERR_ROWS_EVENT_APPLY';
exports[174] = 'HA_ERR_INITIALIZATION';
exports[175] = 'HA_ERR_FILE_TOO_SHORT';
exports[176] = 'HA_ERR_WRONG_CRC';
exports[177] = 'HA_ERR_TOO_MANY_CONCURRENT_TRXS';
exports[178] = 'HA_ERR_NOT_IN_LOCK_PARTITIONS';
exports[179] = 'HA_ERR_INDEX_COL_TOO_LONG';
exports[180] = 'HA_ERR_INDEX_CORRUPT';
exports[181] = 'HA_ERR_UNDO_REC_TOO_BIG';
exports[182] = 'HA_FTS_INVALID_DOCID';
exports[183] = 'HA_ERR_TABLE_IN_FK_CHECK';
exports[184] = 'HA_ERR_TABLESPACE_EXISTS';
exports[185] = 'HA_ERR_TOO_MANY_FIELDS';
exports[186] = 'HA_ERR_ROW_IN_WRONG_PARTITION';
exports[187] = 'HA_ERR_INNODB_READ_ONLY';
exports[188] = 'HA_ERR_FTS_EXCEED_RESULT_CACHE_LIMIT';
exports[189] = 'HA_ERR_TEMP_FILE_WRITE_FAILURE';
exports[190] = 'HA_ERR_INNODB_FORCED_RECOVERY';
exports[191] = 'HA_ERR_FTS_TOO_MANY_WORDS_IN_PHRASE';
exports[192] = 'HA_ERR_FK_DEPTH_EXCEEDED';
exports[193] = 'HA_MISSING_CREATE_OPTION';
exports[194] = 'HA_ERR_SE_OUT_OF_MEMORY';
exports[195] = 'HA_ERR_TABLE_CORRUPT';
exports[196] = 'HA_ERR_QUERY_INTERRUPTED';
exports[197] = 'HA_ERR_TABLESPACE_MISSING';
exports[198] = 'HA_ERR_TABLESPACE_IS_NOT_EMPTY';
exports[199] = 'HA_ERR_WRONG_FILE_NAME';
exports[200] = 'HA_ERR_NOT_ALLOWED_COMMAND';
exports[201] = 'HA_ERR_COMPUTE_FAILED';
exports[202] = 'HA_ERR_ROW_FORMAT_CHANGED';
exports[203] = 'HA_ERR_NO_WAIT_LOCK';
exports[204] = 'HA_ERR_DISK_FULL_NOWAIT';
exports[205] = 'HA_ERR_NO_SESSION_TEMP';
exports[206] = 'HA_ERR_WRONG_TABLE_NAME';
exports[207] = 'HA_ERR_TOO_LONG_PATH';
exports[208] = 'HA_ERR_SAMPLING_INIT_FAILED';
exports[209] = 'HA_ERR_FTS_TOO_MANY_NESTED_EXP';
exports[1000] = 'ER_HASHCHK';
exports[1001] = 'ER_NISAMCHK';
exports[1002] = 'ER_NO';
exports[1003] = 'ER_YES';
exports[1004] = 'ER_CANT_CREATE_FILE';
exports[1005] = 'ER_CANT_CREATE_TABLE';
exports[1006] = 'ER_CANT_CREATE_DB';
exports[1007] = 'ER_DB_CREATE_EXISTS';
exports[1008] = 'ER_DB_DROP_EXISTS';
exports[1009] = 'ER_DB_DROP_DELETE';
exports[1010] = 'ER_DB_DROP_RMDIR';
exports[1011] = 'ER_CANT_DELETE_FILE';
exports[1012] = 'ER_CANT_FIND_SYSTEM_REC';
exports[1013] = 'ER_CANT_GET_STAT';
exports[1014] = 'ER_CANT_GET_WD';
exports[1015] = 'ER_CANT_LOCK';
exports[1016] = 'ER_CANT_OPEN_FILE';
exports[1017] = 'ER_FILE_NOT_FOUND';
exports[1018] = 'ER_CANT_READ_DIR';
exports[1019] = 'ER_CANT_SET_WD';
exports[1020] = 'ER_CHECKREAD';
exports[1021] = 'ER_DISK_FULL';
exports[1022] = 'ER_DUP_KEY';
exports[1023] = 'ER_ERROR_ON_CLOSE';
exports[1024] = 'ER_ERROR_ON_READ';
exports[1025] = 'ER_ERROR_ON_RENAME';
exports[1026] = 'ER_ERROR_ON_WRITE';
exports[1027] = 'ER_FILE_USED';
exports[1028] = 'ER_FILSORT_ABORT';
exports[1029] = 'ER_FORM_NOT_FOUND';
exports[1030] = 'ER_GET_ERRNO';
exports[1031] = 'ER_ILLEGAL_HA';
exports[1032] = 'ER_KEY_NOT_FOUND';
exports[1033] = 'ER_NOT_FORM_FILE';
exports[1034] = 'ER_NOT_KEYFILE';
exports[1035] = 'ER_OLD_KEYFILE';
exports[1036] = 'ER_OPEN_AS_READONLY';
exports[1037] = 'ER_OUTOFMEMORY';
exports[1038] = 'ER_OUT_OF_SORTMEMORY';
exports[1039] = 'ER_UNEXPECTED_EOF';
exports[1040] = 'ER_CON_COUNT_ERROR';
exports[1041] = 'ER_OUT_OF_RESOURCES';
exports[1042] = 'ER_BAD_HOST_ERROR';
exports[1043] = 'ER_HANDSHAKE_ERROR';
exports[1044] = 'ER_DBACCESS_DENIED_ERROR';
exports[1045] = 'ER_ACCESS_DENIED_ERROR';
exports[1046] = 'ER_NO_DB_ERROR';
exports[1047] = 'ER_UNKNOWN_COM_ERROR';
exports[1048] = 'ER_BAD_NULL_ERROR';
exports[1049] = 'ER_BAD_DB_ERROR';
exports[1050] = 'ER_TABLE_EXISTS_ERROR';
exports[1051] = 'ER_BAD_TABLE_ERROR';
exports[1052] = 'ER_NON_UNIQ_ERROR';
exports[1053] = 'ER_SERVER_SHUTDOWN';
exports[1054] = 'ER_BAD_FIELD_ERROR';
exports[1055] = 'ER_WRONG_FIELD_WITH_GROUP';
exports[1056] = 'ER_WRONG_GROUP_FIELD';
exports[1057] = 'ER_WRONG_SUM_SELECT';
exports[1058] = 'ER_WRONG_VALUE_COUNT';
exports[1059] = 'ER_TOO_LONG_IDENT';
exports[1060] = 'ER_DUP_FIELDNAME';
exports[1061] = 'ER_DUP_KEYNAME';
exports[1062] = 'ER_DUP_ENTRY';
exports[1063] = 'ER_WRONG_FIELD_SPEC';
exports[1064] = 'ER_PARSE_ERROR';
exports[1065] = 'ER_EMPTY_QUERY';
exports[1066] = 'ER_NONUNIQ_TABLE';
exports[1067] = 'ER_INVALID_DEFAULT';
exports[1068] = 'ER_MULTIPLE_PRI_KEY';
exports[1069] = 'ER_TOO_MANY_KEYS';
exports[1070] = 'ER_TOO_MANY_KEY_PARTS';
exports[1071] = 'ER_TOO_LONG_KEY';
exports[1072] = 'ER_KEY_COLUMN_DOES_NOT_EXITS';
exports[1073] = 'ER_BLOB_USED_AS_KEY';
exports[1074] = 'ER_TOO_BIG_FIELDLENGTH';
exports[1075] = 'ER_WRONG_AUTO_KEY';
exports[1076] = 'ER_READY';
exports[1077] = 'ER_NORMAL_SHUTDOWN';
exports[1078] = 'ER_GOT_SIGNAL';
exports[1079] = 'ER_SHUTDOWN_COMPLETE';
exports[1080] = 'ER_FORCING_CLOSE';
exports[1081] = 'ER_IPSOCK_ERROR';
exports[1082] = 'ER_NO_SUCH_INDEX';
exports[1083] = 'ER_WRONG_FIELD_TERMINATORS';
exports[1084] = 'ER_BLOBS_AND_NO_TERMINATED';
exports[1085] = 'ER_TEXTFILE_NOT_READABLE';
exports[1086] = 'ER_FILE_EXISTS_ERROR';
exports[1087] = 'ER_LOAD_INFO';
exports[1088] = 'ER_ALTER_INFO';
exports[1089] = 'ER_WRONG_SUB_KEY';
exports[1090] = 'ER_CANT_REMOVE_ALL_FIELDS';
exports[1091] = 'ER_CANT_DROP_FIELD_OR_KEY';
exports[1092] = 'ER_INSERT_INFO';
exports[1093] = 'ER_UPDATE_TABLE_USED';
exports[1094] = 'ER_NO_SUCH_THREAD';
exports[1095] = 'ER_KILL_DENIED_ERROR';
exports[1096] = 'ER_NO_TABLES_USED';
exports[1097] = 'ER_TOO_BIG_SET';
exports[1098] = 'ER_NO_UNIQUE_LOGFILE';
exports[1099] = 'ER_TABLE_NOT_LOCKED_FOR_WRITE';
exports[1100] = 'ER_TABLE_NOT_LOCKED';
exports[1101] = 'ER_BLOB_CANT_HAVE_DEFAULT';
exports[1102] = 'ER_WRONG_DB_NAME';
exports[1103] = 'ER_WRONG_TABLE_NAME';
exports[1104] = 'ER_TOO_BIG_SELECT';
exports[1105] = 'ER_UNKNOWN_ERROR';
exports[1106] = 'ER_UNKNOWN_PROCEDURE';
exports[1107] = 'ER_WRONG_PARAMCOUNT_TO_PROCEDURE';
exports[1108] = 'ER_WRONG_PARAMETERS_TO_PROCEDURE';
exports[1109] = 'ER_UNKNOWN_TABLE';
exports[1110] = 'ER_FIELD_SPECIFIED_TWICE';
exports[1111] = 'ER_INVALID_GROUP_FUNC_USE';
exports[1112] = 'ER_UNSUPPORTED_EXTENSION';
exports[1113] = 'ER_TABLE_MUST_HAVE_COLUMNS';
exports[1114] = 'ER_RECORD_FILE_FULL';
exports[1115] = 'ER_UNKNOWN_CHARACTER_SET';
exports[1116] = 'ER_TOO_MANY_TABLES';
exports[1117] = 'ER_TOO_MANY_FIELDS';
exports[1118] = 'ER_TOO_BIG_ROWSIZE';
exports[1119] = 'ER_STACK_OVERRUN';
exports[1120] = 'ER_WRONG_OUTER_JOIN';
exports[1121] = 'ER_NULL_COLUMN_IN_INDEX';
exports[1122] = 'ER_CANT_FIND_UDF';
exports[1123] = 'ER_CANT_INITIALIZE_UDF';
exports[1124] = 'ER_UDF_NO_PATHS';
exports[1125] = 'ER_UDF_EXISTS';
exports[1126] = 'ER_CANT_OPEN_LIBRARY';
exports[1127] = 'ER_CANT_FIND_DL_ENTRY';
exports[1128] = 'ER_FUNCTION_NOT_DEFINED';
exports[1129] = 'ER_HOST_IS_BLOCKED';
exports[1130] = 'ER_HOST_NOT_PRIVILEGED';
exports[1131] = 'ER_PASSWORD_ANONYMOUS_USER';
exports[1132] = 'ER_PASSWORD_NOT_ALLOWED';
exports[1133] = 'ER_PASSWORD_NO_MATCH';
exports[1134] = 'ER_UPDATE_INFO';
exports[1135] = 'ER_CANT_CREATE_THREAD';
exports[1136] = 'ER_WRONG_VALUE_COUNT_ON_ROW';
exports[1137] = 'ER_CANT_REOPEN_TABLE';
exports[1138] = 'ER_INVALID_USE_OF_NULL';
exports[1139] = 'ER_REGEXP_ERROR';
exports[1140] = 'ER_MIX_OF_GROUP_FUNC_AND_FIELDS';
exports[1141] = 'ER_NONEXISTING_GRANT';
exports[1142] = 'ER_TABLEACCESS_DENIED_ERROR';
exports[1143] = 'ER_COLUMNACCESS_DENIED_ERROR';
exports[1144] = 'ER_ILLEGAL_GRANT_FOR_TABLE';
exports[1145] = 'ER_GRANT_WRONG_HOST_OR_USER';
exports[1146] = 'ER_NO_SUCH_TABLE';
exports[1147] = 'ER_NONEXISTING_TABLE_GRANT';
exports[1148] = 'ER_NOT_ALLOWED_COMMAND';
exports[1149] = 'ER_SYNTAX_ERROR';
exports[1150] = 'ER_UNUSED1';
exports[1151] = 'ER_UNUSED2';
exports[1152] = 'ER_ABORTING_CONNECTION';
exports[1153] = 'ER_NET_PACKET_TOO_LARGE';
exports[1154] = 'ER_NET_READ_ERROR_FROM_PIPE';
exports[1155] = 'ER_NET_FCNTL_ERROR';
exports[1156] = 'ER_NET_PACKETS_OUT_OF_ORDER';
exports[1157] = 'ER_NET_UNCOMPRESS_ERROR';
exports[1158] = 'ER_NET_READ_ERROR';
exports[1159] = 'ER_NET_READ_INTERRUPTED';
exports[1160] = 'ER_NET_ERROR_ON_WRITE';
exports[1161] = 'ER_NET_WRITE_INTERRUPTED';
exports[1162] = 'ER_TOO_LONG_STRING';
exports[1163] = 'ER_TABLE_CANT_HANDLE_BLOB';
exports[1164] = 'ER_TABLE_CANT_HANDLE_AUTO_INCREMENT';
exports[1165] = 'ER_UNUSED3';
exports[1166] = 'ER_WRONG_COLUMN_NAME';
exports[1167] = 'ER_WRONG_KEY_COLUMN';
exports[1168] = 'ER_WRONG_MRG_TABLE';
exports[1169] = 'ER_DUP_UNIQUE';
exports[1170] = 'ER_BLOB_KEY_WITHOUT_LENGTH';
exports[1171] = 'ER_PRIMARY_CANT_HAVE_NULL';
exports[1172] = 'ER_TOO_MANY_ROWS';
exports[1173] = 'ER_REQUIRES_PRIMARY_KEY';
exports[1174] = 'ER_NO_RAID_COMPILED';
exports[1175] = 'ER_UPDATE_WITHOUT_KEY_IN_SAFE_MODE';
exports[1176] = 'ER_KEY_DOES_NOT_EXITS';
exports[1177] = 'ER_CHECK_NO_SUCH_TABLE';
exports[1178] = 'ER_CHECK_NOT_IMPLEMENTED';
exports[1179] = 'ER_CANT_DO_THIS_DURING_AN_TRANSACTION';
exports[1180] = 'ER_ERROR_DURING_COMMIT';
exports[1181] = 'ER_ERROR_DURING_ROLLBACK';
exports[1182] = 'ER_ERROR_DURING_FLUSH_LOGS';
exports[1183] = 'ER_ERROR_DURING_CHECKPOINT';
exports[1184] = 'ER_NEW_ABORTING_CONNECTION';
exports[1185] = 'ER_DUMP_NOT_IMPLEMENTED';
exports[1186] = 'ER_FLUSH_MASTER_BINLOG_CLOSED';
exports[1187] = 'ER_INDEX_REBUILD';
exports[1188] = 'ER_SOURCE';
exports[1189] = 'ER_SOURCE_NET_READ';
exports[1190] = 'ER_SOURCE_NET_WRITE';
exports[1191] = 'ER_FT_MATCHING_KEY_NOT_FOUND';
exports[1192] = 'ER_LOCK_OR_ACTIVE_TRANSACTION';
exports[1193] = 'ER_UNKNOWN_SYSTEM_VARIABLE';
exports[1194] = 'ER_CRASHED_ON_USAGE';
exports[1195] = 'ER_CRASHED_ON_REPAIR';
exports[1196] = 'ER_WARNING_NOT_COMPLETE_ROLLBACK';
exports[1197] = 'ER_TRANS_CACHE_FULL';
exports[1198] = 'ER_SLAVE_MUST_STOP';
exports[1199] = 'ER_REPLICA_NOT_RUNNING';
exports[1200] = 'ER_BAD_REPLICA';
exports[1201] = 'ER_CONNECTION_METADATA';
exports[1202] = 'ER_REPLICA_THREAD';
exports[1203] = 'ER_TOO_MANY_USER_CONNECTIONS';
exports[1204] = 'ER_SET_CONSTANTS_ONLY';
exports[1205] = 'ER_LOCK_WAIT_TIMEOUT';
exports[1206] = 'ER_LOCK_TABLE_FULL';
exports[1207] = 'ER_READ_ONLY_TRANSACTION';
exports[1208] = 'ER_DROP_DB_WITH_READ_LOCK';
exports[1209] = 'ER_CREATE_DB_WITH_READ_LOCK';
exports[1210] = 'ER_WRONG_ARGUMENTS';
exports[1211] = 'ER_NO_PERMISSION_TO_CREATE_USER';
exports[1212] = 'ER_UNION_TABLES_IN_DIFFERENT_DIR';
exports[1213] = 'ER_LOCK_DEADLOCK';
exports[1214] = 'ER_TABLE_CANT_HANDLE_FT';
exports[1215] = 'ER_CANNOT_ADD_FOREIGN';
exports[1216] = 'ER_NO_REFERENCED_ROW';
exports[1217] = 'ER_ROW_IS_REFERENCED';
exports[1218] = 'ER_CONNECT_TO_SOURCE';
exports[1219] = 'ER_QUERY_ON_MASTER';
exports[1220] = 'ER_ERROR_WHEN_EXECUTING_COMMAND';
exports[1221] = 'ER_WRONG_USAGE';
exports[1222] = 'ER_WRONG_NUMBER_OF_COLUMNS_IN_SELECT';
exports[1223] = 'ER_CANT_UPDATE_WITH_READLOCK';
exports[1224] = 'ER_MIXING_NOT_ALLOWED';
exports[1225] = 'ER_DUP_ARGUMENT';
exports[1226] = 'ER_USER_LIMIT_REACHED';
exports[1227] = 'ER_SPECIFIC_ACCESS_DENIED_ERROR';
exports[1228] = 'ER_LOCAL_VARIABLE';
exports[1229] = 'ER_GLOBAL_VARIABLE';
exports[1230] = 'ER_NO_DEFAULT';
exports[1231] = 'ER_WRONG_VALUE_FOR_VAR';
exports[1232] = 'ER_WRONG_TYPE_FOR_VAR';
exports[1233] = 'ER_VAR_CANT_BE_READ';
exports[1234] = 'ER_CANT_USE_OPTION_HERE';
exports[1235] = 'ER_NOT_SUPPORTED_YET';
exports[1236] = 'ER_SOURCE_FATAL_ERROR_READING_BINLOG';
exports[1237] = 'ER_REPLICA_IGNORED_TABLE';
exports[1238] = 'ER_INCORRECT_GLOBAL_LOCAL_VAR';
exports[1239] = 'ER_WRONG_FK_DEF';
exports[1240] = 'ER_KEY_REF_DO_NOT_MATCH_TABLE_REF';
exports[1241] = 'ER_OPERAND_COLUMNS';
exports[1242] = 'ER_SUBQUERY_NO_1_ROW';
exports[1243] = 'ER_UNKNOWN_STMT_HANDLER';
exports[1244] = 'ER_CORRUPT_HELP_DB';
exports[1245] = 'ER_CYCLIC_REFERENCE';
exports[1246] = 'ER_AUTO_CONVERT';
exports[1247] = 'ER_ILLEGAL_REFERENCE';
exports[1248] = 'ER_DERIVED_MUST_HAVE_ALIAS';
exports[1249] = 'ER_SELECT_REDUCED';
exports[1250] = 'ER_TABLENAME_NOT_ALLOWED_HERE';
exports[1251] = 'ER_NOT_SUPPORTED_AUTH_MODE';
exports[1252] = 'ER_SPATIAL_CANT_HAVE_NULL';
exports[1253] = 'ER_COLLATION_CHARSET_MISMATCH';
exports[1254] = 'ER_SLAVE_WAS_RUNNING';
exports[1255] = 'ER_SLAVE_WAS_NOT_RUNNING';
exports[1256] = 'ER_TOO_BIG_FOR_UNCOMPRESS';
exports[1257] = 'ER_ZLIB_Z_MEM_ERROR';
exports[1258] = 'ER_ZLIB_Z_BUF_ERROR';
exports[1259] = 'ER_ZLIB_Z_DATA_ERROR';
exports[1260] = 'ER_CUT_VALUE_GROUP_CONCAT';
exports[1261] = 'ER_WARN_TOO_FEW_RECORDS';
exports[1262] = 'ER_WARN_TOO_MANY_RECORDS';
exports[1263] = 'ER_WARN_NULL_TO_NOTNULL';
exports[1264] = 'ER_WARN_DATA_OUT_OF_RANGE';
exports[1265] = 'WARN_DATA_TRUNCATED';
exports[1266] = 'ER_WARN_USING_OTHER_HANDLER';
exports[1267] = 'ER_CANT_AGGREGATE_2COLLATIONS';
exports[1268] = 'ER_DROP_USER';
exports[1269] = 'ER_REVOKE_GRANTS';
exports[1270] = 'ER_CANT_AGGREGATE_3COLLATIONS';
exports[1271] = 'ER_CANT_AGGREGATE_NCOLLATIONS';
exports[1272] = 'ER_VARIABLE_IS_NOT_STRUCT';
exports[1273] = 'ER_UNKNOWN_COLLATION';
exports[1274] = 'ER_REPLICA_IGNORED_SSL_PARAMS';
exports[1275] = 'ER_SERVER_IS_IN_SECURE_AUTH_MODE';
exports[1276] = 'ER_WARN_FIELD_RESOLVED';
exports[1277] = 'ER_BAD_REPLICA_UNTIL_COND';
exports[1278] = 'ER_MISSING_SKIP_REPLICA';
exports[1279] = 'ER_UNTIL_COND_IGNORED';
exports[1280] = 'ER_WRONG_NAME_FOR_INDEX';
exports[1281] = 'ER_WRONG_NAME_FOR_CATALOG';
exports[1282] = 'ER_WARN_QC_RESIZE';
exports[1283] = 'ER_BAD_FT_COLUMN';
exports[1284] = 'ER_UNKNOWN_KEY_CACHE';
exports[1285] = 'ER_WARN_HOSTNAME_WONT_WORK';
exports[1286] = 'ER_UNKNOWN_STORAGE_ENGINE';
exports[1287] = 'ER_WARN_DEPRECATED_SYNTAX';
exports[1288] = 'ER_NON_UPDATABLE_TABLE';
exports[1289] = 'ER_FEATURE_DISABLED';
exports[1290] = 'ER_OPTION_PREVENTS_STATEMENT';
exports[1291] = 'ER_DUPLICATED_VALUE_IN_TYPE';
exports[1292] = 'ER_TRUNCATED_WRONG_VALUE';
exports[1293] = 'ER_TOO_MUCH_AUTO_TIMESTAMP_COLS';
exports[1294] = 'ER_INVALID_ON_UPDATE';
exports[1295] = 'ER_UNSUPPORTED_PS';
exports[1296] = 'ER_GET_ERRMSG';
exports[1297] = 'ER_GET_TEMPORARY_ERRMSG';
exports[1298] = 'ER_UNKNOWN_TIME_ZONE';
exports[1299] = 'ER_WARN_INVALID_TIMESTAMP';
exports[1300] = 'ER_INVALID_CHARACTER_STRING';
exports[1301] = 'ER_WARN_ALLOWED_PACKET_OVERFLOWED';
exports[1302] = 'ER_CONFLICTING_DECLARATIONS';
exports[1303] = 'ER_SP_NO_RECURSIVE_CREATE';
exports[1304] = 'ER_SP_ALREADY_EXISTS';
exports[1305] = 'ER_SP_DOES_NOT_EXIST';
exports[1306] = 'ER_SP_DROP_FAILED';
exports[1307] = 'ER_SP_STORE_FAILED';
exports[1308] = 'ER_SP_LILABEL_MISMATCH';
exports[1309] = 'ER_SP_LABEL_REDEFINE';
exports[1310] = 'ER_SP_LABEL_MISMATCH';
exports[1311] = 'ER_SP_UNINIT_VAR';
exports[1312] = 'ER_SP_BADSELECT';
exports[1313] = 'ER_SP_BADRETURN';
exports[1314] = 'ER_SP_BADSTATEMENT';
exports[1315] = 'ER_UPDATE_LOG_DEPRECATED_IGNORED';
exports[1316] = 'ER_UPDATE_LOG_DEPRECATED_TRANSLATED';
exports[1317] = 'ER_QUERY_INTERRUPTED';
exports[1318] = 'ER_SP_WRONG_NO_OF_ARGS';
exports[1319] = 'ER_SP_COND_MISMATCH';
exports[1320] = 'ER_SP_NORETURN';
exports[1321] = 'ER_SP_NORETURNEND';
exports[1322] = 'ER_SP_BAD_CURSOR_QUERY';
exports[1323] = 'ER_SP_BAD_CURSOR_SELECT';
exports[1324] = 'ER_SP_CURSOR_MISMATCH';
exports[1325] = 'ER_SP_CURSOR_ALREADY_OPEN';
exports[1326] = 'ER_SP_CURSOR_NOT_OPEN';
exports[1327] = 'ER_SP_UNDECLARED_VAR';
exports[1328] = 'ER_SP_WRONG_NO_OF_FETCH_ARGS';
exports[1329] = 'ER_SP_FETCH_NO_DATA';
exports[1330] = 'ER_SP_DUP_PARAM';
exports[1331] = 'ER_SP_DUP_VAR';
exports[1332] = 'ER_SP_DUP_COND';
exports[1333] = 'ER_SP_DUP_CURS';
exports[1334] = 'ER_SP_CANT_ALTER';
exports[1335] = 'ER_SP_SUBSELECT_NYI';
exports[1336] = 'ER_STMT_NOT_ALLOWED_IN_SF_OR_TRG';
exports[1337] = 'ER_SP_VARCOND_AFTER_CURSHNDLR';
exports[1338] = 'ER_SP_CURSOR_AFTER_HANDLER';
exports[1339] = 'ER_SP_CASE_NOT_FOUND';
exports[1340] = 'ER_FPARSER_TOO_BIG_FILE';
exports[1341] = 'ER_FPARSER_BAD_HEADER';
exports[1342] = 'ER_FPARSER_EOF_IN_COMMENT';
exports[1343] = 'ER_FPARSER_ERROR_IN_PARAMETER';
exports[1344] = 'ER_FPARSER_EOF_IN_UNKNOWN_PARAMETER';
exports[1345] = 'ER_VIEW_NO_EXPLAIN';
exports[1346] = 'ER_FRM_UNKNOWN_TYPE';
exports[1347] = 'ER_WRONG_OBJECT';
exports[1348] = 'ER_NONUPDATEABLE_COLUMN';
exports[1349] = 'ER_VIEW_SELECT_DERIVED';
exports[1350] = 'ER_VIEW_SELECT_CLAUSE';
exports[1351] = 'ER_VIEW_SELECT_VARIABLE';
exports[1352] = 'ER_VIEW_SELECT_TMPTABLE';
exports[1353] = 'ER_VIEW_WRONG_LIST';
exports[1354] = 'ER_WARN_VIEW_MERGE';
exports[1355] = 'ER_WARN_VIEW_WITHOUT_KEY';
exports[1356] = 'ER_VIEW_INVALID';
exports[1357] = 'ER_SP_NO_DROP_SP';
exports[1358] = 'ER_SP_GOTO_IN_HNDLR';
exports[1359] = 'ER_TRG_ALREADY_EXISTS';
exports[1360] = 'ER_TRG_DOES_NOT_EXIST';
exports[1361] = 'ER_TRG_ON_VIEW_OR_TEMP_TABLE';
exports[1362] = 'ER_TRG_CANT_CHANGE_ROW';
exports[1363] = 'ER_TRG_NO_SUCH_ROW_IN_TRG';
exports[1364] = 'ER_NO_DEFAULT_FOR_FIELD';
exports[1365] = 'ER_DIVISION_BY_ZERO';
exports[1366] = 'ER_TRUNCATED_WRONG_VALUE_FOR_FIELD';
exports[1367] = 'ER_ILLEGAL_VALUE_FOR_TYPE';
exports[1368] = 'ER_VIEW_NONUPD_CHECK';
exports[1369] = 'ER_VIEW_CHECK_FAILED';
exports[1370] = 'ER_PROCACCESS_DENIED_ERROR';
exports[1371] = 'ER_RELAY_LOG_FAIL';
exports[1372] = 'ER_PASSWD_LENGTH';
exports[1373] = 'ER_UNKNOWN_TARGET_BINLOG';
exports[1374] = 'ER_IO_ERR_LOG_INDEX_READ';
exports[1375] = 'ER_BINLOG_PURGE_PROHIBITED';
exports[1376] = 'ER_FSEEK_FAIL';
exports[1377] = 'ER_BINLOG_PURGE_FATAL_ERR';
exports[1378] = 'ER_LOG_IN_USE';
exports[1379] = 'ER_LOG_PURGE_UNKNOWN_ERR';
exports[1380] = 'ER_RELAY_LOG_INIT';
exports[1381] = 'ER_NO_BINARY_LOGGING';
exports[1382] = 'ER_RESERVED_SYNTAX';
exports[1383] = 'ER_WSAS_FAILED';
exports[1384] = 'ER_DIFF_GROUPS_PROC';
exports[1385] = 'ER_NO_GROUP_FOR_PROC';
exports[1386] = 'ER_ORDER_WITH_PROC';
exports[1387] = 'ER_LOGGING_PROHIBIT_CHANGING_OF';
exports[1388] = 'ER_NO_FILE_MAPPING';
exports[1389] = 'ER_WRONG_MAGIC';
exports[1390] = 'ER_PS_MANY_PARAM';
exports[1391] = 'ER_KEY_PART_0';
exports[1392] = 'ER_VIEW_CHECKSUM';
exports[1393] = 'ER_VIEW_MULTIUPDATE';
exports[1394] = 'ER_VIEW_NO_INSERT_FIELD_LIST';
exports[1395] = 'ER_VIEW_DELETE_MERGE_VIEW';
exports[1396] = 'ER_CANNOT_USER';
exports[1397] = 'ER_XAER_NOTA';
exports[1398] = 'ER_XAER_INVAL';
exports[1399] = 'ER_XAER_RMFAIL';
exports[1400] = 'ER_XAER_OUTSIDE';
exports[1401] = 'ER_XAER_RMERR';
exports[1402] = 'ER_XA_RBROLLBACK';
exports[1403] = 'ER_NONEXISTING_PROC_GRANT';
exports[1404] = 'ER_PROC_AUTO_GRANT_FAIL';
exports[1405] = 'ER_PROC_AUTO_REVOKE_FAIL';
exports[1406] = 'ER_DATA_TOO_LONG';
exports[1407] = 'ER_SP_BAD_SQLSTATE';
exports[1408] = 'ER_STARTUP';
exports[1409] = 'ER_LOAD_FROM_FIXED_SIZE_ROWS_TO_VAR';
exports[1410] = 'ER_CANT_CREATE_USER_WITH_GRANT';
exports[1411] = 'ER_WRONG_VALUE_FOR_TYPE';
exports[1412] = 'ER_TABLE_DEF_CHANGED';
exports[1413] = 'ER_SP_DUP_HANDLER';
exports[1414] = 'ER_SP_NOT_VAR_ARG';
exports[1415] = 'ER_SP_NO_RETSET';
exports[1416] = 'ER_CANT_CREATE_GEOMETRY_OBJECT';
exports[1417] = 'ER_FAILED_ROUTINE_BREAK_BINLOG';
exports[1418] = 'ER_BINLOG_UNSAFE_ROUTINE';
exports[1419] = 'ER_BINLOG_CREATE_ROUTINE_NEED_SUPER';
exports[1420] = 'ER_EXEC_STMT_WITH_OPEN_CURSOR';
exports[1421] = 'ER_STMT_HAS_NO_OPEN_CURSOR';
exports[1422] = 'ER_COMMIT_NOT_ALLOWED_IN_SF_OR_TRG';
exports[1423] = 'ER_NO_DEFAULT_FOR_VIEW_FIELD';
exports[1424] = 'ER_SP_NO_RECURSION';
exports[1425] = 'ER_TOO_BIG_SCALE';
exports[1426] = 'ER_TOO_BIG_PRECISION';
exports[1427] = 'ER_M_BIGGER_THAN_D';
exports[1428] = 'ER_WRONG_LOCK_OF_SYSTEM_TABLE';
exports[1429] = 'ER_CONNECT_TO_FOREIGN_DATA_SOURCE';
exports[1430] = 'ER_QUERY_ON_FOREIGN_DATA_SOURCE';
exports[1431] = 'ER_FOREIGN_DATA_SOURCE_DOESNT_EXIST';
exports[1432] = 'ER_FOREIGN_DATA_STRING_INVALID_CANT_CREATE';
exports[1433] = 'ER_FOREIGN_DATA_STRING_INVALID';
exports[1434] = 'ER_CANT_CREATE_FEDERATED_TABLE';
exports[1435] = 'ER_TRG_IN_WRONG_SCHEMA';
exports[1436] = 'ER_STACK_OVERRUN_NEED_MORE';
exports[1437] = 'ER_TOO_LONG_BODY';
exports[1438] = 'ER_WARN_CANT_DROP_DEFAULT_KEYCACHE';
exports[1439] = 'ER_TOO_BIG_DISPLAYWIDTH';
exports[1440] = 'ER_XAER_DUPID';
exports[1441] = 'ER_DATETIME_FUNCTION_OVERFLOW';
exports[1442] = 'ER_CANT_UPDATE_USED_TABLE_IN_SF_OR_TRG';
exports[1443] = 'ER_VIEW_PREVENT_UPDATE';
exports[1444] = 'ER_PS_NO_RECURSION';
exports[1445] = 'ER_SP_CANT_SET_AUTOCOMMIT';
exports[1446] = 'ER_MALFORMED_DEFINER';
exports[1447] = 'ER_VIEW_FRM_NO_USER';
exports[1448] = 'ER_VIEW_OTHER_USER';
exports[1449] = 'ER_NO_SUCH_USER';
exports[1450] = 'ER_FORBID_SCHEMA_CHANGE';
exports[1451] = 'ER_ROW_IS_REFERENCED_2';
exports[1452] = 'ER_NO_REFERENCED_ROW_2';
exports[1453] = 'ER_SP_BAD_VAR_SHADOW';
exports[1454] = 'ER_TRG_NO_DEFINER';
exports[1455] = 'ER_OLD_FILE_FORMAT';
exports[1456] = 'ER_SP_RECURSION_LIMIT';
exports[1457] = 'ER_SP_PROC_TABLE_CORRUPT';
exports[1458] = 'ER_SP_WRONG_NAME';
exports[1459] = 'ER_TABLE_NEEDS_UPGRADE';
exports[1460] = 'ER_SP_NO_AGGREGATE';
exports[1461] = 'ER_MAX_PREPARED_STMT_COUNT_REACHED';
exports[1462] = 'ER_VIEW_RECURSIVE';
exports[1463] = 'ER_NON_GROUPING_FIELD_USED';
exports[1464] = 'ER_TABLE_CANT_HANDLE_SPKEYS';
exports[1465] = 'ER_NO_TRIGGERS_ON_SYSTEM_SCHEMA';
exports[1466] = 'ER_REMOVED_SPACES';
exports[1467] = 'ER_AUTOINC_READ_FAILED';
exports[1468] = 'ER_USERNAME';
exports[1469] = 'ER_HOSTNAME';
exports[1470] = 'ER_WRONG_STRING_LENGTH';
exports[1471] = 'ER_NON_INSERTABLE_TABLE';
exports[1472] = 'ER_ADMIN_WRONG_MRG_TABLE';
exports[1473] = 'ER_TOO_HIGH_LEVEL_OF_NESTING_FOR_SELECT';
exports[1474] = 'ER_NAME_BECOMES_EMPTY';
exports[1475] = 'ER_AMBIGUOUS_FIELD_TERM';
exports[1476] = 'ER_FOREIGN_SERVER_EXISTS';
exports[1477] = 'ER_FOREIGN_SERVER_DOESNT_EXIST';
exports[1478] = 'ER_ILLEGAL_HA_CREATE_OPTION';
exports[1479] = 'ER_PARTITION_REQUIRES_VALUES_ERROR';
exports[1480] = 'ER_PARTITION_WRONG_VALUES_ERROR';
exports[1481] = 'ER_PARTITION_MAXVALUE_ERROR';
exports[1482] = 'ER_PARTITION_SUBPARTITION_ERROR';
exports[1483] = 'ER_PARTITION_SUBPART_MIX_ERROR';
exports[1484] = 'ER_PARTITION_WRONG_NO_PART_ERROR';
exports[1485] = 'ER_PARTITION_WRONG_NO_SUBPART_ERROR';
exports[1486] = 'ER_WRONG_EXPR_IN_PARTITION_FUNC_ERROR';
exports[1487] = 'ER_NO_CONST_EXPR_IN_RANGE_OR_LIST_ERROR';
exports[1488] = 'ER_FIELD_NOT_FOUND_PART_ERROR';
exports[1489] = 'ER_LIST_OF_FIELDS_ONLY_IN_HASH_ERROR';
exports[1490] = 'ER_INCONSISTENT_PARTITION_INFO_ERROR';
exports[1491] = 'ER_PARTITION_FUNC_NOT_ALLOWED_ERROR';
exports[1492] = 'ER_PARTITIONS_MUST_BE_DEFINED_ERROR';
exports[1493] = 'ER_RANGE_NOT_INCREASING_ERROR';
exports[1494] = 'ER_INCONSISTENT_TYPE_OF_FUNCTIONS_ERROR';
exports[1495] = 'ER_MULTIPLE_DEF_CONST_IN_LIST_PART_ERROR';
exports[1496] = 'ER_PARTITION_ENTRY_ERROR';
exports[1497] = 'ER_MIX_HANDLER_ERROR';
exports[1498] = 'ER_PARTITION_NOT_DEFINED_ERROR';
exports[1499] = 'ER_TOO_MANY_PARTITIONS_ERROR';
exports[1500] = 'ER_SUBPARTITION_ERROR';
exports[1501] = 'ER_CANT_CREATE_HANDLER_FILE';
exports[1502] = 'ER_BLOB_FIELD_IN_PART_FUNC_ERROR';
exports[1503] = 'ER_UNIQUE_KEY_NEED_ALL_FIELDS_IN_PF';
exports[1504] = 'ER_NO_PARTS_ERROR';
exports[1505] = 'ER_PARTITION_MGMT_ON_NONPARTITIONED';
exports[1506] = 'ER_FOREIGN_KEY_ON_PARTITIONED';
exports[1507] = 'ER_DROP_PARTITION_NON_EXISTENT';
exports[1508] = 'ER_DROP_LAST_PARTITION';
exports[1509] = 'ER_COALESCE_ONLY_ON_HASH_PARTITION';
exports[1510] = 'ER_REORG_HASH_ONLY_ON_SAME_NO';
exports[1511] = 'ER_REORG_NO_PARAM_ERROR';
exports[1512] = 'ER_ONLY_ON_RANGE_LIST_PARTITION';
exports[1513] = 'ER_ADD_PARTITION_SUBPART_ERROR';
exports[1514] = 'ER_ADD_PARTITION_NO_NEW_PARTITION';
exports[1515] = 'ER_COALESCE_PARTITION_NO_PARTITION';
exports[1516] = 'ER_REORG_PARTITION_NOT_EXIST';
exports[1517] = 'ER_SAME_NAME_PARTITION';
exports[1518] = 'ER_NO_BINLOG_ERROR';
exports[1519] = 'ER_CONSECUTIVE_REORG_PARTITIONS';
exports[1520] = 'ER_REORG_OUTSIDE_RANGE';
exports[1521] = 'ER_PARTITION_FUNCTION_FAILURE';
exports[1522] = 'ER_PART_STATE_ERROR';
exports[1523] = 'ER_LIMITED_PART_RANGE';
exports[1524] = 'ER_PLUGIN_IS_NOT_LOADED';
exports[1525] = 'ER_WRONG_VALUE';
exports[1526] = 'ER_NO_PARTITION_FOR_GIVEN_VALUE';
exports[1527] = 'ER_FILEGROUP_OPTION_ONLY_ONCE';
exports[1528] = 'ER_CREATE_FILEGROUP_FAILED';
exports[1529] = 'ER_DROP_FILEGROUP_FAILED';
exports[1530] = 'ER_TABLESPACE_AUTO_EXTEND_ERROR';
exports[1531] = 'ER_WRONG_SIZE_NUMBER';
exports[1532] = 'ER_SIZE_OVERFLOW_ERROR';
exports[1533] = 'ER_ALTER_FILEGROUP_FAILED';
exports[1534] = 'ER_BINLOG_ROW_LOGGING_FAILED';
exports[1535] = 'ER_BINLOG_ROW_WRONG_TABLE_DEF';
exports[1536] = 'ER_BINLOG_ROW_RBR_TO_SBR';
exports[1537] = 'ER_EVENT_ALREADY_EXISTS';
exports[1538] = 'ER_EVENT_STORE_FAILED';
exports[1539] = 'ER_EVENT_DOES_NOT_EXIST';
exports[1540] = 'ER_EVENT_CANT_ALTER';
exports[1541] = 'ER_EVENT_DROP_FAILED';
exports[1542] = 'ER_EVENT_INTERVAL_NOT_POSITIVE_OR_TOO_BIG';
exports[1543] = 'ER_EVENT_ENDS_BEFORE_STARTS';
exports[1544] = 'ER_EVENT_EXEC_TIME_IN_THE_PAST';
exports[1545] = 'ER_EVENT_OPEN_TABLE_FAILED';
exports[1546] = 'ER_EVENT_NEITHER_M_EXPR_NOR_M_AT';
exports[1547] = 'ER_COL_COUNT_DOESNT_MATCH_CORRUPTED';
exports[1548] = 'ER_CANNOT_LOAD_FROM_TABLE';
exports[1549] = 'ER_EVENT_CANNOT_DELETE';
exports[1550] = 'ER_EVENT_COMPILE_ERROR';
exports[1551] = 'ER_EVENT_SAME_NAME';
exports[1552] = 'ER_EVENT_DATA_TOO_LONG';
exports[1553] = 'ER_DROP_INDEX_FK';
exports[1554] = 'ER_WARN_DEPRECATED_SYNTAX_WITH_VER';
exports[1555] = 'ER_CANT_WRITE_LOCK_LOG_TABLE';
exports[1556] = 'ER_CANT_LOCK_LOG_TABLE';
exports[1557] = 'ER_FOREIGN_DUPLICATE_KEY';
exports[1558] = 'ER_COL_COUNT_DOESNT_MATCH_PLEASE_UPDATE';
exports[1559] = 'ER_TEMP_TABLE_PREVENTS_SWITCH_OUT_OF_RBR';
exports[1560] = 'ER_STORED_FUNCTION_PREVENTS_SWITCH_BINLOG_FORMAT';
exports[1561] = 'ER_NDB_CANT_SWITCH_BINLOG_FORMAT';
exports[1562] = 'ER_PARTITION_NO_TEMPORARY';
exports[1563] = 'ER_PARTITION_CONST_DOMAIN_ERROR';
exports[1564] = 'ER_PARTITION_FUNCTION_IS_NOT_ALLOWED';
exports[1565] = 'ER_DDL_LOG_ERROR';
exports[1566] = 'ER_NULL_IN_VALUES_LESS_THAN';
exports[1567] = 'ER_WRONG_PARTITION_NAME';
exports[1568] = 'ER_CANT_CHANGE_TX_CHARACTERISTICS';
exports[1569] = 'ER_DUP_ENTRY_AUTOINCREMENT_CASE';
exports[1570] = 'ER_EVENT_MODIFY_QUEUE_ERROR';
exports[1571] = 'ER_EVENT_SET_VAR_ERROR';
exports[1572] = 'ER_PARTITION_MERGE_ERROR';
exports[1573] = 'ER_CANT_ACTIVATE_LOG';
exports[1574] = 'ER_RBR_NOT_AVAILABLE';
exports[1575] = 'ER_BASE64_DECODE_ERROR';
exports[1576] = 'ER_EVENT_RECURSION_FORBIDDEN';
exports[1577] = 'ER_EVENTS_DB_ERROR';
exports[1578] = 'ER_ONLY_INTEGERS_ALLOWED';
exports[1579] = 'ER_UNSUPORTED_LOG_ENGINE';
exports[1580] = 'ER_BAD_LOG_STATEMENT';
exports[1581] = 'ER_CANT_RENAME_LOG_TABLE';
exports[1582] = 'ER_WRONG_PARAMCOUNT_TO_NATIVE_FCT';
exports[1583] = 'ER_WRONG_PARAMETERS_TO_NATIVE_FCT';
exports[1584] = 'ER_WRONG_PARAMETERS_TO_STORED_FCT';
exports[1585] = 'ER_NATIVE_FCT_NAME_COLLISION';
exports[1586] = 'ER_DUP_ENTRY_WITH_KEY_NAME';
exports[1587] = 'ER_BINLOG_PURGE_EMFILE';
exports[1588] = 'ER_EVENT_CANNOT_CREATE_IN_THE_PAST';
exports[1589] = 'ER_EVENT_CANNOT_ALTER_IN_THE_PAST';
exports[1590] = 'ER_SLAVE_INCIDENT';
exports[1591] = 'ER_NO_PARTITION_FOR_GIVEN_VALUE_SILENT';
exports[1592] = 'ER_BINLOG_UNSAFE_STATEMENT';
exports[1593] = 'ER_BINLOG_FATAL_ERROR';
exports[1594] = 'ER_SLAVE_RELAY_LOG_READ_FAILURE';
exports[1595] = 'ER_SLAVE_RELAY_LOG_WRITE_FAILURE';
exports[1596] = 'ER_SLAVE_CREATE_EVENT_FAILURE';
exports[1597] = 'ER_SLAVE_MASTER_COM_FAILURE';
exports[1598] = 'ER_BINLOG_LOGGING_IMPOSSIBLE';
exports[1599] = 'ER_VIEW_NO_CREATION_CTX';
exports[1600] = 'ER_VIEW_INVALID_CREATION_CTX';
exports[1601] = 'ER_SR_INVALID_CREATION_CTX';
exports[1602] = 'ER_TRG_CORRUPTED_FILE';
exports[1603] = 'ER_TRG_NO_CREATION_CTX';
exports[1604] = 'ER_TRG_INVALID_CREATION_CTX';
exports[1605] = 'ER_EVENT_INVALID_CREATION_CTX';
exports[1606] = 'ER_TRG_CANT_OPEN_TABLE';
exports[1607] = 'ER_CANT_CREATE_SROUTINE';
exports[1608] = 'ER_NEVER_USED';
exports[1609] = 'ER_NO_FORMAT_DESCRIPTION_EVENT_BEFORE_BINLOG_STATEMENT';
exports[1610] = 'ER_REPLICA_CORRUPT_EVENT';
exports[1611] = 'ER_LOAD_DATA_INVALID_COLUMN';
exports[1612] = 'ER_LOG_PURGE_NO_FILE';
exports[1613] = 'ER_XA_RBTIMEOUT';
exports[1614] = 'ER_XA_RBDEADLOCK';
exports[1615] = 'ER_NEED_REPREPARE';
exports[1616] = 'ER_DELAYED_NOT_SUPPORTED';
exports[1617] = 'WARN_NO_CONNECTION_METADATA';
exports[1618] = 'WARN_OPTION_IGNORED';
exports[1619] = 'ER_PLUGIN_DELETE_BUILTIN';
exports[1620] = 'WARN_PLUGIN_BUSY';
exports[1621] = 'ER_VARIABLE_IS_READONLY';
exports[1622] = 'ER_WARN_ENGINE_TRANSACTION_ROLLBACK';
exports[1623] = 'ER_SLAVE_HEARTBEAT_FAILURE';
exports[1624] = 'ER_REPLICA_HEARTBEAT_VALUE_OUT_OF_RANGE';
exports[1625] = 'ER_NDB_REPLICATION_SCHEMA_ERROR';
exports[1626] = 'ER_CONFLICT_FN_PARSE_ERROR';
exports[1627] = 'ER_EXCEPTIONS_WRITE_ERROR';
exports[1628] = 'ER_TOO_LONG_TABLE_COMMENT';
exports[1629] = 'ER_TOO_LONG_FIELD_COMMENT';
exports[1630] = 'ER_FUNC_INEXISTENT_NAME_COLLISION';
exports[1631] = 'ER_DATABASE_NAME';
exports[1632] = 'ER_TABLE_NAME';
exports[1633] = 'ER_PARTITION_NAME';
exports[1634] = 'ER_SUBPARTITION_NAME';
exports[1635] = 'ER_TEMPORARY_NAME';
exports[1636] = 'ER_RENAMED_NAME';
exports[1637] = 'ER_TOO_MANY_CONCURRENT_TRXS';
exports[1638] = 'WARN_NON_ASCII_SEPARATOR_NOT_IMPLEMENTED';
exports[1639] = 'ER_DEBUG_SYNC_TIMEOUT';
exports[1640] = 'ER_DEBUG_SYNC_HIT_LIMIT';
exports[1641] = 'ER_DUP_SIGNAL_SET';
exports[1642] = 'ER_SIGNAL_WARN';
exports[1643] = 'ER_SIGNAL_NOT_FOUND';
exports[1644] = 'ER_SIGNAL_EXCEPTION';
exports[1645] = 'ER_RESIGNAL_WITHOUT_ACTIVE_HANDLER';
exports[1646] = 'ER_SIGNAL_BAD_CONDITION_TYPE';
exports[1647] = 'WARN_COND_ITEM_TRUNCATED';
exports[1648] = 'ER_COND_ITEM_TOO_LONG';
exports[1649] = 'ER_UNKNOWN_LOCALE';
exports[1650] = 'ER_REPLICA_IGNORE_SERVER_IDS';
exports[1651] = 'ER_QUERY_CACHE_DISABLED';
exports[1652] = 'ER_SAME_NAME_PARTITION_FIELD';
exports[1653] = 'ER_PARTITION_COLUMN_LIST_ERROR';
exports[1654] = 'ER_WRONG_TYPE_COLUMN_VALUE_ERROR';
exports[1655] = 'ER_TOO_MANY_PARTITION_FUNC_FIELDS_ERROR';
exports[1656] = 'ER_MAXVALUE_IN_VALUES_IN';
exports[1657] = 'ER_TOO_MANY_VALUES_ERROR';
exports[1658] = 'ER_ROW_SINGLE_PARTITION_FIELD_ERROR';
exports[1659] = 'ER_FIELD_TYPE_NOT_ALLOWED_AS_PARTITION_FIELD';
exports[1660] = 'ER_PARTITION_FIELDS_TOO_LONG';
exports[1661] = 'ER_BINLOG_ROW_ENGINE_AND_STMT_ENGINE';
exports[1662] = 'ER_BINLOG_ROW_MODE_AND_STMT_ENGINE';
exports[1663] = 'ER_BINLOG_UNSAFE_AND_STMT_ENGINE';
exports[1664] = 'ER_BINLOG_ROW_INJECTION_AND_STMT_ENGINE';
exports[1665] = 'ER_BINLOG_STMT_MODE_AND_ROW_ENGINE';
exports[1666] = 'ER_BINLOG_ROW_INJECTION_AND_STMT_MODE';
exports[1667] = 'ER_BINLOG_MULTIPLE_ENGINES_AND_SELF_LOGGING_ENGINE';
exports[1668] = 'ER_BINLOG_UNSAFE_LIMIT';
exports[1669] = 'ER_UNUSED4';
exports[1670] = 'ER_BINLOG_UNSAFE_SYSTEM_TABLE';
exports[1671] = 'ER_BINLOG_UNSAFE_AUTOINC_COLUMNS';
exports[1672] = 'ER_BINLOG_UNSAFE_UDF';
exports[1673] = 'ER_BINLOG_UNSAFE_SYSTEM_VARIABLE';
exports[1674] = 'ER_BINLOG_UNSAFE_SYSTEM_FUNCTION';
exports[1675] = 'ER_BINLOG_UNSAFE_NONTRANS_AFTER_TRANS';
exports[1676] = 'ER_MESSAGE_AND_STATEMENT';
exports[1677] = 'ER_SLAVE_CONVERSION_FAILED';
exports[1678] = 'ER_REPLICA_CANT_CREATE_CONVERSION';
exports[1679] = 'ER_INSIDE_TRANSACTION_PREVENTS_SWITCH_BINLOG_FORMAT';
exports[1680] = 'ER_PATH_LENGTH';
exports[1681] = 'ER_WARN_DEPRECATED_SYNTAX_NO_REPLACEMENT';
exports[1682] = 'ER_WRONG_NATIVE_TABLE_STRUCTURE';
exports[1683] = 'ER_WRONG_PERFSCHEMA_USAGE';
exports[1684] = 'ER_WARN_I_S_SKIPPED_TABLE';
exports[1685] = 'ER_INSIDE_TRANSACTION_PREVENTS_SWITCH_BINLOG_DIRECT';
exports[1686] = 'ER_STORED_FUNCTION_PREVENTS_SWITCH_BINLOG_DIRECT';
exports[1687] = 'ER_SPATIAL_MUST_HAVE_GEOM_COL';
exports[1688] = 'ER_TOO_LONG_INDEX_COMMENT';
exports[1689] = 'ER_LOCK_ABORTED';
exports[1690] = 'ER_DATA_OUT_OF_RANGE';
exports[1691] = 'ER_WRONG_SPVAR_TYPE_IN_LIMIT';
exports[1692] = 'ER_BINLOG_UNSAFE_MULTIPLE_ENGINES_AND_SELF_LOGGING_ENGINE';
exports[1693] = 'ER_BINLOG_UNSAFE_MIXED_STATEMENT';
exports[1694] = 'ER_INSIDE_TRANSACTION_PREVENTS_SWITCH_SQL_LOG_BIN';
exports[1695] = 'ER_STORED_FUNCTION_PREVENTS_SWITCH_SQL_LOG_BIN';
exports[1696] = 'ER_FAILED_READ_FROM_PAR_FILE';
exports[1697] = 'ER_VALUES_IS_NOT_INT_TYPE_ERROR';
exports[1698] = 'ER_ACCESS_DENIED_NO_PASSWORD_ERROR';
exports[1699] = 'ER_SET_PASSWORD_AUTH_PLUGIN';
exports[1700] = 'ER_GRANT_PLUGIN_USER_EXISTS';
exports[1701] = 'ER_TRUNCATE_ILLEGAL_FK';
exports[1702] = 'ER_PLUGIN_IS_PERMANENT';
exports[1703] = 'ER_REPLICA_HEARTBEAT_VALUE_OUT_OF_RANGE_MIN';
exports[1704] = 'ER_REPLICA_HEARTBEAT_VALUE_OUT_OF_RANGE_MAX';
exports[1705] = 'ER_STMT_CACHE_FULL';
exports[1706] = 'ER_MULTI_UPDATE_KEY_CONFLICT';
exports[1707] = 'ER_TABLE_NEEDS_REBUILD';
exports[1708] = 'WARN_OPTION_BELOW_LIMIT';
exports[1709] = 'ER_INDEX_COLUMN_TOO_LONG';
exports[1710] = 'ER_ERROR_IN_TRIGGER_BODY';
exports[1711] = 'ER_ERROR_IN_UNKNOWN_TRIGGER_BODY';
exports[1712] = 'ER_INDEX_CORRUPT';
exports[1713] = 'ER_UNDO_RECORD_TOO_BIG';
exports[1714] = 'ER_BINLOG_UNSAFE_INSERT_IGNORE_SELECT';
exports[1715] = 'ER_BINLOG_UNSAFE_INSERT_SELECT_UPDATE';
exports[1716] = 'ER_BINLOG_UNSAFE_REPLACE_SELECT';
exports[1717] = 'ER_BINLOG_UNSAFE_CREATE_IGNORE_SELECT';
exports[1718] = 'ER_BINLOG_UNSAFE_CREATE_REPLACE_SELECT';
exports[1719] = 'ER_BINLOG_UNSAFE_UPDATE_IGNORE';
exports[1720] = 'ER_PLUGIN_NO_UNINSTALL';
exports[1721] = 'ER_PLUGIN_NO_INSTALL';
exports[1722] = 'ER_BINLOG_UNSAFE_WRITE_AUTOINC_SELECT';
exports[1723] = 'ER_BINLOG_UNSAFE_CREATE_SELECT_AUTOINC';
exports[1724] = 'ER_BINLOG_UNSAFE_INSERT_TWO_KEYS';
exports[1725] = 'ER_TABLE_IN_FK_CHECK';
exports[1726] = 'ER_UNSUPPORTED_ENGINE';
exports[1727] = 'ER_BINLOG_UNSAFE_AUTOINC_NOT_FIRST';
exports[1728] = 'ER_CANNOT_LOAD_FROM_TABLE_V2';
exports[1729] = 'ER_SOURCE_DELAY_VALUE_OUT_OF_RANGE';
exports[1730] = 'ER_ONLY_FD_AND_RBR_EVENTS_ALLOWED_IN_BINLOG_STATEMENT';
exports[1731] = 'ER_PARTITION_EXCHANGE_DIFFERENT_OPTION';
exports[1732] = 'ER_PARTITION_EXCHANGE_PART_TABLE';
exports[1733] = 'ER_PARTITION_EXCHANGE_TEMP_TABLE';
exports[1734] = 'ER_PARTITION_INSTEAD_OF_SUBPARTITION';
exports[1735] = 'ER_UNKNOWN_PARTITION';
exports[1736] = 'ER_TABLES_DIFFERENT_METADATA';
exports[1737] = 'ER_ROW_DOES_NOT_MATCH_PARTITION';
exports[1738] = 'ER_BINLOG_CACHE_SIZE_GREATER_THAN_MAX';
exports[1739] = 'ER_WARN_INDEX_NOT_APPLICABLE';
exports[1740] = 'ER_PARTITION_EXCHANGE_FOREIGN_KEY';
exports[1741] = 'ER_NO_SUCH_KEY_VALUE';
exports[1742] = 'ER_RPL_INFO_DATA_TOO_LONG';
exports[1743] = 'ER_NETWORK_READ_EVENT_CHECKSUM_FAILURE';
exports[1744] = 'ER_BINLOG_READ_EVENT_CHECKSUM_FAILURE';
exports[1745] = 'ER_BINLOG_STMT_CACHE_SIZE_GREATER_THAN_MAX';
exports[1746] = 'ER_CANT_UPDATE_TABLE_IN_CREATE_TABLE_SELECT';
exports[1747] = 'ER_PARTITION_CLAUSE_ON_NONPARTITIONED';
exports[1748] = 'ER_ROW_DOES_NOT_MATCH_GIVEN_PARTITION_SET';
exports[1749] = 'ER_NO_SUCH_PARTITION';
exports[1750] = 'ER_CHANGE_RPL_INFO_REPOSITORY_FAILURE';
exports[1751] = 'ER_WARNING_NOT_COMPLETE_ROLLBACK_WITH_CREATED_TEMP_TABLE';
exports[1752] = 'ER_WARNING_NOT_COMPLETE_ROLLBACK_WITH_DROPPED_TEMP_TABLE';
exports[1753] = 'ER_MTA_FEATURE_IS_NOT_SUPPORTED';
exports[1754] = 'ER_MTA_UPDATED_DBS_GREATER_MAX';
exports[1755] = 'ER_MTA_CANT_PARALLEL';
exports[1756] = 'ER_MTA_INCONSISTENT_DATA';
exports[1757] = 'ER_FULLTEXT_NOT_SUPPORTED_WITH_PARTITIONING';
exports[1758] = 'ER_DA_INVALID_CONDITION_NUMBER';
exports[1759] = 'ER_INSECURE_PLAIN_TEXT';
exports[1760] = 'ER_INSECURE_CHANGE_SOURCE';
exports[1761] = 'ER_FOREIGN_DUPLICATE_KEY_WITH_CHILD_INFO';
exports[1762] = 'ER_FOREIGN_DUPLICATE_KEY_WITHOUT_CHILD_INFO';
exports[1763] = 'ER_SQLTHREAD_WITH_SECURE_REPLICA';
exports[1764] = 'ER_TABLE_HAS_NO_FT';
exports[1765] = 'ER_VARIABLE_NOT_SETTABLE_IN_SF_OR_TRIGGER';
exports[1766] = 'ER_VARIABLE_NOT_SETTABLE_IN_TRANSACTION';
exports[1767] = 'ER_GTID_NEXT_IS_NOT_IN_GTID_NEXT_LIST';
exports[1768] = 'ER_CANT_CHANGE_GTID_NEXT_IN_TRANSACTION';
exports[1769] = 'ER_SET_STATEMENT_CANNOT_INVOKE_FUNCTION';
exports[1770] = 'ER_GTID_NEXT_CANT_BE_AUTOMATIC_IF_GTID_NEXT_LIST_IS_NON_NULL';
exports[1771] = 'ER_SKIPPING_LOGGED_TRANSACTION';
exports[1772] = 'ER_MALFORMED_GTID_SET_SPECIFICATION';
exports[1773] = 'ER_MALFORMED_GTID_SET_ENCODING';
exports[1774] = 'ER_MALFORMED_GTID_SPECIFICATION';
exports[1775] = 'ER_GNO_EXHAUSTED';
exports[1776] = 'ER_BAD_REPLICA_AUTO_POSITION';
exports[1777] = 'ER_AUTO_POSITION_REQUIRES_GTID_MODE_NOT_OFF';
exports[1778] = 'ER_CANT_DO_IMPLICIT_COMMIT_IN_TRX_WHEN_GTID_NEXT_IS_SET';
exports[1779] = 'ER_GTID_MODE_ON_REQUIRES_ENFORCE_GTID_CONSISTENCY_ON';
exports[1780] = 'ER_GTID_MODE_REQUIRES_BINLOG';
exports[1781] = 'ER_CANT_SET_GTID_NEXT_TO_GTID_WHEN_GTID_MODE_IS_OFF';
exports[1782] = 'ER_CANT_SET_GTID_NEXT_TO_ANONYMOUS_WHEN_GTID_MODE_IS_ON';
exports[1783] = 'ER_CANT_SET_GTID_NEXT_LIST_TO_NON_NULL_WHEN_GTID_MODE_IS_OFF';
exports[1784] = 'ER_FOUND_GTID_EVENT_WHEN_GTID_MODE_IS_OFF';
exports[1785] = 'ER_GTID_UNSAFE_NON_TRANSACTIONAL_TABLE';
exports[1786] = 'ER_GTID_UNSAFE_CREATE_SELECT';
exports[1787] = 'ER_GTID_UNSAFE_CREATE_DROP_TEMP_TABLE_IN_TRANSACTION';
exports[1788] = 'ER_GTID_MODE_CAN_ONLY_CHANGE_ONE_STEP_AT_A_TIME';
exports[1789] = 'ER_SOURCE_HAS_PURGED_REQUIRED_GTIDS';
exports[1790] = 'ER_CANT_SET_GTID_NEXT_WHEN_OWNING_GTID';
exports[1791] = 'ER_UNKNOWN_EXPLAIN_FORMAT';
exports[1792] = 'ER_CANT_EXECUTE_IN_READ_ONLY_TRANSACTION';
exports[1793] = 'ER_TOO_LONG_TABLE_PARTITION_COMMENT';
exports[1794] = 'ER_REPLICA_CONFIGURATION';
exports[1795] = 'ER_INNODB_FT_LIMIT';
exports[1796] = 'ER_INNODB_NO_FT_TEMP_TABLE';
exports[1797] = 'ER_INNODB_FT_WRONG_DOCID_COLUMN';
exports[1798] = 'ER_INNODB_FT_WRONG_DOCID_INDEX';
exports[1799] = 'ER_INNODB_ONLINE_LOG_TOO_BIG';
exports[1800] = 'ER_UNKNOWN_ALTER_ALGORITHM';
exports[1801] = 'ER_UNKNOWN_ALTER_LOCK';
exports[1802] = 'ER_MTA_CHANGE_SOURCE_CANT_RUN_WITH_GAPS';
exports[1803] = 'ER_MTA_RECOVERY_FAILURE';
exports[1804] = 'ER_MTA_RESET_WORKERS';
exports[1805] = 'ER_COL_COUNT_DOESNT_MATCH_CORRUPTED_V2';
exports[1806] = 'ER_REPLICA_SILENT_RETRY_TRANSACTION';
exports[1807] = 'ER_DISCARD_FK_CHECKS_RUNNING';
exports[1808] = 'ER_TABLE_SCHEMA_MISMATCH';
exports[1809] = 'ER_TABLE_IN_SYSTEM_TABLESPACE';
exports[1810] = 'ER_IO_READ_ERROR';
exports[1811] = 'ER_IO_WRITE_ERROR';
exports[1812] = 'ER_TABLESPACE_MISSING';
exports[1813] = 'ER_TABLESPACE_EXISTS';
exports[1814] = 'ER_TABLESPACE_DISCARDED';
exports[1815] = 'ER_INTERNAL_ERROR';
exports[1816] = 'ER_INNODB_IMPORT_ERROR';
exports[1817] = 'ER_INNODB_INDEX_CORRUPT';
exports[1818] = 'ER_INVALID_YEAR_COLUMN_LENGTH';
exports[1819] = 'ER_NOT_VALID_PASSWORD';
exports[1820] = 'ER_MUST_CHANGE_PASSWORD';
exports[1821] = 'ER_FK_NO_INDEX_CHILD';
exports[1822] = 'ER_FK_NO_INDEX_PARENT';
exports[1823] = 'ER_FK_FAIL_ADD_SYSTEM';
exports[1824] = 'ER_FK_CANNOT_OPEN_PARENT';
exports[1825] = 'ER_FK_INCORRECT_OPTION';
exports[1826] = 'ER_FK_DUP_NAME';
exports[1827] = 'ER_PASSWORD_FORMAT';
exports[1828] = 'ER_FK_COLUMN_CANNOT_DROP';
exports[1829] = 'ER_FK_COLUMN_CANNOT_DROP_CHILD';
exports[1830] = 'ER_FK_COLUMN_NOT_NULL';
exports[1831] = 'ER_DUP_INDEX';
exports[1832] = 'ER_FK_COLUMN_CANNOT_CHANGE';
exports[1833] = 'ER_FK_COLUMN_CANNOT_CHANGE_CHILD';
exports[1834] = 'ER_UNUSED5';
exports[1835] = 'ER_MALFORMED_PACKET';
exports[1836] = 'ER_READ_ONLY_MODE';
exports[1837] = 'ER_GTID_NEXT_TYPE_UNDEFINED_GTID';
exports[1838] = 'ER_VARIABLE_NOT_SETTABLE_IN_SP';
exports[1839] = 'ER_CANT_SET_GTID_PURGED_WHEN_GTID_MODE_IS_OFF';
exports[1840] = 'ER_CANT_SET_GTID_PURGED_WHEN_GTID_EXECUTED_IS_NOT_EMPTY';
exports[1841] = 'ER_CANT_SET_GTID_PURGED_WHEN_OWNED_GTIDS_IS_NOT_EMPTY';
exports[1842] = 'ER_GTID_PURGED_WAS_CHANGED';
exports[1843] = 'ER_GTID_EXECUTED_WAS_CHANGED';
exports[1844] = 'ER_BINLOG_STMT_MODE_AND_NO_REPL_TABLES';
exports[1845] = 'ER_ALTER_OPERATION_NOT_SUPPORTED';
exports[1846] = 'ER_ALTER_OPERATION_NOT_SUPPORTED_REASON';
exports[1847] = 'ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_COPY';
exports[1848] = 'ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_PARTITION';
exports[1849] = 'ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_FK_RENAME';
exports[1850] = 'ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_COLUMN_TYPE';
exports[1851] = 'ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_FK_CHECK';
exports[1852] = 'ER_UNUSED6';
exports[1853] = 'ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_NOPK';
exports[1854] = 'ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_AUTOINC';
exports[1855] = 'ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_HIDDEN_FTS';
exports[1856] = 'ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_CHANGE_FTS';
exports[1857] = 'ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_FTS';
exports[1858] = 'ER_SQL_REPLICA_SKIP_COUNTER_NOT_SETTABLE_IN_GTID_MODE';
exports[1859] = 'ER_DUP_UNKNOWN_IN_INDEX';
exports[1860] = 'ER_IDENT_CAUSES_TOO_LONG_PATH';
exports[1861] = 'ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_NOT_NULL';
exports[1862] = 'ER_MUST_CHANGE_PASSWORD_LOGIN';
exports[1863] = 'ER_ROW_IN_WRONG_PARTITION';
exports[1864] = 'ER_MTA_EVENT_BIGGER_PENDING_JOBS_SIZE_MAX';
exports[1865] = 'ER_INNODB_NO_FT_USES_PARSER';
exports[1866] = 'ER_BINLOG_LOGICAL_CORRUPTION';
exports[1867] = 'ER_WARN_PURGE_LOG_IN_USE';
exports[1868] = 'ER_WARN_PURGE_LOG_IS_ACTIVE';
exports[1869] = 'ER_AUTO_INCREMENT_CONFLICT';
exports[1870] = 'WARN_ON_BLOCKHOLE_IN_RBR';
exports[1871] = 'ER_REPLICA_CM_INIT_REPOSITORY';
exports[1872] = 'ER_REPLICA_AM_INIT_REPOSITORY';
exports[1873] = 'ER_ACCESS_DENIED_CHANGE_USER_ERROR';
exports[1874] = 'ER_INNODB_READ_ONLY';
exports[1875] = 'ER_STOP_REPLICA_SQL_THREAD_TIMEOUT';
exports[1876] = 'ER_STOP_REPLICA_IO_THREAD_TIMEOUT';
exports[1877] = 'ER_TABLE_CORRUPT';
exports[1878] = 'ER_TEMP_FILE_WRITE_FAILURE';
exports[1879] = 'ER_INNODB_FT_AUX_NOT_HEX_ID';
exports[1880] = 'ER_OLD_TEMPORALS_UPGRADED';
exports[1881] = 'ER_INNODB_FORCED_RECOVERY';
exports[1882] = 'ER_AES_INVALID_IV';
exports[1883] = 'ER_PLUGIN_CANNOT_BE_UNINSTALLED';
exports[1884] = 'ER_GTID_UNSAFE_BINLOG_SPLITTABLE_STATEMENT_AND_ASSIGNED_GTID';
exports[1885] = 'ER_REPLICA_HAS_MORE_GTIDS_THAN_SOURCE';
exports[1886] = 'ER_MISSING_KEY';
exports[1887] = 'WARN_NAMED_PIPE_ACCESS_EVERYONE';
exports[3000] = 'ER_FILE_CORRUPT';
exports[3001] = 'ER_ERROR_ON_SOURCE';
exports[3002] = 'ER_INCONSISTENT_ERROR';
exports[3003] = 'ER_STORAGE_ENGINE_NOT_LOADED';
exports[3004] = 'ER_GET_STACKED_DA_WITHOUT_ACTIVE_HANDLER';
exports[3005] = 'ER_WARN_LEGACY_SYNTAX_CONVERTED';
exports[3006] = 'ER_BINLOG_UNSAFE_FULLTEXT_PLUGIN';
exports[3007] = 'ER_CANNOT_DISCARD_TEMPORARY_TABLE';
exports[3008] = 'ER_FK_DEPTH_EXCEEDED';
exports[3009] = 'ER_COL_COUNT_DOESNT_MATCH_PLEASE_UPDATE_V2';
exports[3010] = 'ER_WARN_TRIGGER_DOESNT_HAVE_CREATED';
exports[3011] = 'ER_REFERENCED_TRG_DOES_NOT_EXIST';
exports[3012] = 'ER_EXPLAIN_NOT_SUPPORTED';
exports[3013] = 'ER_INVALID_FIELD_SIZE';
exports[3014] = 'ER_MISSING_HA_CREATE_OPTION';
exports[3015] = 'ER_ENGINE_OUT_OF_MEMORY';
exports[3016] = 'ER_PASSWORD_EXPIRE_ANONYMOUS_USER';
exports[3017] = 'ER_REPLICA_SQL_THREAD_MUST_STOP';
exports[3018] = 'ER_NO_FT_MATERIALIZED_SUBQUERY';
exports[3019] = 'ER_INNODB_UNDO_LOG_FULL';
exports[3020] = 'ER_INVALID_ARGUMENT_FOR_LOGARITHM';
exports[3021] = 'ER_REPLICA_CHANNEL_IO_THREAD_MUST_STOP';
exports[3022] = 'ER_WARN_OPEN_TEMP_TABLES_MUST_BE_ZERO';
exports[3023] = 'ER_WARN_ONLY_SOURCE_LOG_FILE_NO_POS';
exports[3024] = 'ER_QUERY_TIMEOUT';
exports[3025] = 'ER_NON_RO_SELECT_DISABLE_TIMER';
exports[3026] = 'ER_DUP_LIST_ENTRY';
exports[3027] = 'ER_SQL_MODE_NO_EFFECT';
exports[3028] = 'ER_AGGREGATE_ORDER_FOR_UNION';
exports[3029] = 'ER_AGGREGATE_ORDER_NON_AGG_QUERY';
exports[3030] = 'ER_REPLICA_WORKER_STOPPED_PREVIOUS_THD_ERROR';
exports[3031] = 'ER_DONT_SUPPORT_REPLICA_PRESERVE_COMMIT_ORDER';
exports[3032] = 'ER_SERVER_OFFLINE_MODE';
exports[3033] = 'ER_GIS_DIFFERENT_SRIDS';
exports[3034] = 'ER_GIS_UNSUPPORTED_ARGUMENT';
exports[3035] = 'ER_GIS_UNKNOWN_ERROR';
exports[3036] = 'ER_GIS_UNKNOWN_EXCEPTION';
exports[3037] = 'ER_GIS_INVALID_DATA';
exports[3038] = 'ER_BOOST_GEOMETRY_EMPTY_INPUT_EXCEPTION';
exports[3039] = 'ER_BOOST_GEOMETRY_CENTROID_EXCEPTION';
exports[3040] = 'ER_BOOST_GEOMETRY_OVERLAY_INVALID_INPUT_EXCEPTION';
exports[3041] = 'ER_BOOST_GEOMETRY_TURN_INFO_EXCEPTION';
exports[3042] = 'ER_BOOST_GEOMETRY_SELF_INTERSECTION_POINT_EXCEPTION';
exports[3043] = 'ER_BOOST_GEOMETRY_UNKNOWN_EXCEPTION';
exports[3044] = 'ER_STD_BAD_ALLOC_ERROR';
exports[3045] = 'ER_STD_DOMAIN_ERROR';
exports[3046] = 'ER_STD_LENGTH_ERROR';
exports[3047] = 'ER_STD_INVALID_ARGUMENT';
exports[3048] = 'ER_STD_OUT_OF_RANGE_ERROR';
exports[3049] = 'ER_STD_OVERFLOW_ERROR';
exports[3050] = 'ER_STD_RANGE_ERROR';
exports[3051] = 'ER_STD_UNDERFLOW_ERROR';
exports[3052] = 'ER_STD_LOGIC_ERROR';
exports[3053] = 'ER_STD_RUNTIME_ERROR';
exports[3054] = 'ER_STD_UNKNOWN_EXCEPTION';
exports[3055] = 'ER_GIS_DATA_WRONG_ENDIANESS';
exports[3056] = 'ER_CHANGE_SOURCE_PASSWORD_LENGTH';
exports[3057] = 'ER_USER_LOCK_WRONG_NAME';
exports[3058] = 'ER_USER_LOCK_DEADLOCK';
exports[3059] = 'ER_REPLACE_INACCESSIBLE_ROWS';
exports[3060] = 'ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_GIS';
exports[3061] = 'ER_ILLEGAL_USER_VAR';
exports[3062] = 'ER_GTID_MODE_OFF';
exports[3063] = 'ER_UNSUPPORTED_BY_REPLICATION_THREAD';
exports[3064] = 'ER_INCORRECT_TYPE';
exports[3065] = 'ER_FIELD_IN_ORDER_NOT_SELECT';
exports[3066] = 'ER_AGGREGATE_IN_ORDER_NOT_SELECT';
exports[3067] = 'ER_INVALID_RPL_WILD_TABLE_FILTER_PATTERN';
exports[3068] = 'ER_NET_OK_PACKET_TOO_LARGE';
exports[3069] = 'ER_INVALID_JSON_DATA';
exports[3070] = 'ER_INVALID_GEOJSON_MISSING_MEMBER';
exports[3071] = 'ER_INVALID_GEOJSON_WRONG_TYPE';
exports[3072] = 'ER_INVALID_GEOJSON_UNSPECIFIED';
exports[3073] = 'ER_DIMENSION_UNSUPPORTED';
exports[3074] = 'ER_REPLICA_CHANNEL_DOES_NOT_EXIST';
exports[3075] = 'ER_SLAVE_MULTIPLE_CHANNELS_HOST_PORT';
exports[3076] = 'ER_REPLICA_CHANNEL_NAME_INVALID_OR_TOO_LONG';
exports[3077] = 'ER_REPLICA_NEW_CHANNEL_WRONG_REPOSITORY';
exports[3078] = 'ER_SLAVE_CHANNEL_DELETE';
exports[3079] = 'ER_REPLICA_MULTIPLE_CHANNELS_CMD';
exports[3080] = 'ER_REPLICA_MAX_CHANNELS_EXCEEDED';
exports[3081] = 'ER_REPLICA_CHANNEL_MUST_STOP';
exports[3082] = 'ER_REPLICA_CHANNEL_NOT_RUNNING';
exports[3083] = 'ER_REPLICA_CHANNEL_WAS_RUNNING';
exports[3084] = 'ER_REPLICA_CHANNEL_WAS_NOT_RUNNING';
exports[3085] = 'ER_REPLICA_CHANNEL_SQL_THREAD_MUST_STOP';
exports[3086] = 'ER_REPLICA_CHANNEL_SQL_SKIP_COUNTER';
exports[3087] = 'ER_WRONG_FIELD_WITH_GROUP_V2';
exports[3088] = 'ER_MIX_OF_GROUP_FUNC_AND_FIELDS_V2';
exports[3089] = 'ER_WARN_DEPRECATED_SYSVAR_UPDATE';
exports[3090] = 'ER_WARN_DEPRECATED_SQLMODE';
exports[3091] = 'ER_CANNOT_LOG_PARTIAL_DROP_DATABASE_WITH_GTID';
exports[3092] = 'ER_GROUP_REPLICATION_CONFIGURATION';
exports[3093] = 'ER_GROUP_REPLICATION_RUNNING';
exports[3094] = 'ER_GROUP_REPLICATION_APPLIER_INIT_ERROR';
exports[3095] = 'ER_GROUP_REPLICATION_STOP_APPLIER_THREAD_TIMEOUT';
exports[3096] = 'ER_GROUP_REPLICATION_COMMUNICATION_LAYER_SESSION_ERROR';
exports[3097] = 'ER_GROUP_REPLICATION_COMMUNICATION_LAYER_JOIN_ERROR';
exports[3098] = 'ER_BEFORE_DML_VALIDATION_ERROR';
exports[3099] = 'ER_PREVENTS_VARIABLE_WITHOUT_RBR';
exports[3100] = 'ER_RUN_HOOK_ERROR';
exports[3101] = 'ER_TRANSACTION_ROLLBACK_DURING_COMMIT';
exports[3102] = 'ER_GENERATED_COLUMN_FUNCTION_IS_NOT_ALLOWED';
exports[3103] = 'ER_UNSUPPORTED_ALTER_INPLACE_ON_VIRTUAL_COLUMN';
exports[3104] = 'ER_WRONG_FK_OPTION_FOR_GENERATED_COLUMN';
exports[3105] = 'ER_NON_DEFAULT_VALUE_FOR_GENERATED_COLUMN';
exports[3106] = 'ER_UNSUPPORTED_ACTION_ON_GENERATED_COLUMN';
exports[3107] = 'ER_GENERATED_COLUMN_NON_PRIOR';
exports[3108] = 'ER_DEPENDENT_BY_GENERATED_COLUMN';
exports[3109] = 'ER_GENERATED_COLUMN_REF_AUTO_INC';
exports[3110] = 'ER_FEATURE_NOT_AVAILABLE';
exports[3111] = 'ER_CANT_SET_GTID_MODE';
exports[3112] = 'ER_CANT_USE_AUTO_POSITION_WITH_GTID_MODE_OFF';
exports[3113] = 'ER_CANT_REPLICATE_ANONYMOUS_WITH_AUTO_POSITION';
exports[3114] = 'ER_CANT_REPLICATE_ANONYMOUS_WITH_GTID_MODE_ON';
exports[3115] = 'ER_CANT_REPLICATE_GTID_WITH_GTID_MODE_OFF';
exports[3116] =
  'ER_CANT_ENFORCE_GTID_CONSISTENCY_WITH_ONGOING_GTID_VIOLATING_TX';
exports[3117] =
  'ER_ENFORCE_GTID_CONSISTENCY_WARN_WITH_ONGOING_GTID_VIOLATING_TX';
exports[3118] = 'ER_ACCOUNT_HAS_BEEN_LOCKED';
exports[3119] = 'ER_WRONG_TABLESPACE_NAME';
exports[3120] = 'ER_TABLESPACE_IS_NOT_EMPTY';
exports[3121] = 'ER_WRONG_FILE_NAME';
exports[3122] = 'ER_BOOST_GEOMETRY_INCONSISTENT_TURNS_EXCEPTION';
exports[3123] = 'ER_WARN_OPTIMIZER_HINT_SYNTAX_ERROR';
exports[3124] = 'ER_WARN_BAD_MAX_EXECUTION_TIME';
exports[3125] = 'ER_WARN_UNSUPPORTED_MAX_EXECUTION_TIME';
exports[3126] = 'ER_WARN_CONFLICTING_HINT';
exports[3127] = 'ER_WARN_UNKNOWN_QB_NAME';
exports[3128] = 'ER_UNRESOLVED_HINT_NAME';
exports[3129] = 'ER_WARN_ON_MODIFYING_GTID_EXECUTED_TABLE';
exports[3130] = 'ER_PLUGGABLE_PROTOCOL_COMMAND_NOT_SUPPORTED';
exports[3131] = 'ER_LOCKING_SERVICE_WRONG_NAME';
exports[3132] = 'ER_LOCKING_SERVICE_DEADLOCK';
exports[3133] = 'ER_LOCKING_SERVICE_TIMEOUT';
exports[3134] = 'ER_GIS_MAX_POINTS_IN_GEOMETRY_OVERFLOWED';
exports[3135] = 'ER_SQL_MODE_MERGED';
exports[3136] = 'ER_VTOKEN_PLUGIN_TOKEN_MISMATCH';
exports[3137] = 'ER_VTOKEN_PLUGIN_TOKEN_NOT_FOUND';
exports[3138] = 'ER_CANT_SET_VARIABLE_WHEN_OWNING_GTID';
exports[3139] = 'ER_REPLICA_CHANNEL_OPERATION_NOT_ALLOWED';
exports[3140] = 'ER_INVALID_JSON_TEXT';
exports[3141] = 'ER_INVALID_JSON_TEXT_IN_PARAM';
exports[3142] = 'ER_INVALID_JSON_BINARY_DATA';
exports[3143] = 'ER_INVALID_JSON_PATH';
exports[3144] = 'ER_INVALID_JSON_CHARSET';
exports[3145] = 'ER_INVALID_JSON_CHARSET_IN_FUNCTION';
exports[3146] = 'ER_INVALID_TYPE_FOR_JSON';
exports[3147] = 'ER_INVALID_CAST_TO_JSON';
exports[3148] = 'ER_INVALID_JSON_PATH_CHARSET';
exports[3149] = 'ER_INVALID_JSON_PATH_WILDCARD';
exports[3150] = 'ER_JSON_VALUE_TOO_BIG';
exports[3151] = 'ER_JSON_KEY_TOO_BIG';
exports[3152] = 'ER_JSON_USED_AS_KEY';
exports[3153] = 'ER_JSON_VACUOUS_PATH';
exports[3154] = 'ER_JSON_BAD_ONE_OR_ALL_ARG';
exports[3155] = 'ER_NUMERIC_JSON_VALUE_OUT_OF_RANGE';
exports[3156] = 'ER_INVALID_JSON_VALUE_FOR_CAST';
exports[3157] = 'ER_JSON_DOCUMENT_TOO_DEEP';
exports[3158] = 'ER_JSON_DOCUMENT_NULL_KEY';
exports[3159] = 'ER_SECURE_TRANSPORT_REQUIRED';
exports[3160] = 'ER_NO_SECURE_TRANSPORTS_CONFIGURED';
exports[3161] = 'ER_DISABLED_STORAGE_ENGINE';
exports[3162] = 'ER_USER_DOES_NOT_EXIST';
exports[3163] = 'ER_USER_ALREADY_EXISTS';
exports[3164] = 'ER_AUDIT_API_ABORT';
exports[3165] = 'ER_INVALID_JSON_PATH_ARRAY_CELL';
exports[3166] = 'ER_BUFPOOL_RESIZE_INPROGRESS';
exports[3167] = 'ER_FEATURE_DISABLED_SEE_DOC';
exports[3168] = 'ER_SERVER_ISNT_AVAILABLE';
exports[3169] = 'ER_SESSION_WAS_KILLED';
exports[3170] = 'ER_CAPACITY_EXCEEDED';
exports[3171] = 'ER_CAPACITY_EXCEEDED_IN_RANGE_OPTIMIZER';
exports[3172] = 'ER_TABLE_NEEDS_UPG_PART';
exports[3173] = 'ER_CANT_WAIT_FOR_EXECUTED_GTID_SET_WHILE_OWNING_A_GTID';
exports[3174] = 'ER_CANNOT_ADD_FOREIGN_BASE_COL_VIRTUAL';
exports[3175] = 'ER_CANNOT_CREATE_VIRTUAL_INDEX_CONSTRAINT';
exports[3176] = 'ER_ERROR_ON_MODIFYING_GTID_EXECUTED_TABLE';
exports[3177] = 'ER_LOCK_REFUSED_BY_ENGINE';
exports[3178] = 'ER_UNSUPPORTED_ALTER_ONLINE_ON_VIRTUAL_COLUMN';
exports[3179] = 'ER_MASTER_KEY_ROTATION_NOT_SUPPORTED_BY_SE';
exports[3180] = 'ER_MASTER_KEY_ROTATION_ERROR_BY_SE';
exports[3181] = 'ER_MASTER_KEY_ROTATION_BINLOG_FAILED';
exports[3182] = 'ER_MASTER_KEY_ROTATION_SE_UNAVAILABLE';
exports[3183] = 'ER_TABLESPACE_CANNOT_ENCRYPT';
exports[3184] = 'ER_INVALID_ENCRYPTION_OPTION';
exports[3185] = 'ER_CANNOT_FIND_KEY_IN_KEYRING';
exports[3186] = 'ER_CAPACITY_EXCEEDED_IN_PARSER';
exports[3187] = 'ER_UNSUPPORTED_ALTER_ENCRYPTION_INPLACE';
exports[3188] = 'ER_KEYRING_UDF_KEYRING_SERVICE_ERROR';
exports[3189] = 'ER_USER_COLUMN_OLD_LENGTH';
exports[3190] = 'ER_CANT_RESET_SOURCE';
exports[3191] = 'ER_GROUP_REPLICATION_MAX_GROUP_SIZE';
exports[3192] = 'ER_CANNOT_ADD_FOREIGN_BASE_COL_STORED';
exports[3193] = 'ER_TABLE_REFERENCED';
exports[3194] = 'ER_PARTITION_ENGINE_DEPRECATED_FOR_TABLE';
exports[3195] = 'ER_WARN_USING_GEOMFROMWKB_TO_SET_SRID_ZERO';
exports[3196] = 'ER_WARN_USING_GEOMFROMWKB_TO_SET_SRID';
exports[3197] = 'ER_XA_RETRY';
exports[3198] = 'ER_KEYRING_AWS_UDF_AWS_KMS_ERROR';
exports[3199] = 'ER_BINLOG_UNSAFE_XA';
exports[3200] = 'ER_UDF_ERROR';
exports[3201] = 'ER_KEYRING_MIGRATION_FAILURE';
exports[3202] = 'ER_KEYRING_ACCESS_DENIED_ERROR';
exports[3203] = 'ER_KEYRING_MIGRATION_STATUS';
exports[3204] = 'ER_PLUGIN_FAILED_TO_OPEN_TABLES';
exports[3205] = 'ER_PLUGIN_FAILED_TO_OPEN_TABLE';
exports[3206] = 'ER_AUDIT_LOG_NO_KEYRING_PLUGIN_INSTALLED';
exports[3207] = 'ER_AUDIT_LOG_ENCRYPTION_PASSWORD_HAS_NOT_BEEN_SET';
exports[3208] = 'ER_AUDIT_LOG_COULD_NOT_CREATE_AES_KEY';
exports[3209] = 'ER_AUDIT_LOG_ENCRYPTION_PASSWORD_CANNOT_BE_FETCHED';
exports[3210] = 'ER_AUDIT_LOG_JSON_FILTERING_NOT_ENABLED';
exports[3211] = 'ER_AUDIT_LOG_UDF_INSUFFICIENT_PRIVILEGE';
exports[3212] = 'ER_AUDIT_LOG_SUPER_PRIVILEGE_REQUIRED';
exports[3213] = 'ER_COULD_NOT_REINITIALIZE_AUDIT_LOG_FILTERS';
exports[3214] = 'ER_AUDIT_LOG_UDF_INVALID_ARGUMENT_TYPE';
exports[3215] = 'ER_AUDIT_LOG_UDF_INVALID_ARGUMENT_COUNT';
exports[3216] = 'ER_AUDIT_LOG_HAS_NOT_BEEN_INSTALLED';
exports[3217] = 'ER_AUDIT_LOG_UDF_READ_INVALID_MAX_ARRAY_LENGTH_ARG_TYPE';
exports[3218] = 'ER_AUDIT_LOG_UDF_READ_INVALID_MAX_ARRAY_LENGTH_ARG_VALUE';
exports[3219] = 'ER_AUDIT_LOG_JSON_FILTER_PARSING_ERROR';
exports[3220] = 'ER_AUDIT_LOG_JSON_FILTER_NAME_CANNOT_BE_EMPTY';
exports[3221] = 'ER_AUDIT_LOG_JSON_USER_NAME_CANNOT_BE_EMPTY';
exports[3222] = 'ER_AUDIT_LOG_JSON_FILTER_DOES_NOT_EXISTS';
exports[3223] = 'ER_AUDIT_LOG_USER_FIRST_CHARACTER_MUST_BE_ALPHANUMERIC';
exports[3224] = 'ER_AUDIT_LOG_USER_NAME_INVALID_CHARACTER';
exports[3225] = 'ER_AUDIT_LOG_HOST_NAME_INVALID_CHARACTER';
exports[3226] = 'WARN_DEPRECATED_MAXDB_SQL_MODE_FOR_TIMESTAMP';
exports[3227] = 'ER_XA_REPLICATION_FILTERS';
exports[3228] = 'ER_CANT_OPEN_ERROR_LOG';
exports[3229] = 'ER_GROUPING_ON_TIMESTAMP_IN_DST';
exports[3230] = 'ER_CANT_START_SERVER_NAMED_PIPE';
exports[3231] = 'ER_WRITE_SET_EXCEEDS_LIMIT';
exports[3232] = 'ER_DEPRECATED_TLS_VERSION_SESSION_57';
exports[3233] = 'ER_WARN_DEPRECATED_TLS_VERSION_57';
exports[3234] = 'ER_WARN_WRONG_NATIVE_TABLE_STRUCTURE';
exports[3235] = 'ER_AES_INVALID_KDF_NAME';
exports[3236] = 'ER_AES_INVALID_KDF_ITERATIONS';
exports[3237] = 'WARN_AES_KEY_SIZE';
exports[3238] = 'ER_AES_INVALID_KDF_OPTION_SIZE';
exports[3500] = 'ER_UNSUPPORT_COMPRESSED_TEMPORARY_TABLE';
exports[3501] = 'ER_ACL_OPERATION_FAILED';
exports[3502] = 'ER_UNSUPPORTED_INDEX_ALGORITHM';
exports[3503] = 'ER_NO_SUCH_DB';
exports[3504] = 'ER_TOO_BIG_ENUM';
exports[3505] = 'ER_TOO_LONG_SET_ENUM_VALUE';
exports[3506] = 'ER_INVALID_DD_OBJECT';
exports[3507] = 'ER_UPDATING_DD_TABLE';
exports[3508] = 'ER_INVALID_DD_OBJECT_ID';
exports[3509] = 'ER_INVALID_DD_OBJECT_NAME';
exports[3510] = 'ER_TABLESPACE_MISSING_WITH_NAME';
exports[3511] = 'ER_TOO_LONG_ROUTINE_COMMENT';
exports[3512] = 'ER_SP_LOAD_FAILED';
exports[3513] = 'ER_INVALID_BITWISE_OPERANDS_SIZE';
exports[3514] = 'ER_INVALID_BITWISE_AGGREGATE_OPERANDS_SIZE';
exports[3515] = 'ER_WARN_UNSUPPORTED_HINT';
exports[3516] = 'ER_UNEXPECTED_GEOMETRY_TYPE';
exports[3517] = 'ER_SRS_PARSE_ERROR';
exports[3518] = 'ER_SRS_PROJ_PARAMETER_MISSING';
exports[3519] = 'ER_WARN_SRS_NOT_FOUND';
exports[3520] = 'ER_SRS_NOT_CARTESIAN';
exports[3521] = 'ER_SRS_NOT_CARTESIAN_UNDEFINED';
exports[3522] = 'ER_PK_INDEX_CANT_BE_INVISIBLE';
exports[3523] = 'ER_UNKNOWN_AUTHID';
exports[3524] = 'ER_FAILED_ROLE_GRANT';
exports[3525] = 'ER_OPEN_ROLE_TABLES';
exports[3526] = 'ER_FAILED_DEFAULT_ROLES';
exports[3527] = 'ER_COMPONENTS_NO_SCHEME';
exports[3528] = 'ER_COMPONENTS_NO_SCHEME_SERVICE';
exports[3529] = 'ER_COMPONENTS_CANT_LOAD';
exports[3530] = 'ER_ROLE_NOT_GRANTED';
exports[3531] = 'ER_FAILED_REVOKE_ROLE';
exports[3532] = 'ER_RENAME_ROLE';
exports[3533] = 'ER_COMPONENTS_CANT_ACQUIRE_SERVICE_IMPLEMENTATION';
exports[3534] = 'ER_COMPONENTS_CANT_SATISFY_DEPENDENCY';
exports[3535] = 'ER_COMPONENTS_LOAD_CANT_REGISTER_SERVICE_IMPLEMENTATION';
exports[3536] = 'ER_COMPONENTS_LOAD_CANT_INITIALIZE';
exports[3537] = 'ER_COMPONENTS_UNLOAD_NOT_LOADED';
exports[3538] = 'ER_COMPONENTS_UNLOAD_CANT_DEINITIALIZE';
exports[3539] = 'ER_COMPONENTS_CANT_RELEASE_SERVICE';
exports[3540] = 'ER_COMPONENTS_UNLOAD_CANT_UNREGISTER_SERVICE';
exports[3541] = 'ER_COMPONENTS_CANT_UNLOAD';
exports[3542] = 'ER_WARN_UNLOAD_THE_NOT_PERSISTED';
exports[3543] = 'ER_COMPONENT_TABLE_INCORRECT';
exports[3544] = 'ER_COMPONENT_MANIPULATE_ROW_FAILED';
exports[3545] = 'ER_COMPONENTS_UNLOAD_DUPLICATE_IN_GROUP';
exports[3546] = 'ER_CANT_SET_GTID_PURGED_DUE_SETS_CONSTRAINTS';
exports[3547] = 'ER_CANNOT_LOCK_USER_MANAGEMENT_CACHES';
exports[3548] = 'ER_SRS_NOT_FOUND';
exports[3549] = 'ER_VARIABLE_NOT_PERSISTED';
exports[3550] = 'ER_IS_QUERY_INVALID_CLAUSE';
exports[3551] = 'ER_UNABLE_TO_STORE_STATISTICS';
exports[3552] = 'ER_NO_SYSTEM_SCHEMA_ACCESS';
exports[3553] = 'ER_NO_SYSTEM_TABLESPACE_ACCESS';
exports[3554] = 'ER_NO_SYSTEM_TABLE_ACCESS';
exports[3555] = 'ER_NO_SYSTEM_TABLE_ACCESS_FOR_DICTIONARY_TABLE';
exports[3556] = 'ER_NO_SYSTEM_TABLE_ACCESS_FOR_SYSTEM_TABLE';
exports[3557] = 'ER_NO_SYSTEM_TABLE_ACCESS_FOR_TABLE';
exports[3558] = 'ER_INVALID_OPTION_KEY';
exports[3559] = 'ER_INVALID_OPTION_VALUE';
exports[3560] = 'ER_INVALID_OPTION_KEY_VALUE_PAIR';
exports[3561] = 'ER_INVALID_OPTION_START_CHARACTER';
exports[3562] = 'ER_INVALID_OPTION_END_CHARACTER';
exports[3563] = 'ER_INVALID_OPTION_CHARACTERS';
exports[3564] = 'ER_DUPLICATE_OPTION_KEY';
exports[3565] = 'ER_WARN_SRS_NOT_FOUND_AXIS_ORDER';
exports[3566] = 'ER_NO_ACCESS_TO_NATIVE_FCT';
exports[3567] = 'ER_RESET_SOURCE_TO_VALUE_OUT_OF_RANGE';
exports[3568] = 'ER_UNRESOLVED_TABLE_LOCK';
exports[3569] = 'ER_DUPLICATE_TABLE_LOCK';
exports[3570] = 'ER_BINLOG_UNSAFE_SKIP_LOCKED';
exports[3571] = 'ER_BINLOG_UNSAFE_NOWAIT';
exports[3572] = 'ER_LOCK_NOWAIT';
exports[3573] = 'ER_CTE_RECURSIVE_REQUIRES_UNION';
exports[3574] = 'ER_CTE_RECURSIVE_REQUIRES_NONRECURSIVE_FIRST';
exports[3575] = 'ER_CTE_RECURSIVE_FORBIDS_AGGREGATION';
exports[3576] = 'ER_CTE_RECURSIVE_FORBIDDEN_JOIN_ORDER';
exports[3577] = 'ER_CTE_RECURSIVE_REQUIRES_SINGLE_REFERENCE';
exports[3578] = 'ER_SWITCH_TMP_ENGINE';
exports[3579] = 'ER_WINDOW_NO_SUCH_WINDOW';
exports[3580] = 'ER_WINDOW_CIRCULARITY_IN_WINDOW_GRAPH';
exports[3581] = 'ER_WINDOW_NO_CHILD_PARTITIONING';
exports[3582] = 'ER_WINDOW_NO_INHERIT_FRAME';
exports[3583] = 'ER_WINDOW_NO_REDEFINE_ORDER_BY';
exports[3584] = 'ER_WINDOW_FRAME_START_ILLEGAL';
exports[3585] = 'ER_WINDOW_FRAME_END_ILLEGAL';
exports[3586] = 'ER_WINDOW_FRAME_ILLEGAL';
exports[3587] = 'ER_WINDOW_RANGE_FRAME_ORDER_TYPE';
exports[3588] = 'ER_WINDOW_RANGE_FRAME_TEMPORAL_TYPE';
exports[3589] = 'ER_WINDOW_RANGE_FRAME_NUMERIC_TYPE';
exports[3590] = 'ER_WINDOW_RANGE_BOUND_NOT_CONSTANT';
exports[3591] = 'ER_WINDOW_DUPLICATE_NAME';
exports[3592] = 'ER_WINDOW_ILLEGAL_ORDER_BY';
exports[3593] = 'ER_WINDOW_INVALID_WINDOW_FUNC_USE';
exports[3594] = 'ER_WINDOW_INVALID_WINDOW_FUNC_ALIAS_USE';
exports[3595] = 'ER_WINDOW_NESTED_WINDOW_FUNC_USE_IN_WINDOW_SPEC';
exports[3596] = 'ER_WINDOW_ROWS_INTERVAL_USE';
exports[3597] = 'ER_WINDOW_NO_GROUP_ORDER';
exports[3598] = 'ER_WINDOW_EXPLAIN_JSON';
exports[3599] = 'ER_WINDOW_FUNCTION_IGNORES_FRAME';
exports[3600] = 'ER_WL9236_NOW';
exports[3601] = 'ER_INVALID_NO_OF_ARGS';
exports[3602] = 'ER_FIELD_IN_GROUPING_NOT_GROUP_BY';
exports[3603] = 'ER_TOO_LONG_TABLESPACE_COMMENT';
exports[3604] = 'ER_ENGINE_CANT_DROP_TABLE';
exports[3605] = 'ER_ENGINE_CANT_DROP_MISSING_TABLE';
exports[3606] = 'ER_TABLESPACE_DUP_FILENAME';
exports[3607] = 'ER_DB_DROP_RMDIR2';
exports[3608] = 'ER_IMP_NO_FILES_MATCHED';
exports[3609] = 'ER_IMP_SCHEMA_DOES_NOT_EXIST';
exports[3610] = 'ER_IMP_TABLE_ALREADY_EXISTS';
exports[3611] = 'ER_IMP_INCOMPATIBLE_MYSQLD_VERSION';
exports[3612] = 'ER_IMP_INCOMPATIBLE_DD_VERSION';
exports[3613] = 'ER_IMP_INCOMPATIBLE_SDI_VERSION';
exports[3614] = 'ER_WARN_INVALID_HINT';
exports[3615] = 'ER_VAR_DOES_NOT_EXIST';
exports[3616] = 'ER_LONGITUDE_OUT_OF_RANGE';
exports[3617] = 'ER_LATITUDE_OUT_OF_RANGE';
exports[3618] = 'ER_NOT_IMPLEMENTED_FOR_GEOGRAPHIC_SRS';
exports[3619] = 'ER_ILLEGAL_PRIVILEGE_LEVEL';
exports[3620] = 'ER_NO_SYSTEM_VIEW_ACCESS';
exports[3621] = 'ER_COMPONENT_FILTER_FLABBERGASTED';
exports[3622] = 'ER_PART_EXPR_TOO_LONG';
exports[3623] = 'ER_UDF_DROP_DYNAMICALLY_REGISTERED';
exports[3624] = 'ER_UNABLE_TO_STORE_COLUMN_STATISTICS';
exports[3625] = 'ER_UNABLE_TO_UPDATE_COLUMN_STATISTICS';
exports[3626] = 'ER_UNABLE_TO_DROP_COLUMN_STATISTICS';
exports[3627] = 'ER_UNABLE_TO_BUILD_HISTOGRAM';
exports[3628] = 'ER_MANDATORY_ROLE';
exports[3629] = 'ER_MISSING_TABLESPACE_FILE';
exports[3630] = 'ER_PERSIST_ONLY_ACCESS_DENIED_ERROR';
exports[3631] = 'ER_CMD_NEED_SUPER';
exports[3632] = 'ER_PATH_IN_DATADIR';
exports[3633] = 'ER_CLONE_DDL_IN_PROGRESS';
exports[3634] = 'ER_CLONE_TOO_MANY_CONCURRENT_CLONES';
exports[3635] = 'ER_APPLIER_LOG_EVENT_VALIDATION_ERROR';
exports[3636] = 'ER_CTE_MAX_RECURSION_DEPTH';
exports[3637] = 'ER_NOT_HINT_UPDATABLE_VARIABLE';
exports[3638] = 'ER_CREDENTIALS_CONTRADICT_TO_HISTORY';
exports[3639] = 'ER_WARNING_PASSWORD_HISTORY_CLAUSES_VOID';
exports[3640] = 'ER_CLIENT_DOES_NOT_SUPPORT';
exports[3641] = 'ER_I_S_SKIPPED_TABLESPACE';
exports[3642] = 'ER_TABLESPACE_ENGINE_MISMATCH';
exports[3643] = 'ER_WRONG_SRID_FOR_COLUMN';
exports[3644] = 'ER_CANNOT_ALTER_SRID_DUE_TO_INDEX';
exports[3645] = 'ER_WARN_BINLOG_PARTIAL_UPDATES_DISABLED';
exports[3646] = 'ER_WARN_BINLOG_V1_ROW_EVENTS_DISABLED';
exports[3647] = 'ER_WARN_BINLOG_PARTIAL_UPDATES_SUGGESTS_PARTIAL_IMAGES';
exports[3648] = 'ER_COULD_NOT_APPLY_JSON_DIFF';
exports[3649] = 'ER_CORRUPTED_JSON_DIFF';
exports[3650] = 'ER_RESOURCE_GROUP_EXISTS';
exports[3651] = 'ER_RESOURCE_GROUP_NOT_EXISTS';
exports[3652] = 'ER_INVALID_VCPU_ID';
exports[3653] = 'ER_INVALID_VCPU_RANGE';
exports[3654] = 'ER_INVALID_THREAD_PRIORITY';
exports[3655] = 'ER_DISALLOWED_OPERATION';
exports[3656] = 'ER_RESOURCE_GROUP_BUSY';
exports[3657] = 'ER_RESOURCE_GROUP_DISABLED';
exports[3658] = 'ER_FEATURE_UNSUPPORTED';
exports[3659] = 'ER_ATTRIBUTE_IGNORED';
exports[3660] = 'ER_INVALID_THREAD_ID';
exports[3661] = 'ER_RESOURCE_GROUP_BIND_FAILED';
exports[3662] = 'ER_INVALID_USE_OF_FORCE_OPTION';
exports[3663] = 'ER_GROUP_REPLICATION_COMMAND_FAILURE';
exports[3664] = 'ER_SDI_OPERATION_FAILED';
exports[3665] = 'ER_MISSING_JSON_TABLE_VALUE';
exports[3666] = 'ER_WRONG_JSON_TABLE_VALUE';
exports[3667] = 'ER_TF_MUST_HAVE_ALIAS';
exports[3668] = 'ER_TF_FORBIDDEN_JOIN_TYPE';
exports[3669] = 'ER_JT_VALUE_OUT_OF_RANGE';
exports[3670] = 'ER_JT_MAX_NESTED_PATH';
exports[3671] = 'ER_PASSWORD_EXPIRATION_NOT_SUPPORTED_BY_AUTH_METHOD';
exports[3672] = 'ER_INVALID_GEOJSON_CRS_NOT_TOP_LEVEL';
exports[3673] = 'ER_BAD_NULL_ERROR_NOT_IGNORED';
exports[3674] = 'WARN_USELESS_SPATIAL_INDEX';
exports[3675] = 'ER_DISK_FULL_NOWAIT';
exports[3676] = 'ER_PARSE_ERROR_IN_DIGEST_FN';
exports[3677] = 'ER_UNDISCLOSED_PARSE_ERROR_IN_DIGEST_FN';
exports[3678] = 'ER_SCHEMA_DIR_EXISTS';
exports[3679] = 'ER_SCHEMA_DIR_MISSING';
exports[3680] = 'ER_SCHEMA_DIR_CREATE_FAILED';
exports[3681] = 'ER_SCHEMA_DIR_UNKNOWN';
exports[3682] = 'ER_ONLY_IMPLEMENTED_FOR_SRID_0_AND_4326';
exports[3683] = 'ER_BINLOG_EXPIRE_LOG_DAYS_AND_SECS_USED_TOGETHER';
exports[3684] = 'ER_REGEXP_BUFFER_OVERFLOW';
exports[3685] = 'ER_REGEXP_ILLEGAL_ARGUMENT';
exports[3686] = 'ER_REGEXP_INDEX_OUTOFBOUNDS_ERROR';
exports[3687] = 'ER_REGEXP_INTERNAL_ERROR';
exports[3688] = 'ER_REGEXP_RULE_SYNTAX';
exports[3689] = 'ER_REGEXP_BAD_ESCAPE_SEQUENCE';
exports[3690] = 'ER_REGEXP_UNIMPLEMENTED';
exports[3691] = 'ER_REGEXP_MISMATCHED_PAREN';
exports[3692] = 'ER_REGEXP_BAD_INTERVAL';
exports[3693] = 'ER_REGEXP_MAX_LT_MIN';
exports[3694] = 'ER_REGEXP_INVALID_BACK_REF';
exports[3695] = 'ER_REGEXP_LOOK_BEHIND_LIMIT';
exports[3696] = 'ER_REGEXP_MISSING_CLOSE_BRACKET';
exports[3697] = 'ER_REGEXP_INVALID_RANGE';
exports[3698] = 'ER_REGEXP_STACK_OVERFLOW';
exports[3699] = 'ER_REGEXP_TIME_OUT';
exports[3700] = 'ER_REGEXP_PATTERN_TOO_BIG';
exports[3701] = 'ER_CANT_SET_ERROR_LOG_SERVICE';
exports[3702] = 'ER_EMPTY_PIPELINE_FOR_ERROR_LOG_SERVICE';
exports[3703] = 'ER_COMPONENT_FILTER_DIAGNOSTICS';
exports[3704] = 'ER_NOT_IMPLEMENTED_FOR_CARTESIAN_SRS';
exports[3705] = 'ER_NOT_IMPLEMENTED_FOR_PROJECTED_SRS';
exports[3706] = 'ER_NONPOSITIVE_RADIUS';
exports[3707] = 'ER_RESTART_SERVER_FAILED';
exports[3708] = 'ER_SRS_MISSING_MANDATORY_ATTRIBUTE';
exports[3709] = 'ER_SRS_MULTIPLE_ATTRIBUTE_DEFINITIONS';
exports[3710] = 'ER_SRS_NAME_CANT_BE_EMPTY_OR_WHITESPACE';
exports[3711] = 'ER_SRS_ORGANIZATION_CANT_BE_EMPTY_OR_WHITESPACE';
exports[3712] = 'ER_SRS_ID_ALREADY_EXISTS';
exports[3713] = 'ER_WARN_SRS_ID_ALREADY_EXISTS';
exports[3714] = 'ER_CANT_MODIFY_SRID_0';
exports[3715] = 'ER_WARN_RESERVED_SRID_RANGE';
exports[3716] = 'ER_CANT_MODIFY_SRS_USED_BY_COLUMN';
exports[3717] = 'ER_SRS_INVALID_CHARACTER_IN_ATTRIBUTE';
exports[3718] = 'ER_SRS_ATTRIBUTE_STRING_TOO_LONG';
exports[3719] = 'ER_DEPRECATED_UTF8_ALIAS';
exports[3720] = 'ER_DEPRECATED_NATIONAL';
exports[3721] = 'ER_INVALID_DEFAULT_UTF8MB4_COLLATION';
exports[3722] = 'ER_UNABLE_TO_COLLECT_LOG_STATUS';
exports[3723] = 'ER_RESERVED_TABLESPACE_NAME';
exports[3724] = 'ER_UNABLE_TO_SET_OPTION';
exports[3725] = 'ER_REPLICA_POSSIBLY_DIVERGED_AFTER_DDL';
exports[3726] = 'ER_SRS_NOT_GEOGRAPHIC';
exports[3727] = 'ER_POLYGON_TOO_LARGE';
exports[3728] = 'ER_SPATIAL_UNIQUE_INDEX';
exports[3729] = 'ER_INDEX_TYPE_NOT_SUPPORTED_FOR_SPATIAL_INDEX';
exports[3730] = 'ER_FK_CANNOT_DROP_PARENT';
exports[3731] = 'ER_GEOMETRY_PARAM_LONGITUDE_OUT_OF_RANGE';
exports[3732] = 'ER_GEOMETRY_PARAM_LATITUDE_OUT_OF_RANGE';
exports[3733] = 'ER_FK_CANNOT_USE_VIRTUAL_COLUMN';
exports[3734] = 'ER_FK_NO_COLUMN_PARENT';
exports[3735] = 'ER_CANT_SET_ERROR_SUPPRESSION_LIST';
exports[3736] = 'ER_SRS_GEOGCS_INVALID_AXES';
exports[3737] = 'ER_SRS_INVALID_SEMI_MAJOR_AXIS';
exports[3738] = 'ER_SRS_INVALID_INVERSE_FLATTENING';
exports[3739] = 'ER_SRS_INVALID_ANGULAR_UNIT';
exports[3740] = 'ER_SRS_INVALID_PRIME_MERIDIAN';
exports[3741] = 'ER_TRANSFORM_SOURCE_SRS_NOT_SUPPORTED';
exports[3742] = 'ER_TRANSFORM_TARGET_SRS_NOT_SUPPORTED';
exports[3743] = 'ER_TRANSFORM_SOURCE_SRS_MISSING_TOWGS84';
exports[3744] = 'ER_TRANSFORM_TARGET_SRS_MISSING_TOWGS84';
exports[3745] = 'ER_TEMP_TABLE_PREVENTS_SWITCH_SESSION_BINLOG_FORMAT';
exports[3746] = 'ER_TEMP_TABLE_PREVENTS_SWITCH_GLOBAL_BINLOG_FORMAT';
exports[3747] = 'ER_RUNNING_APPLIER_PREVENTS_SWITCH_GLOBAL_BINLOG_FORMAT';
exports[3748] = 'ER_CLIENT_GTID_UNSAFE_CREATE_DROP_TEMP_TABLE_IN_TRX_IN_SBR';
exports[3749] = 'ER_XA_CANT_CREATE_MDL_BACKUP';
exports[3750] = 'ER_TABLE_WITHOUT_PK';
exports[3751] = 'ER_WARN_DATA_TRUNCATED_FUNCTIONAL_INDEX';
exports[3752] = 'ER_WARN_DATA_OUT_OF_RANGE_FUNCTIONAL_INDEX';
exports[3753] = 'ER_FUNCTIONAL_INDEX_ON_JSON_OR_GEOMETRY_FUNCTION';
exports[3754] = 'ER_FUNCTIONAL_INDEX_REF_AUTO_INCREMENT';
exports[3755] = 'ER_CANNOT_DROP_COLUMN_FUNCTIONAL_INDEX';
exports[3756] = 'ER_FUNCTIONAL_INDEX_PRIMARY_KEY';
exports[3757] = 'ER_FUNCTIONAL_INDEX_ON_LOB';
exports[3758] = 'ER_FUNCTIONAL_INDEX_FUNCTION_IS_NOT_ALLOWED';
exports[3759] = 'ER_FULLTEXT_FUNCTIONAL_INDEX';
exports[3760] = 'ER_SPATIAL_FUNCTIONAL_INDEX';
exports[3761] = 'ER_WRONG_KEY_COLUMN_FUNCTIONAL_INDEX';
exports[3762] = 'ER_FUNCTIONAL_INDEX_ON_FIELD';
exports[3763] = 'ER_GENERATED_COLUMN_NAMED_FUNCTION_IS_NOT_ALLOWED';
exports[3764] = 'ER_GENERATED_COLUMN_ROW_VALUE';
exports[3765] = 'ER_GENERATED_COLUMN_VARIABLES';
exports[3766] = 'ER_DEPENDENT_BY_DEFAULT_GENERATED_VALUE';
exports[3767] = 'ER_DEFAULT_VAL_GENERATED_NON_PRIOR';
exports[3768] = 'ER_DEFAULT_VAL_GENERATED_REF_AUTO_INC';
exports[3769] = 'ER_DEFAULT_VAL_GENERATED_FUNCTION_IS_NOT_ALLOWED';
exports[3770] = 'ER_DEFAULT_VAL_GENERATED_NAMED_FUNCTION_IS_NOT_ALLOWED';
exports[3771] = 'ER_DEFAULT_VAL_GENERATED_ROW_VALUE';
exports[3772] = 'ER_DEFAULT_VAL_GENERATED_VARIABLES';
exports[3773] = 'ER_DEFAULT_AS_VAL_GENERATED';
exports[3774] = 'ER_UNSUPPORTED_ACTION_ON_DEFAULT_VAL_GENERATED';
exports[3775] = 'ER_GTID_UNSAFE_ALTER_ADD_COL_WITH_DEFAULT_EXPRESSION';
exports[3776] = 'ER_FK_CANNOT_CHANGE_ENGINE';
exports[3777] = 'ER_WARN_DEPRECATED_USER_SET_EXPR';
exports[3778] = 'ER_WARN_DEPRECATED_UTF8MB3_COLLATION';
exports[3779] = 'ER_WARN_DEPRECATED_NESTED_COMMENT_SYNTAX';
exports[3780] = 'ER_FK_INCOMPATIBLE_COLUMNS';
exports[3781] = 'ER_GR_HOLD_WAIT_TIMEOUT';
exports[3782] = 'ER_GR_HOLD_KILLED';
exports[3783] = 'ER_GR_HOLD_MEMBER_STATUS_ERROR';
exports[3784] = 'ER_RPL_ENCRYPTION_FAILED_TO_FETCH_KEY';
exports[3785] = 'ER_RPL_ENCRYPTION_KEY_NOT_FOUND';
exports[3786] = 'ER_RPL_ENCRYPTION_KEYRING_INVALID_KEY';
exports[3787] = 'ER_RPL_ENCRYPTION_HEADER_ERROR';
exports[3788] = 'ER_RPL_ENCRYPTION_FAILED_TO_ROTATE_LOGS';
exports[3789] = 'ER_RPL_ENCRYPTION_KEY_EXISTS_UNEXPECTED';
exports[3790] = 'ER_RPL_ENCRYPTION_FAILED_TO_GENERATE_KEY';
exports[3791] = 'ER_RPL_ENCRYPTION_FAILED_TO_STORE_KEY';
exports[3792] = 'ER_RPL_ENCRYPTION_FAILED_TO_REMOVE_KEY';
exports[3793] = 'ER_RPL_ENCRYPTION_UNABLE_TO_CHANGE_OPTION';
exports[3794] = 'ER_RPL_ENCRYPTION_MASTER_KEY_RECOVERY_FAILED';
exports[3795] = 'ER_SLOW_LOG_MODE_IGNORED_WHEN_NOT_LOGGING_TO_FILE';
exports[3796] = 'ER_GRP_TRX_CONSISTENCY_NOT_ALLOWED';
exports[3797] = 'ER_GRP_TRX_CONSISTENCY_BEFORE';
exports[3798] = 'ER_GRP_TRX_CONSISTENCY_AFTER_ON_TRX_BEGIN';
exports[3799] = 'ER_GRP_TRX_CONSISTENCY_BEGIN_NOT_ALLOWED';
exports[3800] = 'ER_FUNCTIONAL_INDEX_ROW_VALUE_IS_NOT_ALLOWED';
exports[3801] = 'ER_RPL_ENCRYPTION_FAILED_TO_ENCRYPT';
exports[3802] = 'ER_PAGE_TRACKING_NOT_STARTED';
exports[3803] = 'ER_PAGE_TRACKING_RANGE_NOT_TRACKED';
exports[3804] = 'ER_PAGE_TRACKING_CANNOT_PURGE';
exports[3805] = 'ER_RPL_ENCRYPTION_CANNOT_ROTATE_BINLOG_MASTER_KEY';
exports[3806] = 'ER_BINLOG_MASTER_KEY_RECOVERY_OUT_OF_COMBINATION';
exports[3807] = 'ER_BINLOG_MASTER_KEY_ROTATION_FAIL_TO_OPERATE_KEY';
exports[3808] = 'ER_BINLOG_MASTER_KEY_ROTATION_FAIL_TO_ROTATE_LOGS';
exports[3809] = 'ER_BINLOG_MASTER_KEY_ROTATION_FAIL_TO_REENCRYPT_LOG';
exports[3810] = 'ER_BINLOG_MASTER_KEY_ROTATION_FAIL_TO_CLEANUP_UNUSED_KEYS';
exports[3811] = 'ER_BINLOG_MASTER_KEY_ROTATION_FAIL_TO_CLEANUP_AUX_KEY';
exports[3812] = 'ER_NON_BOOLEAN_EXPR_FOR_CHECK_CONSTRAINT';
exports[3813] = 'ER_COLUMN_CHECK_CONSTRAINT_REFERENCES_OTHER_COLUMN';
exports[3814] = 'ER_CHECK_CONSTRAINT_NAMED_FUNCTION_IS_NOT_ALLOWED';
exports[3815] = 'ER_CHECK_CONSTRAINT_FUNCTION_IS_NOT_ALLOWED';
exports[3816] = 'ER_CHECK_CONSTRAINT_VARIABLES';
exports[3817] = 'ER_CHECK_CONSTRAINT_ROW_VALUE';
exports[3818] = 'ER_CHECK_CONSTRAINT_REFERS_AUTO_INCREMENT_COLUMN';
exports[3819] = 'ER_CHECK_CONSTRAINT_VIOLATED';
exports[3820] = 'ER_CHECK_CONSTRAINT_REFERS_UNKNOWN_COLUMN';
exports[3821] = 'ER_CHECK_CONSTRAINT_NOT_FOUND';
exports[3822] = 'ER_CHECK_CONSTRAINT_DUP_NAME';
exports[3823] = 'ER_CHECK_CONSTRAINT_CLAUSE_USING_FK_REFER_ACTION_COLUMN';
exports[3824] = 'WARN_UNENCRYPTED_TABLE_IN_ENCRYPTED_DB';
exports[3825] = 'ER_INVALID_ENCRYPTION_REQUEST';
exports[3826] = 'ER_CANNOT_SET_TABLE_ENCRYPTION';
exports[3827] = 'ER_CANNOT_SET_DATABASE_ENCRYPTION';
exports[3828] = 'ER_CANNOT_SET_TABLESPACE_ENCRYPTION';
exports[3829] = 'ER_TABLESPACE_CANNOT_BE_ENCRYPTED';
exports[3830] = 'ER_TABLESPACE_CANNOT_BE_DECRYPTED';
exports[3831] = 'ER_TABLESPACE_TYPE_UNKNOWN';
exports[3832] = 'ER_TARGET_TABLESPACE_UNENCRYPTED';
exports[3833] = 'ER_CANNOT_USE_ENCRYPTION_CLAUSE';
exports[3834] = 'ER_INVALID_MULTIPLE_CLAUSES';
exports[3835] = 'ER_UNSUPPORTED_USE_OF_GRANT_AS';
exports[3836] = 'ER_UKNOWN_AUTH_ID_OR_ACCESS_DENIED_FOR_GRANT_AS';
exports[3837] = 'ER_DEPENDENT_BY_FUNCTIONAL_INDEX';
exports[3838] = 'ER_PLUGIN_NOT_EARLY';
exports[3839] = 'ER_INNODB_REDO_LOG_ARCHIVE_START_SUBDIR_PATH';
exports[3840] = 'ER_INNODB_REDO_LOG_ARCHIVE_START_TIMEOUT';
exports[3841] = 'ER_INNODB_REDO_LOG_ARCHIVE_DIRS_INVALID';
exports[3842] = 'ER_INNODB_REDO_LOG_ARCHIVE_LABEL_NOT_FOUND';
exports[3843] = 'ER_INNODB_REDO_LOG_ARCHIVE_DIR_EMPTY';
exports[3844] = 'ER_INNODB_REDO_LOG_ARCHIVE_NO_SUCH_DIR';
exports[3845] = 'ER_INNODB_REDO_LOG_ARCHIVE_DIR_CLASH';
exports[3846] = 'ER_INNODB_REDO_LOG_ARCHIVE_DIR_PERMISSIONS';
exports[3847] = 'ER_INNODB_REDO_LOG_ARCHIVE_FILE_CREATE';
exports[3848] = 'ER_INNODB_REDO_LOG_ARCHIVE_ACTIVE';
exports[3849] = 'ER_INNODB_REDO_LOG_ARCHIVE_INACTIVE';
exports[3850] = 'ER_INNODB_REDO_LOG_ARCHIVE_FAILED';
exports[3851] = 'ER_INNODB_REDO_LOG_ARCHIVE_SESSION';
exports[3852] = 'ER_STD_REGEX_ERROR';
exports[3853] = 'ER_INVALID_JSON_TYPE';
exports[3854] = 'ER_CANNOT_CONVERT_STRING';
exports[3855] = 'ER_DEPENDENT_BY_PARTITION_FUNC';
exports[3856] = 'ER_WARN_DEPRECATED_FLOAT_AUTO_INCREMENT';
exports[3857] = 'ER_RPL_CANT_STOP_REPLICA_WHILE_LOCKED_BACKUP';
exports[3858] = 'ER_WARN_DEPRECATED_FLOAT_DIGITS';
exports[3859] = 'ER_WARN_DEPRECATED_FLOAT_UNSIGNED';
exports[3860] = 'ER_WARN_DEPRECATED_INTEGER_DISPLAY_WIDTH';
exports[3861] = 'ER_WARN_DEPRECATED_ZEROFILL';
exports[3862] = 'ER_CLONE_DONOR';
exports[3863] = 'ER_CLONE_PROTOCOL';
exports[3864] = 'ER_CLONE_DONOR_VERSION';
exports[3865] = 'ER_CLONE_OS';
exports[3866] = 'ER_CLONE_PLATFORM';
exports[3867] = 'ER_CLONE_CHARSET';
exports[3868] = 'ER_CLONE_CONFIG';
exports[3869] = 'ER_CLONE_SYS_CONFIG';
exports[3870] = 'ER_CLONE_PLUGIN_MATCH';
exports[3871] = 'ER_CLONE_LOOPBACK';
exports[3872] = 'ER_CLONE_ENCRYPTION';
exports[3873] = 'ER_CLONE_DISK_SPACE';
exports[3874] = 'ER_CLONE_IN_PROGRESS';
exports[3875] = 'ER_CLONE_DISALLOWED';
exports[3876] = 'ER_CANNOT_GRANT_ROLES_TO_ANONYMOUS_USER';
exports[3877] = 'ER_SECONDARY_ENGINE_PLUGIN';
exports[3878] = 'ER_SECOND_PASSWORD_CANNOT_BE_EMPTY';
exports[3879] = 'ER_DB_ACCESS_DENIED';
exports[3880] = 'ER_DA_AUTH_ID_WITH_SYSTEM_USER_PRIV_IN_MANDATORY_ROLES';
exports[3881] = 'ER_DA_RPL_GTID_TABLE_CANNOT_OPEN';
exports[3882] = 'ER_GEOMETRY_IN_UNKNOWN_LENGTH_UNIT';
exports[3883] = 'ER_DA_PLUGIN_INSTALL_ERROR';
exports[3884] = 'ER_NO_SESSION_TEMP';
exports[3885] = 'ER_DA_UNKNOWN_ERROR_NUMBER';
exports[3886] = 'ER_COLUMN_CHANGE_SIZE';
exports[3887] = 'ER_REGEXP_INVALID_CAPTURE_GROUP_NAME';
exports[3888] = 'ER_DA_SSL_LIBRARY_ERROR';
exports[3889] = 'ER_SECONDARY_ENGINE';
exports[3890] = 'ER_SECONDARY_ENGINE_DDL';
exports[3891] = 'ER_INCORRECT_CURRENT_PASSWORD';
exports[3892] = 'ER_MISSING_CURRENT_PASSWORD';
exports[3893] = 'ER_CURRENT_PASSWORD_NOT_REQUIRED';
exports[3894] = 'ER_PASSWORD_CANNOT_BE_RETAINED_ON_PLUGIN_CHANGE';
exports[3895] = 'ER_CURRENT_PASSWORD_CANNOT_BE_RETAINED';
exports[3896] = 'ER_PARTIAL_REVOKES_EXIST';
exports[3897] = 'ER_CANNOT_GRANT_SYSTEM_PRIV_TO_MANDATORY_ROLE';
exports[3898] = 'ER_XA_REPLICATION_FILTERS';
exports[3899] = 'ER_UNSUPPORTED_SQL_MODE';
exports[3900] = 'ER_REGEXP_INVALID_FLAG';
exports[3901] = 'ER_PARTIAL_REVOKE_AND_DB_GRANT_BOTH_EXISTS';
exports[3902] = 'ER_UNIT_NOT_FOUND';
exports[3903] = 'ER_INVALID_JSON_VALUE_FOR_FUNC_INDEX';
exports[3904] = 'ER_JSON_VALUE_OUT_OF_RANGE_FOR_FUNC_INDEX';
exports[3905] = 'ER_EXCEEDED_MV_KEYS_NUM';
exports[3906] = 'ER_EXCEEDED_MV_KEYS_SPACE';
exports[3907] = 'ER_FUNCTIONAL_INDEX_DATA_IS_TOO_LONG';
exports[3908] = 'ER_WRONG_MVI_VALUE';
exports[3909] = 'ER_WARN_FUNC_INDEX_NOT_APPLICABLE';
exports[3910] = 'ER_GRP_RPL_UDF_ERROR';
exports[3911] = 'ER_UPDATE_GTID_PURGED_WITH_GR';
exports[3912] = 'ER_GROUPING_ON_TIMESTAMP_IN_DST';
exports[3913] = 'ER_TABLE_NAME_CAUSES_TOO_LONG_PATH';
exports[3914] = 'ER_AUDIT_LOG_INSUFFICIENT_PRIVILEGE';
exports[3915] = 'ER_AUDIT_LOG_PASSWORD_HAS_BEEN_COPIED';
exports[3916] = 'ER_DA_GRP_RPL_STARTED_AUTO_REJOIN';
exports[3917] = 'ER_SYSVAR_CHANGE_DURING_QUERY';
exports[3918] = 'ER_GLOBSTAT_CHANGE_DURING_QUERY';
exports[3919] = 'ER_GRP_RPL_MESSAGE_SERVICE_INIT_FAILURE';
exports[3920] = 'ER_CHANGE_SOURCE_WRONG_COMPRESSION_ALGORITHM_CLIENT';
exports[3921] = 'ER_CHANGE_SOURCE_WRONG_COMPRESSION_LEVEL_CLIENT';
exports[3922] = 'ER_WRONG_COMPRESSION_ALGORITHM_CLIENT';
exports[3923] = 'ER_WRONG_COMPRESSION_LEVEL_CLIENT';
exports[3924] = 'ER_CHANGE_SOURCE_WRONG_COMPRESSION_ALGORITHM_LIST_CLIENT';
exports[3925] = 'ER_CLIENT_PRIVILEGE_CHECKS_USER_CANNOT_BE_ANONYMOUS';
exports[3926] = 'ER_CLIENT_PRIVILEGE_CHECKS_USER_DOES_NOT_EXIST';
exports[3927] = 'ER_CLIENT_PRIVILEGE_CHECKS_USER_CORRUPT';
exports[3928] = 'ER_CLIENT_PRIVILEGE_CHECKS_USER_NEEDS_RPL_APPLIER_PRIV';
exports[3929] = 'ER_WARN_DA_PRIVILEGE_NOT_REGISTERED';
exports[3930] = 'ER_CLIENT_KEYRING_UDF_KEY_INVALID';
exports[3931] = 'ER_CLIENT_KEYRING_UDF_KEY_TYPE_INVALID';
exports[3932] = 'ER_CLIENT_KEYRING_UDF_KEY_TOO_LONG';
exports[3933] = 'ER_CLIENT_KEYRING_UDF_KEY_TYPE_TOO_LONG';
exports[3934] = 'ER_JSON_SCHEMA_VALIDATION_ERROR_WITH_DETAILED_REPORT';
exports[3935] = 'ER_DA_UDF_INVALID_CHARSET_SPECIFIED';
exports[3936] = 'ER_DA_UDF_INVALID_CHARSET';
exports[3937] = 'ER_DA_UDF_INVALID_COLLATION';
exports[3938] = 'ER_DA_UDF_INVALID_EXTENSION_ARGUMENT_TYPE';
exports[3939] = 'ER_MULTIPLE_CONSTRAINTS_WITH_SAME_NAME';
exports[3940] = 'ER_CONSTRAINT_NOT_FOUND';
exports[3941] = 'ER_ALTER_CONSTRAINT_ENFORCEMENT_NOT_SUPPORTED';
exports[3942] = 'ER_TABLE_VALUE_CONSTRUCTOR_MUST_HAVE_COLUMNS';
exports[3943] = 'ER_TABLE_VALUE_CONSTRUCTOR_CANNOT_HAVE_DEFAULT';
exports[3944] = 'ER_CLIENT_QUERY_FAILURE_INVALID_NON_ROW_FORMAT';
exports[3945] = 'ER_REQUIRE_ROW_FORMAT_INVALID_VALUE';
exports[3946] = 'ER_FAILED_TO_DETERMINE_IF_ROLE_IS_MANDATORY';
exports[3947] = 'ER_FAILED_TO_FETCH_MANDATORY_ROLE_LIST';
exports[3948] = 'ER_CLIENT_LOCAL_FILES_DISABLED';
exports[3949] = 'ER_IMP_INCOMPATIBLE_CFG_VERSION';
exports[3950] = 'ER_DA_OOM';
exports[3951] = 'ER_DA_UDF_INVALID_ARGUMENT_TO_SET_CHARSET';
exports[3952] = 'ER_DA_UDF_INVALID_RETURN_TYPE_TO_SET_CHARSET';
exports[3953] = 'ER_MULTIPLE_INTO_CLAUSES';
exports[3954] = 'ER_MISPLACED_INTO';
exports[3955] =
  'ER_USER_ACCESS_DENIED_FOR_USER_ACCOUNT_BLOCKED_BY_PASSWORD_LOCK';
exports[3956] = 'ER_WARN_DEPRECATED_YEAR_UNSIGNED';
exports[3957] = 'ER_CLONE_NETWORK_PACKET';
exports[3958] = 'ER_SDI_OPERATION_FAILED_MISSING_RECORD';
exports[3959] = 'ER_DEPENDENT_BY_CHECK_CONSTRAINT';
exports[3960] = 'ER_GRP_OPERATION_NOT_ALLOWED_GR_MUST_STOP';
exports[3961] = 'ER_WARN_DEPRECATED_JSON_TABLE_ON_ERROR_ON_EMPTY';
exports[3962] = 'ER_WARN_DEPRECATED_INNER_INTO';
exports[3963] = 'ER_WARN_DEPRECATED_VALUES_FUNCTION_ALWAYS_NULL';
exports[3964] = 'ER_WARN_DEPRECATED_SQL_CALC_FOUND_ROWS';
exports[3965] = 'ER_WARN_DEPRECATED_FOUND_ROWS';
exports[3966] = 'ER_MISSING_JSON_VALUE';
exports[3967] = 'ER_MULTIPLE_JSON_VALUES';
exports[3968] = 'ER_HOSTNAME_TOO_LONG';
exports[3969] = 'ER_WARN_CLIENT_DEPRECATED_PARTITION_PREFIX_KEY';
exports[3970] = 'ER_GROUP_REPLICATION_USER_EMPTY_MSG';
exports[3971] = 'ER_GROUP_REPLICATION_USER_MANDATORY_MSG';
exports[3972] = 'ER_GROUP_REPLICATION_PASSWORD_LENGTH';
exports[3973] = 'ER_SUBQUERY_TRANSFORM_REJECTED';
exports[3974] = 'ER_DA_GRP_RPL_RECOVERY_ENDPOINT_FORMAT';
exports[3975] = 'ER_DA_GRP_RPL_RECOVERY_ENDPOINT_INVALID';
exports[3976] = 'ER_WRONG_VALUE_FOR_VAR_PLUS_ACTIONABLE_PART';
exports[3977] = 'ER_STATEMENT_NOT_ALLOWED_AFTER_START_TRANSACTION';
exports[3978] = 'ER_FOREIGN_KEY_WITH_ATOMIC_CREATE_SELECT';
exports[3979] = 'ER_NOT_ALLOWED_WITH_START_TRANSACTION';
exports[3980] = 'ER_INVALID_JSON_ATTRIBUTE';
exports[3981] = 'ER_ENGINE_ATTRIBUTE_NOT_SUPPORTED';
exports[3982] = 'ER_INVALID_USER_ATTRIBUTE_JSON';
exports[3983] = 'ER_INNODB_REDO_DISABLED';
exports[3984] = 'ER_INNODB_REDO_ARCHIVING_ENABLED';
exports[3985] = 'ER_MDL_OUT_OF_RESOURCES';
exports[3986] = 'ER_IMPLICIT_COMPARISON_FOR_JSON';
exports[3987] = 'ER_FUNCTION_DOES_NOT_SUPPORT_CHARACTER_SET';
exports[3988] = 'ER_IMPOSSIBLE_STRING_CONVERSION';
exports[3989] = 'ER_SCHEMA_READ_ONLY';
exports[3990] = 'ER_RPL_ASYNC_RECONNECT_GTID_MODE_OFF';
exports[3991] = 'ER_RPL_ASYNC_RECONNECT_AUTO_POSITION_OFF';
exports[3992] = 'ER_DISABLE_GTID_MODE_REQUIRES_ASYNC_RECONNECT_OFF';
exports[3993] = 'ER_DISABLE_AUTO_POSITION_REQUIRES_ASYNC_RECONNECT_OFF';
exports[3994] = 'ER_INVALID_PARAMETER_USE';
exports[3995] = 'ER_CHARACTER_SET_MISMATCH';
exports[3996] = 'ER_WARN_VAR_VALUE_CHANGE_NOT_SUPPORTED';
exports[3997] = 'ER_INVALID_TIME_ZONE_INTERVAL';
exports[3998] = 'ER_INVALID_CAST';
exports[3999] = 'ER_HYPERGRAPH_NOT_SUPPORTED_YET';
exports[4000] = 'ER_WARN_HYPERGRAPH_EXPERIMENTAL';
exports[4001] = 'ER_DA_NO_ERROR_LOG_PARSER_CONFIGURED';
exports[4002] = 'ER_DA_ERROR_LOG_TABLE_DISABLED';
exports[4003] = 'ER_DA_ERROR_LOG_MULTIPLE_FILTERS';
exports[4004] = 'ER_DA_CANT_OPEN_ERROR_LOG';
exports[4005] = 'ER_USER_REFERENCED_AS_DEFINER';
exports[4006] = 'ER_CANNOT_USER_REFERENCED_AS_DEFINER';
exports[4007] = 'ER_REGEX_NUMBER_TOO_BIG';
exports[4008] = 'ER_SPVAR_NONINTEGER_TYPE';
exports[4009] = 'WARN_UNSUPPORTED_ACL_TABLES_READ';
exports[4010] = 'ER_BINLOG_UNSAFE_ACL_TABLE_READ_IN_DML_DDL';
exports[4011] = 'ER_STOP_REPLICA_MONITOR_IO_THREAD_TIMEOUT';
exports[4012] = 'ER_STARTING_REPLICA_MONITOR_IO_THREAD';
exports[4013] = 'ER_CANT_USE_ANONYMOUS_TO_GTID_WITH_GTID_MODE_NOT_ON';
exports[4014] = 'ER_CANT_COMBINE_ANONYMOUS_TO_GTID_AND_AUTOPOSITION';
exports[4015] =
  'ER_ASSIGN_GTIDS_TO_ANONYMOUS_TRANSACTIONS_REQUIRES_GTID_MODE_ON';
exports[4016] = 'ER_SQL_REPLICA_SKIP_COUNTER_USED_WITH_GTID_MODE_ON';
exports[4017] =
  'ER_USING_ASSIGN_GTIDS_TO_ANONYMOUS_TRANSACTIONS_AS_LOCAL_OR_UUID';
exports[4018] =
  'ER_CANT_SET_ANONYMOUS_TO_GTID_AND_WAIT_UNTIL_SQL_THD_AFTER_GTIDS';
exports[4019] = 'ER_CANT_SET_SQL_AFTER_OR_BEFORE_GTIDS_WITH_ANONYMOUS_TO_GTID';
exports[4020] = 'ER_ANONYMOUS_TO_GTID_UUID_SAME_AS_GROUP_NAME';
exports[4021] = 'ER_CANT_USE_SAME_UUID_AS_GROUP_NAME';
exports[4022] = 'ER_GRP_RPL_RECOVERY_CHANNEL_STILL_RUNNING';
exports[4023] = 'ER_INNODB_INVALID_AUTOEXTEND_SIZE_VALUE';
exports[4024] = 'ER_INNODB_INCOMPATIBLE_WITH_TABLESPACE';
exports[4025] = 'ER_INNODB_AUTOEXTEND_SIZE_OUT_OF_RANGE';
exports[4026] = 'ER_CANNOT_USE_AUTOEXTEND_SIZE_CLAUSE';
exports[4027] = 'ER_ROLE_GRANTED_TO_ITSELF';
exports[4028] = 'ER_TABLE_MUST_HAVE_A_VISIBLE_COLUMN';
exports[4029] = 'ER_INNODB_COMPRESSION_FAILURE';
exports[4030] = 'ER_WARN_ASYNC_CONN_FAILOVER_NETWORK_NAMESPACE';
exports[4031] = 'ER_CLIENT_INTERACTION_TIMEOUT';
exports[4032] = 'ER_INVALID_CAST_TO_GEOMETRY';
exports[4033] = 'ER_INVALID_CAST_POLYGON_RING_DIRECTION';
exports[4034] = 'ER_GIS_DIFFERENT_SRIDS_AGGREGATION';
exports[4035] = 'ER_RELOAD_KEYRING_FAILURE';
exports[4036] = 'ER_SDI_GET_KEYS_INVALID_TABLESPACE';
exports[4037] = 'ER_CHANGE_RPL_SRC_WRONG_COMPRESSION_ALGORITHM_SIZE';
exports[4038] = 'ER_WARN_DEPRECATED_TLS_VERSION_FOR_CHANNEL_CLI';
exports[4039] = 'ER_CANT_USE_SAME_UUID_AS_VIEW_CHANGE_UUID';
exports[4040] = 'ER_ANONYMOUS_TO_GTID_UUID_SAME_AS_VIEW_CHANGE_UUID';
exports[4041] = 'ER_GRP_RPL_VIEW_CHANGE_UUID_FAIL_GET_VARIABLE';
exports[4042] = 'ER_WARN_ADUIT_LOG_MAX_SIZE_AND_PRUNE_SECONDS';
exports[4043] = 'ER_WARN_ADUIT_LOG_MAX_SIZE_CLOSE_TO_ROTATE_ON_SIZE';
exports[4044] = 'ER_KERBEROS_CREATE_USER';
exports[4045] = 'ER_INSTALL_PLUGIN_CONFLICT_CLIENT';
exports[4046] = 'ER_DA_ERROR_LOG_COMPONENT_FLUSH_FAILED';
exports[4047] = 'ER_WARN_SQL_AFTER_MTS_GAPS_GAP_NOT_CALCULATED';
exports[4048] = 'ER_INVALID_ASSIGNMENT_TARGET';
exports[4049] = 'ER_OPERATION_NOT_ALLOWED_ON_GR_SECONDARY';
exports[4050] = 'ER_GRP_RPL_FAILOVER_CHANNEL_STATUS_PROPAGATION';
exports[4051] = 'ER_WARN_AUDIT_LOG_FORMAT_UNIX_TIMESTAMP_ONLY_WHEN_JSON';
exports[4052] = 'ER_INVALID_MFA_PLUGIN_SPECIFIED';
exports[4053] = 'ER_IDENTIFIED_BY_UNSUPPORTED';
exports[4054] = 'ER_INVALID_PLUGIN_FOR_REGISTRATION';
exports[4055] = 'ER_PLUGIN_REQUIRES_REGISTRATION';
exports[4056] = 'ER_MFA_METHOD_EXISTS';
exports[4057] = 'ER_MFA_METHOD_NOT_EXISTS';
exports[4058] = 'ER_AUTHENTICATION_POLICY_MISMATCH';
exports[4059] = 'ER_PLUGIN_REGISTRATION_DONE';
exports[4060] = 'ER_INVALID_USER_FOR_REGISTRATION';
exports[4061] = 'ER_USER_REGISTRATION_FAILED';
exports[4062] = 'ER_MFA_METHODS_INVALID_ORDER';
exports[4063] = 'ER_MFA_METHODS_IDENTICAL';
exports[4064] = 'ER_INVALID_MFA_OPERATIONS_FOR_PASSWORDLESS_USER';
exports[4065] = 'ER_CHANGE_REPLICATION_SOURCE_NO_OPTIONS_FOR_GTID_ONLY';
exports[4066] =
  'ER_CHANGE_REP_SOURCE_CANT_DISABLE_REQ_ROW_FORMAT_WITH_GTID_ONLY';
exports[4067] =
  'ER_CHANGE_REP_SOURCE_CANT_DISABLE_AUTO_POSITION_WITH_GTID_ONLY';
exports[4068] = 'ER_CHANGE_REP_SOURCE_CANT_DISABLE_GTID_ONLY_WITHOUT_POSITIONS';
exports[4069] = 'ER_CHANGE_REP_SOURCE_CANT_DISABLE_AUTO_POS_WITHOUT_POSITIONS';
exports[4070] = 'ER_CHANGE_REP_SOURCE_GR_CHANNEL_WITH_GTID_MODE_NOT_ON';
exports[4071] = 'ER_CANT_USE_GTID_ONLY_WITH_GTID_MODE_NOT_ON';
exports[4072] = 'ER_WARN_C_DISABLE_GTID_ONLY_WITH_SOURCE_AUTO_POS_INVALID_POS';
exports[4073] = 'ER_DA_SSL_FIPS_MODE_ERROR';
exports[4074] = 'ER_VALUE_OUT_OF_RANGE';
exports[4075] = 'ER_FULLTEXT_WITH_ROLLUP';
exports[4076] = 'ER_REGEXP_MISSING_RESOURCE';
exports[4077] = 'ER_WARN_REGEXP_USING_DEFAULT';
exports[4078] = 'ER_REGEXP_MISSING_FILE';
exports[4079] = 'ER_WARN_DEPRECATED_COLLATION';
exports[4080] = 'ER_CONCURRENT_PROCEDURE_USAGE';
exports[4081] = 'ER_DA_GLOBAL_CONN_LIMIT';
exports[4082] = 'ER_DA_CONN_LIMIT';
exports[4083] = 'ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_COLUMN_TYPE_INSTANT';
exports[4084] = 'ER_WARN_SF_UDF_NAME_COLLISION';
exports[4085] = 'ER_CANNOT_PURGE_BINLOG_WITH_BACKUP_LOCK';
exports[4086] = 'ER_TOO_MANY_WINDOWS';
exports[4087] = 'ER_MYSQLBACKUP_CLIENT_MSG';
exports[4088] = 'ER_COMMENT_CONTAINS_INVALID_STRING';
exports[4089] = 'ER_DEFINITION_CONTAINS_INVALID_STRING';
exports[4090] = 'ER_CANT_EXECUTE_COMMAND_WITH_ASSIGNED_GTID_NEXT';
exports[4091] = 'ER_XA_TEMP_TABLE';
exports[4092] = 'ER_INNODB_MAX_ROW_VERSION';
exports[4093] = 'ER_INNODB_INSTANT_ADD_NOT_SUPPORTED_MAX_SIZE';
exports[4094] = 'ER_OPERATION_NOT_ALLOWED_WHILE_PRIMARY_CHANGE_IS_RUNNING';
exports[4095] = 'ER_WARN_DEPRECATED_DATETIME_DELIMITER';
exports[4096] = 'ER_WARN_DEPRECATED_SUPERFLUOUS_DELIMITER';
exports[4097] = 'ER_CANNOT_PERSIST_SENSITIVE_VARIABLES';
exports[4098] = 'ER_WARN_CANNOT_SECURELY_PERSIST_SENSITIVE_VARIABLES';
exports[4099] = 'ER_WARN_TRG_ALREADY_EXISTS';
exports[4100] = 'ER_IF_NOT_EXISTS_UNSUPPORTED_TRG_EXISTS_ON_DIFFERENT_TABLE';
exports[4101] = 'ER_IF_NOT_EXISTS_UNSUPPORTED_UDF_NATIVE_FCT_NAME_COLLISION';
exports[4102] = 'ER_SET_PASSWORD_AUTH_PLUGIN_ERROR';
exports[4103] = 'ER_REDUCED_DBLWR_FILE_CORRUPTED';
exports[4104] = 'ER_REDUCED_DBLWR_PAGE_FOUND';
exports[4105] = 'ER_SRS_INVALID_LATITUDE_OF_ORIGIN';
exports[4106] = 'ER_SRS_INVALID_LONGITUDE_OF_ORIGIN';
exports[4107] = 'ER_SRS_UNUSED_PROJ_PARAMETER_PRESENT';
exports[4108] = 'ER_GIPK_COLUMN_EXISTS';
exports[4109] = 'ER_GIPK_FAILED_AUTOINC_COLUMN_EXISTS';
exports[4110] = 'ER_GIPK_COLUMN_ALTER_NOT_ALLOWED';
exports[4111] = 'ER_DROP_PK_COLUMN_TO_DROP_GIPK';
exports[4112] = 'ER_CREATE_SELECT_WITH_GIPK_DISALLOWED_IN_SBR';
exports[4113] = 'ER_DA_EXPIRE_LOGS_DAYS_IGNORED';
exports[4114] = 'ER_CTE_RECURSIVE_NOT_UNION';
exports[4115] = 'ER_COMMAND_BACKEND_FAILED_TO_FETCH_SECURITY_CTX';
exports[4116] = 'ER_COMMAND_SERVICE_BACKEND_FAILED';
exports[4117] = 'ER_CLIENT_FILE_PRIVILEGE_FOR_REPLICATION_CHECKS';
exports[4118] = 'ER_GROUP_REPLICATION_FORCE_MEMBERS_COMMAND_FAILURE';
exports[4119] = 'ER_WARN_DEPRECATED_IDENT';
exports[4120] = 'ER_INTERSECT_ALL_MAX_DUPLICATES_EXCEEDED';
exports[4121] = 'ER_TP_QUERY_THRS_PER_GRP_EXCEEDS_TXN_THR_LIMIT';
exports[4122] = 'ER_BAD_TIMESTAMP_FORMAT';
exports[4123] = 'ER_SHAPE_PRIDICTION_UDF';
exports[4124] = 'ER_SRS_INVALID_HEIGHT';
exports[4125] = 'ER_SRS_INVALID_SCALING';
exports[4126] = 'ER_SRS_INVALID_ZONE_WIDTH';
exports[4127] = 'ER_SRS_INVALID_LATITUDE_POLAR_STERE_VAR_A';
exports[4128] = 'ER_WARN_DEPRECATED_CLIENT_NO_SCHEMA_OPTION';
exports[4129] = 'ER_TABLE_NOT_EMPTY';
exports[4130] = 'ER_TABLE_NO_PRIMARY_KEY';
exports[4131] = 'ER_TABLE_IN_SHARED_TABLESPACE';
exports[4132] = 'ER_INDEX_OTHER_THAN_PK';
exports[4133] = 'ER_LOAD_BULK_DATA_UNSORTED';
exports[4134] = 'ER_BULK_EXECUTOR_ERROR';
exports[4135] = 'ER_BULK_READER_LIBCURL_INIT_FAILED';
exports[4136] = 'ER_BULK_READER_LIBCURL_ERROR';
exports[4137] = 'ER_BULK_READER_SERVER_ERROR';
exports[4138] = 'ER_BULK_READER_COMMUNICATION_ERROR';
exports[4139] = 'ER_BULK_LOAD_DATA_FAILED';
exports[4140] = 'ER_BULK_LOADER_COLUMN_TOO_BIG_FOR_LEFTOVER_BUFFER';
exports[4141] = 'ER_BULK_LOADER_COMPONENT_ERROR';
exports[4142] = 'ER_BULK_LOADER_FILE_CONTAINS_LESS_LINES_THAN_IGNORE_CLAUSE';
exports[4143] = 'ER_BULK_PARSER_MISSING_ENCLOSED_BY';
exports[4144] = 'ER_BULK_PARSER_ROW_BUFFER_MAX_TOTAL_COLS_EXCEEDED';
exports[4145] = 'ER_BULK_PARSER_COPY_BUFFER_SIZE_EXCEEDED';
exports[4146] = 'ER_BULK_PARSER_UNEXPECTED_END_OF_INPUT';
exports[4147] = 'ER_BULK_PARSER_UNEXPECTED_ROW_TERMINATOR';
exports[4148] = 'ER_BULK_PARSER_UNEXPECTED_CHAR_AFTER_ENDING_ENCLOSED_BY';
exports[4149] = 'ER_BULK_PARSER_UNEXPECTED_CHAR_AFTER_NULL_ESCAPE';
exports[4150] = 'ER_BULK_PARSER_UNEXPECTED_CHAR_AFTER_COLUMN_TERMINATOR';
exports[4151] = 'ER_BULK_PARSER_INCOMPLETE_ESCAPE_SEQUENCE';
exports[4152] = 'ER_LOAD_BULK_DATA_FAILED';
exports[4153] = 'ER_LOAD_BULK_DATA_WRONG_VALUE_FOR_FIELD';
exports[4154] = 'ER_LOAD_BULK_DATA_WARN_NULL_TO_NOTNULL';
exports[4155] = 'ER_REQUIRE_TABLE_PRIMARY_KEY_CHECK_GENERATE_WITH_GR';
exports[4156] = 'ER_CANT_CHANGE_SYS_VAR_IN_READ_ONLY_MODE';
exports[4157] = 'ER_INNODB_INSTANT_ADD_DROP_NOT_SUPPORTED_MAX_SIZE';
exports[4158] = 'ER_INNODB_INSTANT_ADD_NOT_SUPPORTED_MAX_FIELDS';
exports[4159] = 'ER_CANT_SET_PERSISTED';
exports[4160] = 'ER_INSTALL_COMPONENT_SET_NULL_VALUE';
exports[4161] = 'ER_INSTALL_COMPONENT_SET_UNUSED_VALUE';
exports[4162] = 'ER_WARN_DEPRECATED_USER_DEFINED_COLLATIONS';


/***/ }),

/***/ 34615:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


// Manually extracted from mysql-5.5.23/include/mysql_com.h
exports.NOT_NULL = 1; /* Field can't be NULL */
exports.PRI_KEY = 2; /* Field is part of a primary key */
exports.UNIQUE_KEY = 4; /* Field is part of a unique key */
exports.MULTIPLE_KEY = 8; /* Field is part of a key */
exports.BLOB = 16; /* Field is a blob */
exports.UNSIGNED = 32; /* Field is unsigned */
exports.ZEROFILL = 64; /* Field is zerofill */
exports.BINARY = 128; /* Field is binary   */

/* The following are only sent to new clients */
exports.ENUM = 256; /* field is an enum */
exports.AUTO_INCREMENT = 512; /* field is a autoincrement field */
exports.TIMESTAMP = 1024; /* Field is a timestamp */
exports.SET = 2048; /* field is a set */
exports.NO_DEFAULT_VALUE = 4096; /* Field doesn't have default value */
exports.ON_UPDATE_NOW = 8192; /* Field is set to NOW on UPDATE */
exports.NUM = 32768; /* Field is num (for clients) */


/***/ }),

/***/ 92609:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


// Manually extracted from mysql-5.5.23/include/mysql_com.h

/**
  Is raised when a multi-statement transaction
  has been started, either explicitly, by means
  of BEGIN or COMMIT AND CHAIN, or
  implicitly, by the first transactional
  statement, when autocommit=off.
*/
exports.SERVER_STATUS_IN_TRANS = 1;
exports.SERVER_STATUS_AUTOCOMMIT = 2; /* Server in auto_commit mode */
exports.SERVER_MORE_RESULTS_EXISTS = 8; /* Multi query - next query exists */
exports.SERVER_QUERY_NO_GOOD_INDEX_USED = 16;
exports.SERVER_QUERY_NO_INDEX_USED = 32;
/**
  The server was able to fulfill the clients request and opened a
  read-only non-scrollable cursor for a query. This flag comes
  in reply to COM_STMT_EXECUTE and COM_STMT_FETCH commands.
*/
exports.SERVER_STATUS_CURSOR_EXISTS = 64;
/**
  This flag is sent when a read-only cursor is exhausted, in reply to
  COM_STMT_FETCH command.
*/
exports.SERVER_STATUS_LAST_ROW_SENT = 128;
exports.SERVER_STATUS_DB_DROPPED = 256; /* A database was dropped */
exports.SERVER_STATUS_NO_BACKSLASH_ESCAPES = 512;
/**
  Sent to the client if after a prepared statement reprepare
  we discovered that the new statement returns a different
  number of result set columns.
*/
exports.SERVER_STATUS_METADATA_CHANGED = 1024;
exports.SERVER_QUERY_WAS_SLOW = 2048;

/**
  To mark ResultSet containing output parameter values.
*/
exports.SERVER_PS_OUT_PARAMS = 4096;

exports.SERVER_STATUS_IN_TRANS_READONLY = 0x2000; // in a read-only transaction
exports.SERVER_SESSION_STATE_CHANGED = 0x4000;


/***/ }),

/***/ 94335:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


exports.SYSTEM_VARIABLES = 0;
exports.SCHEMA = 1;
exports.STATE_CHANGE = 2;
exports.STATE_GTIDS = 3;
exports.TRANSACTION_CHARACTERISTICS = 4;
exports.TRANSACTION_STATE = 5;

exports.FIRST_KEY = exports.SYSTEM_VARIABLES;
exports.LAST_KEY = exports.TRANSACTION_STATE;


/***/ }),

/***/ 3830:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


const awsCaBundle = __nccwpck_require__(45675);

/**
 * @deprecated
 * Please, use [**aws-ssl-profiles**](https://github.com/mysqljs/aws-ssl-profiles).
 */
exports["Amazon RDS"] = {
  ca: awsCaBundle.ca,
};


/***/ }),

/***/ 95490:
/***/ ((module) => {

"use strict";


module.exports = {
  0x00: 'DECIMAL', // aka DECIMAL
  0x01: 'TINY', // aka TINYINT, 1 byte
  0x02: 'SHORT', // aka SMALLINT, 2 bytes
  0x03: 'LONG', // aka INT, 4 bytes
  0x04: 'FLOAT', // aka FLOAT, 4-8 bytes
  0x05: 'DOUBLE', // aka DOUBLE, 8 bytes
  0x06: 'NULL', // NULL (used for prepared statements, I think)
  0x07: 'TIMESTAMP', // aka TIMESTAMP
  0x08: 'LONGLONG', // aka BIGINT, 8 bytes
  0x09: 'INT24', // aka MEDIUMINT, 3 bytes
  0x0a: 'DATE', // aka DATE
  0x0b: 'TIME', // aka TIME
  0x0c: 'DATETIME', // aka DATETIME
  0x0d: 'YEAR', // aka YEAR, 1 byte (don't ask)
  0x0e: 'NEWDATE', // aka ?
  0x0f: 'VARCHAR', // aka VARCHAR (?)
  0x10: 'BIT', // aka BIT, 1-8 byte
  0xf5: 'JSON',
  0xf6: 'NEWDECIMAL', // aka DECIMAL
  0xf7: 'ENUM', // aka ENUM
  0xf8: 'SET', // aka SET
  0xf9: 'TINY_BLOB', // aka TINYBLOB, TINYTEXT
  0xfa: 'MEDIUM_BLOB', // aka MEDIUMBLOB, MEDIUMTEXT
  0xfb: 'LONG_BLOB', // aka LONGBLOG, LONGTEXT
  0xfc: 'BLOB', // aka BLOB, TEXT
  0xfd: 'VAR_STRING', // aka VARCHAR, VARBINARY
  0xfe: 'STRING', // aka CHAR, BINARY
  0xff: 'GEOMETRY', // aka GEOMETRY
};

// Manually extracted from mysql-5.5.23/include/mysql_com.h
// some more info here: http://dev.mysql.com/doc/refman/5.5/en/c-api-prepared-statement-type-codes.html
module.exports.DECIMAL = 0x00; // aka DECIMAL (http://dev.mysql.com/doc/refman/5.0/en/precision-math-decimal-changes.html)
module.exports.TINY = 0x01; // aka TINYINT, 1 byte
module.exports.SHORT = 0x02; // aka SMALLINT, 2 bytes
module.exports.LONG = 0x03; // aka INT, 4 bytes
module.exports.FLOAT = 0x04; // aka FLOAT, 4-8 bytes
module.exports.DOUBLE = 0x05; // aka DOUBLE, 8 bytes
module.exports.NULL = 0x06; // NULL (used for prepared statements, I think)
module.exports.TIMESTAMP = 0x07; // aka TIMESTAMP
module.exports.LONGLONG = 0x08; // aka BIGINT, 8 bytes
module.exports.INT24 = 0x09; // aka MEDIUMINT, 3 bytes
module.exports.DATE = 0x0a; // aka DATE
module.exports.TIME = 0x0b; // aka TIME
module.exports.DATETIME = 0x0c; // aka DATETIME
module.exports.YEAR = 0x0d; // aka YEAR, 1 byte (don't ask)
module.exports.NEWDATE = 0x0e; // aka ?
module.exports.VARCHAR = 0x0f; // aka VARCHAR (?)
module.exports.BIT = 0x10; // aka BIT, 1-8 byte
module.exports.VECTOR = 0xf2;
module.exports.JSON = 0xf5;
module.exports.NEWDECIMAL = 0xf6; // aka DECIMAL
module.exports.ENUM = 0xf7; // aka ENUM
module.exports.SET = 0xf8; // aka SET
module.exports.TINY_BLOB = 0xf9; // aka TINYBLOB, TINYTEXT
module.exports.MEDIUM_BLOB = 0xfa; // aka MEDIUMBLOB, MEDIUMTEXT
module.exports.LONG_BLOB = 0xfb; // aka LONGBLOG, LONGTEXT
module.exports.BLOB = 0xfc; // aka BLOB, TEXT
module.exports.VAR_STRING = 0xfd; // aka VARCHAR, VARBINARY
module.exports.STRING = 0xfe; // aka CHAR, BINARY
module.exports.GEOMETRY = 0xff; // aka GEOMETRY


/***/ }),

/***/ 31076:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


const Connection = __nccwpck_require__(58661);
const ConnectionConfig = __nccwpck_require__(6566);

function createConnection(opts) {
  return new Connection({ config: new ConnectionConfig(opts) });
}

module.exports = createConnection;


/***/ }),

/***/ 37670:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


const Pool = __nccwpck_require__(72515);
const PoolConfig = __nccwpck_require__(95648);

function createPool(config) {
  return new Pool({ config: new PoolConfig(config) });
}

module.exports = createPool;


/***/ }),

/***/ 33871:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


const PoolCluster = __nccwpck_require__(51498);

function createPoolCluster(config) {
  return new PoolCluster(config);
}

module.exports = createPoolCluster;


/***/ }),

/***/ 33024:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


/*

  this seems to be not only shorter, but faster than
  string.replace(/\\/g, '\\\\').
            replace(/\u0008/g, '\\b').
            replace(/\t/g, '\\t').
            replace(/\n/g, '\\n').
            replace(/\f/g, '\\f').
            replace(/\r/g, '\\r').
            replace(/'/g, '\\\'').
            replace(/"/g, '\\"');
  or string.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&")
  see http://jsperf.com/string-escape-regexp-vs-json-stringify
  */
function srcEscape(str) {
  return JSON.stringify({
    [str]: 1,
  }).slice(1, -3);
}

exports.srcEscape = srcEscape;

let highlightFn;
let cardinalRecommended = false;
try {
  // the purpose of this is to prevent projects using Webpack from displaying a warning during runtime if cardinal is not a dependency
  const REQUIRE_TERMINATOR = '';
  highlightFn = (__nccwpck_require__(15633).highlight);
} catch (err) {
  highlightFn = (text) => {
    if (!cardinalRecommended) {
      // eslint-disable-next-line no-console
      console.log('For nicer debug output consider install cardinal@^2.0.0');
      cardinalRecommended = true;
    }
    return text;
  };
}

/**
 * Prints debug message with code frame, will try to use `cardinal` if available.
 */
function printDebugWithCode(msg, code) {
  // eslint-disable-next-line no-console
  console.log(`\n\n${msg}:\n`);
  // eslint-disable-next-line no-console
  console.log(`${highlightFn(code)}\n`);
}

exports.printDebugWithCode = printDebugWithCode;

/**
 * checks whether the `type` is in the `list`
 */
function typeMatch(type, list, Types) {
  if (Array.isArray(list)) {
    return list.some((t) => type === Types[t]);
  }

  return !!list;
}

exports.typeMatch = typeMatch;

const privateObjectProps = new Set([
  '__defineGetter__',
  '__defineSetter__',
  '__lookupGetter__',
  '__lookupSetter__',
  '__proto__',
]);

exports.privateObjectProps = privateObjectProps;

const fieldEscape = (field, isEval = true) => {
  if (privateObjectProps.has(field)) {
    throw new Error(
      `The field name (${field}) can't be the same as an object's private property.`
    );
  }

  return isEval ? srcEscape(field) : field;
};
exports.fieldEscape = fieldEscape;


/***/ }),

/***/ 61379:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


const Packet = __nccwpck_require__(43743);

const MAX_PACKET_LENGTH = 16777215;

function readPacketLength(b, off) {
  const b0 = b[off];
  const b1 = b[off + 1];
  const b2 = b[off + 2];
  if (b1 + b2 === 0) {
    return b0;
  }
  return b0 + (b1 << 8) + (b2 << 16);
}

class PacketParser {
  constructor(onPacket, packetHeaderLength) {
    // 4 for normal packets, 7 for comprssed protocol packets
    if (typeof packetHeaderLength === 'undefined') {
      packetHeaderLength = 4;
    }
    // array of last payload chunks
    // only used when current payload is not complete
    this.buffer = [];
    // total length of chunks on buffer
    this.bufferLength = 0;
    this.packetHeaderLength = packetHeaderLength;
    // incomplete header state: number of header bytes received
    this.headerLen = 0;
    // expected payload length
    this.length = 0;
    this.largePacketParts = [];
    this.firstPacketSequenceId = 0;
    this.onPacket = onPacket;
    this.execute = PacketParser.prototype.executeStart;
    this._flushLargePacket =
      packetHeaderLength === 7
        ? this._flushLargePacket7
        : this._flushLargePacket4;
  }

  _flushLargePacket4() {
    const numPackets = this.largePacketParts.length;
    this.largePacketParts.unshift(Buffer.from([0, 0, 0, 0])); // insert header
    const body = Buffer.concat(this.largePacketParts);
    const packet = new Packet(this.firstPacketSequenceId, body, 0, body.length);
    this.largePacketParts.length = 0;
    packet.numPackets = numPackets;
    this.onPacket(packet);
  }

  _flushLargePacket7() {
    const numPackets = this.largePacketParts.length;
    this.largePacketParts.unshift(Buffer.from([0, 0, 0, 0, 0, 0, 0])); // insert header
    const body = Buffer.concat(this.largePacketParts);
    this.largePacketParts.length = 0;
    const packet = new Packet(this.firstPacketSequenceId, body, 0, body.length);
    packet.numPackets = numPackets;
    this.onPacket(packet);
  }

  executeStart(chunk) {
    let start = 0;
    const end = chunk.length;
    while (end - start >= 3) {
      this.length = readPacketLength(chunk, start);
      if (end - start >= this.length + this.packetHeaderLength) {
        // at least one full packet
        const sequenceId = chunk[start + 3];
        if (
          this.length < MAX_PACKET_LENGTH &&
          this.largePacketParts.length === 0
        ) {
          this.onPacket(
            new Packet(
              sequenceId,
              chunk,
              start,
              start + this.packetHeaderLength + this.length
            )
          );
        } else {
          // first large packet - remember it's id
          if (this.largePacketParts.length === 0) {
            this.firstPacketSequenceId = sequenceId;
          }
          this.largePacketParts.push(
            chunk.slice(
              start + this.packetHeaderLength,
              start + this.packetHeaderLength + this.length
            )
          );
          if (this.length < MAX_PACKET_LENGTH) {
            this._flushLargePacket();
          }
        }
        start += this.packetHeaderLength + this.length;
      } else {
        // payload is incomplete
        this.buffer = [chunk.slice(start + 3, end)];
        this.bufferLength = end - start - 3;
        this.execute = PacketParser.prototype.executePayload;
        return;
      }
    }
    if (end - start > 0) {
      // there is start of length header, but it's not full 3 bytes
      this.headerLen = end - start; // 1 or 2 bytes
      this.length = chunk[start];
      if (this.headerLen === 2) {
        this.length = chunk[start] + (chunk[start + 1] << 8);
        this.execute = PacketParser.prototype.executeHeader3;
      } else {
        this.execute = PacketParser.prototype.executeHeader2;
      }
    }
  }

  executePayload(chunk) {
    let start = 0;
    const end = chunk.length;
    const remainingPayload =
      this.length - this.bufferLength + this.packetHeaderLength - 3;
    if (end - start >= remainingPayload) {
      // last chunk for payload
      const payload = Buffer.allocUnsafe(this.length + this.packetHeaderLength);
      let offset = 3;
      for (let i = 0; i < this.buffer.length; ++i) {
        this.buffer[i].copy(payload, offset);
        offset += this.buffer[i].length;
      }
      chunk.copy(payload, offset, start, start + remainingPayload);
      const sequenceId = payload[3];
      if (
        this.length < MAX_PACKET_LENGTH &&
        this.largePacketParts.length === 0
      ) {
        this.onPacket(
          new Packet(
            sequenceId,
            payload,
            0,
            this.length + this.packetHeaderLength
          )
        );
      } else {
        // first large packet - remember it's id
        if (this.largePacketParts.length === 0) {
          this.firstPacketSequenceId = sequenceId;
        }
        this.largePacketParts.push(
          payload.slice(
            this.packetHeaderLength,
            this.packetHeaderLength + this.length
          )
        );
        if (this.length < MAX_PACKET_LENGTH) {
          this._flushLargePacket();
        }
      }
      this.buffer = [];
      this.bufferLength = 0;
      this.execute = PacketParser.prototype.executeStart;
      start += remainingPayload;
      if (end - start > 0) {
        return this.execute(chunk.slice(start, end));
      }
    } else {
      this.buffer.push(chunk);
      this.bufferLength += chunk.length;
    }
    return null;
  }

  executeHeader2(chunk) {
    this.length += chunk[0] << 8;
    if (chunk.length > 1) {
      this.length += chunk[1] << 16;
      this.execute = PacketParser.prototype.executePayload;
      return this.executePayload(chunk.slice(2));
    }
    this.execute = PacketParser.prototype.executeHeader3;

    return null;
  }

  executeHeader3(chunk) {
    this.length += chunk[0] << 16;
    this.execute = PacketParser.prototype.executePayload;
    return this.executePayload(chunk.slice(1));
  }
}

module.exports = PacketParser;


/***/ }),

/***/ 48439:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";
// Copyright (c) 2021, Oracle and/or its affiliates.



const Packet = __nccwpck_require__(43743);

class AuthNextFactor {
  constructor(opts) {
    this.pluginName = opts.pluginName;
    this.pluginData = opts.pluginData;
  }

  toPacket(encoding) {
    const length = 6 + this.pluginName.length + this.pluginData.length;
    const buffer = Buffer.allocUnsafe(length);
    const packet = new Packet(0, buffer, 0, length);
    packet.offset = 4;
    packet.writeInt8(0x02);
    packet.writeNullTerminatedString(this.pluginName, encoding);
    packet.writeBuffer(this.pluginData);
    return packet;
  }

  static fromPacket(packet, encoding) {
    packet.readInt8(); // marker
    const name = packet.readNullTerminatedString(encoding);
    const data = packet.readBuffer();
    return new AuthNextFactor({
      pluginName: name,
      pluginData: data,
    });
  }
}

module.exports = AuthNextFactor;


/***/ }),

/***/ 35438:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


// http://dev.mysql.com/doc/internals/en/connection-phase-packets.html#packet-Protocol::AuthSwitchRequest

const Packet = __nccwpck_require__(43743);

class AuthSwitchRequest {
  constructor(opts) {
    this.pluginName = opts.pluginName;
    this.pluginData = opts.pluginData;
  }

  toPacket() {
    const length = 6 + this.pluginName.length + this.pluginData.length;
    const buffer = Buffer.allocUnsafe(length);
    const packet = new Packet(0, buffer, 0, length);
    packet.offset = 4;
    packet.writeInt8(0xfe);
    // TODO: use server encoding
    packet.writeNullTerminatedString(this.pluginName, 'cesu8');
    packet.writeBuffer(this.pluginData);
    return packet;
  }

  static fromPacket(packet) {
    packet.readInt8(); // marker
    // assert marker == 0xfe?
    // TODO: use server encoding
    const name = packet.readNullTerminatedString('cesu8');
    const data = packet.readBuffer();
    return new AuthSwitchRequest({
      pluginName: name,
      pluginData: data,
    });
  }
}

module.exports = AuthSwitchRequest;


/***/ }),

/***/ 38743:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


// http://dev.mysql.com/doc/internals/en/connection-phase-packets.html#packet-Protocol::AuthSwitchRequest

const Packet = __nccwpck_require__(43743);

class AuthSwitchRequestMoreData {
  constructor(data) {
    this.data = data;
  }

  toPacket() {
    const length = 5 + this.data.length;
    const buffer = Buffer.allocUnsafe(length);
    const packet = new Packet(0, buffer, 0, length);
    packet.offset = 4;
    packet.writeInt8(0x01);
    packet.writeBuffer(this.data);
    return packet;
  }

  static fromPacket(packet) {
    packet.readInt8(); // marker
    const data = packet.readBuffer();
    return new AuthSwitchRequestMoreData(data);
  }

  static verifyMarker(packet) {
    return packet.peekByte() === 0x01;
  }
}

module.exports = AuthSwitchRequestMoreData;


/***/ }),

/***/ 1760:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


// http://dev.mysql.com/doc/internals/en/connection-phase-packets.html#packet-Protocol::AuthSwitchRequest

const Packet = __nccwpck_require__(43743);

class AuthSwitchResponse {
  constructor(data) {
    if (!Buffer.isBuffer(data)) {
      data = Buffer.from(data);
    }
    this.data = data;
  }

  toPacket() {
    const length = 4 + this.data.length;
    const buffer = Buffer.allocUnsafe(length);
    const packet = new Packet(0, buffer, 0, length);
    packet.offset = 4;
    packet.writeBuffer(this.data);
    return packet;
  }

  static fromPacket(packet) {
    const data = packet.readBuffer();
    return new AuthSwitchResponse(data);
  }
}

module.exports = AuthSwitchResponse;


/***/ }),

/***/ 3453:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


const Types = __nccwpck_require__(95490);
const Packet = __nccwpck_require__(43743);

const binaryReader = new Array(256);

class BinaryRow {
  constructor(columns) {
    this.columns = columns || [];
  }

  static toPacket(columns, encoding) {
    // throw new Error('Not implemented');
    const sequenceId = 0; // TODO remove, this is calculated now in connecton
    let length = 0;
    columns.forEach((val) => {
      if (val === null || typeof val === 'undefined') {
        ++length;
        return;
      }
      length += Packet.lengthCodedStringLength(val.toString(10), encoding);
    });

    length = length + 2;

    const buffer = Buffer.allocUnsafe(length + 4);
    const packet = new Packet(sequenceId, buffer, 0, length + 4);
    packet.offset = 4;

    packet.writeInt8(0);

    let bitmap = 0;
    let bitValue = 1;
    columns.forEach((parameter) => {
      if (parameter.type === Types.NULL) {
        bitmap += bitValue;
      }
      bitValue *= 2;
      if (bitValue === 256) {
        packet.writeInt8(bitmap);
        bitmap = 0;
        bitValue = 1;
      }
    });
    if (bitValue !== 1) {
      packet.writeInt8(bitmap);
    }

    columns.forEach((val) => {
      if (val === null) {
        packet.writeNull();
        return;
      }
      if (typeof val === 'undefined') {
        packet.writeInt8(0);
        return;
      }
      packet.writeLengthCodedString(val.toString(10), encoding);
    });
    return packet;
  }

  // TODO: complete list of types...
  static fromPacket(fields, packet) {
    const columns = new Array(fields.length);
    packet.readInt8(); // TODO check it's 0
    const nullBitmapLength = Math.floor((fields.length + 7 + 2) / 8);
    // TODO: read and interpret null bitmap
    packet.skip(nullBitmapLength);
    for (let i = 0; i < columns.length; ++i) {
      columns[i] = binaryReader[fields[i].columnType].apply(packet);
    }
    return new BinaryRow(columns);
  }
}

// TODO: replace with constants.MYSQL_TYPE_*
binaryReader[Types.DECIMAL] = Packet.prototype.readLengthCodedString;
binaryReader[1] = Packet.prototype.readInt8; // tiny
binaryReader[2] = Packet.prototype.readInt16; // short
binaryReader[3] = Packet.prototype.readInt32; // long
binaryReader[4] = Packet.prototype.readFloat; // float
binaryReader[5] = Packet.prototype.readDouble; // double
binaryReader[6] = Packet.prototype.assertInvalid; // null, should be skipped vie null bitmap
binaryReader[7] = Packet.prototype.readTimestamp; // timestamp, http://dev.mysql.com/doc/internals/en/prepared-statements.html#packet-ProtocolBinary::MYSQL_TYPE_TIMESTAMP
binaryReader[8] = Packet.prototype.readInt64; // long long
binaryReader[9] = Packet.prototype.readInt32; // int24
binaryReader[10] = Packet.prototype.readTimestamp; // date
binaryReader[11] = Packet.prototype.readTime; // time, http://dev.mysql.com/doc/internals/en/prepared-statements.html#packet-ProtocolBinary::MYSQL_TYPE_TIME
binaryReader[12] = Packet.prototype.readDateTime; // datetime, http://dev.mysql.com/doc/internals/en/prepared-statements.html#packet-ProtocolBinary::MYSQL_TYPE_DATETIME
binaryReader[13] = Packet.prototype.readInt16; // year
binaryReader[Types.VAR_STRING] = Packet.prototype.readLengthCodedString; // var string

module.exports = BinaryRow;


/***/ }),

/***/ 71251:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


// http://dev.mysql.com/doc/internals/en/com-binlog-dump.html#packet-COM_BINLOG_DUMP

const Packet = __nccwpck_require__(43743);
const CommandCodes = __nccwpck_require__(17361);

// TODO: add flag to constants
// 0x01 - BINLOG_DUMP_NON_BLOCK
// send EOF instead of blocking
class BinlogDump {
  constructor(opts) {
    this.binlogPos = opts.binlogPos || 0;
    this.serverId = opts.serverId || 0;
    this.flags = opts.flags || 0;
    this.filename = opts.filename || '';
  }

  toPacket() {
    const length = 15 + Buffer.byteLength(this.filename, 'utf8'); // TODO: should be ascii?
    const buffer = Buffer.allocUnsafe(length);
    const packet = new Packet(0, buffer, 0, length);
    packet.offset = 4;
    packet.writeInt8(CommandCodes.BINLOG_DUMP);
    packet.writeInt32(this.binlogPos);
    packet.writeInt16(this.flags);
    packet.writeInt32(this.serverId);
    packet.writeString(this.filename);
    return packet;
  }
}

module.exports = BinlogDump;


/***/ }),

/***/ 81232:
/***/ ((module) => {

"use strict";


// http://dev.mysql.com/doc/internals/en/query-event.html

const keys = {
  FLAGS2: 0,
  SQL_MODE: 1,
  CATALOG: 2,
  AUTO_INCREMENT: 3,
  CHARSET: 4,
  TIME_ZONE: 5,
  CATALOG_NZ: 6,
  LC_TIME_NAMES: 7,
  CHARSET_DATABASE: 8,
  TABLE_MAP_FOR_UPDATE: 9,
  MASTER_DATA_WRITTEN: 10,
  INVOKERS: 11,
  UPDATED_DB_NAMES: 12,
  MICROSECONDS: 3,
};

module.exports = function parseStatusVars(buffer) {
  const result = {};
  let offset = 0;
  let key, length, prevOffset;
  while (offset < buffer.length) {
    key = buffer[offset++];
    switch (key) {
      case keys.FLAGS2:
        result.flags = buffer.readUInt32LE(offset);
        offset += 4;
        break;
      case keys.SQL_MODE:
        // value is 8 bytes, but all dcumented flags are in first 4 bytes
        result.sqlMode = buffer.readUInt32LE(offset);
        offset += 8;
        break;
      case keys.CATALOG:
        length = buffer[offset++];
        result.catalog = buffer.toString('utf8', offset, offset + length);
        offset += length + 1; // null byte after string
        break;
      case keys.CHARSET:
        result.clientCharset = buffer.readUInt16LE(offset);
        result.connectionCollation = buffer.readUInt16LE(offset + 2);
        result.serverCharset = buffer.readUInt16LE(offset + 4);
        offset += 6;
        break;
      case keys.TIME_ZONE:
        length = buffer[offset++];
        result.timeZone = buffer.toString('utf8', offset, offset + length);
        offset += length; // no null byte
        break;
      case keys.CATALOG_NZ:
        length = buffer[offset++];
        result.catalogNz = buffer.toString('utf8', offset, offset + length);
        offset += length; // no null byte
        break;
      case keys.LC_TIME_NAMES:
        result.lcTimeNames = buffer.readUInt16LE(offset);
        offset += 2;
        break;
      case keys.CHARSET_DATABASE:
        result.schemaCharset = buffer.readUInt16LE(offset);
        offset += 2;
        break;
      case keys.TABLE_MAP_FOR_UPDATE:
        result.mapForUpdate1 = buffer.readUInt32LE(offset);
        result.mapForUpdate2 = buffer.readUInt32LE(offset + 4);
        offset += 8;
        break;
      case keys.MASTER_DATA_WRITTEN:
        result.masterDataWritten = buffer.readUInt32LE(offset);
        offset += 4;
        break;
      case keys.INVOKERS:
        length = buffer[offset++];
        result.invokerUsername = buffer.toString(
          'utf8',
          offset,
          offset + length
        );
        offset += length;
        length = buffer[offset++];
        result.invokerHostname = buffer.toString(
          'utf8',
          offset,
          offset + length
        );
        offset += length;
        break;
      case keys.UPDATED_DB_NAMES:
        length = buffer[offset++];
        // length - number of null-terminated strings
        result.updatedDBs = []; // we'll store them as array here
        for (; length; --length) {
          prevOffset = offset;
          // fast forward to null terminating byte
          while (buffer[offset++] && offset < buffer.length) {
            // empty body, everything inside while condition
          }
          result.updatedDBs.push(
            buffer.toString('utf8', prevOffset, offset - 1)
          );
        }
        break;
      case keys.MICROSECONDS:
        result.microseconds =
          // REVIEW: INVALID UNKNOWN VARIABLE!
          buffer.readInt16LE(offset) + (buffer[offset + 2] << 16);
        offset += 3;
    }
  }
  return result;
};


/***/ }),

/***/ 16549:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


const CommandCode = __nccwpck_require__(17361);
const ClientConstants = __nccwpck_require__(70060);
const Packet = __nccwpck_require__(43743);
const auth41 = __nccwpck_require__(8789);
const CharsetToEncoding = __nccwpck_require__(89998);

// https://dev.mysql.com/doc/internals/en/com-change-user.html#packet-COM_CHANGE_USER
class ChangeUser {
  constructor(opts) {
    this.flags = opts.flags;
    this.user = opts.user || '';
    this.database = opts.database || '';
    this.password = opts.password || '';
    this.passwordSha1 = opts.passwordSha1;
    this.authPluginData1 = opts.authPluginData1;
    this.authPluginData2 = opts.authPluginData2;
    this.connectAttributes = opts.connectAttrinutes || {};
    let authToken;
    if (this.passwordSha1) {
      authToken = auth41.calculateTokenFromPasswordSha(
        this.passwordSha1,
        this.authPluginData1,
        this.authPluginData2
      );
    } else {
      authToken = auth41.calculateToken(
        this.password,
        this.authPluginData1,
        this.authPluginData2
      );
    }
    this.authToken = authToken;
    this.charsetNumber = opts.charsetNumber;
  }

  // TODO
  // ChangeUser.fromPacket = function(packet)
  // };
  serializeToBuffer(buffer) {
    const isSet = (flag) => this.flags & ClientConstants[flag];
    const packet = new Packet(0, buffer, 0, buffer.length);
    packet.offset = 4;
    const encoding = CharsetToEncoding[this.charsetNumber];
    packet.writeInt8(CommandCode.CHANGE_USER);
    packet.writeNullTerminatedString(this.user, encoding);
    if (isSet('SECURE_CONNECTION')) {
      packet.writeInt8(this.authToken.length);
      packet.writeBuffer(this.authToken);
    } else {
      packet.writeBuffer(this.authToken);
      packet.writeInt8(0);
    }
    packet.writeNullTerminatedString(this.database, encoding);
    packet.writeInt16(this.charsetNumber);
    if (isSet('PLUGIN_AUTH')) {
      // TODO: read this from parameters
      packet.writeNullTerminatedString('mysql_native_password', 'latin1');
    }
    if (isSet('CONNECT_ATTRS')) {
      const connectAttributes = this.connectAttributes;
      const attrNames = Object.keys(connectAttributes);
      let keysLength = 0;
      for (let k = 0; k < attrNames.length; ++k) {
        keysLength += Packet.lengthCodedStringLength(attrNames[k], encoding);
        keysLength += Packet.lengthCodedStringLength(
          connectAttributes[attrNames[k]],
          encoding
        );
      }
      packet.writeLengthCodedNumber(keysLength);
      for (let k = 0; k < attrNames.length; ++k) {
        packet.writeLengthCodedString(attrNames[k], encoding);
        packet.writeLengthCodedString(
          connectAttributes[attrNames[k]],
          encoding
        );
      }
    }
    return packet;
  }

  toPacket() {
    if (typeof this.user !== 'string') {
      throw new Error('"user" connection config property must be a string');
    }
    if (typeof this.database !== 'string') {
      throw new Error('"database" connection config property must be a string');
    }
    // dry run: calculate resulting packet length
    const p = this.serializeToBuffer(Packet.MockBuffer());
    return this.serializeToBuffer(Buffer.allocUnsafe(p.offset));
  }
}

module.exports = ChangeUser;


/***/ }),

/***/ 94077:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


const Packet = __nccwpck_require__(43743);
const CommandCodes = __nccwpck_require__(17361);

class CloseStatement {
  constructor(id) {
    this.id = id;
  }

  // note: no response sent back
  toPacket() {
    const packet = new Packet(0, Buffer.allocUnsafe(9), 0, 9);
    packet.offset = 4;
    packet.writeInt8(CommandCodes.STMT_CLOSE);
    packet.writeInt32(this.id);
    return packet;
  }
}

module.exports = CloseStatement;


/***/ }),

/***/ 57485:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


const Packet = __nccwpck_require__(43743);
const StringParser = __nccwpck_require__(86809);
const CharsetToEncoding = __nccwpck_require__(89998);

const fields = ['catalog', 'schema', 'table', 'orgTable', 'name', 'orgName'];

// creating JS string is relatively expensive (compared to
// reading few bytes from buffer) because all string properties
// except for name are unlikely to be used we postpone
// string conversion until property access
//
// TODO: watch for integration benchmarks (one with real network buffer)
// there could be bad side effect as keeping reference to a buffer makes it
// sit in the memory longer (usually until final .query() callback)
// Latest v8 perform much better in regard to bufferer -> string conversion,
// at some point of time this optimisation might become unnecessary
// see https://github.com/sidorares/node-mysql2/pull/137
//
class ColumnDefinition {
  constructor(packet, clientEncoding) {
    this._buf = packet.buffer;
    this._clientEncoding = clientEncoding;
    this._catalogLength = packet.readLengthCodedNumber();
    this._catalogStart = packet.offset;
    packet.offset += this._catalogLength;
    this._schemaLength = packet.readLengthCodedNumber();
    this._schemaStart = packet.offset;
    packet.offset += this._schemaLength;
    this._tableLength = packet.readLengthCodedNumber();
    this._tableStart = packet.offset;
    packet.offset += this._tableLength;
    this._orgTableLength = packet.readLengthCodedNumber();
    this._orgTableStart = packet.offset;
    packet.offset += this._orgTableLength;
    // name is always used, don't make it lazy
    const _nameLength = packet.readLengthCodedNumber();
    const _nameStart = packet.offset;
    packet.offset += _nameLength;
    this._orgNameLength = packet.readLengthCodedNumber();
    this._orgNameStart = packet.offset;
    packet.offset += this._orgNameLength;
    packet.skip(1); //  length of the following fields (always 0x0c)
    this.characterSet = packet.readInt16();
    this.encoding = CharsetToEncoding[this.characterSet];
    this.name = StringParser.decode(
      this._buf,
      this.encoding === 'binary' ? this._clientEncoding : this.encoding,
      _nameStart,
      _nameStart + _nameLength
    );
    this.columnLength = packet.readInt32();
    this.columnType = packet.readInt8();
    this.type = this.columnType;
    this.flags = packet.readInt16();
    this.decimals = packet.readInt8();
  }

  inspect() {
    return {
      catalog: this.catalog,
      schema: this.schema,
      name: this.name,
      orgName: this.orgName,
      table: this.table,
      orgTable: this.orgTable,
      characterSet: this.characterSet,
      encoding: this.encoding,
      columnLength: this.columnLength,
      type: this.columnType,
      flags: this.flags,
      decimals: this.decimals,
    };
  }

  [Symbol.for('nodejs.util.inspect.custom')](depth, inspectOptions, inspect) {
    const Types = __nccwpck_require__(95490);
    const typeNames = [];
    for (const t in Types) {
      typeNames[Types[t]] = t;
    }
    const fiedFlags = __nccwpck_require__(34615);
    const flagNames = [];
    // TODO: respect inspectOptions.showHidden
    //const inspectFlags = inspectOptions.showHidden ? this.flags : this.flags & ~fiedFlags.PRI_KEY;
    const inspectFlags = this.flags;
    for (const f in fiedFlags) {
      if (inspectFlags & fiedFlags[f]) {
        if (f === 'PRI_KEY') {
          flagNames.push('PRIMARY KEY');
        } else if (f === 'NOT_NULL') {
          flagNames.push('NOT NULL');
        } else if (f === 'BINARY') {
          // ignore flag for now
        } else if (f === 'MULTIPLE_KEY') {
          // not sure if that should be part of inspection.
          // in the schema usually this is part of index definition
          // example: UNIQUE KEY `my_uniq_id` (`id_box_elements`,`id_router`)
          // note that only first column has MULTIPLE_KEY flag set in this case
          // so there is no good way of knowing that this is part of index just
          // by looking at indifidual field flags
        } else if (f === 'NO_DEFAULT_VALUE') {
          // almost the same as NOT_NULL?
        } else if (f === 'BLOB') {
          // included in the type
        } else if (f === 'UNSIGNED') {
          // this should be first after type
        } else if (f === 'TIMESTAMP') {
          // timestamp flag is redundant for inspection - already included in type
        } else if (f === 'ON_UPDATE_NOW') {
          flagNames.push('ON UPDATE CURRENT_TIMESTAMP');
        } else {
          flagNames.push(f);
        }
      }
    }

    if (depth > 1) {
      return inspect({
        ...this.inspect(),
        typeName: typeNames[this.columnType],
        flags: flagNames,
      });
    }

    const isUnsigned = this.flags & fiedFlags.UNSIGNED;

    let typeName = typeNames[this.columnType];
    if (typeName === 'BLOB') {
      // TODO: check for non-utf8mb4 encoding
      if (this.columnLength === 4294967295) {
        typeName = 'LONGTEXT';
      } else if (this.columnLength === 67108860) {
        typeName = 'MEDIUMTEXT';
      } else if (this.columnLength === 262140) {
        typeName = 'TEXT';
      } else if (this.columnLength === 1020) {
        // 255*4
        typeName = 'TINYTEXT';
      } else {
        typeName = `BLOB(${this.columnLength})`;
      }
    } else if (typeName === 'VAR_STRING') {
      // TODO: check for non-utf8mb4 encoding
      typeName = `VARCHAR(${Math.ceil(this.columnLength / 4)})`;
    } else if (typeName === 'TINY') {
      if (
        (this.columnLength === 3 && isUnsigned) ||
        (this.columnLength === 4 && !isUnsigned)
      ) {
        typeName = 'TINYINT';
      } else {
        typeName = `TINYINT(${this.columnLength})`;
      }
    } else if (typeName === 'LONGLONG') {
      if (this.columnLength === 20) {
        typeName = 'BIGINT';
      } else {
        typeName = `BIGINT(${this.columnLength})`;
      }
    } else if (typeName === 'SHORT') {
      if (isUnsigned && this.columnLength === 5) {
        typeName = 'SMALLINT';
      } else if (!isUnsigned && this.columnLength === 6) {
        typeName = 'SMALLINT';
      } else {
        typeName = `SMALLINT(${this.columnLength})`;
      }
    } else if (typeName === 'LONG') {
      if (isUnsigned && this.columnLength === 10) {
        typeName = 'INT';
      } else if (!isUnsigned && this.columnLength === 11) {
        typeName = 'INT';
      } else {
        typeName = `INT(${this.columnLength})`;
      }
    } else if (typeName === 'INT24') {
      if (isUnsigned && this.columnLength === 8) {
        typeName = 'MEDIUMINT';
      } else if (!isUnsigned && this.columnLength === 9) {
        typeName = 'MEDIUMINT';
      } else {
        typeName = `MEDIUMINT(${this.columnLength})`;
      }
    } else if (typeName === 'DOUBLE') {
      // DOUBLE without modifiers is reported as DOUBLE(22, 31)
      if (this.columnLength === 22 && this.decimals === 31) {
        typeName = 'DOUBLE';
      } else {
        typeName = `DOUBLE(${this.columnLength},${this.decimals})`;
      }
    } else if (typeName === 'FLOAT') {
      // FLOAT without modifiers is reported as FLOAT(12, 31)
      if (this.columnLength === 12 && this.decimals === 31) {
        typeName = 'FLOAT';
      } else {
        typeName = `FLOAT(${this.columnLength},${this.decimals})`;
      }
    } else if (typeName === 'NEWDECIMAL') {
      if (this.columnLength === 11 && this.decimals === 0) {
        typeName = 'DECIMAL';
      } else if (this.decimals === 0) {
        // not sure why, but DECIMAL(13) is reported as DECIMAL(14, 0)
        // and DECIMAL(13, 9) is reported as NEWDECIMAL(15, 9)
        if (isUnsigned) {
          typeName = `DECIMAL(${this.columnLength})`;
        } else {
          typeName = `DECIMAL(${this.columnLength - 1})`;
        }
      } else {
        typeName = `DECIMAL(${this.columnLength - 2},${this.decimals})`;
      }
    } else {
      typeName = `${typeNames[this.columnType]}(${this.columnLength})`;
    }

    if (isUnsigned) {
      typeName += ' UNSIGNED';
    }

    // TODO respect colors option
    return `\`${this.name}\` ${[typeName, ...flagNames].join(' ')}`;
  }

  static toPacket(column, sequenceId) {
    let length = 17; // = 4 padding + 1 + 12 for the rest
    fields.forEach((field) => {
      length += Packet.lengthCodedStringLength(
        column[field],
        CharsetToEncoding[column.characterSet]
      );
    });
    const buffer = Buffer.allocUnsafe(length);

    const packet = new Packet(sequenceId, buffer, 0, length);
    function writeField(name) {
      packet.writeLengthCodedString(
        column[name],
        CharsetToEncoding[column.characterSet]
      );
    }
    packet.offset = 4;
    fields.forEach(writeField);
    packet.writeInt8(0x0c);
    packet.writeInt16(column.characterSet);
    packet.writeInt32(column.columnLength);
    packet.writeInt8(column.columnType);
    packet.writeInt16(column.flags);
    packet.writeInt8(column.decimals);
    packet.writeInt16(0); // filler
    return packet;
  }

  // node-mysql compatibility: alias "db" to "schema"
  get db() {
    return this.schema;
  }
}

const addString = function (name) {
  Object.defineProperty(ColumnDefinition.prototype, name, {
    get: function () {
      const start = this[`_${name}Start`];
      const end = start + this[`_${name}Length`];
      const val = StringParser.decode(
        this._buf,
        this.encoding === 'binary' ? this._clientEncoding : this.encoding,
        start,
        end
      );

      Object.defineProperty(this, name, {
        value: val,
        writable: false,
        configurable: false,
        enumerable: false,
      });

      return val;
    },
  });
};

addString('catalog');
addString('schema');
addString('table');
addString('orgTable');
addString('orgName');

module.exports = ColumnDefinition;


/***/ }),

/***/ 35764:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


const CursorType = __nccwpck_require__(63493);
const CommandCodes = __nccwpck_require__(17361);
const Types = __nccwpck_require__(95490);
const Packet = __nccwpck_require__(43743);
const CharsetToEncoding = __nccwpck_require__(89998);

function isJSON(value) {
  return (
    Array.isArray(value) ||
    value.constructor === Object ||
    (typeof value.toJSON === 'function' && !Buffer.isBuffer(value))
  );
}

/**
 * Converts a value to an object describing type, String/Buffer representation and length
 * @param {*} value
 */
function toParameter(value, encoding, timezone) {
  let type = Types.VAR_STRING;
  let length;
  let writer = function (value) {
    // eslint-disable-next-line no-invalid-this
    return Packet.prototype.writeLengthCodedString.call(this, value, encoding);
  };
  if (value !== null) {
    switch (typeof value) {
      case 'undefined':
        throw new TypeError('Bind parameters must not contain undefined');

      case 'number':
        type = Types.DOUBLE;
        length = 8;
        writer = Packet.prototype.writeDouble;
        break;

      case 'boolean':
        value = value | 0;
        type = Types.TINY;
        length = 1;
        writer = Packet.prototype.writeInt8;
        break;

      case 'object':
        if (Object.prototype.toString.call(value) === '[object Date]') {
          type = Types.DATETIME;
          length = 12;
          writer = function (value) {
            // eslint-disable-next-line no-invalid-this
            return Packet.prototype.writeDate.call(this, value, timezone);
          };
        } else if (isJSON(value)) {
          value = JSON.stringify(value);
          type = Types.JSON;
        } else if (Buffer.isBuffer(value)) {
          length = Packet.lengthCodedNumberLength(value.length) + value.length;
          writer = Packet.prototype.writeLengthCodedBuffer;
        }
        break;

      default:
        value = value.toString();
    }
  } else {
    value = '';
    type = Types.NULL;
  }
  if (!length) {
    length = Packet.lengthCodedStringLength(value, encoding);
  }
  return { value, type, length, writer };
}

class Execute {
  constructor(id, parameters, charsetNumber, timezone) {
    this.id = id;
    this.parameters = parameters;
    this.encoding = CharsetToEncoding[charsetNumber];
    this.timezone = timezone;
  }

  static fromPacket(packet, encoding) {
    const stmtId = packet.readInt32();
    const flags = packet.readInt8();
    const iterationCount = packet.readInt32();

    let i = packet.offset;
    while (i < packet.end - 1) {
      if (
        (packet.buffer[i + 1] === Types.VAR_STRING ||
          packet.buffer[i + 1] === Types.NULL ||
          packet.buffer[i + 1] === Types.DOUBLE ||
          packet.buffer[i + 1] === Types.TINY ||
          packet.buffer[i + 1] === Types.DATETIME ||
          packet.buffer[i + 1] === Types.JSON) &&
        packet.buffer[i] === 1 &&
        packet.buffer[i + 2] === 0
      ) {
        break;
      } else {
        packet.readInt8();
      }
      i++;
    }

    const types = [];

    for (let i = packet.offset + 1; i < packet.end - 1; i++) {
      if (
        (packet.buffer[i] === Types.VAR_STRING ||
          packet.buffer[i] === Types.NULL ||
          packet.buffer[i] === Types.DOUBLE ||
          packet.buffer[i] === Types.TINY ||
          packet.buffer[i] === Types.DATETIME ||
          packet.buffer[i] === Types.JSON) &&
        packet.buffer[i + 1] === 0
      ) {
        types.push(packet.buffer[i]);
        packet.skip(2);
      }
    }

    packet.skip(1);

    const values = [];
    for (let i = 0; i < types.length; i++) {
      if (types[i] === Types.VAR_STRING) {
        values.push(packet.readLengthCodedString(encoding));
      } else if (types[i] === Types.DOUBLE) {
        values.push(packet.readDouble());
      } else if (types[i] === Types.TINY) {
        values.push(packet.readInt8());
      } else if (types[i] === Types.DATETIME) {
        values.push(packet.readDateTime());
      } else if (types[i] === Types.JSON) {
        values.push(JSON.parse(packet.readLengthCodedString(encoding)));
      }
      if (types[i] === Types.NULL) {
        values.push(null);
      }
    }

    return { stmtId, flags, iterationCount, values };
  }

  toPacket() {
    // TODO: don't try to calculate packet length in advance, allocate some big buffer in advance (header + 256 bytes?)
    // and copy + reallocate if not enough
    // 0 + 4 - length, seqId
    // 4 + 1 - COM_EXECUTE
    // 5 + 4 - stmtId
    // 9 + 1 - flags
    // 10 + 4 - iteration-count (always 1)
    let length = 14;
    let parameters;
    if (this.parameters && this.parameters.length > 0) {
      length += Math.floor((this.parameters.length + 7) / 8);
      length += 1; // new-params-bound-flag
      length += 2 * this.parameters.length; // type byte for each parameter if new-params-bound-flag is set
      parameters = this.parameters.map((value) =>
        toParameter(value, this.encoding, this.timezone)
      );
      length += parameters.reduce(
        (accumulator, parameter) => accumulator + parameter.length,
        0
      );
    }
    const buffer = Buffer.allocUnsafe(length);
    const packet = new Packet(0, buffer, 0, length);
    packet.offset = 4;
    packet.writeInt8(CommandCodes.STMT_EXECUTE);
    packet.writeInt32(this.id);
    packet.writeInt8(CursorType.NO_CURSOR); // flags
    packet.writeInt32(1); // iteration-count, always 1
    if (parameters) {
      let bitmap = 0;
      let bitValue = 1;
      parameters.forEach((parameter) => {
        if (parameter.type === Types.NULL) {
          bitmap += bitValue;
        }
        bitValue *= 2;
        if (bitValue === 256) {
          packet.writeInt8(bitmap);
          bitmap = 0;
          bitValue = 1;
        }
      });
      if (bitValue !== 1) {
        packet.writeInt8(bitmap);
      }
      // TODO: explain meaning of the flag
      // afaik, if set n*2 bytes with type of parameter are sent before parameters
      // if not, previous execution types are used (TODO prooflink)
      packet.writeInt8(1); // new-params-bound-flag
      // Write parameter types
      parameters.forEach((parameter) => {
        packet.writeInt8(parameter.type); // field type
        packet.writeInt8(0); // parameter flag
      });
      // Write parameter values
      parameters.forEach((parameter) => {
        if (parameter.type !== Types.NULL) {
          parameter.writer.call(packet, parameter.value);
        }
      });
    }
    return packet;
  }
}

module.exports = Execute;


/***/ }),

/***/ 52114:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


const Packet = __nccwpck_require__(43743);
const ClientConstants = __nccwpck_require__(70060);

// https://dev.mysql.com/doc/internals/en/connection-phase-packets.html#packet-Protocol::Handshake

class Handshake {
  constructor(args) {
    this.protocolVersion = args.protocolVersion;
    this.serverVersion = args.serverVersion;
    this.capabilityFlags = args.capabilityFlags;
    this.connectionId = args.connectionId;
    this.authPluginData1 = args.authPluginData1;
    this.authPluginData2 = args.authPluginData2;
    this.characterSet = args.characterSet;
    this.statusFlags = args.statusFlags;
    this.authPluginName = args.authPluginName;
  }

  setScrambleData(cb) {
    (__nccwpck_require__(76982).randomBytes)(20, (err, data) => {
      if (err) {
        cb(err);
        return;
      }
      this.authPluginData1 = data.slice(0, 8);
      this.authPluginData2 = data.slice(8, 20);
      cb();
    });
  }

  toPacket(sequenceId) {
    const length = 68 + Buffer.byteLength(this.serverVersion, 'utf8');
    const buffer = Buffer.alloc(length + 4, 0); // zero fill, 10 bytes filler later needs to contain zeros
    const packet = new Packet(sequenceId, buffer, 0, length + 4);
    packet.offset = 4;
    packet.writeInt8(this.protocolVersion);
    packet.writeString(this.serverVersion, 'cesu8');
    packet.writeInt8(0);
    packet.writeInt32(this.connectionId);
    packet.writeBuffer(this.authPluginData1);
    packet.writeInt8(0);
    const capabilityFlagsBuffer = Buffer.allocUnsafe(4);
    capabilityFlagsBuffer.writeUInt32LE(this.capabilityFlags, 0);
    packet.writeBuffer(capabilityFlagsBuffer.slice(0, 2));
    packet.writeInt8(this.characterSet);
    packet.writeInt16(this.statusFlags);
    packet.writeBuffer(capabilityFlagsBuffer.slice(2, 4));
    packet.writeInt8(21); // authPluginDataLength
    packet.skip(10);
    packet.writeBuffer(this.authPluginData2);
    packet.writeInt8(0);
    packet.writeString('mysql_native_password', 'latin1');
    packet.writeInt8(0);
    return packet;
  }

  static fromPacket(packet) {
    const args = {};
    args.protocolVersion = packet.readInt8();
    args.serverVersion = packet.readNullTerminatedString('cesu8');
    args.connectionId = packet.readInt32();
    args.authPluginData1 = packet.readBuffer(8);
    packet.skip(1);
    const capabilityFlagsBuffer = Buffer.allocUnsafe(4);
    capabilityFlagsBuffer[0] = packet.readInt8();
    capabilityFlagsBuffer[1] = packet.readInt8();
    if (packet.haveMoreData()) {
      args.characterSet = packet.readInt8();
      args.statusFlags = packet.readInt16();
      // upper 2 bytes
      capabilityFlagsBuffer[2] = packet.readInt8();
      capabilityFlagsBuffer[3] = packet.readInt8();
      args.capabilityFlags = capabilityFlagsBuffer.readUInt32LE(0);
      if (args.capabilityFlags & ClientConstants.PLUGIN_AUTH) {
        args.authPluginDataLength = packet.readInt8();
      } else {
        args.authPluginDataLength = 0;
        packet.skip(1);
      }
      packet.skip(10);
    } else {
      args.capabilityFlags = capabilityFlagsBuffer.readUInt16LE(0);
    }

    const isSecureConnection =
      args.capabilityFlags & ClientConstants.SECURE_CONNECTION;
    if (isSecureConnection) {
      const authPluginDataLength = args.authPluginDataLength;
      if (authPluginDataLength === 0) {
        // for Secure Password Authentication
        args.authPluginDataLength = 20;
        args.authPluginData2 = packet.readBuffer(12);
        packet.skip(1);
      } else {
        // length > 0
        // for Custom Auth Plugin (PLUGIN_AUTH)
        const len = Math.max(13, authPluginDataLength - 8);
        args.authPluginData2 = packet.readBuffer(len);
      }
    }

    if (args.capabilityFlags & ClientConstants.PLUGIN_AUTH) {
      args.authPluginName = packet.readNullTerminatedString('ascii');
    }

    return new Handshake(args);
  }
}

module.exports = Handshake;


/***/ }),

/***/ 24790:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


const ClientConstants = __nccwpck_require__(70060);
const CharsetToEncoding = __nccwpck_require__(89998);
const Packet = __nccwpck_require__(43743);

const auth41 = __nccwpck_require__(8789);

class HandshakeResponse {
  constructor(handshake) {
    this.user = handshake.user || '';
    this.database = handshake.database || '';
    this.password = handshake.password || '';
    this.passwordSha1 = handshake.passwordSha1;
    this.authPluginData1 = handshake.authPluginData1;
    this.authPluginData2 = handshake.authPluginData2;
    this.compress = handshake.compress;
    this.clientFlags = handshake.flags;
    // TODO: pre-4.1 auth support
    let authToken;
    if (this.passwordSha1) {
      authToken = auth41.calculateTokenFromPasswordSha(
        this.passwordSha1,
        this.authPluginData1,
        this.authPluginData2
      );
    } else {
      authToken = auth41.calculateToken(
        this.password,
        this.authPluginData1,
        this.authPluginData2
      );
    }
    this.authToken = authToken;
    this.charsetNumber = handshake.charsetNumber;
    this.encoding = CharsetToEncoding[handshake.charsetNumber];
    this.connectAttributes = handshake.connectAttributes;
  }

  serializeResponse(buffer) {
    const isSet = (flag) => this.clientFlags & ClientConstants[flag];
    const packet = new Packet(0, buffer, 0, buffer.length);
    packet.offset = 4;
    packet.writeInt32(this.clientFlags);
    packet.writeInt32(0); // max packet size. todo: move to config
    packet.writeInt8(this.charsetNumber);
    packet.skip(23);
    const encoding = this.encoding;
    packet.writeNullTerminatedString(this.user, encoding);
    let k;
    if (isSet('PLUGIN_AUTH_LENENC_CLIENT_DATA')) {
      packet.writeLengthCodedNumber(this.authToken.length);
      packet.writeBuffer(this.authToken);
    } else if (isSet('SECURE_CONNECTION')) {
      packet.writeInt8(this.authToken.length);
      packet.writeBuffer(this.authToken);
    } else {
      packet.writeBuffer(this.authToken);
      packet.writeInt8(0);
    }
    if (isSet('CONNECT_WITH_DB')) {
      packet.writeNullTerminatedString(this.database, encoding);
    }
    if (isSet('PLUGIN_AUTH')) {
      // TODO: pass from config
      packet.writeNullTerminatedString('mysql_native_password', 'latin1');
    }
    if (isSet('CONNECT_ATTRS')) {
      const connectAttributes = this.connectAttributes || {};
      const attrNames = Object.keys(connectAttributes);
      let keysLength = 0;
      for (k = 0; k < attrNames.length; ++k) {
        keysLength += Packet.lengthCodedStringLength(attrNames[k], encoding);
        keysLength += Packet.lengthCodedStringLength(
          connectAttributes[attrNames[k]],
          encoding
        );
      }
      packet.writeLengthCodedNumber(keysLength);
      for (k = 0; k < attrNames.length; ++k) {
        packet.writeLengthCodedString(attrNames[k], encoding);
        packet.writeLengthCodedString(
          connectAttributes[attrNames[k]],
          encoding
        );
      }
    }
    return packet;
  }

  toPacket() {
    if (typeof this.user !== 'string') {
      throw new Error('"user" connection config property must be a string');
    }
    if (typeof this.database !== 'string') {
      throw new Error('"database" connection config property must be a string');
    }
    // dry run: calculate resulting packet length
    const p = this.serializeResponse(Packet.MockBuffer());
    return this.serializeResponse(Buffer.alloc(p.offset));
  }
  static fromPacket(packet) {
    const args = {};
    args.clientFlags = packet.readInt32();
    function isSet(flag) {
      return args.clientFlags & ClientConstants[flag];
    }
    args.maxPacketSize = packet.readInt32();
    args.charsetNumber = packet.readInt8();
    const encoding = CharsetToEncoding[args.charsetNumber];
    args.encoding = encoding;
    packet.skip(23);
    args.user = packet.readNullTerminatedString(encoding);
    let authTokenLength;
    if (isSet('PLUGIN_AUTH_LENENC_CLIENT_DATA')) {
      authTokenLength = packet.readLengthCodedNumber(encoding);
      args.authToken = packet.readBuffer(authTokenLength);
    } else if (isSet('SECURE_CONNECTION')) {
      authTokenLength = packet.readInt8();
      args.authToken = packet.readBuffer(authTokenLength);
    } else {
      args.authToken = packet.readNullTerminatedString(encoding);
    }
    if (isSet('CONNECT_WITH_DB')) {
      args.database = packet.readNullTerminatedString(encoding);
    }
    if (isSet('PLUGIN_AUTH')) {
      args.authPluginName = packet.readNullTerminatedString(encoding);
    }
    if (isSet('CONNECT_ATTRS')) {
      const keysLength = packet.readLengthCodedNumber(encoding);
      const keysEnd = packet.offset + keysLength;
      const attrs = {};
      while (packet.offset < keysEnd) {
        attrs[packet.readLengthCodedString(encoding)] =
          packet.readLengthCodedString(encoding);
      }
      args.connectAttributes = attrs;
    }
    return args;
  }
}

module.exports = HandshakeResponse;


/***/ }),

/***/ 17355:
/***/ ((module, exports, __nccwpck_require__) => {

"use strict";
// This file was modified by Oracle on June 1, 2021.
// A utility method was introduced to generate an Error instance from a
// binary server packet.
// Modifications copyright (c) 2021, Oracle and/or its affiliates.

// This file was modified by Oracle on September 21, 2021.
// The new AuthNextFactor packet is now available.
// Modifications copyright (c) 2021, Oracle and/or its affiliates.



const process = __nccwpck_require__(932);

const AuthNextFactor = __nccwpck_require__(48439);
const AuthSwitchRequest = __nccwpck_require__(35438);
const AuthSwitchRequestMoreData = __nccwpck_require__(38743);
const AuthSwitchResponse = __nccwpck_require__(1760);
const BinaryRow = __nccwpck_require__(3453);
const BinlogDump = __nccwpck_require__(71251);
const ChangeUser = __nccwpck_require__(16549);
const CloseStatement = __nccwpck_require__(94077);
const ColumnDefinition = __nccwpck_require__(57485);
const Execute = __nccwpck_require__(35764);
const Handshake = __nccwpck_require__(52114);
const HandshakeResponse = __nccwpck_require__(24790);
const PrepareStatement = __nccwpck_require__(49450);
const PreparedStatementHeader = __nccwpck_require__(80678);
const Query = __nccwpck_require__(32459);
const RegisterSlave = __nccwpck_require__(41370);
const ResultSetHeader = __nccwpck_require__(11486);
const SSLRequest = __nccwpck_require__(26315);
const TextRow = __nccwpck_require__(28107);

const ctorMap = {
  AuthNextFactor,
  AuthSwitchRequest,
  AuthSwitchRequestMoreData,
  AuthSwitchResponse,
  BinaryRow,
  BinlogDump,
  ChangeUser,
  CloseStatement,
  ColumnDefinition,
  Execute,
  Handshake,
  HandshakeResponse,
  PrepareStatement,
  PreparedStatementHeader,
  Query,
  RegisterSlave,
  ResultSetHeader,
  SSLRequest,
  TextRow,
};
Object.entries(ctorMap).forEach(([name, ctor]) => {
  module.exports[name] = ctor;
  // monkey-patch it to include name if debug is on
  if (process.env.NODE_DEBUG) {
    if (ctor.prototype.toPacket) {
      const old = ctor.prototype.toPacket;
      ctor.prototype.toPacket = function () {
        const p = old.call(this);
        p._name = name;
        return p;
      };
    }
  }
});

// simple packets:
const Packet = __nccwpck_require__(43743);
exports.Packet = Packet;

class OK {
  static toPacket(args, encoding) {
    args = args || {};
    const affectedRows = args.affectedRows || 0;
    const insertId = args.insertId || 0;
    const serverStatus = args.serverStatus || 0;
    const warningCount = args.warningCount || 0;
    const message = args.message || '';

    let length = 9 + Packet.lengthCodedNumberLength(affectedRows);
    length += Packet.lengthCodedNumberLength(insertId);

    const buffer = Buffer.allocUnsafe(length);
    const packet = new Packet(0, buffer, 0, length);
    packet.offset = 4;
    packet.writeInt8(0);
    packet.writeLengthCodedNumber(affectedRows);
    packet.writeLengthCodedNumber(insertId);
    packet.writeInt16(serverStatus);
    packet.writeInt16(warningCount);
    packet.writeString(message, encoding);
    packet._name = 'OK';
    return packet;
  }
}

exports.OK = OK;

// warnings, statusFlags
class EOF {
  static toPacket(warnings, statusFlags) {
    if (typeof warnings === 'undefined') {
      warnings = 0;
    }
    if (typeof statusFlags === 'undefined') {
      statusFlags = 0;
    }
    const packet = new Packet(0, Buffer.allocUnsafe(9), 0, 9);
    packet.offset = 4;
    packet.writeInt8(0xfe);
    packet.writeInt16(warnings);
    packet.writeInt16(statusFlags);
    packet._name = 'EOF';
    return packet;
  }
}

exports.EOF = EOF;

class Error {
  static toPacket(args, encoding) {
    const length = 13 + Buffer.byteLength(args.message, 'utf8');
    const packet = new Packet(0, Buffer.allocUnsafe(length), 0, length);
    packet.offset = 4;
    packet.writeInt8(0xff);
    packet.writeInt16(args.code);
    // TODO: sql state parameter
    packet.writeString('#_____', encoding);
    packet.writeString(args.message, encoding);
    packet._name = 'Error';
    return packet;
  }

  static fromPacket(packet) {
    packet.readInt8(); // marker
    const code = packet.readInt16();
    packet.readString(1, 'ascii'); // sql state marker
    // The SQL state of the ERR_Packet which is always 5 bytes long.
    // https://dev.mysql.com/doc/dev/mysql-server/8.0.11/page_protocol_basic_dt_strings.html#sect_protocol_basic_dt_string_fix
    packet.readString(5, 'ascii'); // sql state (ignore for now)
    const message = packet.readNullTerminatedString('utf8');
    const error = new Error();
    error.message = message;
    error.code = code;
    return error;
  }
}

exports.Error = Error;


/***/ }),

/***/ 43743:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";
// This file was modified by Oracle on June 1, 2021.
// A comment describing some changes in the strict default SQL mode regarding
// non-standard dates was introduced.
// Modifications copyright (c) 2021, Oracle and/or its affiliates.



const ErrorCodeToName = __nccwpck_require__(89228);
const NativeBuffer = (__nccwpck_require__(20181).Buffer);
const Long = __nccwpck_require__(66390);
const StringParser = __nccwpck_require__(86809);
const Types = __nccwpck_require__(95490);
const INVALID_DATE = new Date(NaN);

// this is nearly duplicate of previous function so generated code is not slower
// due to "if (dateStrings)" branching
const pad = '000000000000';
function leftPad(num, value) {
  const s = value.toString();
  // if we don't need to pad
  if (s.length >= num) {
    return s;
  }
  return (pad + s).slice(-num);
}

// The whole reason parse* function below exist
// is because String creation is relatively expensive (at least with V8), and if we have
// a buffer with "12345" content ideally we would like to bypass intermediate
// "12345" string creation and directly build 12345 number out of
// <Buffer 31 32 33 34 35> data.
// In my benchmarks the difference is ~25M 8-digit numbers per second vs
// 4.5 M using Number(packet.readLengthCodedString())
// not used when size is close to max precision as series of *10 accumulate error
// and approximate result mihgt be diffreent from (approximate as well) Number(bigNumStringValue))
// In the futire node version if speed difference is smaller parse* functions might be removed
// don't consider them as Packet public API

const minus = '-'.charCodeAt(0);
const plus = '+'.charCodeAt(0);

// TODO: handle E notation
const dot = '.'.charCodeAt(0);
const exponent = 'e'.charCodeAt(0);
const exponentCapital = 'E'.charCodeAt(0);

class Packet {
  constructor(id, buffer, start, end) {
    // hot path, enable checks when testing only
    // if (!Buffer.isBuffer(buffer) || typeof start == 'undefined' || typeof end == 'undefined')
    //  throw new Error('invalid packet');
    this.sequenceId = id;
    this.numPackets = 1;
    this.buffer = buffer;
    this.start = start;
    this.offset = start + 4;
    this.end = end;
  }

  // ==============================
  // readers
  // ==============================
  reset() {
    this.offset = this.start + 4;
  }

  length() {
    return this.end - this.start;
  }

  slice() {
    return this.buffer.slice(this.start, this.end);
  }

  dump() {
    // eslint-disable-next-line no-console
    console.log(
      [this.buffer.asciiSlice(this.start, this.end)],
      this.buffer.slice(this.start, this.end),
      this.length(),
      this.sequenceId
    );
  }

  haveMoreData() {
    return this.end > this.offset;
  }

  skip(num) {
    this.offset += num;
  }

  readInt8() {
    return this.buffer[this.offset++];
  }

  readInt16() {
    this.offset += 2;
    return this.buffer.readUInt16LE(this.offset - 2);
  }

  readInt24() {
    return this.readInt16() + (this.readInt8() << 16);
  }

  readInt32() {
    this.offset += 4;
    return this.buffer.readUInt32LE(this.offset - 4);
  }

  readSInt8() {
    return this.buffer.readInt8(this.offset++);
  }

  readSInt16() {
    this.offset += 2;
    return this.buffer.readInt16LE(this.offset - 2);
  }

  readSInt32() {
    this.offset += 4;
    return this.buffer.readInt32LE(this.offset - 4);
  }

  readInt64JSNumber() {
    const word0 = this.readInt32();
    const word1 = this.readInt32();
    const l = new Long(word0, word1, true);
    return l.toNumber();
  }

  readSInt64JSNumber() {
    const word0 = this.readInt32();
    const word1 = this.readInt32();
    if (!(word1 & 0x80000000)) {
      return word0 + 0x100000000 * word1;
    }
    const l = new Long(word0, word1, false);
    return l.toNumber();
  }

  readInt64String() {
    const word0 = this.readInt32();
    const word1 = this.readInt32();
    const res = new Long(word0, word1, true);
    return res.toString();
  }

  readSInt64String() {
    const word0 = this.readInt32();
    const word1 = this.readInt32();
    const res = new Long(word0, word1, false);
    return res.toString();
  }

  readInt64() {
    const word0 = this.readInt32();
    const word1 = this.readInt32();
    let res = new Long(word0, word1, true);
    const resNumber = res.toNumber();
    const resString = res.toString();
    res = resNumber.toString() === resString ? resNumber : resString;
    return res;
  }

  readSInt64() {
    const word0 = this.readInt32();
    const word1 = this.readInt32();
    let res = new Long(word0, word1, false);
    const resNumber = res.toNumber();
    const resString = res.toString();
    res = resNumber.toString() === resString ? resNumber : resString;
    return res;
  }

  isEOF() {
    return this.buffer[this.offset] === 0xfe && this.length() < 13;
  }

  eofStatusFlags() {
    return this.buffer.readInt16LE(this.offset + 3);
  }

  eofWarningCount() {
    return this.buffer.readInt16LE(this.offset + 1);
  }

  readLengthCodedNumber(bigNumberStrings, signed) {
    const byte1 = this.buffer[this.offset++];
    if (byte1 < 251) {
      return byte1;
    }
    return this.readLengthCodedNumberExt(byte1, bigNumberStrings, signed);
  }

  readLengthCodedNumberSigned(bigNumberStrings) {
    return this.readLengthCodedNumber(bigNumberStrings, true);
  }

  readLengthCodedNumberExt(tag, bigNumberStrings, signed) {
    let word0, word1;
    let res;
    if (tag === 0xfb) {
      return null;
    }
    if (tag === 0xfc) {
      return this.readInt8() + (this.readInt8() << 8);
    }
    if (tag === 0xfd) {
      return this.readInt8() + (this.readInt8() << 8) + (this.readInt8() << 16);
    }
    if (tag === 0xfe) {
      // TODO: check version
      // Up to MySQL 3.22, 0xfe was followed by a 4-byte integer.
      word0 = this.readInt32();
      word1 = this.readInt32();
      if (word1 === 0) {
        return word0; // don't convert to float if possible
      }
      if (word1 < 2097152) {
        // max exact float point int, 2^52 / 2^32
        return word1 * 0x100000000 + word0;
      }
      res = new Long(word0, word1, !signed); // Long need unsigned
      const resNumber = res.toNumber();
      const resString = res.toString();
      res = resNumber.toString() === resString ? resNumber : resString;
      return bigNumberStrings ? resString : res;
    }
    // eslint-disable-next-line no-console
    console.trace();
    throw new Error(`Should not reach here: ${tag}`);
  }

  readFloat() {
    const res = this.buffer.readFloatLE(this.offset);
    this.offset += 4;
    return res;
  }

  readDouble() {
    const res = this.buffer.readDoubleLE(this.offset);
    this.offset += 8;
    return res;
  }

  readBuffer(len) {
    if (typeof len === 'undefined') {
      len = this.end - this.offset;
    }
    this.offset += len;
    return this.buffer.slice(this.offset - len, this.offset);
  }

  // DATE, DATETIME and TIMESTAMP
  readDateTime(timezone) {
    if (!timezone || timezone === 'Z' || timezone === 'local') {
      const length = this.readInt8();
      if (length === 0xfb) {
        return null;
      }
      let y = 0;
      let m = 0;
      let d = 0;
      let H = 0;
      let M = 0;
      let S = 0;
      let ms = 0;
      if (length > 3) {
        y = this.readInt16();
        m = this.readInt8();
        d = this.readInt8();
      }
      if (length > 6) {
        H = this.readInt8();
        M = this.readInt8();
        S = this.readInt8();
      }
      if (length > 10) {
        ms = this.readInt32() / 1000;
      }
      // NO_ZERO_DATE mode and NO_ZERO_IN_DATE mode are part of the strict
      // default SQL mode used by MySQL 8.0. This means that non-standard
      // dates like '0000-00-00' become NULL. For older versions and other
      // possible MySQL flavours we still need to account for the
      // non-standard behaviour.
      if (y + m + d + H + M + S + ms === 0) {
        return INVALID_DATE;
      }
      if (timezone === 'Z') {
        return new Date(Date.UTC(y, m - 1, d, H, M, S, ms));
      }
      return new Date(y, m - 1, d, H, M, S, ms);
    }
    let str = this.readDateTimeString(6, 'T', null);
    if (str.length === 10) {
      str += 'T00:00:00';
    }
    return new Date(str + timezone);
  }

  readDateTimeString(decimals, timeSep, columnType) {
    const length = this.readInt8();
    let y = 0;
    let m = 0;
    let d = 0;
    let H = 0;
    let M = 0;
    let S = 0;
    let ms = 0;
    let str;
    if (length > 3) {
      y = this.readInt16();
      m = this.readInt8();
      d = this.readInt8();
      str = [leftPad(4, y), leftPad(2, m), leftPad(2, d)].join('-');
    }
    if (length > 6) {
      H = this.readInt8();
      M = this.readInt8();
      S = this.readInt8();
      str += `${timeSep || ' '}${[
        leftPad(2, H),
        leftPad(2, M),
        leftPad(2, S),
      ].join(':')}`;
    } else if (columnType === Types.DATETIME) {
      str += ' 00:00:00';
    }
    if (length > 10) {
      ms = this.readInt32();
      str += '.';
      if (decimals) {
        ms = leftPad(6, ms);
        if (ms.length > decimals) {
          ms = ms.substring(0, decimals); // rounding is done at the MySQL side, only 0 are here
        }
      }
      str += ms;
    }
    return str;
  }

  // TIME - value as a string, Can be negative
  readTimeString(convertTtoMs) {
    const length = this.readInt8();
    if (length === 0) {
      return '00:00:00';
    }
    const sign = this.readInt8() ? -1 : 1; // 'isNegative' flag byte
    let d = 0;
    let H = 0;
    let M = 0;
    let S = 0;
    let ms = 0;
    if (length > 6) {
      d = this.readInt32();
      H = this.readInt8();
      M = this.readInt8();
      S = this.readInt8();
    }
    if (length > 10) {
      ms = this.readInt32();
    }
    if (convertTtoMs) {
      H += d * 24;
      M += H * 60;
      S += M * 60;
      ms += S * 1000;
      ms *= sign;
      return ms;
    }
    // Format follows mySQL TIME format ([-][h]hh:mm:ss[.u[u[u[u[u[u]]]]]])
    // For positive times below 24 hours, this makes it equal to ISO 8601 times
    return (
      (sign === -1 ? '-' : '') +
      [leftPad(2, d * 24 + H), leftPad(2, M), leftPad(2, S)].join(':') +
      (ms ? `.${ms}`.replace(/0+$/, '') : '')
    );
  }

  readLengthCodedString(encoding) {
    const len = this.readLengthCodedNumber();
    // TODO: check manually first byte here to avoid polymorphic return type?
    if (len === null) {
      return null;
    }
    this.offset += len;
    // TODO: Use characterSetCode to get proper encoding
    // https://github.com/sidorares/node-mysql2/pull/374
    return StringParser.decode(
      this.buffer,
      encoding,
      this.offset - len,
      this.offset
    );
  }

  readLengthCodedBuffer() {
    const len = this.readLengthCodedNumber();
    if (len === null) {
      return null;
    }
    return this.readBuffer(len);
  }

  readNullTerminatedString(encoding) {
    const start = this.offset;
    let end = this.offset;
    while (this.buffer[end]) {
      end = end + 1; // TODO: handle OOB check
    }
    this.offset = end + 1;
    return StringParser.decode(this.buffer, encoding, start, end);
  }

  // TODO reuse?
  readString(len, encoding) {
    if (typeof len === 'string' && typeof encoding === 'undefined') {
      encoding = len;
      len = undefined;
    }
    if (typeof len === 'undefined') {
      len = this.end - this.offset;
    }
    this.offset += len;
    return StringParser.decode(
      this.buffer,
      encoding,
      this.offset - len,
      this.offset
    );
  }

  parseInt(len, supportBigNumbers) {
    if (len === null) {
      return null;
    }
    if (len >= 14 && !supportBigNumbers) {
      const s = this.buffer.toString('ascii', this.offset, this.offset + len);
      this.offset += len;
      return Number(s);
    }
    let result = 0;
    const start = this.offset;
    const end = this.offset + len;
    let sign = 1;
    if (len === 0) {
      return 0; // TODO: assert? exception?
    }
    if (this.buffer[this.offset] === minus) {
      this.offset++;
      sign = -1;
    }
    // max precise int is 9007199254740992
    let str;
    const numDigits = end - this.offset;
    if (supportBigNumbers) {
      if (numDigits >= 15) {
        str = this.readString(end - this.offset, 'binary');
        result = parseInt(str, 10);
        if (result.toString() === str) {
          return sign * result;
        }
        return sign === -1 ? `-${str}` : str;
      }
      if (numDigits > 16) {
        str = this.readString(end - this.offset);
        return sign === -1 ? `-${str}` : str;
      }
    }
    if (this.buffer[this.offset] === plus) {
      this.offset++; // just ignore
    }
    while (this.offset < end) {
      result *= 10;
      result += this.buffer[this.offset] - 48;
      this.offset++;
    }
    const num = result * sign;
    if (!supportBigNumbers) {
      return num;
    }
    str = this.buffer.toString('ascii', start, end);
    if (num.toString() === str) {
      return num;
    }
    return str;
  }

  // note that if value of inputNumberAsString is bigger than MAX_SAFE_INTEGER
  // ( or smaller than MIN_SAFE_INTEGER ) the parseIntNoBigCheck result might be
  // different from what you would get from Number(inputNumberAsString)
  // String(parseIntNoBigCheck) <> String(Number(inputNumberAsString)) <> inputNumberAsString
  parseIntNoBigCheck(len) {
    if (len === null) {
      return null;
    }
    let result = 0;
    const end = this.offset + len;
    let sign = 1;
    if (len === 0) {
      return 0; // TODO: assert? exception?
    }
    if (this.buffer[this.offset] === minus) {
      this.offset++;
      sign = -1;
    }
    if (this.buffer[this.offset] === plus) {
      this.offset++; // just ignore
    }
    while (this.offset < end) {
      result *= 10;
      result += this.buffer[this.offset] - 48;
      this.offset++;
    }
    return result * sign;
  }

  // copy-paste from https://github.com/mysqljs/mysql/blob/master/lib/protocol/Parser.js
  parseGeometryValue() {
    const buffer = this.readLengthCodedBuffer();
    let offset = 4;
    if (buffer === null || !buffer.length) {
      return null;
    }
    function parseGeometry() {
      let x, y, i, j, numPoints, line;
      let result = null;
      const byteOrder = buffer.readUInt8(offset);
      offset += 1;
      const wkbType = byteOrder
        ? buffer.readUInt32LE(offset)
        : buffer.readUInt32BE(offset);
      offset += 4;
      switch (wkbType) {
        case 1: // WKBPoint
          x = byteOrder
            ? buffer.readDoubleLE(offset)
            : buffer.readDoubleBE(offset);
          offset += 8;
          y = byteOrder
            ? buffer.readDoubleLE(offset)
            : buffer.readDoubleBE(offset);
          offset += 8;
          result = { x: x, y: y };
          break;
        case 2: // WKBLineString
          numPoints = byteOrder
            ? buffer.readUInt32LE(offset)
            : buffer.readUInt32BE(offset);
          offset += 4;
          result = [];
          for (i = numPoints; i > 0; i--) {
            x = byteOrder
              ? buffer.readDoubleLE(offset)
              : buffer.readDoubleBE(offset);
            offset += 8;
            y = byteOrder
              ? buffer.readDoubleLE(offset)
              : buffer.readDoubleBE(offset);
            offset += 8;
            result.push({ x: x, y: y });
          }
          break;
        case 3: // WKBPolygon
          // eslint-disable-next-line no-case-declarations
          const numRings = byteOrder
            ? buffer.readUInt32LE(offset)
            : buffer.readUInt32BE(offset);
          offset += 4;
          result = [];
          for (i = numRings; i > 0; i--) {
            numPoints = byteOrder
              ? buffer.readUInt32LE(offset)
              : buffer.readUInt32BE(offset);
            offset += 4;
            line = [];
            for (j = numPoints; j > 0; j--) {
              x = byteOrder
                ? buffer.readDoubleLE(offset)
                : buffer.readDoubleBE(offset);
              offset += 8;
              y = byteOrder
                ? buffer.readDoubleLE(offset)
                : buffer.readDoubleBE(offset);
              offset += 8;
              line.push({ x: x, y: y });
            }
            result.push(line);
          }
          break;
        case 4: // WKBMultiPoint
        case 5: // WKBMultiLineString
        case 6: // WKBMultiPolygon
        case 7: // WKBGeometryCollection
          // eslint-disable-next-line no-case-declarations
          const num = byteOrder
            ? buffer.readUInt32LE(offset)
            : buffer.readUInt32BE(offset);
          offset += 4;
          result = [];
          for (i = num; i > 0; i--) {
            result.push(parseGeometry());
          }
          break;
      }
      return result;
    }
    return parseGeometry();
  }

  parseVector() {
    const bufLen = this.readLengthCodedNumber();
    const vectorEnd = this.offset + bufLen;
    const result = [];
    while (this.offset < vectorEnd && this.offset < this.end) {
      result.push(this.readFloat());
    }
    return result;
  }

  parseDate(timezone) {
    const strLen = this.readLengthCodedNumber();
    if (strLen === null) {
      return null;
    }
    if (strLen !== 10) {
      // we expect only YYYY-MM-DD here.
      // if for some reason it's not the case return invalid date
      return new Date(NaN);
    }
    const y = this.parseInt(4);
    this.offset++; // -
    const m = this.parseInt(2);
    this.offset++; // -
    const d = this.parseInt(2);
    if (!timezone || timezone === 'local') {
      return new Date(y, m - 1, d);
    }
    if (timezone === 'Z') {
      return new Date(Date.UTC(y, m - 1, d));
    }
    return new Date(
      `${leftPad(4, y)}-${leftPad(2, m)}-${leftPad(2, d)}T00:00:00${timezone}`
    );
  }

  parseDateTime(timezone) {
    const str = this.readLengthCodedString('binary');
    if (str === null) {
      return null;
    }
    if (!timezone || timezone === 'local') {
      return new Date(str);
    }
    return new Date(`${str}${timezone}`);
  }

  parseFloat(len) {
    if (len === null) {
      return null;
    }
    let result = 0;
    const end = this.offset + len;
    let factor = 1;
    let pastDot = false;
    let charCode = 0;
    if (len === 0) {
      return 0; // TODO: assert? exception?
    }
    if (this.buffer[this.offset] === minus) {
      this.offset++;
      factor = -1;
    }
    if (this.buffer[this.offset] === plus) {
      this.offset++; // just ignore
    }
    while (this.offset < end) {
      charCode = this.buffer[this.offset];
      if (charCode === dot) {
        pastDot = true;
        this.offset++;
      } else if (charCode === exponent || charCode === exponentCapital) {
        this.offset++;
        const exponentValue = this.parseInt(end - this.offset);
        return (result / factor) * Math.pow(10, exponentValue);
      } else {
        result *= 10;
        result += this.buffer[this.offset] - 48;
        this.offset++;
        if (pastDot) {
          factor = factor * 10;
        }
      }
    }
    return result / factor;
  }

  parseLengthCodedIntNoBigCheck() {
    return this.parseIntNoBigCheck(this.readLengthCodedNumber());
  }

  parseLengthCodedInt(supportBigNumbers) {
    return this.parseInt(this.readLengthCodedNumber(), supportBigNumbers);
  }

  parseLengthCodedIntString() {
    return this.readLengthCodedString('binary');
  }

  parseLengthCodedFloat() {
    return this.parseFloat(this.readLengthCodedNumber());
  }

  peekByte() {
    return this.buffer[this.offset];
  }

  // OxFE is often used as "Alt" flag - not ok, not error.
  // For example, it's first byte of AuthSwitchRequest
  isAlt() {
    return this.peekByte() === 0xfe;
  }

  isError() {
    return this.peekByte() === 0xff;
  }

  asError(encoding) {
    this.reset();
    this.readInt8(); // fieldCount
    const errorCode = this.readInt16();
    let sqlState = '';
    if (this.buffer[this.offset] === 0x23) {
      this.skip(1);
      sqlState = this.readBuffer(5).toString();
    }
    const message = this.readString(undefined, encoding);
    const err = new Error(message);
    err.code = ErrorCodeToName[errorCode];
    err.errno = errorCode;
    err.sqlState = sqlState;
    err.sqlMessage = message;
    return err;
  }

  writeInt32(n) {
    this.buffer.writeUInt32LE(n, this.offset);
    this.offset += 4;
  }

  writeInt24(n) {
    this.writeInt8(n & 0xff);
    this.writeInt16(n >> 8);
  }

  writeInt16(n) {
    this.buffer.writeUInt16LE(n, this.offset);
    this.offset += 2;
  }

  writeInt8(n) {
    this.buffer.writeUInt8(n, this.offset);
    this.offset++;
  }

  writeDouble(n) {
    this.buffer.writeDoubleLE(n, this.offset);
    this.offset += 8;
  }

  writeBuffer(b) {
    b.copy(this.buffer, this.offset);
    this.offset += b.length;
  }

  writeNull() {
    this.buffer[this.offset] = 0xfb;
    this.offset++;
  }

  // TODO: refactor following three?
  writeNullTerminatedString(s, encoding) {
    const buf = StringParser.encode(s, encoding);
    this.buffer.length && buf.copy(this.buffer, this.offset);
    this.offset += buf.length;
    this.writeInt8(0);
  }

  writeString(s, encoding) {
    if (s === null) {
      this.writeInt8(0xfb);
      return;
    }
    if (s.length === 0) {
      return;
    }
    // const bytes = Buffer.byteLength(s, 'utf8');
    // this.buffer.write(s, this.offset, bytes, 'utf8');
    // this.offset += bytes;
    const buf = StringParser.encode(s, encoding);
    this.buffer.length && buf.copy(this.buffer, this.offset);
    this.offset += buf.length;
  }

  writeLengthCodedString(s, encoding) {
    const buf = StringParser.encode(s, encoding);
    this.writeLengthCodedNumber(buf.length);
    this.buffer.length && buf.copy(this.buffer, this.offset);
    this.offset += buf.length;
  }

  writeLengthCodedBuffer(b) {
    this.writeLengthCodedNumber(b.length);
    b.copy(this.buffer, this.offset);
    this.offset += b.length;
  }

  writeLengthCodedNumber(n) {
    if (n < 0xfb) {
      return this.writeInt8(n);
    }
    if (n < 0xffff) {
      this.writeInt8(0xfc);
      return this.writeInt16(n);
    }
    if (n < 0xffffff) {
      this.writeInt8(0xfd);
      return this.writeInt24(n);
    }
    if (n === null) {
      return this.writeInt8(0xfb);
    }
    // TODO: check that n is out of int precision
    this.writeInt8(0xfe);
    this.buffer.writeUInt32LE(n, this.offset);
    this.offset += 4;
    this.buffer.writeUInt32LE(n >> 32, this.offset);
    this.offset += 4;
    return this.offset;
  }

  writeDate(d, timezone) {
    this.buffer.writeUInt8(11, this.offset);
    if (!timezone || timezone === 'local') {
      this.buffer.writeUInt16LE(d.getFullYear(), this.offset + 1);
      this.buffer.writeUInt8(d.getMonth() + 1, this.offset + 3);
      this.buffer.writeUInt8(d.getDate(), this.offset + 4);
      this.buffer.writeUInt8(d.getHours(), this.offset + 5);
      this.buffer.writeUInt8(d.getMinutes(), this.offset + 6);
      this.buffer.writeUInt8(d.getSeconds(), this.offset + 7);
      this.buffer.writeUInt32LE(d.getMilliseconds() * 1000, this.offset + 8);
    } else {
      if (timezone !== 'Z') {
        const offset =
          (timezone[0] === '-' ? -1 : 1) *
          (parseInt(timezone.substring(1, 3), 10) * 60 +
            parseInt(timezone.substring(4), 10));
        if (offset !== 0) {
          d = new Date(d.getTime() + 60000 * offset);
        }
      }
      this.buffer.writeUInt16LE(d.getUTCFullYear(), this.offset + 1);
      this.buffer.writeUInt8(d.getUTCMonth() + 1, this.offset + 3);
      this.buffer.writeUInt8(d.getUTCDate(), this.offset + 4);
      this.buffer.writeUInt8(d.getUTCHours(), this.offset + 5);
      this.buffer.writeUInt8(d.getUTCMinutes(), this.offset + 6);
      this.buffer.writeUInt8(d.getUTCSeconds(), this.offset + 7);
      this.buffer.writeUInt32LE(d.getUTCMilliseconds() * 1000, this.offset + 8);
    }
    this.offset += 12;
  }

  writeHeader(sequenceId) {
    const offset = this.offset;
    this.offset = 0;
    this.writeInt24(this.buffer.length - 4);
    this.writeInt8(sequenceId);
    this.offset = offset;
  }

  clone() {
    return new Packet(this.sequenceId, this.buffer, this.start, this.end);
  }

  type() {
    if (this.isEOF()) {
      return 'EOF';
    }
    if (this.isError()) {
      return 'Error';
    }
    if (this.buffer[this.offset] === 0) {
      return 'maybeOK'; // could be other packet types as well
    }
    return '';
  }

  static lengthCodedNumberLength(n) {
    if (n < 0xfb) {
      return 1;
    }
    if (n < 0xffff) {
      return 3;
    }
    if (n < 0xffffff) {
      return 5;
    }
    return 9;
  }

  static lengthCodedStringLength(str, encoding) {
    const buf = StringParser.encode(str, encoding);
    const slen = buf.length;
    return Packet.lengthCodedNumberLength(slen) + slen;
  }

  static MockBuffer() {
    const noop = function () {};
    const res = Buffer.alloc(0);
    for (const op in NativeBuffer.prototype) {
      if (typeof res[op] === 'function') {
        res[op] = noop;
      }
    }
    return res;
  }
}

module.exports = Packet;


/***/ }),

/***/ 49450:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


const Packet = __nccwpck_require__(43743);
const CommandCodes = __nccwpck_require__(17361);
const StringParser = __nccwpck_require__(86809);
const CharsetToEncoding = __nccwpck_require__(89998);

class PrepareStatement {
  constructor(sql, charsetNumber) {
    this.query = sql;
    this.charsetNumber = charsetNumber;
    this.encoding = CharsetToEncoding[charsetNumber];
  }

  toPacket() {
    const buf = StringParser.encode(this.query, this.encoding);
    const length = 5 + buf.length;
    const buffer = Buffer.allocUnsafe(length);
    const packet = new Packet(0, buffer, 0, length);
    packet.offset = 4;
    packet.writeInt8(CommandCodes.STMT_PREPARE);
    packet.writeBuffer(buf);
    return packet;
  }
}

module.exports = PrepareStatement;


/***/ }),

/***/ 80678:
/***/ ((module) => {

"use strict";


class PreparedStatementHeader {
  constructor(packet) {
    packet.skip(1); // should be 0
    this.id = packet.readInt32();
    this.fieldCount = packet.readInt16();
    this.parameterCount = packet.readInt16();
    packet.skip(1); // should be 0
    this.warningCount = packet.readInt16();
  }
}

// TODO: toPacket

module.exports = PreparedStatementHeader;


/***/ }),

/***/ 32459:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


const Packet = __nccwpck_require__(43743);
const CommandCode = __nccwpck_require__(17361);
const StringParser = __nccwpck_require__(86809);
const CharsetToEncoding = __nccwpck_require__(89998);

class Query {
  constructor(sql, charsetNumber) {
    this.query = sql;
    this.charsetNumber = charsetNumber;
    this.encoding = CharsetToEncoding[charsetNumber];
  }

  toPacket() {
    const buf = StringParser.encode(this.query, this.encoding);
    const length = 5 + buf.length;
    const buffer = Buffer.allocUnsafe(length);
    const packet = new Packet(0, buffer, 0, length);
    packet.offset = 4;
    packet.writeInt8(CommandCode.QUERY);
    packet.writeBuffer(buf);
    return packet;
  }
}

module.exports = Query;


/***/ }),

/***/ 41370:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


// http://dev.mysql.com/doc/internals/en/com-register-slave.html
// note that documentation is incorrect, for example command code is actually 0x15 but documented as 0x14

const Packet = __nccwpck_require__(43743);
const CommandCodes = __nccwpck_require__(17361);

class RegisterSlave {
  constructor(opts) {
    this.serverId = opts.serverId || 0;
    this.slaveHostname = opts.slaveHostname || '';
    this.slaveUser = opts.slaveUser || '';
    this.slavePassword = opts.slavePassword || '';
    this.slavePort = opts.slavePort || 0;
    this.replicationRank = opts.replicationRank || 0;
    this.masterId = opts.masterId || 0;
  }

  toPacket() {
    const length =
      15 + // TODO: should be ascii?
      Buffer.byteLength(this.slaveHostname, 'utf8') +
      Buffer.byteLength(this.slaveUser, 'utf8') +
      Buffer.byteLength(this.slavePassword, 'utf8') +
      3 +
      4;
    const buffer = Buffer.allocUnsafe(length);
    const packet = new Packet(0, buffer, 0, length);
    packet.offset = 4;
    packet.writeInt8(CommandCodes.REGISTER_SLAVE);
    packet.writeInt32(this.serverId);
    packet.writeInt8(Buffer.byteLength(this.slaveHostname, 'utf8'));
    packet.writeString(this.slaveHostname);
    packet.writeInt8(Buffer.byteLength(this.slaveUser, 'utf8'));
    packet.writeString(this.slaveUser);
    packet.writeInt8(Buffer.byteLength(this.slavePassword, 'utf8'));
    packet.writeString(this.slavePassword);
    packet.writeInt16(this.slavePort);
    packet.writeInt32(this.replicationRank);
    packet.writeInt32(this.masterId);
    return packet;
  }
}

module.exports = RegisterSlave;


/***/ }),

/***/ 11486:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


// TODO: rename to OK packet
// https://dev.mysql.com/doc/internals/en/packet-OK_Packet.html

const Packet = __nccwpck_require__(43743);
const ClientConstants = __nccwpck_require__(70060);
const ServerSatusFlags = __nccwpck_require__(92609);

const EncodingToCharset = __nccwpck_require__(2197);
const sessionInfoTypes = __nccwpck_require__(94335);

class ResultSetHeader {
  constructor(packet, connection) {
    const bigNumberStrings = connection.config.bigNumberStrings;
    const encoding = connection.serverEncoding;
    const flags = connection._handshakePacket.capabilityFlags;
    const isSet = function (flag) {
      return flags & ClientConstants[flag];
    };
    if (packet.buffer[packet.offset] !== 0) {
      this.fieldCount = packet.readLengthCodedNumber();
      if (this.fieldCount === null) {
        this.infileName = packet.readString(undefined, encoding);
      }
      return;
    }
    this.fieldCount = packet.readInt8(); // skip OK byte
    this.affectedRows = packet.readLengthCodedNumber(bigNumberStrings);
    this.insertId = packet.readLengthCodedNumberSigned(bigNumberStrings);
    this.info = '';
    if (isSet('PROTOCOL_41')) {
      this.serverStatus = packet.readInt16();
      this.warningStatus = packet.readInt16();
    } else if (isSet('TRANSACTIONS')) {
      this.serverStatus = packet.readInt16();
    }
    let stateChanges = null;
    if (isSet('SESSION_TRACK') && packet.offset < packet.end) {
      this.info = packet.readLengthCodedString(encoding);

      if (this.serverStatus && ServerSatusFlags.SERVER_SESSION_STATE_CHANGED) {
        // session change info record - see
        // https://dev.mysql.com/doc/internals/en/packet-OK_Packet.html#cs-sect-packet-ok-sessioninfo
        let len =
          packet.offset < packet.end ? packet.readLengthCodedNumber() : 0;
        const end = packet.offset + len;
        let type, key, stateEnd;
        if (len > 0) {
          stateChanges = {
            systemVariables: {},
            schema: null,
            gtids: [],
            trackStateChange: null,
          };
        }
        while (packet.offset < end) {
          type = packet.readInt8();
          len = packet.readLengthCodedNumber();
          stateEnd = packet.offset + len;
          if (type === sessionInfoTypes.SYSTEM_VARIABLES) {
            key = packet.readLengthCodedString(encoding);
            const val = packet.readLengthCodedString(encoding);
            stateChanges.systemVariables[key] = val;
            if (key === 'character_set_client') {
              const charsetNumber = EncodingToCharset[val];
              // TODO - better api for driver users to handle unknown encodings?
              // maybe custom coverter in the config?
              // For now just ignore character_set_client command if there is
              // no known mapping from reported encoding to a charset code
              if (typeof charsetNumber !== 'undefined') {
                connection.config.charsetNumber = charsetNumber;
              }
            }
          } else if (type === sessionInfoTypes.SCHEMA) {
            key = packet.readLengthCodedString(encoding);
            stateChanges.schema = key;
          } else if (type === sessionInfoTypes.STATE_CHANGE) {
            stateChanges.trackStateChange =
              packet.readLengthCodedString(encoding);
          } else if (type === sessionInfoTypes.STATE_GTIDS) {
            // TODO: find if the first length coded string means anything. Usually comes as empty
            // eslint-disable-next-line no-unused-vars
            const _unknownString = packet.readLengthCodedString(encoding);
            const gtid = packet.readLengthCodedString(encoding);
            stateChanges.gtids = gtid.split(',');
          } else {
            // unsupported session track type. For now just ignore
          }
          packet.offset = stateEnd;
        }
      }
    } else {
      this.info = packet.readString(undefined, encoding);
    }
    if (stateChanges) {
      this.stateChanges = stateChanges;
    }
    const m = this.info.match(/\schanged:\s*(\d+)/i);
    if (m !== null) {
      this.changedRows = parseInt(m[1], 10);
    } else {
      this.changedRows = 0;
    }
  }

  // TODO: should be consistent instance member, but it's just easier here to have just function
  static toPacket(fieldCount, insertId) {
    let length = 4 + Packet.lengthCodedNumberLength(fieldCount);
    if (typeof insertId !== 'undefined') {
      length += Packet.lengthCodedNumberLength(insertId);
    }
    const buffer = Buffer.allocUnsafe(length);
    const packet = new Packet(0, buffer, 0, length);
    packet.offset = 4;
    packet.writeLengthCodedNumber(fieldCount);
    if (typeof insertId !== 'undefined') {
      packet.writeLengthCodedNumber(insertId);
    }
    return packet;
  }
}

module.exports = ResultSetHeader;


/***/ }),

/***/ 26315:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


const ClientConstants = __nccwpck_require__(70060);
const Packet = __nccwpck_require__(43743);

class SSLRequest {
  constructor(flags, charset) {
    this.clientFlags = flags | ClientConstants.SSL;
    this.charset = charset;
  }

  toPacket() {
    const length = 36;
    const buffer = Buffer.allocUnsafe(length);
    const packet = new Packet(0, buffer, 0, length);
    buffer.fill(0);
    packet.offset = 4;
    packet.writeInt32(this.clientFlags);
    packet.writeInt32(0); // max packet size. todo: move to config
    packet.writeInt8(this.charset);
    return packet;
  }
}

module.exports = SSLRequest;


/***/ }),

/***/ 28107:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


const Packet = __nccwpck_require__(43743);

class TextRow {
  constructor(columns) {
    this.columns = columns || [];
  }

  static fromPacket(packet) {
    // packet.reset(); // set offset to starting point?
    const columns = [];
    while (packet.haveMoreData()) {
      columns.push(packet.readLengthCodedString());
    }
    return new TextRow(columns);
  }

  static toPacket(columns, encoding) {
    const sequenceId = 0; // TODO remove, this is calculated now in connecton
    let length = 0;
    columns.forEach((val) => {
      if (val === null || typeof val === 'undefined') {
        ++length;
        return;
      }
      length += Packet.lengthCodedStringLength(val.toString(10), encoding);
    });
    const buffer = Buffer.allocUnsafe(length + 4);
    const packet = new Packet(sequenceId, buffer, 0, length + 4);
    packet.offset = 4;
    columns.forEach((val) => {
      if (val === null) {
        packet.writeNull();
        return;
      }
      if (typeof val === 'undefined') {
        packet.writeInt8(0);
        return;
      }
      packet.writeLengthCodedString(val.toString(10), encoding);
    });
    return packet;
  }
}

module.exports = TextRow;


/***/ }),

/***/ 28835:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


const FieldFlags = __nccwpck_require__(34615);
const Charsets = __nccwpck_require__(33286);
const Types = __nccwpck_require__(95490);
const helpers = __nccwpck_require__(33024);
const genFunc = __nccwpck_require__(44498);
const parserCache = __nccwpck_require__(97962);
const typeNames = [];
for (const t in Types) {
  typeNames[Types[t]] = t;
}

function readCodeFor(field, config, options, fieldNum) {
  const supportBigNumbers = Boolean(
    options.supportBigNumbers || config.supportBigNumbers
  );
  const bigNumberStrings = Boolean(
    options.bigNumberStrings || config.bigNumberStrings
  );
  const timezone = options.timezone || config.timezone;
  const dateStrings = options.dateStrings || config.dateStrings;
  const unsigned = field.flags & FieldFlags.UNSIGNED;
  switch (field.columnType) {
    case Types.TINY:
      return unsigned ? 'packet.readInt8();' : 'packet.readSInt8();';
    case Types.SHORT:
      return unsigned ? 'packet.readInt16();' : 'packet.readSInt16();';
    case Types.LONG:
    case Types.INT24: // in binary protocol int24 is encoded in 4 bytes int32
      return unsigned ? 'packet.readInt32();' : 'packet.readSInt32();';
    case Types.YEAR:
      return 'packet.readInt16()';
    case Types.FLOAT:
      return 'packet.readFloat();';
    case Types.DOUBLE:
      return 'packet.readDouble();';
    case Types.NULL:
      return 'null;';
    case Types.DATE:
    case Types.DATETIME:
    case Types.TIMESTAMP:
    case Types.NEWDATE:
      if (helpers.typeMatch(field.columnType, dateStrings, Types)) {
        return `packet.readDateTimeString(${parseInt(field.decimals, 10)}, ${null}, ${field.columnType});`;
      }
      return `packet.readDateTime(${helpers.srcEscape(timezone)});`;
    case Types.TIME:
      return 'packet.readTimeString()';
    case Types.DECIMAL:
    case Types.NEWDECIMAL:
      if (config.decimalNumbers) {
        return 'packet.parseLengthCodedFloat();';
      }
      return 'packet.readLengthCodedString("ascii");';
    case Types.GEOMETRY:
      return 'packet.parseGeometryValue();';
    case Types.VECTOR:
      return 'packet.parseVector()';
    case Types.JSON:
      // Since for JSON columns mysql always returns charset 63 (BINARY),
      // we have to handle it according to JSON specs and use "utf8",
      // see https://github.com/sidorares/node-mysql2/issues/409
      return config.jsonStrings
        ? 'packet.readLengthCodedString("utf8")'
        : 'JSON.parse(packet.readLengthCodedString("utf8"));';
    case Types.LONGLONG:
      if (!supportBigNumbers) {
        return unsigned
          ? 'packet.readInt64JSNumber();'
          : 'packet.readSInt64JSNumber();';
      }
      if (bigNumberStrings) {
        return unsigned
          ? 'packet.readInt64String();'
          : 'packet.readSInt64String();';
      }
      return unsigned ? 'packet.readInt64();' : 'packet.readSInt64();';

    default:
      if (field.characterSet === Charsets.BINARY) {
        return 'packet.readLengthCodedBuffer();';
      }
      return `packet.readLengthCodedString(fields[${fieldNum}].encoding)`;
  }
}

function compile(fields, options, config) {
  const parserFn = genFunc();
  const nullBitmapLength = Math.floor((fields.length + 7 + 2) / 8);

  function wrap(field, packet) {
    return {
      type: typeNames[field.columnType],
      length: field.columnLength,
      db: field.schema,
      table: field.table,
      name: field.name,
      string: function (encoding = field.encoding) {
        if (field.columnType === Types.JSON && encoding === field.encoding) {
          // Since for JSON columns mysql always returns charset 63 (BINARY),
          // we have to handle it according to JSON specs and use "utf8",
          // see https://github.com/sidorares/node-mysql2/issues/1661
          console.warn(
            `typeCast: JSON column "${field.name}" is interpreted as BINARY by default, recommended to manually set utf8 encoding: \`field.string("utf8")\``
          );
        }

        if (
          [Types.DATETIME, Types.NEWDATE, Types.TIMESTAMP, Types.DATE].includes(
            field.columnType
          )
        ) {
          return packet.readDateTimeString(
            parseInt(field.decimals, 10),
            ' ',
            field.columnType
          );
        }

        if (field.columnType === Types.TINY) {
          const unsigned = field.flags & FieldFlags.UNSIGNED;

          return String(unsigned ? packet.readInt8() : packet.readSInt8());
        }

        if (field.columnType === Types.TIME) {
          return packet.readTimeString();
        }

        return packet.readLengthCodedString(encoding);
      },
      buffer: function () {
        return packet.readLengthCodedBuffer();
      },
      geometry: function () {
        return packet.parseGeometryValue();
      },
    };
  }

  parserFn('(function(){');
  parserFn('return class BinaryRow {');
  parserFn('constructor() {');
  parserFn('}');

  parserFn('next(packet, fields, options) {');
  if (options.rowsAsArray) {
    parserFn(`const result = new Array(${fields.length});`);
  } else {
    parserFn('const result = {};');
  }

  // Global typeCast
  if (
    typeof config.typeCast === 'function' &&
    typeof options.typeCast !== 'function'
  ) {
    options.typeCast = config.typeCast;
  }

  parserFn('packet.readInt8();'); // status byte
  for (let i = 0; i < nullBitmapLength; ++i) {
    parserFn(`const nullBitmaskByte${i} = packet.readInt8();`);
  }

  let lvalue = '';
  let currentFieldNullBit = 4;
  let nullByteIndex = 0;
  let fieldName = '';
  let tableName = '';

  for (let i = 0; i < fields.length; i++) {
    fieldName = helpers.fieldEscape(fields[i].name);
    // parserFn(`// ${fieldName}: ${typeNames[fields[i].columnType]}`);

    if (typeof options.nestTables === 'string') {
      lvalue = `result[${helpers.fieldEscape(fields[i].table + options.nestTables + fields[i].name)}]`;
    } else if (options.nestTables === true) {
      tableName = helpers.fieldEscape(fields[i].table);

      parserFn(`if (!result[${tableName}]) result[${tableName}] = {};`);
      lvalue = `result[${tableName}][${fieldName}]`;
    } else if (options.rowsAsArray) {
      lvalue = `result[${i.toString(10)}]`;
    } else {
      lvalue = `result[${fieldName}]`;
    }

    parserFn(`if (nullBitmaskByte${nullByteIndex} & ${currentFieldNullBit}) `);
    parserFn(`${lvalue} = null;`);
    parserFn('else {');

    if (options.typeCast === false) {
      parserFn(`${lvalue} = packet.readLengthCodedBuffer();`);
    } else {
      const fieldWrapperVar = `fieldWrapper${i}`;
      parserFn(`const ${fieldWrapperVar} = wrap(fields[${i}], packet);`);
      const readCode = readCodeFor(fields[i], config, options, i);

      if (typeof options.typeCast === 'function') {
        parserFn(
          `${lvalue} = options.typeCast(${fieldWrapperVar}, function() { return ${readCode} });`
        );
      } else {
        parserFn(`${lvalue} = ${readCode};`);
      }
    }
    parserFn('}');

    currentFieldNullBit *= 2;
    if (currentFieldNullBit === 0x100) {
      currentFieldNullBit = 1;
      nullByteIndex++;
    }
  }

  parserFn('return result;');
  parserFn('}');
  parserFn('};')('})()');

  if (config.debug) {
    helpers.printDebugWithCode(
      'Compiled binary protocol row parser',
      parserFn.toString()
    );
  }
  return parserFn.toFunction({ wrap });
}

function getBinaryParser(fields, options, config) {
  return parserCache.getParser('binary', fields, options, config, compile);
}

module.exports = getBinaryParser;


/***/ }),

/***/ 97962:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


const { createLRU } = __nccwpck_require__(46963);

const parserCache = createLRU({
  max: 15000,
});

function keyFromFields(type, fields, options, config) {
  const res = [
    type,
    typeof options.nestTables,
    options.nestTables,
    Boolean(options.rowsAsArray),
    Boolean(options.supportBigNumbers || config.supportBigNumbers),
    Boolean(options.bigNumberStrings || config.bigNumberStrings),
    typeof options.typeCast === 'boolean'
      ? options.typeCast
      : typeof options.typeCast,
    options.timezone || config.timezone,
    Boolean(options.decimalNumbers),
    options.dateStrings,
  ];

  for (let i = 0; i < fields.length; ++i) {
    const field = fields[i];

    res.push([
      field.name,
      field.columnType,
      field.length,
      field.schema,
      field.table,
      field.flags,
      field.characterSet,
    ]);
  }

  return JSON.stringify(res, null, 0);
}

function getParser(type, fields, options, config, compiler) {
  const key = keyFromFields(type, fields, options, config);
  let parser = parserCache.get(key);

  if (parser) {
    return parser;
  }

  parser = compiler(fields, options, config);
  parserCache.set(key, parser);
  return parser;
}

function setMaxCache(max) {
  parserCache.resize(max);
}

function clearCache() {
  parserCache.clear();
}

module.exports = {
  getParser: getParser,
  setMaxCache: setMaxCache,
  clearCache: clearCache,
  _keyFromFields: keyFromFields,
};


/***/ }),

/***/ 67640:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


const FieldFlags = __nccwpck_require__(34615);
const Charsets = __nccwpck_require__(33286);
const Types = __nccwpck_require__(95490);
const helpers = __nccwpck_require__(33024);

const typeNames = [];
for (const t in Types) {
  typeNames[Types[t]] = t;
}

function getBinaryParser(fields, _options, config) {
  function readCode(field, config, options, fieldNum, packet) {
    const supportBigNumbers = Boolean(
      options.supportBigNumbers || config.supportBigNumbers
    );
    const bigNumberStrings = Boolean(
      options.bigNumberStrings || config.bigNumberStrings
    );
    const timezone = options.timezone || config.timezone;
    const dateStrings = options.dateStrings || config.dateStrings;
    const unsigned = field.flags & FieldFlags.UNSIGNED;

    switch (field.columnType) {
      case Types.TINY:
        return unsigned ? packet.readInt8() : packet.readSInt8();
      case Types.SHORT:
        return unsigned ? packet.readInt16() : packet.readSInt16();
      case Types.LONG:
      case Types.INT24: // in binary protocol int24 is encoded in 4 bytes int32
        return unsigned ? packet.readInt32() : packet.readSInt32();
      case Types.YEAR:
        return packet.readInt16();
      case Types.FLOAT:
        return packet.readFloat();
      case Types.DOUBLE:
        return packet.readDouble();
      case Types.NULL:
        return null;
      case Types.DATE:
      case Types.DATETIME:
      case Types.TIMESTAMP:
      case Types.NEWDATE:
        return helpers.typeMatch(field.columnType, dateStrings, Types)
          ? packet.readDateTimeString(
              parseInt(field.decimals, 10),
              null,
              field.columnType
            )
          : packet.readDateTime(timezone);
      case Types.TIME:
        return packet.readTimeString();
      case Types.DECIMAL:
      case Types.NEWDECIMAL:
        return config.decimalNumbers
          ? packet.parseLengthCodedFloat()
          : packet.readLengthCodedString('ascii');
      case Types.GEOMETRY:
        return packet.parseGeometryValue();
      case Types.VECTOR:
        return packet.parseVector();
      case Types.JSON:
        // Since for JSON columns mysql always returns charset 63 (BINARY),
        // we have to handle it according to JSON specs and use "utf8",
        // see https://github.com/sidorares/node-mysql2/issues/409
        return config.jsonStrings
          ? packet.readLengthCodedString('utf8')
          : JSON.parse(packet.readLengthCodedString('utf8'));
      case Types.LONGLONG:
        if (!supportBigNumbers)
          return unsigned
            ? packet.readInt64JSNumber()
            : packet.readSInt64JSNumber();
        return bigNumberStrings
          ? unsigned
            ? packet.readInt64String()
            : packet.readSInt64String()
          : unsigned
            ? packet.readInt64()
            : packet.readSInt64();
      default:
        return field.characterSet === Charsets.BINARY
          ? packet.readLengthCodedBuffer()
          : packet.readLengthCodedString(fields[fieldNum].encoding);
    }
  }

  return class BinaryRow {
    constructor() {}

    next(packet, fields, options) {
      packet.readInt8(); // status byte

      const nullBitmapLength = Math.floor((fields.length + 7 + 2) / 8);
      const nullBitmaskBytes = new Array(nullBitmapLength);

      for (let i = 0; i < nullBitmapLength; i++) {
        nullBitmaskBytes[i] = packet.readInt8();
      }

      const result = options.rowsAsArray ? new Array(fields.length) : {};
      let currentFieldNullBit = 4;
      let nullByteIndex = 0;

      for (let i = 0; i < fields.length; i++) {
        const field = fields[i];
        const typeCast =
          options.typeCast !== undefined ? options.typeCast : config.typeCast;

        let value;
        if (nullBitmaskBytes[nullByteIndex] & currentFieldNullBit) {
          value = null;
        } else if (options.typeCast === false) {
          value = packet.readLengthCodedBuffer();
        } else {
          const next = () => readCode(field, config, options, i, packet);
          value =
            typeof typeCast === 'function'
              ? typeCast(
                  {
                    type: typeNames[field.columnType],
                    length: field.columnLength,
                    db: field.schema,
                    table: field.table,
                    name: field.name,
                    string: function (encoding = field.encoding) {
                      if (
                        field.columnType === Types.JSON &&
                        encoding === field.encoding
                      ) {
                        // Since for JSON columns mysql always returns charset 63 (BINARY),
                        // we have to handle it according to JSON specs and use "utf8",
                        // see https://github.com/sidorares/node-mysql2/issues/1661
                        console.warn(
                          `typeCast: JSON column "${field.name}" is interpreted as BINARY by default, recommended to manually set utf8 encoding: \`field.string("utf8")\``
                        );
                      }

                      if (
                        [
                          Types.DATETIME,
                          Types.NEWDATE,
                          Types.TIMESTAMP,
                          Types.DATE,
                        ].includes(field.columnType)
                      ) {
                        return packet.readDateTimeString(
                          parseInt(field.decimals, 10),
                          ' ',
                          field.columnType
                        );
                      }

                      if (field.columnType === Types.TINY) {
                        const unsigned = field.flags & FieldFlags.UNSIGNED;

                        return String(
                          unsigned ? packet.readInt8() : packet.readSInt8()
                        );
                      }

                      if (field.columnType === Types.TIME) {
                        return packet.readTimeString();
                      }

                      return packet.readLengthCodedString(encoding);
                    },
                    buffer: function () {
                      return packet.readLengthCodedBuffer();
                    },
                    geometry: function () {
                      return packet.parseGeometryValue();
                    },
                  },
                  next
                )
              : next();
        }

        if (options.rowsAsArray) {
          result[i] = value;
        } else if (typeof options.nestTables === 'string') {
          const key = helpers.fieldEscape(
            field.table + options.nestTables + field.name,
            false
          );
          result[key] = value;
        } else if (options.nestTables === true) {
          const tableName = helpers.fieldEscape(field.table, false);
          if (!result[tableName]) {
            result[tableName] = {};
          }
          const fieldName = helpers.fieldEscape(field.name, false);
          result[tableName][fieldName] = value;
        } else {
          const key = helpers.fieldEscape(field.name, false);
          result[key] = value;
        }

        currentFieldNullBit *= 2;
        if (currentFieldNullBit === 0x100) {
          currentFieldNullBit = 1;
          nullByteIndex++;
        }
      }

      return result;
    }
  };
}

module.exports = getBinaryParser;


/***/ }),

/***/ 70454:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


const Types = __nccwpck_require__(95490);
const Charsets = __nccwpck_require__(33286);
const helpers = __nccwpck_require__(33024);

const typeNames = [];
for (const t in Types) {
  typeNames[Types[t]] = t;
}

function readField({ packet, type, charset, encoding, config, options }) {
  const supportBigNumbers = Boolean(
    options.supportBigNumbers || config.supportBigNumbers
  );
  const bigNumberStrings = Boolean(
    options.bigNumberStrings || config.bigNumberStrings
  );
  const timezone = options.timezone || config.timezone;
  const dateStrings = options.dateStrings || config.dateStrings;

  switch (type) {
    case Types.TINY:
    case Types.SHORT:
    case Types.LONG:
    case Types.INT24:
    case Types.YEAR:
      return packet.parseLengthCodedIntNoBigCheck();
    case Types.LONGLONG:
      if (supportBigNumbers && bigNumberStrings) {
        return packet.parseLengthCodedIntString();
      }
      return packet.parseLengthCodedInt(supportBigNumbers);
    case Types.FLOAT:
    case Types.DOUBLE:
      return packet.parseLengthCodedFloat();
    case Types.NULL:
    case Types.DECIMAL:
    case Types.NEWDECIMAL:
      if (config.decimalNumbers) {
        return packet.parseLengthCodedFloat();
      }
      return packet.readLengthCodedString('ascii');
    case Types.DATE:
      if (helpers.typeMatch(type, dateStrings, Types)) {
        return packet.readLengthCodedString('ascii');
      }
      return packet.parseDate(timezone);
    case Types.DATETIME:
    case Types.TIMESTAMP:
      if (helpers.typeMatch(type, dateStrings, Types)) {
        return packet.readLengthCodedString('ascii');
      }
      return packet.parseDateTime(timezone);
    case Types.TIME:
      return packet.readLengthCodedString('ascii');
    case Types.GEOMETRY:
      return packet.parseGeometryValue();
    case Types.VECTOR:
      return packet.parseVector();
    case Types.JSON:
      // Since for JSON columns mysql always returns charset 63 (BINARY),
      // we have to handle it according to JSON specs and use "utf8",
      // see https://github.com/sidorares/node-mysql2/issues/409
      return config.jsonStrings
        ? packet.readLengthCodedString('utf8')
        : JSON.parse(packet.readLengthCodedString('utf8'));
    default:
      if (charset === Charsets.BINARY) {
        return packet.readLengthCodedBuffer();
      }
      return packet.readLengthCodedString(encoding);
  }
}

function createTypecastField(field, packet) {
  return {
    type: typeNames[field.columnType],
    length: field.columnLength,
    db: field.schema,
    table: field.table,
    name: field.name,
    string: function (encoding = field.encoding) {
      if (field.columnType === Types.JSON && encoding === field.encoding) {
        // Since for JSON columns mysql always returns charset 63 (BINARY),
        // we have to handle it according to JSON specs and use "utf8",
        // see https://github.com/sidorares/node-mysql2/issues/1661
        console.warn(
          `typeCast: JSON column "${field.name}" is interpreted as BINARY by default, recommended to manually set utf8 encoding: \`field.string("utf8")\``
        );
      }
      return packet.readLengthCodedString(encoding);
    },
    buffer: function () {
      return packet.readLengthCodedBuffer();
    },
    geometry: function () {
      return packet.parseGeometryValue();
    },
  };
}

function getTextParser(_fields, _options, config) {
  return {
    next(packet, fields, options) {
      const result = options.rowsAsArray ? [] : {};
      for (let i = 0; i < fields.length; i++) {
        const field = fields[i];
        const typeCast = options.typeCast ? options.typeCast : config.typeCast;
        const next = () =>
          readField({
            packet,
            type: field.columnType,
            encoding: field.encoding,
            charset: field.characterSet,
            config,
            options,
          });

        let value;

        if (options.typeCast === false) {
          value = packet.readLengthCodedBuffer();
        } else if (typeof typeCast === 'function') {
          value = typeCast(createTypecastField(field, packet), next);
        } else {
          value = next();
        }

        if (options.rowsAsArray) {
          result.push(value);
        } else if (typeof options.nestTables === 'string') {
          result[
            `${helpers.fieldEscape(field.table, false)}${options.nestTables}${helpers.fieldEscape(field.name, false)}`
          ] = value;
        } else if (options.nestTables) {
          const tableName = helpers.fieldEscape(field.table, false);
          if (!result[tableName]) {
            result[tableName] = {};
          }
          result[tableName][helpers.fieldEscape(field.name, false)] = value;
        } else {
          result[helpers.fieldEscape(field.name, false)] = value;
        }
      }

      return result;
    },
  };
}

module.exports = getTextParser;


/***/ }),

/***/ 86809:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


const Iconv = __nccwpck_require__(54820);
const { createLRU } = __nccwpck_require__(46963);

const decoderCache = createLRU({
  max: 500,
});

exports.decode = function (buffer, encoding, start, end, options) {
  if (Buffer.isEncoding(encoding)) {
    return buffer.toString(encoding, start, end);
  }

  // Optimize for common case: encoding="short_string", options=undefined.
  let decoder;
  if (!options) {
    decoder = decoderCache.get(encoding);
    if (!decoder) {
      decoder = Iconv.getDecoder(encoding);
      decoderCache.set(encoding, decoder);
    }
  } else {
    const decoderArgs = { encoding, options };
    const decoderKey = JSON.stringify(decoderArgs);
    decoder = decoderCache.get(decoderKey);
    if (!decoder) {
      decoder = Iconv.getDecoder(decoderArgs.encoding, decoderArgs.options);
      decoderCache.set(decoderKey, decoder);
    }
  }

  const res = decoder.write(buffer.slice(start, end));
  const trail = decoder.end();

  return trail ? res + trail : res;
};

exports.encode = function (string, encoding, options) {
  if (Buffer.isEncoding(encoding)) {
    return Buffer.from(string, encoding);
  }

  const encoder = Iconv.getEncoder(encoding, options || {});

  const res = encoder.write(string);
  const trail = encoder.end();

  return trail && trail.length > 0 ? Buffer.concat([res, trail]) : res;
};


/***/ }),

/***/ 50265:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


const Types = __nccwpck_require__(95490);
const Charsets = __nccwpck_require__(33286);
const helpers = __nccwpck_require__(33024);
const genFunc = __nccwpck_require__(44498);
const parserCache = __nccwpck_require__(97962);

const typeNames = [];
for (const t in Types) {
  typeNames[Types[t]] = t;
}

function readCodeFor(type, charset, encodingExpr, config, options) {
  const supportBigNumbers = Boolean(
    options.supportBigNumbers || config.supportBigNumbers
  );
  const bigNumberStrings = Boolean(
    options.bigNumberStrings || config.bigNumberStrings
  );
  const timezone = options.timezone || config.timezone;
  const dateStrings = options.dateStrings || config.dateStrings;

  switch (type) {
    case Types.TINY:
    case Types.SHORT:
    case Types.LONG:
    case Types.INT24:
    case Types.YEAR:
      return 'packet.parseLengthCodedIntNoBigCheck()';
    case Types.LONGLONG:
      if (supportBigNumbers && bigNumberStrings) {
        return 'packet.parseLengthCodedIntString()';
      }
      return `packet.parseLengthCodedInt(${supportBigNumbers})`;
    case Types.FLOAT:
    case Types.DOUBLE:
      return 'packet.parseLengthCodedFloat()';
    case Types.NULL:
      return 'packet.readLengthCodedNumber()';
    case Types.DECIMAL:
    case Types.NEWDECIMAL:
      if (config.decimalNumbers) {
        return 'packet.parseLengthCodedFloat()';
      }
      return 'packet.readLengthCodedString("ascii")';
    case Types.DATE:
      if (helpers.typeMatch(type, dateStrings, Types)) {
        return 'packet.readLengthCodedString("ascii")';
      }
      return `packet.parseDate(${helpers.srcEscape(timezone)})`;
    case Types.DATETIME:
    case Types.TIMESTAMP:
      if (helpers.typeMatch(type, dateStrings, Types)) {
        return 'packet.readLengthCodedString("ascii")';
      }
      return `packet.parseDateTime(${helpers.srcEscape(timezone)})`;
    case Types.TIME:
      return 'packet.readLengthCodedString("ascii")';
    case Types.GEOMETRY:
      return 'packet.parseGeometryValue()';
    case Types.VECTOR:
      return 'packet.parseVector()';
    case Types.JSON:
      // Since for JSON columns mysql always returns charset 63 (BINARY),
      // we have to handle it according to JSON specs and use "utf8",
      // see https://github.com/sidorares/node-mysql2/issues/409
      return config.jsonStrings
        ? 'packet.readLengthCodedString("utf8")'
        : 'JSON.parse(packet.readLengthCodedString("utf8"))';
    default:
      if (charset === Charsets.BINARY) {
        return 'packet.readLengthCodedBuffer()';
      }
      return `packet.readLengthCodedString(${encodingExpr})`;
  }
}

function compile(fields, options, config) {
  // use global typeCast if current query doesn't specify one
  if (
    typeof config.typeCast === 'function' &&
    typeof options.typeCast !== 'function'
  ) {
    options.typeCast = config.typeCast;
  }

  function wrap(field, _this) {
    return {
      type: typeNames[field.columnType],
      length: field.columnLength,
      db: field.schema,
      table: field.table,
      name: field.name,
      string: function (encoding = field.encoding) {
        if (field.columnType === Types.JSON && encoding === field.encoding) {
          // Since for JSON columns mysql always returns charset 63 (BINARY),
          // we have to handle it according to JSON specs and use "utf8",
          // see https://github.com/sidorares/node-mysql2/issues/1661
          console.warn(
            `typeCast: JSON column "${field.name}" is interpreted as BINARY by default, recommended to manually set utf8 encoding: \`field.string("utf8")\``
          );
        }

        return _this.packet.readLengthCodedString(encoding);
      },
      buffer: function () {
        return _this.packet.readLengthCodedBuffer();
      },
      geometry: function () {
        return _this.packet.parseGeometryValue();
      },
    };
  }

  const parserFn = genFunc();

  parserFn('(function () {')('return class TextRow {');

  // constructor method
  parserFn('constructor(fields) {');
  // node-mysql typeCast compatibility wrapper
  // see https://github.com/mysqljs/mysql/blob/96fdd0566b654436624e2375c7b6604b1f50f825/lib/protocol/packets/Field.js
  if (typeof options.typeCast === 'function') {
    parserFn('const _this = this;');
    parserFn('for(let i=0; i<fields.length; ++i) {');
    parserFn('this[`wrap${i}`] = wrap(fields[i], _this);');
    parserFn('}');
  }
  parserFn('}');

  // next method
  parserFn('next(packet, fields, options) {');
  parserFn('this.packet = packet;');
  if (options.rowsAsArray) {
    parserFn(`const result = new Array(${fields.length});`);
  } else {
    parserFn('const result = {};');
  }

  const resultTables = {};
  let resultTablesArray = [];

  if (options.nestTables === true) {
    for (let i = 0; i < fields.length; i++) {
      resultTables[fields[i].table] = 1;
    }
    resultTablesArray = Object.keys(resultTables);
    for (let i = 0; i < resultTablesArray.length; i++) {
      parserFn(`result[${helpers.fieldEscape(resultTablesArray[i])}] = {};`);
    }
  }

  let lvalue = '';
  let fieldName = '';
  let tableName = '';
  for (let i = 0; i < fields.length; i++) {
    fieldName = helpers.fieldEscape(fields[i].name);
    // parserFn(`// ${fieldName}: ${typeNames[fields[i].columnType]}`);

    if (typeof options.nestTables === 'string') {
      lvalue = `result[${helpers.fieldEscape(fields[i].table + options.nestTables + fields[i].name)}]`;
    } else if (options.nestTables === true) {
      tableName = helpers.fieldEscape(fields[i].table);

      parserFn(`if (!result[${tableName}]) result[${tableName}] = {};`);
      lvalue = `result[${tableName}][${fieldName}]`;
    } else if (options.rowsAsArray) {
      lvalue = `result[${i.toString(10)}]`;
    } else {
      lvalue = `result[${fieldName}]`;
    }
    if (options.typeCast === false) {
      parserFn(`${lvalue} = packet.readLengthCodedBuffer();`);
    } else {
      const encodingExpr = `fields[${i}].encoding`;
      const readCode = readCodeFor(
        fields[i].columnType,
        fields[i].characterSet,
        encodingExpr,
        config,
        options
      );
      if (typeof options.typeCast === 'function') {
        parserFn(
          `${lvalue} = options.typeCast(this.wrap${i}, function() { return ${readCode} });`
        );
      } else {
        parserFn(`${lvalue} = ${readCode};`);
      }
    }
  }

  parserFn('return result;');
  parserFn('}');
  parserFn('};')('})()');

  if (config.debug) {
    helpers.printDebugWithCode(
      'Compiled text protocol row parser',
      parserFn.toString()
    );
  }
  if (typeof options.typeCast === 'function') {
    return parserFn.toFunction({ wrap });
  }
  return parserFn.toFunction();
}

function getTextParser(fields, options, config) {
  return parserCache.getParser('text', fields, options, config, compile);
}

module.exports = getTextParser;


/***/ }),

/***/ 72515:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


const BasePool = __nccwpck_require__(80605);

class Pool extends BasePool {
  promise(promiseImpl) {
    const PromisePool = __nccwpck_require__(63393);
    return new PromisePool(this, promiseImpl);
  }
}

module.exports = Pool;


/***/ }),

/***/ 51498:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


const process = __nccwpck_require__(932);

const Pool = __nccwpck_require__(72515);
const PoolConfig = __nccwpck_require__(95648);
const Connection = __nccwpck_require__(58661);
const EventEmitter = (__nccwpck_require__(24434).EventEmitter);

/**
 * Selector
 */
const makeSelector = {
  RR() {
    let index = 0;
    return (clusterIds) => clusterIds[index++ % clusterIds.length];
  },
  RANDOM() {
    return (clusterIds) =>
      clusterIds[Math.floor(Math.random() * clusterIds.length)];
  },
  ORDER() {
    return (clusterIds) => clusterIds[0];
  },
};

const getMonotonicMilliseconds = function () {
  let ms;

  if (typeof process.hrtime === 'function') {
    ms = process.hrtime();
    ms = ms[0] * 1e3 + ms[1] * 1e-6;
  } else {
    ms = process.uptime() * 1000;
  }

  return Math.floor(ms);
};

const patternRegExp = function (pattern) {
  if (pattern instanceof RegExp) {
    return pattern;
  }

  const source = pattern
    .replace(/([.+?^=!:${}()|[\]/\\])/g, '\\$1')
    .replace(/\*/g, '.*');

  return new RegExp(`^${source}$`);
};

class PoolNamespace {
  constructor(cluster, pattern, selector) {
    this._cluster = cluster;
    this._pattern = pattern;
    this._selector = makeSelector[selector]();
  }

  getConnection(cb) {
    const clusterNode = this._getClusterNode();
    if (clusterNode === null) {
      let err = new Error('Pool does Not exist.');
      err.code = 'POOL_NOEXIST';

      if (this._cluster._findNodeIds(this._pattern, true).length !== 0) {
        err = new Error('Pool does Not have online node.');
        err.code = 'POOL_NONEONLINE';
      }

      return cb(err);
    }
    return this._cluster._getConnection(clusterNode, (err, connection) => {
      if (err) {
        if (
          this._cluster._canRetry &&
          this._cluster._findNodeIds(this._pattern).length !== 0
        ) {
          this._cluster.emit('warn', err);
          return this.getConnection(cb);
        }

        return cb(err);
      }
      return cb(null, connection);
    });
  }

  /**
   * pool cluster query
   * @param {*} sql
   * @param {*} values
   * @param {*} cb
   * @returns query
   */
  query(sql, values, cb) {
    const query = Connection.createQuery(sql, values, cb, {});
    this.getConnection((err, conn) => {
      if (err) {
        if (typeof query.onResult === 'function') {
          query.onResult(err);
        } else {
          query.emit('error', err);
        }
        return;
      }
      try {
        conn.query(query).once('end', () => {
          conn.release();
        });
      } catch (e) {
        conn.release();
        throw e;
      }
    });
    return query;
  }

  /**
   * pool cluster execute
   * @param {*} sql
   * @param {*} values
   * @param {*} cb
   */
  execute(sql, values, cb) {
    if (typeof values === 'function') {
      cb = values;
      values = [];
    }
    this.getConnection((err, conn) => {
      if (err) {
        return cb(err);
      }
      try {
        conn.execute(sql, values, cb).once('end', () => {
          conn.release();
        });
      } catch (e) {
        conn.release();
        throw e;
      }
    });
  }

  _getClusterNode() {
    const foundNodeIds = this._cluster._findNodeIds(this._pattern);
    if (foundNodeIds.length === 0) {
      return null;
    }
    const nodeId =
      foundNodeIds.length === 1
        ? foundNodeIds[0]
        : this._selector(foundNodeIds);
    return this._cluster._getNode(nodeId);
  }
}

class PoolCluster extends EventEmitter {
  constructor(config) {
    super();
    config = config || {};
    this._canRetry =
      typeof config.canRetry === 'undefined' ? true : config.canRetry;
    this._removeNodeErrorCount = config.removeNodeErrorCount || 5;
    this._restoreNodeTimeout = config.restoreNodeTimeout || 0;
    this._defaultSelector = config.defaultSelector || 'RR';
    this._closed = false;
    this._lastId = 0;
    this._nodes = {};
    this._serviceableNodeIds = [];
    this._namespaces = {};
    this._findCaches = {};
  }

  of(pattern, selector) {
    pattern = pattern || '*';
    selector = selector || this._defaultSelector;
    selector = selector.toUpperCase();
    if (!makeSelector[selector] === 'undefined') {
      selector = this._defaultSelector;
    }
    const key = pattern + selector;
    if (typeof this._namespaces[key] === 'undefined') {
      this._namespaces[key] = new PoolNamespace(this, pattern, selector);
    }
    return this._namespaces[key];
  }

  add(id, config) {
    if (typeof id === 'object') {
      config = id;
      id = `CLUSTER::${++this._lastId}`;
    }
    if (typeof this._nodes[id] === 'undefined') {
      this._nodes[id] = {
        id: id,
        errorCount: 0,
        pool: new Pool({ config: new PoolConfig(config) }),
        _offlineUntil: 0,
      };
      this._serviceableNodeIds.push(id);
      this._clearFindCaches();
    }
  }

  remove(pattern) {
    const foundNodeIds = this._findNodeIds(pattern, true);

    for (let i = 0; i < foundNodeIds.length; i++) {
      const node = this._getNode(foundNodeIds[i]);

      if (node) {
        this._removeNode(node);
      }
    }
  }

  getConnection(pattern, selector, cb) {
    let namespace;
    if (typeof pattern === 'function') {
      cb = pattern;
      namespace = this.of();
    } else {
      if (typeof selector === 'function') {
        cb = selector;
        selector = this._defaultSelector;
      }
      namespace = this.of(pattern, selector);
    }
    namespace.getConnection(cb);
  }

  end(callback) {
    const cb =
      callback !== undefined
        ? callback
        : (err) => {
            if (err) {
              throw err;
            }
          };
    if (this._closed) {
      process.nextTick(cb);
      return;
    }

    this._closed = true;

    let calledBack = false;
    let waitingClose = 0;
    const onEnd = (err) => {
      if (!calledBack && (err || --waitingClose <= 0)) {
        calledBack = true;
        return cb(err);
      }
    };

    for (const id in this._nodes) {
      waitingClose++;
      this._nodes[id].pool.end(onEnd);
    }

    if (waitingClose === 0) {
      process.nextTick(onEnd);
    }
  }

  _findNodeIds(pattern, includeOffline) {
    let currentTime = 0;
    let foundNodeIds = this._findCaches[pattern];

    if (foundNodeIds === undefined) {
      const expression = patternRegExp(pattern);

      foundNodeIds = this._serviceableNodeIds.filter((id) =>
        id.match(expression)
      );
    }

    this._findCaches[pattern] = foundNodeIds;

    if (includeOffline) {
      return foundNodeIds;
    }

    return foundNodeIds.filter((nodeId) => {
      const node = this._getNode(nodeId);

      if (!node._offlineUntil) {
        return true;
      }

      if (!currentTime) {
        currentTime = getMonotonicMilliseconds();
      }

      return node._offlineUntil <= currentTime;
    });
  }

  _getNode(id) {
    return this._nodes[id] || null;
  }

  _increaseErrorCount(node) {
    const errorCount = ++node.errorCount;

    if (this._removeNodeErrorCount > errorCount) {
      return;
    }

    if (this._restoreNodeTimeout > 0) {
      node._offlineUntil =
        getMonotonicMilliseconds() + this._restoreNodeTimeout;
      this.emit('offline', node.id);
      return;
    }

    this._removeNode(node);
    this.emit('remove', node.id);
  }

  _decreaseErrorCount(node) {
    let errorCount = node.errorCount;

    if (errorCount > this._removeNodeErrorCount) {
      errorCount = this._removeNodeErrorCount;
    }

    if (errorCount < 1) {
      errorCount = 1;
    }

    node.errorCount = errorCount - 1;

    if (node._offlineUntil) {
      node._offlineUntil = 0;
      this.emit('online', node.id);
    }
  }

  _getConnection(node, cb) {
    node.pool.getConnection((err, connection) => {
      if (err) {
        this._increaseErrorCount(node);
        return cb(err);
      }
      this._decreaseErrorCount(node);

      connection._clusterId = node.id;
      return cb(null, connection);
    });
  }

  _removeNode(node) {
    const index = this._serviceableNodeIds.indexOf(node.id);
    if (index !== -1) {
      this._serviceableNodeIds.splice(index, 1);
      delete this._nodes[node.id];
      this._clearFindCaches();
      node.pool.end();
    }
  }

  _clearFindCaches() {
    this._findCaches = {};
  }
}

module.exports = PoolCluster;


/***/ }),

/***/ 95648:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


const ConnectionConfig = __nccwpck_require__(6566);

class PoolConfig {
  constructor(options) {
    if (typeof options === 'string') {
      options = ConnectionConfig.parseUrl(options);
    }
    this.connectionConfig = new ConnectionConfig(options);
    this.waitForConnections =
      options.waitForConnections === undefined
        ? true
        : Boolean(options.waitForConnections);
    this.connectionLimit = isNaN(options.connectionLimit)
      ? 10
      : Number(options.connectionLimit);
    this.maxIdle = isNaN(options.maxIdle)
      ? this.connectionLimit
      : Number(options.maxIdle);
    this.idleTimeout = isNaN(options.idleTimeout)
      ? 60000
      : Number(options.idleTimeout);
    this.queueLimit = isNaN(options.queueLimit)
      ? 0
      : Number(options.queueLimit);
  }
}

module.exports = PoolConfig;


/***/ }),

/***/ 42062:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


const BasePoolConnection = __nccwpck_require__(49612);

class PoolConnection extends BasePoolConnection {
  promise(promiseImpl) {
    const PromisePoolConnection = __nccwpck_require__(81624);
    return new PromisePoolConnection(this, promiseImpl);
  }
}

module.exports = PoolConnection;


/***/ }),

/***/ 52079:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


const EventEmitter = (__nccwpck_require__(24434).EventEmitter);
const PromisePreparedStatementInfo = __nccwpck_require__(12075);
const makeDoneCb = __nccwpck_require__(76142);
const inheritEvents = __nccwpck_require__(42350);
const BaseConnection = __nccwpck_require__(15851);

class PromiseConnection extends EventEmitter {
  constructor(connection, promiseImpl) {
    super();
    this.connection = connection;
    this.Promise = promiseImpl || Promise;
    inheritEvents(connection, this, [
      'error',
      'drain',
      'connect',
      'end',
      'enqueue',
    ]);
  }

  release() {
    this.connection.release();
  }

  query(query, params) {
    const c = this.connection;
    const localErr = new Error();
    if (typeof params === 'function') {
      throw new Error(
        'Callback function is not available with promise clients.'
      );
    }
    return new this.Promise((resolve, reject) => {
      const done = makeDoneCb(resolve, reject, localErr);
      if (params !== undefined) {
        c.query(query, params, done);
      } else {
        c.query(query, done);
      }
    });
  }

  execute(query, params) {
    const c = this.connection;
    const localErr = new Error();
    if (typeof params === 'function') {
      throw new Error(
        'Callback function is not available with promise clients.'
      );
    }
    return new this.Promise((resolve, reject) => {
      const done = makeDoneCb(resolve, reject, localErr);
      if (params !== undefined) {
        c.execute(query, params, done);
      } else {
        c.execute(query, done);
      }
    });
  }

  end() {
    return new this.Promise((resolve) => {
      this.connection.end(resolve);
    });
  }

  beginTransaction() {
    const c = this.connection;
    const localErr = new Error();
    return new this.Promise((resolve, reject) => {
      const done = makeDoneCb(resolve, reject, localErr);
      c.beginTransaction(done);
    });
  }

  commit() {
    const c = this.connection;
    const localErr = new Error();
    return new this.Promise((resolve, reject) => {
      const done = makeDoneCb(resolve, reject, localErr);
      c.commit(done);
    });
  }

  rollback() {
    const c = this.connection;
    const localErr = new Error();
    return new this.Promise((resolve, reject) => {
      const done = makeDoneCb(resolve, reject, localErr);
      c.rollback(done);
    });
  }

  ping() {
    const c = this.connection;
    const localErr = new Error();
    return new this.Promise((resolve, reject) => {
      c.ping((err) => {
        if (err) {
          localErr.message = err.message;
          localErr.code = err.code;
          localErr.errno = err.errno;
          localErr.sqlState = err.sqlState;
          localErr.sqlMessage = err.sqlMessage;
          reject(localErr);
        } else {
          resolve(true);
        }
      });
    });
  }

  connect() {
    const c = this.connection;
    const localErr = new Error();
    return new this.Promise((resolve, reject) => {
      c.connect((err, param) => {
        if (err) {
          localErr.message = err.message;
          localErr.code = err.code;
          localErr.errno = err.errno;
          localErr.sqlState = err.sqlState;
          localErr.sqlMessage = err.sqlMessage;
          reject(localErr);
        } else {
          resolve(param);
        }
      });
    });
  }

  prepare(options) {
    const c = this.connection;
    const promiseImpl = this.Promise;
    const localErr = new Error();
    return new this.Promise((resolve, reject) => {
      c.prepare(options, (err, statement) => {
        if (err) {
          localErr.message = err.message;
          localErr.code = err.code;
          localErr.errno = err.errno;
          localErr.sqlState = err.sqlState;
          localErr.sqlMessage = err.sqlMessage;
          reject(localErr);
        } else {
          const wrappedStatement = new PromisePreparedStatementInfo(
            statement,
            promiseImpl
          );
          resolve(wrappedStatement);
        }
      });
    });
  }

  changeUser(options) {
    const c = this.connection;
    const localErr = new Error();
    return new this.Promise((resolve, reject) => {
      c.changeUser(options, (err) => {
        if (err) {
          localErr.message = err.message;
          localErr.code = err.code;
          localErr.errno = err.errno;
          localErr.sqlState = err.sqlState;
          localErr.sqlMessage = err.sqlMessage;
          reject(localErr);
        } else {
          resolve();
        }
      });
    });
  }

  get config() {
    return this.connection.config;
  }

  get threadId() {
    return this.connection.threadId;
  }
}
// patching PromiseConnection
// create facade functions for prototype functions on "Connection" that are not yet
// implemented with PromiseConnection

// proxy synchronous functions only
(function (functionsToWrap) {
  for (let i = 0; functionsToWrap && i < functionsToWrap.length; i++) {
    const func = functionsToWrap[i];

    if (
      typeof BaseConnection.prototype[func] === 'function' &&
      PromiseConnection.prototype[func] === undefined
    ) {
      PromiseConnection.prototype[func] = (function factory(funcName) {
        return function () {
          return BaseConnection.prototype[funcName].apply(
            this.connection,
            arguments
          );
        };
      })(func);
    }
  }
})([
  // synchronous functions
  'close',
  'createBinlogStream',
  'destroy',
  'escape',
  'escapeId',
  'format',
  'pause',
  'pipe',
  'resume',
  'unprepare',
]);

module.exports = PromiseConnection;


/***/ }),

/***/ 42350:
/***/ ((module) => {

"use strict";


function inheritEvents(source, target, events) {
  const listeners = {};
  target
    .on('newListener', (eventName) => {
      if (events.indexOf(eventName) >= 0 && !target.listenerCount(eventName)) {
        source.on(
          eventName,
          (listeners[eventName] = function () {
            const args = [].slice.call(arguments);
            args.unshift(eventName);

            target.emit.apply(target, args);
          })
        );
      }
    })
    .on('removeListener', (eventName) => {
      if (events.indexOf(eventName) >= 0 && !target.listenerCount(eventName)) {
        source.removeListener(eventName, listeners[eventName]);
        delete listeners[eventName];
      }
    });
}

module.exports = inheritEvents;


/***/ }),

/***/ 76142:
/***/ ((module) => {

"use strict";


function makeDoneCb(resolve, reject, localErr) {
  return function (err, rows, fields) {
    if (err) {
      localErr.message = err.message;
      localErr.code = err.code;
      localErr.errno = err.errno;
      localErr.sql = err.sql;
      localErr.sqlState = err.sqlState;
      localErr.sqlMessage = err.sqlMessage;
      reject(localErr);
    } else {
      resolve([rows, fields]);
    }
  };
}

module.exports = makeDoneCb;


/***/ }),

/***/ 63393:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


const EventEmitter = (__nccwpck_require__(24434).EventEmitter);
const makeDoneCb = __nccwpck_require__(76142);
const PromisePoolConnection = __nccwpck_require__(81624);
const inheritEvents = __nccwpck_require__(42350);
const BasePool = __nccwpck_require__(80605);

class PromisePool extends EventEmitter {
  constructor(pool, thePromise) {
    super();
    this.pool = pool;
    this.Promise = thePromise || Promise;
    inheritEvents(pool, this, ['acquire', 'connection', 'enqueue', 'release']);
  }

  getConnection() {
    const corePool = this.pool;
    return new this.Promise((resolve, reject) => {
      corePool.getConnection((err, coreConnection) => {
        if (err) {
          reject(err);
        } else {
          resolve(new PromisePoolConnection(coreConnection, this.Promise));
        }
      });
    });
  }

  releaseConnection(connection) {
    if (connection instanceof PromisePoolConnection) connection.release();
  }

  query(sql, args) {
    const corePool = this.pool;
    const localErr = new Error();
    if (typeof args === 'function') {
      throw new Error(
        'Callback function is not available with promise clients.'
      );
    }
    return new this.Promise((resolve, reject) => {
      const done = makeDoneCb(resolve, reject, localErr);
      if (args !== undefined) {
        corePool.query(sql, args, done);
      } else {
        corePool.query(sql, done);
      }
    });
  }

  execute(sql, args) {
    const corePool = this.pool;
    const localErr = new Error();
    if (typeof args === 'function') {
      throw new Error(
        'Callback function is not available with promise clients.'
      );
    }
    return new this.Promise((resolve, reject) => {
      const done = makeDoneCb(resolve, reject, localErr);
      if (args) {
        corePool.execute(sql, args, done);
      } else {
        corePool.execute(sql, done);
      }
    });
  }

  end() {
    const corePool = this.pool;
    const localErr = new Error();
    return new this.Promise((resolve, reject) => {
      corePool.end((err) => {
        if (err) {
          localErr.message = err.message;
          localErr.code = err.code;
          localErr.errno = err.errno;
          localErr.sqlState = err.sqlState;
          localErr.sqlMessage = err.sqlMessage;
          reject(localErr);
        } else {
          resolve();
        }
      });
    });
  }
}

(function (functionsToWrap) {
  for (let i = 0; functionsToWrap && i < functionsToWrap.length; i++) {
    const func = functionsToWrap[i];

    if (
      typeof BasePool.prototype[func] === 'function' &&
      PromisePool.prototype[func] === undefined
    ) {
      PromisePool.prototype[func] = (function factory(funcName) {
        return function () {
          return BasePool.prototype[funcName].apply(this.pool, arguments);
        };
      })(func);
    }
  }
})([
  // synchronous functions
  'escape',
  'escapeId',
  'format',
]);

module.exports = PromisePool;


/***/ }),

/***/ 46864:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


const PromisePoolConnection = __nccwpck_require__(81624);
const makeDoneCb = __nccwpck_require__(76142);

class PromisePoolNamespace {
  constructor(poolNamespace, thePromise) {
    this.poolNamespace = poolNamespace;
    this.Promise = thePromise || Promise;
  }

  getConnection() {
    const corePoolNamespace = this.poolNamespace;
    return new this.Promise((resolve, reject) => {
      corePoolNamespace.getConnection((err, coreConnection) => {
        if (err) {
          reject(err);
        } else {
          resolve(new PromisePoolConnection(coreConnection, this.Promise));
        }
      });
    });
  }

  query(sql, values) {
    const corePoolNamespace = this.poolNamespace;
    const localErr = new Error();
    if (typeof values === 'function') {
      throw new Error(
        'Callback function is not available with promise clients.'
      );
    }
    return new this.Promise((resolve, reject) => {
      const done = makeDoneCb(resolve, reject, localErr);
      corePoolNamespace.query(sql, values, done);
    });
  }

  execute(sql, values) {
    const corePoolNamespace = this.poolNamespace;
    const localErr = new Error();
    if (typeof values === 'function') {
      throw new Error(
        'Callback function is not available with promise clients.'
      );
    }
    return new this.Promise((resolve, reject) => {
      const done = makeDoneCb(resolve, reject, localErr);
      corePoolNamespace.execute(sql, values, done);
    });
  }
}

module.exports = PromisePoolNamespace;


/***/ }),

/***/ 81624:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


const PromiseConnection = __nccwpck_require__(52079);
const BasePoolConnection = __nccwpck_require__(49612);

class PromisePoolConnection extends PromiseConnection {
  constructor(connection, promiseImpl) {
    super(connection, promiseImpl);
  }

  destroy() {
    return BasePoolConnection.prototype.destroy.apply(
      this.connection,
      arguments
    );
  }
}

module.exports = PromisePoolConnection;


/***/ }),

/***/ 12075:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


const makeDoneCb = __nccwpck_require__(76142);

class PromisePreparedStatementInfo {
  constructor(statement, promiseImpl) {
    this.statement = statement;
    this.Promise = promiseImpl;
  }

  execute(parameters) {
    const s = this.statement;
    const localErr = new Error();
    return new this.Promise((resolve, reject) => {
      const done = makeDoneCb(resolve, reject, localErr);
      if (parameters) {
        s.execute(parameters, done);
      } else {
        s.execute(done);
      }
    });
  }

  close() {
    return new this.Promise((resolve) => {
      this.statement.close();
      resolve();
    });
  }
}

module.exports = PromisePreparedStatementInfo;


/***/ }),

/***/ 27588:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


const SqlString = __nccwpck_require__(16921);
const EventEmitter = (__nccwpck_require__(24434).EventEmitter);
const parserCache = __nccwpck_require__(97962);
const PoolCluster = __nccwpck_require__(51498);
const createConnection = __nccwpck_require__(31076);
const createPool = __nccwpck_require__(37670);
const createPoolCluster = __nccwpck_require__(33871);
const PromiseConnection = __nccwpck_require__(52079);
const PromisePool = __nccwpck_require__(63393);
const makeDoneCb = __nccwpck_require__(76142);
const PromisePoolConnection = __nccwpck_require__(81624);
const inheritEvents = __nccwpck_require__(42350);
const PromisePoolNamespace = __nccwpck_require__(46864);

function createConnectionPromise(opts) {
  const coreConnection = createConnection(opts);
  const createConnectionErr = new Error();
  const thePromise = opts.Promise || Promise;
  if (!thePromise) {
    throw new Error(
      'no Promise implementation available.' +
        'Use promise-enabled node version or pass userland Promise' +
        " implementation as parameter, for example: { Promise: require('bluebird') }"
    );
  }
  return new thePromise((resolve, reject) => {
    coreConnection.once('connect', () => {
      resolve(new PromiseConnection(coreConnection, thePromise));
    });
    coreConnection.once('error', (err) => {
      createConnectionErr.message = err.message;
      createConnectionErr.code = err.code;
      createConnectionErr.errno = err.errno;
      createConnectionErr.sqlState = err.sqlState;
      reject(createConnectionErr);
    });
  });
}

// note: the callback of "changeUser" is not called on success
// hence there is no possibility to call "resolve"

function createPromisePool(opts) {
  const corePool = createPool(opts);
  const thePromise = opts.Promise || Promise;
  if (!thePromise) {
    throw new Error(
      'no Promise implementation available.' +
        'Use promise-enabled node version or pass userland Promise' +
        " implementation as parameter, for example: { Promise: require('bluebird') }"
    );
  }

  return new PromisePool(corePool, thePromise);
}

class PromisePoolCluster extends EventEmitter {
  constructor(poolCluster, thePromise) {
    super();
    this.poolCluster = poolCluster;
    this.Promise = thePromise || Promise;
    inheritEvents(poolCluster, this, ['warn', 'remove', 'online', 'offline']);
  }

  getConnection(pattern, selector) {
    const corePoolCluster = this.poolCluster;
    return new this.Promise((resolve, reject) => {
      corePoolCluster.getConnection(
        pattern,
        selector,
        (err, coreConnection) => {
          if (err) {
            reject(err);
          } else {
            resolve(new PromisePoolConnection(coreConnection, this.Promise));
          }
        }
      );
    });
  }

  query(sql, args) {
    const corePoolCluster = this.poolCluster;
    const localErr = new Error();
    if (typeof args === 'function') {
      throw new Error(
        'Callback function is not available with promise clients.'
      );
    }
    return new this.Promise((resolve, reject) => {
      const done = makeDoneCb(resolve, reject, localErr);
      corePoolCluster.query(sql, args, done);
    });
  }

  execute(sql, args) {
    const corePoolCluster = this.poolCluster;
    const localErr = new Error();
    if (typeof args === 'function') {
      throw new Error(
        'Callback function is not available with promise clients.'
      );
    }
    return new this.Promise((resolve, reject) => {
      const done = makeDoneCb(resolve, reject, localErr);
      corePoolCluster.execute(sql, args, done);
    });
  }

  of(pattern, selector) {
    return new PromisePoolNamespace(
      this.poolCluster.of(pattern, selector),
      this.Promise
    );
  }

  end() {
    const corePoolCluster = this.poolCluster;
    const localErr = new Error();
    return new this.Promise((resolve, reject) => {
      corePoolCluster.end((err) => {
        if (err) {
          localErr.message = err.message;
          localErr.code = err.code;
          localErr.errno = err.errno;
          localErr.sqlState = err.sqlState;
          localErr.sqlMessage = err.sqlMessage;
          reject(localErr);
        } else {
          resolve();
        }
      });
    });
  }
}

/**
 * proxy poolCluster synchronous functions
 */
(function (functionsToWrap) {
  for (let i = 0; functionsToWrap && i < functionsToWrap.length; i++) {
    const func = functionsToWrap[i];

    if (
      typeof PoolCluster.prototype[func] === 'function' &&
      PromisePoolCluster.prototype[func] === undefined
    ) {
      PromisePoolCluster.prototype[func] = (function factory(funcName) {
        return function () {
          return PoolCluster.prototype[funcName].apply(
            this.poolCluster,
            arguments
          );
        };
      })(func);
    }
  }
})(['add', 'remove']);

function createPromisePoolCluster(opts) {
  const corePoolCluster = createPoolCluster(opts);
  const thePromise = (opts && opts.Promise) || Promise;
  if (!thePromise) {
    throw new Error(
      'no Promise implementation available.' +
        'Use promise-enabled node version or pass userland Promise' +
        " implementation as parameter, for example: { Promise: require('bluebird') }"
    );
  }
  return new PromisePoolCluster(corePoolCluster, thePromise);
}

exports.createConnection = createConnectionPromise;
exports.createPool = createPromisePool;
exports.createPoolCluster = createPromisePoolCluster;
exports.escape = SqlString.escape;
exports.escapeId = SqlString.escapeId;
exports.format = SqlString.format;
exports.raw = SqlString.raw;
exports.PromisePool = PromisePool;
exports.PromiseConnection = PromiseConnection;
exports.PromisePoolConnection = PromisePoolConnection;

exports.__defineGetter__('Types', () => __nccwpck_require__(95490));

exports.__defineGetter__('Charsets', () =>
  __nccwpck_require__(33286)
);

exports.__defineGetter__('CharsetToEncoding', () =>
  __nccwpck_require__(89998)
);

exports.setMaxParserCache = function (max) {
  parserCache.setMaxCache(max);
};

exports.clearParserCache = function () {
  parserCache.clearCache();
};


/***/ }),

/***/ 99239:
/***/ ((module) => {

const perf =
  typeof performance === 'object' &&
  performance &&
  typeof performance.now === 'function'
    ? performance
    : Date

const hasAbortController = typeof AbortController === 'function'

// minimal backwards-compatibility polyfill
// this doesn't have nearly all the checks and whatnot that
// actual AbortController/Signal has, but it's enough for
// our purposes, and if used properly, behaves the same.
const AC = hasAbortController
  ? AbortController
  : class AbortController {
      constructor() {
        this.signal = new AS()
      }
      abort(reason = new Error('This operation was aborted')) {
        this.signal.reason = this.signal.reason || reason
        this.signal.aborted = true
        this.signal.dispatchEvent({
          type: 'abort',
          target: this.signal,
        })
      }
    }

const hasAbortSignal = typeof AbortSignal === 'function'
// Some polyfills put this on the AC class, not global
const hasACAbortSignal = typeof AC.AbortSignal === 'function'
const AS = hasAbortSignal
  ? AbortSignal
  : hasACAbortSignal
  ? AC.AbortController
  : class AbortSignal {
      constructor() {
        this.reason = undefined
        this.aborted = false
        this._listeners = []
      }
      dispatchEvent(e) {
        if (e.type === 'abort') {
          this.aborted = true
          this.onabort(e)
          this._listeners.forEach(f => f(e), this)
        }
      }
      onabort() {}
      addEventListener(ev, fn) {
        if (ev === 'abort') {
          this._listeners.push(fn)
        }
      }
      removeEventListener(ev, fn) {
        if (ev === 'abort') {
          this._listeners = this._listeners.filter(f => f !== fn)
        }
      }
    }

const warned = new Set()
const deprecatedOption = (opt, instead) => {
  const code = `LRU_CACHE_OPTION_${opt}`
  if (shouldWarn(code)) {
    warn(code, `${opt} option`, `options.${instead}`, LRUCache)
  }
}
const deprecatedMethod = (method, instead) => {
  const code = `LRU_CACHE_METHOD_${method}`
  if (shouldWarn(code)) {
    const { prototype } = LRUCache
    const { get } = Object.getOwnPropertyDescriptor(prototype, method)
    warn(code, `${method} method`, `cache.${instead}()`, get)
  }
}
const deprecatedProperty = (field, instead) => {
  const code = `LRU_CACHE_PROPERTY_${field}`
  if (shouldWarn(code)) {
    const { prototype } = LRUCache
    const { get } = Object.getOwnPropertyDescriptor(prototype, field)
    warn(code, `${field} property`, `cache.${instead}`, get)
  }
}

const emitWarning = (...a) => {
  typeof process === 'object' &&
  process &&
  typeof process.emitWarning === 'function'
    ? process.emitWarning(...a)
    : console.error(...a)
}

const shouldWarn = code => !warned.has(code)

const warn = (code, what, instead, fn) => {
  warned.add(code)
  const msg = `The ${what} is deprecated. Please use ${instead} instead.`
  emitWarning(msg, 'DeprecationWarning', code, fn)
}

const isPosInt = n => n && n === Math.floor(n) && n > 0 && isFinite(n)

/* istanbul ignore next - This is a little bit ridiculous, tbh.
 * The maximum array length is 2^32-1 or thereabouts on most JS impls.
 * And well before that point, you're caching the entire world, I mean,
 * that's ~32GB of just integers for the next/prev links, plus whatever
 * else to hold that many keys and values.  Just filling the memory with
 * zeroes at init time is brutal when you get that big.
 * But why not be complete?
 * Maybe in the future, these limits will have expanded. */
const getUintArray = max =>
  !isPosInt(max)
    ? null
    : max <= Math.pow(2, 8)
    ? Uint8Array
    : max <= Math.pow(2, 16)
    ? Uint16Array
    : max <= Math.pow(2, 32)
    ? Uint32Array
    : max <= Number.MAX_SAFE_INTEGER
    ? ZeroArray
    : null

class ZeroArray extends Array {
  constructor(size) {
    super(size)
    this.fill(0)
  }
}

class Stack {
  constructor(max) {
    if (max === 0) {
      return []
    }
    const UintArray = getUintArray(max)
    this.heap = new UintArray(max)
    this.length = 0
  }
  push(n) {
    this.heap[this.length++] = n
  }
  pop() {
    return this.heap[--this.length]
  }
}

class LRUCache {
  constructor(options = {}) {
    const {
      max = 0,
      ttl,
      ttlResolution = 1,
      ttlAutopurge,
      updateAgeOnGet,
      updateAgeOnHas,
      allowStale,
      dispose,
      disposeAfter,
      noDisposeOnSet,
      noUpdateTTL,
      maxSize = 0,
      maxEntrySize = 0,
      sizeCalculation,
      fetchMethod,
      fetchContext,
      noDeleteOnFetchRejection,
      noDeleteOnStaleGet,
      allowStaleOnFetchRejection,
      allowStaleOnFetchAbort,
      ignoreFetchAbort,
    } = options

    // deprecated options, don't trigger a warning for getting them if
    // the thing being passed in is another LRUCache we're copying.
    const { length, maxAge, stale } =
      options instanceof LRUCache ? {} : options

    if (max !== 0 && !isPosInt(max)) {
      throw new TypeError('max option must be a nonnegative integer')
    }

    const UintArray = max ? getUintArray(max) : Array
    if (!UintArray) {
      throw new Error('invalid max value: ' + max)
    }

    this.max = max
    this.maxSize = maxSize
    this.maxEntrySize = maxEntrySize || this.maxSize
    this.sizeCalculation = sizeCalculation || length
    if (this.sizeCalculation) {
      if (!this.maxSize && !this.maxEntrySize) {
        throw new TypeError(
          'cannot set sizeCalculation without setting maxSize or maxEntrySize'
        )
      }
      if (typeof this.sizeCalculation !== 'function') {
        throw new TypeError('sizeCalculation set to non-function')
      }
    }

    this.fetchMethod = fetchMethod || null
    if (this.fetchMethod && typeof this.fetchMethod !== 'function') {
      throw new TypeError(
        'fetchMethod must be a function if specified'
      )
    }

    this.fetchContext = fetchContext
    if (!this.fetchMethod && fetchContext !== undefined) {
      throw new TypeError(
        'cannot set fetchContext without fetchMethod'
      )
    }

    this.keyMap = new Map()
    this.keyList = new Array(max).fill(null)
    this.valList = new Array(max).fill(null)
    this.next = new UintArray(max)
    this.prev = new UintArray(max)
    this.head = 0
    this.tail = 0
    this.free = new Stack(max)
    this.initialFill = 1
    this.size = 0

    if (typeof dispose === 'function') {
      this.dispose = dispose
    }
    if (typeof disposeAfter === 'function') {
      this.disposeAfter = disposeAfter
      this.disposed = []
    } else {
      this.disposeAfter = null
      this.disposed = null
    }
    this.noDisposeOnSet = !!noDisposeOnSet
    this.noUpdateTTL = !!noUpdateTTL
    this.noDeleteOnFetchRejection = !!noDeleteOnFetchRejection
    this.allowStaleOnFetchRejection = !!allowStaleOnFetchRejection
    this.allowStaleOnFetchAbort = !!allowStaleOnFetchAbort
    this.ignoreFetchAbort = !!ignoreFetchAbort

    // NB: maxEntrySize is set to maxSize if it's set
    if (this.maxEntrySize !== 0) {
      if (this.maxSize !== 0) {
        if (!isPosInt(this.maxSize)) {
          throw new TypeError(
            'maxSize must be a positive integer if specified'
          )
        }
      }
      if (!isPosInt(this.maxEntrySize)) {
        throw new TypeError(
          'maxEntrySize must be a positive integer if specified'
        )
      }
      this.initializeSizeTracking()
    }

    this.allowStale = !!allowStale || !!stale
    this.noDeleteOnStaleGet = !!noDeleteOnStaleGet
    this.updateAgeOnGet = !!updateAgeOnGet
    this.updateAgeOnHas = !!updateAgeOnHas
    this.ttlResolution =
      isPosInt(ttlResolution) || ttlResolution === 0
        ? ttlResolution
        : 1
    this.ttlAutopurge = !!ttlAutopurge
    this.ttl = ttl || maxAge || 0
    if (this.ttl) {
      if (!isPosInt(this.ttl)) {
        throw new TypeError(
          'ttl must be a positive integer if specified'
        )
      }
      this.initializeTTLTracking()
    }

    // do not allow completely unbounded caches
    if (this.max === 0 && this.ttl === 0 && this.maxSize === 0) {
      throw new TypeError(
        'At least one of max, maxSize, or ttl is required'
      )
    }
    if (!this.ttlAutopurge && !this.max && !this.maxSize) {
      const code = 'LRU_CACHE_UNBOUNDED'
      if (shouldWarn(code)) {
        warned.add(code)
        const msg =
          'TTL caching without ttlAutopurge, max, or maxSize can ' +
          'result in unbounded memory consumption.'
        emitWarning(msg, 'UnboundedCacheWarning', code, LRUCache)
      }
    }

    if (stale) {
      deprecatedOption('stale', 'allowStale')
    }
    if (maxAge) {
      deprecatedOption('maxAge', 'ttl')
    }
    if (length) {
      deprecatedOption('length', 'sizeCalculation')
    }
  }

  getRemainingTTL(key) {
    return this.has(key, { updateAgeOnHas: false }) ? Infinity : 0
  }

  initializeTTLTracking() {
    this.ttls = new ZeroArray(this.max)
    this.starts = new ZeroArray(this.max)

    this.setItemTTL = (index, ttl, start = perf.now()) => {
      this.starts[index] = ttl !== 0 ? start : 0
      this.ttls[index] = ttl
      if (ttl !== 0 && this.ttlAutopurge) {
        const t = setTimeout(() => {
          if (this.isStale(index)) {
            this.delete(this.keyList[index])
          }
        }, ttl + 1)
        /* istanbul ignore else - unref() not supported on all platforms */
        if (t.unref) {
          t.unref()
        }
      }
    }

    this.updateItemAge = index => {
      this.starts[index] = this.ttls[index] !== 0 ? perf.now() : 0
    }

    this.statusTTL = (status, index) => {
      if (status) {
        status.ttl = this.ttls[index]
        status.start = this.starts[index]
        status.now = cachedNow || getNow()
        status.remainingTTL = status.now + status.ttl - status.start
      }
    }

    // debounce calls to perf.now() to 1s so we're not hitting
    // that costly call repeatedly.
    let cachedNow = 0
    const getNow = () => {
      const n = perf.now()
      if (this.ttlResolution > 0) {
        cachedNow = n
        const t = setTimeout(
          () => (cachedNow = 0),
          this.ttlResolution
        )
        /* istanbul ignore else - not available on all platforms */
        if (t.unref) {
          t.unref()
        }
      }
      return n
    }

    this.getRemainingTTL = key => {
      const index = this.keyMap.get(key)
      if (index === undefined) {
        return 0
      }
      return this.ttls[index] === 0 || this.starts[index] === 0
        ? Infinity
        : this.starts[index] +
            this.ttls[index] -
            (cachedNow || getNow())
    }

    this.isStale = index => {
      return (
        this.ttls[index] !== 0 &&
        this.starts[index] !== 0 &&
        (cachedNow || getNow()) - this.starts[index] >
          this.ttls[index]
      )
    }
  }
  updateItemAge(_index) {}
  statusTTL(_status, _index) {}
  setItemTTL(_index, _ttl, _start) {}
  isStale(_index) {
    return false
  }

  initializeSizeTracking() {
    this.calculatedSize = 0
    this.sizes = new ZeroArray(this.max)
    this.removeItemSize = index => {
      this.calculatedSize -= this.sizes[index]
      this.sizes[index] = 0
    }
    this.requireSize = (k, v, size, sizeCalculation) => {
      // provisionally accept background fetches.
      // actual value size will be checked when they return.
      if (this.isBackgroundFetch(v)) {
        return 0
      }
      if (!isPosInt(size)) {
        if (sizeCalculation) {
          if (typeof sizeCalculation !== 'function') {
            throw new TypeError('sizeCalculation must be a function')
          }
          size = sizeCalculation(v, k)
          if (!isPosInt(size)) {
            throw new TypeError(
              'sizeCalculation return invalid (expect positive integer)'
            )
          }
        } else {
          throw new TypeError(
            'invalid size value (must be positive integer). ' +
              'When maxSize or maxEntrySize is used, sizeCalculation or size ' +
              'must be set.'
          )
        }
      }
      return size
    }
    this.addItemSize = (index, size, status) => {
      this.sizes[index] = size
      if (this.maxSize) {
        const maxSize = this.maxSize - this.sizes[index]
        while (this.calculatedSize > maxSize) {
          this.evict(true)
        }
      }
      this.calculatedSize += this.sizes[index]
      if (status) {
        status.entrySize = size
        status.totalCalculatedSize = this.calculatedSize
      }
    }
  }
  removeItemSize(_index) {}
  addItemSize(_index, _size) {}
  requireSize(_k, _v, size, sizeCalculation) {
    if (size || sizeCalculation) {
      throw new TypeError(
        'cannot set size without setting maxSize or maxEntrySize on cache'
      )
    }
  }

  *indexes({ allowStale = this.allowStale } = {}) {
    if (this.size) {
      for (let i = this.tail; true; ) {
        if (!this.isValidIndex(i)) {
          break
        }
        if (allowStale || !this.isStale(i)) {
          yield i
        }
        if (i === this.head) {
          break
        } else {
          i = this.prev[i]
        }
      }
    }
  }

  *rindexes({ allowStale = this.allowStale } = {}) {
    if (this.size) {
      for (let i = this.head; true; ) {
        if (!this.isValidIndex(i)) {
          break
        }
        if (allowStale || !this.isStale(i)) {
          yield i
        }
        if (i === this.tail) {
          break
        } else {
          i = this.next[i]
        }
      }
    }
  }

  isValidIndex(index) {
    return (
      index !== undefined &&
      this.keyMap.get(this.keyList[index]) === index
    )
  }

  *entries() {
    for (const i of this.indexes()) {
      if (
        this.valList[i] !== undefined &&
        this.keyList[i] !== undefined &&
        !this.isBackgroundFetch(this.valList[i])
      ) {
        yield [this.keyList[i], this.valList[i]]
      }
    }
  }
  *rentries() {
    for (const i of this.rindexes()) {
      if (
        this.valList[i] !== undefined &&
        this.keyList[i] !== undefined &&
        !this.isBackgroundFetch(this.valList[i])
      ) {
        yield [this.keyList[i], this.valList[i]]
      }
    }
  }

  *keys() {
    for (const i of this.indexes()) {
      if (
        this.keyList[i] !== undefined &&
        !this.isBackgroundFetch(this.valList[i])
      ) {
        yield this.keyList[i]
      }
    }
  }
  *rkeys() {
    for (const i of this.rindexes()) {
      if (
        this.keyList[i] !== undefined &&
        !this.isBackgroundFetch(this.valList[i])
      ) {
        yield this.keyList[i]
      }
    }
  }

  *values() {
    for (const i of this.indexes()) {
      if (
        this.valList[i] !== undefined &&
        !this.isBackgroundFetch(this.valList[i])
      ) {
        yield this.valList[i]
      }
    }
  }
  *rvalues() {
    for (const i of this.rindexes()) {
      if (
        this.valList[i] !== undefined &&
        !this.isBackgroundFetch(this.valList[i])
      ) {
        yield this.valList[i]
      }
    }
  }

  [Symbol.iterator]() {
    return this.entries()
  }

  find(fn, getOptions) {
    for (const i of this.indexes()) {
      const v = this.valList[i]
      const value = this.isBackgroundFetch(v)
        ? v.__staleWhileFetching
        : v
      if (value === undefined) continue
      if (fn(value, this.keyList[i], this)) {
        return this.get(this.keyList[i], getOptions)
      }
    }
  }

  forEach(fn, thisp = this) {
    for (const i of this.indexes()) {
      const v = this.valList[i]
      const value = this.isBackgroundFetch(v)
        ? v.__staleWhileFetching
        : v
      if (value === undefined) continue
      fn.call(thisp, value, this.keyList[i], this)
    }
  }

  rforEach(fn, thisp = this) {
    for (const i of this.rindexes()) {
      const v = this.valList[i]
      const value = this.isBackgroundFetch(v)
        ? v.__staleWhileFetching
        : v
      if (value === undefined) continue
      fn.call(thisp, value, this.keyList[i], this)
    }
  }

  get prune() {
    deprecatedMethod('prune', 'purgeStale')
    return this.purgeStale
  }

  purgeStale() {
    let deleted = false
    for (const i of this.rindexes({ allowStale: true })) {
      if (this.isStale(i)) {
        this.delete(this.keyList[i])
        deleted = true
      }
    }
    return deleted
  }

  dump() {
    const arr = []
    for (const i of this.indexes({ allowStale: true })) {
      const key = this.keyList[i]
      const v = this.valList[i]
      const value = this.isBackgroundFetch(v)
        ? v.__staleWhileFetching
        : v
      if (value === undefined) continue
      const entry = { value }
      if (this.ttls) {
        entry.ttl = this.ttls[i]
        // always dump the start relative to a portable timestamp
        // it's ok for this to be a bit slow, it's a rare operation.
        const age = perf.now() - this.starts[i]
        entry.start = Math.floor(Date.now() - age)
      }
      if (this.sizes) {
        entry.size = this.sizes[i]
      }
      arr.unshift([key, entry])
    }
    return arr
  }

  load(arr) {
    this.clear()
    for (const [key, entry] of arr) {
      if (entry.start) {
        // entry.start is a portable timestamp, but we may be using
        // node's performance.now(), so calculate the offset.
        // it's ok for this to be a bit slow, it's a rare operation.
        const age = Date.now() - entry.start
        entry.start = perf.now() - age
      }
      this.set(key, entry.value, entry)
    }
  }

  dispose(_v, _k, _reason) {}

  set(
    k,
    v,
    {
      ttl = this.ttl,
      start,
      noDisposeOnSet = this.noDisposeOnSet,
      size = 0,
      sizeCalculation = this.sizeCalculation,
      noUpdateTTL = this.noUpdateTTL,
      status,
    } = {}
  ) {
    size = this.requireSize(k, v, size, sizeCalculation)
    // if the item doesn't fit, don't do anything
    // NB: maxEntrySize set to maxSize by default
    if (this.maxEntrySize && size > this.maxEntrySize) {
      if (status) {
        status.set = 'miss'
        status.maxEntrySizeExceeded = true
      }
      // have to delete, in case a background fetch is there already.
      // in non-async cases, this is a no-op
      this.delete(k)
      return this
    }
    let index = this.size === 0 ? undefined : this.keyMap.get(k)
    if (index === undefined) {
      // addition
      index = this.newIndex()
      this.keyList[index] = k
      this.valList[index] = v
      this.keyMap.set(k, index)
      this.next[this.tail] = index
      this.prev[index] = this.tail
      this.tail = index
      this.size++
      this.addItemSize(index, size, status)
      if (status) {
        status.set = 'add'
      }
      noUpdateTTL = false
    } else {
      // update
      this.moveToTail(index)
      const oldVal = this.valList[index]
      if (v !== oldVal) {
        if (this.isBackgroundFetch(oldVal)) {
          oldVal.__abortController.abort(new Error('replaced'))
        } else {
          if (!noDisposeOnSet) {
            this.dispose(oldVal, k, 'set')
            if (this.disposeAfter) {
              this.disposed.push([oldVal, k, 'set'])
            }
          }
        }
        this.removeItemSize(index)
        this.valList[index] = v
        this.addItemSize(index, size, status)
        if (status) {
          status.set = 'replace'
          const oldValue =
            oldVal && this.isBackgroundFetch(oldVal)
              ? oldVal.__staleWhileFetching
              : oldVal
          if (oldValue !== undefined) status.oldValue = oldValue
        }
      } else if (status) {
        status.set = 'update'
      }
    }
    if (ttl !== 0 && this.ttl === 0 && !this.ttls) {
      this.initializeTTLTracking()
    }
    if (!noUpdateTTL) {
      this.setItemTTL(index, ttl, start)
    }
    this.statusTTL(status, index)
    if (this.disposeAfter) {
      while (this.disposed.length) {
        this.disposeAfter(...this.disposed.shift())
      }
    }
    return this
  }

  newIndex() {
    if (this.size === 0) {
      return this.tail
    }
    if (this.size === this.max && this.max !== 0) {
      return this.evict(false)
    }
    if (this.free.length !== 0) {
      return this.free.pop()
    }
    // initial fill, just keep writing down the list
    return this.initialFill++
  }

  pop() {
    if (this.size) {
      const val = this.valList[this.head]
      this.evict(true)
      return val
    }
  }

  evict(free) {
    const head = this.head
    const k = this.keyList[head]
    const v = this.valList[head]
    if (this.isBackgroundFetch(v)) {
      v.__abortController.abort(new Error('evicted'))
    } else {
      this.dispose(v, k, 'evict')
      if (this.disposeAfter) {
        this.disposed.push([v, k, 'evict'])
      }
    }
    this.removeItemSize(head)
    // if we aren't about to use the index, then null these out
    if (free) {
      this.keyList[head] = null
      this.valList[head] = null
      this.free.push(head)
    }
    this.head = this.next[head]
    this.keyMap.delete(k)
    this.size--
    return head
  }

  has(k, { updateAgeOnHas = this.updateAgeOnHas, status } = {}) {
    const index = this.keyMap.get(k)
    if (index !== undefined) {
      if (!this.isStale(index)) {
        if (updateAgeOnHas) {
          this.updateItemAge(index)
        }
        if (status) status.has = 'hit'
        this.statusTTL(status, index)
        return true
      } else if (status) {
        status.has = 'stale'
        this.statusTTL(status, index)
      }
    } else if (status) {
      status.has = 'miss'
    }
    return false
  }

  // like get(), but without any LRU updating or TTL expiration
  peek(k, { allowStale = this.allowStale } = {}) {
    const index = this.keyMap.get(k)
    if (index !== undefined && (allowStale || !this.isStale(index))) {
      const v = this.valList[index]
      // either stale and allowed, or forcing a refresh of non-stale value
      return this.isBackgroundFetch(v) ? v.__staleWhileFetching : v
    }
  }

  backgroundFetch(k, index, options, context) {
    const v = index === undefined ? undefined : this.valList[index]
    if (this.isBackgroundFetch(v)) {
      return v
    }
    const ac = new AC()
    if (options.signal) {
      options.signal.addEventListener('abort', () =>
        ac.abort(options.signal.reason)
      )
    }
    const fetchOpts = {
      signal: ac.signal,
      options,
      context,
    }
    const cb = (v, updateCache = false) => {
      const { aborted } = ac.signal
      const ignoreAbort = options.ignoreFetchAbort && v !== undefined
      if (options.status) {
        if (aborted && !updateCache) {
          options.status.fetchAborted = true
          options.status.fetchError = ac.signal.reason
          if (ignoreAbort) options.status.fetchAbortIgnored = true
        } else {
          options.status.fetchResolved = true
        }
      }
      if (aborted && !ignoreAbort && !updateCache) {
        return fetchFail(ac.signal.reason)
      }
      // either we didn't abort, and are still here, or we did, and ignored
      if (this.valList[index] === p) {
        if (v === undefined) {
          if (p.__staleWhileFetching) {
            this.valList[index] = p.__staleWhileFetching
          } else {
            this.delete(k)
          }
        } else {
          if (options.status) options.status.fetchUpdated = true
          this.set(k, v, fetchOpts.options)
        }
      }
      return v
    }
    const eb = er => {
      if (options.status) {
        options.status.fetchRejected = true
        options.status.fetchError = er
      }
      return fetchFail(er)
    }
    const fetchFail = er => {
      const { aborted } = ac.signal
      const allowStaleAborted =
        aborted && options.allowStaleOnFetchAbort
      const allowStale =
        allowStaleAborted || options.allowStaleOnFetchRejection
      const noDelete = allowStale || options.noDeleteOnFetchRejection
      if (this.valList[index] === p) {
        // if we allow stale on fetch rejections, then we need to ensure that
        // the stale value is not removed from the cache when the fetch fails.
        const del = !noDelete || p.__staleWhileFetching === undefined
        if (del) {
          this.delete(k)
        } else if (!allowStaleAborted) {
          // still replace the *promise* with the stale value,
          // since we are done with the promise at this point.
          // leave it untouched if we're still waiting for an
          // aborted background fetch that hasn't yet returned.
          this.valList[index] = p.__staleWhileFetching
        }
      }
      if (allowStale) {
        if (options.status && p.__staleWhileFetching !== undefined) {
          options.status.returnedStale = true
        }
        return p.__staleWhileFetching
      } else if (p.__returned === p) {
        throw er
      }
    }
    const pcall = (res, rej) => {
      this.fetchMethod(k, v, fetchOpts).then(v => res(v), rej)
      // ignored, we go until we finish, regardless.
      // defer check until we are actually aborting,
      // so fetchMethod can override.
      ac.signal.addEventListener('abort', () => {
        if (
          !options.ignoreFetchAbort ||
          options.allowStaleOnFetchAbort
        ) {
          res()
          // when it eventually resolves, update the cache.
          if (options.allowStaleOnFetchAbort) {
            res = v => cb(v, true)
          }
        }
      })
    }
    if (options.status) options.status.fetchDispatched = true
    const p = new Promise(pcall).then(cb, eb)
    p.__abortController = ac
    p.__staleWhileFetching = v
    p.__returned = null
    if (index === undefined) {
      // internal, don't expose status.
      this.set(k, p, { ...fetchOpts.options, status: undefined })
      index = this.keyMap.get(k)
    } else {
      this.valList[index] = p
    }
    return p
  }

  isBackgroundFetch(p) {
    return (
      p &&
      typeof p === 'object' &&
      typeof p.then === 'function' &&
      Object.prototype.hasOwnProperty.call(
        p,
        '__staleWhileFetching'
      ) &&
      Object.prototype.hasOwnProperty.call(p, '__returned') &&
      (p.__returned === p || p.__returned === null)
    )
  }

  // this takes the union of get() and set() opts, because it does both
  async fetch(
    k,
    {
      // get options
      allowStale = this.allowStale,
      updateAgeOnGet = this.updateAgeOnGet,
      noDeleteOnStaleGet = this.noDeleteOnStaleGet,
      // set options
      ttl = this.ttl,
      noDisposeOnSet = this.noDisposeOnSet,
      size = 0,
      sizeCalculation = this.sizeCalculation,
      noUpdateTTL = this.noUpdateTTL,
      // fetch exclusive options
      noDeleteOnFetchRejection = this.noDeleteOnFetchRejection,
      allowStaleOnFetchRejection = this.allowStaleOnFetchRejection,
      ignoreFetchAbort = this.ignoreFetchAbort,
      allowStaleOnFetchAbort = this.allowStaleOnFetchAbort,
      fetchContext = this.fetchContext,
      forceRefresh = false,
      status,
      signal,
    } = {}
  ) {
    if (!this.fetchMethod) {
      if (status) status.fetch = 'get'
      return this.get(k, {
        allowStale,
        updateAgeOnGet,
        noDeleteOnStaleGet,
        status,
      })
    }

    const options = {
      allowStale,
      updateAgeOnGet,
      noDeleteOnStaleGet,
      ttl,
      noDisposeOnSet,
      size,
      sizeCalculation,
      noUpdateTTL,
      noDeleteOnFetchRejection,
      allowStaleOnFetchRejection,
      allowStaleOnFetchAbort,
      ignoreFetchAbort,
      status,
      signal,
    }

    let index = this.keyMap.get(k)
    if (index === undefined) {
      if (status) status.fetch = 'miss'
      const p = this.backgroundFetch(k, index, options, fetchContext)
      return (p.__returned = p)
    } else {
      // in cache, maybe already fetching
      const v = this.valList[index]
      if (this.isBackgroundFetch(v)) {
        const stale =
          allowStale && v.__staleWhileFetching !== undefined
        if (status) {
          status.fetch = 'inflight'
          if (stale) status.returnedStale = true
        }
        return stale ? v.__staleWhileFetching : (v.__returned = v)
      }

      // if we force a refresh, that means do NOT serve the cached value,
      // unless we are already in the process of refreshing the cache.
      const isStale = this.isStale(index)
      if (!forceRefresh && !isStale) {
        if (status) status.fetch = 'hit'
        this.moveToTail(index)
        if (updateAgeOnGet) {
          this.updateItemAge(index)
        }
        this.statusTTL(status, index)
        return v
      }

      // ok, it is stale or a forced refresh, and not already fetching.
      // refresh the cache.
      const p = this.backgroundFetch(k, index, options, fetchContext)
      const hasStale = p.__staleWhileFetching !== undefined
      const staleVal = hasStale && allowStale
      if (status) {
        status.fetch = hasStale && isStale ? 'stale' : 'refresh'
        if (staleVal && isStale) status.returnedStale = true
      }
      return staleVal ? p.__staleWhileFetching : (p.__returned = p)
    }
  }

  get(
    k,
    {
      allowStale = this.allowStale,
      updateAgeOnGet = this.updateAgeOnGet,
      noDeleteOnStaleGet = this.noDeleteOnStaleGet,
      status,
    } = {}
  ) {
    const index = this.keyMap.get(k)
    if (index !== undefined) {
      const value = this.valList[index]
      const fetching = this.isBackgroundFetch(value)
      this.statusTTL(status, index)
      if (this.isStale(index)) {
        if (status) status.get = 'stale'
        // delete only if not an in-flight background fetch
        if (!fetching) {
          if (!noDeleteOnStaleGet) {
            this.delete(k)
          }
          if (status) status.returnedStale = allowStale
          return allowStale ? value : undefined
        } else {
          if (status) {
            status.returnedStale =
              allowStale && value.__staleWhileFetching !== undefined
          }
          return allowStale ? value.__staleWhileFetching : undefined
        }
      } else {
        if (status) status.get = 'hit'
        // if we're currently fetching it, we don't actually have it yet
        // it's not stale, which means this isn't a staleWhileRefetching.
        // If it's not stale, and fetching, AND has a __staleWhileFetching
        // value, then that means the user fetched with {forceRefresh:true},
        // so it's safe to return that value.
        if (fetching) {
          return value.__staleWhileFetching
        }
        this.moveToTail(index)
        if (updateAgeOnGet) {
          this.updateItemAge(index)
        }
        return value
      }
    } else if (status) {
      status.get = 'miss'
    }
  }

  connect(p, n) {
    this.prev[n] = p
    this.next[p] = n
  }

  moveToTail(index) {
    // if tail already, nothing to do
    // if head, move head to next[index]
    // else
    //   move next[prev[index]] to next[index] (head has no prev)
    //   move prev[next[index]] to prev[index]
    // prev[index] = tail
    // next[tail] = index
    // tail = index
    if (index !== this.tail) {
      if (index === this.head) {
        this.head = this.next[index]
      } else {
        this.connect(this.prev[index], this.next[index])
      }
      this.connect(this.tail, index)
      this.tail = index
    }
  }

  get del() {
    deprecatedMethod('del', 'delete')
    return this.delete
  }

  delete(k) {
    let deleted = false
    if (this.size !== 0) {
      const index = this.keyMap.get(k)
      if (index !== undefined) {
        deleted = true
        if (this.size === 1) {
          this.clear()
        } else {
          this.removeItemSize(index)
          const v = this.valList[index]
          if (this.isBackgroundFetch(v)) {
            v.__abortController.abort(new Error('deleted'))
          } else {
            this.dispose(v, k, 'delete')
            if (this.disposeAfter) {
              this.disposed.push([v, k, 'delete'])
            }
          }
          this.keyMap.delete(k)
          this.keyList[index] = null
          this.valList[index] = null
          if (index === this.tail) {
            this.tail = this.prev[index]
          } else if (index === this.head) {
            this.head = this.next[index]
          } else {
            this.next[this.prev[index]] = this.next[index]
            this.prev[this.next[index]] = this.prev[index]
          }
          this.size--
          this.free.push(index)
        }
      }
    }
    if (this.disposed) {
      while (this.disposed.length) {
        this.disposeAfter(...this.disposed.shift())
      }
    }
    return deleted
  }

  clear() {
    for (const index of this.rindexes({ allowStale: true })) {
      const v = this.valList[index]
      if (this.isBackgroundFetch(v)) {
        v.__abortController.abort(new Error('deleted'))
      } else {
        const k = this.keyList[index]
        this.dispose(v, k, 'delete')
        if (this.disposeAfter) {
          this.disposed.push([v, k, 'delete'])
        }
      }
    }

    this.keyMap.clear()
    this.valList.fill(null)
    this.keyList.fill(null)
    if (this.ttls) {
      this.ttls.fill(0)
      this.starts.fill(0)
    }
    if (this.sizes) {
      this.sizes.fill(0)
    }
    this.head = 0
    this.tail = 0
    this.initialFill = 1
    this.free.length = 0
    this.calculatedSize = 0
    this.size = 0
    if (this.disposed) {
      while (this.disposed.length) {
        this.disposeAfter(...this.disposed.shift())
      }
    }
  }

  get reset() {
    deprecatedMethod('reset', 'clear')
    return this.clear
  }

  get length() {
    deprecatedProperty('length', 'size')
    return this.size
  }

  static get AbortController() {
    return AC
  }
  static get AbortSignal() {
    return AS
  }
}

module.exports = LRUCache


/***/ }),

/***/ 18777:
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('[["8740","‰è∞‰∞≤‰òÉ‰ñ¶‰ï∏ßâß‰µ∑‰ñ≥ß≤±‰≥¢ß≥Ö„Æï‰ú∂‰ùÑ‰±á‰±Ä§äø£òóßçí¶∫ãßÉí‰±ó™çë‰ùè‰óö‰≤Öß±¨‰¥á‰™§‰ö°¶¨£Áà••©î°©££∏Ü£Ω°ÊôçÂõª"],["8767","Á∂ïÂ§ù®Æπ„∑¥Èú¥ßØØÂØõ°µûÂ™§„ò•©∫∞Â´ëÂÆ∑Â≥ºÊùÆËñì©•ÖÁë°Áíù„°µ°µì£öû¶Ä°„ª¨"],["87a1","•£û„´µÁ´ºÈæó§Ö°®§ç£á™†™ä£âû‰åäËíÑÈæñÈêØ‰§∞ËòìÂ¢ñÈùäÈàòÁßêÁ®≤Êô†Ê®©Ë¢ùÁëåÁØÖÊûÇÁ®¨ÂâèÈÅÜ„ì¶ÁèÑ•∂πÁìÜÈøáÂû≥‰§ØÂëå‰Ñ±£öéÂ†òÁ©≤ß≠•ËÆè‰öÆ¶∫à‰ÜÅ•∂ôÁÆÆ¢íºÈøà¢ìÅ¢ìâ¢ìåÈøâËîÑ£ñª‰Ç¥Èøä‰ì°™∑øÊãÅÁÅÆÈøã"],["8840","„áÄ",4,"†Ñå„áÖ†Éë†Éç„áÜ„áá†Éã°ø®„áà†Éä„áâ„áä„áã„áå†Ñé„áç„áéƒÄ√Å«ç√Äƒí√âƒö√à≈å√ì«ë√í‡øø√äÃÑ·∫æ‡øø√äÃå·ªÄ√äƒÅ√°«é√†…ëƒì√©ƒõ√®ƒ´√≠«ê√¨≈ç√≥«í√≤≈´√∫«î√π«ñ«ò«ö"],["88a1","«ú√º‡øø√™ÃÑ·∫ø‡øø√™Ãå·ªÅ√™…°‚èö‚èõ"],["8940","™é©°ÖÖ"],["8943","Êîä"],["8946","‰∏ΩÊªùÈµéÈáü"],["894c","ßúµÊíë‰ºö‰º®‰æ®ÂÖñÂÖ¥ÂÜúÂá§Âä°Âä®ÂåªÂçéÂèëÂèòÂõ¢Â£∞Â§ÑÂ§áÂ§≤Â§¥Â≠¶ÂÆûÂÆüÂ≤öÂ∫ÜÊÄªÊñâÊüæÊ†ÑÊ°•ÊµéÁÇºÁîµÁ∫§Á∫¨Á∫∫ÁªáÁªèÁªüÁºÜÁº∑Ëâ∫ËãèËçØËßÜËÆæËØ¢ËΩ¶ËΩßËΩÆ"],["89a1","ÁêëÁ≥ºÁ∑çÊ•ÜÁ´âÂàß"],["89ab","ÈÜåÁ¢∏ÈÖûËÇº"],["89b0","Ë¥ãËÉ∂†ßß"],["89b5","ËÇüÈªá‰≥çÈ∑âÈ∏å‰∞æ©∑∂ßÄéÈ∏ä™Ñ≥„óÅ"],["89c1","Ê∫öËàæÁîô"],["89c5","‰§ëÈ©¨È™èÈæôÁ¶á®ë¨°∑ä†óê¢´¶‰∏§‰∫Å‰∫Ä‰∫á‰∫ø‰ª´‰º∑„ëå‰æΩ„πàÂÄÉÂÇà„ëΩ„íì„í•ÂÜÜÂ§ÖÂáõÂáºÂàÖ‰∫âÂâπÂäêÂåß„óáÂé©„ïëÂé∞„ïìÂèÇÂê£„ï≠„ï≤„öÅÂíìÂí£Âí¥ÂíπÂìêÂìØÂîòÂî£Âî®„ñòÂîø„ñ•„ñøÂóó„óÖ"],["8a40","ß∂ÑÂî•"],["8a43","†±Ç†¥ï•Ñ´Âñê¢≥Ü„ß¨†çÅËπÜ§∂∏©ì•‰Åì®ÇæÁù∫¢∞∏„®¥‰üï®Öù¶ß≤§∑™Êìù†µº†æ¥†≥ï°É¥ÊíçËπæ†∫ñ†∞ã†Ω§¢≤©®âñ§ìì"],["8a64","†µÜ©©ç®É©‰ü¥§∫ß¢≥ÇÈ™≤„©ß©ó¥„ø≠„îÜ•ãá©üîß£à¢µÑÈµÆÈ†ï"],["8a76","‰èô¶Ç•Êí¥Âì£¢µå¢Øä°Å∑„ßª°ÅØ"],["8aa1","¶õö¶úñß¶†Êì™•Åí†±ÉËπ®¢Ü°®≠å†ú±"],["8aac","‰†ã†Ü©„ø∫Â°≥¢∂ç"],["8ab2","§óà†ìº¶Çó†Ωå†∂ñÂïπ‰Çª‰é∫"],["8abb","‰™¥¢©¶°ÇùËÜ™È£µ†∂úÊçπ„ßæ¢ùµË∑ÄÂö°Êëº„πÉ"],["8ac9","™òÅ†∏â¢´è¢≥â"],["8ace","°Éà£ßÇ„¶í„®Ü®äõ„ï∏•πâ¢ÉáÂôí†º±¢≤≤©ú†„íºÊ∞Ω§∏ª"],["8adf","ßï¥¢∫ã¢àà™ôõ®≥ç†π∫†∞¥¶†úÁæì°Éè¢†É¢§π„óª•á£†∫å†æç†∫™„æì†º∞†µá°Öè†πå"],["8af6","†∫´†Æ©†µà°ÉÄ°ÑΩ„øπ¢öñÊê≤†æ≠"],["8b40","£è¥ßòπ¢Øé†µæ†µø¢±ë¢±ï„®ò†∫ò°Éá†ºÆ™ò≤¶≠ê®≥í®∂ô®≥äÈñ™ÂìåËãÑÂñπ"],["8b55","©ªÉÈ∞¶È™∂ßùû¢∑ÆÁÖÄËÖ≠ËÉ¨Â∞ú¶ï≤ËÑ¥„ûóÂçü®ÇΩÈÜ∂†ª∫†∏è†π∑†ªª„óù§∑´„òâ†≥ñÂöØ¢ûµ°Éâ†∏ê†π∏°Å∏°Öà®àá°ëï†ππ§πê¢∂§Â©î°Äù°Äû°Éµ°É∂Âûú†∏ë"],["8ba1","ßöî®ãç†æµ†πª•Öæ„úÉ†æ∂°ÜÄ•ãò™äΩ§ßö°†∫§Ö∑®âºÂ¢ôÂâ®„òö•úΩÁÆ≤Â≠®‰†Ä‰¨¨Èºß‰ßßÈ∞üÈÆç•≠¥£ÑΩÂóª„ó≤Âöâ‰∏®Â§Ç°ØÅØ°∏Èùë†ÇÜ‰πõ‰∫ª„îæÂ∞£ÂΩëÂøÑ„£∫ÊâåÊîµÊ≠∫Ê∞µÊ∞∫ÁÅ¨Áà´‰∏¨Áä≠§£©ÁΩíÁ§ªÁ≥πÁΩì¶â™„ìÅ"],["8bde","¶çãËÄÇËÇÄ¶òí¶•ëÂçùË°§ËßÅß¢≤ËÆ†Ë¥ùÈíÖÈï∏ÈïøÈó®®∏èÈü¶È°µÈ£éÈ£ûÈ•£©†êÈ±ºÈ∏üÈªÑÊ≠ØÔ§á‰∏∑†ÇáÈòùÊà∑Èí¢"],["8c40","ÂÄªÊ∑æ©±≥Èæ¶„∑âË¢è§ÖéÁÅ∑Â≥µ‰¨†•áç„ïô•¥∞ÊÑ¢®®≤ËæßÈá∂ÁÜëÊúôÁé∫£äÅ™Ñá„≤ã°¶Ä‰¨êÁ£§ÁêÇÂÜÆ®úè‰ÄâÊ©£™ä∫‰à£Ëòè†©ØÁ®™©•á®´™ÈùïÁÅçÂå§¢ÅæÈè¥Áõô®ß£ÈæßÁüù‰∫£‰ø∞ÂÇº‰∏Ø‰ºóÈæ®Âê¥Á∂ãÂ¢íÂ£ê°∂∂Â∫íÂ∫ôÂøÇ¢úíÊñã"],["8ca1","£èπÊ§ôÊ©É£±£Ê≥ø"],["8ca7","ÁàÄ§îÖÁéå„ªõ§®ìÂ¨ïÁíπËÆÉ•≤§•öïÁ™ìÁØ¨Á≥ÉÁπ¨Ëã∏ËñóÈæ©Ë¢êÈæ™Ë∫πÈæ´ËøèËïüÈß†Èà°Èæ¨®∂π°êø‰Å±‰ä¢Â®ö"],["8cc9","È°®Êù´‰â∂ÂúΩ"],["8cce","Ëóñ§•ªËäøßÑç‰≤Å¶µ¥Âµª¶¨ï¶ææÈæ≠ÈæÆÂÆñÈæØÊõßÁπõÊπóÁßä„∂à‰ìÉ£âñ¢ûñ‰éö‰î∂"],["8ce6","Â≥ï£¨öË´πÂ±∏„¥í£ïëÂµ∏Èæ≤ÁÖó‰ïò§É¨°∏£‰±∑„•∏„ëä†Ü§¶±ÅË´å‰æ¥†àπÂ¶øËÖ¨È°ñ©£∫Âºª"],["8d40","†Æü"],["8d42","¢áÅ®•≠‰ÑÇ‰öª©Åπ„ºáÈæ≥™Üµ‰É∏„üñ‰õ∑¶±Ü‰Öº®ö≤ßèø‰ï≠„£î•íö‰ï°‰îõ‰∂â‰±ª‰µ∂‰ó™„øà§¨è„ô°‰ìû‰íΩ‰á≠Â¥æÂµàÂµñ„∑º„†èÂ∂§Â∂π„††„†∏ÂπÇÂ∫ΩÂº•ÂæÉ„§à„§î„§ø„•çÊÉóÊÑΩÂ≥•„¶âÊÜ∑ÊÜπÊáè„¶∏Êà¨ÊäêÊã•Êåò„ß∏Âö±"],["8da1","„®ÉÊè¢ÊèªÊêáÊëö„©ãÊìÄÂ¥ïÂò°Èæü„™óÊñÜ„™ΩÊóøÊôì„´≤Êöí„¨¢Êúñ„≠ÇÊû§Ê†Ä„≠òÊ°äÊ¢Ñ„≠≤„≠±„≠ªÊ§âÊ•ÉÁâúÊ•§Ê¶üÊ¶Ö„ÆºÊßñ„ØùÊ©•Ê©¥Ê©±Ê™Ç„Ø¨Ê™ô„Ø≤Ê™´Ê™µÊ´îÊ´∂ÊÆÅÊØÅÊØ™Ê±µÊ≤™„≥ãÊ¥ÇÊ¥ÜÊ¥¶Ê∂Å„≥ØÊ∂§Ê∂±Ê∏ïÊ∏òÊ∏©Ê∫Ü®ßÄÊ∫ªÊª¢ÊªöÈΩøÊª®Êª©Êº§Êº¥„µÜ£ΩÅÊæÅÊææ„µ™„µµÁÜ∑Â≤ô„∂äÁÄ¨„∂ëÁÅêÁÅîÁÅØÁÅøÁÇâ†å•‰èÅ„ó±†ªò"],["8e40","£ªóÂûæ¶ªìÁÑæ•ü†„ôéÊ¶¢®Ø©Â≠¥Á©â•£°©ìôÁ©•Á©Ω•¶¨Á™ªÁ™∞Á´ÇÁ´ÉÁáë¶íç‰áäÁ´öÁ´ùÁ´™‰áØÂí≤•∞ÅÁ¨ãÁ≠ïÁ¨©•åé•≥æÁÆ¢Á≠ØËéú•Æ¥¶±øÁØêËê°ÁÆíÁÆ∏•¥†„∂≠•±•ËííÁØ∫Á∞ÜÁ∞µ•≥ÅÁ±ÑÁ≤É§¢ÇÁ≤¶ÊôΩ§ï∏Á≥âÁ≥áÁ≥¶Á±¥Á≥≥Á≥µÁ≥é"],["8ea1","Áπß‰îù¶πÑÁµù¶ªñÁíçÁ∂âÁ∂´ÁÑµÁ∂≥Á∑í§Åó¶Ä©Á∑§„¥ìÁ∑µ°üπÁ∑•®ç≠Á∏ù¶Ñ°¶ÖöÁπÆÁ∫í‰å´Èë¨Á∏ßÁΩÄÁΩÅÁΩáÁ§∂¶ãêÈß°Áæó¶çëÁæ£°ô°†Å®‰ïú£ù¶‰îÉ®å∫Áø∫¶íâËÄÖËÄàËÄùËÄ®ËÄØ™Çá¶≥ÉËÄªËÄºËÅ°¢úî‰¶â¶ò¶£∑£¶õ®Êú•ËÇß®©àËÑáËÑöÂ¢∞¢õ∂Ê±ø¶íò§æ∏Êìß°íäËàò°°ûÊ©ì§©•§™ï‰ë∫Ëà©†¨ç¶©í£µæ‰øπ°ìΩËì¢Ëç¢¶¨ä§¶ß£î∞°ù≥£∑∏Ëä™Ê§õØ¶î‰áõ"],["8f40","ËïãËãêËåö†∏ñ°û¥„õÅ£ÖΩ£ïöËâªËã¢Ëåò£∫ã¶∂£¶¨Ö¶Æó£óé„∂øËåùÂó¨ËéÖ‰îã¶∂•Ëé¨ËèÅËèì„ëæ¶ªîÊ©óËïö„íñ¶πÇ¢ªØËëò•Ø§Ëë±„∑ì‰ì§Ê™ßËëä£≤µÁ•òËí®¶Æñ¶π∑¶πÉËìûËêèËéë‰í†ËíìËì§•≤ë‰âÄ•≥Ä‰ïÉËî¥Â´≤¶∫ô‰îßËï≥‰îñÊûøËòñ"],["8fa1","®ò•®òªËóÅßÇàËòÇ°ñÇßÉçØ¶≤‰ï™Ëò®„ôà°¢¢Âè∑ßéöËôæËù±™É∏ËüÆ¢∞ßËû±ËüöË†èÂô°Ëô¨Ê°ñ‰òèË°ÖË°Üßó†£∂πßó§Ë°ûË¢ú‰ôõË¢¥Ë¢µÊèÅË£ÖÁù∑ßúèË¶áË¶äË¶¶Ë¶©Ë¶ßË¶º®®•Ëßßß§§ß™ΩË™úÁûìÈáæË™êß©ôÁ´©ß¨∫£æè‰úìß¨∏ÁÖºË¨åË¨ü•ê∞•ï•Ë¨øË≠åË≠çË™©§©∫ËÆêËÆõË™Ø°õü‰òïË°èË≤õßµîß∂èØßî„ú•ßµìË≥ñß∂òß∂ΩË¥íË¥É°§êË≥õÁÅúË¥ë§≥â„ªêËµ∑"],["9040","Ë∂©®ÄÇ°Äî§¶ä„≠º®ÜºßÑåÁ´ßË∫≠Ë∫∂ËªÉÈãîËºôËº≠®ç•®êíËæ•ÈåÉ™äü†©êËæ≥‰§™®ßû®îΩ£∂ªÂª∏£â¢Ëøπ™Äî®öº®îÅ¢å•„¶Ä¶ªóÈÄ∑®îºß™æÈÅ°®ï¨®òãÈÇ®®úìÈÉÑ®õ¶ÈÇÆÈÉΩÈÖß„´∞ÈÜ©ÈáÑÁ≤¨®§≥°∫âÈàéÊ≤üÈâÅÈâ¢•ñπÈäπ®´Ü£≤õ®¨å•óõ"],["90a1","†¥±Èå¨Èç´®´°®Ø´ÁÇèÂ´É®´¢®´•‰••ÈâÑ®Ø¨®∞π®ØøÈç≥ÈëõË∫ºÈñÖÈñ¶Èê¶Èñ†Êø∂‰äπ¢ô∫®õò°âº£∏Æ‰ßüÊ∞úÈôªÈöñ‰Ö¨Èö£¶ªïÊáöÈö∂Á£µ®´†ÈöΩÂèå‰¶°¶≤∏†â¥¶êê©ÇØ©É•§´ë°§ï£åäÈú±ËôÇÈú∂‰®è‰îΩ‰ñÖ§´©ÁÅµÂ≠ÅÈúõÈùú©áïÈùóÂ≠ä©á´ÈùüÈê•ÂÉê£Ç∑£ÇºÈûâÈûüÈû±ÈûæÈüÄÈüíÈü†•ë¨ÈüÆÁêú©ê≥ÈüøÈüµ©êùß•∫‰´ëÈ†¥È†≥È°ãÈ°¶„¨éßÖµ„µë†ò∞§Öú"],["9140","•úÜÈ£äÈ¢∑È£àÈ£á‰´ø¶¥ß°õìÂñ∞È£°È£¶È£¨Èç∏È§π§®©‰≠≤©°ó©§ÖÈßµÈ®åÈ®ªÈ®êÈ©ò•ú•„õÑ©Ç±©ØïÈ´†È´¢©¨ÖÈ´¥‰∞éÈ¨îÈ¨≠®òÄÂÄ¥È¨¥¶¶®„£É£ÅΩÈ≠êÈ≠Ä©¥æÂ©Ö°°£ÈÆé§âãÈ∞ÇÈØøÈ∞å©π®È∑î©æ∑™Üí™Ü´™É°™Ñ£™áüÈµæÈ∂É™Ñ¥È∏éÊ¢à"],["91a1","È∑Ñ¢Öõ™Üì™à†°§ª™à≥È¥π™Çπ™ä¥È∫êÈ∫ïÈ∫ûÈ∫¢‰¥¥È∫™È∫Ø§ç§ÈªÅ„≠†„ß•„¥ù‰º≤„ûæ®∞´ÈºÇÈºà‰ÆñÈê§¶∂¢ÈºóÈºñÈºπÂöüÂöäÈΩÖÈ¶∏©ÇãÈü≤ËëøÈΩ¢ÈΩ©Á´úÈæéÁàñ‰Ææ§•µ§¶ªÁÖ∑§ß∏§çà§©ëÁéû®Øö°£∫Á¶ü®•æ®∏∂Èç©Èè≥®©ÑÈã¨ÈéÅÈèã®•¨§íπÁàó„ª´Áù≤Á©ÉÁÉê§ë≥§è∏ÁÖæ°üØÁÇ£°¢æ£ñô„ªá°¢Ö•êØ°ü∏„ú¢°õª°†π„õ°°ù¥°£ë•Ωã„ú£°õÄÂùõ§®•°èæ°ä®"],["9240","°èÜ°í∂ËîÉ£ö¶ËîÉËëï§¶îßÖ•£∏±•ïú£ªªßÅí‰ì¥£õÆ©¶ù¶º¶Êüπ„ú≥„∞ï„∑ßÂ°¨°§¢Ê†ê‰Åó£úø§É°§Çã§Ñè¶∞°ÂìãÂöû¶ö±Âöí†øü†Æ®†∏çÈèÜ®¨ìÈéú‰ª∏ÂÑ´„†ô§ê∂‰∫º†ë•†çø‰Ωã‰æä•ôëÂ©®†Ü´†èã„¶ô†åä†êî„êµ‰º©†ãÄ®∫≥†âµË´ö†àå‰∫ò"],["92a1","ÂÉçÂÑç‰æ¢‰ºÉ§®é£∫ä‰ΩÇÂÄÆÂÅ¨ÂÇÅ‰øå‰ø•ÂÅòÂÉºÂÖôÂÖõÂÖùÂÖûÊπ∂£ñï£∏π£∫øÊµ≤°¢Ñ£∫âÂÜ®ÂáÉ†ó†‰ìù†í£†íí†íëËµ∫®™ú†úéÂâôÂä§†°≥Âã°ÈçÆ‰ô∫ÁÜå§éå†∞†§¶¨°É§Êßë†∏ùÁëπ„ªûÁíôÁêîÁëñÁéò‰Æé§™º§ÇçÂèê„ñÑÁàè§ÉâÂñ¥†çÖÂìç†ØÜÂúùÈâùÈõ¥Èç¶ÂüùÂûçÂùø„òæÂ£ãÂ™ô®©Ü°õ∫°ùØ°úêÂ®¨Â¶∏ÈäèÂ©æÂ´èÂ®í••Ü°ß≥°°°§äï„õµÊ¥ÖÁëÉÂ®°•∫É"],["9340","Â™Å®Øó†êìÈè†Áíå°åÉÁÑÖ‰•≤Èêà®ßªÈéΩ„û†Â∞ûÂ≤ûÂπûÂπà°¶ñ°•º£´ÆÂªçÂ≠è°§É°§Ñ„úÅ°¢†„õù°õæ„õìËÑ™®©á°∂∫£ë≤®¶®ÂºåÂºé°§ß°û´Â©´°úªÂ≠ÑËòîßóΩË°†ÊÅæ¢°†¢ò´Âøõ„∫∏¢ñØ¢ñæ©Çà¶Ω≥ÊáÄ†Äæ†ÅÜ¢òõÊÜôÊÜòÊÅµ¢≤õ¢¥á§õî©Öç"],["93a1","Êë±§ô•¢≠™„®©¢¨¢£ëê©£™¢π∏Êå∑™ëõÊí∂Êå±Êèë§ß£¢µßÊä§¢≤°ÊêªÊï´Ê•≤„Ø¥£Çé£ä≠§¶â£ä´Âîç£ã†°£ô©êøÊõé£äâ£Ü≥„´†‰Üê•ñÑ®¨¢•ñè°õº•ïõ•ê•Á£Æ£ÑÉ°†™£à¥„ë§£àè£ÜÇ§ãâÊöé¶¥§Êô´‰ÆìÊò∞ß°∞°∑´Êô££ãí£ã°Êòû•°≤„£ë£†∫£ûº„Æô£û¢£èæÁìê„ÆñÊûè§ò™Ê¢∂Ê†û„ØÑÊ™æ„°££üï§íáÊ®≥Ê©íÊ´âÊ¨Ö°§íÊîëÊ¢òÊ©å„ØóÊ©∫Ê≠ó£øÄ£≤öÈé†Èã≤®Ø™®´ã"],["9440","Èäâ®Äû®ßúÈëßÊ∂•Êºã§ß¨Êµß£Ωø„∂èÊ∏Ñ§ÄºÂ®ΩÊ∏äÂ°áÊ¥§Á°ÇÁÑª§åö§â∂ÁÉ±ÁâêÁäáÁäî§ûè§ú•ÂÖπ§™§†ó´Áë∫£ª∏£ôü§©ä§§ó•ø°„ºÜ„∫±§´ü®∞££ºµÊÇß„ª≥ÁìåÁêºÈéáÁê∑‰íü¶∑™‰ïëÁñÉ„Ω£§≥ô§¥Ü„ΩòÁïïÁô≥™óÜ„¨ôÁë®®´å§¶´§¶é„´ª"],["94a1","„∑ç§©é„ªø§ßÖ§£≥Èá∫Âú≤ÈçÇ®´£°°§ÂÉü•à°•áßÁù∏£à≤ÁúéÁúèÁùª§öó£ûÅ„©û§£∞Áê∏Áíõ„∫ø§™∫§´á‰Éà§™ñ¶ÜÆÈåá•ñÅÁ†ûÁ¢çÁ¢àÁ£íÁèêÁ•ôßùÅ•õ£‰ÑéÁ¶õËíñÁ¶•Ê®≠£ª∫Á®∫Áß¥‰ÖÆ°õ¶‰Ñ≤ÈàµÁß±†µå§¶å†äô£∂∫°ùÆ„ñóÂï´„ï∞„ö™†áî†∞çÁ´¢Â©ô¢õµ•™Ø•™úÂ®ç†âõÁ£∞Â®™•ØÜÁ´æ‰áπÁ±ùÁ±≠‰àë•Æ≥•∫º•∫¶Á≥ç§ßπ°û∞Á≤éÁ±ºÁ≤ÆÊ™≤Á∑úÁ∏áÁ∑ìÁΩé¶â°"],["9540","¶Öúß≠àÁ∂ó•∫Ç‰â™¶≠µ†§ñÊüñ†Åé£óèÂüÑ¶êí¶è∏§•¢ÁøùÁ¨ß††¨•´©•µÉÁ¨å•∏éÈß¶ËôÖÈ©£Ê®ú£êø„ß¢§ß∑¶ñ≠È®ü¶ñ†ËíÄßÑß¶≥ë‰ì™ËÑ∑‰êÇËÉÜËÑâËÖÇ¶û¥È£É¶©ÇËâ¢Ëâ•¶©ëËëì¶∂ßËòêßàõÂ™Ü‰Öø°°ÄÂ¨´°¢°Â´§°£òËö†Ø¶º£∂èË†≠ßê¢Â®Ç"],["95a1","Ë°Æ‰ΩÖË¢áË¢øË£¶Ë••Ë•ç•öÉË•îßûÖßûÑ®Øµ®Øô®Æú®ßπ„∫≠Ëí£‰õµ‰õè„ü≤Ë®ΩË®ú©ëàÂΩçÈà´§äÑÊóîÁÑ©ÁÉÑ°°ÖÈµ≠Ë≤üË≥©ß∑úÂ¶öÁüÉÂß∞‰çÆ„õîË∏™Ë∫ß§∞âËº∞ËΩä‰ã¥Ê±òÊæª¢å°‰¢õÊΩπÊ∫ã°üöÈØ©„öµ§§ØÈÇªÈÇóÂï±‰§ÜÈÜªÈêÑ®©ã‰Å¢®´ºÈêß®∞ù®∞ªËì•Ë®´ÈñôÈñßÈñóÈññ®¥¥ÁëÖ„ªÇ§£ø§©Ç§è™„ªß£à•Èöè®ªß®π¶®π•„ªå§ß≠§©∏£øÆÁêíÁë´„ªºÈùÅ©Ç∞"],["9640","Ê°á‰®ù©Çì•üüÈùùÈç®®¶â®∞¶®¨Ø¶éæÈä∫Â¨ëË≠©‰§ºÁèπ§àõÈûõÈù±È§∏†º¶Â∑Å®ØÖ§™≤È†ü©ìöÈã∂©óóÈá•‰ìÄ®≠ê§©ß®≠§È£ú®©Ö„ºÄÈà™‰§•ËêîÈ§ªÈ•çß¨Ü„∑ΩÈ¶õ‰≠ØÈ¶™È©ú®≠••£àÊ™èÈ®°Â´æÈ®Ø©£±‰Æê©•àÈ¶º‰ÆΩ‰ÆóÈçΩÂ°≤°åÇÂ†¢§¶∏"],["96a1","°ì®Á°Ñ¢úü£∂∏Ê£Ö„µΩÈëò„§ßÊÖê¢ûÅ¢•´ÊÑáÈ±èÈ±ìÈ±ªÈ∞µÈ∞êÈ≠øÈØè©∏≠ÈÆü™áµ™ÉæÈ¥°‰≤Æ§ÑÑÈ∏ò‰≤∞È¥å™Ü¥™É≠™É≥©§ØÈ∂•ËíΩ¶∏í¶øü¶ÆÇËóº‰î≥¶∂§¶∫Ñ¶∑∞Ëê†ËóÆ¶∏Ä£üó¶Å§Áß¢£ñú£ôÄ‰§≠§ßû„µ¢ÈèõÈäæÈçà†äøÁ¢πÈâ∑Èëç‰ø§„ëÄÈÅ§•ïùÁ†ΩÁ°îÁ¢∂Á°ã°ùó£áâ§•Å„öö‰Ω≤ÊøöÊøôÁÄûÁÄûÂêî§ÜµÂûªÂ£≥ÂûäÈ¥ñÂüóÁÑ¥„íØ§Ü¨Áá´¶±Ä§æóÂ¨®°ûµ®©â"],["9740","ÊÑåÂ´éÂ®ã‰äº§íà„ú¨‰≠ª®ßºÈéªÈé∏°£ñ†ºùËë≤¶≥Ä°êì§ã∫¢∞¶§èÅÂ¶î£∂∑¶ùÅÁ∂®¶Öõ¶Ç§§¶π§¶ã®ß∫Èã•Áè¢„ª©Áí¥®≠£°¢ü„ª°§™≥Ê´òÁè≥Áèª„ªñ§®æ§™î°üô§©¶†éß°ê§§ß•Áëà§§ñÁÇ•§•∂ÈäÑÁè¶Èçü†ìæÈå±®´é®®ñÈéÜ®Øß•óï‰§µ®™ÇÁÖ´"],["97a1","§•É†≥øÂö§†òö†Ø´†≤∏ÂîÇÁßÑ°ü∫Á∑æ°õÇ§©ê°°í‰îÆÈêÅ„úä®´Ä§¶≠Â¶∞°¢ø°¢ÉßíÑÂ™°„õ¢£µõ„ö∞ÈâüÂ©π®™Å°°¢Èç¥„≥ç†™¥‰™ñ„¶äÂÉ¥„µ©„µå°éúÁÖµ‰ãª®àòÊ∏è©É§‰ì´ÊµóßπèÁÅßÊ≤Ø„≥ñ£ø≠£∏≠Ê∏ÇÊºå„µØ†èµÁïë„öº„ìà‰öÄ„ªö‰°±ÂßÑÈâÆ‰§æËΩÅ®∞ú¶ØÄÂ†íÂüà„õñ°ëíÁÉæ§ç¢§©±¢ø£°ä∞¢éΩÊ¢πÊ•ß°éò£ì•ßØ¥£õü®™É£üñ£è∫§≤üÊ®ö£ö≠¶≤∑Ëêæ‰ìü‰ìé"],["9840","¶¥¶¶µë¶≤Ç¶øûÊºóßÑâËåΩ°ú∫Ëè≠¶≤ÄßÅì°üõÂ¶âÂ™Ç°û≥Â©°Â©±°§Ö§áº„ú≠ÂßØ°úº„õáÁÜéÈéêÊöö§ä•Â©ÆÂ®´§äìÊ®´£ªπßú∂§ëõ§ãäÁÑù§âô®ß°‰æ∞¶¥®Â≥Ç§ìéßπç§éΩÊ®å§âñ°åÑÁÇ¶ÁÑ≥§è©„∂•Ê≥üØ†•§©èÁπ•Âß´Â¥Ø„∑≥ÂΩú§©ù°üüÁ∂§Ëê¶"],["98a1","ÂíÖ£´∫£åÄ†àîÂùæ†£ï†òô„ø•°æû™ä∂ÁÄÉ©ÖõÂµ∞ÁéèÁ≥ì®©ô©ê†‰øàÁøßÁãçÁåêß´¥Áå∏Áåπ•õ∂ÁçÅÁçà„∫©ß¨òÈÅ¨Ááµ§£≤Áè°Ëá∂„ªäÁúå„ªëÊ≤¢ÂõΩÁêôÁêûÁêü„ª¢„ª∞„ª¥„ª∫Áìì„ºé„ΩìÁïÇÁï≠Áï≤Áñç„ΩºÁóàÁóú„øÄÁôç„øóÁô¥„øúÁô∫§ΩúÁÜàÂò£Ë¶ÄÂ°©‰ÄùÁùÉ‰ÄπÊù°‰ÅÖ„óõÁûò‰Å™‰ÅØÂ±ûÁûæÁüãÂ£≤Á†òÁÇπÁ†ú‰Ç®Á†πÁ°áÁ°ëÁ°¶Ëëà•îµÁ§≥Ê†ÉÁ§≤‰ÑÉ"],["9940","‰ÑâÁ¶ëÁ¶ôËæªÁ®ÜËæº‰ÖßÁ™ë‰Ü≤Á™ºËâπ‰áÑÁ´èÁ´õ‰áè‰∏°Á≠¢Á≠¨Á≠ªÁ∞íÁ∞õ‰â†‰â∫Á±ªÁ≤ú‰äåÁ≤∏‰äîÁ≥≠ËæìÁÉÄ†≥èÁ∑èÁ∑îÁ∑êÁ∑ΩÁæÆÁæ¥Áäü‰éóËÄ†ËÄ•Á¨πËÄÆËÄ±ËÅî„∑åÂû¥ÁÇ†ËÇ∑ËÉ©‰è≠ËÑåÁå™ËÑéËÑíÁï†ËÑî‰êÅ„¨πËÖñËÖôËÖö"],["99a1","‰êìÂ†∫ËÖºËÜÑ‰ê•ËÜì‰ê≠ËÜ•ÂüØËáÅËá§Ëâî‰íèËä¶Ëâ∂ËãäËãòËãø‰í∞ËçóÈô©Ê¶äËêÖÁÉµËë§ÊÉ£Ëíà‰îÑËíæËì°Ëì∏ËîêËî∏Ëïí‰îªËïØËï∞Ëó†‰ï∑Ëô≤ËöíËö≤ËõØÈôÖËûã‰òÜ‰òóË¢ÆË£øË§§Ë•áË¶ëß•ßË®©Ë®∏Ë™îË™¥Ë±ëË≥îË≥≤Ë¥ú‰ûòÂ°üË∑É‰ü≠‰ªÆË∏∫ÂóòÂùîËπ±ÂóµË∫∞‰†∑ËªéËª¢Ëª§Ëª≠Ëª≤Ëæ∑ËøÅËøäËøåÈÄ≥ÈßÑ‰¢≠È£†Èàì‰§ûÈà®ÈâòÈâ´Èä±ÈäÆÈäø"],["9a40","Èã£Èã´Èã≥Èã¥ÈãΩÈçÉÈéÑÈé≠‰•Ö‰•ëÈ∫øÈêóÂåÅÈêùÈê≠Èêæ‰•™ÈëîÈëπÈî≠Èñ¢‰¶ßÈó¥Èò≥‰ß•Êû†‰®§ÈùÄ‰®µÈû≤ÈüÇÂôî‰´§ÊÉ®È¢π‰¨ôÈ£±Â°ÑÈ§éÈ§ôÂÜ¥È§úÈ§∑È•ÇÈ•ùÈ•¢‰≠∞ÈßÖ‰ÆùÈ®ºÈ¨èÁ™ÉÈ≠©ÈÆÅÈØùÈØ±ÈØ¥‰±≠È∞†„ùØ°ØÇÈµâÈ∞∫"],["9aa1","ÈªæÂôêÈ∂ìÈ∂ΩÈ∑ÄÈ∑ºÈì∂Ëæ∂ÈπªÈ∫¨È∫±È∫ΩÈªÜÈìúÈª¢Èª±Èª∏Á´àÈΩÑ†Çî†ä∑†é†Ê§öÈìÉÂ¶¨†ìóÂ°ÄÈìÅ„ûπ†óï†òï†ô∂°ö∫ÂùóÁÖ≥†´Ç†´ç†ÆøÂë™Ø†ª†ØãÂíû†Øª†∞ª†±ì†±•†±ºÊÉß†≤çÂô∫†≤µ†≥ù†≥≠†µØ†∂≤†∑àÊ•ïÈ∞ØËû•†∏Ñ†∏é†ªó†æê†º≠†π≥Â∞††æºÂ∏ã°Åú°Åè°Å∂Êúû°Åª°Çà°Çñ„ôá°Çø°Éì°ÑØ°ÑªÂç§Ëí≠°ã£°çµ°å∂ËÆÅ°ï∑°òô°üÉ°üá‰π∏ÁÇª°†≠°•™"],["9b40","°®≠°©Ö°∞™°±∞°≤¨°ªàÊãÉ°ªï°ºïÁÜòÊ°ï¢ÅÖÊß©„õà¢âº¢èó¢è∫¢ú™¢°±¢•èËãΩ¢•ß¢¶ì¢´ïË¶•¢´®Ëæ†¢¨éÈû∏¢¨øÈ°áÈ™Ω¢±å"],["9b62","¢≤à¢≤∑•Ø®¢¥à¢¥í¢∂∑¢∂ï¢πÇ¢Ω¥¢øå£Ä≥£Å¶£åü£èûÂæ±ÊôàÊöøß©π£ïß£ó≥ÁàÅ§¶∫Áüó£òö£úñÁ∫á†çÜÂ¢µÊúé"],["9ba1","Ê§ò£™ßßôó•ø¢£∏ë£∫πßóæ¢Çö‰£ê‰™∏§Ñô®™ö§ãÆ§åç§Äª§å¥§éñ§©Ö†óäÂáí†òëÂ¶ü°∫®„Ææ£≥ø§êÑ§ìñÂûà§ô¥„¶õ§úØ®ó®©ßâ„ù¢¢áÉË≠û®≠éÈßñ§†í§£ª§®ïÁàâ§´Ä†±∏Â••§∫•§æÜ†ùπËªö•Ä¨ÂäèÂúøÁÖ±•äô•êô£Ωä§™ßÂñº•ëÜ•ëÆ¶≠íÈáî„ë≥•îøßò≤•ïû‰úò•ï¢•ï¶•üá§§ø•°ùÂÅ¶„ìª£èåÊÉû•§É‰ùº®•à•™Æ•Æâ•∞Ü°∂êÂû°ÁÖëÊæ∂¶ÑÇß∞íÈÅñ¶Ü≤§æöË≠¢¶êÇ¶ëä"],["9c40","Âµõ¶Ø∑Ëº∂¶íÑ°§úË´™§ß∂¶íà£øØ¶îí‰ØÄ¶ñø¶öµ¢úõÈë••ü°ÊÜïÂ®ßØ£ç‰æªÂöπ§î°¶õº‰π™§§¥ÈôñÊ∂è¶≤Ω„òòË•∑¶ûô¶°Æ¶êë¶°ûÁáü¶£áÁ≠Ç©ÉÄ†®ë¶§¶ÈÑÑ¶§πÁ©ÖÈ∑∞¶ß∫È®¶¶®≠„ôü¶ë©†Ä°Á¶É¶®¥¶≠õÂ¥¨£îôËèè¶Æù‰õê¶≤§ÁîªË°•¶∂ÆÂ¢∂"],["9ca1","„úú¢ñçßÅãßáç„±îßäÄßäÖÈäÅ¢Ö∫ßäãÈå∞ßã¶§ßêÊ∞πÈíüßëê†ª∏Ë†ßË£µ¢§¶®ë≥°û±Ê∫∏§®™°††„¶§„öπÂ∞êÁß£‰îøÊö∂©≤≠©¢§Ë•Éßüåß°òÂõñ‰Éü°òä„¶°£úØ®É®°èÖÁÜ≠Ëç¶ßßù©Ü®Â©ß‰≤∑ßÇØ®¶´ßßΩß®äß¨ãßµ¶§Ö∫Á≠ÉÁ•æ®ÄâÊæµ™ãüÊ®É®åòÂé¢¶∏áÈéøÊ†∂Èùù®ÖØ®Ä£¶¶µ°è≠£àØ®ÅàÂ∂Ö®∞∞®ÇÉÂúïÈ†£®•âÂ∂´§¶àÊñæÊßïÂèí§™•£æÅ„∞ëÊú∂®Çê®É¥®ÑÆ°æ°®Öè"],["9d40","®Üâ®ÜØ®àö®åÜ®åØ®éä„óä®ë®®ö™‰£∫Êè¶®•ñÁ†àÈâï®¶∏‰è≤®ßß‰èü®ß®®≠Ü®ØîÂß∏®∞âËºã®øÖ©É¨Á≠ë©Ñê©Ñº„∑∑©Öû§´äËøêÁäèÂöã©ìß©ó©©ñ∞©ñ∏©ú≤©£ë©•â©•™©ßÉ©®®©¨é©µö©∂õÁ∫ü©ª∏©º£‰≤§Èïá™äìÁÜ¢™ãø‰∂ëÈÄí™óã‰∂ú†≤úËææÂóÅ"],["9da1","Ëæ∫¢í∞Ëæπ§™ì‰îâÁπøÊΩñÊ™±‰ª™„ì§®¨¨ß¢ù„ú∫Ë∫Ä°üµ®Ä§®≠¨®Æôß®æ¶öØ„∑´ßôï£≤∑•òµ••ñ‰∫ö•∫Å¶âòÂöø†π≠Ë∏éÂ≠≠£∫à§≤ûÊèûÊãê°ü∂°°ªÊî∞Âò≠•±äÂêö•åë„∑Ü©∂ò‰±ΩÂò¢ÂòûÁΩâ•ªòÂ•µ£µÄËù∞‰∏ú†ø™†µâ£ö∫ËÑóÈµûË¥òÁòªÈ±ÖÁôéÁûπÈçÖÂê≤ËÖàËã∑Âò•ËÑ≤ËêòËÇΩÂó™Á•¢ÂôÉÂêñ†∫ù„óéÂòÖÂó±Êõ±®ã¢„ò≠Áî¥Âó∞Âñ∫ÂíóÂï≤†±Å†≤ñÂªê•Öà†π∂¢±¢"],["9e40","†∫¢È∫´ÁµöÂóû°ÅµÊäùÈù≠ÂíîË≥çÁá∂ÈÖ∂ÊèºÊéπÊèæÂï©¢≠ÉÈ±≤¢∫≥ÂÜö„ìü†∂ßÂÜßÂëçÂîûÂîìÁô¶Ë∏≠¶¢äÁñ±ËÇ∂Ë†ÑËûÜË£áËÜ∂Ëêú°ÉÅ‰ì¨ÁåÑ§úÜÂÆêËåã¶¢ìÂôª¢õ¥ß¥Ø§Ü£ßµ≥¶ªêßä∂ÈÖ∞°áôÈàà£≥º™ö©†∫¨†ªπÁâ¶°≤¢‰ùé§øÇßøπ†ø´‰É∫"],["9ea1","È±ùÊîü¢∂†‰£≥§ü†©µº†ø¨†∏äÊÅ¢ßñ£†ø≠"],["9ead","¶Åà°ÜáÁÜ£Á∫éÈµê‰∏ö‰∏Ñ„ï∑Â¨çÊ≤≤Âçß„ö¨„ßúÂçΩ„ö•§òòÂ¢ö§≠ÆËà≠ÂëãÂû™•™ï†•π"],["9ec5","„©í¢ë•Áç¥©∫¨‰¥âÈØ≠£≥æ©º∞‰±õ§æ©©ñû©øûËëú£∂∂ßä≤¶û≥£ú†ÊåÆÁ¥•£ª∑£∏¨„®™ÈÄàÂãå„π¥„ô∫‰ó©†íéÁôÄÂ´∞†∫∂Á°∫ßºÆÂ¢ß‰ÇøÂôºÈÆãÂµ¥Áôî™ê¥È∫Ö‰≥°Áóπ„üªÊÑô£Éö§è≤"],["9ef5","Âôù°ä©Âûß§•£©∏ÜÂà¥ßÇÆ„ñ≠Ê±äÈµº"],["9f40","Á±ñÈ¨πÂüû°ù¨Â±ìÊìì©ìê¶åµßÖ§Ëö≠†¥®¶¥¢§´¢†µ±"],["9f4f","Âáæ°ºèÂ∂éÈúÉ°∑ëÈ∫ÅÈÅåÁ¨üÈ¨ÇÂ≥ëÁÆ£Êâ®ÊåµÈ´øÁØèÈ¨™Á±æÈ¨ÆÁ±ÇÁ≤ÜÈ∞ïÁØºÈ¨âÈºóÈ∞õ§§æÈΩöÂï≥ÂØÉ‰øΩÈ∫ò‰ø≤Ââ†„∏ÜÂãëÂùßÂÅñÂ¶∑Â∏íÈüàÈ∂´ËΩúÂë©Èû¥È•ÄÈû∫Âå¨ÊÑ∞"],["9fa1","Ê§¨ÂèöÈ∞äÈ¥Ç‰∞ªÈôÅÊ¶ÄÂÇ¶ÁïÜ°ù≠ÈßöÂâ≥"],["9fae","ÈÖôÈöÅÈÖú"],["9fb2","ÈÖë®∫óÊçø¶¥£Ê´äÂòëÈÜéÁï∫ÊäÖ†èºÁçèÁ±∞•∞°£≥Ω"],["9fc1","§§ôÁõñÈÆù‰∏™†≥îËéæË°Ç"],["9fc9","Â±äÊßÄÂÉ≠Âù∫ÂàüÂ∑µ‰ªéÊ∞±†á≤‰ºπÂíúÂìöÂäöË∂Ç„óæÂºå„ó≥"],["9fdb","Ê≠íÈÖºÈæ•ÈÆóÈ†ÆÈ¢¥È™∫È∫®È∫ÑÁÖ∫Á¨î"],["9fe7","ÊØ∫Ë†òÁΩ∏"],["9feb","Âò†™ôäËπ∑ÈΩì"],["9ff0","Ë∑îËπèÈ∏úË∏ÅÊäÇ®çΩË∏®ËπµÁ´ì§©∑Á®æÁ£òÊ≥™Ë©ßÁòá"],["a040","®©öÈº¶Ê≥éËüñÁóÉ™ä≤Á°ìØ°ÄË¥åÁã¢Áç±Ë¨≠ÁåÇÁì±Ë≥´§™ªËòØÂæ∫Ë¢†‰í∑"],["a055","°†ª¶∏Ö"],["a058","Ë©æ¢îõ"],["a05b","ÊÉΩÁôßÈ´óÈµÑÈçÆÈÆèËüµ"],["a063","Ë†èË≥∑Áå¨Èú°ÈÆ∞„óñÁä≤‰∞áÁ±ëÈ•ä¶ÖôÊÖô‰∞ÑÈ∫ñÊÖΩ"],["a073","ÂùüÊÖØÊä¶ÊàπÊãé„©úÊá¢Âé™£èµÊç§Ê†Ç„óí"],["a0a1","Âµó®ØÇËøö®∏π"],["a0a6","ÂÉô°µÜÁ§ÜÂå≤Èò∏†ºª‰Å•"],["a0ae","Áüæ"],["a0b0","Á≥Ç•ºöÁ≥öÁ®≠ËÅ¶ËÅ£ÁµçÁîÖÁì≤Ë¶îËàöÊúåËÅ¢ßíÜËÅõÁì∞ËÑÉÁú§Ë¶â¶üåÁïì¶ªëËû©ËüéËáàËûåË©âË≤≠Ë≠ÉÁú´Áì∏Ëìö„òµÊ¶≤Ë∂¶"],["a0d4","Ë¶©Áë®Ê∂πËüÅ§ÄëÁìß„∑õÁÖ∂ÊÇ§ÊÜú„≥ëÁÖ¢ÊÅ∑"],["a0e2","ÁΩ±®¨≠ÁâêÊÉ©‰≠æÂà†„∞ò£≥á•ªóßôñ•î±°•Ñ°ãæ©§É¶∑úßÇ≠Â≥Å¶Ü≠®®è£ô∑†ÉÆ¶°Ü§ºé‰ï¢Â¨ü¶çåÈΩêÈ∫¶¶â´"],["a3c0","‚êÄ",31,"‚ê°"],["c6a1","‚ë†",9,"‚ë¥",9,"‚Ö∞",9,"‰∏∂‰∏ø‰∫Ö‰∫†ÂÜÇÂÜñÂÜ´ÂãπÂå∏Âç©Âé∂Â§äÂÆÄÂ∑õ‚º≥ÂπøÂª¥ÂΩêÂΩ°Êî¥Êó†ÁñíÁô∂ËæµÈö∂¬®ÀÜ„ÉΩ„Éæ„Çù„Çû„ÄÉ‰ªù„ÄÖ„ÄÜ„Äá„ÉºÔºªÔºΩ‚úΩ„ÅÅ",23],["c740","„Åô",58,"„Ç°„Ç¢„Ç£„Ç§"],["c7a1","„Ç•",81,"–ê",5,"–Å–ñ",4],["c840","–õ",26,"—ë–∂",25,"‚áß‚Ü∏‚Üπ„áè†Éå‰πö†ÇäÂàÇ‰íë"],["c8a1","Èæ∞ÂÜàÈæ±ßòá"],["c8cd","Ôø¢Ôø§ÔºáÔºÇ„à±‚Ññ‚Ñ°„Çõ„Çú‚∫Ä‚∫Ñ‚∫Ü‚∫á‚∫à‚∫ä‚∫å‚∫ç‚∫ï‚∫ú‚∫ù‚∫•‚∫ß‚∫™‚∫¨‚∫Æ‚∫∂‚∫º‚∫æ‚ªÜ‚ªä‚ªå‚ªç‚ªè‚ªñ‚ªó‚ªû‚ª£"],["c8f5"," É…ê…õ…î…µ≈ì√∏≈ã ä…™"],["f9fe","Ôø≠"],["fa40","†ïáÈãõ†óü£øÖËïå‰äµÁèØÂÜµ„ôâ§•Ç®ß§ÈçÑ°ßõËãÆ£≥àÁ†ºÊùÑÊãü§§≥®¶™†ä†¶Æ≥°åÖ‰æ´¢ì≠ÂÄà¶¥©ß™Ñ£òÄ§™±¢îìÂÄ©†çæÂæ§†éÄ†çáÊªõ†êüÂÅΩÂÑÅ„ë∫ÂÑéÈ°¨„ùÉËêñ§¶§†íáÂÖ†£é¥ÂÖ™†Øø¢Éº†ã•¢î∞†ñé£à≥°¶ÉÂÆÇËùΩ†ñ≥£≤ôÂÜ≤ÂÜ∏"],["faa1","È¥¥ÂáâÂáèÂáë„≥úÂáì§™¶ÂÜ≥Âá¢ÂçÇÂá≠ËèçÊ§æ£ú≠ÂΩªÂàãÂà¶ÂàºÂäµÂâóÂäîÂäπÂãÖÁ∞ïËïÇÂã†Ëòç¶¨ìÂåÖ®´ûÂïâÊªô£æÄ†•î£ø¨Âå≥ÂçÑ†Ø¢Ê≥ã°ú¶Ê†õÁèïÊÅä„∫™„£å°õ®Ááù‰í¢Âç≠Âç¥®ö´ÂçæÂçø°ññ°òìÁü¶Âéì®™õÂé†Âé´ÂéÆÁéß•ù≤„ΩôÁéúÂèÅÂèÖÊ±â‰πâÂüæÂèô„™´†ÆèÂè†£ø´¢∂£Âè∂†±∑ÂêìÁÅπÂî´ÊôóÊµõÂë≠¶≠ì†µ¥ÂïùÂíèÂí§‰û¶°úç†ªù„∂¥†µç"],["fb40","®¶º¢öòÂïá‰≥≠ÂêØÁêóÂñÜÂñ©ÂòÖ°£ó§Ä∫‰ïí§êµÊö≥°Ç¥Âò∑Êõç£ääÊö§Êö≠ÂôçÂôèÁ£±Âõ±ÈûáÂèæÂúÄÂõØÂõ≠®≠¶„ò£°âèÂùÜ§Ü•Ê±ÆÁÇãÂùÇ„ö±¶±æÂü¶°êñÂ†É°ëî§ç£Â†¶§ØµÂ°úÂ¢™„ï°Â£†Â£ú°àºÂ£ªÂØøÂùÉ™Öê§â∏Èèì„ñ°Â§üÊ¢¶„õÉÊπô"],["fba1","°òæÂ®§Âïì°öíËîÖÂßâ†µé¶≤Å¶¥™°üúÂßô°üª°û≤¶∂¶Êµ±°†®°õïÂßπ¶πÖÂ™´Â©£„õ¶§¶©Â©∑„úàÂ™ñÁë•Â´ì¶æ°¢ïî„∂Ö°§ë„ú≤°ö∏Â∫ÉÂãêÂ≠∂ÊñàÂ≠ºß®é‰ÄÑ‰°ù†àÑÂØïÊÖ†°®¥•ßå†ñ•ÂØ≥ÂÆù‰¥êÂ∞Ö°≠ÑÂ∞ìÁèéÂ∞î°≤•¶¨®Â±â‰£ùÂ≤ÖÂ≥©Â≥ØÂ∂ã°∑π°∏∑Â¥êÂ¥òÂµÜ°∫§Â≤∫Â∑óËãº„†≠§§Å¢Åâ¢Ö≥Ëäá„†∂„ØÇÂ∏ÆÊ™äÂπµÂπ∫§íº†≥ìÂé¶‰∫∑ÂªêÂé®°ù±Â∏âÂª¥®íÇ"],["fc40","ÂªπÂªª„¢†ÂªºÊ†æÈêõÂºç†áÅØ¢î„´û‰¢Æ°å∫Âº∫¶¢à¢èêÂΩò¢ë±ÂΩ£ÈûΩ¶πÆÂΩ≤ÈçÄ®®∂ÂæßÂ∂∂„µü•âê°Ω™ßÉ∏¢ô®Èáñ†äû®®©ÊÄ±ÊöÖ°°∑„•£„∑á„òπÂûê¢û¥Á•±„πÄÊÇûÊÇ§ÊÇ≥§¶Ç§¶èß©ìÁí§ÂÉ°Â™†ÊÖ§Ëê§ÊÖÇØ¢¶¶ªíÊÜÅÂá¥†ôñÊÜáÂÆ™£æ∑"],["fca1","¢°üÊáì®Æù©•ùÊáê„§≤¢¶Ä¢£ÅÊÄ£ÊÖúÊîûÊéã†ÑòÊãÖ°ù∞Êãï¢∏çÊç¨§ßü„®óÊê∏Êè∏°éé°üºÊíêÊæä¢∏∂È†î§Çå•úùÊì°Êì•Èëª„©¶Êê∫„©óÊïçÊºñ§®®§®£ÊñÖÊï≠Êïü£ÅæÊñµ§•Ä‰¨∑Êóë‰Éò°†©Êó†Êó£Âøü£êÄÊòò£á∑£á∏ÊôÑ£Ü§£Ü•Êôã†πµÊôß•á¶Êô≥Êô¥°∏Ω£à±®ó¥£áà•åìÁüÖ¢£∑È¶§ÊúÇ§éú§®°„¨´Êß∫£üÇÊùûÊùßÊù¢§áç©É≠Êüó‰ì©Ê†¢ÊπêÈàºÊ†Å£è¶¶∂†Ê°ù"],["fd40","£ëØÊß°Ê®ã®´üÊ•≥Ê£É£óçÊ§ÅÊ§Ä„¥≤„®Å£òº„ÆÄÊû¨Ê•°®©ä‰ãºÊ§∂Ê¶ò„Æ°†èâËç£ÂÇêÊßπ£ôô¢Ñ™Ê©Ö£úÉÊ™ù„Ø≥Êû±Ê´à©Üú„∞çÊ¨ù†§£ÊÉûÊ¨µÊ≠¥¢üçÊ∫µ£´õ†éµ°•ò„ùÄÂê°£≠öÊØ°£ªºÊØúÊ∞∑¢íã§£±¶≠ëÊ±öËà¶Ê±π£∂º‰ìÖ£∂Ω§Ü§§§å§§Ä"],["fda1","£≥â„õ•„≥´†¥≤ÈÆÉ£áπ¢íëÁæèÊ†∑¶¥•¶∂°¶∑´Ê∂ñÊµúÊπºÊºÑ§•ø§ÇÖ¶π≤Ëî≥¶Ω¥ÂááÊ≤úÊ∏ùËêÆ®¨°Ê∏Ø£∏ØÁëì£æÇÁßåÊπèÂ™ë£ÅãÊø∏„úçÊæù£∏∞Êª∫°íó§ÄΩ‰ïïÈè∞ÊΩÑÊΩú„µéÊΩ¥©Ö∞„¥ªÊæü§ÖÑÊøì§Çë§Öï§Äπ£ø∞£æ¥§ÑøÂáü§Öñ§Öó§ÖÄ¶áùÁÅãÁÅæÁÇßÁÇÅÁÉåÁÉïÁÉñÁÉü‰ÑÑ„∑®ÁÜ¥ÁÜñ§â∑ÁÑ´ÁÖÖÂ™àÁÖäÁÖÆÂ≤ú§ç•ÁÖèÈç¢§ãÅÁÑ¨§ëö§®ß§®¢ÁÜ∫®Ø®ÁÇΩÁàé"],["fe40","ÈëÇÁàïÂ§ëÈëÉÁà§ÈçÅ•òÖÁàÆÁâÄ§•¥Ê¢ΩÁâïÁâó„πï£ÅÑÊ†çÊºΩÁäÇÁå™Áå´§†£®†´‰£≠®†ÑÁå®ÁåÆÁèèÁé™†∞∫¶®ÆÁèâÁëâ§á¢°õß§®§Êò£„õÖ§¶∑§¶ç§ßªÁè∑ÁêïÊ§É§®¶Áêπ†óÉ„ªóÁëú¢¢≠Áë†®∫≤ÁëáÁè§Áë∂ËéπÁë¨„ú∞Áë¥Èè±Ê®¨ÁíÇ‰•ì§™å"],["fea1","§Öü§©π®ÆèÂ≠Ü®∞É°¢ûÁìà°¶àÁîéÁì©Áîû®ªô°©ãÂØó®∫¨ÈéÖÁïçÁïäÁïßÁïÆ§æÇ„ºÑ§¥ìÁñéÁëùÁñûÁñ¥ÁòÇÁò¨ÁôëÁôèÁôØÁô∂¶èµÁöêËáØ„ü∏¶§ë¶§éÁö°Áö•Áö∑Áõå¶æüËë¢•Çù•ÖΩ°∏úÁúûÁú¶ÁùÄÊíØ•à†Áùò£ä¨ÁûØ®•§®•®°õÅÁü¥Á†â°ç∂§®íÊ£äÁ¢ØÁ£áÁ£ìÈö•Á§Æ•ó†Á£óÁ§¥Á¢±ßòåËæ∏Ë¢Ñ®¨´¶ÇÉ¢òúÁ¶ÜË§ÄÊ§ÇÁ¶Ä•°óÁ¶ùß¨πÁ§ºÁ¶©Ê∏™ßÑ¶„∫®ÁßÜ©ÑçÁßî"]]');

/***/ }),

/***/ 82030:
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('[["0","\\u0000",127,"‚Ç¨"],["8140","‰∏Ç‰∏Ñ‰∏Ö‰∏Ü‰∏è‰∏í‰∏ó‰∏ü‰∏†‰∏°‰∏£‰∏¶‰∏©‰∏Æ‰∏Ø‰∏±‰∏≥‰∏µ‰∏∑‰∏º‰πÄ‰πÅ‰πÇ‰πÑ‰πÜ‰πä‰πë‰πï‰πó‰πö‰πõ‰π¢‰π£‰π§‰π•‰πß‰π®‰π™",5,"‰π≤‰π¥",9,"‰πø",6,"‰∫á‰∫ä"],["8180","‰∫ê‰∫ñ‰∫ó‰∫ô‰∫ú‰∫ù‰∫û‰∫£‰∫™‰∫Ø‰∫∞‰∫±‰∫¥‰∫∂‰∫∑‰∫∏‰∫π‰∫º‰∫Ω‰∫æ‰ªà‰ªå‰ªè‰ªê‰ªí‰ªö‰ªõ‰ªú‰ª†‰ª¢‰ª¶‰ªß‰ª©‰ª≠‰ªÆ‰ªØ‰ª±‰ª¥‰ª∏‰ªπ‰ª∫‰ªº‰ªæ‰ºÄ‰ºÇ",6,"‰ºã‰ºå‰ºí",4,"‰ºú‰ºù‰º°‰º£‰º®‰º©‰º¨‰º≠‰ºÆ‰º±‰º≥‰ºµ‰º∑‰ºπ‰ºª‰ºæ",4,"‰ΩÑ‰ΩÖ‰Ωá",5,"‰Ωí‰Ωî‰Ωñ‰Ω°‰Ω¢‰Ω¶‰Ω®‰Ω™‰Ω´‰Ω≠‰ΩÆ‰Ω±‰Ω≤‰Ωµ‰Ω∑‰Ω∏‰Ωπ‰Ω∫‰ΩΩ‰æÄ‰æÅ‰æÇ‰æÖ‰æÜ‰æá‰æä‰æå‰æé‰æê‰æí‰æì‰æï‰æñ‰æò‰æô‰æö‰æú‰æû‰æü‰æ°‰æ¢"],["8240","‰æ§‰æ´‰æ≠‰æ∞",4,"‰æ∂",8,"‰øÄ‰øÅ‰øÇ‰øÜ‰øá‰øà‰øâ‰øã‰øå‰øç‰øí",4,"‰øô‰øõ‰ø†‰ø¢‰ø§‰ø•‰øß‰ø´‰ø¨‰ø∞‰ø≤‰ø¥‰øµ‰ø∂‰ø∑‰øπ‰øª‰øº‰øΩ‰øø",11],["8280","ÂÄãÂÄéÂÄêÂÄëÂÄìÂÄïÂÄñÂÄóÂÄõÂÄùÂÄûÂÄ†ÂÄ¢ÂÄ£ÂÄ§ÂÄßÂÄ´ÂÄØ",10,"ÂÄªÂÄΩÂÄøÂÅÄÂÅÅÂÅÇÂÅÑÂÅÖÂÅÜÂÅâÂÅäÂÅãÂÅçÂÅê",4,"ÂÅñÂÅóÂÅòÂÅôÂÅõÂÅù",7,"ÂÅ¶",5,"ÂÅ≠",8,"ÂÅ∏ÂÅπÂÅ∫ÂÅºÂÅΩÂÇÅÂÇÇÂÇÉÂÇÑÂÇÜÂÇáÂÇâÂÇäÂÇãÂÇåÂÇé",20,"ÂÇ§ÂÇ¶ÂÇ™ÂÇ´ÂÇ≠",4,"ÂÇ≥",6,"ÂÇº"],["8340","ÂÇΩ",17,"ÂÉê",5,"ÂÉóÂÉòÂÉôÂÉõ",10,"ÂÉ®ÂÉ©ÂÉ™ÂÉ´ÂÉØÂÉ∞ÂÉ±ÂÉ≤ÂÉ¥ÂÉ∂",4,"ÂÉº",9,"ÂÑà"],["8380","ÂÑâÂÑäÂÑå",5,"ÂÑì",13,"ÂÑ¢",28,"ÂÖÇÂÖáÂÖäÂÖåÂÖéÂÖèÂÖêÂÖíÂÖìÂÖóÂÖòÂÖôÂÖõÂÖù",4,"ÂÖ£ÂÖ§ÂÖ¶ÂÖßÂÖ©ÂÖ™ÂÖØÂÖ≤ÂÖ∫ÂÖæÂÖøÂÜÉÂÜÑÂÜÜÂÜáÂÜäÂÜãÂÜéÂÜèÂÜêÂÜëÂÜìÂÜîÂÜòÂÜöÂÜùÂÜûÂÜüÂÜ°ÂÜ£ÂÜ¶",4,"ÂÜ≠ÂÜÆÂÜ¥ÂÜ∏ÂÜπÂÜ∫ÂÜæÂÜøÂáÅÂáÇÂáÉÂáÖÂáàÂáäÂáçÂáéÂáêÂáí",5],["8440","ÂáòÂáôÂáöÂáúÂáûÂáüÂá¢Âá£Âá•",5,"Âá¨ÂáÆÂá±Âá≤Âá¥Âá∑ÂáæÂàÑÂàÖÂàâÂàãÂàåÂàèÂàêÂàìÂàîÂàïÂàúÂàûÂàüÂà°Âà¢Âà£Âà•Âà¶ÂàßÂà™Âà¨ÂàØÂà±Âà≤Âà¥ÂàµÂàºÂàæÂâÑ",5,"ÂâãÂâéÂâèÂâíÂâìÂâïÂâóÂâò"],["8480","ÂâôÂâöÂâõÂâùÂâüÂâ†Ââ¢Ââ£Ââ§Ââ¶Ââ®Ââ´Ââ¨Ââ≠ÂâÆÂâ∞Ââ±Ââ≥",9,"ÂâæÂäÄÂäÉ",4,"Âäâ",6,"ÂäëÂäíÂäî",6,"ÂäúÂä§Âä•Âä¶ÂäßÂäÆÂäØÂä∞Âä¥",9,"ÂãÄÂãÅÂãÇÂãÑÂãÖÂãÜÂãàÂãäÂãåÂãçÂãéÂãèÂãëÂãìÂãîÂãïÂãóÂãô",5,"Âã†Âã°Âã¢Âã£Âã•",10,"Âã±",7,"ÂãªÂãºÂãΩÂåÅÂåÇÂåÉÂåÑÂåáÂåâÂåäÂåãÂååÂåé"],["8540","ÂåëÂåíÂåìÂåîÂåòÂåõÂåúÂåûÂåüÂå¢Âå§Âå•ÂåßÂå®Âå©Âå´Âå¨Âå≠ÂåØ",9,"ÂåºÂåΩÂçÄÂçÇÂçÑÂçÜÂçãÂçåÂççÂçêÂçîÂçòÂçôÂçõÂçùÂç•Âç®Âç™Âç¨Âç≠Âç≤Âç∂ÂçπÂçªÂçºÂçΩÂçæÂéÄÂéÅÂéÉÂéáÂéàÂéäÂééÂéè"],["8580","Âéê",4,"ÂéñÂéóÂéôÂéõÂéúÂéûÂé†Âé°Âé§ÂéßÂé™Âé´Âé¨Âé≠ÂéØ",6,"Âé∑Âé∏ÂéπÂé∫ÂéºÂéΩÂéæÂèÄÂèÉ",4,"ÂèéÂèèÂèêÂèíÂèìÂèïÂèöÂèúÂèùÂèûÂè°Âè¢ÂèßÂè¥Âè∫ÂèæÂèøÂêÄÂêÇÂêÖÂêáÂêãÂêîÂêòÂêôÂêöÂêúÂê¢Âê§Âê•Âê™Âê∞Âê≥Âê∂Âê∑Âê∫ÂêΩÂêøÂëÅÂëÇÂëÑÂëÖÂëáÂëâÂëåÂëçÂëéÂëèÂëëÂëöÂëù",4,"Âë£Âë•ÂëßÂë©",7,"Âë¥ÂëπÂë∫ÂëæÂëøÂíÅÂíÉÂíÖÂíáÂíàÂíâÂíäÂíçÂíëÂíìÂíóÂíòÂíúÂíûÂíüÂí†Âí°"],["8640","Âí¢Âí•ÂíÆÂí∞Âí≤ÂíµÂí∂Âí∑ÂíπÂí∫ÂíºÂíæÂìÉÂìÖÂìäÂìãÂìñÂìòÂìõÂì†",4,"Âì´Âì¨ÂìØÂì∞Âì±Âì¥",5,"ÂìªÂìæÂîÄÂîÇÂîÉÂîÑÂîÖÂîàÂîä",4,"ÂîíÂîìÂîï",5,"ÂîúÂîùÂîûÂîüÂî°Âî•Âî¶"],["8680","Âî®Âî©Âî´Âî≠Âî≤Âî¥ÂîµÂî∂Âî∏ÂîπÂî∫ÂîªÂîΩÂïÄÂïÇÂïÖÂïáÂïàÂïã",4,"ÂïëÂïíÂïìÂïîÂïó",4,"ÂïùÂïûÂïüÂï†Âï¢Âï£Âï®Âï©Âï´ÂïØ",5,"ÂïπÂï∫ÂïΩÂïøÂñÖÂñÜÂñåÂñçÂñéÂñêÂñíÂñìÂñïÂññÂñóÂñöÂñõÂñûÂñ†",6,"Âñ®",8,"Âñ≤Âñ¥Âñ∂Âñ∏Âñ∫ÂñºÂñø",4,"ÂóÜÂóáÂóàÂóäÂóãÂóéÂóèÂóêÂóïÂóó",4,"ÂóûÂó†Âó¢ÂóßÂó©Âó≠ÂóÆÂó∞Âó±Âó¥Âó∂Âó∏",4,"ÂóøÂòÇÂòÉÂòÑÂòÖ"],["8740","ÂòÜÂòáÂòäÂòãÂòçÂòê",7,"ÂòôÂòöÂòúÂòùÂò†Âò°Âò¢Âò•Âò¶Âò®Âò©Âò™Âò´ÂòÆÂòØÂò∞Âò≥ÂòµÂò∑Âò∏Âò∫ÂòºÂòΩÂòæÂôÄ",11,"Âôè",4,"ÂôïÂôñÂôöÂôõÂôù",4],["8780","Âô£Âô•Âô¶ÂôßÂô≠ÂôÆÂôØÂô∞Âô≤Âô≥Âô¥ÂôµÂô∑Âô∏ÂôπÂô∫ÂôΩ",7,"Âöá",6,"ÂöêÂöëÂöíÂöî",14,"Âö§",10,"Âö∞",6,"Âö∏ÂöπÂö∫ÂöªÂöΩ",12,"Âõã",8,"ÂõïÂõñÂõòÂõôÂõúÂõ£Âõ•",5,"Âõ¨ÂõÆÂõØÂõ≤Âõ≥Âõ∂Âõ∑Âõ∏ÂõªÂõºÂúÄÂúÅÂúÇÂúÖÂúáÂúã",6],["8840","Âúí",9,"ÂúùÂúûÂú†Âú°Âú¢Âú§Âú•Âú¶ÂúßÂú´Âú±Âú≤Âú¥",4,"ÂúºÂúΩÂúøÂùÅÂùÉÂùÑÂùÖÂùÜÂùàÂùâÂùãÂùí",4,"ÂùòÂùôÂù¢Âù£Âù•ÂùßÂù¨ÂùÆÂù∞Âù±Âù≤Âù¥ÂùµÂù∏ÂùπÂù∫ÂùΩÂùæÂùøÂûÄ"],["8880","ÂûÅÂûáÂûàÂûâÂûäÂûç",4,"Âûî",6,"ÂûúÂûùÂûûÂûüÂû•Âû®Âû™Âû¨ÂûØÂû∞Âû±Âû≥ÂûµÂû∂Âû∑Âûπ",8,"ÂüÑ",6,"ÂüåÂüçÂüêÂüëÂüìÂüñÂüóÂüõÂüúÂüûÂü°Âü¢Âü£Âü•",7,"ÂüÆÂü∞Âü±Âü≤Âü≥ÂüµÂü∂Âü∑ÂüªÂüºÂüæÂüøÂ†ÅÂ†ÉÂ†ÑÂ†ÖÂ†àÂ†âÂ†äÂ†åÂ†éÂ†èÂ†êÂ†íÂ†ìÂ†îÂ†ñÂ†óÂ†òÂ†öÂ†õÂ†úÂ†ùÂ†üÂ†¢Â†£Â†•",4,"Â†´",4,"Â†±Â†≤Â†≥Â†¥Â†∂",7],["8940","Â†æ",5,"Â°Ö",6,"Â°éÂ°èÂ°êÂ°íÂ°ìÂ°ïÂ°ñÂ°óÂ°ô",4,"Â°ü",5,"Â°¶",4,"Â°≠",16,"Â°øÂ¢ÇÂ¢ÑÂ¢ÜÂ¢áÂ¢àÂ¢äÂ¢ãÂ¢å"],["8980","Â¢ç",4,"Â¢î",4,"Â¢õÂ¢úÂ¢ùÂ¢†",7,"Â¢™",17,"Â¢ΩÂ¢æÂ¢øÂ£ÄÂ£ÇÂ£ÉÂ£ÑÂ£Ü",10,"Â£íÂ£ìÂ£îÂ£ñ",13,"Â£•",5,"Â£≠Â£ØÂ£±Â£≤Â£¥Â£µÂ£∑Â£∏Â£∫",7,"Â§ÉÂ§ÖÂ§ÜÂ§à",4,"Â§éÂ§êÂ§ëÂ§íÂ§ìÂ§óÂ§òÂ§õÂ§ùÂ§ûÂ§†Â§°Â§¢Â§£Â§¶Â§®Â§¨Â§∞Â§≤Â§≥Â§µÂ§∂Â§ª"],["8a40","Â§ΩÂ§æÂ§øÂ•ÄÂ•ÉÂ•ÖÂ•ÜÂ•äÂ•åÂ•çÂ•êÂ•íÂ•ìÂ•ôÂ•õ",4,"Â•°Â•£Â•§Â•¶",12,"Â•µÂ•∑Â•∫Â•ªÂ•ºÂ•æÂ•øÂ¶ÄÂ¶ÖÂ¶âÂ¶ãÂ¶åÂ¶éÂ¶èÂ¶êÂ¶ëÂ¶îÂ¶ïÂ¶òÂ¶öÂ¶õÂ¶úÂ¶ùÂ¶üÂ¶†Â¶°Â¶¢Â¶¶"],["8a80","Â¶ßÂ¶¨Â¶≠Â¶∞Â¶±Â¶≥",5,"Â¶∫Â¶ºÂ¶ΩÂ¶ø",6,"ÂßáÂßàÂßâÂßåÂßçÂßéÂßèÂßïÂßñÂßôÂßõÂßû",4,"Âß§Âß¶ÂßßÂß©Âß™Âß´Âß≠",11,"Âß∫ÂßºÂßΩÂßæÂ®ÄÂ®ÇÂ®äÂ®ãÂ®çÂ®éÂ®èÂ®êÂ®íÂ®îÂ®ïÂ®ñÂ®óÂ®ôÂ®öÂ®õÂ®ùÂ®ûÂ®°Â®¢Â®§Â®¶Â®ßÂ®®Â®™",6,"Â®≥Â®µÂ®∑",4,"Â®ΩÂ®æÂ®øÂ©Å",4,"Â©áÂ©àÂ©ã",9,"Â©ñÂ©óÂ©òÂ©ôÂ©õ",5],["8b40","Â©°Â©£Â©§Â©•Â©¶Â©®Â©©Â©´",8,"Â©∏Â©πÂ©ªÂ©ºÂ©ΩÂ©æÂ™Ä",17,"Â™ì",6,"Â™ú",13,"Â™´Â™¨"],["8b80","Â™≠",4,"Â™¥Â™∂Â™∑Â™π",4,"Â™øÂ´ÄÂ´É",5,"Â´äÂ´ãÂ´ç",4,"Â´ìÂ´ïÂ´óÂ´ôÂ´öÂ´õÂ´ùÂ´ûÂ´üÂ´¢Â´§Â´•Â´ßÂ´®Â´™Â´¨",4,"Â´≤",22,"Â¨ä",11,"Â¨ò",25,"Â¨≥Â¨µÂ¨∂Â¨∏",7,"Â≠Å",6],["8c40","Â≠à",7,"Â≠íÂ≠ñÂ≠ûÂ≠†Â≠°Â≠ßÂ≠®Â≠´Â≠≠Â≠ÆÂ≠ØÂ≠≤Â≠¥Â≠∂Â≠∑Â≠∏Â≠πÂ≠ªÂ≠ºÂ≠æÂ≠øÂÆÇÂÆÜÂÆäÂÆçÂÆéÂÆêÂÆëÂÆíÂÆîÂÆñÂÆüÂÆßÂÆ®ÂÆ©ÂÆ¨ÂÆ≠ÂÆÆÂÆØÂÆ±ÂÆ≤ÂÆ∑ÂÆ∫ÂÆªÂÆºÂØÄÂØÅÂØÉÂØàÂØâÂØäÂØãÂØçÂØéÂØè"],["8c80","ÂØëÂØî",8,"ÂØ†ÂØ¢ÂØ£ÂØ¶ÂØßÂØ©",4,"ÂØØÂØ±",6,"ÂØΩÂØæÂ∞ÄÂ∞ÇÂ∞ÉÂ∞ÖÂ∞áÂ∞àÂ∞ãÂ∞åÂ∞çÂ∞éÂ∞êÂ∞íÂ∞ìÂ∞óÂ∞ôÂ∞õÂ∞ûÂ∞üÂ∞†Â∞°Â∞£Â∞¶Â∞®Â∞©Â∞™Â∞´Â∞≠Â∞ÆÂ∞ØÂ∞∞Â∞≤Â∞≥Â∞µÂ∞∂Â∞∑Â±ÉÂ±ÑÂ±ÜÂ±áÂ±åÂ±çÂ±íÂ±ìÂ±îÂ±ñÂ±óÂ±òÂ±öÂ±õÂ±úÂ±ùÂ±üÂ±¢Â±§Â±ß",6,"Â±∞Â±≤",6,"Â±ªÂ±ºÂ±ΩÂ±æÂ≤ÄÂ≤É",4,"Â≤âÂ≤äÂ≤ãÂ≤éÂ≤èÂ≤íÂ≤ìÂ≤ïÂ≤ù",4,"Â≤§",4],["8d40","Â≤™Â≤ÆÂ≤ØÂ≤∞Â≤≤Â≤¥Â≤∂Â≤πÂ≤∫Â≤ªÂ≤ºÂ≤æÂ≥ÄÂ≥ÇÂ≥ÉÂ≥Ö",5,"Â≥å",5,"Â≥ì",5,"Â≥ö",6,"Â≥¢Â≥£Â≥ßÂ≥©Â≥´Â≥¨Â≥ÆÂ≥ØÂ≥±",9,"Â≥º",4],["8d80","Â¥ÅÂ¥ÑÂ¥ÖÂ¥à",5,"Â¥è",4,"Â¥ïÂ¥óÂ¥òÂ¥ôÂ¥öÂ¥úÂ¥ùÂ¥ü",4,"Â¥•Â¥®Â¥™Â¥´Â¥¨Â¥Ø",4,"Â¥µ",7,"Â¥ø",7,"ÂµàÂµâÂµç",10,"ÂµôÂµöÂµúÂµû",10,"Âµ™Âµ≠ÂµÆÂµ∞Âµ±Âµ≤Âµ≥Âµµ",12,"Â∂É",21,"Â∂öÂ∂õÂ∂úÂ∂ûÂ∂üÂ∂†"],["8e40","Â∂°",21,"Â∂∏",12,"Â∑Ü",6,"Â∑é",12,"Â∑úÂ∑üÂ∑†Â∑£Â∑§Â∑™Â∑¨Â∑≠"],["8e80","Â∑∞Â∑µÂ∑∂Â∑∏",4,"Â∑øÂ∏ÄÂ∏ÑÂ∏áÂ∏âÂ∏äÂ∏ãÂ∏çÂ∏éÂ∏íÂ∏ìÂ∏óÂ∏û",7,"Â∏®",4,"Â∏ØÂ∏∞Â∏≤",4,"Â∏πÂ∏∫Â∏æÂ∏øÂπÄÂπÅÂπÉÂπÜ",5,"Âπç",6,"Âπñ",4,"ÂπúÂπùÂπüÂπ†Âπ£",14,"ÂπµÂπ∑ÂππÂπæÂ∫ÅÂ∫ÇÂ∫ÉÂ∫ÖÂ∫àÂ∫âÂ∫åÂ∫çÂ∫éÂ∫íÂ∫òÂ∫õÂ∫ùÂ∫°Â∫¢Â∫£Â∫§Â∫®",4,"Â∫Æ",4,"Â∫¥Â∫∫Â∫ªÂ∫ºÂ∫ΩÂ∫ø",6],["8f40","ÂªÜÂªáÂªàÂªã",5,"ÂªîÂªïÂªóÂªòÂªôÂªöÂªú",11,"Âª©Âª´",8,"ÂªµÂª∏ÂªπÂªªÂªºÂªΩÂºÖÂºÜÂºáÂºâÂºåÂºçÂºéÂºêÂºíÂºîÂºñÂºôÂºöÂºúÂºùÂºûÂº°Âº¢Âº£Âº§"],["8f80","Âº®Âº´Âº¨ÂºÆÂº∞Âº≤",6,"ÂºªÂºΩÂºæÂºøÂΩÅ",14,"ÂΩëÂΩîÂΩôÂΩöÂΩõÂΩúÂΩûÂΩüÂΩ†ÂΩ£ÂΩ•ÂΩßÂΩ®ÂΩ´ÂΩÆÂΩØÂΩ≤ÂΩ¥ÂΩµÂΩ∂ÂΩ∏ÂΩ∫ÂΩΩÂΩæÂΩøÂæÉÂæÜÂæçÂæéÂæèÂæëÂæìÂæîÂæñÂæöÂæõÂæùÂæûÂæüÂæ†Âæ¢",5,"Âæ©Âæ´Âæ¨ÂæØ",5,"Âæ∂Âæ∏ÂæπÂæ∫ÂæªÂææ",4,"ÂøáÂøàÂøäÂøãÂøéÂøìÂøîÂøïÂøöÂøõÂøúÂøûÂøüÂø¢Âø£Âø•Âø¶Âø®Âø©Âø¨ÂøØÂø∞Âø≤Âø≥Âø¥Âø∂Âø∑ÂøπÂø∫ÂøºÊÄá"],["9040","ÊÄàÊÄâÊÄãÊÄåÊÄêÊÄëÊÄìÊÄóÊÄòÊÄöÊÄûÊÄüÊÄ¢ÊÄ£ÊÄ§ÊÄ¨ÊÄ≠ÊÄÆÊÄ∞",4,"ÊÄ∂",4,"ÊÄΩÊÄæÊÅÄÊÅÑ",6,"ÊÅåÊÅéÊÅèÊÅëÊÅìÊÅîÊÅñÊÅóÊÅòÊÅõÊÅúÊÅûÊÅüÊÅ†ÊÅ°ÊÅ•ÊÅ¶ÊÅÆÊÅ±ÊÅ≤ÊÅ¥ÊÅµÊÅ∑ÊÅæÊÇÄ"],["9080","ÊÇÅÊÇÇÊÇÖÊÇÜÊÇáÊÇàÊÇäÊÇãÊÇéÊÇèÊÇêÊÇëÊÇìÊÇïÊÇóÊÇòÊÇôÊÇúÊÇûÊÇ°ÊÇ¢ÊÇ§ÊÇ•ÊÇßÊÇ©ÊÇ™ÊÇÆÊÇ∞ÊÇ≥ÊÇµÊÇ∂ÊÇ∑ÊÇπÊÇ∫ÊÇΩ",7,"ÊÉáÊÉàÊÉâÊÉå",4,"ÊÉíÊÉìÊÉîÊÉñÊÉóÊÉôÊÉõÊÉûÊÉ°",4,"ÊÉ™ÊÉ±ÊÉ≤ÊÉµÊÉ∑ÊÉ∏ÊÉª",4,"ÊÑÇÊÑÉÊÑÑÊÑÖÊÑáÊÑäÊÑãÊÑåÊÑê",4,"ÊÑñÊÑóÊÑòÊÑôÊÑõÊÑúÊÑùÊÑûÊÑ°ÊÑ¢ÊÑ•ÊÑ®ÊÑ©ÊÑ™ÊÑ¨",18,"ÊÖÄ",6],["9140","ÊÖáÊÖâÊÖãÊÖçÊÖèÊÖêÊÖíÊÖìÊÖîÊÖñ",6,"ÊÖûÊÖüÊÖ†ÊÖ°ÊÖ£ÊÖ§ÊÖ•ÊÖ¶ÊÖ©",6,"ÊÖ±ÊÖ≤ÊÖ≥ÊÖ¥ÊÖ∂ÊÖ∏",18,"ÊÜåÊÜçÊÜè",4,"ÊÜï"],["9180","ÊÜñ",6,"ÊÜû",8,"ÊÜ™ÊÜ´ÊÜ≠",9,"ÊÜ∏",5,"ÊÜøÊáÄÊáÅÊáÉ",4,"ÊáâÊáå",4,"ÊáìÊáï",16,"Êáß",13,"Êá∂",8,"ÊàÄ",5,"ÊàáÊàâÊàìÊàîÊàôÊàúÊàùÊàûÊà†Êà£Êà¶ÊàßÊà®Êà©Êà´Êà≠ÊàØÊà∞Êà±Êà≤ÊàµÊà∂Êà∏",4,"ÊâÇÊâÑÊâÖÊâÜÊâä"],["9240","ÊâèÊâêÊâïÊâñÊâóÊâôÊâöÊâú",6,"Êâ§Êâ•Êâ®Êâ±Êâ≤Êâ¥ÊâµÊâ∑Êâ∏Êâ∫ÊâªÊâΩÊäÅÊäÇÊäÉÊäÖÊäÜÊäáÊäàÊäã",5,"ÊäîÊäôÊäúÊäùÊäûÊä£Êä¶ÊäßÊä©Êä™Êä≠ÊäÆÊäØÊä∞Êä≤Êä≥Êä¥Êä∂Êä∑Êä∏Êä∫ÊäæÊãÄÊãÅ"],["9280","ÊãÉÊããÊãèÊãëÊãïÊãùÊãûÊã†Êã°Êã§Êã™Êã´Êã∞Êã≤ÊãµÊã∏ÊãπÊã∫ÊãªÊåÄÊåÉÊåÑÊåÖÊåÜÊåäÊåãÊååÊåçÊåèÊåêÊåíÊåìÊåîÊåïÊåóÊåòÊåôÊåúÊå¶ÊåßÊå©Êå¨Êå≠ÊåÆÊå∞Êå±Êå≥",5,"ÊåªÊåºÊåæÊåøÊçÄÊçÅÊçÑÊçáÊçàÊçäÊçëÊçíÊçìÊçîÊçñ",7,"Êç†Êç§Êç•Êç¶Êç®Êç™Êç´Êç¨ÊçØÊç∞Êç≤Êç≥Êç¥ÊçµÊç∏ÊçπÊçºÊçΩÊçæÊçøÊéÅÊéÉÊéÑÊéÖÊéÜÊéãÊéçÊéëÊéìÊéîÊéïÊéóÊéô",6,"Êé°Êé§Êé¶Êé´ÊéØÊé±Êé≤ÊéµÊé∂ÊéπÊéªÊéΩÊéøÊèÄ"],["9340","ÊèÅÊèÇÊèÉÊèÖÊèáÊèàÊèäÊèãÊèåÊèëÊèìÊèîÊèïÊèó",6,"ÊèüÊè¢Êè§",4,"Êè´Êè¨ÊèÆÊèØÊè∞Êè±Êè≥ÊèµÊè∑ÊèπÊè∫ÊèªÊèºÊèæÊêÉÊêÑÊêÜ",4,"ÊêçÊêéÊêëÊêíÊêï",5,"ÊêùÊêüÊê¢Êê£Êê§"],["9380","Êê•ÊêßÊê®Êê©Êê´ÊêÆ",5,"Êêµ",4,"ÊêªÊêºÊêæÊëÄÊëÇÊëÉÊëâÊëã",6,"ÊëìÊëïÊëñÊëóÊëô",4,"Êëü",7,"Êë®Êë™Êë´Êë¨ÊëÆ",9,"Êëª",6,"ÊíÉÊíÜÊíà",8,"ÊíìÊíîÊíóÊíòÊíöÊíõÊíúÊíùÊíü",4,"Êí•Êí¶ÊíßÊí®Êí™Êí´ÊíØÊí±Êí≤Êí≥Êí¥Êí∂ÊíπÊíªÊíΩÊíæÊíøÊìÅÊìÉÊìÑÊìÜ",6,"ÊìèÊìëÊììÊìîÊìïÊìñÊìôÊìö"],["9440","ÊìõÊìúÊìùÊìüÊì†Êì°Êì£Êì•Êìß",24,"ÊîÅ",7,"Êîä",7,"Êîì",4,"Êîô",8],["9480","Êî¢Êî£Êî§Êî¶",4,"Êî¨Êî≠Êî∞Êî±Êî≤Êî≥Êî∑Êî∫ÊîºÊîΩÊïÄ",4,"ÊïÜÊïáÊïäÊïãÊïçÊïéÊïêÊïíÊïìÊïîÊïóÊïòÊïöÊïúÊïüÊï†Êï°Êï§Êï•ÊïßÊï®Êï©Êï™Êï≠ÊïÆÊïØÊï±Êï≥ÊïµÊï∂Êï∏",14,"ÊñàÊñâÊñäÊñçÊñéÊñèÊñíÊñîÊñïÊññÊñòÊñöÊñùÊñûÊñ†Êñ¢Êñ£Êñ¶Êñ®Êñ™Êñ¨ÊñÆÊñ±",7,"Êñ∫ÊñªÊñæÊñøÊóÄÊóÇÊóáÊóàÊóâÊóäÊóçÊóêÊóëÊóìÊóîÊóïÊóò",7,"Êó°Êó£Êó§Êó™Êó´"],["9540","Êó≤Êó≥Êó¥ÊóµÊó∏ÊóπÊóª",4,"ÊòÅÊòÑÊòÖÊòáÊòàÊòâÊòãÊòçÊòêÊòëÊòíÊòñÊòóÊòòÊòöÊòõÊòúÊòûÊò°Êò¢Êò£Êò§Êò¶Êò©Êò™Êò´Êò¨ÊòÆÊò∞Êò≤Êò≥Êò∑",4,"ÊòΩÊòøÊôÄÊôÇÊôÑ",6,"ÊôçÊôéÊôêÊôëÊôò"],["9580","ÊôôÊôõÊôúÊôùÊôûÊô†Êô¢Êô£Êô•ÊôßÊô©",4,"Êô±Êô≤Êô≥ÊôµÊô∏ÊôπÊôªÊôºÊôΩÊôøÊöÄÊöÅÊöÉÊöÖÊöÜÊöàÊöâÊöäÊöãÊöçÊöéÊöèÊöêÊöíÊöìÊöîÊöïÊöò",4,"Êöû",8,"Êö©",4,"ÊöØ",4,"ÊöµÊö∂Êö∑Êö∏Êö∫ÊöªÊöºÊöΩÊöø",25,"ÊõöÊõû",7,"ÊõßÊõ®Êõ™",5,"Êõ±ÊõµÊõ∂Êõ∏Êõ∫ÊõªÊõΩÊúÅÊúÇÊúÉ"],["9640","ÊúÑÊúÖÊúÜÊúáÊúåÊúéÊúèÊúëÊúíÊúìÊúñÊúòÊúôÊúöÊúúÊúûÊú†",5,"ÊúßÊú©ÊúÆÊú∞Êú≤Êú≥Êú∂Êú∑Êú∏ÊúπÊúªÊúºÊúæÊúøÊùÅÊùÑÊùÖÊùáÊùäÊùãÊùçÊùíÊùîÊùïÊùó",4,"ÊùùÊù¢Êù£Êù§Êù¶ÊùßÊù´Êù¨ÊùÆÊù±Êù¥Êù∂"],["9680","Êù∏ÊùπÊù∫ÊùªÊùΩÊûÄÊûÇÊûÉÊûÖÊûÜÊûàÊûäÊûåÊûçÊûéÊûèÊûëÊûíÊûìÊûîÊûñÊûôÊûõÊûüÊû†Êû°Êû§Êû¶Êû©Êû¨ÊûÆÊû±Êû≤Êû¥Êûπ",7,"ÊüÇÊüÖ",9,"ÊüïÊüñÊüóÊüõÊüüÊü°Êü£Êü§Êü¶ÊüßÊü®Êü™Êü´Êü≠ÊüÆÊü≤Êüµ",7,"ÊüæÊ†ÅÊ†ÇÊ†ÉÊ†ÑÊ†ÜÊ†çÊ†êÊ†íÊ†îÊ†ïÊ†ò",4,"Ê†ûÊ†üÊ††Ê†¢",6,"Ê†´",6,"Ê†¥Ê†µÊ†∂Ê†∫Ê†ªÊ†øÊ°áÊ°ãÊ°çÊ°èÊ°íÊ°ñ",5],["9740","Ê°úÊ°ùÊ°ûÊ°üÊ°™Ê°¨",7,"Ê°µÊ°∏",8,"Ê¢ÇÊ¢ÑÊ¢á",7,"Ê¢êÊ¢ëÊ¢íÊ¢îÊ¢ïÊ¢ñÊ¢ò",9,"Ê¢£Ê¢§Ê¢•Ê¢©Ê¢™Ê¢´Ê¢¨Ê¢ÆÊ¢±Ê¢≤Ê¢¥Ê¢∂Ê¢∑Ê¢∏"],["9780","Ê¢π",6,"Ê£ÅÊ£É",5,"Ê£äÊ£åÊ£éÊ£èÊ£êÊ£ëÊ£ìÊ£îÊ£ñÊ£óÊ£ôÊ£õ",4,"Ê£°Ê£¢Ê£§",9,"Ê£ØÊ£≤Ê£≥Ê£¥Ê£∂Ê£∑Ê£∏Ê£ªÊ£ΩÊ£æÊ£øÊ§ÄÊ§ÇÊ§ÉÊ§ÑÊ§Ü",4,"Ê§åÊ§èÊ§ëÊ§ì",11,"Ê§°Ê§¢Ê§£Ê§•",7,"Ê§ÆÊ§ØÊ§±Ê§≤Ê§≥Ê§µÊ§∂Ê§∑Ê§∏Ê§∫Ê§ªÊ§ºÊ§æÊ•ÄÊ•ÅÊ•É",16,"Ê•ïÊ•ñÊ•òÊ•ôÊ•õÊ•úÊ•ü"],["9840","Ê•°Ê•¢Ê•§Ê••Ê•ßÊ•®Ê•©Ê•™Ê•¨Ê•≠Ê•ØÊ•∞Ê•≤",4,"Ê•∫Ê•ªÊ•ΩÊ•æÊ•øÊ¶ÅÊ¶ÉÊ¶ÖÊ¶äÊ¶ãÊ¶åÊ¶é",5,"Ê¶ñÊ¶óÊ¶ôÊ¶öÊ¶ù",9,"Ê¶©Ê¶™Ê¶¨Ê¶ÆÊ¶ØÊ¶∞Ê¶≤Ê¶≥Ê¶µÊ¶∂Ê¶∏Ê¶πÊ¶∫Ê¶ºÊ¶Ω"],["9880","Ê¶æÊ¶øÊßÄÊßÇ",7,"ÊßãÊßçÊßèÊßëÊßíÊßìÊßï",5,"ÊßúÊßùÊßûÊß°",11,"ÊßÆÊßØÊß∞Êß±Êß≥",9,"ÊßæÊ®Ä",9,"Ê®ã",11,"Ê®ô",5,"Ê®†Ê®¢",5,"Ê®©Ê®´Ê®¨Ê®≠Ê®ÆÊ®∞Ê®≤Ê®≥Ê®¥Ê®∂",6,"Ê®ø",4,"Ê©ÖÊ©ÜÊ©à",7,"Ê©ë",6,"Ê©ö"],["9940","Ê©ú",4,"Ê©¢Ê©£Ê©§Ê©¶",10,"Ê©≤",6,"Ê©∫Ê©ªÊ©ΩÊ©æÊ©øÊ™ÅÊ™ÇÊ™ÉÊ™Ö",8,"Ê™èÊ™í",4,"Ê™ò",7,"Ê™°",5],["9980","Ê™ßÊ™®Ê™™Ê™≠",114,"Ê¨•Ê¨¶Ê¨®",6],["9a40","Ê¨ØÊ¨∞Ê¨±Ê¨≥Ê¨¥Ê¨µÊ¨∂Ê¨∏Ê¨ªÊ¨ºÊ¨ΩÊ¨øÊ≠ÄÊ≠ÅÊ≠ÇÊ≠ÑÊ≠ÖÊ≠àÊ≠äÊ≠ãÊ≠ç",11,"Ê≠ö",7,"Ê≠®Ê≠©Ê≠´",13,"Ê≠∫Ê≠ΩÊ≠æÊ≠øÊÆÄÊÆÖÊÆà"],["9a80","ÊÆåÊÆéÊÆèÊÆêÊÆëÊÆîÊÆïÊÆóÊÆòÊÆôÊÆú",4,"ÊÆ¢",7,"ÊÆ´",7,"ÊÆ∂ÊÆ∏",6,"ÊØÄÊØÉÊØÑÊØÜ",4,"ÊØåÊØéÊØêÊØëÊØòÊØöÊØú",4,"ÊØ¢",7,"ÊØ¨ÊØ≠ÊØÆÊØ∞ÊØ±ÊØ≤ÊØ¥ÊØ∂ÊØ∑ÊØ∏ÊØ∫ÊØªÊØºÊØæ",6,"Ê∞à",4,"Ê∞éÊ∞íÊ∞óÊ∞úÊ∞ùÊ∞ûÊ∞†Ê∞£Ê∞•Ê∞´Ê∞¨Ê∞≠Ê∞±Ê∞≥Ê∞∂Ê∞∑Ê∞πÊ∞∫Ê∞ªÊ∞ºÊ∞æÊ∞øÊ±ÉÊ±ÑÊ±ÖÊ±àÊ±ã",4,"Ê±ëÊ±íÊ±ìÊ±ñÊ±ò"],["9b40","Ê±ôÊ±öÊ±¢Ê±£Ê±•Ê±¶Ê±ßÊ±´",4,"Ê±±Ê±≥Ê±µÊ±∑Ê±∏Ê±∫Ê±ªÊ±ºÊ±øÊ≤ÄÊ≤ÑÊ≤áÊ≤äÊ≤ãÊ≤çÊ≤éÊ≤ëÊ≤íÊ≤ïÊ≤ñÊ≤óÊ≤òÊ≤öÊ≤úÊ≤ùÊ≤ûÊ≤†Ê≤¢Ê≤®Ê≤¨Ê≤ØÊ≤∞Ê≤¥Ê≤µÊ≤∂Ê≤∑Ê≤∫Ê≥ÄÊ≥ÅÊ≥ÇÊ≥ÉÊ≥ÜÊ≥áÊ≥àÊ≥ãÊ≥çÊ≥éÊ≥èÊ≥ëÊ≥íÊ≥ò"],["9b80","Ê≥ôÊ≥öÊ≥úÊ≥ùÊ≥üÊ≥§Ê≥¶Ê≥ßÊ≥©Ê≥¨Ê≥≠Ê≥≤Ê≥¥Ê≥πÊ≥øÊ¥ÄÊ¥ÇÊ¥ÉÊ¥ÖÊ¥ÜÊ¥àÊ¥âÊ¥äÊ¥çÊ¥èÊ¥êÊ¥ëÊ¥ìÊ¥îÊ¥ïÊ¥ñÊ¥òÊ¥úÊ¥ùÊ¥ü",5,"Ê¥¶Ê¥®Ê¥©Ê¥¨Ê¥≠Ê¥ØÊ¥∞Ê¥¥Ê¥∂Ê¥∑Ê¥∏Ê¥∫Ê¥øÊµÄÊµÇÊµÑÊµâÊµåÊµêÊµïÊµñÊµóÊµòÊµõÊµùÊµüÊµ°Êµ¢Êµ§Êµ•ÊµßÊµ®Êµ´Êµ¨Êµ≠Êµ∞Êµ±Êµ≤Êµ≥ÊµµÊµ∂ÊµπÊµ∫ÊµªÊµΩ",4,"Ê∂ÉÊ∂ÑÊ∂ÜÊ∂áÊ∂äÊ∂ãÊ∂çÊ∂èÊ∂êÊ∂íÊ∂ñ",4,"Ê∂úÊ∂¢Ê∂•Ê∂¨Ê∂≠Ê∂∞Ê∂±Ê∂≥Ê∂¥Ê∂∂Ê∂∑Ê∂π",5,"Ê∑ÅÊ∑ÇÊ∑ÉÊ∑àÊ∑âÊ∑ä"],["9c40","Ê∑çÊ∑éÊ∑èÊ∑êÊ∑íÊ∑ìÊ∑îÊ∑ïÊ∑óÊ∑öÊ∑õÊ∑úÊ∑üÊ∑¢Ê∑£Ê∑•Ê∑ßÊ∑®Ê∑©Ê∑™Ê∑≠Ê∑ØÊ∑∞Ê∑≤Ê∑¥Ê∑µÊ∑∂Ê∑∏Ê∑∫Ê∑Ω",7,"Ê∏ÜÊ∏áÊ∏àÊ∏âÊ∏ãÊ∏èÊ∏íÊ∏ìÊ∏ïÊ∏òÊ∏ôÊ∏õÊ∏úÊ∏ûÊ∏üÊ∏¢Ê∏¶Ê∏ßÊ∏®Ê∏™Ê∏¨Ê∏ÆÊ∏∞Ê∏±Ê∏≥Ê∏µ"],["9c80","Ê∏∂Ê∏∑Ê∏πÊ∏ª",7,"ÊπÖ",7,"ÊπèÊπêÊπëÊπíÊπïÊπóÊπôÊπöÊπúÊπùÊπûÊπ†",10,"Êπ¨Êπ≠ÊπØ",14,"Ê∫ÄÊ∫ÅÊ∫ÇÊ∫ÑÊ∫áÊ∫àÊ∫ä",4,"Ê∫ë",6,"Ê∫ôÊ∫öÊ∫õÊ∫ùÊ∫ûÊ∫†Ê∫°Ê∫£Ê∫§Ê∫¶Ê∫®Ê∫©Ê∫´Ê∫¨Ê∫≠Ê∫ÆÊ∫∞Ê∫≥Ê∫µÊ∫∏Ê∫πÊ∫ºÊ∫æÊ∫øÊªÄÊªÉÊªÑÊªÖÊªÜÊªàÊªâÊªäÊªåÊªçÊªéÊªêÊªíÊªñÊªòÊªôÊªõÊªúÊªùÊª£ÊªßÊª™",5],["9d40","Êª∞Êª±Êª≤Êª≥ÊªµÊª∂Êª∑Êª∏Êª∫",7,"ÊºÉÊºÑÊºÖÊºáÊºàÊºä",4,"ÊºêÊºëÊºíÊºñ",9,"Êº°Êº¢Êº£Êº•Êº¶ÊºßÊº®Êº¨ÊºÆÊº∞Êº≤Êº¥ÊºµÊº∑",6,"ÊºøÊΩÄÊΩÅÊΩÇ"],["9d80","ÊΩÉÊΩÑÊΩÖÊΩàÊΩâÊΩäÊΩåÊΩé",9,"ÊΩôÊΩöÊΩõÊΩùÊΩüÊΩ†ÊΩ°ÊΩ£ÊΩ§ÊΩ•ÊΩß",5,"ÊΩØÊΩ∞ÊΩ±ÊΩ≥ÊΩµÊΩ∂ÊΩ∑ÊΩπÊΩªÊΩΩ",6,"ÊæÖÊæÜÊæáÊæäÊæãÊæè",12,"ÊæùÊæûÊæüÊæ†Êæ¢",4,"Êæ®",10,"Êæ¥ÊæµÊæ∑Êæ∏Êæ∫",5,"ÊøÅÊøÉ",5,"Êøä",6,"Êøì",10,"ÊøüÊø¢Êø£Êø§Êø•"],["9e40","Êø¶",7,"Êø∞",32,"ÁÄí",7,"ÁÄú",6,"ÁÄ§",6],["9e80","ÁÄ´",9,"ÁÄ∂ÁÄ∑ÁÄ∏ÁÄ∫",17,"ÁÅçÁÅéÁÅê",13,"ÁÅü",11,"ÁÅÆÁÅ±ÁÅ≤ÁÅ≥ÁÅ¥ÁÅ∑ÁÅπÁÅ∫ÁÅªÁÅΩÁÇÅÁÇÇÁÇÉÁÇÑÁÇÜÁÇáÁÇàÁÇãÁÇåÁÇçÁÇèÁÇêÁÇëÁÇìÁÇóÁÇòÁÇöÁÇõÁÇû",12,"ÁÇ∞ÁÇ≤ÁÇ¥ÁÇµÁÇ∂ÁÇ∫ÁÇæÁÇøÁÉÑÁÉÖÁÉÜÁÉáÁÉâÁÉã",12,"ÁÉö"],["9f40","ÁÉúÁÉùÁÉûÁÉ†ÁÉ°ÁÉ¢ÁÉ£ÁÉ•ÁÉ™ÁÉÆÁÉ∞",6,"ÁÉ∏ÁÉ∫ÁÉªÁÉºÁÉæ",10,"ÁÑã",4,"ÁÑëÁÑíÁÑîÁÑóÁÑõ",10,"ÁÑß",7,"ÁÑ≤ÁÑ≥ÁÑ¥"],["9f80","ÁÑµÁÑ∑",13,"ÁÖÜÁÖáÁÖàÁÖâÁÖãÁÖçÁÖè",12,"ÁÖùÁÖü",4,"ÁÖ•ÁÖ©",4,"ÁÖØÁÖ∞ÁÖ±ÁÖ¥ÁÖµÁÖ∂ÁÖ∑ÁÖπÁÖªÁÖºÁÖæ",5,"ÁÜÖ",4,"ÁÜãÁÜåÁÜçÁÜéÁÜêÁÜëÁÜíÁÜìÁÜïÁÜñÁÜóÁÜö",4,"ÁÜ°",6,"ÁÜ©ÁÜ™ÁÜ´ÁÜ≠",5,"ÁÜ¥ÁÜ∂ÁÜ∑ÁÜ∏ÁÜ∫",8,"ÁáÑ",9,"Ááè",4],["a040","Ááñ",9,"Áá°Áá¢Áá£Áá§Áá¶Áá®",5,"ÁáØ",9,"Áá∫",11,"Áàá",19],["a080","ÁàõÁàúÁàû",9,"Áà©Áà´Áà≠ÁàÆÁàØÁà≤Áà≥Áà¥Áà∫ÁàºÁàæÁâÄ",6,"ÁââÁâäÁâãÁâéÁâèÁâêÁâëÁâìÁâîÁâïÁâóÁâòÁâöÁâúÁâûÁâ†Áâ£Áâ§Áâ•Áâ®Áâ™Áâ´Áâ¨Áâ≠Áâ∞Áâ±Áâ≥Áâ¥Áâ∂Áâ∑Áâ∏ÁâªÁâºÁâΩÁäÇÁäÉÁäÖ",4,"ÁäåÁäéÁäêÁäëÁäì",11,"Áä†",11,"ÁäÆÁä±Áä≤Áä≥ÁäµÁä∫",6,"ÁãÖÁãÜÁãáÁãâÁãäÁããÁãåÁãèÁãëÁãìÁãîÁãïÁãñÁãòÁãöÁãõ"],["a1a1","„ÄÄ„ÄÅ„ÄÇ¬∑ÀâÀá¬®„ÄÉ„ÄÖ‚ÄîÔΩû‚Äñ‚Ä¶‚Äò‚Äô‚Äú‚Äù„Äî„Äï„Äà",7,"„Äñ„Äó„Äê„Äë¬±√ó√∑‚à∂‚àß‚à®‚àë‚àè‚à™‚à©‚àà‚à∑‚àö‚ä•‚à•‚à†‚åí‚äô‚à´‚àÆ‚â°‚âå‚âà‚àΩ‚àù‚â†‚âÆ‚âØ‚â§‚â•‚àû‚àµ‚à¥‚ôÇ‚ôÄ¬∞‚Ä≤‚Ä≥‚ÑÉÔºÑ¬§Ôø†Ôø°‚Ä∞¬ß‚Ññ‚òÜ‚òÖ‚óã‚óè‚óé‚óá‚óÜ‚ñ°‚ñ†‚ñ≥‚ñ≤‚Äª‚Üí‚Üê‚Üë‚Üì„Äì"],["a2a1","‚Ö∞",9],["a2b1","‚íà",19,"‚ë¥",19,"‚ë†",9],["a2e5","„à†",9],["a2f1","‚Ö†",11],["a3a1","ÔºÅÔºÇÔºÉÔø•ÔºÖ",88,"Ôø£"],["a4a1","„ÅÅ",82],["a5a1","„Ç°",85],["a6a1","Œë",16,"Œ£",6],["a6c1","Œ±",16,"œÉ",6],["a6e0","Ô∏µÔ∏∂Ô∏πÔ∏∫Ô∏øÔπÄÔ∏ΩÔ∏æÔπÅÔπÇÔπÉÔπÑ"],["a6ee","Ô∏ªÔ∏ºÔ∏∑Ô∏∏Ô∏±"],["a6f4","Ô∏≥Ô∏¥"],["a7a1","–ê",5,"–Å–ñ",25],["a7d1","–∞",5,"—ë–∂",25],["a840","ÀäÀãÀô‚Äì‚Äï‚Ä•‚Äµ‚ÑÖ‚Ñâ‚Üñ‚Üó‚Üò‚Üô‚àï‚àü‚à£‚âí‚â¶‚âß‚äø‚ïê",35,"‚ñÅ",6],["a880","‚ñà",7,"‚ñì‚ñî‚ñï‚ñº‚ñΩ‚ó¢‚ó£‚ó§‚ó•‚òâ‚äï„Äí„Äù„Äû"],["a8a1","ƒÅ√°«é√†ƒì√©ƒõ√®ƒ´√≠«ê√¨≈ç√≥«í√≤≈´√∫«î√π«ñ«ò«ö«ú√º√™…ë"],["a8bd","≈Ñ≈à"],["a8c0","…°"],["a8c5","„ÑÖ",36],["a940","„Ä°",8,"„ä£„éé„éè„éú„éù„éû„é°„èÑ„èé„èë„èí„èïÔ∏∞Ôø¢Ôø§"],["a959","‚Ñ°„à±"],["a95c","‚Äê"],["a960","„Éº„Çõ„Çú„ÉΩ„Éæ„ÄÜ„Çù„ÇûÔπâ",9,"ÔπîÔπïÔπñÔπóÔπô",8],["a980","Ôπ¢",4,"Ôπ®Ôπ©Ôπ™Ôπ´"],["a996","„Äá"],["a9a4","‚îÄ",75],["aa40","ÁãúÁãùÁãüÁã¢",5,"Áã™Áã´ÁãµÁã∂ÁãπÁãΩÁãæÁãøÁåÄÁåÇÁåÑ",5,"ÁåãÁååÁåçÁåèÁåêÁåëÁåíÁåîÁåòÁåôÁåöÁåüÁå†Áå£Áå§Áå¶ÁåßÁå®Áå≠ÁåØÁå∞Áå≤Áå≥ÁåµÁå∂Áå∫ÁåªÁåºÁåΩÁçÄ",8],["aa80","ÁçâÁçäÁçãÁçåÁçéÁçèÁçëÁçìÁçîÁçïÁçñÁçò",7,"Áç°",10,"ÁçÆÁç∞Áç±"],["ab40","Áç≤",11,"Áçø",4,"ÁéÖÁéÜÁéàÁéäÁéåÁéçÁéèÁéêÁéíÁéìÁéîÁéïÁéóÁéòÁéôÁéöÁéúÁéùÁéûÁé†Áé°Áé£",5,"Áé™Áé¨Áé≠Áé±Áé¥ÁéµÁé∂Áé∏ÁéπÁéºÁéΩÁéæÁéøÁèÅÁèÉ",4],["ab80","ÁèãÁèåÁèéÁèí",6,"ÁèöÁèõÁèúÁèùÁèüÁè°Áè¢Áè£Áè§Áè¶Áè®Áè™Áè´Áè¨ÁèÆÁèØÁè∞Áè±Áè≥",4],["ac40","Áè∏",10,"ÁêÑÁêáÁêàÁêãÁêåÁêçÁêéÁêë",8,"Áêú",5,"Áê£Áê§ÁêßÁê©Áê´Áê≠ÁêØÁê±Áê≤Áê∑",4,"ÁêΩÁêæÁêøÁëÄÁëÇ",11],["ac80","Áëé",6,"ÁëñÁëòÁëùÁë†",12,"ÁëÆÁëØÁë±",4,"Áë∏ÁëπÁë∫"],["ad40","ÁëªÁëºÁëΩÁëøÁíÇÁíÑÁíÖÁíÜÁíàÁíâÁíäÁíåÁíçÁíèÁíë",10,"ÁíùÁíü",7,"Áí™",15,"Áíª",12],["ad80","Áìà",9,"Áìì",8,"ÁìùÁìüÁì°Áì•Áìß",6,"Áì∞Áì±Áì≤"],["ae40","Áì≥ÁìµÁì∏",6,"ÁîÄÁîÅÁîÇÁîÉÁîÖ",7,"ÁîéÁîêÁîíÁîîÁîïÁîñÁîóÁîõÁîùÁîûÁî†",4,"Áî¶ÁîßÁî™ÁîÆÁî¥Áî∂ÁîπÁîºÁîΩÁîøÁïÅÁïÇÁïÉÁïÑÁïÜÁïáÁïâÁïäÁïçÁïêÁïëÁïíÁïìÁïïÁïñÁïóÁïò"],["ae80","Áïù",7,"ÁïßÁï®Áï©Áï´",6,"Áï≥ÁïµÁï∂Áï∑Áï∫",4,"ÁñÄÁñÅÁñÇÁñÑÁñÖÁñá"],["af40","ÁñàÁñâÁñäÁñåÁñçÁñéÁñêÁñìÁñïÁñòÁñõÁñúÁñûÁñ¢Áñ¶",4,"Áñ≠Áñ∂Áñ∑Áñ∫ÁñªÁñøÁóÄÁóÅÁóÜÁóãÁóåÁóéÁóèÁóêÁóëÁóìÁóóÁóôÁóöÁóúÁóùÁóüÁó†Áó°Áó•Áó©Áó¨Áó≠ÁóÆÁóØÁó≤Áó≥ÁóµÁó∂Áó∑Áó∏Áó∫ÁóªÁóΩÁóæÁòÇÁòÑÁòÜÁòá"],["af80","ÁòàÁòâÁòãÁòçÁòéÁòèÁòëÁòíÁòìÁòîÁòñÁòöÁòúÁòùÁòûÁò°Áò£ÁòßÁò®Áò¨ÁòÆÁòØÁò±Áò≤Áò∂Áò∑ÁòπÁò∫ÁòªÁòΩÁôÅÁôÇÁôÑ"],["b040","ÁôÖ",6,"Áôé",5,"ÁôïÁôó",4,"ÁôùÁôüÁô†Áô°Áô¢Áô§",6,"Áô¨Áô≠ÁôÆÁô∞",7,"ÁôπÁô∫ÁôºÁôøÁöÄÁöÅÁöÉÁöÖÁöâÁöäÁöåÁöçÁöèÁöêÁöíÁöîÁöïÁöóÁöòÁööÁöõ"],["b080","Áöú",7,"Áö•",8,"ÁöØÁö∞Áö≥Áöµ",9,"ÁõÄÁõÅÁõÉÂïäÈòøÂüÉÊå®ÂìéÂîâÂìÄÁöëÁôåËîºÁüÆËâæÁ¢çÁà±ÈöòÈûçÊ∞®ÂÆâ‰ø∫ÊåâÊöóÂ≤∏ËÉ∫Ê°àËÇÆÊòÇÁõéÂáπÊïñÁÜ¨Áø±Ë¢ÑÂÇ≤Â••ÊáäÊæ≥Ëä≠ÊçåÊâíÂè≠ÂêßÁ¨ÜÂÖ´Áñ§Â∑¥ÊãîË∑ãÈù∂ÊääËÄôÂùùÈú∏ÁΩ¢Áà∏ÁôΩÊüèÁôæÊëÜ‰Ω∞Ë¥•ÊãúÁ®óÊñëÁè≠Êê¨Êâ≥Ëà¨È¢ÅÊùøÁâàÊâÆÊãå‰º¥Áì£ÂçäÂäûÁªäÈÇ¶Â∏ÆÊ¢ÜÊ¶úËÜÄÁªëÊ£íÁ£ÖËöåÈïëÂÇçË∞§ËãûËÉûÂåÖË§íÂâ•"],["b140","ÁõÑÁõáÁõâÁõãÁõåÁõìÁõïÁõôÁõöÁõúÁõùÁõûÁõ†",4,"Áõ¶",7,"Áõ∞Áõ≥ÁõµÁõ∂Áõ∑Áõ∫ÁõªÁõΩÁõøÁúÄÁúÇÁúÉÁúÖÁúÜÁúäÁúåÁúé",10,"ÁúõÁúúÁúùÁúûÁú°Áú£Áú§Áú•ÁúßÁú™Áú´"],["b180","Áú¨ÁúÆÁú∞",4,"ÁúπÁúªÁúΩÁúæÁúøÁùÇÁùÑÁùÖÁùÜÁùà",7,"Áùí",7,"ÁùúËñÑÈõπ‰øùÂ†°È•±ÂÆùÊä±Êä•Êö¥Ë±πÈ≤çÁàÜÊùØÁ¢ëÊÇ≤ÂçëÂåóËæàËÉåË¥ùÈí°ÂÄçÁãàÂ§áÊÉ´ÁÑôË¢´Â•îËãØÊú¨Á¨®Â¥©Áª∑Áî≠Ê≥µËπ¶Ëø∏ÈÄºÈºªÊØîÈÑôÁ¨îÂΩºÁ¢ßËìñËîΩÊØïÊØôÊØñÂ∏ÅÂ∫áÁóπÈó≠ÊïùÂºäÂøÖËæüÂ£ÅËáÇÈÅøÈôõÈû≠ËæπÁºñË¥¨ÊâÅ‰æøÂèòÂçûËæ®Ëæ©Ëæ´ÈÅçÊ†áÂΩ™ËÜòË°®È≥ñÊÜãÂà´Áò™ÂΩ¨ÊñåÊøíÊª®ÂÆæÊëàÂÖµÂÜ∞ÊüÑ‰∏ôÁßâÈ•ºÁÇ≥"],["b240","ÁùùÁùûÁùüÁù†Áù§ÁùßÁù©Áù™Áù≠",11,"Áù∫ÁùªÁùºÁûÅÁûÇÁûÉÁûÜ",5,"ÁûèÁûêÁûì",11,"Áû°Áû£Áû§Áû¶Áû®Áû´Áû≠ÁûÆÁûØÁû±Áû≤Áû¥Áû∂",4],["b280","ÁûºÁûæÁüÄ",12,"Áüé",8,"ÁüòÁüôÁüöÁüù",4,"Áü§ÁóÖÂπ∂ÁéªËè†Êí≠Êã®ÈíµÊ≥¢ÂçöÂãÉÊêèÈìÇÁÆî‰ºØÂ∏õËà∂ËÑñËÜäÊ∏§Ê≥äÈ©≥ÊçïÂçúÂì∫Ë°•Âü†‰∏çÂ∏ÉÊ≠•Á∞øÈÉ®ÊÄñÊì¶ÁåúË£ÅÊùêÊâçË¥¢Áù¨Ë∏©ÈááÂΩ©ËèúËî°È§êÂèÇËöïÊÆãÊÉ≠ÊÉ®ÁÅøËãçËà±‰ªìÊ≤ßËóèÊìçÁ≥ôÊßΩÊõπËçâÂéïÁ≠ñ‰æßÂÜåÊµãÂ±ÇËπ≠ÊèíÂèâËå¨Ëå∂Êü•Á¢¥ÊêΩÂØüÂ≤îÂ∑ÆËØßÊãÜÊü¥Ë±∫ÊêÄÊé∫ËùâÈ¶ãË∞óÁº†Èì≤‰∫ßÈòêÈ¢§ÊòåÁåñ"],["b340","Áü¶Áü®Áü™ÁüØÁü∞Áü±Áü≤Áü¥ÁüµÁü∑ÁüπÁü∫ÁüªÁüºÁ†É",5,"Á†äÁ†ãÁ†éÁ†èÁ†êÁ†ìÁ†ïÁ†ôÁ†õÁ†ûÁ††Á†°Á†¢Á†§Á†®Á†™Á†´Á†ÆÁ†ØÁ†±Á†≤Á†≥Á†µÁ†∂Á†ΩÁ†øÁ°ÅÁ°ÇÁ°ÉÁ°ÑÁ°ÜÁ°àÁ°âÁ°äÁ°ãÁ°çÁ°èÁ°ëÁ°ìÁ°îÁ°òÁ°ôÁ°ö"],["b380","Á°õÁ°úÁ°û",11,"Á°Ø",7,"Á°∏Á°πÁ°∫Á°ªÁ°Ω",6,"Âú∫Â∞ùÂ∏∏ÈïøÂÅøËÇ†ÂéÇÊïûÁïÖÂî±ÂÄ°Ë∂ÖÊäÑÈíûÊúùÂò≤ÊΩÆÂ∑¢ÂêµÁÇíËΩ¶ÊâØÊí§Êé£ÂΩªÊæàÈÉ¥Ëá£Ëæ∞Â∞òÊô®Âø±Ê≤âÈôàË∂ÅË°¨ÊíëÁß∞ÂüéÊ©ôÊàêÂëà‰πòÁ®ãÊÉ©ÊæÑËØöÊâøÈÄûÈ™ãÁß§ÂêÉÁó¥ÊåÅÂåôÊ±†ËøüÂºõÈ©∞ËÄªÈΩø‰æàÂ∞∫Ëµ§ÁøÖÊñ•ÁÇΩÂÖÖÂÜ≤Ëô´Â¥áÂÆ†ÊäΩÈÖ¨Áï¥Ë∏åÁ®†ÊÑÅÁ≠π‰ªáÁª∏ÁûÖ‰∏ëËá≠ÂàùÂá∫Ê©±Âé®Ë∫áÈîÑÈõèÊªÅÈô§Ê•ö"],["b440","Á¢ÑÁ¢ÖÁ¢ÜÁ¢àÁ¢äÁ¢ãÁ¢èÁ¢êÁ¢íÁ¢îÁ¢ïÁ¢ñÁ¢ôÁ¢ùÁ¢ûÁ¢†Á¢¢Á¢§Á¢¶Á¢®",7,"Á¢µÁ¢∂Á¢∑Á¢∏Á¢∫Á¢ªÁ¢ºÁ¢ΩÁ¢øÁ£ÄÁ£ÇÁ£ÉÁ£ÑÁ£ÜÁ£áÁ£àÁ£åÁ£çÁ£éÁ£èÁ£ëÁ£íÁ£ìÁ£ñÁ£óÁ£òÁ£ö",9],["b480","Á£§Á£•Á£¶Á£ßÁ£©Á£™Á£´Á£≠",4,"Á£≥Á£µÁ£∂Á£∏Á£πÁ£ª",5,"Á§ÇÁ§ÉÁ§ÑÁ§Ü",6,"Á°ÄÂÇ®ÁüóÊêêËß¶Â§ÑÊè£Â∑ùÁ©øÊ§Ω‰º†ËàπÂñò‰∏≤ÁñÆÁ™óÂπ¢Â∫äÈóØÂàõÂêπÁÇäÊç∂Èî§ÂûÇÊò•Ê§øÈÜáÂîáÊ∑≥Á∫ØË†¢Êà≥Áª∞ÁñµËå®Á£ÅÈõåËæûÊÖàÁì∑ËØçÊ≠§Âà∫ËµêÊ¨°ËÅ™Ëë±Âõ±ÂåÜ‰ªé‰∏õÂáëÁ≤óÈÜãÁ∞á‰øÉËπøÁØ°Á™úÊëßÂ¥îÂÇ¨ËÑÜÁòÅÁ≤πÊ∑¨Áø†ÊùëÂ≠òÂØ∏Á£ãÊíÆÊêìÊé™Êå´ÈîôÊê≠ËææÁ≠îÁò©ÊâìÂ§ßÂëÜÊ≠πÂÇ£Êà¥Â∏¶ÊÆÜ‰ª£Ë¥∑Ë¢ãÂæÖÈÄÆ"],["b540","Á§ç",5,"Á§î",9,"Á§ü",4,"Á§•",14,"Á§µ",4,"Á§ΩÁ§øÁ•ÇÁ•ÉÁ•ÑÁ•ÖÁ•áÁ•ä",8,"Á•îÁ•ïÁ•òÁ•ôÁ•°Á•£"],["b580","Á•§Á•¶Á•©Á•™Á•´Á•¨Á•ÆÁ•∞",6,"Á•πÁ•ª",4,"Á¶ÇÁ¶ÉÁ¶ÜÁ¶áÁ¶àÁ¶âÁ¶ãÁ¶åÁ¶çÁ¶éÁ¶êÁ¶ëÁ¶íÊÄ†ËÄΩÊãÖ‰∏πÂçïÈÉ∏Êé∏ËÉÜÊó¶Ê∞Æ‰ΩÜÊÉÆÊ∑°ËØûÂºπËõãÂΩìÊå°ÂÖöËç°Ê°£ÂàÄÊç£ËπàÂÄíÂ≤õÁ•∑ÂØºÂà∞Á®ªÊÇºÈÅìÁõóÂæ∑ÂæóÁöÑËπ¨ÁÅØÁôªÁ≠âÁû™Âá≥ÈÇìÂ†§‰ΩéÊª¥Ëø™ÊïåÁ¨õÁãÑÊ∂§ÁøüÂ´°ÊäµÂ∫ïÂú∞ËíÇÁ¨¨Â∏ùÂºüÈÄíÁºîÈ¢†ÊéÇÊªáÁ¢òÁÇπÂÖ∏ÈùõÂû´Áîµ‰ΩÉÁî∏Â∫óÊÉ¶Â•†Ê∑ÄÊÆøÁ¢âÂèºÈõïÂáãÂàÅÊéâÂêäÈíìË∞ÉË∑åÁàπÁ¢üËù∂Ëø≠Ë∞çÂè†"],["b640","Á¶ì",6,"Á¶õ",11,"Á¶®",10,"Á¶¥",4,"Á¶ºÁ¶øÁßÇÁßÑÁßÖÁßáÁßàÁßäÁßåÁßéÁßèÁßêÁßìÁßîÁßñÁßóÁßô",5,"Áß†Áß°Áß¢Áß•Áß®Áß™"],["b680","Áß¨ÁßÆÁß±",6,"ÁßπÁß∫ÁßºÁßæÁßøÁ®ÅÁ®ÑÁ®ÖÁ®áÁ®àÁ®âÁ®äÁ®åÁ®è",4,"Á®ïÁ®ñÁ®òÁ®ôÁ®õÁ®ú‰∏ÅÁõØÂèÆÈíâÈ°∂ÈºéÈî≠ÂÆöËÆ¢‰∏¢‰∏úÂÜ¨Ëë£ÊáÇÂä®Ê†ã‰æóÊÅ´ÂÜªÊ¥ûÂÖúÊäñÊñóÈô°Ë±ÜÈÄóÁóòÈÉΩÁù£ÊØíÁääÁã¨ËØªÂ†µÁùπËµåÊùúÈïÄËÇöÂ∫¶Ê∏°Â¶íÁ´ØÁü≠ÈîªÊÆµÊñ≠ÁºéÂ†ÜÂÖëÈòüÂØπÂ¢©Âê®Ëπ≤Êï¶È°øÂõ§ÈíùÁõæÈÅÅÊéáÂìÜÂ§öÂ§∫ÂûõË∫≤ÊúµË∑∫ËàµÂâÅÊÉ∞Â†ïËõæÂ≥®ÈπÖ‰øÑÈ¢ùËÆπÂ®•ÊÅ∂ÂéÑÊâºÈÅèÈÑÇÈ•øÊÅ©ËÄåÂÑøËÄ≥Â∞îÈ•µÊ¥±‰∫å"],["b740","Á®ùÁ®üÁ®°Á®¢Á®§",14,"Á®¥Á®µÁ®∂Á®∏Á®∫Á®æÁ©Ä",5,"Á©á",9,"Á©í",4,"Á©ò",16],["b780","Á©©",6,"Á©±Á©≤Á©≥Á©µÁ©ªÁ©ºÁ©ΩÁ©æÁ™ÇÁ™ÖÁ™áÁ™âÁ™äÁ™ãÁ™åÁ™éÁ™èÁ™êÁ™ìÁ™îÁ™ôÁ™öÁ™õÁ™ûÁ™°Á™¢Ë¥∞ÂèëÁΩöÁ≠è‰ºê‰πèÈòÄÊ≥ïÁèêËó©Â∏ÜÁï™ÁøªÊ®äÁüæÈííÁπÅÂá°ÁÉ¶ÂèçËøîËåÉË¥©ÁäØÈ•≠Ê≥õÂùäËä≥ÊñπËÇ™ÊàøÈò≤Â¶®‰ªøËÆøÁ∫∫ÊîæËè≤ÈùûÂï°È£ûËÇ•Âå™ËØΩÂê†ËÇ∫Â∫üÊ≤∏Ë¥πËä¨ÈÖöÂê©Ê∞õÂàÜÁ∫∑ÂùüÁÑöÊ±æÁ≤âÂ•ã‰ªΩÂøøÊÑ§Á≤™‰∏∞Â∞ÅÊû´ËúÇÂ≥∞ÈîãÈ£éÁñØÁÉΩÈÄ¢ÂÜØÁºùËÆΩÂ•âÂá§‰ΩõÂê¶Â§´Êï∑ËÇ§Â≠µÊâ∂ÊãÇËæêÂπÖÊ∞üÁ¨¶‰ºè‰øòÊúç"],["b840","Á™£Á™§Á™ßÁ™©Á™™Á™´Á™Æ",4,"Á™¥",10,"Á´Ä",10,"Á´å",9,"Á´óÁ´òÁ´öÁ´õÁ´úÁ´ùÁ´°Á´¢Á´§Á´ß",5,"Á´ÆÁ´∞Á´±Á´≤Á´≥"],["b880","Á´¥",4,"Á´ªÁ´ºÁ´æÁ¨ÄÁ¨ÅÁ¨ÇÁ¨ÖÁ¨áÁ¨âÁ¨åÁ¨çÁ¨éÁ¨êÁ¨íÁ¨ìÁ¨ñÁ¨óÁ¨òÁ¨öÁ¨úÁ¨ùÁ¨üÁ¨°Á¨¢Á¨£Á¨ßÁ¨©Á¨≠ÊµÆÊ∂™Á¶èË¢±ÂºóÁî´ÊäöËæÖ‰øØÈáúÊñßËÑØËÖëÂ∫úËÖêËµ¥ÂâØË¶ÜËµãÂ§çÂÇÖ‰ªòÈòúÁà∂ËÖπË¥üÂØåËÆ£ÈôÑÂ¶áÁºöÂíêÂô∂ÂòéËØ•ÊîπÊ¶ÇÈíôÁõñÊ∫âÂπ≤ÁîòÊùÜÊüëÁ´øËÇùËµ∂ÊÑüÁßÜÊï¢Ëµ£ÂÜàÂàöÈí¢Áº∏ËÇõÁ∫≤Â≤óÊ∏ØÊù†ÁØôÁöãÈ´òËÜèÁæîÁ≥ïÊêûÈïêÁ®øÂëäÂì•Ê≠åÊêÅÊààÈ∏ΩËÉ≥ÁñôÂâ≤Èù©ËëõÊ†ºËõ§ÈòÅÈöîÈì¨‰∏™ÂêÑÁªôÊ†πË∑üËÄïÊõ¥Â∫öÁæπ"],["b940","Á¨ØÁ¨∞Á¨≤Á¨¥Á¨µÁ¨∂Á¨∑Á¨πÁ¨ªÁ¨ΩÁ¨ø",5,"Á≠ÜÁ≠àÁ≠äÁ≠çÁ≠éÁ≠ìÁ≠ïÁ≠óÁ≠ôÁ≠úÁ≠ûÁ≠üÁ≠°Á≠£",10,"Á≠ØÁ≠∞Á≠≥Á≠¥Á≠∂Á≠∏Á≠∫Á≠ºÁ≠ΩÁ≠øÁÆÅÁÆÇÁÆÉÁÆÑÁÆÜ",6,"ÁÆéÁÆè"],["b980","ÁÆëÁÆíÁÆìÁÆñÁÆòÁÆôÁÆöÁÆõÁÆûÁÆüÁÆ†ÁÆ£ÁÆ§ÁÆ•ÁÆÆÁÆØÁÆ∞ÁÆ≤ÁÆ≥ÁÆµÁÆ∂ÁÆ∑ÁÆπ",7,"ÁØÇÁØÉÁØÑÂüÇËÄøÊ¢óÂ∑•ÊîªÂäüÊÅ≠Èæö‰æõË∫¨ÂÖ¨ÂÆ´ÂºìÂ∑©Ê±ûÊã±Ë¥°ÂÖ±Èí©ÂãæÊ≤üËãüÁãóÂû¢ÊûÑË¥≠Â§üËæúËèáÂíïÁÆç‰º∞Ê≤ΩÂ≠§ÂßëÈºìÂè§ËõäÈ™®Ë∞∑ËÇ°ÊïÖÈ°æÂõ∫ÈõáÂàÆÁìúÂâêÂØ°ÊåÇË§Ç‰πñÊãêÊÄ™Ê£∫ÂÖ≥ÂÆòÂÜ†ËßÇÁÆ°È¶ÜÁΩêÊÉØÁÅåË¥ØÂÖâÂπøÈÄõÁë∞ËßÑÂú≠Á°ÖÂΩíÈæüÈó∫ËΩ®È¨ºËØ°Áô∏Ê°ÇÊüúË∑™Ë¥µÂàΩËæäÊªöÊ£çÈîÖÈÉ≠ÂõΩÊûúË£πËøáÂìà"],["ba40","ÁØÖÁØàÁØâÁØäÁØãÁØçÁØéÁØèÁØêÁØíÁØî",4,"ÁØõÁØúÁØûÁØüÁØ†ÁØ¢ÁØ£ÁØ§ÁØßÁØ®ÁØ©ÁØ´ÁØ¨ÁØ≠ÁØØÁØ∞ÁØ≤",4,"ÁØ∏ÁØπÁØ∫ÁØªÁØΩÁØø",7,"Á∞àÁ∞âÁ∞äÁ∞çÁ∞éÁ∞ê",5,"Á∞óÁ∞òÁ∞ô"],["ba80","Á∞ö",4,"Á∞†",5,"Á∞®Á∞©Á∞´",12,"Á∞π",5,"Á±ÇÈ™∏Â≠©Êµ∑Ê∞¶‰∫•ÂÆ≥È™áÈÖ£ÊÜ®ÈÇØÈü©Âê´Ê∂µÂØíÂáΩÂñäÁΩïÁø∞ÊíºÊççÊó±ÊÜæÊÇçÁÑäÊ±óÊ±âÂ§ØÊù≠Ëà™Â£ïÂöéË±™ÊØ´ÈÉùÂ•ΩËÄóÂè∑Êµ©ÂëµÂñùËç∑ËèèÊ†∏Á¶æÂíå‰ΩïÂêàÁõíË≤âÈòÇÊ≤≥Ê∂∏Ëµ´Ë§êÈπ§Ë¥∫ÂòøÈªëÁóïÂæàÁã†ÊÅ®Âìº‰∫®Ê®™Ë°°ÊÅíËΩ∞ÂìÑÁÉòËôπÈ∏øÊ¥™ÂÆèÂºòÁ∫¢Âñâ‰æØÁå¥ÂêºÂéöÂÄôÂêéÂëº‰πéÂøΩÁëöÂ£∂Ëë´ËÉ°Ëù¥ÁãêÁ≥äÊπñ"],["bb40","Á±É",9,"Á±é",36,"Á±µ",5,"Á±æ",9],["bb80","Á≤àÁ≤ä",6,"Á≤ìÁ≤îÁ≤ñÁ≤ôÁ≤öÁ≤õÁ≤†Á≤°Á≤£Á≤¶Á≤ßÁ≤®Á≤©Á≤´Á≤¨Á≤≠Á≤ØÁ≤∞Á≤¥",4,"Á≤∫Á≤ªÂºßËôéÂî¨Êä§‰∫íÊ≤™Êà∑Ëä±ÂìóÂçéÁåæÊªëÁîªÂàíÂåñËØùÊßêÂæäÊÄÄÊ∑ÆÂùèÊ¨¢ÁéØÊ°ìËøòÁºìÊç¢ÊÇ£Âî§Áó™Ë±¢ÁÑïÊ∂£ÂÆ¶ÂπªËçíÊÖåÈªÑÁ£∫ËùóÁ∞ßÁöáÂá∞ÊÉ∂ÁÖåÊôÉÂπåÊÅçË∞éÁÅ∞Êå•ËæâÂæΩÊÅ¢ËõîÂõûÊØÅÊÇîÊÖßÂçâÊÉ†Êô¶Ë¥øÁßΩ‰ºöÁÉ©Ê±áËÆ≥ËØ≤ÁªòËç§ÊòèÂ©öÈ≠ÇÊµëÊ∑∑Ë±ÅÊ¥ª‰ºôÁÅ´Ëé∑ÊàñÊÉëÈúçË¥ßÁ•∏ÂáªÂúæÂü∫Êú∫Áï∏Á®ΩÁßØÁÆï"],["bc40","Á≤øÁ≥ÄÁ≥ÇÁ≥ÉÁ≥ÑÁ≥ÜÁ≥âÁ≥ãÁ≥é",6,"Á≥òÁ≥öÁ≥õÁ≥ùÁ≥ûÁ≥°",6,"Á≥©",5,"Á≥∞",7,"Á≥πÁ≥∫Á≥º",13,"Á¥ã",5],["bc80","Á¥ë",14,"Á¥°Á¥£Á¥§Á¥•Á¥¶Á¥®Á¥©Á¥™Á¥¨Á¥≠Á¥ÆÁ¥∞",6,"ËÇåÈ••ËøπÊøÄËÆ•È∏°Âß¨Áª©ÁºâÂêâÊûÅÊ£òËæëÁ±çÈõÜÂèäÊÄ•ÁñæÊ±≤Âç≥Â´âÁ∫ßÊå§Âá†ËÑäÂ∑±ËìüÊäÄÂÜÄÂ≠£‰ºéÁ•≠ÂâÇÊÇ∏ÊµéÂØÑÂØÇËÆ°ËÆ∞Êó¢ÂøåÈôÖÂ¶ìÁªßÁ∫™ÂòâÊû∑Â§π‰Ω≥ÂÆ∂Âä†ËçöÈ¢äË¥æÁî≤ÈíæÂÅáÁ®º‰ª∑Êû∂È©æÂ´ÅÊ≠ºÁõëÂùöÂ∞ñÁ¨∫Èó¥ÁÖéÂÖºËÇ©Ëâ∞Â•∏ÁºÑËåßÊ£ÄÊü¨Á¢±Á°∑Êã£Êç°ÁÆÄ‰ø≠Ââ™ÂáèËçêÊßõÈâ¥Ë∑µË¥±ËßÅÈîÆÁÆ≠‰ª∂"],["bd40","Á¥∑",54,"ÁµØ",7],["bd80","Áµ∏",32,"ÂÅ•Ëà∞ÂâëÈ•ØÊ∏êÊ∫ÖÊ∂ßÂª∫ÂÉµÂßúÂ∞ÜÊµÜÊ±üÁñÜËíãÊ°®Â•ñËÆ≤Âå†ÈÖ±ÈôçËïâÊ§íÁ§ÅÁÑ¶ËÉ∂‰∫§ÈÉäÊµáÈ™ÑÂ®áÂöºÊêÖÈì∞Áü´‰æ•ËÑöÁã°ËßíÈ•∫Áº¥ÁªûÂâøÊïôÈÖµËΩøËæÉÂè´Á™ñÊè≠Êé•ÁöÜÁß∏Ë°óÈò∂Êà™Âä´ËäÇÊ°îÊù∞Êç∑Áù´Á´≠Ê¥ÅÁªìËß£ÂßêÊàíËóâËä•ÁïåÂÄü‰ªãÁñ•ËØ´Â±äÂ∑æÁ≠ãÊñ§Èáë‰ªäÊ¥•Ë•üÁ¥ßÈî¶‰ªÖË∞®ËøõÈù≥ÊôãÁ¶ÅËøëÁÉ¨Êµ∏"],["be40","Á∂ô",12,"Á∂ß",6,"Á∂Ø",42],["be80","Á∑ö",32,"Â∞ΩÂä≤ËçÜÂÖ¢ËåéÁùõÊô∂È≤∏‰∫¨ÊÉäÁ≤æÁ≤≥Áªè‰∫ïË≠¶ÊôØÈ¢àÈùôÂ¢ÉÊï¨ÈïúÂæÑÁóâÈùñÁ´üÁ´ûÂáÄÁÇØÁ™òÊè™Á©∂Á∫†ÁéñÈü≠‰πÖÁÅ∏‰πùÈÖíÂé©ÊïëÊóßËáºËàÖÂíéÂ∞±ÁñöÈû†ÊãòÁãôÁñΩÂ±ÖÈ©πËèäÂ±ÄÂíÄÁü©‰∏æÊ≤ÆËÅöÊãíÊçÆÂ∑®ÂÖ∑Ë∑ùË∏ûÈîØ‰ø±Âè•ÊÉßÁÇ¨ÂâßÊçêÈπÉÂ®üÂÄ¶Áú∑Âç∑Áª¢ÊíÖÊî´ÊäâÊéòÂÄîÁàµËßâÂÜ≥ËØÄÁªùÂùáËèåÈíßÂÜõÂêõÂ≥ª"],["bf40","Á∑ª",62],["bf80","Á∏∫Á∏º",4,"ÁπÇ",4,"Áπà",21,"‰øäÁ´£ÊµöÈÉ°È™èÂñÄÂíñÂç°ÂíØÂºÄÊè©Ê•∑ÂáØÊÖ®ÂàäÂ†™ÂãòÂùéÁ†çÁúãÂ∫∑ÊÖ∑Á≥†ÊâõÊäó‰∫¢ÁÇïËÄÉÊã∑ÁÉ§Èù†Âù∑ËãõÊüØÊ£µÁ£ïÈ¢óÁßëÂ£≥Âí≥ÂèØÊ∏¥ÂÖãÂàªÂÆ¢ËØæËÇØÂïÉÂû¶ÊÅ≥ÂùëÂê≠Á©∫ÊÅêÂ≠îÊéßÊä†Âè£Êâ£ÂØáÊûØÂì≠Á™üËã¶ÈÖ∑Â∫ìË£§Â§∏ÂûÆÊåéË∑®ËÉØÂùóÁ≠∑‰æ©Âø´ÂÆΩÊ¨æÂå°Á≠êÁãÇÊ°ÜÁüøÁú∂Êó∑ÂÜµ‰∫èÁõîÂ≤øÁ™•ËëµÂ•éÈ≠ÅÂÇÄ"],["c040","Áπû",35,"Á∫É",23,"Á∫úÁ∫ùÁ∫û"],["c080","Á∫ÆÁ∫¥Á∫ªÁ∫ºÁªñÁª§Áª¨ÁªπÁºäÁºêÁºûÁº∑ÁºπÁºª",6,"ÁΩÉÁΩÜ",9,"ÁΩíÁΩìÈ¶àÊÑßÊ∫ÉÂù§ÊòÜÊçÜÂõ∞Êã¨Êâ©ÂªìÈòîÂûÉÊãâÂñáËú°ËÖäËæ£Âï¶Ëé±Êù•ËµñËìùÂ©™Ê†èÊã¶ÁØÆÈòëÂÖ∞ÊæúË∞∞ÊèΩËßàÊáíÁºÜÁÉÇÊª•ÁêÖÊ¶îÁãºÂªäÈÉéÊúóÊµ™ÊçûÂä≥Áâ¢ËÄÅ‰Ω¨Âß•ÈÖ™ÁÉôÊ∂ùÂãí‰πêÈõ∑Èï≠ËïæÁ£äÁ¥ØÂÑ°ÂûíÊìÇËÇãÁ±ªÊ≥™Ê£±Ê•ûÂÜ∑ÂéòÊ¢®ÁäÅÈªéÁØ±Áã∏Á¶ªÊºìÁêÜÊùéÈáåÈ≤§Á§ºËéâËçîÂêèÊ†ó‰∏ΩÂéâÂä±Á†æÂéÜÂà©ÂÇà‰æã‰øê"],["c140","ÁΩñÁΩôÁΩõÁΩúÁΩùÁΩûÁΩ†ÁΩ£",4,"ÁΩ´ÁΩ¨ÁΩ≠ÁΩØÁΩ∞ÁΩ≥ÁΩµÁΩ∂ÁΩ∑ÁΩ∏ÁΩ∫ÁΩªÁΩºÁΩΩÁΩøÁæÄÁæÇ",7,"ÁæãÁæçÁæè",4,"Áæï",4,"ÁæõÁæúÁæ†Áæ¢Áæ£Áæ•Áæ¶Áæ®",6,"Áæ±"],["c180","Áæ≥",4,"Áæ∫ÁæªÁææÁøÄÁøÇÁøÉÁøÑÁøÜÁøáÁøàÁøâÁøãÁøçÁøè",4,"ÁøñÁøóÁøô",5,"Áø¢Áø£Áó¢Á´ãÁ≤íÊ≤•Èö∂ÂäõÁíÉÂì©‰ø©ËÅîËé≤ËøûÈï∞ÂªâÊÄúÊ∂üÂ∏òÊïõËÑ∏ÈìæÊÅãÁÇºÁªÉÁ≤ÆÂáâÊ¢ÅÁ≤±ËâØ‰∏§ËæÜÈáèÊôæ‰∫ÆË∞ÖÊí©ËÅäÂÉöÁñóÁáéÂØ•ËæΩÊΩ¶‰∫ÜÊíÇÈï£ÂªñÊñôÂàóË£ÇÁÉàÂä£ÁåéÁê≥ÊûóÁ£∑Èúñ‰∏¥ÈÇªÈ≥ûÊ∑ãÂáõËµÅÂêùÊãéÁé≤Ëè±Èõ∂ÈæÑÈìÉ‰º∂ÁæöÂáåÁÅµÈôµÂ≤≠È¢ÜÂè¶‰ª§Ê∫úÁêâÊ¶¥Á°´È¶èÁïôÂàòÁò§ÊµÅÊü≥ÂÖ≠ÈæôËÅãÂíôÁ¨ºÁ™ø"],["c240","Áø§ÁøßÁø®Áø™Áø´Áø¨Áø≠ÁøØÁø≤Áø¥",6,"ÁøΩÁøæÁøøËÄÇËÄáËÄàËÄâËÄäËÄéËÄèËÄëËÄìËÄöËÄõËÄùËÄûËÄüËÄ°ËÄ£ËÄ§ËÄ´",5,"ËÄ≤ËÄ¥ËÄπËÄ∫ËÄºËÄæËÅÄËÅÅËÅÑËÅÖËÅáËÅàËÅâËÅéËÅèËÅêËÅëËÅìËÅïËÅñËÅó"],["c280","ËÅôËÅõ",13,"ËÅ´",5,"ËÅ≤",11,"ÈöÜÂûÑÊã¢ÈôáÊ•ºÂ®ÑÊêÇÁØìÊºèÈôãËä¶Âç¢È¢ÖÂ∫êÁÇâÊé≥Âç§ËôèÈ≤ÅÈ∫ìÁ¢åÈú≤Ë∑ØËµÇÈπøÊΩûÁ¶ÑÂΩïÈôÜÊàÆÈ©¥ÂêïÈìù‰æ£ÊóÖÂ±•Â±°ÁºïËôëÊ∞ØÂæãÁéáÊª§ÁªøÂ≥¶ÊåõÂ≠™Êª¶Âçµ‰π±Êé†Áï•Êä°ËΩÆ‰º¶‰ªëÊ≤¶Á∫∂ËÆ∫ËêùËû∫ÁΩóÈÄªÈî£ÁÆ©È™°Ë£∏ËêΩÊ¥õÈ™ÜÁªúÂ¶àÈ∫ªÁéõÁ†ÅËöÇÈ©¨È™ÇÂòõÂêóÂüã‰π∞È∫¶ÂçñËøàËÑâÁûíÈ¶íËõÆÊª°ËîìÊõºÊÖ¢Êº´"],["c340","ËÅæËÇÅËÇÇËÇÖËÇàËÇäËÇç",5,"ËÇîËÇïËÇóËÇôËÇûËÇ£ËÇ¶ËÇßËÇ®ËÇ¨ËÇ∞ËÇ≥ËÇµËÇ∂ËÇ∏ËÇπËÇªËÉÖËÉá",4,"ËÉè",6,"ËÉòËÉüËÉ†ËÉ¢ËÉ£ËÉ¶ËÉÆËÉµËÉ∑ËÉπËÉªËÉæËÉøËÑÄËÑÅËÑÉËÑÑËÑÖËÑáËÑàËÑã"],["c380","ËÑåËÑïËÑóËÑôËÑõËÑúËÑùËÑü",12,"ËÑ≠ËÑÆËÑ∞ËÑ≥ËÑ¥ËÑµËÑ∑ËÑπ",4,"ËÑøË∞©ËäíËå´Áõ≤Ê∞ìÂøôËéΩÁå´ËåÖÈîöÊØõÁüõÈìÜÂçØËåÇÂÜíÂ∏ΩË≤åË¥∏‰πàÁé´ÊûöÊ¢ÖÈÖ∂ÈúâÁÖ§Ê≤°ÁúâÂ™íÈïÅÊØèÁæéÊòßÂØêÂ¶πÂ™öÈó®Èó∑‰ª¨ËêåËíôÊ™¨ÁõüÈî∞ÁåõÊ¢¶Â≠üÁúØÈÜöÈù°Á≥úËø∑Ë∞úÂº•Á±≥ÁßòËßÖÊ≥åËúúÂØÜÂπÇÊ£âÁú†ÁªµÂÜïÂÖçÂãâÂ®©ÁºÖÈù¢ËãóÊèèÁûÑËóêÁßíÊ∏∫Â∫ôÂ¶ôËîëÁÅ≠Ê∞ëÊäøÁöøÊïèÊÇØÈóΩÊòéËûüÈ∏£Èì≠ÂêçÂëΩË∞¨Êë∏"],["c440","ËÖÄ",5,"ËÖáËÖâËÖçËÖéËÖèËÖíËÖñËÖóËÖòËÖõ",4,"ËÖ°ËÖ¢ËÖ£ËÖ§ËÖ¶ËÖ®ËÖ™ËÖ´ËÖ¨ËÖØËÖ≤ËÖ≥ËÖµËÖ∂ËÖ∑ËÖ∏ËÜÅËÜÉ",4,"ËÜâËÜãËÜåËÜçËÜéËÜêËÜí",5,"ËÜôËÜöËÜû",4,"ËÜ§ËÜ•"],["c480","ËÜßËÜ©ËÜ´",7,"ËÜ¥",5,"ËÜºËÜΩËÜæËÜøËáÑËáÖËááËáàËáâËáãËáç",6,"ÊëπËòëÊ®°ËÜúÁ£®Êë©È≠îÊäπÊú´Ëé´Â¢®ÈªòÊ≤´Êº†ÂØûÈôåË∞ãÁâüÊüêÊãáÁâ°‰∫©ÂßÜÊØçÂ¢ìÊöÆÂπïÂãüÊÖïÊú®ÁõÆÁù¶ÁâßÁ©ÜÊãøÂì™ÂëêÈí†ÈÇ£Â®úÁ∫≥Ê∞ñ‰πÉÂ•∂ËÄêÂ•àÂçóÁî∑ÈöæÂõäÊå†ËÑëÊÅºÈóπÊ∑ñÂë¢È¶ÅÂÜÖÂ´©ËÉΩÂ¶ÆÈúìÂÄ™Ê≥•Â∞ºÊãü‰Ω†ÂåøËÖªÈÄÜÊ∫∫Ëî´ÊãàÂπ¥Á¢æÊíµÊçªÂøµÂ®òÈÖøÈ∏üÂ∞øÊçèËÅÇÂ≠ΩÂïÆÈïäÈïçÊ∂ÖÊÇ®Êü†ÁãûÂáùÂÆÅ"],["c540","Ëáî",14,"Ëá§Ëá•Ëá¶Ëá®Ëá©Ëá´ËáÆ",4,"Ëáµ",5,"ËáΩËáøËàÉËàá",4,"ËàéËàèËàëËàìËàï",5,"ËàùËà†Ëà§Ëà•Ëà¶ËàßËà©ËàÆËà≤Ëà∫ËàºËàΩËàø"],["c580","ËâÄËâÅËâÇËâÉËâÖËâÜËâàËâäËâåËâçËâéËâê",7,"ËâôËâõËâúËâùËâûËâ†",7,"Ëâ©ÊãßÊ≥ûÁâõÊâ≠ÈíÆÁ∫ΩËÑìÊµìÂÜúÂºÑÂ•¥Âä™ÊÄíÂ•≥ÊöñËôêÁñüÊå™Êá¶Á≥ØËØ∫Âì¶Ê¨ßÈ∏•ÊÆ¥ËóïÂëïÂÅ∂Ê≤§Âï™Ë∂¥Áà¨Â∏ïÊÄïÁê∂ÊãçÊéíÁâåÂæòÊπÉÊ¥æÊîÄÊΩòÁõòÁ£êÁõºÁïîÂà§Âèõ‰πìÂ∫ûÊóÅËÄ™ËÉñÊäõÂíÜÂà®ÁÇÆË¢çË∑ëÊ≥°Âë∏ËÉöÂüπË£¥ËµîÈô™ÈÖç‰Ω©Ê≤õÂñ∑ÁõÜÁ†∞Êä®ÁÉπÊæéÂΩ≠Ëì¨Ê£öÁ°ºÁØ∑ËÜ®ÊúãÈπèÊçßÁ¢∞ÂùØÁ†íÈúπÊâπÊä´ÂäàÁêµÊØó"],["c640","Ëâ™Ëâ´Ëâ¨Ëâ≠Ëâ±ËâµËâ∂Ëâ∑Ëâ∏ËâªËâºËäÄËäÅËäÉËäÖËäÜËäáËäâËäåËäêËäìËäîËäïËäñËäöËäõËäûËä†Ëä¢Ëä£ËäßËä≤ËäµËä∂Ëä∫ËäªËäºËäøËãÄËãÇËãÉËãÖËãÜËãâËãêËãñËãôËãöËãùËã¢ËãßËã®Ëã©Ëã™Ëã¨Ëã≠ËãÆËã∞Ëã≤Ëã≥ËãµËã∂Ëã∏"],["c680","Ëã∫Ëãº",4,"ËåäËåãËåçËåêËåíËåìËåñËåòËåôËåù",9,"Ëå©Ëå™ËåÆËå∞Ëå≤Ëå∑ËåªËåΩÂï§ËÑæÁñ≤ÁöÆÂåπÁóûÂÉªÂ±ÅË≠¨ÁØáÂÅèÁâáÈ™óÈ£òÊºÇÁì¢Á•®ÊíáÁû•ÊãºÈ¢ëË¥´ÂìÅËÅò‰πíÂù™ËãπËêçÂπ≥Âá≠Áì∂ËØÑÂ±èÂù°Ê≥ºÈ¢áÂ©ÜÁ†¥È≠ÑËø´Á≤ïÂâñÊâëÈì∫‰ªÜËéÜËë°Ëè©Ëí≤ÂüîÊú¥ÂúÉÊôÆÊµ¶Ë∞±ÊõùÁÄëÊúüÊ¨∫Ê†ñÊàöÂ¶ª‰∏ÉÂáÑÊºÜÊüíÊ≤èÂÖ∂Ê£ãÂ•áÊ≠ßÁï¶Â¥éËÑêÈΩêÊóóÁ•àÁ•ÅÈ™ëËµ∑Â≤Ç‰πû‰ºÅÂêØÂ•ëÁ†åÂô®Ê∞îËøÑÂºÉÊ±ΩÊ≥£ËÆ´Êéê"],["c740","ËåæËåøËçÅËçÇËçÑËçÖËçàËçä",4,"ËçìËçï",4,"ËçùËç¢Ëç∞",6,"ËçπËç∫Ëçæ",6,"ËéáËéàËéäËéãËéåËéçËéèËéêËéëËéîËéïËéñËéóËéôËéöËéùËéüËé°",6,"Ëé¨Ëé≠ËéÆ"],["c780","ËéØËéµËéªËéæËéøËèÇËèÉËèÑËèÜËèàËèâËèãËèçËèéËèêËèëËèíËèìËèïËèóËèôËèöËèõËèûËè¢Ëè£Ëè§Ëè¶ËèßËè®Ëè´Ëè¨Ëè≠ÊÅ∞Ê¥ΩÁâµÊâ¶ÈíéÈìÖÂçÉËøÅÁ≠æ‰ªüË∞¶‰πæÈªîÈí±Èí≥ÂâçÊΩúÈÅ£ÊµÖË∞¥Â†ëÂµåÊ¨†Ê≠âÊû™ÂëõËÖîÁæåÂ¢ôËî∑Âº∫Êä¢Ê©áÈîπÊï≤ÊÇÑÊ°•Áûß‰πî‰æ®Â∑ßÈûòÊí¨ÁøòÂ≥≠‰øèÁ™çÂàáËåÑ‰∏îÊÄØÁ™ÉÈí¶‰æµ‰∫≤Áß¶Áê¥Âã§ËäπÊìíÁ¶ΩÂØùÊ≤ÅÈùíËΩªÊ∞¢ÂÄæÂçøÊ∏ÖÊìéÊô¥Ê∞∞ÊÉÖÈ°∑ËØ∑Â∫ÜÁêºÁ©∑Áßã‰∏òÈÇ±ÁêÉÊ±ÇÂõöÈÖãÊ≥ÖË∂ãÂå∫ËõÜÊõ≤Ë∫ØÂ±àÈ©±Ê∏†"],["c840","ËèÆËèØËè≥",4,"Ëè∫ËèªËèºËèæËèøËêÄËêÇËêÖËêáËêàËêâËêäËêêËêí",5,"ËêôËêöËêõËêû",5,"Ëê©",7,"Ëê≤",5,"ËêπËê∫ËêªËêæ",7,"ËëáËëàËëâ"],["c880","Ëëä",6,"Ëëí",4,"ËëòËëùËëûËëüËë†Ëë¢Ëë§",4,"Ëë™ËëÆËëØËë∞Ëë≤Ëë¥Ëë∑ËëπËëªËëºÂèñÂ®∂ÈæãË∂£ÂéªÂúàÈ¢ßÊùÉÈÜõÊ≥âÂÖ®ÁóäÊã≥Áä¨Âà∏ÂäùÁº∫ÁÇîÁò∏Âç¥ÈπäÊ¶∑Á°ÆÈõÄË£ôÁæ§ÁÑ∂ÁáÉÂÜâÊüìÁì§Â£§ÊîòÂö∑ËÆ©È•∂Êâ∞ÁªïÊÉπÁÉ≠Â£¨‰ªÅ‰∫∫ÂøçÈüß‰ªªËÆ§ÂàÉÂ¶äÁ∫´Êâî‰ªçÊó•ÊàéËå∏ËìâËç£ËûçÁÜîÊ∫∂ÂÆπÁªíÂÜóÊèâÊüîËÇâËåπË†ïÂÑíÂ≠∫Â¶ÇËæ±‰π≥Ê±ùÂÖ•Ë§•ËΩØÈòÆËïäÁëûÈîêÈó∞Ê∂¶Ëã•Âº±ÊííÊ¥íËê®ËÖÆÈ≥ÉÂ°ûËµõ‰∏âÂèÅ"],["c940","ËëΩ",4,"ËíÉËíÑËíÖËíÜËíäËíçËíè",7,"ËíòËíöËíõËíùËíûËíüËí†Ëí¢",12,"Ëí∞Ëí±Ëí≥ËíµËí∂Ëí∑ËíªËíºËíæËìÄËìÇËìÉËìÖËìÜËìáËìàËìãËìåËìéËìèËìíËìîËìïËìó"],["c980","Ëìò",4,"ËìûËì°Ëì¢Ëì§Ëìß",4,"Ëì≠ËìÆËìØËì±",10,"ËìΩËìæËîÄËîÅËîÇ‰ºûÊï£Ê°ëÂóì‰∏ßÊêîÈ™öÊâ´Â´ÇÁëüËâ≤Ê∂©Ê£ÆÂÉßËééÁ†ÇÊùÄÂàπÊ≤ôÁ∫±ÂÇªÂï•ÁÖûÁ≠õÊôíÁèäËã´ÊùâÂ±±Âà†ÁÖΩË°´Èó™ÈôïÊìÖËµ°ËÜ≥ÂñÑÊ±ïÊâáÁºÆÂ¢í‰º§ÂïÜËµèÊôå‰∏äÂ∞öË£≥Ê¢¢ÊçéÁ®çÁÉßËäçÂã∫Èü∂Â∞ëÂì®ÈÇµÁªçÂ•¢ËµäËõáËàåËàçËµ¶ÊëÑÂ∞ÑÊÖëÊ∂âÁ§æËÆæÁ†∑Áî≥Âëª‰º∏Ë∫´Ê∑±Â®†ÁªÖÁ•ûÊ≤àÂÆ°Â©∂ÁîöËÇæÊÖéÊ∏óÂ£∞ÁîüÁî•Áâ≤ÂçáÁª≥"],["ca40","ËîÉ",8,"ËîçËîéËîèËîêËîíËîîËîïËîñËîòËîôËîõËîúËîùËîûËî†Ëî¢",8,"Ëî≠",9,"Ëîæ",4,"ËïÑËïÖËïÜËïáËïã",10],["ca80","ËïóËïòËïöËïõËïúËïùËïü",4,"Ëï•Ëï¶ËïßËï©",8,"Ëï≥ËïµËï∂Ëï∑Ëï∏ËïºËïΩËïøËñÄËñÅÁúÅÁõõÂâ©ËÉúÂú£Â∏àÂ§±ÁãÆÊñΩÊπøËØóÂ∞∏Ëô±ÂçÅÁü≥ÊãæÊó∂‰ªÄÈ£üËöÄÂÆûËØÜÂè≤Áü¢‰ΩøÂ±éÈ©∂ÂßãÂºèÁ§∫Â£´‰∏ñÊüø‰∫ãÊã≠Ë™ìÈÄùÂäøÊòØÂóúÂô¨ÈÄÇ‰ªï‰æçÈáäÈ•∞Ê∞èÂ∏ÇÊÅÉÂÆ§ËßÜËØïÊî∂ÊâãÈ¶ñÂÆàÂØøÊéàÂîÆÂèóÁò¶ÂÖΩËî¨Êû¢Ê¢≥ÊÆäÊäíËæìÂèîËàíÊ∑ëÁñè‰π¶ËµéÂ≠∞ÁÜüËñØÊöëÊõôÁΩ≤ËúÄÈªçÈº†Â±ûÊúØËø∞Ê†ëÊùüÊàçÁ´ñÂ¢ÖÂ∫∂Êï∞Êº±"],["cb40","ËñÇËñÉËñÜËñà",6,"Ëñê",10,"Ëñù",6,"Ëñ•Ëñ¶ËñßËñ©Ëñ´Ëñ¨Ëñ≠Ëñ±",5,"Ëñ∏Ëñ∫",6,"ËóÇ",6,"Ëóä",4,"ËóëËóí"],["cb80","ËóîËóñ",5,"Ëóù",6,"Ëó•Ëó¶ËóßËó®Ëó™",14,"ÊÅïÂà∑ËÄçÊëîË°∞Áî©Â∏ÖÊ†ìÊã¥ÈúúÂèåÁàΩË∞ÅÊ∞¥Áù°Á®éÂêÆÁû¨È°∫ËàúËØ¥Á°ïÊúîÁÉÅÊñØÊíïÂò∂ÊÄùÁßÅÂè∏‰∏ùÊ≠ªËÇÜÂØ∫Âó£Âõõ‰º∫‰ººÈ•≤Â∑≥ÊùæËÄ∏ÊÄÇÈ¢ÇÈÄÅÂÆãËÆºËØµÊêúËâòÊìûÂóΩËãèÈÖ•‰øóÁ¥†ÈÄüÁ≤üÂÉ≥Â°ëÊ∫ØÂÆøËØâËÇÉÈÖ∏ËíúÁÆóËôΩÈöãÈöèÁª•È´ìÁ¢éÂ≤ÅÁ©óÈÅÇÈößÁ•üÂ≠ôÊçüÁ¨ãËìëÊ¢≠ÂîÜÁº©ÁêêÁ¥¢ÈîÅÊâÄÂ°å‰ªñÂÆÉÂ•πÂ°î"],["cc40","ËóπËó∫ËóºËóΩËóæËòÄ",4,"ËòÜ",10,"ËòíËòìËòîËòïËòó",15,"Ëò®Ëò™",13,"ËòπËò∫ËòªËòΩËòæËòøËôÄ"],["cc80","ËôÅ",11,"ËôíËôìËôï",4,"ËôõËôúËôùËôüËô†Ëô°Ëô£",7,"Áç≠ÊåûËπãË∏èËÉéËãîÊä¨Âè∞Ê≥∞ÈÖûÂ§™ÊÄÅÊ±∞ÂùçÊëäË¥™Áò´Êª©ÂùõÊ™ÄÁó∞ÊΩ≠Ë∞≠Ë∞àÂù¶ÊØØË¢íÁ¢≥Êé¢ÂèπÁÇ≠Ê±§Â°òÊê™Â†ÇÊ£†ËÜõÂîêÁ≥ñÂÄòË∫∫Ê∑åË∂üÁÉ´ÊéèÊ∂õÊªîÁª¶ËêÑÊ°ÉÈÄÉÊ∑òÈô∂ËÆ®Â•óÁâπËó§ËÖæÁñºË™äÊ¢ØÂâîË∏¢ÈîëÊèêÈ¢òËπÑÂïº‰ΩìÊõøÂöèÊÉïÊ∂ïÂâÉÂ±âÂ§©Ê∑ªÂ°´Áî∞ÁîúÊÅ¨ËàîËÖÜÊåëÊù°Ëø¢Áú∫Ë∑≥Ë¥¥ÈìÅÂ∏ñÂéÖÂê¨ÁÉÉ"],["cd40","Ëô≠ËôØËô∞Ëô≤",6,"ËöÉ",6,"Ëöé",4,"ËöîËöñ",5,"Ëöû",4,"Ëö•Ëö¶Ëö´Ëö≠ËöÆËö≤Ëö≥Ëö∑Ëö∏ËöπËöª",4,"ËõÅËõÇËõÉËõÖËõàËõåËõçËõíËõìËõïËõñËõóËõöËõú"],["cd80","ËõùËõ†Ëõ°Ëõ¢Ëõ£Ëõ•Ëõ¶ËõßËõ®Ëõ™Ëõ´Ëõ¨ËõØËõµËõ∂Ëõ∑Ëõ∫ËõªËõºËõΩËõøËúÅËúÑËúÖËúÜËúãËúåËúéËúèËúêËúëËúîËúñÊ±ÄÂª∑ÂÅú‰∫≠Â∫≠Êå∫ËâáÈÄöÊ°êÈÖÆÁû≥ÂêåÈìúÂΩ§Á´•Ê°∂ÊçÖÁ≠íÁªüÁóõÂÅ∑ÊäïÂ§¥ÈÄèÂá∏ÁßÉÁ™ÅÂõæÂæíÈÄîÊ∂ÇÂ±†ÂúüÂêêÂÖîÊπçÂõ¢Êé®È¢ìËÖøËúïË§™ÈÄÄÂêûÂ±ØËáÄÊãñÊâòËÑ±È∏µÈôÄÈ©ÆÈ©ºÊ§≠Â¶•ÊãìÂîæÊåñÂìáËõôÊ¥ºÂ®ÉÁì¶Ë¢úÊ≠™Â§ñË±åÂºØÊπæÁé©È°Ω‰∏∏ÁÉ∑ÂÆåÁ¢óÊåΩÊôöÁöñÊÉãÂÆõÂ©â‰∏áËÖïÊ±™Áéã‰∫°ÊûâÁΩëÂæÄÊó∫ÊúõÂøòÂ¶ÑÂ®Å"],["ce40","ËúôËúõËúùËúüËú†Ëú§Ëú¶ËúßËú®Ëú™Ëú´Ëú¨Ëú≠ËúØËú∞Ëú≤Ëú≥ËúµËú∂Ëú∏ËúπËú∫ËúºËúΩËùÄ",6,"ËùäËùãËùçËùèËùêËùëËùíËùîËùïËùñËùòËùö",5,"Ëù°Ëù¢Ëù¶",7,"ËùØËù±Ëù≤Ëù≥Ëùµ"],["ce80","Ëù∑Ëù∏ËùπËù∫ËùøËûÄËûÅËûÑËûÜËûáËûâËûäËûåËûé",4,"ËûîËûïËûñËûò",6,"Ëû†",4,"Â∑çÂæÆÂç±Èü¶ËøùÊ°ÖÂõ¥ÂîØÊÉü‰∏∫ÊΩçÁª¥ËãáËêéÂßî‰ºü‰º™Â∞æÁ∫¨Êú™ËîöÂë≥ÁïèËÉÉÂñÇÈ≠è‰ΩçÊ∏≠Ë∞ìÂ∞âÊÖ∞Âç´ÁòüÊ∏©ËöäÊñáÈóªÁ∫πÂêªÁ®≥Á¥äÈóÆÂó°ÁøÅÁìÆÊåùËúóÊ∂°Á™ùÊàëÊñ°ÂçßÊè°Ê≤ÉÂ∑´ÂëúÈí®‰πåÊ±°ËØ¨Â±ãÊó†ËäúÊ¢ßÂêæÂê¥ÊØãÊ≠¶‰∫îÊçÇÂçàËàû‰ºç‰æÆÂùûÊàäÈõæÊô§Áâ©ÂãøÂä°ÊÇüËØØÊòîÁÜôÊûêË•øÁ°íÁüΩÊô∞ÂòªÂê∏Èî°Áâ∫"],["cf40","Ëû•Ëû¶ËûßËû©Ëû™ËûÆËû∞Ëû±Ëû≤Ëû¥Ëû∂Ëû∑Ëû∏ËûπËûªËûºËûæËûøËüÅ",4,"ËüáËüàËüâËüå",4,"Ëüî",6,"ËüúËüùËüûËüüËü°Ëü¢Ëü£Ëü§Ëü¶ËüßËü®Ëü©Ëü´Ëü¨Ëü≠ËüØ",9],["cf80","Ëü∫ËüªËüºËüΩËüøË†ÄË†ÅË†ÇË†Ñ",5,"Ë†ã",7,"Ë†îË†óË†òË†ôË†öË†ú",4,"Ë†£Á®ÄÊÅØÂ∏åÊÇâËÜùÂ§ïÊÉúÁÜÑÁÉØÊ∫™Ê±êÁäÄÊ™ÑË¢≠Â∏≠‰π†Â™≥ÂñúÈì£Ê¥óÁ≥ªÈöôÊàèÁªÜÁûéËôæÂå£ÈúûËæñÊöáÂ≥°‰æ†Áã≠‰∏ãÂé¶Â§èÂêìÊéÄÈî®ÂÖà‰ªôÈ≤úÁ∫§Âí∏Ë¥§Ë°îËà∑Èó≤Ê∂éÂº¶Â´åÊòæÈô©Áé∞ÁåÆÂéøËÖ∫È¶ÖÁæ°ÂÆ™Èô∑ÈôêÁ∫øÁõ∏Âé¢Èï∂È¶ôÁÆ±Ë•ÑÊπò‰π°ÁøîÁ••ËØ¶ÊÉ≥Âìç‰∫´È°πÂ∑∑Ê©°ÂÉèÂêëË±°ËêßÁ°ùÈúÑÂâäÂìÆÂö£ÈîÄÊ∂àÂÆµÊ∑ÜÊôì"],["d040","Ë†§",13,"Ë†≥",5,"Ë†∫Ë†ªË†ΩË†æË†øË°ÅË°ÇË°ÉË°Ü",5,"Ë°é",5,"Ë°ïË°ñË°òË°ö",6,"Ë°¶Ë°ßË°™Ë°≠Ë°ØË°±Ë°≥Ë°¥Ë°µË°∂Ë°∏Ë°πË°∫"],["d080","Ë°ªË°ºË¢ÄË¢ÉË¢ÜË¢áË¢âË¢äË¢åË¢éË¢èË¢êË¢ëË¢ìË¢îË¢ïË¢ó",4,"Ë¢ù",4,"Ë¢£Ë¢•",5,"Â∞èÂ≠ùÊ†°ËÇñÂï∏Á¨ëÊïàÊ•î‰∫õÊ≠áËùéÈûãÂçèÊåüÊê∫ÈÇ™ÊñúËÉÅË∞êÂÜôÊ¢∞Âç∏ËüπÊáàÊ≥ÑÊ≥ªË∞¢Â±ëËñ™ËäØÈîåÊ¨£ËæõÊñ∞ÂøªÂøÉ‰ø°Ë°ÖÊòüËÖ•Áå©ÊÉ∫ÂÖ¥ÂàëÂûãÂΩ¢ÈÇ¢Ë°åÈÜíÂπ∏ÊùèÊÄßÂßìÂÖÑÂá∂ËÉ∏ÂåàÊ±πÈõÑÁÜä‰ºë‰øÆÁæûÊúΩÂóÖÈîàÁßÄË¢ñÁª£Â¢üÊàåÈúÄËôöÂòòÈ°ªÂæêËÆ∏ËìÑÈÖóÂèôÊó≠Â∫èÁïúÊÅ§ÁµÆÂ©øÁª™Áª≠ËΩ©ÂñßÂÆ£ÊÇ¨ÊóãÁéÑ"],["d140","Ë¢¨Ë¢ÆË¢ØË¢∞Ë¢≤",4,"Ë¢∏Ë¢πË¢∫Ë¢ªË¢ΩË¢æË¢øË£ÄË£ÉË£ÑË£áË£àË£äË£ãË£åË£çË£èË£êË£ëË£ìË£ñË£óË£ö",4,"Ë£†Ë£°Ë£¶Ë£ßË£©",6,"Ë£≤Ë£µË£∂Ë£∑Ë£∫Ë£ªË£ΩË£øË§ÄË§ÅË§É",5],["d180","Ë§âË§ã",4,"Ë§ëË§î",4,"Ë§ú",4,"Ë§¢Ë§£Ë§§Ë§¶Ë§ßË§®Ë§©Ë§¨Ë§≠Ë§ÆË§ØË§±Ë§≤Ë§≥Ë§µË§∑ÈÄâÁô£Áú©ÁªöÈù¥ËñõÂ≠¶Á©¥Èõ™Ë°ÄÂããÁÜèÂæ™Êó¨ËØ¢ÂØªÈ©ØÂ∑°ÊÆâÊ±õËÆ≠ËÆØÈÄäËøÖÂéãÊäºÈ∏¶È∏≠ÂëÄ‰∏´ËäΩÁâôËöúÂ¥ñË°ôÊ∂ØÈõÖÂìë‰∫öËÆ∂ÁÑâÂíΩÈòâÁÉüÊ∑πÁõê‰∏•Á†îËúíÂ≤©Âª∂Ë®ÄÈ¢úÈòéÁÇéÊ≤øÂ•ÑÊé©ÁúºË°çÊºîËâ≥Â†∞ÁáïÂéåÁ†öÈõÅÂîÅÂΩ¶ÁÑ∞ÂÆ¥Ë∞öÈ™åÊÆÉÂ§ÆÈ∏ØÁßßÊù®Êâ¨‰ΩØÁñ°ÁæäÊ¥ãÈò≥Ê∞ß‰ª∞ÁóíÂÖªÊ†∑ÊºæÈÇÄËÖ∞Â¶ñÁë∂"],["d240","Ë§∏",8,"Ë•ÇË•ÉË•Ö",24,"Ë•†",5,"Ë•ß",19,"Ë•º"],["d280","Ë•ΩË•æË¶ÄË¶ÇË¶ÑË¶ÖË¶á",26,"ÊëáÂ∞ßÈÅ•Á™ëË∞£ÂßöÂí¨ËàÄËçØË¶ÅËÄÄÊ§∞ÂôéËÄ∂Áà∑ÈáéÂÜ∂‰πüÈ°µÊéñ‰∏öÂè∂Êõ≥ËÖãÂ§úÊ∂≤‰∏ÄÂ£πÂåªÊèñÈì±‰æù‰ºäË°£È¢êÂ§∑ÈÅóÁßª‰ª™ËÉ∞ÁñëÊ≤ÇÂÆúÂß®ÂΩùÊ§ÖËöÅÂÄöÂ∑≤‰πôÁü£‰ª•Ëâ∫ÊäëÊòìÈÇëÂ±π‰∫øÂΩπËáÜÈÄ∏ËÇÑÁñ´‰∫¶Ë£îÊÑèÊØÖÂøÜ‰πâÁõäÊ∫¢ËØ£ËÆÆË∞äËØëÂºÇÁøºÁøåÁªéËåµËç´Âõ†ÊÆ∑Èü≥Èò¥ÂßªÂêüÈì∂Ê∑´ÂØÖÈ•ÆÂ∞πÂºïÈöê"],["d340","Ë¶¢",30,"ËßÉËßçËßìËßîËßïËßóËßòËßôËßõËßùËßüËß†Ëß°Ëß¢Ëß§ËßßËß®Ëß©Ëß™Ëß¨Ëß≠ËßÆËß∞Ëß±Ëß≤Ëß¥",6],["d380","Ëßª",4,"Ë®Å",5,"Ë®à",21,"Âç∞Ëã±Ê®±Â©¥Èπ∞Â∫îÁº®ËéπËê§Ëê•ËçßËùáËøéËµ¢ÁõàÂΩ±È¢ñÁ°¨Êò†ÂìüÊã•‰Ω£ËáÉÁóàÂ∫∏ÈõçË∏äËõπÂíèÊ≥≥Ê∂åÊ∞∏ÊÅøÂãáÁî®ÂπΩ‰ºòÊÇ†ÂøßÂ∞§Áî±ÈÇÆÈìÄÁäπÊ≤πÊ∏∏ÈÖâÊúâÂèãÂè≥‰ΩëÈáâËØ±ÂèàÂπºËøÇÊ∑§‰∫éÁõÇÊ¶ÜËôûÊÑöËàÜ‰Ωô‰øûÈÄæÈ±ºÊÑâÊ∏ùÊ∏îÈöÖ‰∫àÂ®±Èõ®‰∏éÂ±øÁ¶πÂÆáËØ≠ÁæΩÁéâÂüüËäãÈÉÅÂêÅÈÅáÂñªÂ≥™Âæ°ÊÑàÊ¨≤Áã±ËÇ≤Ë™â"],["d440","Ë®û",31,"Ë®ø",8,"Ë©â",21],["d480","Ë©ü",25,"Ë©∫",6,"Êµ¥ÂØìË£ïÈ¢ÑË±´È©≠È∏≥Ê∏äÂÜ§ÂÖÉÂû£Ë¢ÅÂéüÊè¥ËæïÂõ≠ÂëòÂúÜÁåøÊ∫êÁºòËøúËãëÊÑøÊÄ®Èô¢Êõ∞Á∫¶Ë∂äË∑ÉÈí•Â≤≥Á≤§ÊúàÊÇ¶ÈòÖËÄò‰∫ëÈÉßÂåÄÈô®ÂÖÅËøêËï¥ÈÖùÊôïÈüµÂ≠ïÂåùÁ†∏ÊùÇÊ†ΩÂìâÁÅæÂÆ∞ËΩΩÂÜçÂú®Âí±ÊîíÊöÇËµûËµÉËÑèËë¨ÈÅ≠Á≥üÂáøËóªÊû£Êó©Êæ°Ëö§Ë∫ÅÂô™ÈÄ†ÁöÇÁÅ∂Áá•Ë¥£Êã©ÂàôÊ≥ΩË¥ºÊÄéÂ¢ûÊÜéÊõæËµ†ÊâéÂñ≥Ê∏£Êú≠ËΩß"],["d540","Ë™Å",7,"Ë™ã",7,"Ë™î",46],["d580","Ë´É",32,"Èì°Èó∏Áú®Ê†ÖÊ¶®Âíã‰πçÁÇ∏ËØàÊëòÊñãÂÆÖÁ™ÑÂÄ∫ÂØ®ÁûªÊØ°Ë©πÁ≤òÊ≤æÁõèÊñ©ËæóÂ¥≠Â±ïËò∏Ê†àÂç†ÊàòÁ´ôÊπõÁªΩÊ®üÁ´†ÂΩ∞Êº≥Âº†ÊéåÊ∂®Êùñ‰∏àÂ∏êË¥¶‰ªóËÉÄÁò¥ÈöúÊãõÊò≠ÊâæÊ≤ºËµµÁÖßÁΩ©ÂÖÜËÇáÂè¨ÈÅÆÊäòÂì≤Ëõ∞ËæôËÄÖÈîóËîóËøôÊµôÁèçÊñüÁúüÁîÑÁ†ßËáªË¥ûÈíà‰æ¶ÊûïÁñπËØäÈúáÊåØÈïáÈòµËí∏Êå£ÁùÅÂæÅÁã∞‰∫âÊÄîÊï¥ÊãØÊ≠£Êîø"],["d640","Ë´§",34,"Ë¨à",27],["d680","Ë¨§Ë¨•Ë¨ß",30,"Â∏ßÁóáÈÉëËØÅËäùÊûùÊîØÂê±ËúòÁü•ËÇ¢ËÑÇÊ±Å‰πãÁªáËÅåÁõ¥Ê§çÊÆñÊâßÂÄº‰æÑÂùÄÊåáÊ≠¢Ë∂æÂè™Êó®Á∫∏ÂøóÊåöÊé∑Ëá≥Ëá¥ÁΩÆÂ∏úÂ≥ôÂà∂Êô∫Áß©Á®öË¥®ÁÇôÁóîÊªûÊ≤ªÁ™í‰∏≠ÁõÖÂø†ÈíüË°∑ÁªàÁßçËÇøÈáç‰ª≤‰ºóËàüÂë®Â∑ûÊ¥≤ËØåÁ≤•ËΩ¥ËÇòÂ∏öÂííÁö±ÂÆôÊòºÈ™§Áè†Ê†™ËõõÊú±Áå™ËØ∏ËØõÈÄêÁ´πÁÉõÁÖÆÊãÑÁû©Âò±‰∏ªËëóÊü±Âä©ËõÄË¥ÆÈì∏Á≠ë"],["d740","Ë≠Ü",31,"Ë≠ß",4,"Ë≠≠",25],["d780","ËÆá",24,"ËÆ¨ËÆ±ËÆªËØáËØêËØ™Ë∞âË∞û‰ΩèÊ≥®Á•ùÈ©ªÊäìÁà™ÊãΩ‰∏ìÁ†ñËΩ¨Êí∞ËµöÁØÜÊ°©Â∫ÑË£ÖÂ¶ÜÊíûÂ£ÆÁä∂Ê§éÈî•ËøΩËµòÂù†ÁºÄË∞ÜÂáÜÊçâÊãôÂçìÊ°åÁê¢ËåÅÈÖåÂïÑÁùÄÁÅºÊµäÂÖπÂí®ËµÑÂßøÊªãÊ∑ÑÂ≠úÁ¥´‰ªîÁ±ΩÊªìÂ≠êËá™Ê∏çÂ≠óÈ¨ÉÊ£ïË∏™ÂÆóÁªºÊÄªÁ∫µÈÇπËµ∞Â•èÊèçÁßüË∂≥ÂçíÊóèÁ•ñËØÖÈòªÁªÑÈíªÁ∫ÇÂò¥ÈÜâÊúÄÁΩ™Â∞äÈÅµÊò®Â∑¶‰ΩêÊüûÂÅö‰ΩúÂùêÂ∫ß"],["d840","Ë∞∏",8,"Ë±ÇË±ÉË±ÑË±ÖË±àË±äË±ãË±ç",7,"Ë±ñË±óË±òË±ôË±õ",5,"Ë±£",6,"Ë±¨",6,"Ë±¥Ë±µË±∂Ë±∑Ë±ª",6,"Ë≤ÉË≤ÑË≤ÜË≤á"],["d880","Ë≤àË≤ãË≤ç",6,"Ë≤ïË≤ñË≤óË≤ô",20,"‰∫ç‰∏åÂÖÄ‰∏êÂªøÂçÖ‰∏ï‰∫ò‰∏ûÈ¨≤Â≠¨Âô©‰∏®Á¶∫‰∏øÂåï‰πáÂ§≠ÁàªÂçÆÊ∞êÂõüËÉ§È¶óÊØìÁùæÈºó‰∏∂‰∫üÈºê‰πú‰π©‰∫ìËäàÂ≠õÂï¨Âòè‰ªÑÂéçÂéùÂé£Âé•ÂéÆÈù•ËµùÂåöÂèµÂå¶ÂåÆÂåæËµúÂç¶Âç£ÂàÇÂààÂàéÂà≠Âà≥ÂàøÂâÄÂâåÂâûÂâ°ÂâúËíØÂâΩÂäÇÂäÅÂäêÂäìÂÜÇÁΩî‰∫ª‰ªÉ‰ªâ‰ªÇ‰ª®‰ª°‰ª´‰ªû‰ºõ‰ª≥‰º¢‰Ω§‰ªµ‰º•‰ºß‰ºâ‰º´‰Ωû‰ΩßÊî∏‰Ωö‰Ωù"],["d940","Ë≤Æ",62],["d980","Ë≥≠",32,"‰Ωü‰Ωó‰º≤‰ºΩ‰Ω∂‰Ω¥‰æë‰æâ‰æÉ‰æè‰Ωæ‰Ωª‰æ™‰Ωº‰æ¨‰æî‰ø¶‰ø®‰ø™‰øÖ‰øö‰ø£‰øú‰øë‰øü‰ø∏ÂÄ©ÂÅå‰ø≥ÂÄ¨ÂÄèÂÄÆÂÄ≠‰øæÂÄúÂÄåÂÄ•ÂÄ®ÂÅæÂÅÉÂÅïÂÅàÂÅéÂÅ¨ÂÅªÂÇ•ÂÇßÂÇ©ÂÇ∫ÂÉñÂÑÜÂÉ≠ÂÉ¨ÂÉ¶ÂÉÆÂÑáÂÑã‰ªùÊ∞Ω‰Ωò‰Ω•‰øéÈæ†Ê±ÜÁ±¥ÂÖÆÂ∑ΩÈªâÈ¶òÂÜÅÂ§îÂãπÂåçË®áÂåêÂá´Â§ôÂÖï‰∫†ÂÖñ‰∫≥Ë°ÆË¢§‰∫µËÑîË£íÁ¶ÄÂ¨¥Ë†ÉÁæ∏ÂÜ´ÂÜ±ÂÜΩÂÜº"],["da40","Ë¥é",14,"Ë¥†ËµëËµíËµóËµüËµ•Ëµ®Ëµ©Ëµ™Ëµ¨ËµÆËµØËµ±Ëµ≤Ëµ∏",8,"Ë∂ÇË∂ÉË∂ÜË∂áË∂àË∂âË∂å",4,"Ë∂íË∂ìË∂ï",9,"Ë∂†Ë∂°"],["da80","Ë∂¢Ë∂§",12,"Ë∂≤Ë∂∂Ë∂∑Ë∂πË∂ªË∂ΩË∑ÄË∑ÅË∑ÇË∑ÖË∑áË∑àË∑âË∑äË∑çË∑êË∑íË∑ìË∑îÂááÂÜñÂÜ¢ÂÜ•ËÆ†ËÆ¶ËÆßËÆ™ËÆ¥ËÆµËÆ∑ËØÇËØÉËØãËØèËØéËØíËØìËØîËØñËØòËØôËØúËØüËØ†ËØ§ËØ®ËØ©ËØÆËØ∞ËØ≥ËØ∂ËØπËØºËØøË∞ÄË∞ÇË∞ÑË∞áË∞åË∞èË∞ëË∞íË∞îË∞ïË∞ñË∞ôË∞õË∞òË∞ùË∞üË∞†Ë∞°Ë∞•Ë∞ßË∞™Ë∞´Ë∞ÆË∞ØË∞≤Ë∞≥Ë∞µË∞∂Âç©Âç∫ÈòùÈò¢Èò°Èò±Èò™ÈòΩÈòºÈôÇÈôâÈôîÈôüÈôßÈô¨Èô≤Èô¥ÈöàÈöçÈöóÈö∞ÈÇóÈÇõÈÇùÈÇôÈÇ¨ÈÇ°ÈÇ¥ÈÇ≥ÈÇ∂ÈÇ∫"],["db40","Ë∑ïË∑òË∑ôË∑úË∑†Ë∑°Ë∑¢Ë∑•Ë∑¶Ë∑ßË∑©Ë∑≠Ë∑ÆË∑∞Ë∑±Ë∑≤Ë∑¥Ë∑∂Ë∑ºË∑æ",6,"Ë∏ÜË∏áË∏àË∏ãË∏çË∏éË∏êË∏ëË∏íË∏ìË∏ï",7,"Ë∏†Ë∏°Ë∏§",4,"Ë∏´Ë∏≠Ë∏∞Ë∏≤Ë∏≥Ë∏¥Ë∏∂Ë∏∑Ë∏∏Ë∏ªË∏ºË∏æ"],["db80","Ë∏øËπÉËπÖËπÜËπå",4,"Ëπì",5,"Ëπö",11,"ËπßËπ®Ëπ™Ëπ´ËπÆËπ±ÈÇ∏ÈÇ∞ÈÉèÈÉÖÈÇæÈÉêÈÉÑÈÉáÈÉìÈÉ¶ÈÉ¢ÈÉúÈÉóÈÉõÈÉ´ÈÉØÈÉæÈÑÑÈÑ¢ÈÑûÈÑ£ÈÑ±ÈÑØÈÑπÈÖÉÈÖÜÂàçÂ•ÇÂä¢Âä¨Âä≠ÂäæÂìøÂãêÂãñÂã∞ÂèüÁáÆÁüçÂª¥ÂáµÂáºÈ¨ØÂé∂ÂºÅÁïöÂ∑ØÂùåÂû©Âû°Â°æÂ¢ºÂ£ÖÂ£ëÂú©Âú¨Âú™Âú≥ÂúπÂúÆÂúØÂùúÂúªÂùÇÂù©ÂûÖÂù´ÂûÜÂùºÂùªÂù®Âù≠Âù∂Âù≥Âû≠Âû§ÂûåÂû≤ÂüèÂûßÂû¥ÂûìÂû†ÂüïÂüòÂüöÂüôÂüíÂû∏Âü¥ÂüØÂü∏Âü§Âüù"],["dc40","Ëπ≥ËπµËπ∑",4,"ËπΩËπæË∫ÄË∫ÇË∫ÉË∫ÑË∫ÜË∫à",6,"Ë∫ëË∫íË∫ìË∫ï",6,"Ë∫ùË∫ü",11,"Ë∫≠Ë∫ÆË∫∞Ë∫±Ë∫≥",6,"Ë∫ª",7],["dc80","ËªÉ",10,"Ëªè",21,"Â†ãÂ†çÂüΩÂü≠Â†ÄÂ†ûÂ†ôÂ°ÑÂ††Â°•Â°¨Â¢ÅÂ¢âÂ¢öÂ¢ÄÈ¶®ÈºôÊáøËâπËâΩËâøËäèËääËä®ËäÑËäéËäëËäóËäôËä´Ëä∏ËäæËä∞ËãàËãäËã£ËäòËä∑ËäÆËããËãåËãÅËä©Ëä¥Ëä°Ëä™ËäüËãÑËãéËä§Ëã°ËåâËã∑Ëã§ËåèËåáËãúËã¥ËãíËãòËååËãªËãìËåëËåöËåÜËåîËåïËã†ËãïËåúËçëËçõËçúËåàËéíËåºËå¥Ëå±ËéõËçûËåØËçèËçáËçÉËçüËçÄËåóËç†Ëå≠Ëå∫Ëå≥Ëç¶Ëç•"],["dd40","Ëª•",62],["dd80","Ëº§",32,"Ëç®ËåõËç©Ëç¨Ëç™Ëç≠ËçÆËé∞Ëç∏Ëé≥Ëé¥Ëé†Ëé™ËéìËéúËéÖËçºËé∂Ëé©ËçΩËé∏ËçªËéòËéûËé®Ëé∫ËéºËèÅËêÅËè•ËèòÂ†áËêòËêãËèùËèΩËèñËêúËê∏ËêëËêÜËèîËèüËêèËêÉËè∏ËèπËè™ËèÖËèÄËê¶Ëè∞Ëè°ËëúËëëËëöËëôËë≥ËíáËíàËë∫ËíâËë∏ËêºËëÜËë©Ëë∂ËíåËíéËê±Ëë≠ËìÅËìçËìêËì¶ËíΩËììËìäËíøËí∫Ëì†Ëí°ËíπËí¥ËíóËì•Ëì£ËîåÁîçËî∏Ëì∞ËîπËîüËî∫"],["de40","ËΩÖ",32,"ËΩ™ËæÄËæåËæíËæùËæ†Ëæ°Ëæ¢Ëæ§Ëæ•Ëæ¶ËæßËæ™Ëæ¨Ëæ≠ËæÆËæØËæ≤Ëæ≥Ëæ¥ËæµËæ∑Ëæ∏Ëæ∫ËæªËæºËæøËøÄËøÉËøÜ"],["de80","Ëøâ",4,"ËøèËøíËøñËøóËøöËø†Ëø°Ëø£ËøßËø¨ËøØËø±Ëø≤Ëø¥ËøµËø∂Ëø∫ËøªËøºËøæËøøÈÄáÈÄàÈÄåÈÄéÈÄìÈÄïÈÄòËïñËîªËìøËìºËïôËïàËï®Ëï§ËïûËï∫Áû¢ËïÉËï≤ËïªËñ§Ëñ®ËñáËñèËïπËñÆËñúËñÖËñπËñ∑Ëñ∞ËóìËóÅËóúËóøËòßËòÖËò©ËòñËòºÂªæÂºàÂ§ºÂ•ÅËÄ∑Â•ïÂ•öÂ•òÂåèÂ∞¢Â∞•Â∞¨Â∞¥ÊâåÊâ™ÊäüÊäªÊãäÊãöÊãóÊãÆÊå¢Êã∂ÊåπÊçãÊçÉÊé≠Êè∂Êç±Êç∫ÊééÊé¥Êç≠Êé¨ÊéäÊç©ÊéÆÊéºÊè≤Êè∏Êè†ÊèøÊèÑÊèûÊèéÊëíÊèÜÊéæÊëÖÊëÅÊêãÊêõÊê†ÊêåÊê¶Êê°ÊëûÊíÑÊë≠Êíñ"],["df40","ÈÄôÈÄúÈÄ£ÈÄ§ÈÄ•ÈÄß",5,"ÈÄ∞",4,"ÈÄ∑ÈÄπÈÄ∫ÈÄΩÈÄøÈÅÄÈÅÉÈÅÖÈÅÜÈÅà",4,"ÈÅéÈÅîÈÅïÈÅñÈÅôÈÅöÈÅú",5,"ÈÅ§ÈÅ¶ÈÅßÈÅ©ÈÅ™ÈÅ´ÈÅ¨ÈÅØ",4,"ÈÅ∂",6,"ÈÅæÈÇÅ"],["df80","ÈÇÑÈÇÖÈÇÜÈÇáÈÇâÈÇäÈÇå",4,"ÈÇíÈÇîÈÇñÈÇòÈÇöÈÇúÈÇûÈÇüÈÇ†ÈÇ§ÈÇ•ÈÇßÈÇ®ÈÇ©ÈÇ´ÈÇ≠ÈÇ≤ÈÇ∑ÈÇºÈÇΩÈÇøÈÉÄÊë∫Êí∑Êí∏ÊíôÊí∫ÊìÄÊìêÊìóÊì§Êì¢ÊîâÊî•ÊîÆÂºãÂøíÁîôÂºëÂçüÂè±ÂèΩÂè©Âè®ÂèªÂêíÂêñÂêÜÂëãÂëíÂëìÂëîÂëñÂëÉÂê°ÂëóÂëôÂê£Âê≤ÂíÇÂíîÂë∑Âë±Âë§ÂíöÂíõÂíÑÂë∂Âë¶ÂíùÂìêÂí≠ÂìÇÂí¥ÂìíÂíßÂí¶ÂììÂìîÂë≤Âí£ÂìïÂíªÂíøÂìåÂìôÂìöÂìúÂí©Âí™Âí§ÂìùÂìèÂìûÂîõÂìßÂî†ÂìΩÂîîÂì≥Âî¢Âî£ÂîèÂîëÂîßÂî™ÂïßÂñèÂñµÂïâÂï≠ÂïÅÂïïÂîøÂïêÂîº"],["e040","ÈÉÇÈÉÉÈÉÜÈÉàÈÉâÈÉãÈÉåÈÉçÈÉíÈÉîÈÉïÈÉñÈÉòÈÉôÈÉöÈÉûÈÉüÈÉ†ÈÉ£ÈÉ§ÈÉ•ÈÉ©ÈÉ™ÈÉ¨ÈÉÆÈÉ∞ÈÉ±ÈÉ≤ÈÉ≥ÈÉµÈÉ∂ÈÉ∑ÈÉπÈÉ∫ÈÉªÈÉºÈÉøÈÑÄÈÑÅÈÑÉÈÑÖ",19,"ÈÑöÈÑõÈÑú"],["e080","ÈÑùÈÑüÈÑ†ÈÑ°ÈÑ§",10,"ÈÑ∞ÈÑ≤",6,"ÈÑ∫",8,"ÈÖÑÂî∑ÂïñÂïµÂï∂Âï∑Âî≥Âî∞ÂïúÂñãÂóíÂñÉÂñ±ÂñπÂñàÂñÅÂñüÂïæÂóñÂñëÂïªÂóüÂñΩÂñæÂñîÂñôÂó™Âó∑ÂóâÂòüÂóëÂó´Âó¨ÂóîÂó¶ÂóùÂóÑÂóØÂó•Âó≤Âó≥ÂóåÂóçÂó®ÂóµÂó§ËæîÂòûÂòàÂòåÂòÅÂò§Âò£ÂóæÂòÄÂòßÂò≠ÂôòÂòπÂôóÂò¨ÂôçÂô¢ÂôôÂôúÂôåÂôîÂöÜÂô§Âô±Âô´ÂôªÂôºÂöÖÂöìÂöØÂõîÂõóÂõùÂõ°ÂõµÂõ´ÂõπÂõøÂúÑÂúäÂúâÂúúÂ∏èÂ∏ôÂ∏îÂ∏ëÂ∏±Â∏ªÂ∏º"],["e140","ÈÖÖÈÖáÈÖàÈÖëÈÖìÈÖîÈÖïÈÖñÈÖòÈÖôÈÖõÈÖúÈÖüÈÖ†ÈÖ¶ÈÖßÈÖ®ÈÖ´ÈÖ≠ÈÖ≥ÈÖ∫ÈÖªÈÖºÈÜÄ",4,"ÈÜÜÈÜàÈÜäÈÜéÈÜèÈÜì",6,"ÈÜú",5,"ÈÜ§",5,"ÈÜ´ÈÜ¨ÈÜ∞ÈÜ±ÈÜ≤ÈÜ≥ÈÜ∂ÈÜ∑ÈÜ∏ÈÜπÈÜª"],["e180","ÈÜº",10,"ÈáàÈáãÈáêÈáí",9,"Èáù",8,"Â∏∑ÂπÑÂπîÂπõÂπûÂπ°Â≤åÂ±∫Â≤çÂ≤êÂ≤ñÂ≤àÂ≤òÂ≤ôÂ≤ëÂ≤öÂ≤úÂ≤µÂ≤¢Â≤ΩÂ≤¨Â≤´Â≤±Â≤£Â≥ÅÂ≤∑Â≥ÑÂ≥íÂ≥§Â≥ãÂ≥•Â¥ÇÂ¥ÉÂ¥ßÂ¥¶Â¥ÆÂ¥§Â¥ûÂ¥ÜÂ¥õÂµòÂ¥æÂ¥¥Â¥ΩÂµ¨ÂµõÂµØÂµùÂµ´ÂµãÂµäÂµ©Âµ¥Â∂ÇÂ∂ôÂ∂ùË±≥Â∂∑Â∑ÖÂΩ≥ÂΩ∑ÂæÇÂæáÂæâÂæåÂæïÂæôÂæúÂæ®Âæ≠ÂæµÂæºË°¢ÂΩ°Áä≠Áä∞Áä¥Áä∑Áä∏ÁãÉÁãÅÁãéÁãçÁãíÁã®ÁãØÁã©Áã≤Áã¥Áã∑ÁåÅÁã≥ÁåÉÁã∫"],["e240","Èá¶",62],["e280","Èà•",32,"ÁãªÁåóÁåìÁå°ÁåäÁåûÁåùÁåïÁå¢ÁåπÁå•Áå¨Áå∏Áå±ÁçêÁççÁçóÁç†Áç¨ÁçØÁçæËàõÂ§•È£ßÂ§§Â§ÇÈ•£È•ß",5,"È•¥È•∑È•ΩÈ¶ÄÈ¶ÑÈ¶áÈ¶äÈ¶çÈ¶êÈ¶ëÈ¶ìÈ¶îÈ¶ïÂ∫ÄÂ∫ëÂ∫ãÂ∫ñÂ∫•Â∫†Â∫πÂ∫µÂ∫æÂ∫≥ËµìÂªíÂªëÂªõÂª®Âª™ËÜ∫ÂøÑÂøâÂøñÂøèÊÄÉÂøÆÊÄÑÂø°Âø§ÂøæÊÄÖÊÄÜÂø™Âø≠Âø∏ÊÄôÊÄµÊÄ¶ÊÄõÊÄèÊÄçÊÄ©ÊÄ´ÊÄäÊÄøÊÄ°ÊÅ∏ÊÅπÊÅªÊÅ∫ÊÅÇ"],["e340","ÈâÜ",45,"Èâµ",16],["e380","ÈäÜ",7,"Èäè",24,"ÊÅ™ÊÅΩÊÇñÊÇöÊÇ≠ÊÇùÊÇÉÊÇíÊÇåÊÇõÊÉ¨ÊÇªÊÇ±ÊÉùÊÉòÊÉÜÊÉöÊÇ¥ÊÑ†ÊÑ¶ÊÑïÊÑ£ÊÉ¥ÊÑÄÊÑéÊÑ´ÊÖäÊÖµÊÜ¨ÊÜîÊÜßÊÜ∑ÊáîÊáµÂøùÈö≥Èó©Èó´Èó±Èó≥ÈóµÈó∂ÈóºÈóæÈòÉÈòÑÈòÜÈòàÈòäÈòãÈòåÈòçÈòèÈòíÈòïÈòñÈòóÈòôÈòö‰∏¨ÁàøÊàïÊ∞µÊ±îÊ±úÊ±äÊ≤£Ê≤ÖÊ≤êÊ≤îÊ≤åÊ±®Ê±©Ê±¥Ê±∂Ê≤ÜÊ≤©Ê≥êÊ≥îÊ≤≠Ê≥∑Ê≥∏Ê≥±Ê≥óÊ≤≤Ê≥†Ê≥ñÊ≥∫Ê≥´Ê≥ÆÊ≤±Ê≥ìÊ≥ØÊ≥æ"],["e440","Èä®",5,"ÈäØ",24,"Èãâ",31],["e480","Èã©",32,"Ê¥πÊ¥ßÊ¥åÊµÉÊµàÊ¥áÊ¥ÑÊ¥ôÊ¥éÊ¥´ÊµçÊ¥ÆÊ¥µÊ¥öÊµèÊµíÊµîÊ¥≥Ê∂ëÊµØÊ∂ûÊ∂†ÊµûÊ∂ìÊ∂îÊµúÊµ†ÊµºÊµ£Ê∏öÊ∑áÊ∑ÖÊ∑ûÊ∏éÊ∂øÊ∑†Ê∏ëÊ∑¶Ê∑ùÊ∑ôÊ∏ñÊ∂´Ê∏åÊ∂ÆÊ∏´ÊπÆÊπéÊπ´Ê∫≤ÊπüÊ∫ÜÊπìÊπîÊ∏≤Ê∏•ÊπÑÊªüÊ∫±Ê∫òÊª†Êº≠Êª¢Ê∫•Ê∫ßÊ∫ΩÊ∫ªÊ∫∑ÊªóÊ∫¥ÊªèÊ∫èÊªÇÊ∫üÊΩ¢ÊΩÜÊΩáÊº§ÊºïÊªπÊºØÊº∂ÊΩãÊΩ¥Êº™ÊºâÊº©ÊæâÊæçÊæåÊΩ∏ÊΩ≤ÊΩºÊΩ∫Êøë"],["e540","Èåä",51,"Èåø",10],["e580","Èçä",31,"Èç´ÊøâÊæßÊæπÊæ∂ÊøÇÊø°ÊøÆÊøûÊø†ÊøØÁÄöÁÄ£ÁÄõÁÄπÁÄµÁÅèÁÅûÂÆÄÂÆÑÂÆïÂÆìÂÆ•ÂÆ∏ÁîØÈ™ûÊê¥ÂØ§ÂØÆË§∞ÂØ∞ËπáË¨áËæ∂ËøìËøïËø•ËøÆËø§Ëø©Ëø¶Ëø≥Ëø®ÈÄÖÈÄÑÈÄãÈÄ¶ÈÄëÈÄçÈÄñÈÄ°ÈÄµÈÄ∂ÈÄ≠ÈÄØÈÅÑÈÅëÈÅíÈÅêÈÅ®ÈÅòÈÅ¢ÈÅõÊöπÈÅ¥ÈÅΩÈÇÇÈÇàÈÇÉÈÇãÂΩêÂΩóÂΩñÂΩòÂ∞ªÂí´Â±êÂ±ôÂ≠±Â±£Â±¶ÁæºÂº™Âº©Âº≠Ëâ¥ÂººÈ¨ªÂ±ÆÂ¶ÅÂ¶ÉÂ¶çÂ¶©Â¶™Â¶£"],["e640","Èç¨",34,"Èéê",27],["e680","Èé¨",29,"ÈèãÈèåÈèçÂ¶óÂßäÂ¶´Â¶ûÂ¶§ÂßíÂ¶≤Â¶ØÂßóÂ¶æÂ®ÖÂ®ÜÂßùÂ®àÂß£ÂßòÂßπÂ®åÂ®âÂ®≤Â®¥Â®ëÂ®£Â®ìÂ©ÄÂ©ßÂ©äÂ©ïÂ®ºÂ©¢Â©µËÉ¨Â™™Â™õÂ©∑Â©∫Â™æÂ´´Â™≤Â´íÂ´îÂ™∏Â´†Â´£Â´±Â´ñÂ´¶Â´òÂ´úÂ¨âÂ¨óÂ¨ñÂ¨≤Â¨∑Â≠ÄÂ∞ïÂ∞úÂ≠öÂ≠•Â≠≥Â≠ëÂ≠ìÂ≠¢È©µÈ©∑È©∏È©∫È©øÈ©ΩÈ™ÄÈ™ÅÈ™ÖÈ™àÈ™äÈ™êÈ™íÈ™ìÈ™ñÈ™òÈ™õÈ™úÈ™ùÈ™üÈ™†È™¢È™£È™•È™ßÁ∫üÁ∫°Á∫£Á∫•Á∫®Á∫©"],["e740","Èèé",7,"Èèó",54],["e780","Èêé",32,"Á∫≠Á∫∞Á∫æÁªÄÁªÅÁªÇÁªâÁªãÁªåÁªêÁªîÁªóÁªõÁª†Áª°Áª®Áª´ÁªÆÁªØÁª±Áª≤ÁºçÁª∂Áª∫ÁªªÁªæÁºÅÁºÇÁºÉÁºáÁºàÁºãÁºåÁºèÁºëÁºíÁºóÁºôÁºúÁºõÁºüÁº°",6,"Áº™Áº´Áº¨Áº≠ÁºØ",4,"ÁºµÂπ∫ÁïøÂ∑õÁîæÈÇïÁééÁéëÁéÆÁé¢ÁéüÁèèÁèÇÁèëÁé∑Áé≥ÁèÄÁèâÁèàÁè•ÁèôÈ°ºÁêäÁè©ÁèßÁèûÁé∫Áè≤ÁêèÁê™ÁëõÁê¶Áê•Áê®Áê∞ÁêÆÁê¨"],["e840","ÈêØ",14,"Èêø",43,"Èë¨Èë≠ÈëÆÈëØ"],["e880","Èë∞",20,"ÈíëÈíñÈíòÈìáÈìèÈììÈìîÈìöÈì¶ÈìªÈîúÈî†ÁêõÁêöÁëÅÁëúÁëóÁëïÁëôÁë∑Áë≠ÁëæÁíúÁíéÁíÄÁíÅÁíáÁíãÁíûÁí®Áí©ÁíêÁíßÁìíÁí∫Èü™Èü´Èü¨ÊùåÊùìÊùûÊùàÊù©Êû•ÊûáÊù™Êù≥ÊûòÊûßÊùµÊû®ÊûûÊû≠ÊûãÊù∑ÊùºÊü∞Ê†âÊüòÊ†äÊü©Êû∞Ê†åÊüôÊûµÊüöÊû≥ÊüùÊ†ÄÊüÉÊû∏Êü¢Ê†éÊüÅÊüΩÊ†≤Ê†≥Ê°†Ê°°Ê°éÊ°¢Ê°ÑÊ°§Ê¢ÉÊ†ùÊ°ïÊ°¶Ê°ÅÊ°ßÊ°ÄÊ†æÊ°äÊ°âÊ†©Ê¢µÊ¢èÊ°¥Ê°∑Ê¢ìÊ°´Ê£ÇÊ•ÆÊ£ºÊ§üÊ§†Ê£π"],["e940","ÈîßÈî≥ÈîΩÈïÉÈïàÈïãÈïïÈïöÈï†ÈïÆÈï¥ÈïµÈï∑",7,"ÈñÄ",42],["e980","Èñ´",32,"Ê§§Ê£∞Ê§ãÊ§ÅÊ•óÊ££Ê§êÊ•±Ê§πÊ•†Ê•ÇÊ•ùÊ¶ÑÊ•´Ê¶ÄÊ¶òÊ•∏Ê§¥ÊßåÊ¶áÊ¶àÊßéÊ¶âÊ•¶Ê•£Ê•πÊ¶õÊ¶ßÊ¶ªÊ¶´Ê¶≠ÊßîÊ¶±ÊßÅÊßäÊßüÊ¶ïÊß†Ê¶çÊßøÊ®ØÊß≠Ê®óÊ®òÊ©•Êß≤Ê©ÑÊ®æÊ™†Ê©êÊ©õÊ®µÊ™éÊ©πÊ®ΩÊ®®Ê©òÊ©ºÊ™ëÊ™êÊ™©Ê™óÊ™´Áå∑ÁçíÊÆÅÊÆÇÊÆáÊÆÑÊÆíÊÆìÊÆçÊÆöÊÆõÊÆ°ÊÆ™ËΩ´ËΩ≠ËΩ±ËΩ≤ËΩ≥ËΩµËΩ∂ËΩ∏ËΩ∑ËΩπËΩ∫ËΩºËΩæËæÅËæÇËæÑËæáËæã"],["ea40","Èóå",27,"Èó¨ÈóøÈòáÈòìÈòòÈòõÈòûÈò†Èò£",6,"Èò´Èò¨Èò≠ÈòØÈò∞Èò∑Èò∏ÈòπÈò∫ÈòæÈôÅÈôÉÈôäÈôéÈôèÈôëÈôíÈôìÈôñÈôó"],["ea80","ÈôòÈôôÈôöÈôúÈôùÈôûÈô†Èô£Èô•Èô¶Èô´Èô≠",4,"Èô≥Èô∏",12,"ÈöáÈöâÈöäËæçËæéËæèËæòËæöËªéÊàãÊàóÊàõÊàüÊà¢Êà°Êà•Êà§Êà¨ËáßÁìØÁì¥ÁìøÁîèÁîëÁîìÊî¥ÊóÆÊóØÊó∞ÊòäÊòôÊù≤ÊòÉÊòïÊòÄÁÇÖÊõ∑ÊòùÊò¥Êò±Êò∂ÊòµËÄÜÊôüÊôîÊôÅÊôèÊôñÊô°ÊôóÊô∑ÊöÑÊöåÊößÊöùÊöæÊõõÊõúÊõ¶Êõ©Ë¥≤Ë¥≥Ë¥∂Ë¥ªË¥ΩËµÄËµÖËµÜËµàËµâËµáËµçËµïËµôËßáËßäËßãËßåËßéËßèËßêËßëÁâÆÁäüÁâùÁâ¶ÁâØÁâæÁâøÁäÑÁäãÁäçÁäèÁäíÊåàÊå≤Êé∞"],["eb40","ÈöåÈöéÈöëÈöíÈöìÈöïÈöñÈööÈöõÈöù",9,"Èö®",7,"Èö±Èö≤Èö¥ÈöµÈö∑Èö∏Èö∫ÈöªÈöøÈõÇÈõÉÈõàÈõäÈõãÈõêÈõëÈõìÈõîÈõñ",9,"Èõ°",6,"Èõ´"],["eb80","Èõ¨Èõ≠ÈõÆÈõ∞Èõ±Èõ≤Èõ¥ÈõµÈõ∏Èõ∫ÈõªÈõºÈõΩÈõøÈúÇÈúÉÈúÖÈúäÈúãÈúåÈúêÈúëÈúíÈúîÈúïÈúó",4,"ÈúùÈúüÈú†ÊêøÊìòËÄÑÊØ™ÊØ≥ÊØΩÊØµÊØπÊ∞ÖÊ∞áÊ∞ÜÊ∞çÊ∞ïÊ∞òÊ∞ôÊ∞öÊ∞°Ê∞©Ê∞§Ê∞™Ê∞≤ÊîµÊïïÊï´ÁâçÁâíÁâñÁà∞Ëô¢ÂàñËÇüËÇúËÇìËÇºÊúäËÇΩËÇ±ËÇ´ËÇ≠ËÇ¥ËÇ∑ËÉßËÉ®ËÉ©ËÉ™ËÉõËÉÇËÉÑËÉôËÉçËÉóÊúêËÉùËÉ´ËÉ±ËÉ¥ËÉ≠ËÑçËÑéËÉ≤ËÉºÊúïËÑíË±öËÑ∂ËÑûËÑ¨ËÑòËÑ≤ËÖàËÖåËÖìËÖ¥ËÖôËÖöËÖ±ËÖ†ËÖ©ËÖºËÖΩËÖ≠ËÖßÂ°çÂ™µËÜàËÜÇËÜëÊªïËÜ£ËÜ™ËáåÊú¶ËáäËÜª"],["ec40","Èú°",8,"Èú´Èú¨ÈúÆÈúØÈú±Èú≥",4,"Èú∫ÈúªÈúºÈúΩÈúø",18,"ÈùîÈùïÈùóÈùòÈùöÈùúÈùùÈùüÈù£Èù§Èù¶ÈùßÈù®Èù™",7],["ec80","Èù≤ÈùµÈù∑",4,"ÈùΩ",7,"ÈûÜ",4,"ÈûåÈûéÈûèÈûêÈûìÈûïÈûñÈûóÈûô",4,"ËáÅËÜ¶Ê¨§Ê¨∑Ê¨πÊ≠ÉÊ≠ÜÊ≠ôÈ£ëÈ£íÈ£ìÈ£ïÈ£ôÈ£öÊÆ≥ÂΩÄÊØÇËß≥ÊñêÈΩëÊñìÊñºÊóÜÊóÑÊóÉÊóåÊóéÊóíÊóñÁÇÄÁÇúÁÇñÁÇùÁÇªÁÉÄÁÇ∑ÁÇ´ÁÇ±ÁÉ®ÁÉäÁÑêÁÑìÁÑñÁÑØÁÑ±ÁÖ≥ÁÖúÁÖ®ÁÖÖÁÖ≤ÁÖäÁÖ∏ÁÖ∫ÁÜòÁÜ≥ÁÜµÁÜ®ÁÜ†Áá†ÁáîÁáßÁáπÁàùÁà®ÁÅ¨ÁÑòÁÖ¶ÁÜπÊàæÊàΩÊâÉÊâàÊââÁ§ªÁ•ÄÁ•ÜÁ•âÁ•õÁ•úÁ•ìÁ•öÁ•¢Á•óÁ•†Á•ØÁ•ßÁ•∫Á¶ÖÁ¶äÁ¶öÁ¶ßÁ¶≥ÂøëÂøê"],["ed40","ÈûûÈûüÈû°Èû¢Èû§",6,"Èû¨ÈûÆÈû∞Èû±Èû≥Èûµ",46],["ed80","Èü§Èü•Èü®ÈüÆ",4,"Èü¥Èü∑",23,"ÊÄºÊÅùÊÅöÊÅßÊÅÅÊÅôÊÅ£ÊÇ´ÊÑÜÊÑçÊÖùÊÜ©ÊÜùÊáãÊáëÊàÜËÇÄËÅøÊ≤ìÊ≥∂Ê∑ºÁü∂Áü∏Á†ÄÁ†âÁ†óÁ†òÁ†ëÊñ´Á†≠Á†úÁ†ùÁ†πÁ†∫Á†ªÁ†üÁ†ºÁ†•Á†¨Á†£Á†©Á°éÁ°≠Á°ñÁ°óÁ†¶Á°êÁ°áÁ°åÁ°™Á¢õÁ¢ìÁ¢öÁ¢áÁ¢úÁ¢°Á¢£Á¢≤Á¢πÁ¢•Á£îÁ£ôÁ£âÁ£¨Á£≤Á§ÖÁ£¥Á§ìÁ§§Á§ûÁ§¥ÈæõÈªπÈªªÈªºÁõ±ÁúÑÁúçÁõπÁúáÁúàÁúöÁú¢ÁúôÁú≠Áú¶ÁúµÁú∏ÁùêÁùëÁùáÁùÉÁùöÁù®"],["ee40","È†è",62],["ee80","È°é",32,"Áù¢Áù•ÁùøÁûçÁùΩÁûÄÁûåÁûëÁûüÁû†Áû∞ÁûµÁûΩÁî∫ÁïÄÁïéÁïãÁïàÁïõÁï≤ÁïπÁñÉÁΩòÁΩ°ÁΩüË©àÁΩ®ÁΩ¥ÁΩ±ÁΩπÁæÅÁΩæÁõçÁõ•Ë†≤ÈíÖÈíÜÈíáÈíãÈíäÈíåÈíçÈíèÈíêÈíîÈíóÈíïÈíöÈíõÈíúÈí£Èí§Èí´Èí™Èí≠Èí¨ÈíØÈí∞Èí≤Èí¥Èí∂",4,"ÈíºÈíΩÈíøÈìÑÈìà",6,"ÈìêÈìëÈìíÈìïÈìñÈìóÈìôÈìòÈìõÈìûÈìüÈì†Èì¢Èì§Èì•ÈìßÈì®Èì™"],["ef40","È°Ø",5,"È¢ãÈ¢éÈ¢íÈ¢ïÈ¢ôÈ¢£È¢®",37,"È£èÈ£êÈ£îÈ£ñÈ£óÈ£õÈ£úÈ£ùÈ£†",4],["ef80","È£•È£¶È£©",30,"Èì©Èì´ÈìÆÈìØÈì≥Èì¥ÈìµÈì∑ÈìπÈìºÈìΩÈìøÈîÉÈîÇÈîÜÈîáÈîâÈîäÈîçÈîéÈîèÈîí",4,"ÈîòÈîõÈîùÈîûÈîüÈî¢Èî™Èî´Èî©Èî¨Èî±Èî≤Èî¥Èî∂Èî∑Èî∏ÈîºÈîæÈîøÈïÇÈîµÈïÑÈïÖÈïÜÈïâÈïåÈïéÈïèÈïíÈïìÈïîÈïñÈïóÈïòÈïôÈïõÈïûÈïüÈïùÈï°Èï¢Èï§",8,"ÈïØÈï±Èï≤Èï≥Èî∫ÁüßÁü¨ÈõâÁßïÁß≠Áß£Áß´Á®ÜÂµáÁ®ÉÁ®ÇÁ®ûÁ®î"],["f040","È§à",4,"È§éÈ§èÈ§ë",28,"È§Ø",26],["f080","È•ä",9,"È•ñ",12,"È•§È•¶È•≥È•∏È•πÈ•ªÈ•æÈ¶ÇÈ¶ÉÈ¶âÁ®πÁ®∑Á©ëÈªèÈ¶•Á©∞ÁöàÁöéÁöìÁöôÁö§ÁìûÁì†Áî¨È∏†È∏¢È∏®",4,"È∏≤È∏±È∏∂È∏∏È∏∑È∏πÈ∏∫È∏æÈπÅÈπÇÈπÑÈπÜÈπáÈπàÈπâÈπãÈπåÈπéÈπëÈπïÈπóÈπöÈπõÈπúÈπûÈπ£Èπ¶",6,"Èπ±Èπ≠Èπ≥ÁñíÁñîÁññÁñ†ÁñùÁñ¨Áñ£Áñ≥Áñ¥Áñ∏ÁóÑÁñ±Áñ∞ÁóÉÁóÇÁóñÁóçÁó£Áó®Áó¶Áó§Áó´ÁóßÁòÉÁó±ÁóºÁóøÁòêÁòÄÁòÖÁòåÁòóÁòäÁò•ÁòòÁòïÁòô"],["f140","È¶åÈ¶éÈ¶ö",10,"È¶¶È¶ßÈ¶©",47],["f180","Èßô",32,"ÁòõÁòºÁò¢Áò†ÁôÄÁò≠Áò∞ÁòøÁòµÁôÉÁòæÁò≥ÁôçÁôûÁôîÁôúÁôñÁô´ÁôØÁøäÁ´¶Á©∏Á©πÁ™ÄÁ™ÜÁ™àÁ™ïÁ™¶Á™†Á™¨Á™®Á™≠Á™≥Ë°§Ë°©Ë°≤Ë°ΩË°øË¢ÇË¢¢Ë£ÜË¢∑Ë¢ºË£âË£¢Ë£éË££Ë£•Ë£±Ë§öË£ºË£®Ë£æË£∞Ë§°Ë§ôË§ìË§õË§äË§¥Ë§´Ë§∂Ë•ÅË•¶Ë•ªÁñãËÉ•Áö≤Áö¥ÁüúËÄíËÄîËÄñËÄúËÄ†ËÄ¢ËÄ•ËÄ¶ËÄßËÄ©ËÄ®ËÄ±ËÄãËÄµËÅÉËÅÜËÅçËÅíËÅ©ËÅ±Ë¶ÉÈ°∏È¢ÄÈ¢É"],["f240","Èß∫",62],["f280","È®π",32,"È¢âÈ¢åÈ¢çÈ¢èÈ¢îÈ¢öÈ¢õÈ¢ûÈ¢üÈ¢°È¢¢È¢•È¢¶ËôçËôîËô¨ËôÆËôøËô∫ËôºËôªËö®ËöçËöãËö¨ËöùËößËö£Ëö™ËöìËö©Ëö∂ËõÑËöµËõéËö∞Ëö∫Ëö±ËöØËõâËõèËö¥Ëõ©Ëõ±Ëõ≤Ëõ≠Ëõ≥ËõêËúìËõûËõ¥ËõüËõòËõëËúÉËúáËõ∏ËúàËúäËúçËúâËú£ËúªËúûËú•ËúÆËúöËúæËùàËú¥Ëú±Ëú©Ëú∑ËúøËûÇËú¢ËùΩËùæËùªËù†Ëù∞ËùåËùÆËûãËùìËù£ËùºËù§ËùôËù•ËûìËûØËû®Ëüí"],["f340","È©ö",17,"È©≤È™ÉÈ™âÈ™çÈ™éÈ™îÈ™ïÈ™ôÈ™¶È™©",6,"È™≤È™≥È™¥È™µÈ™πÈ™ªÈ™ΩÈ™æÈ™øÈ´ÉÈ´ÑÈ´Ü",4,"È´çÈ´éÈ´èÈ´êÈ´íÈ´îÈ´ïÈ´ñÈ´óÈ´ôÈ´öÈ´õÈ´ú"],["f380","È´ùÈ´ûÈ´†È´¢È´£È´§È´•È´ßÈ´®È´©È´™È´¨È´ÆÈ´∞",8,"È´∫È´º",6,"È¨ÑÈ¨ÖÈ¨ÜËüÜËûàËûÖËû≠ËûóËûÉËû´Ëü•Ëû¨ËûµËû≥ËüãËüìËûΩËüëËüÄËüäËüõËü™Ëü†ËüÆË†ñË†ìËüæË†äË†õË†°Ë†πË†ºÁº∂ÁΩÇÁΩÑÁΩÖËàêÁ´∫Á´ΩÁ¨àÁ¨ÉÁ¨ÑÁ¨ïÁ¨äÁ¨´Á¨èÁ≠áÁ¨∏Á¨™Á¨ôÁ¨ÆÁ¨±Á¨†Á¨•Á¨§Á¨≥Á¨æÁ¨ûÁ≠òÁ≠öÁ≠ÖÁ≠µÁ≠åÁ≠ùÁ≠†Á≠ÆÁ≠ªÁ≠¢Á≠≤Á≠±ÁÆêÁÆ¶ÁÆßÁÆ∏ÁÆ¨ÁÆùÁÆ®ÁÆÖÁÆ™ÁÆúÁÆ¢ÁÆ´ÁÆ¥ÁØëÁØÅÁØåÁØùÁØöÁØ•ÁØ¶ÁØ™Á∞åÁØæÁØºÁ∞èÁ∞ñÁ∞ã"],["f440","È¨áÈ¨â",5,"È¨êÈ¨ëÈ¨íÈ¨î",10,"È¨†È¨°È¨¢È¨§",10,"È¨∞È¨±È¨≥",7,"È¨ΩÈ¨æÈ¨øÈ≠ÄÈ≠ÜÈ≠äÈ≠ãÈ≠åÈ≠éÈ≠êÈ≠íÈ≠ìÈ≠ï",5],["f480","È≠õ",32,"Á∞üÁ∞™Á∞¶Á∞∏Á±ÅÁ±ÄËáæËàÅËàÇËàÑËá¨Ë°ÑËà°Ëà¢Ëà£Ëà≠ËàØËà®Ëà´Ëà∏ËàªËà≥Ëà¥ËàæËâÑËââËâãËâèËâöËâüËâ®Ë°æË¢ÖË¢àË£òË£üË•ûÁæùÁæüÁæßÁæØÁæ∞Áæ≤Á±ºÊïâÁ≤ëÁ≤ùÁ≤úÁ≤ûÁ≤¢Á≤≤Á≤ºÁ≤ΩÁ≥ÅÁ≥áÁ≥åÁ≥çÁ≥àÁ≥ÖÁ≥óÁ≥®ËâÆÊö®ÁæøÁøéÁøïÁø•Áø°Áø¶Áø©ÁøÆÁø≥Á≥∏Áµ∑Á∂¶Á∂ÆÁπáÁ∫õÈ∫∏È∫¥Ëµ≥Ë∂ÑË∂îË∂ëË∂±ËµßËµ≠Ë±áË±âÈÖäÈÖêÈÖéÈÖèÈÖ§"],["f540","È≠º",62],["f580","ÈÆª",32,"ÈÖ¢ÈÖ°ÈÖ∞ÈÖ©ÈÖØÈÖΩÈÖæÈÖ≤ÈÖ¥ÈÖπÈÜåÈÜÖÈÜêÈÜçÈÜëÈÜ¢ÈÜ£ÈÜ™ÈÜ≠ÈÜÆÈÜØÈÜµÈÜ¥ÈÜ∫Ë±ïÈπæË∂∏Ë∑´Ë∏ÖËπôËπ©Ë∂µË∂øË∂ºË∂∫Ë∑ÑË∑ñË∑óË∑öË∑ûË∑éË∑èË∑õË∑ÜË∑¨Ë∑∑Ë∑∏Ë∑£Ë∑πË∑ªË∑§Ë∏âË∑ΩË∏îË∏ùË∏üË∏¨Ë∏ÆË∏£Ë∏ØË∏∫ËπÄË∏πË∏µË∏ΩË∏±ËπâËπÅËπÇËπëËπíËπäËπ∞Ëπ∂ËπºËπØËπ¥Ë∫ÖË∫èË∫îË∫êË∫úË∫ûË±∏Ë≤ÇË≤äË≤ÖË≤òË≤îÊñõËßñËßûËßöËßú"],["f640","ÈØú",62],["f680","È∞õ",32,"Ëß•Ëß´ËßØË®æË¨¶ÈùìÈõ©Èõ≥ÈõØÈúÜÈúÅÈúàÈúèÈúéÈú™Èú≠Èú∞ÈúæÈæÄÈæÉÈæÖ",5,"ÈæåÈªæÈºãÈºçÈöπÈöºÈöΩÈõéÈõíÁûøÈõ†ÈäéÈäÆÈãàÈåæÈç™ÈèäÈéèÈêæÈë´È±øÈ≤ÇÈ≤ÖÈ≤ÜÈ≤áÈ≤àÁ®£È≤ãÈ≤éÈ≤êÈ≤ëÈ≤íÈ≤îÈ≤ïÈ≤öÈ≤õÈ≤û",5,"È≤•",4,"È≤´È≤≠È≤ÆÈ≤∞",7,"È≤∫È≤ªÈ≤ºÈ≤ΩÈ≥ÑÈ≥ÖÈ≥ÜÈ≥áÈ≥äÈ≥ã"],["f740","È∞º",62],["f780","È±ªÈ±ΩÈ±æÈ≤ÄÈ≤ÉÈ≤ÑÈ≤âÈ≤äÈ≤åÈ≤èÈ≤ìÈ≤ñÈ≤óÈ≤òÈ≤ôÈ≤ùÈ≤™È≤¨È≤ØÈ≤πÈ≤æ",4,"È≥àÈ≥âÈ≥ëÈ≥íÈ≥öÈ≥õÈ≥†È≥°È≥å",4,"È≥ìÈ≥îÈ≥ïÈ≥óÈ≥òÈ≥ôÈ≥úÈ≥ùÈ≥üÈ≥¢ÈùºÈûÖÈûëÈûíÈûîÈûØÈû´Èû£Èû≤Èû¥È™±È™∞È™∑ÈπòÈ™∂È™∫È™ºÈ´ÅÈ´ÄÈ´ÖÈ´ÇÈ´ãÈ´åÈ´ëÈ≠ÖÈ≠ÉÈ≠áÈ≠âÈ≠àÈ≠çÈ≠ëÈ£®È§çÈ§ÆÈ•ïÈ•îÈ´üÈ´°È´¶È´ØÈ´´È´ªÈ´≠È´πÈ¨àÈ¨èÈ¨ìÈ¨üÈ¨£È∫ΩÈ∫æÁ∏ªÈ∫ÇÈ∫áÈ∫àÈ∫ãÈ∫íÈèñÈ∫ùÈ∫üÈªõÈªúÈªùÈª†ÈªüÈª¢Èª©ÈªßÈª•Èª™ÈªØÈº¢Èº¨ÈºØÈºπÈº∑ÈºΩÈºæÈΩÑ"],["f840","È≥£",62],["f880","È¥¢",32],["f940","ÈµÉ",62],["f980","È∂Ç",32],["fa40","È∂£",62],["fa80","È∑¢",32],["fb40","È∏É",27,"È∏§È∏ßÈ∏ÆÈ∏∞È∏¥È∏ªÈ∏ºÈπÄÈπçÈπêÈπíÈπìÈπîÈπñÈπôÈπùÈπüÈπ†Èπ°Èπ¢Èπ•ÈπÆÈπØÈπ≤Èπ¥",9,"È∫Ä"],["fb80","È∫ÅÈ∫ÉÈ∫ÑÈ∫ÖÈ∫ÜÈ∫âÈ∫äÈ∫å",5,"È∫î",8,"È∫ûÈ∫†",5,"È∫ßÈ∫®È∫©È∫™"],["fc40","È∫´",8,"È∫µÈ∫∂È∫∑È∫πÈ∫∫È∫ºÈ∫ø",4,"ÈªÖÈªÜÈªáÈªàÈªäÈªãÈªåÈªêÈªíÈªìÈªïÈªñÈªóÈªôÈªöÈªûÈª°Èª£Èª§Èª¶Èª®Èª´Èª¨Èª≠ÈªÆÈª∞",8,"Èª∫ÈªΩÈªø",6],["fc80","ÈºÜ",4,"ÈºåÈºèÈºëÈºíÈºîÈºïÈºñÈºòÈºö",5,"Èº°Èº£",8,"Èº≠ÈºÆÈº∞Èº±"],["fd40","Èº≤",4,"Èº∏Èº∫ÈººÈºø",4,"ÈΩÖ",10,"ÈΩí",38],["fd80","ÈΩπ",5,"ÈæÅÈæÇÈæç",11,"ÈæúÈæùÈæûÈæ°",4,"Ô§¨Ô•πÔ¶ïÔßßÔß±"],["fe40","Ô®åÔ®çÔ®éÔ®èÔ®ëÔ®ìÔ®îÔ®òÔ®üÔ®†Ô®°Ô®£Ô®§Ô®ßÔ®®Ô®©"]]');

/***/ }),

/***/ 16836:
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('[["0","\\u0000",127],["8141","Í∞ÇÍ∞ÉÍ∞ÖÍ∞ÜÍ∞ã",4,"Í∞òÍ∞ûÍ∞üÍ∞°Í∞¢Í∞£Í∞•",6,"Í∞ÆÍ∞≤Í∞≥Í∞¥"],["8161","Í∞µÍ∞∂Í∞∑Í∞∫Í∞ªÍ∞ΩÍ∞æÍ∞øÍ±Å",9,"Í±åÍ±é",5,"Í±ï"],["8181","Í±ñÍ±óÍ±ôÍ±öÍ±õÍ±ù",18,"Í±≤Í±≥Í±µÍ±∂Í±πÍ±ª",4,"Í≤ÇÍ≤áÍ≤àÍ≤çÍ≤éÍ≤èÍ≤ëÍ≤íÍ≤ìÍ≤ï",6,"Í≤ûÍ≤¢",5,"Í≤´Í≤≠Í≤ÆÍ≤±",6,"Í≤∫Í≤æÍ≤øÍ≥ÄÍ≥ÇÍ≥ÉÍ≥ÖÍ≥ÜÍ≥áÍ≥âÍ≥äÍ≥ãÍ≥ç",7,"Í≥ñÍ≥ò",7,"Í≥¢Í≥£Í≥•Í≥¶Í≥©Í≥´Í≥≠Í≥ÆÍ≥≤Í≥¥Í≥∑",4,"Í≥æÍ≥øÍ¥ÅÍ¥ÇÍ¥ÉÍ¥ÖÍ¥á",4,"Í¥éÍ¥êÍ¥íÍ¥ì"],["8241","Í¥îÍ¥ïÍ¥ñÍ¥óÍ¥ôÍ¥öÍ¥õÍ¥ùÍ¥ûÍ¥üÍ¥°",7,"Í¥™Í¥´Í¥Æ",5],["8261","Í¥∂Í¥∑Í¥πÍ¥∫Í¥ªÍ¥Ω",6,"ÍµÜÍµàÍµä",5,"ÍµëÍµíÍµìÍµïÍµñÍµó"],["8281","Íµô",7,"Íµ¢Íµ§",7,"ÍµÆÍµØÍµ±Íµ≤Íµ∑Íµ∏ÍµπÍµ∫ÍµæÍ∂ÄÍ∂É",4,"Í∂äÍ∂ãÍ∂çÍ∂éÍ∂èÍ∂ë",10,"Í∂û",5,"Í∂•",17,"Í∂∏",7,"Í∑ÇÍ∑ÉÍ∑ÖÍ∑ÜÍ∑áÍ∑â",6,"Í∑íÍ∑î",7,"Í∑ùÍ∑ûÍ∑üÍ∑°Í∑¢Í∑£Í∑•",18],["8341","Í∑∫Í∑ªÍ∑ΩÍ∑æÍ∏Ç",5,"Í∏äÍ∏åÍ∏é",5,"Í∏ï",7],["8361","Í∏ù",18,"Í∏≤Í∏≥Í∏µÍ∏∂Í∏πÍ∏ªÍ∏º"],["8381","Í∏ΩÍ∏æÍ∏øÍπÇÍπÑÍπáÍπàÍπâÍπãÍπèÍπëÍπíÍπìÍπïÍπó",4,"ÍπûÍπ¢Íπ£Íπ§Íπ¶ÍπßÍπ™Íπ´Íπ≠ÍπÆÍπØÍπ±",6,"Íπ∫Íπæ",5,"Í∫Ü",5,"Í∫ç",46,"Í∫øÍªÅÍªÇÍªÉÍªÖ",6,"ÍªéÍªí",5,"ÍªöÍªõÍªù",8],["8441","Íª¶ÍªßÍª©Íª™Íª¨ÍªÆ",5,"ÍªµÍª∂Íª∑ÍªπÍª∫ÍªªÍªΩ",8],["8461","ÍºÜÍºâÍºäÍºãÍºåÍºéÍºèÍºë",18],["8481","Íº§",7,"ÍºÆÍºØÍº±Íº≥Íºµ",6,"ÍºæÍΩÄÍΩÑÍΩÖÍΩÜÍΩáÍΩä",5,"ÍΩë",10,"ÍΩû",5,"ÍΩ¶",18,"ÍΩ∫",5,"ÍæÅÍæÇÍæÉÍæÖÍæÜÍæáÍæâ",6,"ÍæíÍæìÍæîÍæñ",5,"Íæù",26,"Íæ∫ÍæªÍæΩÍææ"],["8541","ÍæøÍøÅ",5,"ÍøäÍøåÍøè",4,"Íøï",6,"Íøù",4],["8561","Íø¢",5,"Íø™",5,"Íø≤Íø≥ÍøµÍø∂Íø∑Íøπ",6,"ÎÄÇÎÄÉ"],["8581","ÎÄÖ",6,"ÎÄçÎÄéÎÄèÎÄëÎÄíÎÄìÎÄï",6,"ÎÄû",9,"ÎÄ©",26,"ÎÅÜÎÅáÎÅâÎÅãÎÅçÎÅèÎÅêÎÅëÎÅíÎÅñÎÅòÎÅöÎÅõÎÅúÎÅû",29,"ÎÅæÎÅøÎÇÅÎÇÇÎÇÉÎÇÖ",6,"ÎÇéÎÇêÎÇí",5,"ÎÇõÎÇùÎÇûÎÇ£ÎÇ§"],["8641","ÎÇ•ÎÇ¶ÎÇßÎÇ™ÎÇ∞ÎÇ≤ÎÇ∂ÎÇ∑ÎÇπÎÇ∫ÎÇªÎÇΩ",6,"ÎÉÜÎÉä",5,"ÎÉí"],["8661","ÎÉìÎÉïÎÉñÎÉóÎÉô",6,"ÎÉ°ÎÉ¢ÎÉ£ÎÉ§ÎÉ¶",10],["8681","ÎÉ±",22,"ÎÑäÎÑçÎÑéÎÑèÎÑëÎÑîÎÑïÎÑñÎÑóÎÑöÎÑû",4,"ÎÑ¶ÎÑßÎÑ©ÎÑ™ÎÑ´ÎÑ≠",6,"ÎÑ∂ÎÑ∫",5,"ÎÖÇÎÖÉÎÖÖÎÖÜÎÖáÎÖâ",6,"ÎÖíÎÖìÎÖñÎÖóÎÖôÎÖöÎÖõÎÖùÎÖûÎÖüÎÖ°",22,"ÎÖ∫ÎÖªÎÖΩÎÖæÎÖøÎÜÅÎÜÉ",4,"ÎÜäÎÜåÎÜéÎÜèÎÜêÎÜëÎÜïÎÜñÎÜóÎÜôÎÜöÎÜõÎÜù"],["8741","ÎÜû",9,"ÎÜ©",15],["8761","ÎÜπ",18,"ÎáçÎáéÎáèÎáëÎáíÎáìÎáï"],["8781","Îáñ",5,"ÎáûÎá†",7,"Îá™Îá´Îá≠ÎáÆÎáØÎá±",7,"Îá∫ÎáºÎáæ",5,"ÎàÜÎàáÎàâÎàäÎàç",6,"ÎàñÎàòÎàö",5,"Îà°",18,"Îàµ",6,"ÎàΩ",26,"ÎâôÎâöÎâõÎâùÎâûÎâüÎâ°",6,"Îâ™",4],["8841","ÎâØ",4,"Îâ∂",5,"ÎâΩ",6,"ÎäÜÎäáÎäàÎää",4],["8861","ÎäèÎäíÎäìÎäïÎäñÎäóÎäõ",4,"Îä¢Îä§ÎäßÎä®Îä©Îä´Îä≠ÎäÆÎäØÎä±Îä≤Îä≥ÎäµÎä∂Îä∑"],["8881","Îä∏",15,"ÎãäÎããÎãçÎãéÎãèÎãëÎãì",4,"ÎãöÎãúÎãûÎãüÎã†Îã°Îã£ÎãßÎã©Îã™Îã∞Îã±Îã≤Îã∂ÎãºÎãΩÎãæÎåÇÎåÉÎåÖÎåÜÎåáÎåâ",6,"ÎåíÎåñ",5,"Îåù",54,"ÎçóÎçôÎçöÎçùÎç†Îç°Îç¢Îç£"],["8941","Îç¶Îç®Îç™Îç¨Îç≠ÎçØÎç≤Îç≥ÎçµÎç∂Îç∑Îçπ",6,"ÎéÇÎéÜ",5,"Îéç"],["8961","ÎééÎéèÎéëÎéíÎéìÎéï",10,"Îé¢",5,"Îé©Îé™Îé´Îé≠"],["8981","ÎéÆ",21,"ÎèÜÎèáÎèâÎèäÎèçÎèèÎèëÎèíÎèìÎèñÎèòÎèöÎèúÎèûÎèüÎè°Îè¢Îè£Îè•Îè¶ÎèßÎè©",18,"ÎèΩ",18,"Îêë",6,"ÎêôÎêöÎêõÎêùÎêûÎêüÎê°",6,"Îê™Îê¨",7,"Îêµ",15],["8a41","ÎëÖ",10,"ÎëíÎëìÎëïÎëñÎëóÎëô",6,"Îë¢Îë§Îë¶"],["8a61","Îëß",4,"Îë≠",18,"ÎíÅÎíÇ"],["8a81","ÎíÉ",4,"Îíâ",19,"Îíû",5,"Îí•Îí¶ÎíßÎí©Îí™Îí´Îí≠",7,"Îí∂Îí∏Îí∫",5,"ÎìÅÎìÇÎìÉÎìÖÎìÜÎìáÎìâ",6,"ÎìëÎìíÎììÎìîÎìñ",5,"ÎìûÎìüÎì°Îì¢Îì•Îìß",4,"ÎìÆÎì∞Îì≤",5,"Îìπ",26,"ÎîñÎîóÎîôÎîöÎîù"],["8b41","Îîû",5,"Îî¶Îî´",4,"Îî≤Îî≥ÎîµÎî∂Îî∑Îîπ",6,"ÎïÇÎïÜ"],["8b61","ÎïáÎïàÎïâÎïäÎïéÎïèÎïëÎïíÎïìÎïï",6,"ÎïûÎï¢",8],["8b81","Îï´",52,"Îñ¢Îñ£Îñ•Îñ¶ÎñßÎñ©Îñ¨Îñ≠ÎñÆÎñØÎñ≤Îñ∂",4,"ÎñæÎñøÎóÅÎóÇÎóÉÎóÖ",6,"ÎóéÎóí",5,"Îóô",18,"Îó≠",18],["8c41","ÎòÄ",15,"ÎòíÎòìÎòïÎòñÎòóÎòô",4],["8c61","Îòû",6,"Îò¶",5,"Îò≠",6,"Îòµ",5],["8c81","Îòª",12,"Îôâ",26,"Îô•Îô¶ÎôßÎô©",50,"ÎöûÎöüÎö°Îö¢Îö£Îö•",5,"Îö≠ÎöÆÎöØÎö∞Îö≤",16],["8d41","ÎõÉ",16,"Îõï",8],["8d61","Îõû",17,"Îõ±Îõ≤Îõ≥ÎõµÎõ∂Îõ∑ÎõπÎõ∫"],["8d81","Îõª",4,"ÎúÇÎúÉÎúÑÎúÜ",33,"Îú™Îú´Îú≠ÎúÆÎú±",6,"Îú∫Îúº",7,"ÎùÖÎùÜÎùáÎùâÎùäÎùãÎùç",6,"Îùñ",9,"Îù°Îù¢Îù£Îù•Îù¶ÎùßÎù©",6,"Îù≤Îù¥Îù∂",5,"ÎùæÎùøÎûÅÎûÇÎûÉÎûÖ",6,"ÎûéÎûìÎûîÎûïÎûöÎûõÎûùÎûû"],["8e41","ÎûüÎû°",6,"Îû™ÎûÆ",5,"Îû∂Îû∑Îûπ",8],["8e61","ÎüÇ",4,"ÎüàÎüä",19],["8e81","Îüû",13,"ÎüÆÎüØÎü±Îü≤Îü≥Îüµ",6,"ÎüæÎ†Ç",4,"Î†äÎ†ãÎ†çÎ†éÎ†èÎ†ë",6,"Î†öÎ†úÎ†û",5,"Î†¶Î†ßÎ†©Î†™Î†´Î†≠",6,"Î†∂Î†∫",5,"Î°ÅÎ°ÇÎ°ÉÎ°Ö",11,"Î°íÎ°î",7,"Î°ûÎ°üÎ°°Î°¢Î°£Î°•",6,"Î°ÆÎ°∞Î°≤",5,"Î°πÎ°∫Î°ªÎ°Ω",7],["8f41","Î¢Ö",7,"Î¢é",17],["8f61","Î¢†",7,"Î¢©",6,"Î¢±Î¢≤Î¢≥Î¢µÎ¢∂Î¢∑Î¢π",4],["8f81","Î¢æÎ¢øÎ£ÇÎ£ÑÎ£Ü",5,"Î£çÎ£éÎ£èÎ£ëÎ£íÎ£ìÎ£ï",7,"Î£ûÎ£†Î£¢",5,"Î£™Î£´Î£≠Î£ÆÎ£ØÎ£±",6,"Î£∫Î£ºÎ£æ",5,"Î§Ö",18,"Î§ô",6,"Î§°",26,"Î§æÎ§øÎ•ÅÎ•ÇÎ•ÉÎ•Ö",6,"Î•çÎ•éÎ•êÎ•í",5],["9041","Î•öÎ•õÎ•ùÎ•ûÎ•üÎ•°",6,"Î•™Î•¨Î•Æ",5,"Î•∂Î•∑Î•πÎ•∫Î•ªÎ•Ω"],["9061","Î•æ",5,"Î¶ÜÎ¶àÎ¶ãÎ¶åÎ¶è",15],["9081","Î¶ü",12,"Î¶ÆÎ¶ØÎ¶±Î¶≤Î¶≥Î¶µ",6,"Î¶æÎßÄÎßÇ",5,"ÎßäÎßãÎßçÎßì",4,"ÎßöÎßúÎßüÎß†Îß¢Îß¶ÎßßÎß©Îß™Îß´Îß≠",6,"Îß∂Îßª",4,"Î®Ç",5,"Î®â",11,"Î®ñ",33,"Î®∫Î®ªÎ®ΩÎ®æÎ®øÎ©ÅÎ©ÉÎ©ÑÎ©ÖÎ©Ü"],["9141","Î©áÎ©äÎ©åÎ©èÎ©êÎ©ëÎ©íÎ©ñÎ©óÎ©ôÎ©öÎ©õÎ©ù",6,"Î©¶Î©™",5],["9161","Î©≤Î©≥Î©µÎ©∂Î©∑Î©π",9,"Î™ÜÎ™àÎ™âÎ™äÎ™ãÎ™ç",5],["9181","Î™ì",20,"Î™™Î™≠Î™ÆÎ™ØÎ™±Î™≥",4,"Î™∫Î™ºÎ™æ",5,"Î´ÖÎ´ÜÎ´áÎ´â",14,"Î´ö",33,"Î´ΩÎ´æÎ´øÎ¨ÅÎ¨ÇÎ¨ÉÎ¨Ö",7,"Î¨éÎ¨êÎ¨í",5,"Î¨ôÎ¨öÎ¨õÎ¨ùÎ¨ûÎ¨üÎ¨°",6],["9241","Î¨®Î¨™Î¨¨",7,"Î¨∑Î¨πÎ¨∫Î¨ø",4,"Î≠ÜÎ≠àÎ≠äÎ≠ãÎ≠åÎ≠éÎ≠ëÎ≠í"],["9261","Î≠ìÎ≠ïÎ≠ñÎ≠óÎ≠ô",7,"Î≠¢Î≠§",7,"Î≠≠",4],["9281","Î≠≤",21,"ÎÆâÎÆäÎÆãÎÆçÎÆéÎÆèÎÆë",18,"ÎÆ•ÎÆ¶ÎÆßÎÆ©ÎÆ™ÎÆ´ÎÆ≠",6,"ÎÆµÎÆ∂ÎÆ∏",7,"ÎØÅÎØÇÎØÉÎØÖÎØÜÎØáÎØâ",6,"ÎØëÎØíÎØî",35,"ÎØ∫ÎØªÎØΩÎØæÎ∞Å"],["9341","Î∞É",4,"Î∞äÎ∞éÎ∞êÎ∞íÎ∞ìÎ∞ôÎ∞öÎ∞†Î∞°Î∞¢Î∞£Î∞¶Î∞®Î∞™Î∞´Î∞¨Î∞ÆÎ∞ØÎ∞≤Î∞≥Î∞µ"],["9361","Î∞∂Î∞∑Î∞π",6,"Î±ÇÎ±ÜÎ±áÎ±àÎ±äÎ±ãÎ±éÎ±èÎ±ë",8],["9381","Î±öÎ±õÎ±úÎ±û",37,"Î≤ÜÎ≤áÎ≤âÎ≤äÎ≤çÎ≤è",4,"Î≤ñÎ≤òÎ≤õ",4,"Î≤¢Î≤£Î≤•Î≤¶Î≤©",6,"Î≤≤Î≤∂",5,"Î≤æÎ≤øÎ≥ÅÎ≥ÇÎ≥ÉÎ≥Ö",7,"Î≥éÎ≥íÎ≥ìÎ≥îÎ≥ñÎ≥óÎ≥ôÎ≥öÎ≥õÎ≥ù",22,"Î≥∑Î≥πÎ≥∫Î≥ªÎ≥Ω"],["9441","Î≥æ",5,"Î¥ÜÎ¥àÎ¥ä",5,"Î¥ëÎ¥íÎ¥ìÎ¥ï",8],["9461","Î¥û",5,"Î¥•",6,"Î¥≠",12],["9481","Î¥∫",5,"ÎµÅ",6,"ÎµäÎµãÎµçÎµéÎµèÎµë",6,"Îµö",9,"Îµ•Îµ¶ÎµßÎµ©",22,"Î∂ÇÎ∂ÉÎ∂ÖÎ∂ÜÎ∂ã",4,"Î∂íÎ∂îÎ∂ñÎ∂óÎ∂òÎ∂õÎ∂ù",6,"Î∂•",10,"Î∂±",6,"Î∂π",24],["9541","Î∑íÎ∑ìÎ∑ñÎ∑óÎ∑ôÎ∑öÎ∑õÎ∑ù",11,"Î∑™",5,"Î∑±"],["9561","Î∑≤Î∑≥Î∑µÎ∑∂Î∑∑Î∑π",6,"Î∏ÅÎ∏ÇÎ∏ÑÎ∏Ü",5,"Î∏éÎ∏èÎ∏ëÎ∏íÎ∏ì"],["9581","Î∏ï",6,"Î∏ûÎ∏†",35,"ÎπÜÎπáÎπâÎπäÎπãÎπçÎπè",4,"ÎπñÎπòÎπúÎπùÎπûÎπüÎπ¢Îπ£Îπ•Îπ¶ÎπßÎπ©Îπ´",4,"Îπ≤Îπ∂",4,"ÎπæÎπøÎ∫ÅÎ∫ÇÎ∫ÉÎ∫Ö",6,"Î∫éÎ∫í",5,"Î∫ö",13,"Î∫©",14],["9641","Î∫∏",23,"ÎªíÎªì"],["9661","ÎªïÎªñÎªô",6,"Îª°Îª¢Îª¶",5,"Îª≠",8],["9681","Îª∂",10,"ÎºÇ",5,"Îºä",13,"ÎºöÎºû",33,"ÎΩÇÎΩÉÎΩÖÎΩÜÎΩáÎΩâ",6,"ÎΩíÎΩìÎΩîÎΩñ",44],["9741","ÎæÉ",16,"Îæï",8],["9761","Îæû",17,"Îæ±",7],["9781","Îæπ",11,"ÎøÜ",5,"ÎøéÎøèÎøëÎøíÎøìÎøï",6,"ÎøùÎøûÎø†Îø¢",89,"ÏÄΩÏÄæÏÄø"],["9841","ÏÅÄ",16,"ÏÅí",5,"ÏÅôÏÅöÏÅõ"],["9861","ÏÅùÏÅûÏÅüÏÅ°",6,"ÏÅ™",15],["9881","ÏÅ∫",21,"ÏÇíÏÇìÏÇïÏÇñÏÇóÏÇô",6,"ÏÇ¢ÏÇ§ÏÇ¶",5,"ÏÇÆÏÇ±ÏÇ≤ÏÇ∑",4,"ÏÇæÏÉÇÏÉÉÏÉÑÏÉÜÏÉáÏÉäÏÉãÏÉçÏÉéÏÉèÏÉë",6,"ÏÉöÏÉû",5,"ÏÉ¶ÏÉßÏÉ©ÏÉ™ÏÉ´ÏÉ≠",6,"ÏÉ∂ÏÉ∏ÏÉ∫",5,"ÏÑÅÏÑÇÏÑÉÏÑÖÏÑÜÏÑáÏÑâ",6,"ÏÑëÏÑíÏÑìÏÑîÏÑñ",5,"ÏÑ°ÏÑ¢ÏÑ•ÏÑ®ÏÑ©ÏÑ™ÏÑ´ÏÑÆ"],["9941","ÏÑ≤ÏÑ≥ÏÑ¥ÏÑµÏÑ∑ÏÑ∫ÏÑªÏÑΩÏÑæÏÑøÏÖÅ",6,"ÏÖäÏÖé",5,"ÏÖñÏÖó"],["9961","ÏÖôÏÖöÏÖõÏÖù",6,"ÏÖ¶ÏÖ™",5,"ÏÖ±ÏÖ≤ÏÖ≥ÏÖµÏÖ∂ÏÖ∑ÏÖπÏÖ∫ÏÖª"],["9981","ÏÖº",8,"ÏÜÜ",5,"ÏÜèÏÜëÏÜíÏÜìÏÜïÏÜó",4,"ÏÜûÏÜ†ÏÜ¢ÏÜ£ÏÜ§ÏÜ¶ÏÜßÏÜ™ÏÜ´ÏÜ≠ÏÜÆÏÜØÏÜ±",11,"ÏÜæ",5,"ÏáÖÏáÜÏááÏáâÏáäÏáãÏáç",6,"ÏáïÏáñÏáô",6,"Ïá°Ïá¢Ïá£Ïá•Ïá¶ÏáßÏá©",6,"Ïá≤Ïá¥",7,"ÏáæÏáøÏàÅÏàÇÏàÉÏàÖ",6,"ÏàéÏàêÏàí",5,"ÏàöÏàõÏàùÏàûÏà°Ïà¢Ïà£"],["9a41","Ïà§Ïà•Ïà¶ÏàßÏà™Ïà¨ÏàÆÏà∞Ïà≥Ïàµ",16],["9a61","ÏâÜÏâáÏââ",6,"ÏâíÏâìÏâïÏâñÏâóÏâô",6,"Ïâ°Ïâ¢Ïâ£Ïâ§Ïâ¶"],["9a81","Ïâß",4,"ÏâÆÏâØÏâ±Ïâ≤Ïâ≥Ïâµ",6,"ÏâæÏäÄÏäÇ",5,"Ïää",5,"Ïäë",6,"ÏäôÏäöÏäúÏäû",5,"Ïä¶ÏäßÏä©Ïä™Ïä´ÏäÆ",5,"Ïä∂Ïä∏Ïä∫",33,"ÏãûÏãüÏã°Ïã¢Ïã•",5,"ÏãÆÏã∞Ïã≤Ïã≥Ïã¥ÏãµÏã∑Ïã∫ÏãΩÏãæÏãøÏåÅ",6,"ÏåäÏåãÏåéÏåè"],["9b41","ÏåêÏåëÏåíÏåñÏåóÏåôÏåöÏåõÏåù",6,"Ïå¶ÏåßÏå™",8],["9b61","Ïå≥",17,"ÏçÜ",7],["9b81","Ïçé",25,"Ïç™Ïç´Ïç≠ÏçÆÏçØÏç±Ïç≥",4,"Ïç∫ÏçªÏçæ",5,"ÏéÖÏéÜÏéáÏéâÏéäÏéãÏéç",50,"ÏèÅ",22,"Ïèö"],["9c41","ÏèõÏèùÏèûÏè°Ïè£",4,"Ïè™Ïè´Ïè¨ÏèÆ",5,"Ïè∂Ïè∑Ïèπ",5],["9c61","Ïèø",8,"Ïêâ",6,"Ïêë",9],["9c81","Ïêõ",8,"Ïê•",6,"Ïê≠ÏêÆÏêØÏê±Ïê≤Ïê≥Ïêµ",6,"Ïêæ",9,"Ïëâ",26,"Ïë¶ÏëßÏë©Ïë™Ïë´Ïë≠",6,"Ïë∂Ïë∑Ïë∏Ïë∫",5,"ÏíÅ",18,"Ïíï",6,"Ïíù",12],["9d41","Ïí™",13,"ÏíπÏí∫ÏíªÏíΩ",8],["9d61","ÏìÜ",25],["9d81","Ïì†",8,"Ïì™",5,"Ïì≤Ïì≥ÏìµÏì∂Ïì∑ÏìπÏìªÏìºÏìΩÏìæÏîÇ",9,"ÏîçÏîéÏîèÏîëÏîíÏîìÏîï",6,"Ïîù",10,"Ïî™Ïî´Ïî≠ÏîÆÏîØÏî±",6,"Ïî∫ÏîºÏîæ",5,"ÏïÜÏïáÏïãÏïèÏïêÏïëÏïíÏïñÏïöÏïõÏïúÏïüÏï¢Ïï£Ïï•Ïï¶ÏïßÏï©",6,"Ïï≤Ïï∂",5,"ÏïæÏïøÏñÅÏñÇÏñÉÏñÖÏñÜÏñàÏñâÏñäÏñãÏñéÏñêÏñíÏñìÏñî"],["9e41","ÏññÏñôÏñöÏñõÏñùÏñûÏñüÏñ°",7,"Ïñ™",9,"Ïñ∂"],["9e61","Ïñ∑Ïñ∫Ïñø",4,"ÏóãÏóçÏóèÏóíÏóìÏóïÏóñÏóóÏóô",6,"Ïó¢Ïó§Ïó¶Ïóß"],["9e81","Ïó®Ïó©Ïó™Ïó´ÏóØÏó±Ïó≤Ïó≥ÏóµÏó∏ÏóπÏó∫ÏóªÏòÇÏòÉÏòÑÏòâÏòäÏòãÏòçÏòéÏòèÏòë",6,"ÏòöÏòù",6,"Ïò¶ÏòßÏò©Ïò™Ïò´ÏòØÏò±Ïò≤Ïò∂Ïò∏Ïò∫ÏòºÏòΩÏòæÏòøÏôÇÏôÉÏôÖÏôÜÏôáÏôâ",6,"ÏôíÏôñ",5,"ÏôûÏôüÏô°",10,"Ïô≠ÏôÆÏô∞Ïô≤",5,"Ïô∫ÏôªÏôΩÏôæÏôøÏöÅ",6,"ÏöäÏöåÏöé",5,"ÏöñÏöóÏöôÏööÏöõÏöù",6,"Ïö¶"],["9f41","Ïö®Ïö™",5,"Ïö≤Ïö≥ÏöµÏö∂Ïö∑Ïöª",4,"ÏõÇÏõÑÏõÜ",5,"Ïõé"],["9f61","ÏõèÏõëÏõíÏõìÏõï",6,"ÏõûÏõüÏõ¢",5,"Ïõ™Ïõ´Ïõ≠ÏõÆÏõØÏõ±Ïõ≤"],["9f81","Ïõ≥",4,"Ïõ∫ÏõªÏõºÏõæ",5,"ÏúÜÏúáÏúâÏúäÏúãÏúç",6,"ÏúñÏúòÏúö",5,"Ïú¢Ïú£Ïú•Ïú¶ÏúßÏú©",6,"Ïú≤Ïú¥Ïú∂Ïú∏ÏúπÏú∫ÏúªÏúæÏúøÏùÅÏùÇÏùÉÏùÖ",4,"ÏùãÏùéÏùêÏùôÏùöÏùõÏùùÏùûÏùüÏù°",6,"Ïù©Ïù™Ïù¨",7,"Ïù∂Ïù∑ÏùπÏù∫ÏùªÏùøÏûÄÏûÅÏûÇÏûÜÏûãÏûåÏûçÏûèÏûíÏûìÏûïÏûôÏûõ",4,"Ïû¢Ïûß",4,"ÏûÆÏûØÏû±Ïû≤Ïû≥ÏûµÏû∂Ïû∑"],["a041","Ïû∏ÏûπÏû∫ÏûªÏûæÏüÇ",5,"ÏüäÏüãÏüçÏüèÏüë",6,"ÏüôÏüöÏüõÏüú"],["a061","Ïüû",5,"Ïü•Ïü¶ÏüßÏü©Ïü™Ïü´Ïü≠",13],["a081","Ïüª",4,"Ï†ÇÏ†ÉÏ†ÖÏ†ÜÏ†áÏ†âÏ†ã",4,"Ï†íÏ†îÏ†ó",4,"Ï†ûÏ†üÏ†°Ï†¢Ï†£Ï†•",6,"Ï†ÆÏ†∞Ï†≤",5,"Ï†πÏ†∫Ï†ªÏ†ΩÏ†æÏ†øÏ°Å",6,"Ï°äÏ°ãÏ°é",5,"Ï°ï",26,"Ï°≤Ï°≥Ï°µÏ°∂Ï°∑Ï°πÏ°ª",4,"Ï¢ÇÏ¢ÑÏ¢àÏ¢âÏ¢äÏ¢é",5,"Ï¢ï",7,"Ï¢ûÏ¢†Ï¢¢Ï¢£Ï¢§"],["a141","Ï¢•Ï¢¶Ï¢ßÏ¢©",18,"Ï¢æÏ¢øÏ£ÄÏ£Å"],["a161","Ï£ÇÏ£ÉÏ£ÖÏ£ÜÏ£áÏ£âÏ£äÏ£ãÏ£ç",6,"Ï£ñÏ£òÏ£ö",5,"Ï£¢Ï££Ï£•"],["a181","Ï£¶",14,"Ï£∂",5,"Ï£æÏ£øÏ§ÅÏ§ÇÏ§ÉÏ§á",4,"Ï§é„ÄÄ„ÄÅ„ÄÇ¬∑‚Ä•‚Ä¶¬®„ÄÉ¬≠‚Äï‚à•Ôºº‚àº‚Äò‚Äô‚Äú‚Äù„Äî„Äï„Äà",9,"¬±√ó√∑‚â†‚â§‚â•‚àû‚à¥¬∞‚Ä≤‚Ä≥‚ÑÉ‚Ñ´Ôø†Ôø°Ôø•‚ôÇ‚ôÄ‚à†‚ä•‚åí‚àÇ‚àá‚â°‚âí¬ß‚Äª‚òÜ‚òÖ‚óã‚óè‚óé‚óá‚óÜ‚ñ°‚ñ†‚ñ≥‚ñ≤‚ñΩ‚ñº‚Üí‚Üê‚Üë‚Üì‚Üî„Äì‚â™‚â´‚àö‚àΩ‚àù‚àµ‚à´‚à¨‚àà‚àã‚äÜ‚äá‚äÇ‚äÉ‚à™‚à©‚àß‚à®Ôø¢"],["a241","Ï§êÏ§í",5,"Ï§ô",18],["a261","Ï§≠",6,"Ï§µ",18],["a281","Ï•à",7,"Ï•íÏ•ìÏ•ïÏ•ñÏ•óÏ•ô",6,"Ï•¢Ï•§",7,"Ï•≠Ï•ÆÏ•Ø‚áí‚áî‚àÄ‚àÉ¬¥ÔΩûÀáÀòÀùÀöÀô¬∏Àõ¬°¬øÀê‚àÆ‚àë‚àè¬§‚Ñâ‚Ä∞‚óÅ‚óÄ‚ñ∑‚ñ∂‚ô§‚ô†‚ô°‚ô•‚ôß‚ô£‚äô‚óà‚ñ£‚óê‚óë‚ñí‚ñ§‚ñ•‚ñ®‚ñß‚ñ¶‚ñ©‚ô®‚òè‚òé‚òú‚òû¬∂‚Ä†‚Ä°‚Üï‚Üó‚Üô‚Üñ‚Üò‚ô≠‚ô©‚ô™‚ô¨„âø„àú‚Ññ„èá‚Ñ¢„èÇ„èò‚Ñ°‚Ç¨¬Æ"],["a341","Ï•±Ï•≤Ï•≥Ï•µ",6,"Ï•Ω",10,"Ï¶äÏ¶ãÏ¶çÏ¶éÏ¶è"],["a361","Ï¶ë",6,"Ï¶öÏ¶úÏ¶û",16],["a381","Ï¶Ø",16,"ÏßÇÏßÉÏßÖÏßÜÏßâÏßã",4,"ÏßíÏßîÏßóÏßòÏßõÔºÅ",58,"Ôø¶ÔºΩ",32,"Ôø£"],["a441","ÏßûÏßüÏß°Ïß£Ïß•Ïß¶Ïß®Ïß©Ïß™Ïß´ÏßÆÏß≤",5,"Ïß∫ÏßªÏßΩÏßæÏßøÏ®ÅÏ®ÇÏ®ÉÏ®Ñ"],["a461","Ï®ÖÏ®ÜÏ®áÏ®äÏ®é",5,"Ï®ïÏ®ñÏ®óÏ®ô",12],["a481","Ï®¶Ï®ßÏ®®Ï®™",28,"„Ñ±",93],["a541","Ï©á",4,"Ï©éÏ©èÏ©ëÏ©íÏ©ìÏ©ï",6,"Ï©ûÏ©¢",5,"Ï©©Ï©™"],["a561","Ï©´",17,"Ï©æ",5,"Ï™ÖÏ™Ü"],["a581","Ï™á",16,"Ï™ô",14,"‚Ö∞",9],["a5b0","‚Ö†",9],["a5c1","Œë",16,"Œ£",6],["a5e1","Œ±",16,"œÉ",6],["a641","Ï™®",19,"Ï™æÏ™øÏ´ÅÏ´ÇÏ´ÉÏ´Ö"],["a661","Ï´Ü",5,"Ï´éÏ´êÏ´íÏ´îÏ´ïÏ´ñÏ´óÏ´ö",5,"Ï´°",6],["a681","Ï´®Ï´©Ï´™Ï´´Ï´≠",6,"Ï´µ",18,"Ï¨âÏ¨ä‚îÄ‚îÇ‚îå‚îê‚îò‚îî‚îú‚î¨‚î§‚î¥‚îº‚îÅ‚îÉ‚îè‚îì‚îõ‚îó‚î£‚î≥‚î´‚îª‚ïã‚î†‚îØ‚î®‚î∑‚îø‚îù‚î∞‚î•‚î∏‚ïÇ‚îí‚îë‚îö‚îô‚îñ‚îï‚îé‚îç‚îû‚îü‚î°‚î¢‚î¶‚îß‚î©‚î™‚î≠‚îÆ‚î±‚î≤‚îµ‚î∂‚îπ‚î∫‚îΩ‚îæ‚ïÄ‚ïÅ‚ïÉ",7],["a741","Ï¨ã",4,"Ï¨ëÏ¨íÏ¨ìÏ¨ïÏ¨ñÏ¨óÏ¨ô",6,"Ï¨¢",7],["a761","Ï¨™",22,"Ï≠ÇÏ≠ÉÏ≠Ñ"],["a781","Ï≠ÖÏ≠ÜÏ≠áÏ≠äÏ≠ãÏ≠çÏ≠éÏ≠èÏ≠ë",6,"Ï≠öÏ≠õÏ≠úÏ≠û",5,"Ï≠•",7,"„éï„éñ„éó‚Ñì„éò„èÑ„é£„é§„é•„é¶„éô",9,"„èä„éç„éé„éè„èè„éà„éâ„èà„éß„é®„é∞",9,"„éÄ",4,"„é∫",5,"„éê",4,"‚Ñ¶„èÄ„èÅ„éä„éã„éå„èñ„èÖ„é≠„éÆ„éØ„èõ„é©„é™„é´„é¨„èù„èê„èì„èÉ„èâ„èú„èÜ"],["a841","Ï≠≠",10,"Ï≠∫",14],["a861","ÏÆâ",18,"ÏÆù",6],["a881","ÏÆ§",19,"ÏÆπ",11,"√Ü√ê¬™ƒ¶"],["a8a6","ƒ≤"],["a8a8","ƒø≈Å√ò≈í¬∫√û≈¶≈ä"],["a8b1","„â†",27,"‚ìê",25,"‚ë†",14,"¬Ω‚Öì‚Öî¬º¬æ‚Öõ‚Öú‚Öù‚Öû"],["a941","ÏØÖ",14,"ÏØï",10],["a961","ÏØ†ÏØ°ÏØ¢ÏØ£ÏØ•ÏØ¶ÏØ®ÏØ™",18],["a981","ÏØΩ",14,"Ï∞éÏ∞èÏ∞ëÏ∞íÏ∞ìÏ∞ï",6,"Ï∞ûÏ∞üÏ∞†Ï∞£Ï∞§√¶ƒë√∞ƒßƒ±ƒ≥ƒ∏≈Ä≈Ç√∏≈ì√ü√æ≈ß≈ã≈â„àÄ",27,"‚íú",25,"‚ë¥",14,"¬π¬≤¬≥‚Å¥‚Åø‚ÇÅ‚ÇÇ‚ÇÉ‚ÇÑ"],["aa41","Ï∞•Ï∞¶Ï∞™Ï∞´Ï∞≠Ï∞ØÏ∞±",6,"Ï∞∫Ï∞ø",4,"Ï±ÜÏ±áÏ±âÏ±äÏ±ãÏ±çÏ±é"],["aa61","Ï±è",4,"Ï±ñÏ±ö",5,"Ï±°Ï±¢Ï±£Ï±•Ï±ßÏ±©",6,"Ï±±Ï±≤"],["aa81","Ï±≥Ï±¥Ï±∂",29,"„ÅÅ",82],["ab41","Ï≤îÏ≤ïÏ≤ñÏ≤óÏ≤öÏ≤õÏ≤ùÏ≤ûÏ≤üÏ≤°",6,"Ï≤™Ï≤Æ",5,"Ï≤∂Ï≤∑Ï≤π"],["ab61","Ï≤∫Ï≤ªÏ≤Ω",6,"Ï≥ÜÏ≥àÏ≥ä",5,"Ï≥ëÏ≥íÏ≥ìÏ≥ï",5],["ab81","Ï≥õ",8,"Ï≥•",6,"Ï≥≠Ï≥ÆÏ≥ØÏ≥±",12,"„Ç°",85],["ac41","Ï≥æÏ≥øÏ¥ÄÏ¥Ç",5,"Ï¥äÏ¥ãÏ¥çÏ¥éÏ¥èÏ¥ë",6,"Ï¥öÏ¥úÏ¥ûÏ¥üÏ¥†"],["ac61","Ï¥°Ï¥¢Ï¥£Ï¥•Ï¥¶Ï¥ßÏ¥©Ï¥™Ï¥´Ï¥≠",11,"Ï¥∫",4],["ac81","Ï¥ø",28,"ÏµùÏµûÏµü–ê",5,"–Å–ñ",25],["acd1","–∞",5,"—ë–∂",25],["ad41","Ïµ°Ïµ¢Ïµ£Ïµ•",6,"ÏµÆÏµ∞Ïµ≤",5,"Ïµπ",7],["ad61","Ï∂Å",6,"Ï∂â",10,"Ï∂ñÏ∂óÏ∂ôÏ∂öÏ∂õÏ∂ùÏ∂ûÏ∂ü"],["ad81","Ï∂†Ï∂°Ï∂¢Ï∂£Ï∂¶Ï∂®Ï∂™",5,"Ï∂±",18,"Ï∑Ö"],["ae41","Ï∑Ü",5,"Ï∑çÏ∑éÏ∑èÏ∑ë",16],["ae61","Ï∑¢",5,"Ï∑©Ï∑™Ï∑´Ï∑≠Ï∑ÆÏ∑ØÏ∑±",6,"Ï∑∫Ï∑ºÏ∑æ",4],["ae81","Ï∏ÉÏ∏ÖÏ∏ÜÏ∏áÏ∏âÏ∏äÏ∏ãÏ∏ç",6,"Ï∏ïÏ∏ñÏ∏óÏ∏òÏ∏ö",5,"Ï∏¢Ï∏£Ï∏•Ï∏¶Ï∏ßÏ∏©Ï∏™Ï∏´"],["af41","Ï∏¨Ï∏≠Ï∏ÆÏ∏ØÏ∏≤Ï∏¥Ï∏∂",19],["af61","Ïπä",13,"ÏπöÏπõÏπùÏπûÏπ¢",5,"Ïπ™Ïπ¨"],["af81","ÏπÆ",5,"Ïπ∂Ïπ∑ÏππÏπ∫ÏπªÏπΩ",6,"Ï∫ÜÏ∫àÏ∫ä",5,"Ï∫íÏ∫ìÏ∫ïÏ∫ñÏ∫óÏ∫ô"],["b041","Ï∫ö",5,"Ï∫¢Ï∫¶",5,"Ï∫Æ",12],["b061","Ï∫ª",5,"ÏªÇ",19],["b081","Ïªñ",13,"Ïª¶ÏªßÏª©Ïª™Ïª≠",6,"Ïª∂Ïª∫",5,"Í∞ÄÍ∞ÅÍ∞ÑÍ∞áÍ∞àÍ∞âÍ∞äÍ∞ê",7,"Í∞ô",4,"Í∞†Í∞§Í∞¨Í∞≠Í∞ØÍ∞∞Í∞±Í∞∏Í∞πÍ∞ºÍ±ÄÍ±ãÍ±çÍ±îÍ±òÍ±úÍ±∞Í±±Í±¥Í±∑Í±∏Í±∫Í≤ÄÍ≤ÅÍ≤ÉÍ≤ÑÍ≤ÖÍ≤ÜÍ≤âÍ≤äÍ≤ãÍ≤åÍ≤êÍ≤îÍ≤úÍ≤ùÍ≤üÍ≤†Í≤°Í≤®Í≤©Í≤™Í≤¨Í≤ØÍ≤∞Í≤∏Í≤πÍ≤ªÍ≤ºÍ≤ΩÍ≥ÅÍ≥ÑÍ≥àÍ≥åÍ≥ïÍ≥óÍ≥†Í≥°Í≥§Í≥ßÍ≥®Í≥™Í≥¨Í≥ØÍ≥∞Í≥±Í≥≥Í≥µÍ≥∂Í≥ºÍ≥ΩÍ¥ÄÍ¥ÑÍ¥Ü"],["b141","ÏºÇÏºÉÏºÖÏºÜÏºáÏºâ",6,"ÏºíÏºîÏºñ",5,"ÏºùÏºûÏºüÏº°Ïº¢Ïº£"],["b161","Ïº•",6,"ÏºÆÏº≤",5,"Ïºπ",11],["b181","ÏΩÖ",14,"ÏΩñÏΩóÏΩôÏΩöÏΩõÏΩù",6,"ÏΩ¶ÏΩ®ÏΩ™ÏΩ´ÏΩ¨Í¥åÍ¥çÍ¥èÍ¥ëÍ¥òÍ¥úÍ¥†Í¥©Í¥¨Í¥≠Í¥¥Í¥µÍ¥∏Í¥ºÍµÑÍµÖÍµáÍµâÍµêÍµîÍµòÍµ°Íµ£Íµ¨Íµ≠Íµ∞Íµ≥Íµ¥ÍµµÍµ∂ÍµªÍµºÍµΩÍµøÍ∂ÅÍ∂ÇÍ∂àÍ∂âÍ∂åÍ∂êÍ∂úÍ∂ùÍ∂§Í∂∑Í∑ÄÍ∑ÅÍ∑ÑÍ∑àÍ∑êÍ∑ëÍ∑ìÍ∑úÍ∑†Í∑§Í∑∏Í∑πÍ∑ºÍ∑øÍ∏ÄÍ∏ÅÍ∏àÍ∏âÍ∏ãÍ∏çÍ∏îÍ∏∞Í∏±Í∏¥Í∏∑Í∏∏Í∏∫ÍπÄÍπÅÍπÉÍπÖÍπÜÍπäÍπåÍπçÍπéÍπêÍπîÍπñÍπúÍπùÍπüÍπ†Íπ°Íπ•Íπ®Íπ©Íπ¨Íπ∞Íπ∏"],["b241","ÏΩ≠ÏΩÆÏΩØÏΩ≤ÏΩ≥ÏΩµÏΩ∂ÏΩ∑ÏΩπ",6,"ÏæÅÏæÇÏæÉÏæÑÏæÜ",5,"Ïæç"],["b261","Ïæé",18,"Ïæ¢",5,"Ïæ©"],["b281","Ïæ™",5,"Ïæ±",18,"ÏøÖ",6,"ÍππÍπªÍπºÍπΩÍ∫ÑÍ∫ÖÍ∫åÍ∫ºÍ∫ΩÍ∫æÍªÄÍªÑÍªåÍªçÍªèÍªêÍªëÍªòÍªôÍªúÍª®Íª´Íª≠Íª¥Íª∏ÍªºÍºáÍºàÍºçÍºêÍº¨Íº≠Íº∞Íº≤Íº¥ÍººÍºΩÍºøÍΩÅÍΩÇÍΩÉÍΩàÍΩâÍΩêÍΩúÍΩùÍΩ§ÍΩ•ÍΩπÍæÄÍæÑÍæàÍæêÍæëÍæïÍæúÍæ∏ÍæπÍæºÍøÄÍøáÍøàÍøâÍøãÍøçÍøéÍøîÍøúÍø®Íø©Íø∞Íø±Íø¥Íø∏ÎÄÄÎÄÅÎÄÑÎÄåÎÄêÎÄîÎÄúÎÄùÎÄ®ÎÅÑÎÅÖÎÅàÎÅäÎÅåÎÅéÎÅìÎÅîÎÅïÎÅóÎÅô"],["b341","Ïøå",19,"Ïø¢Ïø£Ïø•Ïø¶ÏøßÏø©"],["b361","Ïø™",5,"Ïø≤Ïø¥Ïø∂",5,"ÏøΩÏøæÏøøÌÄÅÌÄÇÌÄÉÌÄÖ",5],["b381","ÌÄã",5,"ÌÄí",5,"ÌÄô",19,"ÎÅùÎÅºÎÅΩÎÇÄÎÇÑÎÇåÎÇçÎÇèÎÇëÎÇòÎÇôÎÇöÎÇúÎÇüÎÇ†ÎÇ°ÎÇ¢ÎÇ®ÎÇ©ÎÇ´",4,"ÎÇ±ÎÇ≥ÎÇ¥ÎÇµÎÇ∏ÎÇºÎÉÑÎÉÖÎÉáÎÉàÎÉâÎÉêÎÉëÎÉîÎÉòÎÉ†ÎÉ•ÎÑàÎÑâÎÑãÎÑåÎÑêÎÑíÎÑìÎÑòÎÑôÎÑõÎÑúÎÑùÎÑ£ÎÑ§ÎÑ•ÎÑ®ÎÑ¨ÎÑ¥ÎÑµÎÑ∑ÎÑ∏ÎÑπÎÖÄÎÖÅÎÖÑÎÖàÎÖêÎÖëÎÖîÎÖïÎÖòÎÖúÎÖ†ÎÖ∏ÎÖπÎÖºÎÜÄÎÜÇÎÜàÎÜâÎÜãÎÜçÎÜíÎÜìÎÜîÎÜòÎÜúÎÜ®ÎáåÎáêÎáîÎáúÎáù"],["b441","ÌÄÆ",5,"ÌÄ∂ÌÄ∑ÌÄπÌÄ∫ÌÄªÌÄΩ",6,"ÌÅÜÌÅàÌÅä",5],["b461","ÌÅëÌÅíÌÅìÌÅïÌÅñÌÅóÌÅô",6,"ÌÅ°",10,"ÌÅÆÌÅØ"],["b481","ÌÅ±ÌÅ≤ÌÅ≥ÌÅµ",6,"ÌÅæÌÅøÌÇÄÌÇÇ",18,"ÎáüÎá®Îá©Îá¨Îá∞ÎáπÎáªÎáΩÎàÑÎàÖÎààÎàãÎàåÎàîÎàïÎàóÎàôÎà†Îà¥ÎàºÎâòÎâúÎâ†Îâ®Îâ©Îâ¥ÎâµÎâºÎäÑÎäÖÎäâÎäêÎäëÎäîÎäòÎäôÎäöÎä†Îä°Îä£Îä•Îä¶Îä™Îä¨Îä∞Îä¥ÎãàÎãâÎãåÎãêÎãíÎãòÎãôÎãõÎãùÎã¢Îã§Îã•Îã¶Îã®Îã´",4,"Îã≥Îã¥ÎãµÎã∑",4,"ÎãøÎåÄÎåÅÎåÑÎåàÎåêÎåëÎåìÎåîÎåïÎåúÎçîÎçïÎçñÎçòÎçõÎçúÎçûÎçüÎç§Îç•"],["b541","ÌÇï",14,"ÌÇ¶ÌÇßÌÇ©ÌÇ™ÌÇ´ÌÇ≠",5],["b561","ÌÇ≥ÌÇ∂ÌÇ∏ÌÇ∫",5,"ÌÉÇÌÉÉÌÉÖÌÉÜÌÉáÌÉä",5,"ÌÉíÌÉñ",4],["b581","ÌÉõÌÉûÌÉüÌÉ°ÌÉ¢ÌÉ£ÌÉ•",6,"ÌÉÆÌÉ≤",5,"ÌÉπ",11,"ÎçßÎç©Îç´ÎçÆÎç∞Îç±Îç¥Îç∏ÎéÄÎéÅÎéÉÎéÑÎéÖÎéåÎéêÎéîÎé†Îé°Îé®Îé¨ÎèÑÎèÖÎèàÎèãÎèåÎèéÎèêÎèîÎèïÎèóÎèôÎèõÎèùÎè†Îè§Îè®ÎèºÎêêÎêòÎêúÎê†Îê®Îê©Îê´Îê¥ÎëêÎëëÎëîÎëòÎë†Îë°Îë£Îë•Îë¨ÎíÄÎíàÎíùÎí§Îí®Îí¨ÎíµÎí∑ÎíπÎìÄÎìÑÎìàÎìêÎìïÎìúÎìùÎì†Îì£Îì§Îì¶Îì¨Îì≠ÎìØÎì±Îì∏ÎîîÎîïÎîòÎîõÎîúÎî§Îî•ÎîßÎî®Îî©Îî™Îî∞Îî±Îî¥Îî∏"],["b641","ÌÑÖ",7,"ÌÑé",17],["b661","ÌÑ†",15,"ÌÑ≤ÌÑ≥ÌÑµÌÑ∂ÌÑ∑ÌÑπÌÑªÌÑºÌÑΩÌÑæ"],["b681","ÌÑøÌÖÇÌÖÜ",5,"ÌÖéÌÖèÌÖëÌÖíÌÖìÌÖï",6,"ÌÖûÌÖ†ÌÖ¢",5,"ÌÖ©ÌÖ™ÌÖ´ÌÖ≠ÎïÄÎïÅÎïÉÎïÑÎïÖÎïãÎïåÎïçÎïêÎïîÎïúÎïùÎïüÎï†Îï°Îñ†Îñ°Îñ§Îñ®Îñ™Îñ´Îñ∞Îñ±Îñ≥Îñ¥ÎñµÎñªÎñºÎñΩÎóÄÎóÑÎóåÎóçÎóèÎóêÎóëÎóòÎó¨ÎòêÎòëÎòîÎòòÎò•Îò¨Îò¥ÎôàÎô§Îô®ÎöúÎöùÎö†Îö§Îö´Îö¨Îö±ÎõîÎõ∞Îõ¥Îõ∏ÎúÄÎúÅÎúÖÎú®Îú©Îú¨ÎúØÎú∞Îú∏ÎúπÎúªÎùÑÎùàÎùåÎùîÎùïÎù†Îù§Îù®Îù∞Îù±Îù≥ÎùµÎùºÎùΩÎûÄÎûÑÎûåÎûçÎûèÎûêÎûëÎûíÎûñÎûó"],["b741","ÌÖÆ",13,"ÌÖΩ",6,"ÌÜÖÌÜÜÌÜáÌÜâÌÜä"],["b761","ÌÜã",20,"ÌÜ¢ÌÜ£ÌÜ•ÌÜ¶ÌÜß"],["b781","ÌÜ©",6,"ÌÜ≤ÌÜ¥ÌÜ∂ÌÜ∑ÌÜ∏ÌÜπÌÜªÌÜΩÌÜæÌÜøÌáÅ",14,"ÎûòÎûôÎûúÎû†Îû®Îû©Îû´Îû¨Îû≠Îû¥ÎûµÎû∏ÎüáÎüâÎü¨Îü≠Îü∞Îü¥ÎüºÎüΩÎüøÎ†ÄÎ†ÅÎ†áÎ†àÎ†âÎ†åÎ†êÎ†òÎ†ôÎ†õÎ†ùÎ†§Î†•Î†®Î†¨Î†¥Î†µÎ†∑Î†∏Î†πÎ°ÄÎ°ÑÎ°ëÎ°ìÎ°úÎ°ùÎ°†Î°§Î°¨Î°≠Î°ØÎ°±Î°∏Î°ºÎ¢çÎ¢®Î¢∞Î¢¥Î¢∏Î£ÄÎ£ÅÎ£ÉÎ£ÖÎ£åÎ£êÎ£îÎ£ùÎ£üÎ£°Î£®Î£©Î£¨Î£∞Î£∏Î£πÎ£ªÎ£ΩÎ§ÑÎ§òÎ§†Î§ºÎ§ΩÎ•ÄÎ•ÑÎ•åÎ•èÎ•ëÎ•òÎ•ôÎ•úÎ•†Î•®Î•©"],["b841","Ìáê",7,"Ìáô",17],["b861","Ìá´",8,"ÌáµÌá∂Ìá∑Ìáπ",13],["b881","ÌààÌàä",5,"Ìàë",24,"Î•´Î•≠Î•¥Î•µÎ•∏Î•ºÎ¶ÑÎ¶ÖÎ¶áÎ¶âÎ¶äÎ¶çÎ¶éÎ¶¨Î¶≠Î¶∞Î¶¥Î¶ºÎ¶ΩÎ¶øÎßÅÎßàÎßâÎßåÎßé",4,"ÎßòÎßôÎßõÎßùÎßûÎß°Îß£Îß§Îß•Îß®Îß¨Îß¥ÎßµÎß∑Îß∏ÎßπÎß∫Î®ÄÎ®ÅÎ®àÎ®ïÎ®∏Î®πÎ®ºÎ©ÄÎ©ÇÎ©àÎ©âÎ©ãÎ©çÎ©éÎ©ìÎ©îÎ©ïÎ©òÎ©úÎ©§Î©•Î©ßÎ©®Î©©Î©∞Î©±Î©¥Î©∏Î™ÉÎ™ÑÎ™ÖÎ™áÎ™åÎ™®Î™©Î™´Î™¨Î™∞Î™≤Î™∏Î™πÎ™ªÎ™ΩÎ´ÑÎ´àÎ´òÎ´ôÎ´º"],["b941","Ìà™Ìà´ÌàÆÌàØÌà±Ìà≤Ìà≥Ìàµ",6,"ÌàæÌâÄÌâÇ",5,"ÌââÌâäÌâãÌâå"],["b961","Ìâç",14,"Ìâù",6,"Ìâ•Ìâ¶ÌâßÌâ®"],["b981","Ìâ©",22,"ÌäÇÌäÉÌäÖÌäÜÌäáÌäâÌääÌäãÌäåÎ¨ÄÎ¨ÑÎ¨çÎ¨èÎ¨ëÎ¨òÎ¨úÎ¨†Î¨©Î¨´Î¨¥Î¨µÎ¨∂Î¨∏Î¨ªÎ¨ºÎ¨ΩÎ¨æÎ≠ÑÎ≠ÖÎ≠áÎ≠âÎ≠çÎ≠èÎ≠êÎ≠îÎ≠òÎ≠°Î≠£Î≠¨ÎÆàÎÆåÎÆêÎÆ§ÎÆ®ÎÆ¨ÎÆ¥ÎÆ∑ÎØÄÎØÑÎØàÎØêÎØìÎØ∏ÎØπÎØºÎØøÎ∞ÄÎ∞ÇÎ∞àÎ∞âÎ∞ãÎ∞åÎ∞çÎ∞èÎ∞ëÎ∞î",4,"Î∞õ",4,"Î∞§Î∞•Î∞ßÎ∞©Î∞≠Î∞∞Î∞±Î∞¥Î∞∏Î±ÄÎ±ÅÎ±ÉÎ±ÑÎ±ÖÎ±âÎ±åÎ±çÎ±êÎ±ùÎ≤ÑÎ≤ÖÎ≤àÎ≤ãÎ≤åÎ≤éÎ≤îÎ≤ïÎ≤ó"],["ba41","ÌäçÌäéÌäèÌäíÌäìÌäîÌäñ",5,"ÌäùÌäûÌäüÌä°Ìä¢Ìä£Ìä•",6,"Ìä≠"],["ba61","ÌäÆÌäØÌä∞Ìä≤",5,"Ìä∫ÌäªÌäΩÌäæÌãÅÌãÉ",4,"ÌãäÌãå",5],["ba81","ÌãíÌãìÌãïÌãñÌãóÌãôÌãöÌãõÌãù",6,"Ìã¶",9,"Ìã≤Ìã≥ÌãµÌã∂Ìã∑ÌãπÌã∫Î≤ôÎ≤öÎ≤†Î≤°Î≤§Î≤ßÎ≤®Î≤∞Î≤±Î≤≥Î≤¥Î≤µÎ≤ºÎ≤ΩÎ≥ÄÎ≥ÑÎ≥çÎ≥èÎ≥êÎ≥ëÎ≥ïÎ≥òÎ≥úÎ≥¥Î≥µÎ≥∂Î≥∏Î≥ºÎ¥ÑÎ¥ÖÎ¥áÎ¥âÎ¥êÎ¥îÎ¥§Î¥¨ÎµÄÎµàÎµâÎµåÎµêÎµòÎµôÎµ§Îµ®Î∂ÄÎ∂ÅÎ∂ÑÎ∂áÎ∂àÎ∂âÎ∂äÎ∂êÎ∂ëÎ∂ìÎ∂ïÎ∂ôÎ∂öÎ∂úÎ∂§Î∂∞Î∂∏Î∑îÎ∑ïÎ∑òÎ∑úÎ∑©Î∑∞Î∑¥Î∑∏Î∏ÄÎ∏ÉÎ∏ÖÎ∏åÎ∏çÎ∏êÎ∏îÎ∏úÎ∏ùÎ∏üÎπÑÎπÖÎπàÎπåÎπéÎπîÎπïÎπóÎπôÎπöÎπõÎπ†Îπ°Îπ§"],["bb41","Ìãª",4,"ÌåÇÌåÑÌåÜ",5,"ÌåèÌåëÌåíÌåìÌåïÌåó",4,"ÌåûÌå¢Ìå£"],["bb61","Ìå§Ìå¶ÌåßÌå™Ìå´Ìå≠ÌåÆÌåØÌå±",6,"Ìå∫Ìåæ",5,"ÌçÜÌçáÌçàÌçâ"],["bb81","Ìçä",31,"Îπ®Îπ™Îπ∞Îπ±Îπ≥Îπ¥ÎπµÎπªÎπºÎπΩÎ∫ÄÎ∫ÑÎ∫åÎ∫çÎ∫èÎ∫êÎ∫ëÎ∫òÎ∫ôÎ∫®ÎªêÎªëÎªîÎªóÎªòÎª†Îª£Îª§Îª•Îª¨ÎºÅÎºàÎºâÎºòÎºôÎºõÎºúÎºùÎΩÄÎΩÅÎΩÑÎΩàÎΩêÎΩëÎΩïÎæîÎæ∞ÎøÖÎøåÎøçÎøêÎøîÎøúÎøüÎø°ÏÄºÏÅëÏÅòÏÅúÏÅ†ÏÅ®ÏÅ©ÏÇêÏÇëÏÇîÏÇòÏÇ†ÏÇ°ÏÇ£ÏÇ•ÏÇ¨ÏÇ≠ÏÇØÏÇ∞ÏÇ≥ÏÇ¥ÏÇµÏÇ∂ÏÇºÏÇΩÏÇøÏÉÄÏÉÅÏÉÖÏÉàÏÉâÏÉåÏÉêÏÉòÏÉôÏÉõÏÉúÏÉùÏÉ§"],["bc41","Ìç™",17,"ÌçæÌçøÌéÅÌéÇÌéÉÌéÖÌéÜÌéá"],["bc61","ÌéàÌéâÌéäÌéãÌééÌéí",5,"ÌéöÌéõÌéùÌéûÌéüÌé°",6,"Ìé™Ìé¨ÌéÆ"],["bc81","ÌéØ",4,"ÌéµÌé∂Ìé∑ÌéπÌé∫ÌéªÌéΩ",6,"ÌèÜÌèáÌèä",5,"Ìèë",5,"ÏÉ•ÏÉ®ÏÉ¨ÏÉ¥ÏÉµÏÉ∑ÏÉπÏÑÄÏÑÑÏÑàÏÑêÏÑïÏÑú",4,"ÏÑ£ÏÑ§ÏÑ¶ÏÑßÏÑ¨ÏÑ≠ÏÑØÏÑ∞ÏÑ±ÏÑ∂ÏÑ∏ÏÑπÏÑºÏÖÄÏÖàÏÖâÏÖãÏÖåÏÖçÏÖîÏÖïÏÖòÏÖúÏÖ§ÏÖ•ÏÖßÏÖ®ÏÖ©ÏÖ∞ÏÖ¥ÏÖ∏ÏÜÖÏÜåÏÜçÏÜéÏÜêÏÜîÏÜñÏÜúÏÜùÏÜüÏÜ°ÏÜ•ÏÜ®ÏÜ©ÏÜ¨ÏÜ∞ÏÜΩÏáÑÏáàÏáåÏáîÏáóÏáòÏá†Ïá§Ïá®Ïá∞Ïá±Ïá≥ÏáºÏáΩÏàÄÏàÑÏàåÏàçÏàèÏàëÏàòÏàôÏàúÏàüÏà†Ïà®Ïà©Ïà´Ïà≠"],["bd41","ÌèóÌèô",7,"Ìè¢Ìè§",7,"ÌèÆÌèØÌè±Ìè≤Ìè≥ÌèµÌè∂Ìè∑"],["bd61","Ìè∏ÌèπÌè∫ÌèªÌèæÌêÄÌêÇ",5,"Ìêâ",13],["bd81","Ìêó",5,"Ìêû",25,"ÏàØÏà±Ïà≤Ïà¥ÏâàÏâêÏâëÏâîÏâòÏâ†Ïâ•Ïâ¨Ïâ≠Ïâ∞Ïâ¥ÏâºÏâΩÏâøÏäÅÏäàÏäâÏäêÏäòÏäõÏäùÏä§Ïä•Ïä®Ïä¨Ïä≠Ïä¥ÏäµÏä∑ÏäπÏãúÏãùÏã†Ïã£Ïã§Ïã´Ïã¨Ïã≠ÏãØÏã±Ïã∂Ïã∏ÏãπÏãªÏãºÏåÄÏåàÏåâÏååÏåçÏåìÏåîÏåïÏåòÏåúÏå§Ïå•Ïå®Ïå©ÏçÖÏç®Ïç©Ïç¨Ïç∞Ïç≤Ïç∏ÏçπÏçºÏçΩÏéÑÏéàÏéåÏèÄÏèòÏèôÏèúÏèüÏè†Ïè¢Ïè®Ïè©Ïè≠Ïè¥ÏèµÏè∏ÏêàÏêêÏê§Ïê¨Ïê∞"],["be41","Ìê∏",7,"ÌëÅÌëÇÌëÉÌëÖ",14],["be61","Ìëî",7,"ÌëùÌëûÌëüÌë°Ìë¢Ìë£Ìë•",7,"ÌëÆÌë∞Ìë±Ìë≤"],["be81","Ìë≥",4,"Ìë∫ÌëªÌëΩÌëæÌíÅÌíÉ",4,"ÌíäÌíåÌíé",5,"Ìíï",8,"Ïê¥ÏêºÏêΩÏëàÏë§Ïë•Ïë®Ïë¨Ïë¥ÏëµÏëπÏíÄÏíîÏíúÏí∏ÏíºÏì©Ïì∞Ïì±Ïì¥Ïì∏Ïì∫ÏìøÏîÄÏîÅÏîåÏîêÏîîÏîúÏî®Ïî©Ïî¨Ïî∞Ïî∏ÏîπÏîªÏîΩÏïÑÏïÖÏïàÏïâÏïäÏïåÏïçÏïéÏïìÏïîÏïïÏïóÏïòÏïôÏïùÏïûÏï†Ïï°Ïï§Ïï®Ïï∞Ïï±Ïï≥Ïï¥ÏïµÏïºÏïΩÏñÄÏñÑÏñáÏñåÏñçÏñèÏñëÏñïÏñóÏñòÏñúÏñ†Ïñ©Ïñ¥ÏñµÏñ∏ÏñπÏñªÏñºÏñΩÏñæÏóÑ",6,"ÏóåÏóé"],["bf41","Ìíû",10,"Ìí™",14],["bf61","Ìíπ",18,"ÌìçÌìéÌìèÌìëÌìíÌììÌìï"],["bf81","Ììñ",5,"ÌìùÌìûÌì†",7,"Ìì©Ìì™Ìì´Ìì≠ÌìÆÌìØÌì±",6,"ÌìπÌì∫ÌìºÏóêÏóëÏóîÏóòÏó†Ïó°Ïó£Ïó•Ïó¨Ïó≠ÏóÆÏó∞Ïó¥Ïó∂Ïó∑Ïóº",5,"ÏòÖÏòÜÏòáÏòàÏòåÏòêÏòòÏòôÏòõÏòúÏò§Ïò•Ïò®Ïò¨Ïò≠ÏòÆÏò∞Ïò≥Ïò¥ÏòµÏò∑ÏòπÏòªÏôÄÏôÅÏôÑÏôàÏôêÏôëÏôìÏôîÏôïÏôúÏôùÏô†Ïô¨ÏôØÏô±Ïô∏ÏôπÏôºÏöÄÏöàÏöâÏöãÏöçÏöîÏöïÏöòÏöúÏö§Ïö•ÏößÏö©Ïö∞Ïö±Ïö¥Ïö∏ÏöπÏö∫ÏõÄÏõÅÏõÉÏõÖÏõåÏõçÏõêÏõîÏõúÏõùÏõ†Ïõ°Ïõ®"],["c041","Ììæ",5,"ÌîÖÌîÜÌîáÌîâÌîäÌîãÌîç",6,"ÌîñÌîò",5],["c061","Ìîû",25],["c081","Ìî∏ÌîπÌî∫ÌîªÌîæÌîøÌïÅÌïÇÌïÉÌïÖ",6,"ÌïéÌïêÌïí",5,"ÌïöÌïõÌïùÌïûÌïüÌï°Ìï¢Ìï£Ïõ©Ïõ¨Ïõ∞Ïõ∏ÏõπÏõΩÏúÑÏúÖÏúàÏúåÏúîÏúïÏúóÏúôÏú†Ïú°Ïú§Ïú®Ïú∞Ïú±Ïú≥ÏúµÏú∑ÏúºÏúΩÏùÄÏùÑÏùäÏùåÏùçÏùèÏùë",7,"ÏùúÏù†Ïù®Ïù´Ïù¥ÏùµÏù∏ÏùºÏùΩÏùæÏûÉÏûÑÏûÖÏûáÏûàÏûâÏûäÏûéÏûêÏûëÏûîÏûñÏûóÏûòÏûöÏû†Ïû°Ïû£Ïû§Ïû•Ïû¶Ïû¨Ïû≠Ïû∞Ïû¥ÏûºÏûΩÏûøÏüÄÏüÅÏüàÏüâÏüåÏüéÏüêÏüòÏüùÏü§Ïü®Ïü¨Ï†ÄÏ†ÅÏ†ÑÏ†àÏ†ä"],["c141","Ìï§Ìï¶ÌïßÌï™Ìï¨ÌïÆ",5,"Ìï∂Ìï∑ÌïπÌï∫ÌïªÌïΩ",6,"ÌñÜÌñäÌñã"],["c161","ÌñåÌñçÌñéÌñèÌñë",19,"Ìñ¶Ìñß"],["c181","Ìñ®",31,"Ï†êÏ†ëÏ†ìÏ†ïÏ†ñÏ†úÏ†ùÏ††Ï†§Ï†¨Ï†≠Ï†ØÏ†±Ï†∏Ï†ºÏ°ÄÏ°àÏ°âÏ°åÏ°çÏ°îÏ°∞Ï°±Ï°¥Ï°∏Ï°∫Ï¢ÄÏ¢ÅÏ¢ÉÏ¢ÖÏ¢ÜÏ¢áÏ¢ãÏ¢åÏ¢çÏ¢îÏ¢ùÏ¢üÏ¢°Ï¢®Ï¢ºÏ¢ΩÏ£ÑÏ£àÏ£åÏ£îÏ£ïÏ£óÏ£ôÏ£†Ï£°Ï£§Ï£µÏ£ºÏ£ΩÏ§ÄÏ§ÑÏ§ÖÏ§ÜÏ§åÏ§çÏ§èÏ§ëÏ§òÏ§¨Ï§¥Ï•êÏ•ëÏ•îÏ•òÏ•†Ï•°Ï•£Ï•¨Ï•∞Ï•¥Ï•ºÏ¶àÏ¶âÏ¶åÏ¶êÏ¶òÏ¶ôÏ¶õÏ¶ùÏßÄÏßÅÏßÑÏßáÏßàÏßäÏßêÏßëÏßì"],["c241","ÌóäÌóãÌóçÌóéÌóèÌóëÌóì",4,"ÌóöÌóúÌóû",5,"Ìó¶ÌóßÌó©Ìó™Ìó´Ìó≠ÌóÆ"],["c261","ÌóØ",4,"Ìó∂Ìó∏Ìó∫",5,"ÌòÇÌòÉÌòÖÌòÜÌòáÌòâ",6,"Ìòí"],["c281","Ìòñ",5,"ÌòùÌòûÌòüÌò°Ìò¢Ìò£Ìò•",7,"ÌòÆ",9,"Ìò∫ÌòªÏßïÏßñÏßôÏßöÏßúÏßùÏß†Ïß¢Ïß§ÏßßÏß¨Ïß≠ÏßØÏß∞Ïß±Ïß∏ÏßπÏßºÏ®ÄÏ®àÏ®âÏ®ãÏ®åÏ®çÏ®îÏ®òÏ®©Ï©åÏ©çÏ©êÏ©îÏ©úÏ©ùÏ©üÏ©†Ï©°Ï©®Ï©ΩÏ™ÑÏ™òÏ™ºÏ™ΩÏ´ÄÏ´ÑÏ´åÏ´çÏ´èÏ´ëÏ´ìÏ´òÏ´ôÏ´†Ï´¨Ï´¥Ï¨àÏ¨êÏ¨îÏ¨òÏ¨†Ï¨°Ï≠ÅÏ≠àÏ≠âÏ≠åÏ≠êÏ≠òÏ≠ôÏ≠ùÏ≠§Ï≠∏Ï≠πÏÆúÏÆ∏ÏØîÏØ§ÏØßÏØ©Ï∞åÏ∞çÏ∞êÏ∞îÏ∞úÏ∞ùÏ∞°Ï∞¢Ï∞ßÏ∞®Ï∞©Ï∞¨Ï∞ÆÏ∞∞Ï∞∏Ï∞πÏ∞ª"],["c341","ÌòΩÌòæÌòøÌôÅÌôÇÌôÉÌôÑÌôÜÌôáÌôäÌôåÌôéÌôèÌôêÌôíÌôìÌôñÌôóÌôôÌôöÌôõÌôù",4],["c361","Ìô¢",4,"Ìô®Ìô™",5,"Ìô≤Ìô≥Ìôµ",11],["c381","ÌöÅÌöÇÌöÑÌöÜ",5,"ÌöéÌöèÌöëÌöíÌöìÌöï",7,"ÌöûÌö†Ìö¢",5,"Ìö©Ìö™Ï∞ºÏ∞ΩÏ∞æÏ±ÑÏ±ÖÏ±àÏ±åÏ±îÏ±ïÏ±óÏ±òÏ±ôÏ±†Ï±§Ï±¶Ï±®Ï±∞Ï±µÏ≤òÏ≤ôÏ≤úÏ≤†Ï≤®Ï≤©Ï≤´Ï≤¨Ï≤≠Ï≤¥Ï≤µÏ≤∏Ï≤ºÏ≥ÑÏ≥ÖÏ≥áÏ≥âÏ≥êÏ≥îÏ≥§Ï≥¨Ï≥∞Ï¥ÅÏ¥àÏ¥âÏ¥åÏ¥êÏ¥òÏ¥ôÏ¥õÏ¥ùÏ¥§Ï¥®Ï¥¨Ï¥πÏµúÏµ†Ïµ§Ïµ¨Ïµ≠ÏµØÏµ±Ïµ∏Ï∂àÏ∂îÏ∂ïÏ∂òÏ∂úÏ∂§Ï∂•Ï∂ßÏ∂©Ï∂∞Ï∑ÑÏ∑åÏ∑êÏ∑®Ï∑¨Ï∑∞Ï∑∏Ï∑πÏ∑ªÏ∑ΩÏ∏ÑÏ∏àÏ∏åÏ∏îÏ∏ôÏ∏†Ï∏°Ï∏§Ï∏®Ï∏∞Ï∏±Ï∏≥Ï∏µ"],["c441","Ìö´Ìö≠ÌöÆÌöØÌö±",7,"Ìö∫Ìöº",7,"ÌõÜÌõáÌõâÌõäÌõã"],["c461","ÌõçÌõéÌõèÌõêÌõíÌõìÌõïÌõñÌõòÌõö",5,"Ìõ°Ìõ¢Ìõ£Ìõ•Ìõ¶ÌõßÌõ©",4],["c481","ÌõÆÌõØÌõ±Ìõ≤Ìõ≥Ìõ¥Ìõ∂",5,"ÌõæÌõøÌúÅÌúÇÌúÉÌúÖ",11,"ÌúíÌúìÌúîÏπòÏπôÏπúÏπüÏπ†Ïπ°Ïπ®Ïπ©Ïπ´Ïπ≠Ïπ¥ÏπµÏπ∏ÏπºÏ∫ÑÏ∫ÖÏ∫áÏ∫âÏ∫êÏ∫ëÏ∫îÏ∫òÏ∫†Ï∫°Ï∫£Ï∫§Ï∫•Ï∫¨Ï∫≠ÏªÅÏª§Ïª•Ïª®Ïª´Ïª¨Ïª¥ÏªµÏª∑Ïª∏ÏªπÏºÄÏºÅÏºÑÏºàÏºêÏºëÏºìÏºïÏºúÏº†Ïº§Ïº¨Ïº≠ÏºØÏº∞Ïº±Ïº∏ÏΩîÏΩïÏΩòÏΩúÏΩ§ÏΩ•ÏΩßÏΩ©ÏΩ∞ÏΩ±ÏΩ¥ÏΩ∏ÏæÄÏæÖÏæåÏæ°Ïæ®Ïæ∞ÏøÑÏø†Ïø°Ïø§Ïø®Ïø∞Ïø±Ïø≥ÏøµÏøºÌÄÄÌÄÑÌÄëÌÄòÌÄ≠ÌÄ¥ÌÄµÌÄ∏ÌÄº"],["c541","ÌúïÌúñÌúóÌúöÌúõÌúùÌúûÌúüÌú°",6,"Ìú™Ìú¨ÌúÆ",5,"Ìú∂Ìú∑Ìúπ"],["c561","Ìú∫ÌúªÌúΩ",6,"ÌùÖÌùÜÌùàÌùä",5,"ÌùíÌùìÌùïÌùö",4],["c581","ÌùüÌù¢Ìù§Ìù¶ÌùßÌù®Ìù™Ìù´Ìù≠ÌùÆÌùØÌù±Ìù≤Ìù≥Ìùµ",6,"ÌùæÌùøÌûÄÌûÇ",5,"ÌûäÌûãÌÅÑÌÅÖÌÅáÌÅâÌÅêÌÅîÌÅòÌÅ†ÌÅ¨ÌÅ≠ÌÅ∞ÌÅ¥ÌÅºÌÅΩÌÇÅÌÇ§ÌÇ•ÌÇ®ÌÇ¨ÌÇ¥ÌÇµÌÇ∑ÌÇπÌÉÄÌÉÅÌÉÑÌÉàÌÉâÌÉêÌÉëÌÉìÌÉîÌÉïÌÉúÌÉùÌÉ†ÌÉ§ÌÉ¨ÌÉ≠ÌÉØÌÉ∞ÌÉ±ÌÉ∏ÌÑçÌÑ∞ÌÑ±ÌÑ¥ÌÑ∏ÌÑ∫ÌÖÄÌÖÅÌÖÉÌÖÑÌÖÖÌÖåÌÖçÌÖêÌÖîÌÖúÌÖùÌÖüÌÖ°ÌÖ®ÌÖ¨ÌÖºÌÜÑÌÜàÌÜ†ÌÜ°ÌÜ§ÌÜ®ÌÜ∞ÌÜ±ÌÜ≥ÌÜµÌÜ∫ÌÜºÌáÄÌáòÌá¥Ìá∏ÌàáÌàâÌàêÌà¨Ìà≠Ìà∞Ìà¥ÌàºÌàΩÌàøÌâÅÌâàÌâú"],["c641","ÌûçÌûéÌûèÌûë",6,"ÌûöÌûúÌûû",5],["c6a1","Ìâ§ÌäÄÌäÅÌäÑÌäàÌäêÌäëÌäïÌäúÌä†Ìä§Ìä¨Ìä±Ìä∏ÌäπÌäºÌäøÌãÄÌãÇÌãàÌãâÌããÌãîÌãòÌãúÌã§Ìã•Ìã∞Ìã±Ìã¥Ìã∏ÌåÄÌåÅÌåÉÌåÖÌååÌåçÌåéÌåêÌåîÌåñÌåúÌåùÌåüÌå†Ìå°Ìå•Ìå®Ìå©Ìå¨Ìå∞Ìå∏ÌåπÌåªÌåºÌåΩÌçÑÌçÖÌçºÌçΩÌéÄÌéÑÌéåÌéçÌéèÌéêÌéëÌéòÌéôÌéúÌé†Ìé®Ìé©Ìé´Ìé≠Ìé¥Ìé∏ÌéºÌèÑÌèÖÌèàÌèâÌèêÌèòÌè°Ìè£Ìè¨Ìè≠Ìè∞Ìè¥ÌèºÌèΩÌèøÌêÅ"],["c7a1","ÌêàÌêùÌëÄÌëÑÌëúÌë†Ìë§Ìë≠ÌëØÌë∏ÌëπÌëºÌëøÌíÄÌíÇÌíàÌíâÌíãÌíçÌíîÌí©ÌìåÌìêÌìîÌìúÌìüÌì®Ìì¨Ìì∞Ìì∏ÌìªÌìΩÌîÑÌîàÌîåÌîîÌîïÌîóÌîºÌîΩÌïÄÌïÑÌïåÌïçÌïèÌïëÌïòÌïôÌïúÌï†Ìï•Ìï®Ìï©Ìï´Ìï≠Ìï¥ÌïµÌï∏ÌïºÌñÑÌñÖÌñáÌñàÌñâÌñêÌñ•ÌóàÌóâÌóåÌóêÌóíÌóòÌóôÌóõÌóùÌó§Ìó•Ìó®Ìó¨Ìó¥ÌóµÌó∑ÌóπÌòÄÌòÅÌòÑÌòàÌòêÌòëÌòìÌòîÌòïÌòúÌò†"],["c8a1","Ìò§Ìò≠Ìò∏ÌòπÌòºÌôÄÌôÖÌôàÌôâÌôãÌôçÌôëÌôîÌôïÌôòÌôúÌôßÌô©Ìô∞Ìô±Ìô¥ÌöÉÌöÖÌöåÌöçÌöêÌöîÌöùÌöüÌö°Ìö®Ìö¨Ìö∞ÌöπÌöªÌõÑÌõÖÌõàÌõåÌõëÌõîÌõóÌõôÌõ†Ìõ§Ìõ®Ìõ∞ÌõµÌõºÌõΩÌúÄÌúÑÌúëÌúòÌúôÌúúÌú†Ìú®Ìú©Ìú´Ìú≠Ìú¥ÌúµÌú∏ÌúºÌùÑÌùáÌùâÌùêÌùëÌùîÌùñÌùóÌùòÌùôÌù†Ìù°Ìù£Ìù•Ìù©Ìù¨Ìù∞Ìù¥ÌùºÌùΩÌûÅÌûàÌûâÌûåÌûêÌûòÌûôÌûõÌûù"],["caa1","‰ºΩ‰Ω≥ÂÅáÂÉπÂä†ÂèØÂëµÂì•ÂòâÂ´ÅÂÆ∂ÊöáÊû∂Êû∑ÊüØÊ≠åÁèÇÁóÇÁ®ºËãõËåÑË°óË¢àË®∂Ë≥àË∑èËªªËø¶ÈßïÂàªÂç¥ÂêÑÊÅ™ÊÖ§ÊÆºÁèèËÑöË¶∫ËßíÈñ£‰æÉÂàäÂ¢æÂ•∏Âß¶Âπ≤ÂππÊááÊèÄÊùÜÊü¨Ê°øÊæóÁôéÁúãÁ£µÁ®àÁ´øÁ∞°ËÇùËâÆËâ±Ë´´Èñì‰π´ÂñùÊõ∑Ê∏¥Á¢£Á´≠ËëõË§êËùéÈû®ÂãòÂùéÂ†™ÂµåÊÑüÊÜæÊà°Êï¢ÊüëÊ©ÑÊ∏õÁîòÁñ≥Áõ£Áû∞Á¥∫ÈÇØÈëëÈëíÈæï"],["cba1","Âå£Â≤¨Áî≤ËÉõÈâÄÈñòÂâõÂ†àÂßúÂ≤°Â¥óÂ∫∑Âº∫ÂΩäÊÖ∑Ê±üÁï∫ÁñÜÁ≥†Áµ≥Á∂±ÁæåËÖîËà°ËñëË•ÅË¨õÈãºÈôçÈ±á‰ªã‰ª∑ÂÄãÂá±Â°èÊÑ∑ÊÑæÊÖ®ÊîπÊß™ÊºëÁñ•ÁöÜÁõñÁÆáËä•ËìãÔ§ÄÈéßÈñãÂñÄÂÆ¢ÂùëÔ§ÅÁ≤≥ÁæπÈÜµÂÄ®ÂéªÂ±ÖÂ∑®ÊãíÊçÆÊìöÊìßÊ∏†ÁÇ¨Á•õË∑ùË∏ûÔ§ÇÈÅΩÈâÖÈã∏‰πæ‰ª∂ÂÅ•Â∑æÂª∫ÊÑÜÊ•óËÖ±ËôîËπáÈçµÈ®´‰πûÂÇëÊù∞Ê°ÄÂÑâÂäçÂäíÊ™¢"],["cca1","ÁûºÈàêÈªîÂä´ÊÄØËø≤ÂÅàÊÜ©Êè≠ÊìäÊ†ºÊ™ÑÊøÄËÜàË¶°ÈöîÂ†ÖÁâΩÁä¨ÁîÑÁµπÁπ≠ËÇ©Ë¶ãË≠¥ÈÅ£ÈµëÊäâÊ±∫ÊΩîÁµêÁº∫Ë®£ÂÖºÊÖäÁÆùË¨ôÈâóÈéå‰∫¨‰øìÂÄûÂÇæÂÑÜÂãÅÂãçÂçøÂù∞Â¢ÉÂ∫öÂæëÊÖ∂ÊÜ¨ÊìéÊï¨ÊôØÊöªÊõ¥Ê¢óÊ∂áÁÇÖÁÉ±ÁíüÁí•ÁìäÁóôÁ°¨Á£¨Á´üÁ´∂ÁµÖÁ∂ìËÄïËÄøËÑõËéñË≠¶ËºïÈÄïÈè°È†ÉÈ†∏È©öÈØ®‰øÇÂïìÂ†∫Â•ëÂ≠£Â±ÜÊÇ∏ÊàíÊ°ÇÊ¢∞"],["cda1","Ê£®Ê∫™ÁïåÁô∏Á£éÁ®ΩÁ≥ªÁπ´ÁπºË®àË™°Ë∞øÈöéÈ∑ÑÂè§Âè©ÂëäÂë±Âõ∫ÂßëÂ≠§Â∞ªÂ∫´Êã∑Êî∑ÊïÖÊï≤Êö†ÊûØÊßÅÊ≤ΩÁóºÁöêÁùæÁ®øÁæîËÄÉËÇ°ËÜèËã¶ËãΩËè∞ËóÅË†±Ë¢¥Ë™•Ô§ÉËæúÈåÆÈõáÈ°ßÈ´òÈºìÂì≠ÊñõÊõ≤Ê¢èÁ©ÄË∞∑Èµ†Âõ∞Âù§Â¥ëÊòÜÊ¢±Ê£çÊªæÁê®Ë¢ûÈØ§Ê±®Ô§ÑÈ™®‰æõÂÖ¨ÂÖ±ÂäüÂ≠îÂ∑•ÊÅêÊÅ≠Êã±ÊéßÊîªÁèôÁ©∫Ëö£Ë≤¢Èûè‰∏≤ÂØ°ÊààÊûúÁìú"],["cea1","ÁßëËèìË™áË™≤Ë∑®ÈÅéÈçãÈ°ÜÂªìÊß®ËóøÈÉ≠Ô§ÖÂÜ†ÂÆòÂØ¨ÊÖ£Ê£∫Ê¨æÁÅåÁêØÁìòÁÆ°ÁΩêËèÖËßÄË≤´ÈóúÈ§®ÂàÆÊÅùÊã¨ÈÄÇ‰æäÂÖâÂå°Â£ôÂª£Êõ†Ê¥∏ÁÇöÁãÇÁèñÁ≠êËÉ±ÈëõÂç¶ÊéõÁΩ´‰πñÂÇÄÂ°äÂ£ûÊÄ™ÊÑßÊãêÊßêÈ≠ÅÂÆèÁ¥òËÇ±ËΩü‰∫§ÂÉëÂí¨Âñ¨Â¨åÂ∂†Â∑ßÊî™ÊïéÊ†°Ê©ãÁã°ÁöéÁüØÁµûÁøπËÜ†ËïéËõüËºÉËΩéÈÉäÈ§ÉÈ©ïÈÆ´‰∏ò‰πÖ‰πù‰ªá‰ø±ÂÖ∑Âãæ"],["cfa1","ÂçÄÂè£Âè•ÂíéÂòîÂùµÂû¢ÂØáÂ∂áÂªêÊáºÊãòÊïëÊû∏Êü©ÊßãÊ≠êÊØÜÊØ¨Ê±ÇÊ∫ùÁÅ∏ÁãóÁéñÁêÉÁûøÁü©Á©∂ÁµøËÄâËáºËàÖËàäËãüË°¢Ë¨≥Ë≥ºËªÄÈÄëÈÇ±Èâ§Èä∂ÈßíÈ©ÖÈ≥©È∑óÈæúÂúãÂ±ÄËèäÈû†Èû´È∫¥ÂêõÁ™òÁæ§Ë£ôËªçÈÉ°Â†ÄÂ±àÊéòÁ™üÂÆÆÂºìÁ©πÁ™ÆËäéË∫¨ÂÄ¶Âà∏Âã∏Âç∑ÂúàÊã≥Êç≤Ê¨äÊ∑ÉÁú∑Âé•ÁçóËï®Ëπ∂ÈóïÊú∫Ê´ÉÊΩ∞Ë©≠ËªåÈ•ãÔ§ÜÊô∑Ê≠∏Ë≤¥"],["d0a1","È¨ºÔ§áÂè´Âú≠Â•éÊèÜÊßªÁè™Á°ÖÁ™∫Á´ÖÁ≥æËëµË¶èËµ≥ÈÄµÈñ®ÂãªÂùáÁïáÁ≠†ËèåÈàûÔ§àÊ©òÂÖãÂâãÂäáÊàüÊ£òÊ•µÈöôÂÉÖÂä§Âã§ÊáÉÊñ§Ê†πÊßøÁëæÁ≠ãËäπËè´Ë¶≤Ë¨πËøëÈ•âÔ§â‰ªäÂ¶óÊìíÊòëÊ™éÁê¥Á¶ÅÁ¶ΩËä©Ë°æË°øË•üÔ§äÈå¶‰ºãÂèäÊÄ•Êâ±Ê±≤Á¥öÁµ¶‰∫òÂÖ¢ÁüúËÇØ‰ºÅ‰ºéÂÖ∂ÂÜÄÂóúÂô®ÂúªÂü∫ÂüºÂ§îÂ•áÂ¶ìÂØÑÂ≤êÂ¥éÂ∑±ÂπæÂøåÊäÄÊóóÊó£"],["d1a1","ÊúûÊúüÊùûÊ£ãÊ£ÑÊ©üÊ¨∫Ê∞£Ê±ΩÊ≤ÇÊ∑áÁéòÁê¶Áê™ÁíÇÁí£Áï∏ÁïøÁ¢ÅÁ£ØÁ•ÅÁ•áÁ•àÁ•∫ÁÆïÁ¥ÄÁ∂∫ÁæàËÄÜËÄ≠ËÇåË®òË≠èË±àËµ∑Èå°Èå§È£¢È•ëÈ®éÈ®èÈ©•È∫íÁ∑ä‰Ω∂ÂêâÊãÆÊ°îÈáëÂñ´ÂÑ∫Ô§ãÔ§åÂ®úÊá¶Ô§çÊãèÊãøÔ§é",5,"ÈÇ£Ô§î",4,"Ë´æÔ§ôÔ§öÔ§õÔ§úÊöñÔ§ùÁÖñÔ§ûÔ§üÈõ£Ô§†ÊçèÊç∫ÂçóÔ§°ÊûèÊ•†Êπ≥Ô§¢Áî∑Ô§£Ô§§Ô§•"],["d2a1","Á¥çÔ§¶Ô§ßË°≤ÂõäÂ®òÔ§®",4,"‰πÉÔ§≠ÂÖßÂ•àÊü∞ËÄêÔ§ÆÂ•≥Âπ¥ÊíöÁßäÂøµÊÅ¨ÊãàÊçªÂØßÂØóÂä™Ô§ØÂ•¥Âº©ÊÄíÔ§∞Ô§±Ô§≤ÁëôÔ§≥",5,"ÈßëÔ§π",10,"ÊøÉÔ•ÑÔ•ÖËÜøËæ≤ÊÉ±Ô•ÜÔ•áËÖ¶Ô•àÔ•âÂ∞øÔ•ä",7,"Â´©Ë®•ÊùªÁ¥êÔ•í",5,"ËÉΩÔ•òÔ•ôÂ∞ºÊ≥•ÂåøÊ∫∫Â§öËå∂"],["d3a1","‰∏π‰∫∂‰ΩÜÂñÆÂúòÂ£áÂΩñÊñ∑Êó¶Ê™ÄÊÆµÊπçÁü≠Á´ØÁ∞ûÁ∑ûËõãË¢íÈÑ≤ÈçõÊíªÊææÁç∫Áñ∏ÈÅîÂïñÂùçÊÜ∫ÊìîÊõáÊ∑°ÊπõÊΩ≠ÊæπÁó∞ËÅÉËÜΩËïÅË¶ÉË´áË≠öÈåüÊ≤ìÁïìÁ≠îË∏èÈÅùÂîêÂ†ÇÂ°òÂπ¢ÊàáÊíûÊ£†Áï∂Á≥ñËû≥Èª®‰ª£ÂûàÂùÆÂ§ßÂ∞çÂ≤±Â∏∂ÂæÖÊà¥Êì°Áé≥Ëá∫Ë¢ãË≤∏ÈöäÈªõÂÆÖÂæ∑ÊÇ≥ÂÄíÂàÄÂà∞ÂúñÂ†µÂ°óÂ∞éÂ±†Â≥∂Â∂ãÂ∫¶ÂæíÊÇºÊåëÊéâÊêóÊ°É"],["d4a1","Ê£πÊ´ÇÊ∑òÊ∏°ÊªîÊø§ÁáæÁõúÁùπÁ¶±Á®ªËêÑË¶©Ë≥≠Ë∑≥ËπàÈÄÉÈÄîÈÅìÈÉΩÈççÈô∂ÈüúÊØíÁÄÜÁâòÁä¢Áç®Áù£Á¶øÁØ§Á∫õËÆÄÂ¢©ÊÉáÊï¶ÊóΩÊöæÊ≤åÁÑûÁáâË±öÈ†ì‰π≠Á™Å‰ªùÂÜ¨ÂáçÂãïÂêåÊÜßÊù±Ê°êÊ£üÊ¥ûÊΩºÁñºÁû≥Á´•ËÉ¥Ëë£ÈäÖÂÖúÊñóÊùúÊûìÁóòÁ´áËç≥Ô•öË±ÜÈÄóÈ†≠Â±ØËáÄËäöÈÅÅÈÅØÈàçÂæóÂ∂ùÊ©ôÁáàÁôªÁ≠âËó§Ë¨ÑÈÑßÈ®∞ÂñáÊá∂Ô•õÁô©ÁæÖ"],["d5a1","ËòøËû∫Ë£∏ÈÇèÔ•úÊ¥õÁÉôÁèûÁµ°ËêΩÔ•ùÈÖ™Èß±Ô•û‰∫ÇÂçµÊ¨ÑÊ¨íÁÄæÁàõËò≠È∏ûÂâåËæ£ÂµêÊì•Êî¨Ê¨ñÊø´Á±ÉÁ∫úËóçË•§Ë¶ΩÊãâËáòË†üÂªäÊúóÊµ™ÁãºÁêÖÁëØËûÇÈÉû‰æÜÂ¥çÂæ†ËêäÂÜ∑Êé†Áï•‰∫ÆÂÄÜÂÖ©ÂáâÊ¢ÅÊ®ëÁ≤ÆÁ≤±Á≥ßËâØË´íËºõÈáè‰æ∂ÂÑ∑ÂãµÂëÇÂª¨ÊÖÆÊàæÊóÖÊ´öÊøæÁ§™ËóúË†£Èñ≠È©¢È©™È∫óÈªéÂäõÊõÜÊ≠∑ÁÄùÁ§´ËΩ¢ÈùÇÊÜêÊàÄÊî£Êº£"],["d6a1","ÁÖâÁíâÁ∑¥ËÅØËìÆËº¶ÈÄ£ÈçäÂÜΩÂàóÂä£Ê¥åÁÉàË£ÇÂªâÊñÇÊÆÆÊøÇÁ∞æÁçµ‰ª§‰º∂ÂõπÔ•üÂ≤∫Â∂∫ÊÄúÁé≤Á¨≠ÁæöÁøéËÅÜÈÄûÈà¥Èõ∂ÈùàÈ†òÈΩ°‰æãÊæßÁ¶ÆÈÜ¥Èö∑ÂãûÔ•†ÊíàÊìÑÊ´ìÊΩûÁÄòÁàêÁõßËÄÅËòÜËôúË∑ØËºÖÈú≤È≠ØÈ∑∫ÈπµÁ¢åÁ•øÁ∂†ËèâÈåÑÈπøÈ∫ìË´ñÂ£üÂºÑÊúßÁÄßÁìèÁ±†ËÅæÂÑ°ÁÄ®Áâ¢Á£äË≥ÇË≥öË≥¥Èõ∑‰∫ÜÂÉöÂØÆÂªñÊñôÁáéÁôÇÁû≠ËÅäËìº"],["d7a1","ÈÅºÈ¨ßÈæçÂ£òÂ©ÅÂ±¢Ê®ìÊ∑öÊºèÁòªÁ¥ØÁ∏∑ËîûË§∏Èè§ÈôãÂäâÊóíÊü≥Ê¶¥ÊµÅÊ∫úÁÄèÁêâÁë†ÁïôÁò§Á°´Ë¨¨È°ûÂÖ≠ÊàÆÈô∏‰æñÂÄ´Â¥ôÊ∑™Á∂∏Ëº™ÂæãÊÖÑÊ†óÔ•°ÈöÜÂãíËÇãÂáúÂáåÊ•ûÁ®úÁ∂æËè±Èôµ‰øöÂà©ÂéòÂêèÂîéÂ±•ÊÇßÊùéÊ¢®Êµ¨ÁäÅÁã∏ÁêÜÁíÉÔ•¢Áó¢Á±¨ÁΩπÁæ∏ËéâË£èË£°ÈáåÈáêÈõ¢ÈØâÂêùÊΩæÁáêÁíòËó∫Ë∫™Èö£È±óÈ∫üÊûóÊ∑ãÁê≥Ëá®ÈúñÁ†¨"],["d8a1","Á´ãÁ¨†Á≤íÊë©Áë™Áó≤Á¢ºÁ£®È¶¨È≠îÈ∫ªÂØûÂπïÊº†ËÜúËé´ÈÇà‰∏áÂççÂ®©Â∑íÂΩéÊÖ¢ÊåΩÊô©ÊõºÊªøÊº´ÁÅ£ÁûûËê¨ËîìË†ªËºìÈ•ÖÈ∞ªÂîúÊäπÊú´Ê≤´ËåâË•™Èù∫‰∫°Â¶ÑÂøòÂøôÊúõÁ∂≤ÁΩîËäíËå´ËéΩËºûÈÇôÂüãÂ¶πÂ™íÂØêÊòßÊûöÊ¢ÖÊØèÁÖ§ÁΩµË≤∑Ë≥£ÈÇÅÈ≠ÖËÑàË≤äÈôåÈ©ÄÈ∫•Â≠üÊ∞ìÁåõÁõ≤ÁõüËêåÂÜ™Ë¶ìÂÖçÂÜïÂãâÊ£âÊ≤îÁúÑÁú†Á∂øÁ∑¨Èù¢È∫µÊªÖ"],["d9a1","ËîëÂÜ•ÂêçÂëΩÊòéÊöùÊ§ßÊ∫üÁöøÁûëËåóËìÇËûüÈÖ©ÈäòÈ≥¥Ë¢Ç‰æÆÂÜíÂãüÂßÜÂ∏ΩÊÖïÊë∏ÊëπÊöÆÊüêÊ®°ÊØçÊØõÁâüÁâ°ÁëÅÁú∏ÁüõËÄóËäºËåÖË¨ÄË¨®Ë≤åÊú®Ê≤êÁâßÁõÆÁù¶Á©ÜÈ∂©Ê≠øÊ≤íÂ§¢Êú¶ËíôÂçØÂ¢ìÂ¶ôÂªüÊèèÊò¥Êù≥Ê∏∫Áå´Á´óËãóÈå®ÂãôÂ∑´ÊÜÆÊáãÊàäÊãáÊí´Êó†Ê•ôÊ≠¶ÊØãÁÑ°Áè∑ÁïùÁπÜËàûËåÇËï™Ë™£Ë≤øÈúßÈµ°Â¢®ÈªòÂÄëÂàéÂêªÂïèÊñá"],["daa1","Ê±∂Á¥äÁ¥ãËÅûËöäÈñÄÈõØÂãøÊ≤ïÁâ©Âë≥Â™öÂ∞æÂµãÂΩåÂæÆÊú™Ê¢∂Ê•£Ê∏ºÊπÑÁúâÁ±≥ÁæéËñáË¨éËø∑Èù°Èª¥Â≤∑ÊÇ∂ÊÑçÊÜ´ÊïèÊóªÊóºÊ∞ëÊ≥ØÁéüÁèâÁ∑°ÈñîÂØÜËúúË¨êÂâùÂçöÊãçÊêèÊí≤Êú¥Ê®∏Ê≥äÁèÄÁíûÁÆîÁ≤ïÁ∏õËÜäËà∂ËñÑËø´ÈõπÈßÅ‰º¥ÂçäÂèçÂèõÊãåÊê¨ÊîÄÊñëÊßÉÊ≥ÆÊΩòÁè≠ÁïîÁò¢Áõ§ÁõºÁ£êÁ£ªÁ§¨ÁµÜËà¨Ëü†ËøîÈ†íÈ£ØÂãÉÊãîÊí•Ê∏§ÊΩë"],["dba1","ÁôºË∑ãÈÜ±Èâ¢È´ÆÈ≠ÉÂÄ£ÂÇçÂùäÂ¶®Â∞®ÂπáÂΩ∑ÊàøÊîæÊñπÊóÅÊòâÊûãÊ¶úÊªÇÁ£ÖÁ¥°ËÇ™ËÜÄËà´Ëä≥Ëí°ËöåË®™Ë¨óÈÇ¶Èò≤ÈæêÂÄç‰ø≥Ô•£ÂüπÂæòÊãúÊéíÊùØÊπÉÁÑôÁõÉËÉåËÉöË£¥Ë£µË§ôË≥†Ëº©ÈÖçÈô™‰ºØ‰Ω∞Â∏õÊüèÊ†¢ÁôΩÁôæÈ≠ÑÂπ°Ê®äÁÖ©ÁáîÁï™Ô•§ÁπÅËïÉËó©È£ú‰ºêÁ≠èÁΩ∞Èñ•Âá°Â∏ÜÊ¢µÊ∞æÊ±éÊ≥õÁäØÁØÑËåÉÊ≥ïÁê∫ÂÉªÂäàÂ£ÅÊìòÊ™óÁíßÁôñ"],["dca1","Á¢ßËòóÈó¢ÈúπÔ••ÂçûÂºÅËÆäËæ®ËæØÈÇäÂà•Áû•È±âÈºà‰∏ôÂÄÇÂÖµÂ±õÂπ∑ÊòûÊò∫ÊüÑÊ£ÖÁÇ≥ÁîÅÁóÖÁßâÁ´ùËºßÈ§†È®à‰øùÂ†°Â†±ÂØ∂ÊôÆÊ≠•Ê¥ëÊπ∫ÊΩΩÁè§Áî´Ëè©Ë£úË§ìË≠úËºî‰ºèÂÉïÂåêÂçúÂÆìÂæ©ÊúçÁ¶èËÖπËåØËîîË§áË¶ÜËºπËºªÈ¶•È∞íÊú¨‰π∂‰ø∏Â•âÂ∞ÅÂ≥ØÂ≥∞ÊçßÊ£íÁÉΩÁÜ¢Áê´Á∏´Ëì¨ËúÇÈÄ¢ÈãíÈ≥≥‰∏ç‰ªò‰øØÂÇÖÂâñÂâØÂê¶ÂíêÂü†Â§´Â©¶"],["dda1","Â≠öÂ≠µÂØåÂ∫úÔ•¶Êâ∂Êï∑ÊñßÊµÆÊ∫•Áà∂Á¨¶Á∞øÁº∂ËÖêËÖëËÜöËâÄËäôËé©Ë®ÉË≤†Ë≥¶Ë≥ªËµ¥Ë∂∫ÈÉ®ÈáúÈòúÈôÑÈßôÈ≥ßÂåóÂàÜÂê©Âô¥Â¢≥Â•îÂ•ÆÂøøÊÜ§ÊâÆÊòêÊ±æÁÑöÁõÜÁ≤âÁ≥ûÁ¥õËä¨Ë≥ÅÈõ∞Ô•ß‰ΩõÂºóÂΩøÊãÇÂ¥©ÊúãÊ£öÁ°ºÁπÉÈµ¨‰∏ïÂÇôÂåïÂå™ÂçëÂ¶ÉÂ©¢Â∫áÊÇ≤ÊÜäÊââÊâπÊñêÊûáÊ¶ßÊØîÊØñÊØóÊØòÊ≤∏Ô•®ÁêµÁó∫Á†íÁ¢ëÁßïÁßòÁ≤ÉÁ∑ãÁø°ËÇ•"],["dea1","ËÑæËáÇËè≤ËúöË£®Ë™πË≠¨Ë≤ªÈÑôÈùûÈ£õÈºªÂö¨Â¨™ÂΩ¨ÊñåÊ™≥ÊÆØÊµúÊø±ÁÄïÁâùÁé≠Ë≤ßË≥ìÈ†ªÊÜëÊ∞∑ËÅòÈ®Å‰πç‰∫ã‰∫õ‰ªï‰º∫‰ºº‰Ωø‰øüÂÉøÂè≤Âè∏ÂîÜÂó£ÂõõÂ£´Â•¢Â®ëÂØ´ÂØ∫Â∞ÑÂ∑≥Â∏´ÂæôÊÄùÊç®ÊñúÊñØÊü∂ÊüªÊ¢≠Ê≠ªÊ≤ôÊ≥óÊ∏£ÁÄâÁçÖÁ†ÇÁ§æÁ•ÄÁ•†ÁßÅÁØ©Á¥óÁµ≤ËÇÜËàçËééËìëËõáË£üË©êË©ûË¨ùË≥úËµ¶Ëæ≠ÈÇ™È£ºÈßüÈ∫ùÂâäÔ•©ÊúîÔ•™"],["dfa1","ÂÇòÂà™Â±±Êï£Ê±ïÁèäÁî£ÁñùÁÆóËíúÈÖ∏Èú∞‰π∑ÊííÊÆ∫ÁÖûËñ©‰∏âÔ•´ÊùâÊ£ÆÊ∏óËäüËîòË°´Êè∑ÊæÅÈàíÈ¢Ø‰∏äÂÇ∑ÂÉèÂÑüÂïÜÂñ™ÂòóÂ≠ÄÂ∞ôÂ≥†Â∏∏Â∫äÂ∫†ÂªÇÊÉ≥Ê°ëÊ©°ÊπòÁàΩÁâÄÁãÄÁõ∏Á••ÁÆ±ÁøîË£≥Ëß¥Ë©≥Ë±°Ë≥ûÈúúÂ°ûÁíΩË≥ΩÂóáÔ•¨Á©°Á¥¢Ëâ≤Áâ≤ÁîüÁî•Ô•≠Á¨ôÂ¢ÖÂ£ªÂ∂ºÂ∫èÂ∫∂ÂæêÊÅïÊäíÊçøÊïçÊöëÊõôÊõ∏Ê†ñÊ£≤ÁäÄÁëûÁ≠ÆÁµÆÁ∑ñÁΩ≤"],["e0a1","ËÉ•ËàíËñØË•øË™ìÈÄùÈã§ÈªçÈº†Â§ïÂ•≠Â∏≠ÊÉúÊòîÊô≥ÊûêÊ±êÊ∑ÖÊΩüÁü≥Á¢©ËìÜÈáãÈå´‰ªôÂÉäÂÖàÂñÑÂ¨ãÂÆ£ÊâáÊïæÊóãÊ∏≤ÁÖΩÁêÅÁëÑÁíáÁíøÁô¨Á¶™Á∑öÁπïÁæ®ËÖ∫ËÜ≥ËàπËòöËü¨Ë©µË∑£ÈÅ∏ÈäëÈê•È•çÈÆÆÂç®Â±ëÊ•îÊ≥ÑÊ¥©Ê∏´ËàåËñõË§ªË®≠Ë™™Èõ™ÈΩßÂâ°ÊöπÊÆ≤Á∫ñËüæË¥çÈñÉÈôùÊîùÊ∂âÁáÆÔ•ÆÂüéÂßìÂÆ¨ÊÄßÊÉ∫ÊàêÊòüÊôüÁå©ÁèπÁõõÁúÅÁ≠¨"],["e1a1","ËÅñËÅ≤ËÖ•Ë™†ÈÜí‰∏ñÂã¢Ê≠≤Ê¥óÁ®ÖÁ¨πÁ¥∞Ô•ØË≤∞Âè¨ÂòØÂ°ëÂÆµÂ∞èÂ∞ëÂ∑¢ÊâÄÊéÉÊêîÊò≠Ê¢≥Ê≤ºÊ∂àÊ∫ØÁÄüÁÇ§ÁáíÁî¶ÁñèÁñéÁòôÁ¨ëÁØ†Á∞´Á¥†Á¥πËî¨Ëï≠ËòáË®¥ÈÄçÈÅ°ÈÇµÈä∑Èü∂È®∑‰øóÂ±¨ÊùüÊ∂ëÁ≤üÁ∫åË¨ñË¥ñÈÄüÂ≠´Â∑ΩÊêçËìÄÈÅúÈ£°ÁéáÂÆãÊÇöÊùæÊ∑ûË®üË™¶ÈÄÅÈ†åÂà∑Ô•∞ÁÅëÁ¢éÈéñË°∞Èáó‰øÆÂèóÂóΩÂõöÂûÇÂ£ΩÂ´ÇÂÆàÂ≤´Â≥ÄÂ∏•ÊÑÅ"],["e2a1","ÊàçÊâãÊéàÊêúÊî∂Êï∏Ê®πÊÆäÊ∞¥Ê¥ôÊº±ÁáßÁã©Áç∏ÁêáÁí≤Áò¶Áù°ÁßÄÁ©óÁ´™Á≤πÁ∂èÁ∂¨Áπ°ÁæûËÑ©Ëå±ËíêËìöËó™Ë¢ñË™∞ËÆêËº∏ÈÅÇÈÇÉÈÖ¨ÈäñÈäπÈöãÈößÈö®ÈõñÈúÄÈ†àÈ¶ñÈ´ìÈ¨öÂèîÂ°æÂ§ôÂ≠∞ÂÆøÊ∑ëÊΩöÁÜüÁê°ÁíπËÇÖËèΩÂ∑°ÂæáÂæ™ÊÅÇÊó¨Ê†íÊ•ØÊ©ìÊÆâÊ¥µÊ∑≥Áè£ÁõæÁû¨Á≠çÁ¥îËÑ£ËàúËçÄËì¥Ëï£Ë©¢Ë´ÑÈÜáÈåûÈ†ÜÈ¶¥ÊàåË°ìËø∞Èâ•Â¥áÂ¥ß"],["e3a1","Âµ©ÁëüËÜùËù®ÊøïÊãæÁøíË§∂Ë•≤‰∏û‰πòÂÉßÂãùÂçáÊâøÊòáÁπ©Ë†ÖÈôû‰æçÂåôÂò∂ÂßãÂ™§Â∞∏Â±éÂ±çÂ∏ÇÂºëÊÅÉÊñΩÊòØÊôÇÊûæÊü¥ÁåúÁü¢Á§∫ÁøÖËíîËìçË¶ñË©¶Ë©©Ë´°Ë±ïË±∫Âü¥ÂØîÂºèÊÅØÊã≠Ê§çÊÆñÊπúÁÜÑÁØíËùïË≠òËªæÈ£üÈ£æ‰º∏‰æÅ‰ø°ÂëªÂ®†ÂÆ∏ÊÑºÊñ∞Êô®ÁáºÁî≥Á•ûÁ¥≥ËÖéËá£ËéòËñ™ËóéËúÉË®äË∫´ËæõÔ•±ËøÖÂ§±ÂÆ§ÂØ¶ÊÇâÂØ©Â∞ãÂøÉÊ≤Å"],["e4a1","Ô•≤Ê∑±ÁÄãÁîöËäØË´∂‰ªÄÂçÅÔ•≥ÈõôÊ∞è‰∫û‰øÑÂÖíÂïûÂ®•Â≥®ÊàëÁâôËäΩËé™ËõæË°ôË®ùÈòøÈõÖÈ§ìÈ¥âÈµùÂ†äÂ≤≥Â∂ΩÂπÑÊÉ°ÊÑïÊè°Ê®ÇÊ∏•ÈÑÇÈçîÈ°éÈ∞êÈΩ∑ÂÆâÂ≤∏ÊåâÊôèÊ°àÁúºÈõÅÈûçÈ°îÈÆüÊñ°Ë¨ÅËªãÈñºÂîµÂ≤©Â∑ñÂ∫µÊöóÁôåËè¥ÈóáÂ£ìÊäºÁãéÈ¥®‰ª∞Â§ÆÊÄèÊòªÊÆÉÁßßÈ¥¶ÂéìÂìÄÂüÉÂ¥ñÊÑõÊõñÊ∂ØÁ¢çËâæÈöòÈùÑÂéÑÊâºÊéñÊ∂≤Á∏äËÖãÈ°ç"],["e5a1","Ê´ªÁΩåÈ∂ØÈ∏ö‰πüÂÄªÂÜ∂Â§úÊÉπÊè∂Ê§∞Áà∫ËÄ∂Ô•¥ÈáéÂº±Ô•µÔ•∂Á¥ÑËã•ËëØËíªËó•Ë∫çÔ•∑‰ΩØÔ•∏Ô•πÂ£§Â≠ÉÊÅôÊèöÊîòÊï≠ÊöòÔ•∫Ê•äÊ®£Ê¥ãÁÄÅÁÖ¨ÁóíÁòçÁ¶≥Á©∞Ô•ªÁæäÔ•ºË•ÑÔ•ΩËÆìÈáÄÈôΩÔ•æÈ§äÂúÑÂæ°ÊñºÊºÅÁòÄÁ¶¶Ë™ûÈ¶≠È≠öÈΩ¨ÂÑÑÊÜ∂ÊäëÊ™çËáÜÂÅÉÂ†∞ÂΩ¶ÁÑâË®ÄË´∫Â≠ºËòñ‰ø∫ÂÑºÂö¥Â•ÑÊé©Ê∑πÂ∂™Ê•≠ÂÜÜ‰∫à‰ΩôÔ•øÔ¶ÄÔ¶ÅÂ¶ÇÔ¶Ç"],["e6a1","Ô¶ÉÊ≠üÊ±ùÔ¶ÑÁíµÁ§ñÔ¶ÖËàáËâÖËåπËºøËΩùÔ¶ÜÈ§òÔ¶áÔ¶àÔ¶â‰∫¶Ô¶äÂüüÂΩπÊòìÔ¶ãÔ¶åÁñ´ÁππË≠ØÔ¶çÈÄÜÈ©õÂö•Â†ßÂß∏Â®üÂÆ¥Ô¶éÂª∂Ô¶èÔ¶êÊçêÊåªÔ¶ëÊ§ΩÊ≤áÊ≤øÊ∂éÊ∂ìÊ∑µÊºîÔ¶íÁÉüÁÑ∂ÁÖôÔ¶ìÁáÉÁáïÔ¶îÁ°èÁ°ØÔ¶ïÁ≠µÁ∑£Ô¶ñÁ∏ØÔ¶óË°çËªüÔ¶òÔ¶ôÔ¶öÈâõÔ¶õÈ≥∂Ô¶úÔ¶ùÔ¶ûÊÇÖÊ∂ÖÔ¶üÁÜ±Ô¶†Ô¶°Èñ±Âé≠Ô¶¢Ô¶£Ô¶§ÊüìÔ¶•ÁÇéÁÑ∞Áê∞Ëâ∂Ëãí"],["e7a1","Ô¶¶ÈñªÈ´•ÈπΩÊõÑÔ¶ßÁáÅËëâÔ¶®Ô¶©Â°ãÔ¶™Ô¶´Â∂∏ÂΩ±Ô¶¨Êò†ÊöéÊ•πÊ¶ÆÊ∞∏Ê≥≥Ê∏∂ÊΩÅÊøöÁÄõÁÄØÁÖêÁáüÁç∞Ô¶≠ÁëõÔ¶ÆÁìîÁõàÁ©éÁ∫ìÔ¶ØÔ¶∞Ëã±Ë©†ËøéÔ¶±ÈçàÔ¶≤ÈúôÔ¶≥Ô¶¥‰πÇÂÄ™Ô¶µÂààÂè°Êõ≥Ê±≠ÊøäÁåäÁùøÁ©¢ËäÆËóùËòÇÔ¶∂Ë£îË©£Ë≠ΩË±´Ô¶∑Èä≥Ô¶∏ÈúìÈ†ê‰∫î‰ºç‰øâÂÇ≤ÂçàÂêæÂê≥ÂóöÂ°¢Â¢∫Â•ßÂ®õÂØ§ÊÇüÔ¶πÊáäÊïñÊóøÊô§Ê¢ßÊ±öÊæ≥"],["e8a1","ÁÉèÁÜ¨ÁçíÁ≠ΩËúàË™§È∞≤ÈºáÂ±ãÊ≤ÉÁçÑÁéâÈà∫Ê∫´Áë•ÁòüÁ©©Á∏ïËòäÂÖÄÂ£ÖÊìÅÁìÆÁîïÁô∞ÁøÅÈÇïÈõçÈ•îÊ∏¶Áì¶Á™©Á™™Ëá•ËõôËù∏Ë®õÂ©âÂÆåÂÆõÊ¢°Ê§ÄÊµ£Áé©ÁêìÁê¨Á¢óÁ∑©Áø´ËÑòËÖïËéûË±åÈòÆÈ†ëÊõ∞ÂæÄÊó∫ÊûâÊ±™ÁéãÂÄ≠Â®ÉÊ≠™ÁüÆÂ§ñÂµ¨Â∑çÁå•ÁïèÔ¶∫Ô¶ªÂÉ•ÂáπÂ†ØÂ§≠Â¶ñÂßöÂØ•Ô¶ºÔ¶ΩÂ∂¢ÊãóÊêñÊíìÊìæÔ¶æÊõúÔ¶øÊ©àÔßÄÁáøÁë§ÔßÅ"],["e9a1","Á™àÁ™ØÁπáÁπûËÄÄËÖ∞ÔßÇËüØË¶ÅË¨†ÈÅôÔßÉÈÇÄÈ•íÊÖæÊ¨≤Êµ¥Á∏üË§•Ëæ±‰øëÂÇ≠ÂÜóÂãáÂüáÂ¢âÂÆπÂ∫∏ÊÖÇÊ¶ïÊ∂åÊπßÊ∫∂ÁÜîÁë¢Áî®Áî¨ËÅ≥Ëå∏ËìâË∏äÈéîÈèûÔßÑ‰∫é‰ΩëÂÅ∂ÂÑ™ÂèàÂèãÂè≥ÂÆáÂØìÂ∞§ÊÑöÊÜÇÊó¥ÁâõÁéóÁëÄÁõÇÁ•êÁ¶ëÁ¶πÁ¥ÜÁæΩËäãËóïËôûËøÇÈÅáÈÉµÈá™ÈöÖÈõ®Èõ©ÂãñÂΩßÊó≠Êò±Ê†ØÁÖúÁ®∂ÈÉÅÈ†ä‰∫ëÔßÖÊ©íÊÆûÊæêÁÜâËÄòËä∏Ëïì"],["eaa1","ÈÅãÈöïÈõ≤ÈüªËîöÈ¨±‰∫êÁÜäÈõÑÂÖÉÂéüÂì°ÂúìÂúíÂû£Â™õÂ´ÑÂØÉÊÄ®ÊÑøÊè¥Ê≤ÖÊ¥πÊπ≤Ê∫êÁà∞ÁåøÁëóËãëË¢ÅËΩÖÈÅ†ÔßÜÈô¢È°òÈ¥õÊúàË∂äÈâû‰ΩçÂÅâÂÉûÂç±ÂúçÂßîÂ®ÅÂ∞âÊÖ∞ÊöêÊ∏≠Áà≤ÁëãÁ∑ØËÉÉËêéËë¶ËîøËùüË°õË§òË¨ÇÈÅïÈüãÈ≠è‰π≥‰æëÂÑíÂÖ™ÔßáÂîØÂñ©Â≠∫ÂÆ•ÂπºÂπΩÂ∫æÊÇ†ÊÉüÊÑàÊÑâÊèÑÊî∏ÊúâÔßàÊüîÊüöÔßâÊ•°Ê•¢Ê≤πÊ¥ßÔßäÊ∏∏Ôßã"],["eba1","Êø°Áå∂Áå∑ÔßåÁëúÁî±ÔßçÁôíÔßéÔßèÁ∂≠ËáæËê∏Ë£ïË™òË´õË´≠Ë∏∞ËπÇÈÅäÈÄæÈÅ∫ÈÖâÈáâÈçÆÔßêÔßëÂ†âÔßíÊØìËÇâËÇ≤ÔßìÔßîÂÖÅÂ•´Â∞πÔßïÔßñÊΩ§ÁéßËÉ§Ë¥áÔßóÈàóÈñèÔßòÔßôÔßöÔßõËÅøÊàéÁÄúÁµ®ËûçÔßúÂû†ÊÅ©ÊÖáÊÆ∑Ë™æÈäÄÈö±‰πôÂêüÊ∑´Ëî≠Èô∞Èü≥È£ÆÊèñÊ≥£ÈÇëÂáùÊáâËÜ∫È∑π‰æùÂÄöÂÑÄÂÆúÊÑèÊáøÊì¨Ê§ÖÊØÖÁñëÁü£Áæ©Ëâ§ËñèËüªË°£Ë™º"],["eca1","Ë≠∞ÈÜ´‰∫å‰ª•‰ºäÔßùÔßûÂ§∑Âß®ÔßüÂ∑≤ÂºõÂΩõÊÄ°Ôß†Ôß°Ôß¢Ôß£ÁàæÁè•Ôß§Áï∞ÁóçÔß•ÁßªÔß¶ËÄåËÄ≥ËÇÑËã°ËçëÔßßÔß®Ë≤ΩË≤≥ÈÇáÔß©Ôß™È£¥È§åÔß´Ôß¨ÁÄ∑ÁõäÁøäÁøåÁøºË¨ö‰∫∫‰ªÅÂàÉÂç∞Ôß≠ÂíΩÂõ†ÂßªÂØÖÂºïÂøçÊπÆÔßÆÔßØÁµ™ËåµÔß∞ËöìË™çÔß±Èù≠Èù∑Ôß≤Ôß≥‰∏Ä‰Ωö‰ΩæÂ£πÊó•Ê∫¢ÈÄ∏Èé∞È¶π‰ªªÂ£¨Â¶äÂßôÊÅÅÔß¥ÔßµÁ®îÔß∂ËçèË≥ÉÂÖ•ÂçÑ"],["eda1","Ôß∑Ôß∏Ôßπ‰ªçÂâ©Â≠ïËäø‰ªîÂà∫Âí®ÂßâÂßøÂ≠êÂ≠óÂ≠úÊÅ£ÊÖàÊªãÁÇôÁÖÆÁéÜÁì∑ÁñµÁ£ÅÁ¥´ËÄÖËá™Ëå®ËîóËóâË´ÆË≥áÈõå‰ΩúÂã∫ÂöºÊñ´Êò®ÁÅºÁÇ∏ÁàµÁ∂ΩËäçÈÖåÈõÄÈµ≤Â≠±Ê£ßÊÆòÊΩ∫ÁõûÂ≤ëÊö´ÊΩõÁÆ¥Á∞™Ë†∂Èõú‰∏à‰ªóÂå†Â†¥Â¢ªÂ£ØÂ•¨Â∞áÂ∏≥Â∫ÑÂºµÊéåÊö≤ÊùñÊ®üÊ™£Ê¨åÊºøÁâÜÔß∫ÁçêÁíãÁ´†Á≤ßËÖ∏ËáüËáßËéäËë¨Ëî£ËñîËóèË£ùË¥ìÈÜ¨Èï∑"],["eea1","ÈöúÂÜçÂìâÂú®ÂÆ∞ÊâçÊùêÊ†ΩÊ¢ìÊ∏ΩÊªìÁÅΩÁ∏°Ë£ÅË≤°ËºâÈΩãÈΩéÁà≠ÁÆèË´çÈåö‰Ωá‰ΩéÂÑ≤ÂíÄÂßêÂ∫ïÊäµÊùµÊ•ÆÊ®óÊ≤ÆÊ∏öÁãôÁå™ÁñΩÁÆ∏Á¥µËãßËèπËëóËó∑Ë©õË≤ØË∫áÈÄôÈÇ∏ÈõéÈΩüÂã£ÂêäÂ´°ÂØÇÊëòÊïµÊª¥ÁãÑÔßªÁöÑÁ©çÁ¨õÁ±çÁ∏æÁøüËçªË¨´Ë≥äËµ§Ë∑°ËπüËø™ËøπÈÅ©Èèë‰ΩÉ‰Ω∫ÂÇ≥ÂÖ®ÂÖ∏ÂâçÂâ™Â°°Â°ºÂ•†Â∞àÂ±ïÂªõÊÇõÊà∞Ê†ìÊÆøÊ∞àÊæ±"],["efa1","ÁÖéÁê†Áî∞Áî∏ÁïëÁô≤Á≠åÁÆãÁÆ≠ÁØÜÁ∫èË©ÆËºæËΩâÈàøÈäìÈå¢Èê´ÈõªÈ°öÈ°´È§ûÂàáÊà™ÊäòÊµôÁô§Á´äÁØÄÁµ∂Âç†Â≤æÂ∫óÊº∏ÁÇπÁ≤òÈúëÈÆéÈªûÊé•Êë∫Ëù∂‰∏Å‰∫ï‰∫≠ÂÅúÂÅµÂëàÂßÉÂÆöÂπÄÂ∫≠Âª∑ÂæÅÊÉÖÊå∫ÊîøÊï¥ÊóåÊô∂Êô∏ÊüæÊ•®Ê™âÊ≠£Ê±ÄÊ∑ÄÊ∑®Ê∏üÊπûÁÄûÁÇ°ÁééÁèΩÁî∫ÁùõÁ¢áÁ¶éÁ®ãÁ©ΩÁ≤æÁ∂éËâáË®ÇË´™Ë≤ûÈÑ≠ÈÖäÈáòÈâ¶ÈãåÈå†ÈúÜÈùñ"],["f0a1","ÈùúÈ†ÇÈºéÂà∂ÂäëÂïºÂ†§Â∏ùÂºüÊÇåÊèêÊ¢ØÊøüÁ•≠Á¨¨ËáçËñ∫Ë£ΩË´∏ËπÑÈÜçÈô§ÈöõÈúΩÈ°åÈΩä‰øéÂÖÜÂáãÂä©Âò≤ÂºîÂΩ´Êé™ÊìçÊó©ÊôÅÊõ∫ÊõπÊúùÊ¢ùÊ£óÊßΩÊºïÊΩÆÁÖßÁá•Áà™Áí™Áú∫Á•ñÁ•öÁßüÁ®†Á™ïÁ≤óÁ≥üÁµÑÁπ∞ËÇáËóªËö§Ë©îË™øË∂ôË∫ÅÈÄ†ÈÅ≠Èá£ÈòªÈõïÈ≥•ÊóèÁ∞áË∂≥ÈèÉÂ≠òÂ∞äÂçíÊãôÁåùÂÄßÂÆóÂæûÊÇ∞ÊÖ´Ê£ïÊ∑ôÁêÆÁ®ÆÁµÇÁ∂úÁ∏±ËÖ´"],["f1a1","Ë∏™Ë∏µÈçæÈêò‰ΩêÂùêÂ∑¶Â∫ßÊå´ÁΩ™‰∏ª‰Ωè‰æèÂÅöÂßùËÉÑÂë™Âë®ÂóæÂ•èÂÆôÂ∑ûÂªöÊôùÊú±Êü±Ê†™Ê≥®Ê¥≤ÊπäÊæçÁÇ∑Áè†ÁñáÁ±åÁ¥ÇÁ¥¨Á∂¢ËàüËõõË®ªË™ÖËµ∞Ë∫äËº≥ÈÄ±ÈÖéÈÖíÈëÑÈßêÁ´πÁ≤•‰øäÂÑÅÂáÜÂüàÂØØÂ≥ªÊôôÊ®ΩÊµöÊ∫ñÊø¨ÁÑåÁïØÁ´£Ë†¢ÈÄ°ÈÅµÈõãÈßøËåÅ‰∏≠‰ª≤Ë°ÜÈáçÂçΩÊ´õÊ•´Ê±ÅËë∫Â¢ûÊÜéÊõæÊãØÁÉùÁîëÁóáÁπíËí∏Ë≠âË¥à‰πãÂè™"],["f2a1","Âí´Âú∞ÂùÄÂøóÊåÅÊåáÊëØÊîØÊó®Êô∫ÊûùÊû≥Ê≠¢Ê±†Ê≤öÊº¨Áü•Á†•Á•âÁ•óÁ¥ôËÇ¢ËÑÇËá≥ËäùËä∑ËúòË™åÔßºË¥ÑË∂æÈÅ≤Áõ¥Á®ôÁ®∑ÁπîËÅ∑ÂîáÂóîÂ°µÊåØÊê¢ÊôâÊôãÊ°≠Ê¶õÊÆÑÊ¥•Ê∫±ÁèçÁë®Áí°ÁïõÁñπÁõ°ÁúûÁûãÁß¶Á∏âÁ∏ùËáªËîØË¢óË®∫Ë≥ëËª´Ëæ∞ÈÄ≤Èé≠Èô£Èô≥Èúá‰æÑÂè±Âß™Â´âÂ∏ôÊ°éÁìÜÁñæÁß©Á™íËÜ£Ëõ≠Ë≥™Ë∑åËø≠ÊñüÊúïÔßΩÂü∑ÊΩóÁ∑ùËºØ"],["f3a1","Èè∂ÈõÜÂæµÊá≤ÊæÑ‰∏î‰æòÂÄüÂèâÂóüÂµØÂ∑ÆÊ¨°Ê≠§Á£ãÁÆöÔßæËπâËªäÈÅÆÊçâÊêæÁùÄÁ™ÑÈåØÈëøÈΩ™Êí∞ÊæØÁá¶Áí®ÁìöÁ´ÑÁ∞íÁ∫ÇÁ≤≤Á∫òËÆöË¥äÈëΩÈ§êÈ•åÂàπÂØüÊì¶Êú≠Á¥ÆÂÉ≠ÂèÉÂ°πÊÖòÊÖôÊá∫Êñ¨Á´ôËÆíËÆñÂÄâÂÄ°ÂâµÂî±Â®ºÂª†ÂΩ∞ÊÑ¥ÊïûÊòåÊò∂Êö¢ÊßçÊªÑÊº≤ÁåñÁò°Á™ìËÑπËâôËèñËíºÂÇµÂü∞ÂØÄÂØ®ÂΩ©Êé°Á†¶Á∂µËèúËî°ÈááÈáµÂÜäÊüµÁ≠ñ"],["f4a1","Ë≤¨ÂáÑÂ¶ªÊÇΩËôïÂÄúÔßøÂâîÂ∞∫ÊÖΩÊàöÊãìÊì≤Êñ•ÊªåÁò†ËÑäËπ†ÈôüÈöª‰ªüÂçÉÂñòÂ§©Â∑ùÊìÖÊ≥âÊ∑∫ÁéîÁ©øËàõËñ¶Ë≥§Ë∏êÈÅ∑ÈáßÈó°Èò°ÈüÜÂá∏Âì≤ÂñÜÂæπÊí§ÊæàÁ∂¥ËºüËΩçÈêµÂÉâÂ∞ñÊ≤æÊ∑ªÁîõÁûªÁ∞ΩÁ±§Ë©πË´ÇÂ†ûÂ¶æÂ∏ñÊç∑ÁâíÁñäÁù´Ë´úË≤ºËºíÂª≥Êô¥Ê∑∏ËÅΩËèÅË´ãÈùëÈØñÔ®ÄÂâÉÊõøÊ∂ïÊªØÁ∑†Ë´¶ÈÄÆÈÅûÈ´îÂàùÂâøÂì®ÊÜîÊäÑÊãõÊ¢¢"],["f5a1","Ê§íÊ•öÊ®µÁÇíÁÑ¶Á°ùÁ§ÅÁ§éÁßíÁ®çËÇñËâ∏ËãïËçâËïâË≤ÇË∂ÖÈÖ¢ÈÜãÈÜÆ‰øÉÂõëÁá≠ÁüóËúÄËß∏ÂØ∏ÂøñÊùëÈÇ®Âè¢Â°öÂØµÊÇ§ÊÜÅÊë†Á∏ΩËÅ∞Ëî•ÈäÉÊíÆÂÇ¨Â¥îÊúÄÂ¢úÊäΩÊé®Ê§éÊ•∏Ê®ûÊπ´Áö∫ÁßãËäªËê©Ë´èË∂®ËøΩÈÑíÈÖãÈÜúÈåêÈåòÈéöÈõõÈ®∂È∞ç‰∏ëÁïúÁ•ùÁ´∫Á≠ëÁØâÁ∏ÆËìÑËπôËπ¥Ëª∏ÈÄêÊò•Ê§øÁëÉÂá∫ÊúÆÈªúÂÖÖÂø†Ê≤ñËü≤Ë°ùË°∑ÊÇ¥ËÜµËêÉ"],["f6a1","Ë¥ÖÂèñÂêπÂò¥Â®∂Â∞±ÁÇäÁø†ËÅöËÑÜËá≠Ë∂£ÈÜâÈ©üÈ∑≤ÂÅ¥‰ªÑÂé†ÊÉªÊ∏¨Â±§‰æàÂÄ§Âó§Â≥ôÂπüÊÅ•Ê¢îÊ≤ªÊ∑ÑÁÜæÁóîÁó¥Áô°Á®öÁ©âÁ∑áÁ∑ªÁΩÆËá¥Ëö©ËºúÈõâÈ¶≥ÈΩíÂâáÂãÖÈ£≠Ë¶™‰∏ÉÊüíÊºÜ‰æµÂØ¢ÊûïÊ≤àÊµ∏ÁêõÁ†ßÈáùÈçºËüÑÁß§Á®±Âø´‰ªñÂí§ÂîæÂ¢ÆÂ¶•ÊÉ∞ÊâìÊãñÊú∂Ê•ïËàµÈôÄÈ¶±ÈßùÂÄ¨ÂçìÂïÑÂùºÔ®ÅÊâòÔ®ÇÊì¢Êô´ÊüùÊøÅÊøØÁê¢Áê∏Ë®ó"],["f7a1","Èê∏ÂëëÂòÜÂù¶ÂΩàÊÜöÊ≠éÁÅòÁÇ≠Á∂ªË™ïÂ•™ËÑ´Êé¢ÁúàËÄΩË≤™Â°îÊê≠Ê¶ªÂÆïÂ∏ëÊπØÔ®ÉËï©ÂÖåÂè∞Â§™ÊÄ†ÊÖãÊÆÜÊ±∞Ê≥∞Á¨ûËÉéËãîË∑ÜÈÇ∞È¢±Ô®ÑÊìáÊæ§ÊíëÊîÑÂÖéÂêêÂúüË®éÊÖüÊ°∂Ô®ÖÁóõÁ≠íÁµ±ÈÄöÂ†ÜÊßåËÖøË§™ÈÄÄÈ†πÂÅ∏Â•óÂ¶¨ÊäïÈÄèÈ¨™ÊÖùÁâπÈóñÂù°Â©ÜÂ∑¥ÊääÊí≠Êì∫Êù∑Ê≥¢Ê¥æÁà¨Áê∂Á†¥ÁΩ∑Ëä≠Ë∑õÈ†óÂà§ÂùÇÊùøÁâàÁì£Ë≤©Ëæ¶Èàë"],["f8a1","Èò™ÂÖ´Âè≠Êçå‰Ω©ÂîÑÊÇñÊïóÊ≤õÊµøÁâåÁãΩÁ®óË¶áË≤ùÂΩ≠ÊæéÁÉπËÜ®ÊÑé‰æøÂÅèÊâÅÁâáÁØáÁ∑®Áø©ÈÅçÈû≠È®ôË≤∂Âù™Âπ≥Êû∞ËêçË©ïÂê†Â¨ñÂπ£Âª¢ÂºäÊñÉËÇ∫ËîΩÈñâÈôõ‰ΩàÂåÖÂåçÂåèÂíÜÂì∫ÂúÉÂ∏ÉÊÄñÊäõÊä±ÊçïÔ®ÜÊ≥°Êµ¶Áñ±Á†≤ËÉûËÑØËãûËë°Ëí≤Ë¢çË§íÈÄãÈã™È£ΩÈÆëÂπÖÊö¥ÊõùÁÄëÁàÜÔ®á‰øµÂâΩÂΩ™ÊÖìÊùìÊ®ôÊºÇÁì¢Á•®Ë°®Ë±πÈ£áÈ£ÑÈ©É"],["f9a1","ÂìÅÁ®üÊ•ìË´∑Ë±äÈ¢®È¶ÆÂΩºÊä´Áñ≤ÁöÆË¢´ÈÅøÈôÇÂåπÂººÂøÖÊ≥åÁèåÁï¢ÁñãÁ≠ÜËãæÈ¶ù‰πèÈÄº‰∏ã‰ΩïÂé¶Â§èÂªàÊò∞Ê≤≥ÁëïËç∑Ëù¶Ë≥ÄÈÅêÈúûÈ∞ïÂ£ëÂ≠∏ËôêË¨îÈ∂¥ÂØíÊÅ®ÊÇçÊó±Ê±óÊº¢Êæ£ÁÄöÁΩïÁø∞ÈñëÈñíÈôêÈüìÂâ≤ËΩÑÂáΩÂê´Âí∏Âï£ÂñäÊ™ªÊ∂µÁ∑òËâ¶ÈäúÈô∑ÈππÂêàÂìàÁõíËõ§Èñ§ÈóîÈôú‰∫¢‰ºâÂßÆÂ´¶Â∑∑ÊÅíÊäóÊù≠Ê°ÅÊ≤ÜÊ∏ØÁº∏ËÇõËà™"],["faa1","Ô®àÔ®âÈ†Ö‰∫•ÂÅïÂí≥ÂûìÂ•öÂ≠©ÂÆ≥ÊáàÊ•∑Êµ∑ÁÄ£ËüπËß£Ë©≤Ë´ßÈÇÇÈß≠È™∏ÂäæÊ†∏ÂÄñÂπ∏ÊùèËçáË°å‰∫´ÂêëÂöÆÁè¶ÈÑïÈüøÈ§âÈ•óÈ¶ôÂôìÂ¢üËôõË®±ÊÜ≤Ê´∂ÁçªËªíÊ≠áÈö™È©óÂ•ïÁàÄËµ´Èù©‰øîÂ≥¥Âº¶Êá∏ÊôõÊ≥´ÁÇ´ÁéÑÁéπÁèæÁú©ÁùçÁµÉÁµ¢Á∏£Ëà∑Ë°íÔ®äË≥¢ÈââÈ°ØÂ≠ëÁ©¥Ë°ÄÈ†ÅÂ´å‰ø†ÂçîÂ§æÂ≥ΩÊåæÊµπÁãπËÑÖËÑáËé¢ÈãèÈ†∞‰∫®ÂÖÑÂàëÂûã"],["fba1","ÂΩ¢Ê≥ÇÊªéÁÄÖÁÅêÁÇØÁÜíÁè©Áë©ËçäËû¢Ë°°ÈÄàÈÇ¢Èé£È¶®ÂÖÆÂΩóÊÉ†ÊÖßÊö≥ËïôËπäÈÜØÈûã‰πé‰∫íÂëºÂ£ïÂ£∫Â•ΩÂ≤µÂºßÊà∂ÊâàÊòäÊôßÊØ´Êµ©Ê∑èÊπñÊª∏ÊæîÊø†Êø©ÁÅùÁãêÁê•ÁëöÁì†ÁöìÁ•úÁ≥äÁ∏ûËÉ°Ëä¶Ëë´ËíøËôéËôüËù¥Ë≠∑Ë±™Èé¨È†ÄÈ°•ÊÉëÊàñÈÖ∑Â©öÊòèÊ∑∑Ê∏æÁêøÈ≠ÇÂøΩÊÉöÁ¨èÂìÑÂºòÊ±ûÊ≥ìÊ¥™ÁÉòÁ¥ÖËôπË®åÈ¥ªÂåñÂíåÂ¨ÖÊ®∫ÁÅ´Áïµ"],["fca1","Á¶çÁ¶æËä±ËèØË©±Ë≠ÅË≤®Èù¥Ô®ãÊì¥Êî´Á¢∫Á¢ªÁ©´‰∏∏ÂñöÂ•êÂÆ¶ÂπªÊÇ£ÊèõÊ≠°Êô•Ê°ìÊ∏ôÁÖ•Áí∞Á¥àÈÇÑÈ©©È∞•Ê¥ªÊªëÁåæË±ÅÈóäÂá∞ÂπåÂæ®ÊÅçÊÉ∂ÊÑ∞ÊÖåÊôÉÊôÑÊ¶•Ê≥ÅÊπüÊªâÊΩ¢ÁÖåÁíúÁöáÁØÅÁ∞ßËçíËùóÈÅëÈöçÈªÉÂåØÂõûÂªªÂæäÊÅ¢ÊÇîÊá∑Êô¶ÊúÉÊ™úÊ∑ÆÊæÆÁÅ∞Áç™Áπ™ËÜæËå¥ËõîË™®Ë≥ÑÂäÉÁç≤ÂÆñÊ©´ÈêÑÂìÆÂöÜÂ≠ùÊïàÊñÖÊõâÊ¢üÊ∂çÊ∑Ü"],["fda1","ÁàªËÇ¥ÈÖµÈ©ç‰æØÂÄôÂéöÂêéÂêºÂñâÂóÖÂ∏øÂæåÊúΩÁÖ¶ÁèùÈÄÖÂãõÂã≥Â°§Â£éÁÑÑÁÜèÁáªËñ∞Ë®ìÊöàËñ®ÂñßÊöÑÁÖäËê±ÂçâÂñôÊØÅÂΩôÂæΩÊèÆÊöâÁÖáË´±ËºùÈ∫æ‰ºëÊê∫ÁÉãÁï¶ËôßÊÅ§Ë≠éÈ∑∏ÂÖáÂá∂ÂåàÊ¥∂ËÉ∏ÈªëÊòïÊ¨£ÁÇòÁóïÂêÉÂ±πÁ¥áË®ñÊ¨†Ê¨ΩÊ≠ÜÂê∏ÊÅ∞Ê¥ΩÁøïËààÂÉñÂáûÂñúÂô´ÂõçÂß¨Â¨âÂ∏åÊÜôÊÜòÊà±ÊôûÊõ¶ÁÜôÁÜπÁÜ∫ÁäßÁ¶ßÁ®ÄÁæ≤Ë©∞"]]');

/***/ }),

/***/ 15322:
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('[["0","\\u0000",127],["a140","„ÄÄÔºå„ÄÅ„ÄÇÔºé‚ÄßÔºõÔºöÔºüÔºÅÔ∏∞‚Ä¶‚Ä•ÔπêÔπëÔπí¬∑ÔπîÔπïÔπñÔπóÔΩú‚ÄìÔ∏±‚ÄîÔ∏≥‚ï¥Ô∏¥ÔπèÔºàÔºâÔ∏µÔ∏∂ÔΩõÔΩùÔ∏∑Ô∏∏„Äî„ÄïÔ∏πÔ∏∫„Äê„ÄëÔ∏ªÔ∏º„Ää„ÄãÔ∏ΩÔ∏æ„Äà„ÄâÔ∏øÔπÄ„Äå„ÄçÔπÅÔπÇ„Äé„ÄèÔπÉÔπÑÔπôÔπö"],["a1a1","ÔπõÔπúÔπùÔπû‚Äò‚Äô‚Äú‚Äù„Äù„Äû‚Äµ‚Ä≤ÔºÉÔºÜÔºä‚Äª¬ß„ÄÉ‚óã‚óè‚ñ≥‚ñ≤‚óé‚òÜ‚òÖ‚óá‚óÜ‚ñ°‚ñ†‚ñΩ‚ñº„ä£‚ÑÖ¬ØÔø£ÔºøÀçÔπâÔπäÔπçÔπéÔπãÔπåÔπüÔπ†Ôπ°ÔºãÔºç√ó√∑¬±‚àöÔºúÔºûÔºù‚â¶‚âß‚â†‚àû‚âí‚â°Ôπ¢",4,"ÔΩû‚à©‚à™‚ä•‚à†‚àü‚äø„èí„èë‚à´‚àÆ‚àµ‚à¥‚ôÄ‚ôÇ‚äï‚äô‚Üë‚Üì‚Üê‚Üí‚Üñ‚Üó‚Üô‚Üò‚à•‚à£Ôºè"],["a240","Ôºº‚àïÔπ®ÔºÑÔø•„ÄíÔø†Ôø°ÔºÖÔº†‚ÑÉ‚ÑâÔπ©Ôπ™Ôπ´„èï„éú„éù„éû„èé„é°„éé„éè„èÑ¬∞ÂÖôÂÖõÂÖûÂÖùÂÖ°ÂÖ£ÂóßÁì©Á≥é‚ñÅ",7,"‚ñè‚ñé‚ñç‚ñå‚ñã‚ñä‚ñâ‚îº‚î¥‚î¨‚î§‚îú‚ñî‚îÄ‚îÇ‚ñï‚îå‚îê‚îî‚îò‚ï≠"],["a2a1","‚ïÆ‚ï∞‚ïØ‚ïê‚ïû‚ï™‚ï°‚ó¢‚ó£‚ó•‚ó§‚ï±‚ï≤‚ï≥Ôºê",9,"‚Ö†",9,"„Ä°",8,"ÂçÅÂçÑÂçÖÔº°",25,"ÔΩÅ",21],["a340","ÔΩóÔΩòÔΩôÔΩöŒë",16,"Œ£",6,"Œ±",16,"œÉ",6,"„ÑÖ",10],["a3a1","„Ñê",25,"ÀôÀâÀäÀáÀã"],["a3e1","‚Ç¨"],["a440","‰∏Ä‰πô‰∏Å‰∏É‰πÉ‰πù‰∫Ü‰∫å‰∫∫ÂÑøÂÖ•ÂÖ´Âá†ÂàÄÂàÅÂäõÂåïÂçÅÂçúÂèà‰∏â‰∏ã‰∏à‰∏ä‰∏´‰∏∏Âá°‰πÖ‰πà‰πü‰πû‰∫é‰∫°ÂÖÄÂàÉÂã∫ÂçÉÂèâÂè£ÂúüÂ£´Â§ïÂ§ßÂ•≥Â≠êÂ≠ëÂ≠ìÂØ∏Â∞èÂ∞¢Â∞∏Â±±Â∑ùÂ∑•Â∑±Â∑≤Â∑≥Â∑æÂπ≤ÂªæÂºãÂºìÊâç"],["a4a1","‰∏ë‰∏ê‰∏ç‰∏≠‰∏∞‰∏π‰πãÂ∞π‰∫à‰∫ë‰∫ï‰∫í‰∫î‰∫¢‰ªÅ‰ªÄ‰ªÉ‰ªÜ‰ªá‰ªç‰ªä‰ªã‰ªÑÂÖÉÂÖÅÂÖßÂÖ≠ÂÖÆÂÖ¨ÂÜóÂá∂ÂàÜÂàáÂààÂãªÂãæÂãøÂåñÂåπÂçàÂçáÂçÖÂçûÂéÑÂèãÂèäÂèçÂ£¨Â§©Â§´Â§™Â§≠Â≠îÂ∞ëÂ∞§Â∞∫Â±ØÂ∑¥ÂπªÂªøÂºîÂºïÂøÉÊààÊà∂ÊâãÊâéÊîØÊñáÊñóÊñ§ÊñπÊó•Êõ∞ÊúàÊú®Ê¨†Ê≠¢Ê≠πÊØãÊØîÊØõÊ∞èÊ∞¥ÁÅ´Áà™Áà∂ÁàªÁâáÁâôÁâõÁä¨Áéã‰∏ô"],["a540","‰∏ñ‰∏ï‰∏î‰∏ò‰∏ª‰πç‰πè‰πé‰ª•‰ªò‰ªî‰ªï‰ªñ‰ªó‰ª£‰ª§‰ªô‰ªûÂÖÖÂÖÑÂÜâÂÜäÂÜ¨ÂáπÂá∫Âá∏ÂàäÂä†ÂäüÂåÖÂåÜÂåóÂåù‰ªüÂçäÂçâÂç°Âç†ÂçØÂçÆÂéªÂèØÂè§Âè≥Âè¨ÂèÆÂè©Âè®ÂèºÂè∏ÂèµÂè´Âè¶Âè™Âè≤Âè±Âè∞Âè•Âè≠ÂèªÂõõÂõöÂ§ñ"],["a5a1","Â§ÆÂ§±Â•¥Â•∂Â≠ïÂÆÉÂ∞ºÂ∑®Â∑ßÂ∑¶Â∏ÇÂ∏ÉÂπ≥ÂπºÂºÅÂºòÂºóÂøÖÊàäÊâìÊâîÊâíÊâëÊñ•Êó¶ÊúÆÊú¨Êú™Êú´Êú≠Ê≠£ÊØçÊ∞ëÊ∞êÊ∞∏Ê±ÅÊ±ÄÊ∞æÁäØÁéÑÁéâÁìúÁì¶ÁîòÁîüÁî®Áî©Áî∞Áî±Áî≤Áî≥ÁñãÁôΩÁöÆÁöøÁõÆÁüõÁü¢Áü≥Á§∫Á¶æÁ©¥Á´ã‰∏û‰∏ü‰πí‰πì‰π©‰∫ô‰∫§‰∫¶‰∫•‰ªø‰ºâ‰ºô‰ºä‰ºï‰ºç‰ºê‰ºë‰ºè‰ª≤‰ª∂‰ªª‰ª∞‰ª≥‰ªΩ‰ºÅ‰ºãÂÖâÂÖáÂÖÜÂÖàÂÖ®"],["a640","ÂÖ±ÂÜçÂÜ∞ÂàóÂàëÂàíÂàéÂàñÂä£ÂåàÂå°Âå†Âç∞Âç±ÂêâÂêèÂêåÂêäÂêêÂêÅÂêãÂêÑÂêëÂêçÂêàÂêÉÂêéÂêÜÂêíÂõ†ÂõûÂõùÂú≥Âú∞Âú®Âú≠Âú¨ÂúØÂú©Â§ôÂ§öÂ§∑Â§∏Â¶ÑÂ•∏Â¶ÉÂ•ΩÂ•πÂ¶ÇÂ¶ÅÂ≠óÂ≠òÂÆáÂÆàÂÆÖÂÆâÂØ∫Â∞ñÂ±πÂ∑ûÂ∏ÜÂπ∂Âπ¥"],["a6a1","ÂºèÂºõÂøôÂøñÊàéÊàåÊàçÊàêÊâ£ÊâõÊâòÊî∂Êó©Êó®Êó¨Êó≠Êõ≤Êõ≥ÊúâÊúΩÊú¥Êú±ÊúµÊ¨°Ê≠§Ê≠ªÊ∞ñÊ±ùÊ±óÊ±ôÊ±üÊ±†Ê±êÊ±ïÊ±°Ê±õÊ±çÊ±éÁÅ∞ÁâüÁâùÁôæÁ´πÁ±≥Á≥∏Áº∂ÁæäÁæΩËÄÅËÄÉËÄåËÄíËÄ≥ËÅøËÇâËÇãËÇåËá£Ëá™Ëá≥ËáºËàåËàõËàüËâÆËâ≤ËâæËô´Ë°ÄË°åË°£Ë•øÈò°‰∏≤‰∫®‰Ωç‰Ωè‰Ωá‰Ωó‰Ωû‰º¥‰Ωõ‰Ωï‰º∞‰Ωê‰Ωë‰ºΩ‰º∫‰º∏‰ΩÉ‰Ωî‰ºº‰ΩÜ‰Ω£"],["a740","‰Ωú‰Ω†‰ºØ‰Ωé‰º∂‰Ωô‰Ωù‰Ωà‰ΩöÂÖåÂÖãÂÖçÂÖµÂÜ∂ÂÜ∑Âà•Âà§Âà©Âà™Âà®Âä´Âä©Âä™Âä¨Âå£Âç≥ÂçµÂêùÂê≠ÂêûÂêæÂê¶ÂëéÂêßÂëÜÂëÉÂê≥ÂëàÂëÇÂêõÂê©ÂëäÂêπÂêªÂê∏ÂêÆÂêµÂê∂Âê†ÂêºÂëÄÂê±Âê´ÂêüÂê¨Âõ™Âõ∞Âõ§Âõ´ÂùäÂùëÂùÄÂùç"],["a7a1","ÂùáÂùéÂúæÂùêÂùèÂúªÂ£ØÂ§æÂ¶ùÂ¶íÂ¶®Â¶ûÂ¶£Â¶ôÂ¶ñÂ¶çÂ¶§Â¶ìÂ¶äÂ¶•Â≠ùÂ≠úÂ≠öÂ≠õÂÆåÂÆãÂÆèÂ∞¨Â±ÄÂ±ÅÂ∞øÂ∞æÂ≤êÂ≤ëÂ≤îÂ≤åÂ∑´Â∏åÂ∫èÂ∫áÂ∫äÂª∑ÂºÑÂºüÂΩ§ÂΩ¢ÂΩ∑ÂΩπÂøòÂøåÂøóÂøçÂø±Âø´Âø∏Âø™ÊàíÊàëÊäÑÊäóÊäñÊäÄÊâ∂ÊäâÊâ≠ÊääÊâºÊâæÊâπÊâ≥ÊäíÊâØÊäòÊâÆÊäïÊäìÊäëÊäÜÊîπÊîªÊî∏Êó±Êõ¥ÊùüÊùéÊùèÊùêÊùëÊùúÊùñÊùûÊùâÊùÜÊù†"],["a840","ÊùìÊùóÊ≠•ÊØèÊ±ÇÊ±ûÊ≤ôÊ≤ÅÊ≤àÊ≤âÊ≤ÖÊ≤õÊ±™Ê±∫Ê≤êÊ±∞Ê≤åÊ±®Ê≤ñÊ≤íÊ±ΩÊ≤ÉÊ±≤Ê±æÊ±¥Ê≤ÜÊ±∂Ê≤çÊ≤îÊ≤òÊ≤ÇÁÅ∂ÁÅºÁÅΩÁÅ∏Áâ¢Áâ°Áâ†ÁãÑÁãÇÁéñÁî¨Áî´Áî∑Áî∏ÁöÇÁõØÁü£ÁßÅÁßÄÁ¶øÁ©∂Á≥ªÁΩïËÇñËÇìËÇùËÇòËÇõËÇöËÇ≤ËâØËäí"],["a8a1","ËäãËäçË¶ãËßíË®ÄË∞∑Ë±ÜË±ïË≤ùËµ§Ëµ∞Ë∂≥Ë∫´ËªäËæõËæ∞ËøÇËøÜËøÖËøÑÂ∑°ÈÇëÈÇ¢ÈÇ™ÈÇ¶ÈÇ£ÈÖâÈáÜÈáåÈò≤ÈòÆÈò±Èò™Èò¨‰∏¶‰πñ‰π≥‰∫ã‰∫õ‰∫û‰∫´‰∫¨‰ΩØ‰æù‰æç‰Ω≥‰Ωø‰Ω¨‰æõ‰æã‰æÜ‰æÉ‰Ω∞‰Ωµ‰æà‰Ω©‰Ωª‰æñ‰Ωæ‰æè‰æë‰Ω∫ÂÖîÂÖíÂÖïÂÖ©ÂÖ∑ÂÖ∂ÂÖ∏ÂÜΩÂáΩÂàªÂà∏Âà∑Âà∫Âà∞ÂàÆÂà∂ÂâÅÂäæÂäªÂçíÂçîÂçìÂçëÂç¶Âç∑Âç∏ÂçπÂèñÂèîÂèóÂë≥Âëµ"],["a940","ÂíñÂë∏ÂíïÂíÄÂëªÂë∑ÂíÑÂííÂíÜÂëºÂíêÂë±Âë∂ÂíåÂíöÂë¢Âë®ÂíãÂëΩÂíéÂõ∫ÂûÉÂù∑Âù™Âù©Âù°Âù¶Âù§ÂùºÂ§úÂ•âÂ•áÂ•àÂ•ÑÂ•îÂ¶æÂ¶ªÂßîÂ¶πÂ¶ÆÂßëÂßÜÂßêÂßçÂßãÂßìÂßäÂ¶ØÂ¶≥ÂßíÂßÖÂ≠üÂ≠§Â≠£ÂÆóÂÆöÂÆòÂÆúÂÆôÂÆõÂ∞öÂ±àÂ±Ö"],["a9a1","Â±ÜÂ≤∑Â≤°Â≤∏Â≤©Â≤´Â≤±Â≤≥Â∏òÂ∏öÂ∏ñÂ∏ïÂ∏õÂ∏ëÂπ∏Â∫öÂ∫óÂ∫úÂ∫ïÂ∫ñÂª∂Âº¶ÂºßÂº©ÂæÄÂæÅÂΩøÂΩºÂøùÂø†ÂøΩÂøµÂøøÊÄèÊÄîÊÄØÊÄµÊÄñÊÄ™ÊÄïÊÄ°ÊÄßÊÄ©ÊÄ´ÊÄõÊàñÊàïÊàøÊàæÊâÄÊâøÊãâÊãåÊãÑÊäøÊãÇÊäπÊãíÊãõÊä´ÊãìÊãîÊããÊãàÊä®ÊäΩÊäºÊãêÊãôÊãáÊãçÊäµÊãöÊä±ÊãòÊãñÊãóÊãÜÊä¨ÊãéÊîæÊñßÊñºÊó∫ÊòîÊòìÊòåÊòÜÊòÇÊòéÊòÄÊòèÊòïÊòä"],["aa40","ÊòáÊúçÊúãÊù≠ÊûãÊûïÊù±ÊûúÊù≥Êù∑ÊûáÊûùÊûóÊùØÊù∞ÊùøÊûâÊùæÊûêÊùµÊûöÊûìÊùºÊù™Êù≤Ê¨£Ê≠¶Ê≠ßÊ≠øÊ∞ìÊ∞õÊ≥£Ê≥®Ê≥≥Ê≤±Ê≥åÊ≥•Ê≤≥Ê≤ΩÊ≤æÊ≤ºÊ≥¢Ê≤´Ê≥ïÊ≥ìÊ≤∏Ê≥ÑÊ≤πÊ≥ÅÊ≤ÆÊ≥óÊ≥ÖÊ≥±Ê≤øÊ≤ªÊ≥°Ê≥õÊ≥äÊ≤¨Ê≥ØÊ≥úÊ≥ñÊ≥†"],["aaa1","ÁÇïÁÇéÁÇíÁÇäÁÇôÁà¨Áà≠Áà∏ÁâàÁâßÁâ©ÁãÄÁãéÁãôÁãóÁãêÁé©Áé®ÁéüÁé´Áé•ÁîΩÁñùÁñôÁñöÁöÑÁõÇÁõ≤Áõ¥Áü•ÁüΩÁ§æÁ•ÄÁ•ÅÁßâÁßàÁ©∫Á©πÁ´∫Á≥æÁΩîÁæåÁæãËÄÖËÇ∫ËÇ•ËÇ¢ËÇ±ËÇ°ËÇ´ËÇ©ËÇ¥ËÇ™ËÇØËá•ËáæËàçËä≥ËäùËäôËä≠ËäΩËäüËäπËä±Ëä¨Ëä•ËäØËä∏Ëä£Ëä∞ËäæËä∑ËôéËô±ÂàùË°®ËªãËøéËøîËøëÈÇµÈÇ∏ÈÇ±ÈÇ∂ÈááÈáëÈï∑ÈñÄÈòúÈôÄÈòøÈòªÈôÑ"],["ab40","ÈôÇÈöπÈõ®ÈùíÈùû‰∫ü‰∫≠‰∫Æ‰ø°‰æµ‰æØ‰æø‰ø†‰øë‰øè‰øù‰øÉ‰æ∂‰øò‰øü‰øä‰øó‰æÆ‰øê‰øÑ‰øÇ‰øö‰øé‰øû‰æ∑ÂÖóÂÜíÂÜëÂÜ†ÂâéÂâÉÂâäÂâçÂâåÂâãÂâáÂãáÂãâÂãÉÂãÅÂåçÂçóÂçªÂéöÂèõÂí¨ÂìÄÂí®ÂìéÂìâÂí∏Âí¶Âí≥ÂìáÂìÇÂíΩÂí™ÂìÅ"],["aba1","ÂìÑÂìàÂíØÂí´Âí±ÂíªÂí©ÂíßÂíøÂõøÂûÇÂûãÂû†Âû£Âû¢ÂüéÂûÆÂûìÂ•ïÂ•ëÂ•èÂ•éÂ•êÂßúÂßòÂßøÂß£Âß®Â®ÉÂß•Âß™ÂßöÂß¶Â®ÅÂßªÂ≠©ÂÆ£ÂÆ¶ÂÆ§ÂÆ¢ÂÆ•Â∞ÅÂ±éÂ±èÂ±çÂ±ãÂ≥ôÂ≥íÂ∑∑Â∏ùÂ∏•Â∏üÂπΩÂ∫†Â∫¶Âª∫ÂºàÂº≠ÂΩ•ÂæàÂæÖÂæäÂæãÂæáÂæåÂæâÊÄíÊÄùÊÄ†ÊÄ•ÊÄéÊÄ®ÊÅçÊÅ∞ÊÅ®ÊÅ¢ÊÅÜÊÅÉÊÅ¨ÊÅ´ÊÅ™ÊÅ§ÊâÅÊãúÊåñÊåâÊãºÊã≠ÊåÅÊãÆÊãΩÊåáÊã±Êã∑"],["ac40","ÊãØÊã¨ÊãæÊã¥ÊåëÊåÇÊîøÊïÖÊñ´ÊñΩÊó¢Êò•Êò≠Êò†ÊòßÊòØÊòüÊò®Êò±Êò§Êõ∑ÊüøÊüìÊü±ÊüîÊüêÊü¨Êû∂ÊûØÊüµÊü©ÊüØÊüÑÊüëÊû¥ÊüöÊü•Êû∏ÊüèÊüûÊü≥Êû∞ÊüôÊü¢ÊüùÊüíÊ≠™ÊÆÉÊÆÜÊÆµÊØíÊØóÊ∞üÊ≥âÊ¥ãÊ¥≤Ê¥™ÊµÅÊ¥•Ê¥åÊ¥±Ê¥ûÊ¥ó"],["aca1","Ê¥ªÊ¥ΩÊ¥æÊ¥∂Ê¥õÊ≥µÊ¥πÊ¥ßÊ¥∏Ê¥©Ê¥ÆÊ¥µÊ¥éÊ¥´ÁÇ´ÁÇ∫ÁÇ≥ÁÇ¨ÁÇØÁÇ≠ÁÇ∏ÁÇÆÁÇ§Áà∞Áâ≤ÁâØÁâ¥Áã©Áã†Áã°Áé∑ÁèäÁéªÁé≤ÁèçÁèÄÁé≥ÁîöÁî≠ÁïèÁïåÁïéÁïãÁñ´Áñ§Áñ•Áñ¢Áñ£Áô∏ÁöÜÁöáÁöàÁõàÁõÜÁõÉÁõÖÁúÅÁõπÁõ∏ÁúâÁúãÁõæÁõºÁúáÁüúÁ†ÇÁ†îÁ†åÁ†çÁ•ÜÁ•âÁ•àÁ•áÁ¶πÁ¶∫ÁßëÁßíÁßãÁ©øÁ™ÅÁ´øÁ´ΩÁ±ΩÁ¥ÇÁ¥ÖÁ¥ÄÁ¥âÁ¥áÁ¥ÑÁ¥ÜÁº∏ÁæéÁæøËÄÑ"],["ad40","ËÄêËÄçËÄëËÄ∂ËÉñËÉ•ËÉöËÉÉËÉÑËÉåËÉ°ËÉõËÉéËÉûËÉ§ËÉùËá¥Ëà¢ËãßËåÉËåÖËã£ËãõËã¶ËåÑËã•ËåÇËåâËãíËãóËã±ËåÅËãúËãîËãëËãûËãìËãüËãØËåÜËôêËôπËôªËô∫Ë°çË°´Ë¶ÅËßîË®àË®ÇË®ÉË≤ûË≤†Ëµ¥Ëµ≥Ë∂¥ËªçËªåËø∞Ëø¶Ëø¢Ëø™Ëø•"],["ada1","Ëø≠Ëø´Ëø§Ëø®ÈÉäÈÉéÈÉÅÈÉÉÈÖãÈÖäÈáçÈñÇÈôêÈôãÈôåÈôçÈù¢Èù©ÈüãÈü≠Èü≥È†ÅÈ¢®È£õÈ£üÈ¶ñÈ¶ô‰πò‰∫≥ÂÄåÂÄçÂÄ£‰øØÂÄ¶ÂÄ•‰ø∏ÂÄ©ÂÄñÂÄÜÂÄºÂÄüÂÄöÂÄíÂÄë‰ø∫ÂÄÄÂÄîÂÄ®‰ø±ÂÄ°ÂÄãÂÄôÂÄò‰ø≥‰øÆÂÄ≠ÂÄ™‰øæÂÄ´ÂÄâÂÖºÂÜ§ÂÜ•ÂÜ¢ÂáçÂáåÂáÜÂáãÂâñÂâúÂâîÂâõÂâùÂå™ÂçøÂéüÂéùÂèüÂì®ÂîêÂîÅÂî∑ÂìºÂì•Âì≤ÂîÜÂì∫ÂîîÂì©Âì≠Âì°ÂîâÂìÆÂì™"],["ae40","Âì¶ÂîßÂîáÂìΩÂîèÂúÉÂúÑÂüÇÂüîÂüãÂüÉÂ†âÂ§èÂ•óÂ•òÂ•öÂ®ëÂ®òÂ®úÂ®üÂ®õÂ®ìÂß¨Â®†Â®£Â®©Â®•Â®åÂ®âÂ≠´Â±òÂÆ∞ÂÆ≥ÂÆ∂ÂÆ¥ÂÆÆÂÆµÂÆπÂÆ∏Â∞ÑÂ±ëÂ±ïÂ±êÂ≥≠Â≥ΩÂ≥ªÂ≥™Â≥®Â≥∞Â≥∂Â¥ÅÂ≥¥Â∑ÆÂ∏≠Â∏´Â∫´Â∫≠Â∫ßÂº±ÂæíÂæëÂæêÊÅô"],["aea1","ÊÅ£ÊÅ•ÊÅêÊÅïÊÅ≠ÊÅ©ÊÅØÊÇÑÊÇüÊÇöÊÇçÊÇîÊÇåÊÇÖÊÇñÊâáÊã≥ÊåàÊãøÊçéÊåæÊåØÊçïÊçÇÊçÜÊçèÊçâÊå∫ÊçêÊåΩÊå™Êå´Êå®ÊççÊçåÊïàÊïâÊñôÊóÅÊóÖÊôÇÊôâÊôèÊôÉÊôíÊôåÊôÖÊôÅÊõ∏ÊúîÊúïÊúóÊ†°Ê†∏Ê°àÊ°ÜÊ°ìÊ†πÊ°ÇÊ°îÊ†©Ê¢≥Ê†óÊ°åÊ°ëÊ†ΩÊü¥Ê°êÊ°ÄÊ†ºÊ°ÉÊ†™Ê°ÖÊ†ìÊ†òÊ°ÅÊÆäÊÆâÊÆ∑Ê∞£Ê∞ßÊ∞®Ê∞¶Ê∞§Ê≥∞Êµ™Ê∂ïÊ∂àÊ∂áÊµ¶Êµ∏Êµ∑ÊµôÊ∂ì"],["af40","Êµ¨Ê∂âÊµÆÊµöÊµ¥Êµ©Ê∂åÊ∂äÊµπÊ∂ÖÊµ•Ê∂îÁÉäÁÉòÁÉ§ÁÉôÁÉàÁÉèÁàπÁâπÁãºÁãπÁãΩÁã∏Áã∑ÁéÜÁè≠ÁêâÁèÆÁè†Áè™ÁèûÁïîÁïùÁïúÁïöÁïôÁñæÁóÖÁóáÁñ≤Áñ≥ÁñΩÁñºÁñπÁóÇÁñ∏ÁöãÁö∞ÁõäÁõçÁõéÁú©ÁúüÁú†Áú®Áü©Á†∞Á†ßÁ†∏Á†ùÁ†¥Á†∑"],["afa1","Á†•Á†≠Á††Á†üÁ†≤Á•ïÁ•êÁ•†Á•üÁ•ñÁ•ûÁ•ùÁ•óÁ•öÁß§Áß£ÁßßÁßüÁß¶Áß©ÁßòÁ™ÑÁ™àÁ´ôÁ¨ÜÁ¨ëÁ≤âÁ¥°Á¥óÁ¥ãÁ¥äÁ¥†Á¥¢Á¥îÁ¥êÁ¥ïÁ¥öÁ¥úÁ¥çÁ¥ôÁ¥õÁº∫ÁΩüÁæîÁøÖÁøÅËÄÜËÄòËÄïËÄôËÄóËÄΩËÄøËÉ±ËÑÇËÉ∞ËÑÖËÉ≠ËÉ¥ËÑÜËÉ∏ËÉ≥ËÑàËÉΩËÑäËÉºËÉØËá≠Ëá¨ËàÄËàêËà™Ëà´Ëà®Ëà¨ËäªËå´ËçíËçîËçäËå∏ËçêËçâËåµËå¥ËçèËå≤ËåπËå∂ËåóËçÄËå±Ëå®ËçÉ"],["b040","ËôîËöäËö™ËöìËö§Ëö©ËöåËö£ËöúË°∞Ë°∑Ë¢ÅË¢ÇË°ΩË°πË®òË®êË®éË®åË®ïË®äË®óË®ìË®ñË®èË®ëË±àË±∫Ë±πË≤°Ë≤¢Ëµ∑Ë∫¨ËªíËªîËªèËæ±ÈÄÅÈÄÜËø∑ÈÄÄËø∫Ëø¥ÈÄÉËøΩÈÄÖËø∏ÈÇïÈÉ°ÈÉùÈÉ¢ÈÖíÈÖçÈÖåÈáòÈáùÈáóÈáúÈáôÈñÉÈô¢Èô£Èô°"],["b0a1","ÈôõÈôùÈô§ÈôòÈôûÈöªÈ£¢È¶¨È™®È´òÈ¨•È¨≤È¨º‰πæÂÅ∫ÂÅΩÂÅúÂÅáÂÅÉÂÅåÂÅöÂÅâÂÅ•ÂÅ∂ÂÅéÂÅïÂÅµÂÅ¥ÂÅ∑ÂÅèÂÄèÂÅØÂÅ≠ÂÖúÂÜïÂá∞Ââ™ÂâØÂãíÂãôÂãòÂãïÂåêÂåèÂåôÂåøÂçÄÂåæÂèÉÊõºÂïÜÂï™Âï¶ÂïÑÂïûÂï°ÂïÉÂïäÂî±ÂïñÂïèÂïïÂîØÂï§Âî∏ÂîÆÂïúÂî¨Âï£Âî≥ÂïÅÂïóÂúàÂúãÂúâÂüüÂ†ÖÂ†äÂ†ÜÂü†Âü§Âü∫Â†ÇÂ†µÂü∑ÂüπÂ§†Â•¢Â®∂Â©ÅÂ©âÂ©¶Â©™Â©Ä"],["b140","Â®ºÂ©¢Â©öÂ©ÜÂ©äÂ≠∞ÂØáÂØÖÂØÑÂØÇÂÆøÂØÜÂ∞âÂ∞àÂ∞áÂ±†Â±úÂ±ùÂ¥áÂ¥ÜÂ¥éÂ¥õÂ¥ñÂ¥¢Â¥ëÂ¥©Â¥îÂ¥ôÂ¥§Â¥ßÂ¥óÂ∑¢Â∏∏Â∏∂Â∏≥Â∏∑Â∫∑Â∫∏Â∫∂Â∫µÂ∫æÂºµÂº∑ÂΩóÂΩ¨ÂΩ©ÂΩ´ÂæóÂæôÂæûÂæòÂæ°Âæ†ÂæúÊÅøÊÇ£ÊÇâÊÇ†ÊÇ®ÊÉãÊÇ¥ÊÉ¶ÊÇΩ"],["b1a1","ÊÉÖÊÇªÊÇµÊÉúÊÇºÊÉòÊÉïÊÉÜÊÉüÊÇ∏ÊÉöÊÉáÊàöÊàõÊâàÊé†ÊéßÊç≤ÊéñÊé¢Êé•Êç∑ÊçßÊéòÊé™Êç±Êé©ÊéâÊéÉÊéõÊç´Êé®ÊéÑÊéàÊéôÊé°Êé¨ÊéíÊéèÊéÄÊçªÊç©Êç®Êç∫ÊïùÊïñÊïëÊïôÊïóÂïüÊïèÊïòÊïïÊïîÊñúÊñõÊñ¨ÊóèÊóãÊóåÊóéÊôùÊôöÊô§Êô®Êô¶ÊôûÊõπÂãóÊúõÊ¢ÅÊ¢ØÊ¢¢Ê¢ìÊ¢µÊ°øÊ°∂Ê¢±Ê¢ßÊ¢óÊ¢∞Ê¢ÉÊ£ÑÊ¢≠Ê¢ÜÊ¢ÖÊ¢îÊ¢ùÊ¢®Ê¢üÊ¢°Ê¢ÇÊ¨≤ÊÆ∫"],["b240","ÊØ´ÊØ¨Ê∞´Ê∂éÊ∂ºÊ∑≥Ê∑ôÊ∂≤Ê∑°Ê∑åÊ∑§Ê∑ªÊ∑∫Ê∏ÖÊ∑áÊ∑ãÊ∂ØÊ∑ëÊ∂ÆÊ∑ûÊ∑πÊ∂∏Ê∑∑Ê∑µÊ∑ÖÊ∑íÊ∏öÊ∂µÊ∑öÊ∑´Ê∑òÊ∑™Ê∑±Ê∑ÆÊ∑®Ê∑ÜÊ∑ÑÊ∂™Ê∑¨Ê∂øÊ∑¶ÁÉπÁÑâÁÑäÁÉΩÁÉØÁàΩÁâΩÁäÅÁåúÁåõÁåñÁåìÁåôÁéáÁêÖÁêäÁêÉÁêÜÁèæÁêçÁì†Áì∂"],["b2a1","Áì∑ÁîúÁî¢Áï•Áï¶Áï¢Áï∞ÁñèÁóîÁóïÁñµÁóäÁóçÁöéÁõîÁõíÁõõÁú∑ÁúæÁúºÁú∂Áú∏Áú∫Á°´Á°ÉÁ°éÁ••Á•®Á•≠ÁßªÁ™íÁ™ïÁ¨†Á¨®Á¨õÁ¨¨Á¨¶Á¨ôÁ¨ûÁ¨ÆÁ≤íÁ≤óÁ≤ïÁµÜÁµÉÁµ±Á¥ÆÁ¥πÁ¥ºÁµÄÁ¥∞Á¥≥ÁµÑÁ¥ØÁµÇÁ¥≤Á¥±ÁºΩÁæûÁæöÁøåÁøéÁøíËÄúËÅäËÅÜËÑØËÑñËÑ£ËÑ´ËÑ©ËÑ∞ËÑ§ËàÇËàµËà∑Ëà∂ËàπËééËéûËéòËç∏Ëé¢ËéñËéΩËé´ËéíËéäËéìËéâËé†Ëç∑ËçªËçº"],["b340","ËéÜËéßËôïÂΩ™ËõáËõÄËö∂ËõÑËöµËõÜËõãËö±ËöØËõâË°ìË¢ûË¢àË¢´Ë¢íË¢ñË¢çË¢ãË¶ìË¶èË®™Ë®ùË®£Ë®•Ë®±Ë®≠Ë®üË®õË®¢Ë±âË±öË≤©Ë≤¨Ë≤´Ë≤®Ë≤™Ë≤ßËµßËµ¶Ë∂æË∂∫ËªõËªüÈÄôÈÄçÈÄöÈÄóÈÄ£ÈÄüÈÄùÈÄêÈÄïÈÄûÈÄ†ÈÄèÈÄ¢ÈÄñÈÄõÈÄî"],["b3a1","ÈÉ®ÈÉ≠ÈÉΩÈÖóÈáéÈáµÈá¶Èá£ÈáßÈá≠Èá©ÈñâÈô™ÈôµÈô≥Èô∏Èô∞Èô¥Èô∂Èô∑Èô¨ÈõÄÈõ™Èõ©Á´†Á´üÈ†ÇÈ†ÉÈ≠öÈ≥•ÈπµÈπøÈ∫•È∫ªÂÇ¢ÂÇçÂÇÖÂÇôÂÇëÂÇÄÂÇñÂÇòÂÇöÊúÄÂá±Ââ≤Ââ¥ÂâµÂâ©ÂãûÂãùÂãõÂçöÂé•ÂïªÂñÄÂñßÂïºÂñäÂñùÂñòÂñÇÂñúÂñ™ÂñîÂñáÂñãÂñÉÂñ≥ÂñÆÂñüÂîæÂñ≤ÂñöÂñªÂñ¨Âñ±ÂïæÂñâÂñ´ÂñôÂúçÂ†ØÂ†™Â†¥Â†§Â†∞Â†±Â†°Â†ùÂ††Â£πÂ£∫Â•†"],["b440","Â©∑Â™öÂ©øÂ™íÂ™õÂ™ßÂ≠≥Â≠±ÂØíÂØåÂØìÂØêÂ∞äÂ∞ãÂ∞±ÂµåÂµêÂ¥¥ÂµáÂ∑ΩÂπÖÂ∏ΩÂπÄÂπÉÂπæÂªäÂªÅÂªÇÂªÑÂººÂΩ≠Âæ©Âæ™Âæ®ÊÉëÊÉ°ÊÇ≤ÊÇ∂ÊÉ†ÊÑúÊÑ£ÊÉ∫ÊÑïÊÉ∞ÊÉªÊÉ¥ÊÖ®ÊÉ±ÊÑéÊÉ∂ÊÑâÊÑÄÊÑíÊàüÊââÊé£ÊéåÊèèÊèÄÊè©ÊèâÊèÜÊèç"],["b4a1","ÊèíÊè£ÊèêÊè°ÊèñÊè≠ÊèÆÊç∂Êè¥Êè™ÊèõÊëíÊèöÊèπÊïûÊï¶Êï¢Êï£ÊñëÊñêÊñØÊôÆÊô∞Êô¥Êô∂ÊôØÊöëÊô∫ÊôæÊô∑ÊõæÊõøÊúüÊúùÊ£∫Ê£ïÊ£†Ê£òÊ£óÊ§ÖÊ£üÊ£µÊ£ÆÊ£ßÊ£πÊ£íÊ£≤Ê££Ê£ãÊ£çÊ§çÊ§íÊ§éÊ£âÊ£öÊ•ÆÊ£ªÊ¨æÊ¨∫Ê¨ΩÊÆòÊÆñÊÆºÊØØÊ∞ÆÊ∞ØÊ∞¨Ê∏ØÊ∏∏ÊπîÊ∏°Ê∏≤ÊπßÊπäÊ∏†Ê∏•Ê∏£Ê∏õÊπõÊπòÊ∏§ÊπñÊπÆÊ∏≠Ê∏¶ÊπØÊ∏¥ÊπçÊ∏∫Ê∏¨ÊπÉÊ∏ùÊ∏æÊªã"],["b540","Ê∫âÊ∏ôÊπéÊπ£ÊπÑÊπ≤Êπ©ÊπüÁÑôÁÑöÁÑ¶ÁÑ∞ÁÑ°ÁÑ∂ÁÖÆÁÑúÁâåÁäÑÁäÄÁå∂Áå•Áå¥Áå©Áê∫Áê™Áê≥Áê¢Áê•ÁêµÁê∂Áê¥ÁêØÁêõÁê¶Áê®Áî•Áî¶Áï´Áï™Áó¢ÁóõÁó£ÁóôÁóòÁóûÁó†ÁôªÁôºÁöñÁöìÁö¥ÁõúÁùèÁü≠Á°ùÁ°¨Á°ØÁ®çÁ®àÁ®ãÁ®ÖÁ®ÄÁ™ò"],["b5a1","Á™óÁ™ñÁ´•Á´£Á≠âÁ≠ñÁ≠ÜÁ≠êÁ≠íÁ≠îÁ≠çÁ≠ãÁ≠èÁ≠ëÁ≤üÁ≤•ÁµûÁµêÁµ®ÁµïÁ¥´ÁµÆÁµ≤Áµ°Áµ¶Áµ¢Áµ∞Áµ≥ÂñÑÁøîÁøïËÄãËÅíËÇÖËÖïËÖîËÖãËÖëËÖéËÑπËÖÜËÑæËÖåËÖìËÖ¥ËàíËàúËè©ËêÉËè∏ËêçËè†ËèÖËêãËèÅËèØËè±Ëè¥ËëóËêäËè∞ËêåËèåËèΩËè≤ËèäËê∏ËêéËêÑËèúËêáËèîËèüËôõËõüËõôËõ≠ËõîËõõËõ§ËõêËõûË°óË£ÅË£ÇË¢±Ë¶ÉË¶ñË®ªË©†Ë©ïË©ûË®ºË©Å"],["b640","Ë©îË©õË©êË©ÜË®¥Ë®∫Ë®∂Ë©ñË±°Ë≤ÇË≤ØË≤ºË≤≥Ë≤ΩË≥ÅË≤ªË≥ÄË≤¥Ë≤∑Ë≤∂Ë≤øË≤∏Ë∂äË∂ÖË∂ÅË∑éË∑ùË∑ãË∑öË∑ëË∑åË∑õË∑ÜËªªËª∏ËªºËæúÈÄÆÈÄµÈÄ±ÈÄ∏ÈÄ≤ÈÄ∂ÈÑÇÈÉµÈÑâÈÉæÈÖ£ÈÖ•ÈáèÈàîÈàïÈà£ÈàâÈàûÈàçÈàêÈàáÈàëÈñîÈñèÈñãÈñë"],["b6a1","ÈñìÈñíÈñéÈöäÈöéÈöãÈôΩÈöÖÈöÜÈöçÈô≤ÈöÑÈõÅÈõÖÈõÑÈõÜÈõáÈõØÈõ≤ÈüåÈ†ÖÈ†ÜÈ†àÈ£ßÈ£™È£ØÈ£©È£≤È£≠È¶ÆÈ¶≠ÈªÉÈªçÈªë‰∫ÇÂÇ≠ÂÇµÂÇ≤ÂÇ≥ÂÉÖÂÇæÂÇ¨ÂÇ∑ÂÇªÂÇØÂÉáÂâøÂâ∑ÂâΩÂãüÂã¶Âã§Âã¢Âã£ÂåØÂóüÂó®ÂóìÂó¶ÂóéÂóúÂóáÂóëÂó£Âó§ÂóØÂóöÂó°ÂóÖÂóÜÂó•ÂóâÂúíÂúìÂ°ûÂ°ëÂ°òÂ°óÂ°öÂ°îÂ°´Â°åÂ°≠Â°äÂ°¢Â°íÂ°ãÂ•ßÂ´ÅÂ´âÂ´åÂ™æÂ™ΩÂ™º"],["b740","Â™≥Â´ÇÂ™≤Âµ©ÂµØÂπåÂππÂªâÂªàÂºíÂΩôÂæ¨ÂæÆÊÑöÊÑèÊÖàÊÑüÊÉ≥ÊÑõÊÉπÊÑÅÊÑàÊÖéÊÖåÊÖÑÊÖçÊÑæÊÑ¥ÊÑßÊÑçÊÑÜÊÑ∑Êà°Êà¢ÊêìÊêæÊêûÊê™Êê≠ÊêΩÊê¨ÊêèÊêúÊêîÊêçÊê∂ÊêñÊêóÊêÜÊï¨ÊñüÊñ∞ÊöóÊöâÊöáÊöàÊöñÊöÑÊöòÊöçÊúÉÊ¶îÊ•≠"],["b7a1","Ê•öÊ•∑Ê•†Ê•îÊ•µÊ§∞Ê¶ÇÊ•äÊ•®Ê•´Ê•ûÊ•ìÊ•πÊ¶ÜÊ•ùÊ•£Ê•õÊ≠áÊ≠≤ÊØÄÊÆøÊØìÊØΩÊ∫¢Ê∫ØÊªìÊ∫∂ÊªÇÊ∫êÊ∫ùÊªáÊªÖÊ∫•Ê∫òÊ∫ºÊ∫∫Ê∫´ÊªëÊ∫ñÊ∫úÊªÑÊªîÊ∫™Ê∫ßÊ∫¥ÁÖéÁÖôÁÖ©ÁÖ§ÁÖâÁÖßÁÖúÁÖ¨ÁÖ¶ÁÖåÁÖ•ÁÖûÁÖÜÁÖ®ÁÖñÁà∫ÁâíÁå∑ÁçÖÁåøÁåæÁëØÁëöÁëïÁëüÁëûÁëÅÁêøÁëôÁëõÁëúÁï∂Áï∏ÁòÄÁó∞ÁòÅÁó≤Áó±Áó∫ÁóøÁó¥Áó≥ÁõûÁõüÁùõÁù´Áù¶ÁùûÁù£"],["b840","ÁùπÁù™Áù¨ÁùúÁù•Áù®Áù¢ÁüÆÁ¢éÁ¢∞Á¢óÁ¢òÁ¢åÁ¢âÁ°ºÁ¢ëÁ¢ìÁ°øÁ•∫Á•øÁ¶ÅËê¨Á¶ΩÁ®úÁ®öÁ®†Á®îÁ®üÁ®ûÁ™üÁ™†Á≠∑ÁØÄÁ≠†Á≠ÆÁ≠ßÁ≤±Á≤≥Á≤µÁ∂ìÁµπÁ∂ëÁ∂ÅÁ∂èÁµõÁΩÆÁΩ©ÁΩ™ÁΩ≤Áæ©Áæ®Áæ§ËÅñËÅòËÇÜËÇÑËÖ±ËÖ∞ËÖ∏ËÖ•ËÖÆËÖ≥ËÖ´"],["b8a1","ËÖπËÖ∫ËÖ¶ËàÖËâáËíÇËë∑ËêΩËê±ËëµËë¶Ëë´ËëâËë¨ËëõËêºËêµËë°Ëë£Ëë©Ëë≠ËëÜËôûËôúËôüËõπËúìËúàËúáËúÄËõæËõªËúÇËúÉËúÜËúäË°ôË£üË£îË£ôË£úË£òË£ùË£°Ë£äË£ïË£íË¶úËß£Ë©´Ë©≤Ë©≥Ë©¶Ë©©Ë©∞Ë™áË©ºË©£Ë™†Ë©±Ë™ÖË©≠Ë©¢Ë©ÆË©¨Ë©πË©ªË®æË©®Ë±¢Ë≤äË≤âË≥äË≥áË≥àË≥ÑË≤≤Ë≥ÉË≥ÇË≥ÖË∑°Ë∑üË∑®Ë∑ØË∑≥Ë∑∫Ë∑™Ë∑§Ë∑¶Ë∫≤ËºÉËºâËªæËºä"],["b940","ËæüËæ≤ÈÅãÈÅäÈÅìÈÅÇÈÅîÈÄºÈÅïÈÅêÈÅáÈÅèÈÅéÈÅçÈÅëÈÄæÈÅÅÈÑíÈÑóÈÖ¨ÈÖ™ÈÖ©ÈáâÈà∑ÈâóÈà∏ÈàΩÈâÄÈàæÈâõÈâãÈâ§ÈâëÈà¥ÈââÈâçÈâÖÈàπÈàøÈâöÈñòÈöòÈöîÈöïÈõçÈõãÈõâÈõäÈõ∑ÈõªÈõπÈõ∂ÈùñÈù¥Èù∂È†êÈ†ëÈ†ìÈ†äÈ†íÈ†åÈ£ºÈ£¥"],["b9a1","È£ΩÈ£æÈ¶≥È¶±È¶¥È´°È≥©È∫ÇÈºéÈºìÈº†ÂÉßÂÉÆÂÉ•ÂÉñÂÉ≠ÂÉöÂÉïÂÉèÂÉëÂÉ±ÂÉéÂÉ©ÂÖ¢Âá≥ÂäÉÂäÇÂå±Âé≠ÂóæÂòÄÂòõÂòóÂóΩÂòîÂòÜÂòâÂòçÂòéÂó∑ÂòñÂòüÂòàÂòêÂó∂ÂúòÂúñÂ°µÂ°æÂ¢ÉÂ¢ìÂ¢äÂ°πÂ¢ÖÂ°ΩÂ£ΩÂ§•Â§¢Â§§Â•™Â•©Â´°Â´¶Â´©Â´óÂ´ñÂ´òÂ´£Â≠µÂØûÂØßÂØ°ÂØ•ÂØ¶ÂØ®ÂØ¢ÂØ§ÂØüÂ∞çÂ±¢Â∂ÑÂ∂áÂπõÂπ£ÂπïÂπóÂπîÂªìÂªñÂºäÂΩÜÂΩ∞ÂæπÊÖá"],["ba40","ÊÑøÊÖãÊÖ∑ÊÖ¢ÊÖ£ÊÖüÊÖöÊÖòÊÖµÊà™ÊíáÊëòÊëîÊí§Êë∏ÊëüÊë∫ÊëëÊëßÊê¥Êë≠ÊëªÊï≤Êñ°ÊóóÊóñÊö¢Êö®ÊöùÊ¶úÊ¶®Ê¶ïÊßÅÊ¶ÆÊßìÊßãÊ¶õÊ¶∑Ê¶ªÊ¶´Ê¶¥ÊßêÊßçÊ¶≠ÊßåÊ¶¶ÊßÉÊ¶£Ê≠âÊ≠åÊ∞≥Êº≥ÊºîÊªæÊºìÊª¥Êº©ÊºæÊº†Êº¨ÊºèÊºÇÊº¢"],["baa1","ÊªøÊªØÊºÜÊº±Êº∏Êº≤Êº£ÊºïÊº´ÊºØÊæàÊº™Êª¨ÊºÅÊª≤ÊªåÊª∑ÁÜîÁÜôÁÖΩÁÜäÁÜÑÁÜíÁàæÁäíÁäñÁçÑÁçêÁë§Áë£Áë™Áë∞Áë≠ÁîÑÁñëÁòßÁòçÁòãÁòâÁòìÁõ°Áõ£ÁûÑÁùΩÁùøÁù°Á£ÅÁ¢üÁ¢ßÁ¢≥Á¢©Á¢£Á¶éÁ¶èÁ¶çÁ®ÆÁ®±Á™™Á™©Á´≠Á´ØÁÆ°ÁÆïÁÆãÁ≠µÁÆóÁÆùÁÆîÁÆèÁÆ∏ÁÆáÁÆÑÁ≤πÁ≤ΩÁ≤æÁ∂ªÁ∂∞Á∂úÁ∂ΩÁ∂æÁ∂†Á∑äÁ∂¥Á∂≤Á∂±Á∂∫Á∂¢Á∂øÁ∂µÁ∂∏Á∂≠Á∑íÁ∑áÁ∂¨"],["bb40","ÁΩ∞Áø†Áø°ÁøüËÅûËÅöËÇáËÖêËÜÄËÜèËÜàËÜäËÖøËÜÇËáßËá∫ËàáËàîËàûËâãËìâËíøËìÜËìÑËíôËíûËí≤ËíúËìãËí∏ËìÄËììËíêËíºËìëËìäËúøËúúËúªËú¢Ëú•Ëú¥ËúòËùïËú∑Ëú©Ë£≥Ë§ÇË£¥Ë£πË£∏Ë£ΩË£®Ë§öË£ØË™¶Ë™åË™ûË™£Ë™çË™°Ë™ìË™§"],["bba1","Ë™™Ë™•Ë™®Ë™òË™ëË™öË™ßË±™Ë≤çË≤åË≥ìË≥ëË≥íËµ´Ë∂ôË∂ïË∑ºËºîËºíËºïËºìËæ£ÈÅ†ÈÅòÈÅúÈÅ£ÈÅôÈÅûÈÅ¢ÈÅùÈÅõÈÑôÈÑòÈÑûÈÖµÈÖ∏ÈÖ∑ÈÖ¥Èâ∏ÈäÄÈäÖÈäòÈäñÈâªÈäìÈäúÈä®ÈâºÈäëÈñ°Èñ®Èñ©Èñ£Èñ•Èñ§ÈöôÈöúÈöõÈõåÈõíÈúÄÈùºÈûÖÈü∂È†óÈ†òÈ¢ØÈ¢±È§ÉÈ§ÖÈ§åÈ§âÈßÅÈ™ØÈ™∞È´¶È≠ÅÈ≠ÇÈ≥¥È≥∂È≥≥È∫ºÈºªÈΩäÂÑÑÂÑÄÂÉªÂÉµÂÉπÂÑÇÂÑàÂÑâÂÑÖÂáú"],["bc40","ÂäáÂäàÂäâÂäçÂääÂã∞Âé≤ÂòÆÂòªÂòπÂò≤ÂòøÂò¥Âò©ÂôìÂôéÂôóÂô¥Âò∂ÂòØÂò∞Â¢ÄÂ¢üÂ¢ûÂ¢≥Â¢úÂ¢ÆÂ¢©Â¢¶Â•≠Â¨âÂ´ªÂ¨ãÂ´µÂ¨åÂ¨àÂØÆÂØ¨ÂØ©ÂØ´Â±§Â±•Â∂ùÂ∂îÂπ¢ÂπüÂπ°Âª¢ÂªöÂªüÂªùÂª£Âª†ÂΩàÂΩ±Âæ∑ÂæµÊÖ∂ÊÖßÊÖÆÊÖùÊÖïÊÜÇ"],["bca1","ÊÖºÊÖ∞ÊÖ´ÊÖæÊÜßÊÜêÊÜ´ÊÜéÊÜ¨ÊÜöÊÜ§ÊÜîÊÜÆÊàÆÊë©ÊëØÊëπÊíûÊí≤ÊíàÊíêÊí∞Êí•ÊíìÊíïÊí©ÊííÊíÆÊí≠Êí´ÊíöÊí¨ÊíôÊí¢Êí≥ÊïµÊï∑Êï∏ÊöÆÊö´Êö¥Êö±Ê®£Ê®üÊß®Ê®ÅÊ®ûÊ®ôÊßΩÊ®°Ê®ìÊ®äÊß≥Ê®ÇÊ®ÖÊß≠Ê®ëÊ≠êÊ≠éÊÆ§ÊØÖÊØÜÊºøÊΩºÊæÑÊΩëÊΩ¶ÊΩîÊæÜÊΩ≠ÊΩõÊΩ∏ÊΩÆÊæéÊΩ∫ÊΩ∞ÊΩ§ÊæóÊΩòÊªïÊΩØÊΩ†ÊΩüÁÜüÁÜ¨ÁÜ±ÁÜ®ÁâñÁäõÁçéÁçóÁë©ÁíãÁíÉ"],["bd40","ÁëæÁíÄÁïøÁò†Áò©ÁòüÁò§Áò¶Áò°Áò¢ÁööÁö∫Áõ§ÁûéÁûáÁûåÁûëÁûãÁ£ãÁ£ÖÁ¢∫Á£äÁ¢æÁ£ïÁ¢ºÁ£êÁ®øÁ®ºÁ©ÄÁ®ΩÁ®∑Á®ªÁ™ØÁ™ÆÁÆ≠ÁÆ±ÁØÑÁÆ¥ÁØÜÁØáÁØÅÁÆ†ÁØåÁ≥äÁ∑†Á∑¥Á∑ØÁ∑ªÁ∑òÁ∑¨Á∑ùÁ∑®Á∑£Á∑öÁ∑ûÁ∑©Á∂ûÁ∑ôÁ∑≤Á∑πÁΩµÁΩ∑ÁæØ"],["bda1","Áø©ËÄ¶ËÜõËÜúËÜùËÜ†ËÜöËÜòËîóËîΩËîöËìÆËî¨Ëî≠ËîìËîëËî£Ëî°ËîîËì¨Ëî•ËìøËîÜËûÇËù¥Ëù∂Ëù†Ëù¶Ëù∏Ëù®ËùôËùóËùåËùìË°õË°ùË§êË§áË§íË§ìË§ïË§äË™ºË´íË´áË´ÑË™ïË´ãË´∏Ë™≤Ë´âË´ÇË™øË™∞Ë´ñË´çË™∂Ë™πË´õË±åË±éË±¨Ë≥†Ë≥ûË≥¶Ë≥§Ë≥¨Ë≥≠Ë≥¢Ë≥£Ë≥úË≥™Ë≥°Ëµ≠Ë∂üË∂£Ë∏´Ë∏êË∏ùË∏¢Ë∏èË∏©Ë∏üË∏°Ë∏ûË∫∫ËºùËºõËºüËº©Ëº¶Ëº™ËºúËºû"],["be40","Ëº•ÈÅ©ÈÅÆÈÅ®ÈÅ≠ÈÅ∑ÈÑ∞ÈÑ≠ÈÑßÈÑ±ÈÜáÈÜâÈÜãÈÜÉÈãÖÈäªÈä∑Èã™Èä¨Èã§ÈãÅÈä≥ÈäºÈãíÈãáÈã∞Èä≤Èñ≠Èñ±ÈúÑÈúÜÈúáÈúâÈù†ÈûçÈûãÈûèÈ†°È†´È†úÈ¢≥È§äÈ§ìÈ§íÈ§òÈßùÈßêÈßüÈßõÈßëÈßïÈßíÈßôÈ™∑È´ÆÈ´ØÈ¨ßÈ≠ÖÈ≠ÑÈ≠∑È≠ØÈ¥ÜÈ¥â"],["bea1","È¥ÉÈ∫©È∫æÈªéÂ¢®ÈΩíÂÑíÂÑòÂÑîÂÑêÂÑïÂÜÄÂÜ™ÂáùÂäëÂäìÂã≥ÂôôÂô´ÂôπÂô©Âô§Âô∏Âô™Âô®Âô•Âô±ÂôØÂô¨Âô¢Âô∂Â£ÅÂ¢æÂ£áÂ£ÖÂ•ÆÂ¨ùÂ¨¥Â≠∏ÂØ∞Â∞éÂΩäÊÜ≤ÊÜëÊÜ©ÊÜäÊáçÊÜ∂ÊÜæÊáäÊáàÊà∞ÊìÖÊìÅÊìãÊíªÊíºÊìöÊìÑÊìáÊìÇÊìçÊíøÊìíÊìîÊíæÊï¥ÊõÜÊõâÊöπÊõÑÊõáÊö∏Ê®ΩÊ®∏Ê®∫Ê©ôÊ©´Ê©òÊ®πÊ©ÑÊ©¢Ê©°Ê©ãÊ©áÊ®µÊ©üÊ©àÊ≠ôÊ≠∑Ê∞ÖÊøÇÊæ±Êæ°"],["bf40","ÊøÉÊæ§ÊøÅÊæßÊæ≥ÊøÄÊæπÊæ∂Êæ¶Êæ†Êæ¥ÁÜæÁáâÁáêÁáíÁáàÁáïÁÜπÁáéÁáôÁáúÁáÉÁáÑÁç®ÁíúÁí£ÁíòÁíüÁíûÁì¢ÁîåÁîçÁò¥Áò∏Áò∫ÁõßÁõ•Áû†ÁûûÁûüÁû•Á£®Á£öÁ£¨Á£ßÁ¶¶Á©çÁ©éÁ©ÜÁ©åÁ©ãÁ™∫ÁØôÁ∞ëÁØâÁØ§ÁØõÁØ°ÁØ©ÁØ¶Á≥ïÁ≥ñÁ∏ä"],["bfa1","Á∏ëÁ∏àÁ∏õÁ∏£Á∏ûÁ∏ùÁ∏âÁ∏êÁΩπÁæ≤Áø∞Áø±ÁøÆËÄ®ËÜ≥ËÜ©ËÜ®ËáªËààËâòËâôËïäËïôËïàËï®Ëï©ËïÉËïâËï≠Ëï™ËïûËûÉËûüËûûËû¢ËûçË°°Ë§™Ë§≤Ë§•Ë§´Ë§°Ë¶™Ë¶¶Ë´¶Ë´∫Ë´´Ë´±Ë¨ÄË´úË´ßË´ÆË´æË¨ÅË¨ÇË´∑Ë´≠Ë´≥Ë´∂Ë´ºË±´Ë±≠Ë≤ìË≥¥ËπÑË∏±Ë∏¥ËπÇË∏πË∏µËºªËºØËº∏Ëº≥Ëæ®Ëæ¶ÈÅµÈÅ¥ÈÅ∏ÈÅ≤ÈÅºÈÅ∫ÈÑ¥ÈÜíÈå†Èå∂Èã∏Èå≥ÈåØÈå¢ÈãºÈå´ÈåÑÈåö"],["c040","ÈåêÈå¶Èå°ÈåïÈåÆÈåôÈñªÈößÈö®Èö™ÈõïÈúéÈúëÈúñÈúçÈúìÈúèÈùõÈùúÈù¶ÈûòÈ†∞È†∏È†ªÈ†∑È†≠È†πÈ†§È§êÈ§®È§ûÈ§õÈ§°È§öÈß≠Èß¢Èß±È™∏È™ºÈ´ªÈ´≠È¨®ÈÆëÈ¥ïÈ¥£È¥¶È¥®È¥íÈ¥õÈªòÈªîÈæçÈæúÂÑ™ÂÑüÂÑ°ÂÑ≤ÂãµÂöéÂöÄÂöêÂöÖÂöá"],["c0a1","ÂöèÂ£ïÂ£ìÂ£ëÂ£éÂ¨∞Â¨™Â¨§Â≠∫Â∞∑Â±®Â∂ºÂ∂∫Â∂ΩÂ∂∏Âπ´ÂΩåÂæΩÊáâÊáÇÊááÊá¶ÊáãÊà≤Êà¥ÊìéÊìäÊìòÊì†Êì∞Êì¶Êì¨Êì±Êì¢Êì≠ÊñÇÊñÉÊõôÊõñÊ™ÄÊ™îÊ™ÑÊ™¢Ê™úÊ´õÊ™£Ê©æÊ™óÊ™êÊ™†Ê≠úÊÆÆÊØöÊ∞àÊøòÊø±ÊøüÊø†ÊøõÊø§Êø´ÊøØÊæÄÊø¨Êø°Êø©ÊøïÊøÆÊø∞ÁáßÁáüÁáÆÁá¶Áá•Áá≠Áá¨Áá¥Áá†ÁàµÁâÜÁç∞Áç≤Áí©Áí∞Áí¶Áí®ÁôÜÁôÇÁôåÁõ™Áû≥Áû™Áû∞Áû¨"],["c140","ÁûßÁû≠ÁüØÁ£∑Á£∫Á£¥Á£ØÁ§ÅÁ¶ßÁ¶™Á©óÁ™øÁ∞áÁ∞çÁØæÁØ∑Á∞åÁØ†Á≥†Á≥úÁ≥ûÁ≥¢Á≥üÁ≥ôÁ≥ùÁ∏ÆÁ∏æÁπÜÁ∏∑Á∏≤ÁπÉÁ∏´Á∏ΩÁ∏±ÁπÖÁπÅÁ∏¥Á∏πÁπàÁ∏µÁ∏øÁ∏ØÁΩÑÁø≥ÁøºËÅ±ËÅ≤ËÅ∞ËÅØËÅ≥ËáÜËáÉËÜ∫ËáÇËáÄËÜøËÜΩËáâËÜæËá®ËàâËâ±Ëñ™"],["c1a1","ËñÑËïæËñúËñëËñîËñØËñõËñáËñ®ËñäËôßËüÄËüëËû≥ËüíËüÜËû´ËûªËû∫ËüàËüãË§ªË§∂Ë•ÑË§∏Ë§ΩË¶¨Ë¨éË¨óË¨ôË¨õË¨äË¨†Ë¨ùË¨ÑË¨êË±ÅË∞øË±≥Ë≥∫Ë≥ΩË≥ºË≥∏Ë≥ªË∂®ËπâËπãËπàËπäËΩÑËºæËΩÇËΩÖËºøÈÅøÈÅΩÈÇÑÈÇÅÈÇÇÈÇÄÈÑπÈÜ£ÈÜûÈÜúÈççÈéÇÈå®ÈçµÈçäÈç•ÈçãÈåòÈçæÈç¨ÈçõÈç∞ÈçöÈçîÈóäÈóãÈóåÈóàÈóÜÈö±Èö∏ÈõñÈúúÈúûÈû†ÈüìÈ°ÜÈ¢∂È§µÈ®Å"],["c240","ÈßøÈÆÆÈÆ´ÈÆ™ÈÆ≠È¥ªÈ¥øÈ∫ãÈªèÈªûÈªúÈªùÈªõÈºæÈΩãÂè¢ÂöïÂöÆÂ£ôÂ£òÂ¨∏ÂΩùÊá£Êà≥Êì¥Êì≤ÊìæÊîÜÊì∫ÊìªÊì∑Êñ∑ÊõúÊú¶Ê™≥Ê™¨Ê´ÉÊ™ªÊ™∏Ê´ÇÊ™ÆÊ™ØÊ≠üÊ≠∏ÊÆØÁÄâÁÄãÊøæÁÄÜÊø∫ÁÄëÁÄèÁáªÁáºÁáæÁá∏Áç∑ÁçµÁíßÁíøÁîïÁôñÁôò"],["c2a1","ÁôíÁûΩÁûøÁûªÁûºÁ§éÁ¶ÆÁ©°Á©¢Á©†Á´ÑÁ´ÖÁ∞´Á∞ßÁ∞™Á∞ûÁ∞£Á∞°Á≥ßÁπîÁπïÁπûÁπöÁπ°ÁπíÁπôÁΩàÁøπÁøªËÅ∑ËÅ∂ËáçËáèËàäËóèËñ©ËóçËóêËóâËñ∞Ëñ∫ËñπËñ¶ËüØËü¨Ëü≤Ëü†Ë¶ÜË¶≤Ëß¥Ë¨®Ë¨πË¨¨Ë¨´Ë±êË¥ÖËπôËπ£Ëπ¶Ëπ§ËπüËπïËªÄËΩâËΩçÈÇáÈÇÉÈÇàÈÜ´ÈÜ¨ÈáêÈéîÈéäÈéñÈé¢Èé≥ÈéÆÈé¨Èé∞ÈéòÈéöÈéóÈóîÈóñÈóêÈóïÈõ¢ÈõúÈõôÈõõÈõûÈú§Èû£Èû¶"],["c340","Èû≠ÈüπÈ°çÈ°èÈ°åÈ°éÈ°ìÈ¢∫È§æÈ§øÈ§ΩÈ§ÆÈ¶•È®éÈ´ÅÈ¨ÉÈ¨ÜÈ≠èÈ≠éÈ≠çÈØäÈØâÈØΩÈØàÈØÄÈµëÈµùÈµ†Èª†ÈºïÈº¨ÂÑ≥Âö•Â£ûÂ£üÂ£¢ÂØµÈæêÂª¨Êá≤Êá∑Êá∂ÊáµÊîÄÊîèÊõ†ÊõùÊ´•Ê´ùÊ´öÊ´ìÁÄõÁÄüÁÄ®ÁÄöÁÄùÁÄïÁÄòÁàÜÁàçÁâòÁä¢Áç∏"],["c3a1","Áç∫ÁíΩÁìäÁì£ÁñáÁñÜÁôüÁô°ÁüáÁ§ôÁ¶±Á©´Á©©Á∞æÁ∞øÁ∞∏Á∞ΩÁ∞∑Á±ÄÁπ´Áπ≠ÁππÁπ©Áπ™ÁæÖÁπ≥Áæ∂ÁæπÁæ∏ËáòËó©ËóùËó™ËóïËó§Ëó•Ëó∑ËüªË†ÖË†çËüπËüæË•†Ë•üË•ñË•ûË≠ÅË≠úË≠òË≠âË≠öË≠éË≠èË≠ÜË≠ôË¥àË¥äËπºËπ≤Ë∫áËπ∂Ëπ¨Ëπ∫Ëπ¥ËΩîËΩéËæ≠ÈÇäÈÇãÈÜ±ÈÜÆÈè°ÈèëÈèüÈèÉÈèàÈèúÈèùÈèñÈè¢ÈèçÈèòÈè§ÈèóÈè®ÈóúÈö¥Èõ£Èú™ÈúßÈù°ÈüúÈüªÈ°û"],["c440","È°òÈ°õÈ¢ºÈ•ÖÈ•âÈ®ñÈ®ôÈ¨çÈØ®ÈØßÈØñÈØõÈ∂âÈµ°Èµ≤Èµ™Èµ¨È∫íÈ∫óÈ∫ìÈ∫¥Âã∏Âö®Âö∑Âö∂Âö¥ÂöºÂ£§Â≠ÄÂ≠ÉÂ≠ΩÂØ∂Â∑âÊá∏Êá∫ÊîòÊîîÊîôÊõ¶ÊúßÊ´¨ÁÄæÁÄ∞ÁÄ≤ÁàêÁçªÁìèÁô¢Áô•Á§¶Á§™Á§¨Á§´Á´áÁ´∂Á±åÁ±ÉÁ±çÁ≥ØÁ≥∞ËæÆÁπΩÁπº"],["c4a1","Á∫ÇÁΩåËÄÄËáöËâ¶ËóªËóπËòëËó∫ËòÜËòãËòáËòäË†îË†ïË•§Ë¶∫Ëß∏Ë≠∞Ë≠¨Ë≠¶Ë≠ØË≠üË≠´Ë¥èË¥çË∫âË∫ÅË∫ÖË∫ÇÈÜ¥ÈáãÈêòÈêÉÈèΩÈó°Èú∞È£ÑÈ•íÈ•ëÈ¶®È®´È®∞È®∑È®µÈ∞ìÈ∞çÈππÈ∫µÈª®ÈºØÈΩüÈΩ£ÈΩ°ÂÑ∑ÂÑ∏ÂõÅÂõÄÂõÇÂ§îÂ±¨Â∑çÊáºÊáæÊîùÊîúÊñïÊõ©Ê´ªÊ¨ÑÊ´∫ÊÆ≤ÁÅåÁàõÁäßÁìñÁìîÁô©ÁüìÁ±êÁ∫èÁ∫åÁæºËòóËò≠ËòöË†£Ë†¢Ë†°Ë†üË•™Ë•¨Ë¶ΩË≠¥"],["c540","Ë≠∑Ë≠ΩË¥ìË∫äË∫çË∫ãËΩüËæØÈÜ∫ÈêÆÈê≥ÈêµÈê∫Èê∏Èê≤Èê´Èó¢Èú∏ÈúπÈú≤ÈüøÈ°ßÈ°•È•óÈ©ÖÈ©ÉÈ©ÄÈ®æÈ´èÈ≠îÈ≠ëÈ∞≠È∞•È∂ØÈ∂¥È∑ÇÈ∂∏È∫ùÈªØÈºôÈΩúÈΩ¶ÈΩßÂÑºÂÑªÂõàÂõäÂõâÂ≠øÂ∑îÂ∑íÂΩéÊáøÊî§Ê¨äÊ≠°ÁÅëÁÅòÁéÄÁì§ÁñäÁôÆÁô¨"],["c5a1","Á¶≥Á±†Á±üËÅæËÅΩËáüË•≤Ë•ØËßºËÆÄË¥ñË¥óË∫ëË∫ìËΩ°ÈÖàÈëÑÈëëÈëíÈúΩÈúæÈüÉÈüÅÈ°´È•ïÈ©ïÈ©çÈ´íÈ¨öÈ±âÈ∞±È∞æÈ∞ªÈ∑ìÈ∑óÈº¥ÈΩ¨ÈΩ™ÈæîÂõåÂ∑ñÊàÄÊî£Êî´Êî™Êõ¨Ê¨êÁìöÁ´äÁ±§Á±£Á±•Á∫ìÁ∫ñÁ∫îËá¢Ëò∏ËòøË†±ËÆäÈÇêÈÇèÈë£Èë†Èë§Èù®È°ØÈ•úÈ©öÈ©õÈ©óÈ´ìÈ´îÈ´ëÈ±îÈ±óÈ±ñÈ∑•È∫üÈª¥ÂõëÂ£©Êî¨ÁÅûÁô±Áô≤ÁüóÁΩêÁæàË†∂Ë†πË°¢ËÆìËÆí"],["c640","ËÆñËâ∑Ë¥õÈáÄÈë™ÈùÇÈùàÈùÑÈüÜÈ°∞È©üÈ¨¢È≠òÈ±üÈ∑πÈ∑∫ÈπºÈπΩÈºáÈΩ∑ÈΩ≤Âª≥Ê¨ñÁÅ£Á±¨Á±ÆË†ªËßÄË∫°ÈáÅÈë≤Èë∞È°±È•ûÈ´ñÈ¨£ÈªåÁÅ§ÁüöËÆöÈë∑ÈüâÈ©¢È©•Á∫úËÆúË∫™ÈáÖÈëΩÈëæÈëºÈ±∑È±∏Èª∑Ë±îÈëøÈ∏öÁà®È©™È¨±È∏õÈ∏ûÁ±≤"],["c940","‰πÇ‰πúÂáµÂåöÂéÇ‰∏á‰∏å‰πá‰∫çÂõóÔ®åÂ±ÆÂΩ≥‰∏èÂÜá‰∏é‰∏Æ‰∫ì‰ªÇ‰ªâ‰ªàÂÜòÂãºÂç¨ÂéπÂú†Â§ÉÂ§¨Â∞êÂ∑øÊó°ÊÆ≥ÊØåÊ∞îÁàø‰∏±‰∏º‰ª®‰ªú‰ª©‰ª°‰ªù‰ªöÂàåÂåúÂçåÂú¢Âú£Â§óÂ§ØÂÆÅÂÆÑÂ∞íÂ∞ªÂ±¥Â±≥Â∏ÑÂ∫ÄÂ∫ÇÂøâÊàâÊâêÊ∞ï"],["c9a1","Ê∞∂Ê±ÉÊ∞øÊ∞ªÁäÆÁä∞ÁéäÁ¶∏ËÇäÈòû‰ºé‰ºò‰º¨‰ªµ‰ºî‰ª±‰ºÄ‰ª∑‰ºà‰ºù‰ºÇ‰ºÖ‰º¢‰ºì‰ºÑ‰ª¥‰ºíÂÜ±ÂàìÂàâÂàêÂä¶Âå¢ÂåüÂççÂéäÂêáÂõ°ÂõüÂúÆÂú™Âú¥Â§ºÂ¶ÄÂ•ºÂ¶ÖÂ•ªÂ•æÂ•∑Â•øÂ≠ñÂ∞ïÂ∞•Â±ºÂ±∫Â±ªÂ±æÂ∑üÂπµÂ∫ÑÂºÇÂºöÂΩ¥ÂøïÂøîÂøèÊâúÊâûÊâ§Êâ°Êâ¶Êâ¢ÊâôÊâ†ÊâöÊâ•ÊóØÊóÆÊúæÊúπÊú∏ÊúªÊú∫ÊúøÊúºÊú≥Ê∞òÊ±ÜÊ±íÊ±úÊ±èÊ±äÊ±îÊ±ã"],["ca40","Ê±åÁÅ±ÁâûÁä¥ÁäµÁééÁî™ÁôøÁ©µÁΩëËâ∏ËâºËäÄËâΩËâøËôçË•æÈÇôÈÇóÈÇòÈÇõÈÇîÈò¢Èò§Èò†Èò£‰Ωñ‰ºª‰Ω¢‰Ωâ‰Ωì‰Ω§‰ºæ‰Ωß‰Ωí‰Ωü‰ΩÅ‰Ωò‰º≠‰º≥‰ºø‰Ω°ÂÜèÂÜπÂàúÂàûÂà°Âä≠ÂäÆÂåâÂç£Âç≤ÂééÂéèÂê∞Âê∑Âê™ÂëîÂëÖÂêôÂêúÂê•Âêò"],["caa1","ÂêΩÂëèÂëÅÂê®Âê§ÂëáÂõÆÂõßÂõ•ÂùÅÂùÖÂùåÂùâÂùãÂùíÂ§ÜÂ•ÄÂ¶¶Â¶òÂ¶†Â¶óÂ¶éÂ¶¢Â¶êÂ¶èÂ¶ßÂ¶°ÂÆéÂÆíÂ∞®Â∞™Â≤çÂ≤èÂ≤àÂ≤ãÂ≤âÂ≤íÂ≤äÂ≤ÜÂ≤ìÂ≤ïÂ∑†Â∏äÂ∏éÂ∫ãÂ∫âÂ∫åÂ∫àÂ∫çÂºÖÂºùÂΩ∏ÂΩ∂ÂøíÂøëÂøêÂø≠Âø®ÂøÆÂø≥Âø°Âø§Âø£Âø∫ÂøØÂø∑ÂøªÊÄÄÂø¥Êà∫ÊäÉÊäåÊäéÊäèÊäîÊäáÊâ±ÊâªÊâ∫Êâ∞ÊäÅÊäàÊâ∑ÊâΩÊâ≤Êâ¥Êî∑Êó∞Êó¥Êó≥Êó≤ÊóµÊùÖÊùá"],["cb40","ÊùôÊùïÊùåÊùàÊùùÊùçÊùöÊùãÊØêÊ∞ôÊ∞öÊ±∏Ê±ßÊ±´Ê≤ÑÊ≤ãÊ≤èÊ±±Ê±ØÊ±©Ê≤öÊ±≠Ê≤áÊ≤ïÊ≤úÊ±¶Ê±≥Ê±•Ê±ªÊ≤éÁÅ¥ÁÅ∫Áâ£ÁäøÁäΩÁãÉÁãÜÁãÅÁä∫ÁãÖÁéïÁéóÁéìÁéîÁéíÁî∫ÁîπÁñîÁñïÁöÅÁ§ΩËÄ¥ËÇïËÇôËÇêËÇíËÇúËäêËäèËäÖËäéËäëËäì"],["cba1","ËääËäÉËäÑË±∏ËøâËæøÈÇüÈÇ°ÈÇ•ÈÇûÈÇßÈÇ†Èò∞Èò®ÈòØÈò≠‰∏≥‰æò‰Ωº‰æÖ‰ΩΩ‰æÄ‰æá‰Ω∂‰Ω¥‰æâ‰æÑ‰Ω∑‰Ωå‰æó‰Ω™‰æö‰Ωπ‰æÅ‰Ω∏‰æê‰æú‰æî‰æû‰æí‰æÇ‰æï‰Ω´‰ΩÆÂÜûÂÜºÂÜæÂàµÂà≤Âà≥ÂâÜÂà±ÂäºÂåäÂåãÂåºÂéíÂéîÂíáÂëøÂíÅÂíëÂíÇÂíàÂë´Âë∫ÂëæÂë•Âë¨Âë¥Âë¶ÂíçÂëØÂë°Âë†ÂíòÂë£ÂëßÂë§Âõ∑ÂõπÂùØÂù≤Âù≠Âù´Âù±Âù∞Âù∂ÂûÄÂùµÂùªÂù≥Âù¥Âù¢"],["cc40","Âù®ÂùΩÂ§åÂ•ÖÂ¶µÂ¶∫ÂßèÂßéÂ¶≤ÂßåÂßÅÂ¶∂Â¶ºÂßÉÂßñÂ¶±Â¶ΩÂßÄÂßàÂ¶¥ÂßáÂ≠¢Â≠•ÂÆìÂÆïÂ±ÑÂ±áÂ≤ÆÂ≤§Â≤†Â≤µÂ≤ØÂ≤®Â≤¨Â≤üÂ≤£Â≤≠Â≤¢Â≤™Â≤ßÂ≤ùÂ≤•Â≤∂Â≤∞Â≤¶Â∏óÂ∏îÂ∏ôÂº®Âº¢Âº£Âº§ÂΩîÂæÇÂΩæÂΩΩÂøûÂø•ÊÄ≠ÊÄ¶ÊÄôÊÄ≤ÊÄã"],["cca1","ÊÄ¥ÊÄäÊÄóÊÄ≥ÊÄöÊÄûÊÄ¨ÊÄ¢ÊÄçÊÄêÊÄÆÊÄìÊÄëÊÄåÊÄâÊÄúÊàîÊàΩÊä≠Êä¥ÊãëÊäæÊä™Êä∂ÊãäÊäÆÊä≥ÊäØÊäªÊä©Êä∞Êä∏ÊîΩÊñ®ÊñªÊòâÊóºÊòÑÊòíÊòàÊóªÊòÉÊòãÊòçÊòÖÊóΩÊòëÊòêÊõ∂ÊúäÊûÖÊù¨ÊûéÊûíÊù∂ÊùªÊûòÊûÜÊûÑÊù¥ÊûçÊûåÊù∫ÊûüÊûëÊûôÊûÉÊùΩÊûÅÊù∏ÊùπÊûîÊ¨•ÊÆÄÊ≠æÊØûÊ∞ùÊ≤ìÊ≥¨Ê≥´Ê≥ÆÊ≥ôÊ≤∂Ê≥îÊ≤≠Ê≥ßÊ≤∑Ê≥êÊ≥ÇÊ≤∫Ê≥ÉÊ≥ÜÊ≥≠Ê≥≤"],["cd40","Ê≥íÊ≥ùÊ≤¥Ê≤äÊ≤ùÊ≤ÄÊ≥ûÊ≥ÄÊ¥∞Ê≥çÊ≥áÊ≤∞Ê≥πÊ≥èÊ≥©Ê≥ëÁÇîÁÇòÁÇÖÁÇìÁÇÜÁÇÑÁÇëÁÇñÁÇÇÁÇöÁÇÉÁâ™ÁãñÁããÁãòÁãâÁãúÁãíÁãîÁãöÁãåÁãëÁé§Áé°Áé≠Áé¶Áé¢Áé†Áé¨ÁéùÁìùÁì®ÁîøÁïÄÁîæÁñåÁñòÁöØÁõ≥Áõ±Áõ∞ÁõµÁü∏ÁüºÁüπÁüªÁü∫"],["cda1","Áü∑Á•ÇÁ§øÁßÖÁ©∏Á©ªÁ´ªÁ±µÁ≥ΩËÄµËÇèËÇÆËÇ£ËÇ∏ËÇµËÇ≠Ëà†Ëä†ËãÄËä´ËäöËäòËäõËäµËäßËäÆËäºËäûËä∫Ëä¥Ëä®Ëä°Ëä©ËãÇËä§ËãÉËä∂Ëä¢Ëô∞ËôØËô≠ËôÆË±ñËøíËøãËøìËøçËøñËøïËøóÈÇ≤ÈÇ¥ÈÇØÈÇ≥ÈÇ∞ÈòπÈòΩÈòºÈò∫ÈôÉ‰øç‰øÖ‰øì‰æ≤‰øâ‰øã‰øÅ‰øî‰øú‰øô‰æª‰æ≥‰øõ‰øá‰øñ‰æ∫‰øÄ‰æπ‰ø¨ÂâÑÂââÂãÄÂãÇÂåΩÂçºÂéóÂéñÂéôÂéòÂí∫Âí°Âí≠Âí•Âìè"],["ce40","ÂìÉËåçÂí∑ÂíÆÂìñÂí∂ÂìÖÂìÜÂí†Âë∞ÂíºÂí¢ÂíæÂë≤ÂìûÂí∞ÂûµÂûûÂûüÂû§ÂûåÂûóÂûùÂûõÂûîÂûòÂûèÂûôÂû•ÂûöÂûïÂ£¥Â§çÂ•ìÂß°ÂßûÂßÆÂ®ÄÂß±ÂßùÂß∫ÂßΩÂßºÂß∂Âß§Âß≤Âß∑ÂßõÂß©Âß≥ÂßµÂß†ÂßæÂß¥Âß≠ÂÆ®Â±åÂ≥êÂ≥òÂ≥åÂ≥óÂ≥ãÂ≥õ"],["cea1","Â≥ûÂ≥öÂ≥âÂ≥áÂ≥äÂ≥ñÂ≥ìÂ≥îÂ≥èÂ≥àÂ≥ÜÂ≥éÂ≥üÂ≥∏Â∑πÂ∏°Â∏¢Â∏£Â∏†Â∏§Â∫∞Â∫§Â∫¢Â∫õÂ∫£Â∫•ÂºáÂºÆÂΩñÂæÜÊÄ∑ÊÄπÊÅîÊÅ≤ÊÅûÊÅÖÊÅìÊÅáÊÅâÊÅõÊÅåÊÅÄÊÅÇÊÅüÊÄ§ÊÅÑÊÅòÊÅ¶ÊÅÆÊâÇÊâÉÊãèÊåçÊåãÊãµÊåéÊåÉÊã´ÊãπÊåèÊååÊã∏Êã∂ÊåÄÊåìÊåîÊã∫ÊåïÊãªÊã∞ÊïÅÊïÉÊñ™ÊñøÊò∂Êò°Êò≤ÊòµÊòúÊò¶Êò¢Êò≥Êò´Êò∫ÊòùÊò¥ÊòπÊòÆÊúèÊúêÊüÅÊü≤ÊüàÊû∫"],["cf40","ÊüúÊûªÊü∏ÊüòÊüÄÊû∑ÊüÖÊü´Êü§ÊüüÊûµÊüçÊû≥Êü∑Êü∂ÊüÆÊü£ÊüÇÊûπÊüéÊüßÊü∞Êû≤ÊüºÊüÜÊü≠ÊüåÊûÆÊü¶ÊüõÊü∫ÊüâÊüäÊüÉÊü™ÊüãÊ¨®ÊÆÇÊÆÑÊÆ∂ÊØñÊØòÊØ†Ê∞†Ê∞°Ê¥®Ê¥¥Ê¥≠Ê¥üÊ¥ºÊ¥øÊ¥íÊ¥äÊ≥öÊ¥≥Ê¥ÑÊ¥ôÊ¥∫Ê¥öÊ¥ëÊ¥ÄÊ¥ùÊµÇ"],["cfa1","Ê¥ÅÊ¥òÊ¥∑Ê¥ÉÊ¥èÊµÄÊ¥áÊ¥†Ê¥¨Ê¥àÊ¥¢Ê¥âÊ¥êÁÇ∑ÁÇüÁÇæÁÇ±ÁÇ∞ÁÇ°ÁÇ¥ÁÇµÁÇ©ÁâÅÁââÁâäÁâ¨Áâ∞Áâ≥ÁâÆÁãäÁã§Áã®Áã´ÁãüÁã™Áã¶Áã£ÁéÖÁèåÁèÇÁèàÁèÖÁéπÁé∂ÁéµÁé¥Áè´ÁéøÁèáÁéæÁèÉÁèÜÁé∏ÁèãÁì¨ÁìÆÁîÆÁïáÁïàÁñßÁñ™ÁôπÁõÑÁúàÁúÉÁúÑÁúÖÁúäÁõ∑ÁõªÁõ∫ÁüßÁü®Á†ÜÁ†ëÁ†íÁ†ÖÁ†êÁ†èÁ†éÁ†âÁ†ÉÁ†ìÁ•äÁ•åÁ•ãÁ•ÖÁ•ÑÁßïÁßçÁßèÁßñÁßéÁ™Ä"],["d040","Á©æÁ´ëÁ¨ÄÁ¨ÅÁ±∫Á±∏Á±πÁ±øÁ≤ÄÁ≤ÅÁ¥ÉÁ¥àÁ¥ÅÁΩòÁæëÁæçÁææËÄáËÄéËÄèËÄîËÄ∑ËÉòËÉáËÉ†ËÉëËÉàËÉÇËÉêËÉÖËÉ£ËÉôËÉúËÉäËÉïËÉâËÉèËÉóËÉ¶ËÉçËáøËà°ËäîËãôËãæËãπËåáËã®ËåÄËãïËå∫Ëã´ËãñËã¥Ëã¨Ëã°Ëã≤ËãµËååËãªËã∂Ëã∞Ëã™"],["d0a1","Ëã§Ëã†Ëã∫Ëã≥Ëã≠Ëô∑Ëô¥ËôºËô≥Ë°ÅË°éË°ßË°™Ë°©ËßìË®ÑË®áËµ≤Ëø£Ëø°ËøÆËø†ÈÉ±ÈÇΩÈÇøÈÉïÈÉÖÈÇæÈÉáÈÉãÈÉàÈáîÈáìÈôîÈôèÈôëÈôìÈôäÈôéÂÄûÂÄÖÂÄáÂÄìÂÄ¢ÂÄ∞ÂÄõ‰øµ‰ø¥ÂÄ≥ÂÄ∑ÂÄ¨‰ø∂‰ø∑ÂÄóÂÄúÂÄ†ÂÄßÂÄµÂÄØÂÄ±ÂÄéÂÖöÂÜîÂÜìÂáäÂáÑÂáÖÂáàÂáéÂâ°ÂâöÂâíÂâûÂâüÂâïÂâ¢ÂãçÂåéÂéûÂî¶Âì¢ÂîóÂîíÂìßÂì≥Âì§ÂîöÂìøÂîÑÂîàÂì´ÂîëÂîÖÂì±"],["d140","ÂîäÂìªÂì∑Âì∏Âì†ÂîéÂîÉÂîãÂúÅÂúÇÂüåÂ†≤ÂüïÂüíÂû∫ÂüÜÂûΩÂûºÂû∏Âû∂ÂûøÂüáÂüêÂûπÂüÅÂ§éÂ•äÂ®ôÂ®ñÂ®≠Â®ÆÂ®ïÂ®èÂ®óÂ®äÂ®ûÂ®≥Â≠¨ÂÆßÂÆ≠ÂÆ¨Â∞ÉÂ±ñÂ±îÂ≥¨Â≥øÂ≥ÆÂ≥±Â≥∑Â¥ÄÂ≥πÂ∏©Â∏®Â∫®Â∫ÆÂ∫™Â∫¨Âº≥Âº∞ÂΩßÊÅùÊÅöÊÅß"],["d1a1","ÊÅÅÊÇ¢ÊÇàÊÇÄÊÇíÊÇÅÊÇùÊÇÉÊÇïÊÇõÊÇóÊÇáÊÇúÊÇéÊàôÊâÜÊã≤ÊåêÊçñÊå¨ÊçÑÊçÖÊå∂ÊçÉÊè§ÊåπÊçãÊçäÊåºÊå©ÊçÅÊå¥ÊçòÊçîÊçôÊå≠ÊçáÊå≥ÊçöÊçëÊå∏ÊçóÊçÄÊçàÊïäÊïÜÊóÜÊóÉÊóÑÊóÇÊôäÊôüÊôáÊôëÊúíÊúìÊ†üÊ†öÊ°âÊ†≤Ê†≥Ê†ªÊ°ãÊ°èÊ†ñÊ†±Ê†úÊ†µÊ†´Ê†≠Ê†ØÊ°éÊ°ÑÊ†¥Ê†ùÊ†íÊ†îÊ†¶Ê†®Ê†ÆÊ°çÊ†∫Ê†•Ê††Ê¨¨Ê¨ØÊ¨≠Ê¨±Ê¨¥Ê≠≠ËÇÇÊÆàÊØ¶ÊØ§"],["d240","ÊØ®ÊØ£ÊØ¢ÊØßÊ∞•Êµ∫Êµ£Êµ§Êµ∂Ê¥çÊµ°Ê∂íÊµòÊµ¢Êµ≠ÊµØÊ∂ëÊ∂çÊ∑ØÊµøÊ∂ÜÊµûÊµßÊµ†Ê∂óÊµ∞ÊµºÊµüÊ∂ÇÊ∂òÊ¥ØÊµ®Ê∂ãÊµæÊ∂ÄÊ∂ÑÊ¥ñÊ∂ÉÊµªÊµΩÊµµÊ∂êÁÉúÁÉìÁÉëÁÉùÁÉãÁºπÁÉ¢ÁÉóÁÉíÁÉûÁÉ†ÁÉîÁÉçÁÉÖÁÉÜÁÉáÁÉöÁÉéÁÉ°ÁâÇÁâ∏"],["d2a1","Áâ∑Áâ∂ÁåÄÁã∫Áã¥ÁãæÁã∂Áã≥ÁãªÁåÅÁèìÁèôÁè•ÁèñÁéºÁèßÁè£Áè©ÁèúÁèíÁèõÁèîÁèùÁèöÁèóÁèòÁè®ÁìûÁìüÁì¥ÁìµÁî°ÁïõÁïüÁñ∞ÁóÅÁñªÁóÑÁóÄÁñøÁñ∂Áñ∫ÁöäÁõâÁúùÁúõÁúêÁúìÁúíÁú£ÁúëÁúïÁúôÁúöÁú¢ÁúßÁ†£Á†¨Á†¢Á†µÁ†ØÁ†®Á†ÆÁ†´Á†°Á†©Á†≥Á†™Á†±Á•îÁ•õÁ•èÁ•úÁ•ìÁ•íÁ•ëÁß´Áß¨Áß†ÁßÆÁß≠Áß™ÁßúÁßûÁßùÁ™ÜÁ™âÁ™ÖÁ™ãÁ™åÁ™äÁ™áÁ´òÁ¨ê"],["d340","Á¨ÑÁ¨ìÁ¨ÖÁ¨èÁ¨àÁ¨äÁ¨éÁ¨âÁ¨íÁ≤ÑÁ≤ëÁ≤äÁ≤åÁ≤àÁ≤çÁ≤ÖÁ¥ûÁ¥ùÁ¥ëÁ¥éÁ¥òÁ¥ñÁ¥ìÁ¥üÁ¥íÁ¥èÁ¥åÁΩúÁΩ°ÁΩûÁΩ†ÁΩùÁΩõÁæñÁæíÁøÉÁøÇÁøÄËÄñËÄæËÄπËÉ∫ËÉ≤ËÉπËÉµËÑÅËÉªËÑÄËàÅËàØËà•Ëå≥Ëå≠ËçÑËåôËçëËå•ËçñËåøËçÅËå¶ËåúËå¢"],["d3a1","ËçÇËçéËåõËå™ËåàËåºËççËåñËå§Ëå†Ëå∑ËåØËå©ËçáËçÖËçåËçìËåûËå¨ËçãËåßËçàËôìËôíËö¢Ëö®ËöñËöçËöëËöûËöáËöóËöÜËöãËööËöÖËö•ËöôËö°ËößËöïËöòËöéËöùËöêËöîË°ÉË°ÑË°≠Ë°µË°∂Ë°≤Ë¢ÄË°±Ë°øË°ØË¢ÉË°æË°¥Ë°ºË®íË±áË±óË±ªË≤§Ë≤£Ëµ∂Ëµ∏Ë∂µË∂∑Ë∂∂ËªëËªìËøæËøµÈÄÇËøøËøªÈÄÑËøºËø∂ÈÉñÈÉ†ÈÉôÈÉöÈÉ£ÈÉüÈÉ•ÈÉòÈÉõÈÉóÈÉúÈÉ§ÈÖê"],["d440","ÈÖéÈÖèÈáïÈá¢ÈáöÈôúÈôüÈöºÈ££È´üÈ¨Ø‰πøÂÅ∞ÂÅ™ÂÅ°ÂÅûÂÅ†ÂÅìÂÅãÂÅùÂÅ≤ÂÅàÂÅçÂÅÅÂÅõÂÅäÂÅ¢ÂÄïÂÅÖÂÅüÂÅ©ÂÅ´ÂÅ£ÂÅ§ÂÅÜÂÅÄÂÅÆÂÅ≥ÂÅóÂÅëÂáêÂâ´Ââ≠Ââ¨ÂâÆÂãñÂãìÂå≠ÂéúÂïµÂï∂ÂîºÂïçÂïêÂî¥Âî™ÂïëÂï¢Âî∂ÂîµÂî∞ÂïíÂïÖ"],["d4a1","ÂîåÂî≤Âï•ÂïéÂîπÂïàÂî≠ÂîªÂïÄÂïãÂúäÂúáÂüªÂ†îÂü¢Âü∂ÂüúÂü¥Â†ÄÂü≠ÂüΩÂ†àÂü∏Â†ãÂü≥ÂüèÂ†áÂüÆÂü£Âü≤Âü•Âü¨Âü°Â†éÂüºÂ†êÂüßÂ†ÅÂ†åÂü±Âü©Âü∞Â†çÂ†ÑÂ•úÂ©†Â©òÂ©ïÂ©ßÂ©ûÂ®∏Â®µÂ©≠Â©êÂ©üÂ©•Â©¨Â©ìÂ©§Â©óÂ©ÉÂ©ùÂ©íÂ©ÑÂ©õÂ©àÂ™éÂ®æÂ©çÂ®πÂ©åÂ©∞Â©©Â©áÂ©ëÂ©ñÂ©ÇÂ©úÂ≠≤Â≠ÆÂØÅÂØÄÂ±ôÂ¥ûÂ¥ãÂ¥ùÂ¥öÂ¥†Â¥åÂ¥®Â¥çÂ¥¶Â¥•Â¥è"],["d540","Â¥∞Â¥íÂ¥£Â¥üÂ¥ÆÂ∏æÂ∏¥Â∫±Â∫¥Â∫πÂ∫≤Â∫≥Âº∂Âº∏ÂæõÂæñÂæüÊÇäÊÇêÊÇÜÊÇæÊÇ∞ÊÇ∫ÊÉìÊÉîÊÉèÊÉ§ÊÉôÊÉùÊÉàÊÇ±ÊÉõÊÇ∑ÊÉäÊÇøÊÉÉÊÉçÊÉÄÊå≤Êç•ÊéäÊéÇÊçΩÊéΩÊéûÊé≠ÊéùÊéóÊé´ÊééÊçØÊéáÊéêÊçÆÊéØÊçµÊéúÊç≠ÊéÆÊçºÊé§ÊåªÊéü"],["d5a1","Êç∏ÊéÖÊéÅÊéëÊéçÊç∞ÊïìÊóçÊô•Êô°ÊôõÊôôÊôúÊô¢ÊúòÊ°πÊ¢áÊ¢êÊ¢úÊ°≠Ê°ÆÊ¢ÆÊ¢´Ê•ñÊ°ØÊ¢£Ê¢¨Ê¢©Ê°µÊ°¥Ê¢≤Ê¢èÊ°∑Ê¢íÊ°ºÊ°´Ê°≤Ê¢™Ê¢ÄÊ°±Ê°æÊ¢õÊ¢ñÊ¢ãÊ¢†Ê¢âÊ¢§Ê°∏Ê°ªÊ¢ëÊ¢åÊ¢äÊ°ΩÊ¨∂Ê¨≥Ê¨∑Ê¨∏ÊÆëÊÆèÊÆçÊÆéÊÆåÊ∞™Ê∑ÄÊ∂´Ê∂¥Ê∂≥Êπ¥Ê∂¨Ê∑©Ê∑¢Ê∂∑Ê∑∂Ê∑îÊ∏ÄÊ∑àÊ∑†Ê∑üÊ∑ñÊ∂æÊ∑•Ê∑úÊ∑ùÊ∑õÊ∑¥Ê∑äÊ∂ΩÊ∑≠Ê∑∞Ê∂∫Ê∑ïÊ∑ÇÊ∑èÊ∑â"],["d640","Ê∑êÊ∑≤Ê∑ìÊ∑ΩÊ∑óÊ∑çÊ∑£Ê∂ªÁÉ∫ÁÑçÁÉ∑ÁÑóÁÉ¥ÁÑåÁÉ∞ÁÑÑÁÉ≥ÁÑêÁÉºÁÉøÁÑÜÁÑìÁÑÄÁÉ∏ÁÉ∂ÁÑãÁÑÇÁÑéÁâæÁâªÁâºÁâøÁåùÁåóÁåáÁåëÁåòÁåäÁåàÁãøÁåèÁåûÁéàÁè∂Áè∏ÁèµÁêÑÁêÅÁèΩÁêáÁêÄÁè∫ÁèºÁèøÁêåÁêãÁè¥ÁêàÁï§Áï£ÁóéÁóíÁóè"],["d6a1","ÁóãÁóåÁóëÁóêÁöèÁöâÁõìÁúπÁúØÁú≠Áú±Áú≤Áú¥Áú≥ÁúΩÁú•ÁúªÁúµÁ°àÁ°íÁ°âÁ°çÁ°äÁ°åÁ†¶Á°ÖÁ°êÁ•§Á•ßÁ•©Á•™Á•£Á•´Á•°Á¶ªÁß∫Áß∏Áß∂Áß∑Á™èÁ™îÁ™êÁ¨µÁ≠áÁ¨¥Á¨•Á¨∞Á¨¢Á¨§Á¨≥Á¨òÁ¨™Á¨ùÁ¨±Á¨´Á¨≠Á¨ØÁ¨≤Á¨∏Á¨öÁ¨£Á≤îÁ≤òÁ≤ñÁ≤£Á¥µÁ¥ΩÁ¥∏Á¥∂Á¥∫ÁµÖÁ¥¨Á¥©ÁµÅÁµáÁ¥æÁ¥øÁµäÁ¥ªÁ¥®ÁΩ£ÁæïÁæúÁæùÁæõÁøäÁøãÁøçÁøêÁøëÁøáÁøèÁøâËÄü"],["d740","ËÄûËÄõËÅáËÅÉËÅàËÑòËÑ•ËÑôËÑõËÑ≠ËÑüËÑ¨ËÑûËÑ°ËÑïËÑßËÑùËÑ¢ËàëËà∏Ëà≥Ëà∫Ëà¥Ëà≤Ëâ¥ËéêËé£Ëé®ËéçËç∫Ëç≥Ëé§Ëç¥ËéèËéÅËéïËéôËçµËéîËé©ËçΩËéÉËéåËéùËéõËé™ËéãËçæËé•ËéØËéàËéóËé∞ËçøËé¶ËéáËéÆËç∂ËéöËôôËôñËöøËö∑"],["d7a1","ËõÇËõÅËõÖËö∫Ëö∞ËõàËöπËö≥Ëö∏ËõåËö¥ËöªËöºËõÉËöΩËöæË°íË¢âË¢ïË¢®Ë¢¢Ë¢™Ë¢öË¢ëË¢°Ë¢üË¢òË¢ßË¢ôË¢õË¢óË¢§Ë¢¨Ë¢åË¢ìË¢éË¶ÇËßñËßôËßïË®∞Ë®ßË®¨Ë®ûË∞πË∞ªË±úË±ùË±ΩË≤•ËµΩËµªËµπË∂ºË∑ÇË∂πË∂øË∑ÅËªòËªûËªùËªúËªóËª†Ëª°ÈÄ§ÈÄãÈÄëÈÄúÈÄåÈÄ°ÈÉØÈÉ™ÈÉ∞ÈÉ¥ÈÉ≤ÈÉ≥ÈÉîÈÉ´ÈÉ¨ÈÉ©ÈÖñÈÖòÈÖöÈÖìÈÖïÈá¨Èá¥Èá±Èá≥Èá∏Èá§ÈáπÈá™"],["d840","Èá´Èá∑Èá®ÈáÆÈï∫ÈñÜÈñàÈôºÈô≠Èô´Èô±ÈôØÈöøÈù™È†ÑÈ£•È¶óÂÇõÂÇïÂÇîÂÇûÂÇãÂÇ£ÂÇÉÂÇåÂÇéÂÇùÂÅ®ÂÇúÂÇíÂÇÇÂÇáÂÖüÂáîÂåíÂåëÂé§ÂéßÂñëÂñ®Âñ•Âñ≠Âï∑ÂôÖÂñ¢ÂñìÂñàÂñèÂñµÂñÅÂñ£ÂñíÂñ§ÂïΩÂñåÂñ¶ÂïøÂñïÂñ°ÂñéÂúåÂ†©Â†∑"],["d8a1","Â†ôÂ†ûÂ†ßÂ†£Â†®ÂüµÂ°àÂ†•Â†úÂ†õÂ†≥Â†øÂ†∂Â†ÆÂ†πÂ†∏Â†≠Â†¨Â†ªÂ•°Â™ØÂ™îÂ™üÂ©∫Â™¢Â™ûÂ©∏Â™¶Â©ºÂ™•Â™¨Â™ïÂ™ÆÂ®∑Â™ÑÂ™äÂ™óÂ™ÉÂ™ãÂ™©Â©ªÂ©ΩÂ™åÂ™úÂ™èÂ™ìÂ™ùÂØ™ÂØçÂØãÂØîÂØëÂØäÂØéÂ∞åÂ∞∞Â¥∑ÂµÉÂµ´ÂµÅÂµãÂ¥øÂ¥µÂµëÂµéÂµïÂ¥≥Â¥∫ÂµíÂ¥ΩÂ¥±ÂµôÂµÇÂ¥πÂµâÂ¥∏Â¥ºÂ¥≤Â¥∂ÂµÄÂµÖÂπÑÂπÅÂΩòÂæ¶Âæ•Âæ´ÊÉâÊÇπÊÉåÊÉ¢ÊÉéÊÉÑÊÑî"],["d940","ÊÉ≤ÊÑäÊÑñÊÑÖÊÉµÊÑìÊÉ∏ÊÉºÊÉæÊÉÅÊÑÉÊÑòÊÑùÊÑêÊÉøÊÑÑÊÑãÊâäÊéîÊé±Êé∞ÊèéÊè•Êè®ÊèØÊèÉÊíùÊè≥ÊèäÊè†Êè∂ÊèïÊè≤ÊèµÊë°ÊèüÊéæÊèùÊèúÊèÑÊèòÊèìÊèÇÊèáÊèåÊèãÊèàÊè∞ÊèóÊèôÊî≤ÊïßÊï™Êï§ÊïúÊï®Êï•ÊñåÊñùÊñûÊñÆÊóêÊóí"],["d9a1","ÊôºÊô¨ÊôªÊöÄÊô±ÊôπÊô™Êô≤ÊúÅÊ§åÊ£ìÊ§ÑÊ£úÊ§™Ê£¨Ê£™Ê£±Ê§èÊ£ñÊ£∑Ê£´Ê£§Ê£∂Ê§ìÊ§êÊ£≥Ê£°Ê§áÊ£åÊ§àÊ•∞Ê¢¥Ê§ëÊ£ØÊ£ÜÊ§îÊ£∏Ê£êÊ£ΩÊ£ºÊ£®Ê§ãÊ§äÊ§óÊ£éÊ£àÊ£ùÊ£ûÊ£¶Ê£¥Ê£ëÊ§ÜÊ£îÊ£©Ê§ïÊ§•Ê£áÊ¨πÊ¨ªÊ¨øÊ¨ºÊÆîÊÆóÊÆôÊÆïÊÆΩÊØ∞ÊØ≤ÊØ≥Ê∞∞Ê∑ºÊπÜÊπáÊ∏üÊπâÊ∫àÊ∏ºÊ∏ΩÊπÖÊπ¢Ê∏´Ê∏øÊπÅÊπùÊπ≥Ê∏úÊ∏≥ÊπãÊπÄÊπëÊ∏ªÊ∏ÉÊ∏ÆÊπû"],["da40","Êπ®ÊπúÊπ°Ê∏±Ê∏®Êπ†Êπ±Êπ´Ê∏πÊ∏¢Ê∏∞ÊπìÊπ•Ê∏ßÊπ∏Êπ§Êπ∑ÊπïÊππÊπíÊπ¶Ê∏µÊ∏∂ÊπöÁÑ†ÁÑûÁÑØÁÉªÁÑÆÁÑ±ÁÑ£ÁÑ•ÁÑ¢ÁÑ≤ÁÑüÁÑ®ÁÑ∫ÁÑõÁâãÁâöÁäàÁäâÁäÜÁäÖÁäãÁåíÁåãÁå∞Áå¢Áå±Áå≥ÁåßÁå≤Áå≠Áå¶Áå£ÁåµÁååÁêÆÁê¨Áê∞Áê´Áêñ"],["daa1","ÁêöÁê°Áê≠Áê±Áê§Áê£ÁêùÁê©Áê†Áê≤ÁìªÁîØÁïØÁï¨ÁóßÁóöÁó°Áó¶ÁóùÁóüÁó§ÁóóÁöïÁöíÁõöÁùÜÁùáÁùÑÁùçÁùÖÁùäÁùéÁùãÁùåÁüûÁü¨Á°†Á°§Á°•Á°úÁ°≠Á°±Á°™Á°ÆÁ°∞Á°©Á°®Á°ûÁ°¢Á•¥Á•≥Á•≤Á•∞Á®ÇÁ®äÁ®ÉÁ®åÁ®ÑÁ™ôÁ´¶Á´§Á≠äÁ¨ªÁ≠ÑÁ≠àÁ≠åÁ≠éÁ≠ÄÁ≠òÁ≠ÖÁ≤¢Á≤ûÁ≤®Á≤°ÁµòÁµØÁµ£ÁµìÁµñÁµßÁµ™ÁµèÁµ≠ÁµúÁµ´ÁµíÁµîÁµ©ÁµëÁµüÁµéÁºæÁºøÁΩ•"],["db40","ÁΩ¶Áæ¢Áæ†Áæ°ÁøóËÅëËÅèËÅêËÉæËÉîËÖÉËÖäËÖíËÖèËÖáËÑΩËÖçËÑ∫Ëá¶ËáÆËá∑Ëá∏ËáπËàÑËàºËàΩËàøËâµËåªËèèËèπËê£ËèÄËè®ËêíËèßËè§ËèºËè∂ËêêËèÜËèàËè´Ëè£ËéøËêÅËèùËè•ËèòËèøËè°ËèãËèéËèñËèµËèâËêâËêèËèûËêëËêÜËèÇËè≥"],["dba1","ËèïËè∫ËèáËèëËè™ËêìËèÉËè¨ËèÆËèÑËèªËèóËè¢ËêõËèõËèæËõòËõ¢Ëõ¶ËõìËõ£ËõöËõ™ËõùËõ´ËõúËõ¨Ëõ©ËõóËõ®ËõëË°àË°ñË°ïË¢∫Ë£óË¢πË¢∏Ë£ÄË¢æË¢∂Ë¢ºË¢∑Ë¢ΩË¢≤Ë§ÅË£âË¶ïË¶òË¶óËßùËßöËßõË©éË©çË®πË©ôË©ÄË©óË©òË©ÑË©ÖË©íË©àË©ëË©äË©åË©èË±üË≤ÅË≤ÄË≤∫Ë≤æË≤∞Ë≤πË≤µË∂ÑË∂ÄË∂âË∑òË∑ìË∑çË∑áË∑ñË∑úË∑èË∑ïË∑ôË∑àË∑óË∑ÖËªØËª∑Ëª∫"],["dc40","ËªπËª¶ËªÆËª•ËªµËªßËª®Ëª∂Ëª´Ëª±Ëª¨Ëª¥Ëª©ÈÄ≠ÈÄ¥ÈÄØÈÑÜÈÑ¨ÈÑÑÈÉøÈÉºÈÑàÈÉπÈÉªÈÑÅÈÑÄÈÑáÈÑÖÈÑÉÈÖ°ÈÖ§ÈÖüÈÖ¢ÈÖ†ÈàÅÈàäÈà•ÈàÉÈàöÈà¶ÈàèÈàåÈàÄÈàíÈáøÈáΩÈàÜÈàÑÈàßÈàÇÈàúÈà§ÈàôÈàóÈàÖÈàñÈïªÈñçÈñåÈñêÈöáÈôæÈöà"],["dca1","ÈöâÈöÉÈöÄÈõÇÈõàÈõÉÈõ±Èõ∞Èù¨Èù∞ÈùÆÈ†áÈ¢©È£´È≥¶Èªπ‰∫É‰∫Ñ‰∫∂ÂÇΩÂÇøÂÉÜÂÇÆÂÉÑÂÉäÂÇ¥ÂÉàÂÉÇÂÇ∞ÂÉÅÂÇ∫ÂÇ±ÂÉãÂÉâÂÇ∂ÂÇ∏ÂáóÂâ∫Ââ∏ÂâªÂâºÂóÉÂóõÂóåÂóêÂóãÂóäÂóùÂóÄÂóîÂóÑÂó©ÂñøÂóíÂñçÂóèÂóïÂó¢ÂóñÂóàÂó≤ÂóçÂóôÂóÇÂúîÂ°ìÂ°®Â°§Â°èÂ°çÂ°âÂ°ØÂ°ïÂ°éÂ°ùÂ°ôÂ°•Â°õÂ†ΩÂ°£Â°±Â£ºÂ´áÂ´ÑÂ´ãÂ™∫Â™∏Â™±Â™µÂ™∞Â™øÂ´àÂ™ªÂ´Ü"],["dd40","Â™∑Â´ÄÂ´äÂ™¥Â™∂Â´çÂ™πÂ™êÂØñÂØòÂØôÂ∞üÂ∞≥Âµ±Âµ£ÂµäÂµ•Âµ≤Âµ¨ÂµûÂµ®ÂµßÂµ¢Â∑∞ÂπèÂπéÂπäÂπçÂπãÂªÖÂªåÂªÜÂªãÂªáÂΩÄÂæØÂæ≠ÊÉ∑ÊÖâÊÖäÊÑ´ÊÖÖÊÑ∂ÊÑ≤ÊÑÆÊÖÜÊÑØÊÖèÊÑ©ÊÖÄÊà†ÈÖ®Êà£Êà•Êà§ÊèÖÊè±Êè´ÊêêÊêíÊêâÊê†Êê§"],["dda1","Êê≥ÊëÉÊêüÊêïÊêòÊêπÊê∑Êê¢Êê£ÊêåÊê¶Êê∞Êê®ÊëÅÊêµÊêØÊêäÊêöÊëÄÊê•ÊêßÊêãÊèßÊêõÊêÆÊê°ÊêéÊïØÊñíÊóìÊöÜÊöåÊöïÊöêÊöãÊöäÊöôÊöîÊô∏Êú†Ê•¶Ê•üÊ§∏Ê•éÊ•¢Ê•±Ê§øÊ•ÖÊ•™Ê§πÊ•ÇÊ•óÊ•ôÊ•∫Ê•àÊ•âÊ§µÊ•¨Ê§≥Ê§ΩÊ••Ê£∞Ê•∏Ê§¥Ê•©Ê•ÄÊ•ØÊ•ÑÊ•∂Ê•òÊ•ÅÊ•¥Ê•åÊ§ªÊ•ãÊ§∑Ê•úÊ•èÊ•ëÊ§≤Ê•íÊ§ØÊ•ªÊ§ºÊ≠ÜÊ≠ÖÊ≠ÉÊ≠ÇÊ≠àÊ≠ÅÊÆõÔ®çÊØªÊØº"],["de40","ÊØπÊØ∑ÊØ∏Ê∫õÊªñÊªàÊ∫èÊªÄÊ∫üÊ∫ìÊ∫îÊ∫†Ê∫±Ê∫πÊªÜÊªíÊ∫ΩÊªÅÊ∫ûÊªâÊ∫∑Ê∫∞ÊªçÊ∫¶ÊªèÊ∫≤Ê∫æÊªÉÊªúÊªòÊ∫ôÊ∫íÊ∫éÊ∫çÊ∫§Ê∫°Ê∫øÊ∫≥ÊªêÊªäÊ∫óÊ∫ÆÊ∫£ÁÖáÁÖîÁÖíÁÖ£ÁÖ†ÁÖÅÁÖùÁÖ¢ÁÖ≤ÁÖ∏ÁÖ™ÁÖ°ÁÖÇÁÖòÁÖÉÁÖãÁÖ∞ÁÖüÁÖêÁÖì"],["dea1","ÁÖÑÁÖçÁÖöÁâèÁäçÁäåÁäëÁäêÁäéÁåºÁçÇÁåªÁå∫ÁçÄÁçäÁçâÁëÑÁëäÁëãÁëíÁëëÁëóÁëÄÁëèÁëêÁëéÁëÇÁëÜÁëçÁëîÁì°ÁìøÁìæÁìΩÁîùÁïπÁï∑Ê¶ÉÁóØÁòèÁòÉÁó∑ÁóæÁóºÁóπÁó∏ÁòêÁóªÁó∂Áó≠ÁóµÁóΩÁöôÁöµÁõùÁùïÁùüÁù†ÁùíÁùñÁùöÁù©ÁùßÁùîÁùôÁù≠Áü†Á¢áÁ¢öÁ¢îÁ¢èÁ¢ÑÁ¢ïÁ¢ÖÁ¢ÜÁ¢°Á¢ÉÁ°πÁ¢ôÁ¢ÄÁ¢ñÁ°ªÁ•ºÁ¶ÇÁ•ΩÁ•πÁ®ëÁ®òÁ®ôÁ®íÁ®óÁ®ïÁ®¢Á®ì"],["df40","Á®õÁ®êÁ™£Á™¢Á™ûÁ´´Á≠¶Á≠§Á≠≠Á≠¥Á≠©Á≠≤Á≠•Á≠≥Á≠±Á≠∞Á≠°Á≠∏Á≠∂Á≠£Á≤≤Á≤¥Á≤ØÁ∂àÁ∂ÜÁ∂ÄÁ∂çÁµøÁ∂ÖÁµ∫Á∂éÁµªÁ∂ÉÁµºÁ∂åÁ∂îÁ∂ÑÁµΩÁ∂íÁΩ≠ÁΩ´ÁΩßÁΩ®ÁΩ¨Áæ¶Áæ•ÁæßÁøõÁøúËÄ°ËÖ§ËÖ†ËÖ∑ËÖúËÖ©ËÖõËÖ¢ËÖ≤Êú°ËÖûËÖ∂ËÖßËÖØ"],["dfa1","ËÖÑËÖ°ËàùËââËâÑËâÄËâÇËâÖËì±ËêøËëñËë∂ËëπËíèËíçËë•ËëëËëÄËíÜËëßËê∞ËëçËëΩËëöËëôËë¥Ëë≥ËëùËîáËëûËê∑Ëê∫Ëê¥Ëë∫ËëÉËë∏Ëê≤ËëÖËê©ËèôËëãËêØËëÇËê≠ËëüËë∞ËêπËëéËëåËëíËëØËìÖËíéËêªËëáËê∂Ëê≥Ëë®ËëæËëÑËê´Ëë†ËëîËëÆËëêËúãËúÑËõ∑ËúåËõ∫ËõñËõµËùçËõ∏ËúéËúâËúÅËõ∂ËúçËúÖË£ñË£ãË£çË£éË£ûË£õË£öË£åË£êË¶ÖË¶õËßüËß•Ëß§"],["e040","Ëß°Ëß†Ëß¢ËßúËß¶Ë©∂Ë™ÜË©øË©°Ë®øË©∑Ë™ÇË™ÑË©µË™ÉË™ÅË©¥Ë©∫Ë∞ºË±ãË±äË±•Ë±§Ë±¶Ë≤ÜË≤ÑË≤ÖË≥åËµ®Ëµ©Ë∂ëË∂åË∂éË∂èË∂çË∂ìË∂îË∂êË∂íË∑∞Ë∑†Ë∑¨Ë∑±Ë∑ÆË∑êË∑©Ë∑£Ë∑¢Ë∑ßË∑≤Ë∑´Ë∑¥ËºÜËªøËºÅËºÄËºÖËºáËºàËºÇËºãÈÅíÈÄø"],["e0a1","ÈÅÑÈÅâÈÄΩÈÑêÈÑçÈÑèÈÑëÈÑñÈÑîÈÑãÈÑéÈÖÆÈÖØÈâàÈâíÈà∞Èà∫Èâ¶Èà≥Èâ•ÈâûÈäÉÈàÆÈâäÈâÜÈâ≠Èâ¨ÈâèÈâ†ÈâßÈâØÈà∂Èâ°Èâ∞Èà±ÈâîÈâ£ÈâêÈâ≤ÈâéÈâìÈâåÈâñÈà≤ÈñüÈñúÈñûÈñõÈöíÈöìÈöëÈöóÈõéÈõ∫ÈõΩÈõ∏ÈõµÈù≥Èù∑Èù∏Èù≤È†èÈ†çÈ†éÈ¢¨È£∂È£πÈ¶ØÈ¶≤È¶∞È¶µÈ™≠È™´È≠õÈ≥™È≥≠È≥ßÈ∫ÄÈªΩÂÉ¶ÂÉîÂÉóÂÉ®ÂÉ≥ÂÉõÂÉ™ÂÉùÂÉ§ÂÉìÂÉ¨ÂÉ∞ÂÉØÂÉ£ÂÉ†"],["e140","ÂáòÂäÄÂäÅÂã©Âã´Âå∞Âé¨ÂòßÂòïÂòåÂòíÂóºÂòèÂòúÂòÅÂòìÂòÇÂó∫ÂòùÂòÑÂóøÂóπÂ¢âÂ°ºÂ¢êÂ¢òÂ¢ÜÂ¢ÅÂ°øÂ°¥Â¢ãÂ°∫Â¢áÂ¢ëÂ¢éÂ°∂Â¢ÇÂ¢àÂ°ªÂ¢îÂ¢èÂ£æÂ•´Â´úÂ´ÆÂ´•Â´ïÂ´™Â´öÂ´≠Â´´Â´≥Â´¢Â´†Â´õÂ´¨Â´ûÂ´ùÂ´ôÂ´®Â´üÂ≠∑ÂØ†"],["e1a1","ÂØ£Â±£Â∂ÇÂ∂ÄÂµΩÂ∂ÜÂµ∫Â∂ÅÂµ∑Â∂äÂ∂âÂ∂àÂµæÂµºÂ∂çÂµπÂµøÂπòÂπôÂπìÂªòÂªëÂªóÂªéÂªúÂªïÂªôÂªíÂªîÂΩÑÂΩÉÂΩØÂæ∂ÊÑ¨ÊÑ®ÊÖÅÊÖûÊÖ±ÊÖ≥ÊÖíÊÖìÊÖ≤ÊÖ¨ÊÜÄÊÖ¥ÊÖîÊÖ∫ÊÖõÊÖ•ÊÑªÊÖ™ÊÖ°ÊÖñÊà©ÊàßÊà´Êê´ÊëçÊëõÊëùÊë¥Êë∂Êë≤Êë≥ÊëΩÊëµÊë¶Êí¶ÊëéÊíÇÊëûÊëúÊëãÊëìÊë†ÊëêÊëøÊêøÊë¨Êë´ÊëôÊë•Êë∑Êï≥Êñ†Êö°Êö†ÊöüÊúÖÊúÑÊú¢Ê¶±Ê¶∂Êßâ"],["e240","Ê¶†ÊßéÊ¶ñÊ¶∞Ê¶¨Ê¶ºÊ¶ëÊ¶ôÊ¶éÊ¶ßÊ¶çÊ¶©Ê¶æÊ¶ØÊ¶øÊßÑÊ¶ΩÊ¶§ÊßîÊ¶πÊßäÊ¶öÊßèÊ¶≥Ê¶ìÊ¶™Ê¶°Ê¶ûÊßôÊ¶óÊ¶êÊßÇÊ¶µÊ¶•ÊßÜÊ≠äÊ≠çÊ≠ãÊÆûÊÆüÊÆ†ÊØÉÊØÑÊØæÊªéÊªµÊª±ÊºÉÊº•Êª∏Êº∑ÊªªÊºÆÊºâÊΩéÊºôÊºöÊºßÊºòÊºªÊºíÊª≠Êºä"],["e2a1","Êº∂ÊΩ≥ÊªπÊªÆÊº≠ÊΩÄÊº∞ÊººÊºµÊª´ÊºáÊºéÊΩÉÊºÖÊªΩÊª∂ÊºπÊºúÊªºÊº∫ÊºüÊºçÊºûÊºàÊº°ÁÜáÁÜêÁÜâÁÜÄÁÜÖÁÜÇÁÜèÁÖªÁÜÜÁÜÅÁÜóÁâÑÁâìÁäóÁäïÁäìÁçÉÁççÁçëÁçåÁë¢Áë≥Áë±ÁëµÁë≤ÁëßÁëÆÁîÄÁîÇÁîÉÁïΩÁñêÁòñÁòàÁòåÁòïÁòëÁòäÁòîÁö∏ÁûÅÁùºÁûÖÁûÇÁùÆÁûÄÁùØÁùæÁûÉÁ¢≤Á¢™Á¢¥Á¢≠Á¢®Á°æÁ¢´Á¢ûÁ¢•Á¢†Á¢¨Á¢¢Á¢§Á¶òÁ¶äÁ¶ãÁ¶ñÁ¶ïÁ¶îÁ¶ì"],["e340","Á¶óÁ¶àÁ¶íÁ¶êÁ®´Á©äÁ®∞Á®ØÁ®®Á®¶Á™®Á™´Á™¨Á´ÆÁÆàÁÆúÁÆäÁÆëÁÆêÁÆñÁÆçÁÆåÁÆõÁÆéÁÆÖÁÆòÂäÑÁÆôÁÆ§ÁÆÇÁ≤ªÁ≤øÁ≤ºÁ≤∫Á∂ßÁ∂∑Á∑ÇÁ∂£Á∂™Á∑ÅÁ∑ÄÁ∑ÖÁ∂ùÁ∑éÁ∑ÑÁ∑ÜÁ∑ãÁ∑åÁ∂ØÁ∂πÁ∂ñÁ∂ºÁ∂üÁ∂¶Á∂ÆÁ∂©Á∂°Á∑âÁΩ≥Áø¢Áø£Áø•Áøû"],["e3a1","ËÄ§ËÅùËÅúËÜâËÜÜËÜÉËÜáËÜçËÜåËÜãËàïËíóËí§Ëí°ËíüËí∫ËìéËìÇËí¨ËíÆËí´ËíπËí¥ËìÅËìçËí™ËíöËí±ËìêËíùËíßËíªËí¢ËíîËìáËìåËíõËí©ËíØËí®ËìñËíòËí∂ËìèËí†ËìóËìîËìíËìõËí∞ËíëËô°Ëú≥Ëú£Ëú®Ëù´ËùÄËúÆËúûËú°ËúôËúõËùÉËú¨ËùÅËúæËùÜËú†Ëú≤Ëú™Ëú≠ËúºËúíËú∫Ëú±ËúµËùÇËú¶ËúßËú∏Ëú§ËúöËú∞ËúëË£∑Ë£ßË£±Ë£≤Ë£∫Ë£æË£ÆË£ºË£∂Ë£ª"],["e440","Ë£∞Ë£¨Ë£´Ë¶ùË¶°Ë¶üË¶ûËß©Ëß´Ëß®Ë™´Ë™ôË™ãË™íË™èË™ñË∞ΩË±®Ë±©Ë≥ïË≥èË≥óË∂ñË∏âË∏ÇË∑øË∏çË∑ΩË∏äË∏ÉË∏áË∏ÜË∏ÖË∑æË∏ÄË∏ÑËºêËºëËºéËºçÈÑ£ÈÑúÈÑ†ÈÑ¢ÈÑüÈÑùÈÑöÈÑ§ÈÑ°ÈÑõÈÖ∫ÈÖ≤ÈÖπÈÖ≥Èä•Èä§Èâ∂ÈäõÈâ∫Èä†ÈäîÈä™Èäç"],["e4a1","Èä¶ÈäöÈä´ÈâπÈäóÈâøÈä£ÈãÆÈäéÈäÇÈäïÈä¢ÈâΩÈäàÈä°ÈääÈäÜÈäåÈäôÈäßÈâæÈäáÈä©ÈäùÈäãÈà≠ÈöûÈö°ÈõøÈùòÈùΩÈù∫ÈùæÈûÉÈûÄÈûÇÈùªÈûÑÈûÅÈùøÈüéÈüçÈ†ñÈ¢≠È¢ÆÈ§ÇÈ§ÄÈ§áÈ¶ùÈ¶úÈßÉÈ¶πÈ¶ªÈ¶∫ÈßÇÈ¶ΩÈßáÈ™±È´£È´ßÈ¨æÈ¨øÈ≠†È≠°È≠üÈ≥±È≥≤È≥µÈ∫ßÂÉøÂÑÉÂÑ∞ÂÉ∏ÂÑÜÂÑáÂÉ∂ÂÉæÂÑãÂÑåÂÉΩÂÑäÂäãÂäåÂã±ÂãØÂôàÂôÇÂôåÂòµÂôÅÂôäÂôâÂôÜÂôò"],["e540","ÂôöÂôÄÂò≥ÂòΩÂò¨ÂòæÂò∏Âò™Âò∫ÂúöÂ¢´Â¢ùÂ¢±Â¢†Â¢£Â¢ØÂ¢¨Â¢•Â¢°Â£øÂ´øÂ´¥Â´ΩÂ´∑Â´∂Â¨ÉÂ´∏Â¨ÇÂ´πÂ¨ÅÂ¨áÂ¨ÖÂ¨èÂ±ßÂ∂ôÂ∂óÂ∂üÂ∂íÂ∂¢Â∂ìÂ∂ïÂ∂†Â∂úÂ∂°Â∂öÂ∂ûÂπ©ÂπùÂπ†ÂπúÁ∑≥ÂªõÂªûÂª°ÂΩâÂæ≤ÊÜãÊÜÉÊÖπÊÜ±ÊÜ∞ÊÜ¢ÊÜâ"],["e5a1","ÊÜõÊÜìÊÜØÊÜ≠ÊÜüÊÜíÊÜ™ÊÜ°ÊÜçÊÖ¶ÊÜ≥Êà≠ÊëÆÊë∞ÊíñÊí†ÊíÖÊíóÊíúÊíèÊíãÊíäÊíåÊí£ÊíüÊë®Êí±ÊíòÊï∂Êï∫ÊïπÊïªÊñ≤Êñ≥ÊöµÊö∞Êö©Êö≤Êö∑Êö™ÊöØÊ®ÄÊ®ÜÊ®óÊß•Êß∏Ê®ïÊß±Êß§Ê®†ÊßøÊß¨Êß¢Ê®õÊ®ùÊßæÊ®ßÊß≤ÊßÆÊ®îÊß∑ÊßßÊ©ÄÊ®àÊß¶ÊßªÊ®çÊßºÊß´Ê®âÊ®ÑÊ®òÊ®•Ê®èÊß∂Ê®¶Ê®áÊß¥Ê®ñÊ≠ëÊÆ•ÊÆ£ÊÆ¢ÊÆ¶Ê∞ÅÊ∞ÄÊØøÊ∞ÇÊΩÅÊº¶ÊΩæÊæáÊøÜÊæí"],["e640","ÊæçÊæâÊæåÊΩ¢ÊΩèÊæÖÊΩöÊæñÊΩ∂ÊΩ¨ÊæÇÊΩïÊΩ≤ÊΩíÊΩêÊΩóÊæîÊæìÊΩùÊºÄÊΩ°ÊΩ´ÊΩΩÊΩßÊæêÊΩìÊæãÊΩ©ÊΩøÊæïÊΩ£ÊΩ∑ÊΩ™ÊΩªÁÜ≤ÁÜØÁÜõÁÜ∞ÁÜ†ÁÜöÁÜ©ÁÜµÁÜùÁÜ•ÁÜûÁÜ§ÁÜ°ÁÜ™ÁÜúÁÜßÁÜ≥ÁäòÁäöÁçòÁçíÁçûÁçüÁç†ÁçùÁçõÁç°ÁçöÁçô"],["e6a1","Áç¢ÁíáÁíâÁíäÁíÜÁíÅÁëΩÁíÖÁíàÁëºÁëπÁîàÁîáÁïæÁò•ÁòûÁòôÁòùÁòúÁò£ÁòöÁò®ÁòõÁöúÁöùÁöûÁöõÁûçÁûèÁûâÁûàÁ£çÁ¢ªÁ£èÁ£åÁ£ëÁ£éÁ£îÁ£àÁ£ÉÁ£ÑÁ£âÁ¶öÁ¶°Á¶†Á¶úÁ¶¢Á¶õÊ≠∂Á®πÁ™≤Á™¥Á™≥ÁÆ∑ÁØãÁÆæÁÆ¨ÁØéÁÆØÁÆπÁØäÁÆµÁ≥ÖÁ≥àÁ≥åÁ≥ãÁ∑∑Á∑õÁ∑™Á∑ßÁ∑óÁ∑°Á∏ÉÁ∑∫Á∑¶Á∑∂Á∑±Á∑∞Á∑ÆÁ∑üÁΩ∂Áæ¨Áæ∞Áæ≠Áø≠Áø´Áø™Áø¨Áø¶Áø®ËÅ§ËÅßËÜ£ËÜü"],["e740","ËÜûËÜïËÜ¢ËÜôËÜóËàñËâèËâìËâíËâêËâéËâëËî§ËîªËîèËîÄËî©ËîéËîâËîçËîüËîäËîßËîúËìªËî´Ëì∫ËîàËîåËì¥Ëî™Ëì≤ËîïËì∑Ëì´Ëì≥ËìºËîíËì™Ëì©ËîñËìæËî®ËîùËîÆËîÇËìΩËîûËì∂Ëî±Ëî¶ËìßËì®Ëì∞ËìØËìπËîòËî†Ëî∞ËîãËîôËîØËô¢"],["e7a1","ËùñËù£Ëù§Ëù∑Ëü°Ëù≥ËùòËùîËùõËùíËù°ËùöËùëËùûËù≠Ëù™ËùêËùéËùüËùùËùØËù¨Ëù∫ËùÆËùúËù•ËùèËùªËùµËù¢ËùßËù©Ë°öË§ÖË§åË§îË§ãË§óË§òË§ôË§ÜË§ñË§ëË§éË§âË¶¢Ë¶§Ë¶£Ëß≠Ëß∞Ëß¨Ë´èË´ÜË™∏Ë´ìË´ëË´îË´ïË™ªË´óË™æË´ÄË´ÖË´òË´ÉË™∫Ë™ΩË´ôË∞æË±çË≤èË≥•Ë≥üË≥ôË≥®Ë≥öË≥ùË≥ßË∂†Ë∂úË∂°Ë∂õË∏†Ë∏£Ë∏•Ë∏§Ë∏ÆË∏ïË∏õË∏ñË∏ëË∏ôË∏¶Ë∏ß"],["e840","Ë∏îË∏íË∏òË∏ìË∏úË∏óË∏öËº¨Ëº§ËºòËºöËº†Ëº£ËºñËºóÈÅ≥ÈÅ∞ÈÅØÈÅßÈÅ´ÈÑØÈÑ´ÈÑ©ÈÑ™ÈÑ≤ÈÑ¶ÈÑÆÈÜÖÈÜÜÈÜäÈÜÅÈÜÇÈÜÑÈÜÄÈãêÈãÉÈãÑÈãÄÈãôÈä∂ÈãèÈã±ÈãüÈãòÈã©ÈãóÈãùÈãåÈãØÈãÇÈã®ÈãäÈãàÈãéÈã¶ÈãçÈãïÈãâÈã†ÈãûÈãßÈãëÈãì"],["e8a1","ÈäµÈã°ÈãÜÈä¥ÈïºÈñ¨Èñ´ÈñÆÈñ∞Èö§Èö¢ÈõìÈúÖÈúàÈúÇÈùöÈûäÈûéÈûàÈüêÈüèÈ†ûÈ†ùÈ†¶È†©È†®È††È†õÈ†ßÈ¢≤È§àÈ£∫È§ëÈ§îÈ§ñÈ§óÈ§ïÈßúÈßçÈßèÈßìÈßîÈßéÈßâÈßñÈßòÈßãÈßóÈßåÈ™≥È´¨È´´È´≥È´≤È´±È≠ÜÈ≠ÉÈ≠ßÈ≠¥È≠±È≠¶È≠∂È≠µÈ≠∞È≠®È≠§È≠¨È≥ºÈ≥∫È≥ΩÈ≥øÈ≥∑È¥áÈ¥ÄÈ≥πÈ≥ªÈ¥àÈ¥ÖÈ¥ÑÈ∫ÉÈªìÈºèÈºêÂÑúÂÑìÂÑóÂÑöÂÑëÂáûÂå¥Âè°Âô∞Âô†ÂôÆ"],["e940","Âô≥Âô¶Âô£Âô≠Âô≤ÂôûÂô∑ÂúúÂúõÂ£àÂ¢ΩÂ£âÂ¢øÂ¢∫Â£ÇÂ¢ºÂ£ÜÂ¨óÂ¨ôÂ¨õÂ¨°Â¨îÂ¨ìÂ¨êÂ¨ñÂ¨®Â¨öÂ¨†Â¨ûÂØØÂ∂¨Â∂±Â∂©Â∂ßÂ∂µÂ∂∞Â∂ÆÂ∂™Â∂®Â∂≤Â∂≠Â∂ØÂ∂¥ÂπßÂπ®Âπ¶ÂπØÂª©ÂªßÂª¶Âª®Âª•ÂΩãÂæºÊÜùÊÜ®ÊÜñÊáÖÊÜ¥ÊáÜÊáÅÊáåÊÜ∫"],["e9a1","ÊÜøÊÜ∏ÊÜåÊìóÊìñÊìêÊìèÊìâÊíΩÊíâÊìÉÊìõÊì≥ÊìôÊî≥ÊïøÊïºÊñ¢ÊõàÊöæÊõÄÊõäÊõãÊõèÊöΩÊöªÊö∫ÊõåÊú£Ê®¥Ê©¶Ê©âÊ©ßÊ®≤Ê©®Ê®æÊ©ùÊ©≠Ê©∂Ê©õÊ©ëÊ®®Ê©öÊ®ªÊ®øÊ©ÅÊ©™Ê©§Ê©êÊ©èÊ©îÊ©ØÊ©©Ê©†Ê®ºÊ©ûÊ©ñÊ©ïÊ©çÊ©éÊ©ÜÊ≠ïÊ≠îÊ≠ñÊÆßÊÆ™ÊÆ´ÊØàÊØáÊ∞ÑÊ∞ÉÊ∞ÜÊæ≠ÊøãÊæ£ÊøáÊæºÊøéÊøàÊΩûÊøÑÊæΩÊæûÊøäÊæ®ÁÄÑÊæ•ÊæÆÊæ∫Êæ¨Êæ™ÊøèÊæøÊæ∏"],["ea40","Êæ¢ÊøâÊæ´ÊøçÊæØÊæ≤Êæ∞ÁáÖÁáÇÁÜøÁÜ∏ÁáñÁáÄÁáÅÁáãÁáîÁáäÁááÁáèÁÜΩÁáòÁÜºÁáÜÁáöÁáõÁäùÁäûÁç©Áç¶ÁçßÁç¨Áç•Áç´Áç™ÁëøÁíöÁí†ÁíîÁííÁíïÁí°ÁîãÁñÄÁòØÁò≠Áò±ÁòΩÁò≥ÁòºÁòµÁò≤Áò∞ÁöªÁõ¶ÁûöÁûùÁû°ÁûúÁûõÁû¢Áû£ÁûïÁûô"],["eaa1","ÁûóÁ£ùÁ£©Á£•Á£™Á£ûÁ££Á£õÁ£°Á£¢Á£≠Á£üÁ£†Á¶§Á©ÑÁ©àÁ©áÁ™∂Á™∏Á™µÁ™±Á™∑ÁØûÁØ£ÁØßÁØùÁØïÁØ•ÁØöÁØ®ÁØπÁØîÁØ™ÁØ¢ÁØúÁØ´ÁØòÁØüÁ≥íÁ≥îÁ≥óÁ≥êÁ≥ëÁ∏íÁ∏°Á∏óÁ∏åÁ∏üÁ∏†Á∏ìÁ∏éÁ∏úÁ∏ïÁ∏öÁ∏¢Á∏ãÁ∏èÁ∏ñÁ∏çÁ∏îÁ∏•Á∏§ÁΩÉÁΩªÁΩºÁΩ∫Áæ±ÁøØËÄ™ËÄ©ËÅ¨ËÜ±ËÜ¶ËÜÆËÜπËÜµËÜ´ËÜ∞ËÜ¨ËÜ¥ËÜ≤ËÜ∑ËÜßËá≤ËâïËâñËâóËïñËïÖËï´ËïçËïìËï°Ëïò"],["eb40","ËïÄËïÜËï§ËïÅËï¢ËïÑËïëËïáËï£ËîæËïõËï±ËïéËïÆËïµËïïËïßËï†ËñåËï¶ËïùËïîËï•Ëï¨Ëô£Ëô•Ëô§ËûõËûèËûóËûìËûíËûàËûÅËûñËûòËùπËûáËû£ËûÖËûêËûëËûùËûÑËûîËûúËûöËûâË§ûË§¶Ë§∞Ë§≠Ë§ÆË§ßË§±Ë§¢Ë§©Ë§£Ë§ØË§¨Ë§üËß±Ë´†"],["eba1","Ë´¢Ë´≤Ë´¥Ë´µË´ùË¨îË´§Ë´üË´∞Ë´àË´ûË´°Ë´®Ë´øË´ØË´ªË≤ëË≤íË≤êË≥µË≥ÆË≥±Ë≥∞Ë≥≥Ëµ¨ËµÆË∂•Ë∂ßË∏≥Ë∏æË∏∏ËπÄËπÖË∏∂Ë∏ºË∏ΩËπÅË∏∞Ë∏øË∫ΩËº∂ËºÆËºµËº≤ËºπËº∑Ëº¥ÈÅ∂ÈÅπÈÅªÈÇÜÈÉ∫ÈÑ≥ÈÑµÈÑ∂ÈÜìÈÜêÈÜëÈÜçÈÜèÈåßÈåûÈåàÈåüÈåÜÈåèÈç∫Èå∏ÈåºÈåõÈå£ÈåíÈåÅÈçÜÈå≠ÈåéÈåçÈããÈåùÈã∫Èå•ÈåìÈãπÈã∑Èå¥ÈåÇÈå§ÈãøÈå©ÈåπÈåµÈå™ÈåîÈåå"],["ec40","ÈåãÈãæÈåâÈåÄÈãªÈåñÈñºÈóçÈñæÈñπÈñ∫Èñ∂ÈñøÈñµÈñΩÈö©ÈõîÈúãÈúíÈúêÈûôÈûóÈûîÈü∞Èü∏È†µÈ†ØÈ†≤È§§È§üÈ§ßÈ§©È¶ûÈßÆÈß¨Èß•Èß§Èß∞Èß£Èß™Èß©ÈßßÈ™πÈ™øÈ™¥È™ªÈ´∂È´∫È´πÈ´∑È¨≥ÈÆÄÈÆÖÈÆáÈ≠ºÈ≠æÈ≠ªÈÆÇÈÆìÈÆíÈÆêÈ≠∫ÈÆï"],["eca1","È≠ΩÈÆàÈ¥•È¥óÈ¥†È¥ûÈ¥îÈ¥©È¥ùÈ¥òÈ¥¢È¥êÈ¥ôÈ¥üÈ∫àÈ∫ÜÈ∫áÈ∫ÆÈ∫≠ÈªïÈªñÈª∫ÈºíÈºΩÂÑ¶ÂÑ•ÂÑ¢ÂÑ§ÂÑ†ÂÑ©Âã¥ÂöìÂöåÂöçÂöÜÂöÑÂöÉÂôæÂöÇÂôøÂöÅÂ£ñÂ£îÂ£èÂ£íÂ¨≠Â¨•Â¨≤Â¨£Â¨¨Â¨ßÂ¨¶Â¨ØÂ¨ÆÂ≠ªÂØ±ÂØ≤Â∂∑Âπ¨Âπ™ÂææÂæªÊáÉÊÜµÊÜºÊáßÊá†Êá•Êá§Êá®ÊáûÊìØÊì©Êì£Êì´Êì§Êì®ÊñÅÊñÄÊñ∂ÊóöÊõíÊ™çÊ™ñÊ™ÅÊ™•Ê™âÊ™üÊ™õÊ™°Ê™ûÊ™áÊ™ìÊ™é"],["ed40","Ê™ïÊ™ÉÊ™®Ê™§Ê™ëÊ©øÊ™¶Ê™öÊ™ÖÊ™åÊ™íÊ≠õÊÆ≠Ê∞âÊøåÊæ©Êø¥ÊøîÊø£ÊøúÊø≠ÊøßÊø¶ÊøûÊø≤ÊøùÊø¢Êø®Áá°Áá±Áá®Áá≤Áá§Áá∞Áá¢Áç≥ÁçÆÁçØÁíóÁí≤Áí´ÁíêÁí™Áí≠Áí±Áí•ÁíØÁîêÁîëÁîíÁîèÁñÑÁôÉÁôàÁôâÁôáÁö§Áõ©ÁûµÁû´Áû≤Áû∑Áû∂"],["eda1","Áû¥Áû±Áû®Áü∞Á£≥Á£ΩÁ§ÇÁ£ªÁ£ºÁ£≤Á§ÖÁ£πÁ£æÁ§ÑÁ¶´Á¶®Á©úÁ©õÁ©ñÁ©òÁ©îÁ©öÁ™æÁ´ÄÁ´ÅÁ∞ÖÁ∞èÁØ≤Á∞ÄÁØøÁØªÁ∞éÁØ¥Á∞ãÁØ≥Á∞ÇÁ∞âÁ∞ÉÁ∞ÅÁØ∏ÁØΩÁ∞ÜÁØ∞ÁØ±Á∞êÁ∞äÁ≥®Á∏≠Á∏ºÁπÇÁ∏≥È°àÁ∏∏Á∏™ÁπâÁπÄÁπáÁ∏©ÁπåÁ∏∞Á∏ªÁ∏∂ÁπÑÁ∏∫ÁΩÖÁΩøÁΩæÁΩΩÁø¥Áø≤ËÄ¨ËÜªËáÑËáåËáäËáÖËááËÜºËá©ËâõËâöËâúËñÉËñÄËñèËñßËñïËñ†ËñãËñ£ËïªËñ§ËñöËñû"],["ee40","Ëï∑ËïºËñâËñ°Ëï∫Ëï∏ËïóËñéËññËñÜËñçËñôËñùËñÅËñ¢ËñÇËñàËñÖËïπËï∂ËñòËñêËñüËô®ËûæËû™Ëû≠ËüÖËû∞Ëû¨ËûπËûµËûºËûÆËüâËüÉËüÇËüåËû∑ËûØËüÑËüäËû¥Ëû∂ËûøËû∏ËûΩËüûËû≤Ë§µË§≥Ë§ºË§æË•ÅË•íË§∑Ë•ÇË¶≠Ë¶ØË¶ÆËß≤Ëß≥Ë¨û"],["eea1","Ë¨òË¨ñË¨ëË¨ÖË¨ãË¨¢Ë¨èË¨íË¨ïË¨áË¨çË¨àË¨ÜË¨úË¨ìË¨öË±èË±∞Ë±≤Ë±±Ë±ØË≤ïË≤îË≥πËµØËπéËπçËπìËπêËπåËπáËΩÉËΩÄÈÇÖÈÅæÈÑ∏ÈÜöÈÜ¢ÈÜõÈÜôÈÜüÈÜ°ÈÜùÈÜ†Èé°ÈéÉÈéØÈç§ÈçñÈçáÈçºÈçòÈçúÈç∂ÈçâÈçêÈçëÈç†Èç≠ÈéèÈçåÈç™ÈçπÈçóÈçïÈçíÈçèÈç±Èç∑ÈçªÈç°ÈçûÈç£ÈçßÈéÄÈçéÈçôÈóáÈóÄÈóâÈóÉÈóÖÈñ∑ÈöÆÈö∞Èö¨Èú†ÈúüÈúòÈúùÈúôÈûöÈû°Èûú"],["ef40","ÈûûÈûùÈüïÈüîÈü±È°ÅÈ°ÑÈ°äÈ°âÈ°ÖÈ°ÉÈ§•È§´È§¨È§™È§≥È§≤È§ØÈ§≠È§±È§∞È¶òÈ¶£È¶°È®ÇÈß∫Èß¥Èß∑ÈßπÈß∏Èß∂ÈßªÈßΩÈßæÈßºÈ®ÉÈ™æÈ´æÈ´ΩÈ¨ÅÈ´ºÈ≠àÈÆöÈÆ®ÈÆûÈÆõÈÆ¶ÈÆ°ÈÆ•ÈÆ§ÈÆÜÈÆ¢ÈÆ†ÈÆØÈ¥≥ÈµÅÈµßÈ¥∂È¥ÆÈ¥ØÈ¥±È¥∏È¥∞"],["efa1","ÈµÖÈµÇÈµÉÈ¥æÈ¥∑ÈµÄÈ¥ΩÁøµÈ¥≠È∫äÈ∫âÈ∫çÈ∫∞ÈªàÈªöÈªªÈªøÈº§Èº£Èº¢ÈΩîÈæ†ÂÑ±ÂÑ≠ÂÑÆÂöòÂöúÂöóÂööÂöùÂöôÂ•∞Â¨ºÂ±©Â±™Â∑ÄÂπ≠ÂπÆÊáòÊáüÊá≠ÊáÆÊá±Êá™Êá∞Êá´ÊáñÊá©ÊìøÊîÑÊìΩÊì∏ÊîÅÊîÉÊìºÊñîÊóõÊõöÊõõÊõòÊ´ÖÊ™πÊ™ΩÊ´°Ê´ÜÊ™∫Ê™∂Ê™∑Ê´áÊ™¥Ê™≠Ê≠ûÊØâÊ∞ãÁÄáÁÄåÁÄçÁÄÅÁÄÖÁÄîÁÄéÊøøÁÄÄÊøªÁÄ¶ÊøºÊø∑ÁÄäÁàÅÁáøÁáπÁàÉÁáΩÁç∂"],["f040","Áí∏ÁìÄÁíµÁìÅÁíæÁí∂ÁíªÁìÇÁîîÁîìÁôúÁô§ÁôôÁôêÁôìÁôóÁôöÁö¶ÁöΩÁõ¨ÁüÇÁû∫Á£øÁ§åÁ§ìÁ§îÁ§âÁ§êÁ§íÁ§ëÁ¶≠Á¶¨Á©üÁ∞úÁ∞©Á∞ôÁ∞†Á∞üÁ∞≠Á∞ùÁ∞¶Á∞®Á∞¢Á∞•Á∞∞ÁπúÁπêÁπñÁπ£ÁπòÁπ¢ÁπüÁπëÁπ†ÁπóÁπìÁæµÁæ≥Áø∑Áø∏ËÅµËáëËáí"],["f0a1","ËáêËâüËâûËñ¥ËóÜËóÄËóÉËóÇËñ≥ËñµËñΩËóáËóÑËñøËóãËóéËóàËóÖËñ±Ëñ∂ËóíËò§Ëñ∏Ëñ∑ËñæËô©ËüßËü¶Ëü¢ËüõËü´Ëü™Ëü•ËüüËü≥Ëü§ËüîËüúËüìËü≠ËüòËü£Ëû§ËüóËüôË†ÅËü¥Ëü®ËüùË•ìË•ãË•èË•åË•ÜË•êË•ëË•âË¨™Ë¨ßË¨£Ë¨≥Ë¨∞Ë¨µË≠áË¨ØË¨ºË¨æË¨±Ë¨•Ë¨∑Ë¨¶Ë¨∂Ë¨ÆË¨§Ë¨ªË¨ΩË¨∫Ë±ÇË±µË≤ôË≤òË≤óË≥æË¥ÑË¥ÇË¥ÄËπúËπ¢Ëπ†ËπóËπñËπûËπ•Ëπß"],["f140","ËπõËπöËπ°ËπùËπ©ËπîËΩÜËΩáËΩàËΩãÈÑ®ÈÑ∫ÈÑªÈÑæÈÜ®ÈÜ•ÈÜßÈÜØÈÜ™ÈéµÈéåÈéíÈé∑ÈéõÈéùÈéâÈéßÈééÈé™ÈéûÈé¶ÈéïÈéàÈéôÈéüÈéçÈé±ÈéëÈé≤Èé§Èé®Èé¥Èé£Èé•ÈóíÈóìÈóëÈö≥ÈõóÈõöÂ∑ÇÈõüÈõòÈõùÈú£Èú¢Èú•Èû¨ÈûÆÈû®Èû´Èû§Èû™"],["f1a1","Èû¢Èû•ÈüóÈüôÈüñÈüòÈü∫È°êÈ°ëÈ°íÈ¢∏È•ÅÈ§ºÈ§∫È®èÈ®ãÈ®âÈ®çÈ®ÑÈ®ëÈ®äÈ®ÖÈ®áÈ®ÜÈ´ÄÈ´úÈ¨àÈ¨ÑÈ¨ÖÈ¨©È¨µÈ≠äÈ≠åÈ≠ãÈØáÈØÜÈØÉÈÆøÈØÅÈÆµÈÆ∏ÈØìÈÆ∂ÈØÑÈÆπÈÆΩÈµúÈµìÈµèÈµäÈµõÈµãÈµôÈµñÈµåÈµóÈµíÈµîÈµüÈµòÈµöÈ∫éÈ∫åÈªüÈºÅÈºÄÈºñÈº•Èº´Èº™Èº©Èº®ÈΩåÈΩïÂÑ¥ÂÑµÂäñÂã∑Âé¥Âö´Âö≠Âö¶ÂößÂö™Âö¨Â£öÂ£ùÂ£õÂ§íÂ¨ΩÂ¨æÂ¨øÂ∑ÉÂπ∞"],["f240","ÂæøÊáªÊîáÊîêÊîçÊîâÊîåÊîéÊñÑÊóûÊóùÊõûÊ´ßÊ´†Ê´åÊ´ëÊ´ôÊ´ãÊ´üÊ´úÊ´êÊ´´Ê´èÊ´çÊ´ûÊ≠†ÊÆ∞Ê∞åÁÄôÁÄßÁÄ†ÁÄñÁÄ´ÁÄ°ÁÄ¢ÁÄ£ÁÄ©ÁÄóÁÄ§ÁÄúÁÄ™ÁàåÁàäÁàáÁàÇÁàÖÁä•Áä¶Áä§Áä£Áä°ÁìãÁìÖÁí∑ÁìÉÁîñÁô†ÁüâÁüäÁüÑÁü±Á§ùÁ§õ"],["f2a1","Á§°Á§úÁ§óÁ§ûÁ¶∞Á©ßÁ©®Á∞≥Á∞ºÁ∞πÁ∞¨Á∞ªÁ≥¨Á≥™Áπ∂ÁπµÁπ∏Áπ∞Áπ∑ÁπØÁπ∫Áπ≤Áπ¥Áπ®ÁΩãÁΩäÁæÉÁæÜÁæ∑ÁøΩÁøæËÅ∏ËáóËáïËâ§Ëâ°Ëâ£Ëó´Ëó±Ëó≠ËóôËó°Ëó®ËóöËóóËó¨Ëó≤Ëó∏ËóòËóüËó£ËóúËóëËó∞Ëó¶ËóØËóûËó¢Ë†ÄËü∫Ë†ÉËü∂Ëü∑Ë†âË†åË†ãË†ÜËüºË†àËüøË†äË†ÇË•¢Ë•öË•õË•óË•°Ë•úË•òË•ùË•ôË¶àË¶∑Ë¶∂Ëß∂Ë≠êË≠àË≠äË≠ÄË≠ìË≠ñË≠îË≠ãË≠ï"],["f340","Ë≠ëË≠ÇË≠íË≠óË±ÉË±∑Ë±∂Ë≤öË¥ÜË¥áË¥âË∂¨Ë∂™Ë∂≠Ë∂´Ëπ≠Ëπ∏Ëπ≥Ëπ™ËπØËπªËªÇËΩíËΩëËΩèËΩêËΩìËæ¥ÈÖÄÈÑøÈÜ∞ÈÜ≠ÈèûÈèáÈèèÈèÇÈèöÈèêÈèπÈè¨ÈèåÈèôÈé©Èè¶ÈèäÈèîÈèÆÈè£ÈèïÈèÑÈèéÈèÄÈèíÈèßÈïΩÈóöÈóõÈõ°Èú©Èú´Èú¨Èú®Èú¶"],["f3a1","Èû≥Èû∑Èû∂ÈüùÈüûÈüüÈ°úÈ°ôÈ°ùÈ°óÈ¢øÈ¢ΩÈ¢ªÈ¢æÈ•àÈ•áÈ•ÉÈ¶¶È¶ßÈ®öÈ®ïÈ®•È®ùÈ®§È®õÈ®¢È®†È®ßÈ®£È®ûÈ®úÈ®îÈ´ÇÈ¨ãÈ¨äÈ¨éÈ¨åÈ¨∑ÈØ™ÈØ´ÈØ†ÈØûÈØ§ÈØ¶ÈØ¢ÈØ∞ÈØîÈØóÈØ¨ÈØúÈØôÈØ•ÈØïÈØ°ÈØöÈµ∑È∂ÅÈ∂äÈ∂ÑÈ∂àÈµ±È∂ÄÈµ∏È∂ÜÈ∂ãÈ∂åÈµΩÈµ´Èµ¥ÈµµÈµ∞Èµ©È∂ÖÈµ≥ÈµªÈ∂ÇÈµØÈµπÈµøÈ∂áÈµ®È∫îÈ∫ëÈªÄÈªºÈº≠ÈΩÄÈΩÅÈΩçÈΩñÈΩóÈΩòÂå∑Âö≤"],["f440","ÂöµÂö≥Â££Â≠ÖÂ∑ÜÂ∑áÂªÆÂªØÂøÄÂøÅÊáπÊîóÊîñÊîïÊîìÊóüÊõ®Êõ£Êõ§Ê´≥Ê´∞Ê´™Ê´®Ê´πÊ´±Ê´ÆÊ´ØÁÄºÁÄµÁÄØÁÄ∑ÁÄ¥ÁÄ±ÁÅÇÁÄ∏ÁÄøÁÄ∫ÁÄπÁÅÄÁÄªÁÄ≥ÁÅÅÁàìÁàîÁä®ÁçΩÁçºÁí∫Áö´Áö™ÁöæÁõ≠ÁüåÁüéÁüèÁüçÁü≤Á§•Á§£Á§ßÁ§®Á§§Á§©"],["f4a1","Á¶≤Á©ÆÁ©¨Á©≠Á´∑Á±âÁ±àÁ±äÁ±áÁ±ÖÁ≥ÆÁπªÁπæÁ∫ÅÁ∫ÄÁæ∫ÁøøËÅπËáõËáôËàãËâ®Ëâ©Ëò¢ËóøËòÅËóæËòõËòÄËó∂ËòÑËòâËòÖËòåËóΩË†ôË†êË†ëË†óË†ìË†ñË•£Ë•¶Ë¶πËß∑Ë≠†Ë≠™Ë≠ùË≠®Ë≠£Ë≠•Ë≠ßË≠≠Ë∂ÆË∫ÜË∫àË∫ÑËΩôËΩñËΩóËΩïËΩòËΩöÈÇçÈÖÉÈÖÅÈÜ∑ÈÜµÈÜ≤ÈÜ≥ÈêãÈêìÈèªÈê†ÈêèÈêîÈèæÈêïÈêêÈê®ÈêôÈêçÈèµÈêÄÈè∑ÈêáÈêéÈêñÈêíÈè∫ÈêâÈè∏ÈêäÈèø"],["f540","ÈèºÈêåÈè∂ÈêëÈêÜÈóûÈó†ÈóüÈúÆÈúØÈûπÈûªÈüΩÈüæÈ°†È°¢È°£È°üÈ£ÅÈ£ÇÈ•êÈ•éÈ•ôÈ•åÈ•ãÈ•ìÈ®≤È®¥È®±È®¨È®™È®∂È®©È®ÆÈ®∏È®≠È´áÈ´äÈ´ÜÈ¨êÈ¨íÈ¨ëÈ∞ãÈ∞àÈØ∑È∞ÖÈ∞íÈØ∏È±ÄÈ∞áÈ∞éÈ∞ÜÈ∞óÈ∞îÈ∞âÈ∂üÈ∂ôÈ∂§È∂ùÈ∂íÈ∂òÈ∂êÈ∂õ"],["f5a1","È∂†È∂îÈ∂úÈ∂™È∂óÈ∂°È∂öÈ∂¢È∂®È∂ûÈ∂£È∂øÈ∂©È∂ñÈ∂¶È∂ßÈ∫ôÈ∫õÈ∫öÈª•Èª§ÈªßÈª¶Èº∞ÈºÆÈΩõÈΩ†ÈΩûÈΩùÈΩôÈæëÂÑ∫ÂÑπÂäòÂäóÂõÉÂöΩÂöæÂ≠àÂ≠áÂ∑ãÂ∑èÂª±ÊáΩÊîõÊ¨ÇÊ´ºÊ¨ÉÊ´∏Ê¨ÄÁÅÉÁÅÑÁÅäÁÅàÁÅâÁÅÖÁÅÜÁàùÁàöÁàôÁçæÁîóÁô™ÁüêÁ§≠Á§±Á§ØÁ±îÁ±ìÁ≥≤Á∫äÁ∫áÁ∫àÁ∫ãÁ∫ÜÁ∫çÁΩçÁæªËÄ∞ËáùËòòËò™Ëò¶ËòüËò£ËòúËòôËòßËòÆËò°Ëò†Ëò©ËòûËò•"],["f640","Ë†©Ë†ùË†õË††Ë†§Ë†úË†´Ë°äË•≠Ë•©Ë•ÆË•´Ëß∫Ë≠πË≠∏Ë≠ÖË≠∫Ë≠ªË¥êË¥îË∂ØË∫éË∫åËΩûËΩõËΩùÈÖÜÈÖÑÈÖÖÈÜπÈêøÈêªÈê∂Èê©ÈêΩÈêºÈê∞ÈêπÈê™Èê∑Èê¨ÈëÄÈê±Èó•Èó§Èó£ÈúµÈú∫ÈûøÈü°È°§È£âÈ£ÜÈ£ÄÈ•òÈ•ñÈ®πÈ®ΩÈ©ÜÈ©ÑÈ©ÇÈ©ÅÈ®∫"],["f6a1","È®øÈ´çÈ¨ïÈ¨óÈ¨òÈ¨ñÈ¨∫È≠íÈ∞´È∞ùÈ∞úÈ∞¨È∞£È∞®È∞©È∞§È∞°È∂∑È∂∂È∂ºÈ∑ÅÈ∑áÈ∑äÈ∑èÈ∂æÈ∑ÖÈ∑ÉÈ∂ªÈ∂µÈ∑éÈ∂πÈ∂∫È∂¨È∑àÈ∂±È∂≠È∑åÈ∂≥È∑çÈ∂≤Èπ∫È∫úÈª´ÈªÆÈª≠ÈºõÈºòÈºöÈº±ÈΩéÈΩ•ÈΩ§Èæí‰∫πÂõÜÂõÖÂõãÂ•±Â≠ãÂ≠åÂ∑ïÂ∑ëÂª≤Êî°Êî†Êî¶Êî¢Ê¨ãÊ¨àÊ¨âÊ∞çÁÅïÁÅñÁÅóÁÅíÁàûÁàüÁä©ÁçøÁìòÁìïÁìôÁìóÁô≠Áö≠Á§µÁ¶¥Á©∞Á©±Á±óÁ±úÁ±ôÁ±õÁ±ö"],["f740","Á≥¥Á≥±Á∫ëÁΩèÁæáËáûËâ´Ëò¥ËòµËò≥Ëò¨Ëò≤Ëò∂Ë†¨Ë†®Ë†¶Ë†™Ë†•Ë•±Ë¶øË¶æËßªË≠æËÆÑËÆÇËÆÜËÆÖË≠øË¥ïË∫ïË∫îË∫öË∫íË∫êË∫ñË∫óËΩ†ËΩ¢ÈÖáÈëåÈëêÈëäÈëãÈëèÈëáÈëÖÈëàÈëâÈëÜÈúøÈü£È°™È°©È£ãÈ•îÈ•õÈ©éÈ©ìÈ©îÈ©åÈ©èÈ©àÈ©ä"],["f7a1","È©âÈ©íÈ©êÈ´êÈ¨ôÈ¨´È¨ªÈ≠ñÈ≠ïÈ±ÜÈ±àÈ∞øÈ±ÑÈ∞πÈ∞≥È±ÅÈ∞ºÈ∞∑È∞¥È∞≤È∞ΩÈ∞∂È∑õÈ∑íÈ∑ûÈ∑öÈ∑ãÈ∑êÈ∑úÈ∑ëÈ∑üÈ∑©È∑ôÈ∑òÈ∑ñÈ∑µÈ∑ïÈ∑ùÈ∫∂Èª∞ÈºµÈº≥Èº≤ÈΩÇÈΩ´ÈæïÈæ¢ÂÑΩÂäôÂ£®Â£ßÂ•≤Â≠çÂ∑òË†ØÂΩèÊàÅÊàÉÊàÑÊî©Êî•ÊññÊõ´Ê¨ëÊ¨íÊ¨èÊØäÁÅõÁÅöÁà¢ÁéÇÁéÅÁéÉÁô∞ÁüîÁ±ßÁ±¶Á∫ïËâ¨Ëò∫ËôÄËòπËòºËò±ËòªËòæË†∞Ë†≤Ë†ÆË†≥Ë•∂Ë•¥Ë•≥Ëßæ"],["f840","ËÆåËÆéËÆãËÆàË±ÖË¥ôË∫òËΩ§ËΩ£ÈÜºÈë¢ÈëïÈëùÈëóÈëûÈüÑÈüÖÈ†ÄÈ©ñÈ©ôÈ¨ûÈ¨üÈ¨†È±íÈ±òÈ±êÈ±äÈ±çÈ±ãÈ±ïÈ±ôÈ±åÈ±éÈ∑ªÈ∑∑È∑ØÈ∑£È∑´È∑∏È∑§È∑∂È∑°È∑ÆÈ∑¶È∑≤È∑∞È∑¢È∑¨È∑¥È∑≥È∑®È∑≠ÈªÇÈªêÈª≤Èª≥ÈºÜÈºúÈº∏Èº∑Èº∂ÈΩÉÈΩè"],["f8a1","ÈΩ±ÈΩ∞ÈΩÆÈΩØÂõìÂõçÂ≠éÂ±≠Êî≠Êõ≠ÊõÆÊ¨ìÁÅüÁÅ°ÁÅùÁÅ†Áà£ÁìõÁì•ÁüïÁ§∏Á¶∑Á¶∂Á±™Á∫óÁæâËâ≠ËôÉË†∏Ë†∑Ë†µË°ãËÆîËÆïË∫ûË∫üË∫†Ë∫ùÈÜæÈÜΩÈáÇÈë´Èë®Èë©Èõ•ÈùÜÈùÉÈùáÈüáÈü•È©ûÈ´ïÈ≠ôÈ±£È±ßÈ±¶È±¢È±ûÈ±†È∏ÇÈ∑æÈ∏áÈ∏ÉÈ∏ÜÈ∏ÖÈ∏ÄÈ∏ÅÈ∏âÈ∑øÈ∑ΩÈ∏ÑÈ∫†ÈºûÈΩÜÈΩ¥ÈΩµÈΩ∂ÂõîÊîÆÊñ∏Ê¨òÊ¨ôÊ¨óÊ¨öÁÅ¢Áà¶Áä™ÁüòÁüôÁ§πÁ±©Á±´Á≥∂Á∫ö"],["f940","Á∫òÁ∫õÁ∫ôËá†Ëá°ËôÜËôáËôàË•πË•∫Ë•ºË•ªËßøËÆòËÆôË∫•Ë∫§Ë∫£ÈëÆÈë≠ÈëØÈë±Èë≥ÈùâÈ°≤È•üÈ±®È±ÆÈ±≠È∏ãÈ∏çÈ∏êÈ∏èÈ∏íÈ∏ëÈ∫°ÈªµÈºâÈΩáÈΩ∏ÈΩªÈΩ∫ÈΩπÂúûÁÅ¶Á±ØË†ºË∂≤Ë∫¶ÈáÉÈë¥Èë∏Èë∂ÈëµÈ©†È±¥È±≥È±±È±µÈ∏îÈ∏ìÈª∂Èºä"],["f9a1","Èæ§ÁÅ®ÁÅ•Á≥∑Ëô™Ë†æË†ΩË†øËÆûË≤úË∫©ËªâÈùãÈ°≥È°¥È£åÈ•°È¶´È©§È©¶È©ßÈ¨§È∏ïÈ∏óÈΩàÊàáÊ¨ûÁàßËôåË∫®ÈíÇÈíÄÈíÅÈ©©È©®È¨ÆÈ∏ôÁà©ËôãËÆüÈíÉÈ±πÈ∫∑ÁôµÈ©´È±∫È∏ùÁÅ©ÁÅ™È∫§ÈΩæÈΩâÈæòÁ¢ÅÈäπË£èÂ¢ªÊÅíÁ≤ßÂ´∫‚ïî‚ï¶‚ïó‚ï†‚ï¨‚ï£‚ïö‚ï©‚ïù‚ïí‚ï§‚ïï‚ïû‚ï™‚ï°‚ïò‚ïß‚ïõ‚ïì‚ï•‚ïñ‚ïü‚ï´‚ï¢‚ïô‚ï®‚ïú‚ïë‚ïê‚ï≠‚ïÆ‚ï∞‚ïØ‚ñì"]]');

/***/ }),

/***/ 5520:
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('[["0","\\u0000",127],["8ea1","ÔΩ°",62],["a1a1","„ÄÄ„ÄÅ„ÄÇÔºåÔºé„ÉªÔºöÔºõÔºüÔºÅ„Çõ„Çú¬¥ÔΩÄ¬®ÔºæÔø£Ôºø„ÉΩ„Éæ„Çù„Çû„ÄÉ‰ªù„ÄÖ„ÄÜ„Äá„Éº‚Äï‚ÄêÔºèÔººÔΩû‚à•ÔΩú‚Ä¶‚Ä•‚Äò‚Äô‚Äú‚ÄùÔºàÔºâ„Äî„ÄïÔºªÔºΩÔΩõÔΩù„Äà",9,"ÔºãÔºç¬±√ó√∑Ôºù‚â†ÔºúÔºû‚â¶‚âß‚àû‚à¥‚ôÇ‚ôÄ¬∞‚Ä≤‚Ä≥‚ÑÉÔø•ÔºÑÔø†Ôø°ÔºÖÔºÉÔºÜÔºäÔº†¬ß‚òÜ‚òÖ‚óã‚óè‚óé‚óá"],["a2a1","‚óÜ‚ñ°‚ñ†‚ñ≥‚ñ≤‚ñΩ‚ñº‚Äª„Äí‚Üí‚Üê‚Üë‚Üì„Äì"],["a2ba","‚àà‚àã‚äÜ‚äá‚äÇ‚äÉ‚à™‚à©"],["a2ca","‚àß‚à®Ôø¢‚áí‚áî‚àÄ‚àÉ"],["a2dc","‚à†‚ä•‚åí‚àÇ‚àá‚â°‚âí‚â™‚â´‚àö‚àΩ‚àù‚àµ‚à´‚à¨"],["a2f2","‚Ñ´‚Ä∞‚ôØ‚ô≠‚ô™‚Ä†‚Ä°¬∂"],["a2fe","‚óØ"],["a3b0","Ôºê",9],["a3c1","Ôº°",25],["a3e1","ÔΩÅ",25],["a4a1","„ÅÅ",82],["a5a1","„Ç°",85],["a6a1","Œë",16,"Œ£",6],["a6c1","Œ±",16,"œÉ",6],["a7a1","–ê",5,"–Å–ñ",25],["a7d1","–∞",5,"—ë–∂",25],["a8a1","‚îÄ‚îÇ‚îå‚îê‚îò‚îî‚îú‚î¨‚î§‚î¥‚îº‚îÅ‚îÉ‚îè‚îì‚îõ‚îó‚î£‚î≥‚î´‚îª‚ïã‚î†‚îØ‚î®‚î∑‚îø‚îù‚î∞‚î•‚î∏‚ïÇ"],["ada1","‚ë†",19,"‚Ö†",9],["adc0","„çâ„åî„å¢„çç„åò„åß„åÉ„å∂„çë„çó„åç„å¶„å£„å´„çä„åª„éú„éù„éû„éé„éè„èÑ„é°"],["addf","„çª„Äù„Äü‚Ññ„èç‚Ñ°„ä§",4,"„à±„à≤„àπ„çæ„çΩ„çº‚âí‚â°‚à´‚àÆ‚àë‚àö‚ä•‚à†‚àü‚äø‚àµ‚à©‚à™"],["b0a1","‰∫úÂîñÂ®ÉÈòøÂìÄÊÑõÊå®Âß∂ÈÄ¢ËëµËåúÁ©êÊÇ™Êè°Ê∏•Êó≠Ëë¶Ëä¶ÈØµÊ¢ìÂúßÊñ°Êâ±ÂÆõÂßêËôªÈ£¥Áµ¢Á∂æÈÆéÊàñÁ≤üË¢∑ÂÆâÂ∫µÊåâÊöóÊ°àÈóáÈûçÊùè‰ª•‰ºä‰Ωç‰æùÂÅâÂõ≤Â§∑ÂßîÂ®ÅÂ∞âÊÉüÊÑèÊÖ∞ÊòìÊ§ÖÁÇ∫ÁïèÁï∞ÁßªÁ∂≠Á∑ØËÉÉËêéË°£Ë¨ÇÈÅïÈÅ∫Âåª‰∫ï‰∫•ÂüüËÇ≤ÈÉÅÁ£Ø‰∏ÄÂ£±Ê∫¢ÈÄ∏Á®≤Ëå®ËäãÈ∞ØÂÖÅÂç∞ÂíΩÂì°Âõ†ÂßªÂºïÈ£≤Ê∑´ËÉ§Ëî≠"],["b1a1","Èô¢Èô∞Èö†ÈüªÂêãÂè≥ÂÆáÁÉèÁæΩËøÇÈõ®ÂçØÈµúÁ™∫‰∏ëÁ¢ìËáºÊ∏¶ÂòòÂîÑÊ¨ùËîöÈ∞ªÂß•Âé©Êµ¶ÁìúÈñèÂôÇ‰∫ëÈÅãÈõ≤ËçèÈ§åÂè°Âñ∂Â¨∞ÂΩ±Êò†Êõ≥Ê†ÑÊ∞∏Ê≥≥Ê¥©ÁëõÁõàÁ©éÈ†¥Ëã±Ë°õË©†Èã≠Ê∂≤Áñ´ÁõäÈßÖÊÇ¶Ë¨ÅË∂äÈñ≤Ê¶éÂé≠ÂÜÜÂúíÂ†∞Â•ÑÂÆ¥Âª∂ÊÄ®Êé©Êè¥Ê≤øÊºîÁÇéÁÑîÁÖôÁáïÁåøÁ∏ÅËâ∂ËãëËñóÈÅ†ÈâõÈ¥õÂ°©ÊñºÊ±öÁî•ÂáπÂ§ÆÂ••ÂæÄÂøú"],["b2a1","ÊäºÊó∫Ê®™Ê¨ßÊÆ¥ÁéãÁøÅË•ñÈ¥¨È¥éÈªÑÂ≤°Ê≤ñËçªÂÑÑÂ±ãÊÜ∂ËáÜÊ°∂Áâ°‰πô‰ø∫Âç∏ÊÅ©Ê∏©Á©èÈü≥‰∏ãÂåñ‰ªÆ‰Ωï‰ºΩ‰æ°‰Ω≥Âä†ÂèØÂòâÂ§èÂ´ÅÂÆ∂ÂØ°ÁßëÊöáÊûúÊû∂Ê≠åÊ≤≥ÁÅ´ÁèÇÁ¶çÁ¶æÁ®ºÁÆáËä±ËãõËåÑËç∑ËèØËèìËù¶Ë™≤Âò©Ë≤®Ëø¶ÈÅéÈúûËöä‰øÑÂ≥®ÊàëÁâôÁîªËá•ËäΩËõæË≥ÄÈõÖÈ§ìÈßï‰ªã‰ºöËß£ÂõûÂ°äÂ£äÂªªÂø´ÊÄ™ÊÇîÊÅ¢ÊáêÊàíÊãêÊîπ"],["b3a1","È≠ÅÊô¶Ê¢∞Êµ∑ÁÅ∞ÁïåÁöÜÁµµËä•ËüπÈñãÈöéË≤ùÂá±ÂäæÂ§ñÂí≥ÂÆ≥Â¥ñÊÖ®Ê¶ÇÊ∂ØÁ¢çËìãË°óË©≤ÈéßÈ™∏Êµ¨È¶®ËõôÂû£ÊüøËõéÈàéÂäÉÂöáÂêÑÂªìÊã°ÊíπÊ†ºÊ†∏ÊÆªÁç≤Á¢∫Á©´Ë¶öËßíËµ´ËºÉÈÉ≠Èñ£ÈöîÈù©Â≠¶Â≤≥Ê•ΩÈ°çÈ°éÊéõÁ¨†Ê®´Ê©øÊ¢∂È∞çÊΩüÂâ≤ÂñùÊÅ∞Êã¨Ê¥ªÊ∏áÊªëËëõË§êËΩÑ‰∏îÈ∞πÂè∂Ê§õÊ®∫ÈûÑÊ†™ÂÖúÁ´ÉËí≤ÈáúÈéåÂôõÈ¥®Ê†¢ËåÖËê±"],["b4a1","Á≤•ÂààËãÖÁì¶‰πæ‰æÉÂÜ†ÂØíÂàäÂãòÂãßÂ∑ªÂñöÂ†™Âß¶ÂÆåÂÆòÂØõÂπ≤ÂππÊÇ£ÊÑüÊÖ£ÊÜæÊèõÊï¢ÊüëÊ°ìÊ£∫Ê¨æÊ≠ìÊ±óÊº¢ÊæóÊΩÖÁí∞ÁîòÁõ£ÁúãÁ´øÁÆ°Á∞°Á∑©Áº∂Áø∞ËÇùËâ¶ËéûË¶≥Ë´åË≤´ÈÇÑÈëëÈñìÈñëÈñ¢Èô•ÈüìÈ§®Ëàò‰∏∏Âê´Â≤∏Â∑åÁé©ÁôåÁúºÂ≤©Áø´Ë¥ãÈõÅÈ†ëÈ°îÈ°ò‰ºÅ‰ºéÂç±ÂñúÂô®Âü∫Â•áÂ¨âÂØÑÂ≤êÂ∏åÂπæÂøåÊèÆÊú∫ÊóóÊó¢ÊúüÊ£ãÊ£Ñ"],["b5a1","Ê©üÂ∏∞ÊØÖÊ∞óÊ±ΩÁïøÁ•àÂ≠£Á®ÄÁ¥ÄÂæΩË¶èË®òË≤¥Ëµ∑ËªåËºùÈ£¢È®éÈ¨º‰∫ÄÂÅΩÂÑÄÂ¶ìÂÆúÊàØÊäÄÊì¨Ê¨∫Áä†ÁñëÁ•áÁæ©ËüªË™ºË≠∞Êé¨ËèäÈû†ÂêâÂêÉÂñ´Ê°îÊ©òË©∞Á†ßÊùµÈªçÂç¥ÂÆ¢ËÑöËôêÈÄÜ‰∏ò‰πÖ‰ªá‰ºëÂèäÂê∏ÂÆÆÂºìÊÄ•ÊïëÊúΩÊ±ÇÊ±≤Ê≥£ÁÅ∏ÁêÉÁ©∂Á™ÆÁ¨àÁ¥öÁ≥æÁµ¶ÊóßÁâõÂéªÂ±ÖÂ∑®ÊãíÊã†ÊåôÊ∏†ËôöË®±Ë∑ùÈã∏ÊºÅÁ¶¶È≠ö‰∫®‰∫´‰∫¨"],["b6a1","‰æõ‰æ†ÂÉëÂÖáÁ´∂ÂÖ±Âá∂ÂçîÂå°ÂçøÂè´Âñ¨Â¢ÉÂ≥°Âº∑ÂΩäÊÄØÊÅêÊÅ≠ÊåüÊïôÊ©ãÊ≥ÅÁãÇÁã≠ÁüØËÉ∏ËÑÖËààËïéÈÉ∑Èè°ÈüøÈ•óÈ©ö‰ª∞ÂáùÂ∞≠ÊöÅÊ•≠Â±ÄÊõ≤Ê•µÁéâÊ°êÁ≤ÅÂÉÖÂã§ÂùáÂ∑æÈå¶Êñ§Ê¨£Ê¨ΩÁê¥Á¶ÅÁ¶ΩÁ≠ãÁ∑äËäπËèåË°øË•üË¨πËøëÈáëÂêüÈäÄ‰πùÂÄ∂Âè•Âå∫ÁãóÁéñÁü©Ëã¶Ë∫ØÈßÜÈßàÈßíÂÖ∑ÊÑöËôûÂñ∞Á©∫ÂÅ∂ÂØìÈÅáÈöÖ‰∏≤Ê´õÈáßÂ±ëÂ±à"],["b7a1","ÊéòÁ™üÊ≤ìÈù¥ËΩ°Á™™ÁÜäÈöàÁ≤ÇÊ†óÁπ∞Ê°ëÈç¨Âã≤ÂêõËñ´Ë®ìÁæ§ËªçÈÉ°Âç¶Ë¢àÁ•Å‰øÇÂÇæÂàëÂÖÑÂïìÂú≠Áè™ÂûãÂ•ëÂΩ¢ÂæÑÊÅµÊÖ∂ÊÖßÊÜ©Êé≤Êê∫Êï¨ÊôØÊ°ÇÊ∏ìÁï¶Á®ΩÁ≥ªÁµåÁ∂ôÁπãÁΩ´ËåéËçäËõçË®àË©£Ë≠¶ËªΩÈ†öÈ∂èËä∏ËøéÈØ®ÂäáÊàüÊíÉÊøÄÈöôÊ°ÅÂÇëÊ¨†Ê±∫ÊΩîÁ©¥ÁµêË°ÄË®£Êúà‰ª∂ÂÄπÂÄ¶ÂÅ•ÂÖºÂà∏Ââ£ÂñßÂúèÂ†ÖÂ´åÂª∫ÊÜ≤Êá∏Êã≥Êç≤"],["b8a1","Ê§úÊ®©ÁâΩÁä¨ÁåÆÁ†îÁ°ØÁµπÁúåËÇ©Ë¶ãË¨ôË≥¢ËªíÈÅ£ÈçµÈô∫È°ïÈ®ìÈπ∏ÂÖÉÂéüÂé≥ÂπªÂº¶Ê∏õÊ∫êÁéÑÁèæÁµÉËà∑Ë®ÄË´∫Èôê‰πéÂÄãÂè§ÂëºÂõ∫ÂßëÂ≠§Â∑±Â∫´ÂºßÊà∏ÊïÖÊûØÊπñÁãêÁ≥äË¢¥ËÇ°ËÉ°Ëè∞ËôéË™áË∑®Èà∑ÈõáÈ°ßÈºì‰∫î‰∫í‰ºçÂçàÂëâÂêæÂ®ØÂæåÂæ°ÊÇüÊ¢ßÊ™éÁëöÁ¢ÅË™ûË™§Ë≠∑ÈÜê‰πûÈØâ‰∫§‰Ωº‰æØÂÄôÂÄñÂÖâÂÖ¨ÂäüÂäπÂãæÂéöÂè£Âêë"],["b9a1","ÂêéÂñâÂùëÂû¢Â•ΩÂ≠îÂ≠ùÂÆèÂ∑•Â∑ßÂ∑∑Âπ∏Â∫ÉÂ∫öÂ∫∑ÂºòÊÅíÊÖåÊäóÊãòÊéßÊîªÊòÇÊôÉÊõ¥Êù≠Ê†°Ê¢óÊßãÊ±üÊ¥™Êµ©Ê∏ØÊ∫ùÁî≤ÁöáÁ°¨Á®øÁ≥†Á¥ÖÁ¥òÁµûÁ∂±ËÄïËÄÉËÇØËÇ±ËÖîËÜèËà™ËçíË°åË°°Ë¨õË≤¢Ë≥ºÈÉäÈÖµÈâ±Á†øÈãºÈñ§ÈôçÈ†ÖÈ¶ôÈ´òÈ¥ªÂâõÂä´Âè∑ÂêàÂ£ïÊã∑Êø†Ë±™ËΩüÈ∫πÂÖãÂàªÂëäÂõΩÁ©ÄÈÖ∑Èµ†ÈªíÁçÑÊºâËÖ∞ÁîëÂøΩÊÉöÈ™®ÁãõËæº"],["baa1","Ê≠§È†É‰ªäÂõ∞Âù§Â¢æÂ©öÊÅ®ÊááÊòèÊòÜÊ†πÊ¢±Ê∑∑ÁóïÁ¥∫ËâÆÈ≠Ç‰∫õ‰ΩêÂèâÂîÜÂµØÂ∑¶Â∑ÆÊüªÊ≤ôÁë≥Á†ÇË©êÈéñË£üÂùêÂ∫ßÊå´ÂÇµÂÇ¨ÂÜçÊúÄÂìâÂ°ûÂ¶ªÂÆ∞ÂΩ©ÊâçÊé°Ê†ΩÊ≠≥Ê∏àÁÅΩÈááÁäÄÁ†ïÁ†¶Á•≠ÊñéÁ¥∞ËèúË£ÅËºâÈöõÂâ§Âú®ÊùêÁΩ™Ë≤°ÂÜ¥ÂùÇÈò™Â†∫Ê¶äËÇ¥Âí≤Â¥éÂüºÁ¢ïÈ∑∫‰ΩúÂâäÂíãÊêæÊò®ÊúîÊüµÁ™ÑÁ≠ñÁ¥¢ÈåØÊ°úÈÆ≠Á¨πÂåôÂÜäÂà∑"],["bba1","ÂØüÊã∂ÊíÆÊì¶Êú≠ÊÆ∫Ëñ©ÈõëÁöêÈØñÊçåÈåÜÈÆ´ÁöøÊôí‰∏âÂÇòÂèÇÂ±±ÊÉ®ÊííÊï£Ê°üÁá¶ÁèäÁî£ÁÆóÁ∫ÇËöïËÆÉË≥õÈÖ∏È§êÊñ¨Êö´ÊÆã‰ªï‰ªî‰º∫‰ΩøÂà∫Âè∏Âè≤Âó£ÂõõÂ£´ÂßãÂßâÂßøÂ≠êÂ±çÂ∏ÇÂ∏´ÂøóÊÄùÊåáÊîØÂ≠úÊñØÊñΩÊó®ÊûùÊ≠¢Ê≠ªÊ∞èÁçÖÁ•âÁßÅÁ≥∏Á¥ôÁ¥´ËÇ¢ËÑÇËá≥Ë¶ñË©ûË©©Ë©¶Ë™åË´ÆË≥áË≥úÈõåÈ£ºÊ≠Ø‰∫ã‰ºº‰æçÂÖêÂ≠óÂØ∫ÊÖàÊåÅÊôÇ"],["bca1","Ê¨°ÊªãÊ≤ªÁàæÁíΩÁóîÁ£ÅÁ§∫ËÄåËÄ≥Ëá™ËíîËæûÊ±êÈπøÂºèË≠òÈ¥´Á´∫Ëª∏ÂÆçÈõ´‰∏ÉÂè±Âü∑Â§±Â´âÂÆ§ÊÇâÊπøÊºÜÁñæË≥™ÂÆüËîÄÁØ†ÂÅ≤Êü¥ËäùÂ±°ËïäÁ∏ûËàéÂÜôÂ∞ÑÊç®Ëµ¶ÊñúÁÖÆÁ§æÁ¥óËÄÖË¨ùËªäÈÅÆËõáÈÇ™ÂÄüÂã∫Â∞∫ÊùìÁÅºÁàµÈÖåÈáàÈå´Ëã•ÂØÇÂº±ÊÉπ‰∏ªÂèñÂÆàÊâãÊú±ÊÆäÁã©Áè†Á®ÆËÖ´Ë∂£ÈÖíÈ¶ñÂÑíÂèóÂë™ÂØøÊéàÊ®πÁ∂¨ÈúÄÂõöÂèéÂë®"],["bda1","ÂÆóÂ∞±Â∑û‰øÆÊÑÅÊãæÊ¥≤ÁßÄÁßãÁµÇÁπçÁøíËá≠ËàüËíêË°ÜË•≤ËÆêËπ¥ËºØÈÄ±ÈÖãÈÖ¨ÈõÜÈÜú‰ªÄ‰ΩèÂÖÖÂçÅÂæìÊàéÊüîÊ±ÅÊ∏ãÁç£Á∏¶ÈáçÈäÉÂèîÂ§ôÂÆøÊ∑ëÁ•ùÁ∏ÆÁ≤õÂ°æÁÜüÂá∫Ë°ìËø∞‰øäÂ≥ªÊò•Áû¨Á´£ËàúÈßøÂáÜÂæ™Êó¨Ê•ØÊÆâÊ∑≥Ê∫ñÊΩ§ÁõæÁ¥îÂ∑°ÈÅµÈÜáÈ†ÜÂá¶ÂàùÊâÄÊöëÊõôÊ∏öÂ∫∂Á∑íÁΩ≤Êõ∏ËñØËó∑Ë´∏Âä©ÂèôÂ•≥Â∫èÂæêÊÅïÈã§Èô§ÂÇ∑ÂÑü"],["bea1","ÂãùÂå†ÂçáÂè¨Âì®ÂïÜÂî±ÂòóÂ•®Â¶æÂ®ºÂÆµÂ∞ÜÂ∞èÂ∞ëÂ∞öÂ∫ÑÂ∫äÂª†ÂΩ∞ÊâøÊäÑÊãõÊéåÊç∑ÊòáÊòåÊò≠Êô∂ÊùæÊ¢¢Ê®üÊ®µÊ≤ºÊ∂àÊ∏âÊπòÁÑºÁÑ¶ÁÖßÁóáÁúÅÁ°ùÁ§ÅÁ••Áß∞Á´†Á¨ëÁ≤ßÁ¥πËÇñËèñËíãËïâË°ùË£≥Ë®üË®ºË©îË©≥Ë±°Ë≥ûÈÜ§Èâ¶ÈçæÈêòÈöúÈûò‰∏ä‰∏à‰∏û‰πóÂÜóÂâ∞ÂüéÂ†¥Â£åÂ¨¢Â∏∏ÊÉÖÊìæÊù°ÊùñÊµÑÁä∂Áï≥Á©£Ëí∏Ë≠≤ÈÜ∏Èå†Âò±Âü¥È£æ"],["bfa1","Êã≠Ê§çÊÆñÁá≠ÁπîËÅ∑Ëâ≤Ëß¶È£üËùïËæ±Â∞ª‰º∏‰ø°‰æµÂîáÂ®†ÂØùÂØ©ÂøÉÊÖéÊåØÊñ∞ÊôãÊ£ÆÊ¶õÊµ∏Ê∑±Áî≥ÁñπÁúüÁ•ûÁß¶Á¥≥Ëá£ËäØËñ™Ë¶™Ë®∫Ë∫´ËæõÈÄ≤ÈáùÈúá‰∫∫‰ªÅÂàÉÂ°µÂ£¨Â∞ãÁîöÂ∞ΩËÖéË®äËøÖÈô£Èù≠Á¨•Ë´èÈ†àÈÖ¢Âõ≥Âé®ÈÄóÂêπÂûÇÂ∏•Êé®Ê∞¥ÁÇäÁù°Á≤ãÁø†Ë°∞ÈÅÇÈÖîÈåêÈåòÈöèÁëûÈ´ÑÂ¥áÂµ©Êï∞Êû¢Ë∂®ÈõõÊçÆÊùâÊ§ôËèÖÈ†óÈõÄË£æ"],["c0a1","ÊæÑÊë∫ÂØ∏‰∏ñÁÄ¨ÁïùÊòØÂáÑÂà∂Âã¢ÂßìÂæÅÊÄßÊàêÊîøÊï¥ÊòüÊô¥Ê£≤Ê†ñÊ≠£Ê∏ÖÁâ≤ÁîüÁõõÁ≤æËÅñÂ£∞Ë£ΩË•øË™†Ë™ìË´ãÈÄùÈÜíÈùíÈùôÊñâÁ®éËÑÜÈöªÂ∏≠ÊÉúÊàöÊñ•ÊòîÊûêÁü≥Á©çÁ±çÁ∏æËÑäË≤¨Ëµ§Ë∑°ËπüÁ¢©ÂàáÊãôÊé•ÊëÇÊäòË®≠Á™ÉÁØÄË™¨Èõ™Áµ∂ËàåËùâ‰ªôÂÖàÂçÉÂç†ÂÆ£Â∞ÇÂ∞ñÂ∑ùÊà¶ÊâáÊí∞Ê†ìÊ†¥Ê≥âÊµÖÊ¥óÊüìÊΩúÁÖéÁÖΩÊóãÁ©øÁÆ≠Á∑ö"],["c1a1","ÁπäÁæ®ËÖ∫ËàõËàπËñ¶Ë©ÆË≥éË∑µÈÅ∏ÈÅ∑Èä≠ÈäëÈñÉÈÆÆÂâçÂñÑÊº∏ÁÑ∂ÂÖ®Á¶ÖÁπïËÜ≥Á≥éÂôåÂ°ëÂ≤®Êé™ÊõæÊõΩÊ•öÁãôÁñèÁñéÁ§éÁ•ñÁßüÁ≤óÁ¥†ÁµÑËòáË®¥ÈòªÈÅ°Èº†ÂÉßÂâµÂèåÂè¢ÂÄâÂñ™Â£ÆÂ•èÁàΩÂÆãÂ±§ÂåùÊÉ£ÊÉ≥ÊçúÊéÉÊåøÊéªÊìçÊó©ÊõπÂ∑£ÊßçÊßΩÊºïÁá•‰∫âÁó©Áõ∏Á™ìÁ≥üÁ∑èÁ∂úËÅ°ËçâËçòËë¨ËíºËóªË£ÖËµ∞ÈÄÅÈÅ≠ÈéóÈúúÈ®íÂÉèÂ¢óÊÜé"],["c2a1","ËáìËîµË¥àÈÄ†‰øÉÂÅ¥ÂâáÂç≥ÊÅØÊçâÊùüÊ∏¨Ë∂≥ÈÄü‰øóÂ±ûË≥äÊóèÁ∂öÂçíË¢ñÂÖ∂ÊèÉÂ≠òÂ≠´Â∞äÊêçÊùëÈÅú‰ªñÂ§öÂ§™Ê±∞Ë©ëÂîæÂ†ïÂ¶•ÊÉ∞ÊâìÊüÅËàµÊ•ïÈôÄÈßÑÈ®®‰ΩìÂ†ÜÂØæËÄêÂ≤±Â∏ØÂæÖÊÄ†ÊÖãÊà¥ÊõøÊ≥∞ÊªûËÉéËÖøËãîË¢ãË≤∏ÈÄÄÈÄÆÈöäÈªõÈØõ‰ª£Âè∞Â§ßÁ¨¨ÈÜçÈ°åÈ∑πÊªùÁÄßÂçìÂïÑÂÆÖÊâòÊäûÊãìÊ≤¢ÊøØÁê¢Ë®óÈê∏ÊøÅË´æËå∏ÂáßËõ∏Âè™"],["c3a1","Âè©‰ΩÜÈÅîËæ∞Â•™ËÑ±Â∑ΩÁ´™ËæøÊ£öË∞∑Áã∏È±àÊ®ΩË™∞‰∏πÂçòÂòÜÂù¶ÊãÖÊé¢Êó¶Ê≠éÊ∑°ÊπõÁÇ≠Áü≠Á´ØÁÆ™Á∂ªËÄΩËÉÜËõãË™ïÈçõÂõ£Â£áÂºæÊñ≠ÊöñÊ™ÄÊÆµÁî∑Ë´áÂÄ§Áü•Âú∞ÂºõÊÅ•Êô∫Ê±†Áó¥Á®öÁΩÆËá¥ËúòÈÅÖÈ¶≥ÁØâÁïúÁ´πÁ≠ëËìÑÈÄêÁß©Á™íËå∂Â´°ÁùÄ‰∏≠‰ª≤ÂÆôÂø†ÊäΩÊòºÊü±Ê≥®Ëô´Ë°∑Ë®ªÈÖéÈã≥ÈßêÊ®óÁÄ¶Áå™ËãßËëóË≤Ø‰∏ÅÂÖÜÂáãÂñãÂØµ"],["c4a1","Â∏ñÂ∏≥Â∫ÅÂºîÂºµÂΩ´Âæ¥Êá≤ÊåëÊö¢ÊúùÊΩÆÁâíÁî∫Áú∫ËÅ¥ËÑπËÖ∏Ëù∂Ë™øË´úË∂ÖË∑≥ÈäöÈï∑È†ÇÈ≥•ÂãÖÊçóÁõ¥ÊúïÊ≤àÁèçË≥ÉÈéÆÈô≥Ê¥•Â¢úÊ§éÊßåËøΩÈéöÁóõÈÄöÂ°öÊ†ÇÊé¥Êßª‰ΩÉÊº¨ÊüòËæªËî¶Á∂¥ÈçîÊ§øÊΩ∞Âù™Â£∑Â¨¨Á¥¨Áà™ÂêäÈá£È∂¥‰∫≠‰ΩéÂÅúÂÅµÂâÉË≤ûÂëàÂ†§ÂÆöÂ∏ùÂ∫ïÂ∫≠Âª∑ÂºüÊÇåÊäµÊå∫ÊèêÊ¢ØÊ±ÄÁ¢áÁ¶éÁ®ãÁ∑†ËâáË®ÇË´¶ËπÑÈÄì"],["c5a1","ÈÇ∏ÈÑ≠ÈáòÈºéÊ≥•ÊëòÊì¢ÊïµÊª¥ÁöÑÁ¨õÈÅ©ÈèëÊ∫∫Âì≤ÂæπÊí§ËΩçËø≠ÈâÑÂÖ∏Â°´Â§©Â±ïÂ∫óÊ∑ªÁ∫èÁîúË≤ºËª¢È°õÁÇπ‰ºùÊÆøÊæ±Áî∞ÈõªÂÖéÂêêÂ†µÂ°óÂ¶¨Â±†ÂæíÊñóÊùúÊ∏°ÁôªËèüË≥≠ÈÄîÈÉΩÈççÁ†•Á†∫Âä™Â∫¶ÂúüÂ•¥ÊÄíÂÄíÂÖöÂÜ¨ÂáçÂàÄÂîêÂ°îÂ°òÂ•óÂÆïÂ≥∂Â∂ãÊÇºÊäïÊê≠Êù±Ê°ÉÊ¢ºÊ£üÁõóÊ∑òÊπØÊ∂õÁÅØÁáàÂΩìÁóòÁ•∑Á≠âÁ≠îÁ≠íÁ≥ñÁµ±Âà∞"],["c6a1","Ëë£Ëï©Ëó§Ë®éË¨ÑË±ÜË∏èÈÄÉÈÄèÈêôÈô∂È†≠È®∞ÈóòÂÉçÂãïÂêåÂ†ÇÂ∞éÊÜßÊíûÊ¥ûÁû≥Á´•ËÉ¥ËêÑÈÅìÈäÖÂ≥†È¥áÂåøÂæóÂæ≥Ê∂úÁâπÁù£Á¶øÁØ§ÊØíÁã¨Ë™≠Ê†ÉÊ©°Âá∏Á™ÅÊ§¥Â±äÈ≥∂Ëã´ÂØÖÈÖâÁÄûÂô∏Â±ØÊÉáÊï¶Ê≤åË±öÈÅÅÈ†ìÂëëÊõáÈàçÂ•àÈÇ£ÂÜÖ‰πçÂá™ËñôË¨éÁÅòÊç∫ÈçãÊ•¢È¶¥Á∏ÑÁï∑ÂçóÊ•†ËªüÈõ£Ê±ù‰∫åÂ∞ºÂºêËø©ÂåÇË≥ëËÇâËôπÂªøÊó•‰π≥ÂÖ•"],["c7a1","Â¶ÇÂ∞øÈüÆ‰ªªÂ¶äÂøçË™çÊø°Á¶∞Á•¢ÂØßËë±Áå´ÁÜ±Âπ¥ÂøµÊçªÊíöÁáÉÁ≤ò‰πÉÂªº‰πãÂüúÂö¢ÊÇ©ÊøÉÁ¥çËÉΩËÑ≥ËÜøËæ≤Ë¶óËö§Â∑¥ÊääÊí≠Ë¶áÊù∑Ê≥¢Ê¥æÁê∂Á†¥Â©ÜÁΩµËä≠È¶¨‰ø≥ÂªÉÊãùÊéíÊïóÊùØÁõÉÁâåËÉåËÇ∫Ëº©ÈÖçÂÄçÂüπÂ™íÊ¢ÖÊ•≥ÁÖ§ÁãΩË≤∑Â£≤Ë≥†Èô™ÈÄôËùøÁß§ÁüßËê©‰ºØÂâ•ÂçöÊãçÊüèÊ≥äÁôΩÁÆîÁ≤ïËà∂ËñÑËø´ÊõùÊº†ÁàÜÁ∏õËé´ÈßÅÈ∫¶"],["c8a1","ÂáΩÁÆ±Á°≤ÁÆ∏ËÇáÁ≠àÊ´®Âπ°ËÇåÁïëÁï†ÂÖ´Èâ¢Ê∫åÁô∫ÈÜóÈ´™‰ºêÁΩ∞ÊäúÁ≠èÈñ•È≥©Âô∫Â°ôËõ§Èöº‰º¥Âà§ÂçäÂèçÂèõÂ∏ÜÊê¨ÊñëÊùøÊ∞æÊ±éÁâàÁäØÁè≠ÁïîÁπÅËà¨Ëó©Ë≤©ÁØÑÈáÜÁÖ©È†íÈ£ØÊåΩÊô©Áï™Áõ§Á£êËïÉËõÆÂå™ÂçëÂê¶Â¶ÉÂ∫áÂΩºÊÇ≤ÊââÊâπÊä´ÊñêÊØîÊ≥åÁñ≤ÁöÆÁ¢ëÁßòÁ∑ãÁΩ∑ËÇ•Ë¢´Ë™πË≤ªÈÅøÈùûÈ£õÊ®ãÁ∞∏ÂÇôÂ∞æÂæÆÊûáÊØòÁêµÁúâÁæé"],["c9a1","ÈºªÊüäÁ®óÂåπÁñãÈ´≠ÂΩ¶ËÜùËè±ËÇòÂººÂøÖÁï¢Á≠ÜÈÄºÊ°ßÂß´Â™õÁ¥êÁôæË¨¨‰øµÂΩ™Ê®ôÊ∞∑ÊºÇÁì¢Á•®Ë°®Ë©ïË±πÂªüÊèèÁóÖÁßíËãóÈå®Èã≤ËíúËõ≠È∞≠ÂìÅÂΩ¨ÊñåÊµúÁÄïË≤ßË≥ìÈ†ªÊïèÁì∂‰∏ç‰ªòÂü†Â§´Â©¶ÂØåÂÜ®Â∏ÉÂ∫úÊÄñÊâ∂Êï∑ÊñßÊôÆÊµÆÁà∂Á¨¶ËÖêËÜöËäôË≠úË≤†Ë≥¶Ëµ¥ÈòúÈôÑ‰æÆÊí´Ê≠¶ËàûËë°Ëï™ÈÉ®Â∞ÅÊ•ìÈ¢®Ëë∫Ëïó‰ºèÂâØÂæ©ÂπÖÊúç"],["caa1","Á¶èËÖπË§áË¶ÜÊ∑µÂºóÊâïÊ≤∏‰ªèÁâ©ÈÆíÂàÜÂêªÂô¥Â¢≥ÊÜ§ÊâÆÁÑöÂ•ÆÁ≤âÁ≥ûÁ¥õÈõ∞ÊñáËÅû‰∏ô‰ΩµÂÖµÂ°ÄÂπ£Âπ≥ÂºäÊüÑ‰∏¶ËîΩÈñâÈôõÁ±≥È†ÅÂÉªÂ£ÅÁôñÁ¢ßÂà•Áû•ËîëÁÆÜÂÅèÂ§âÁâáÁØáÁ∑®Ëæ∫ËøîÈÅç‰æøÂãâÂ®©ÂºÅÈû≠‰øùËàóÈã™ÂúÉÊçïÊ≠©Áî´Ë£úËºîÁ©ÇÂãüÂ¢ìÊÖïÊàäÊöÆÊØçÁ∞øËè©ÂÄ£‰ø∏ÂåÖÂëÜÂ†±Â•âÂÆùÂ≥∞Â≥ØÂ¥©Â∫ñÊä±ÊçßÊîæÊñπÊúã"],["cba1","Ê≥ïÊ≥°ÁÉπÁ†≤Á∏´ËÉûËä≥ËêåËì¨ËúÇË§íË®™Ë±äÈÇ¶ÈãíÈ£ΩÈ≥≥Èµ¨‰πè‰∫°ÂÇçÂâñÂùäÂ¶®Â∏ΩÂøòÂøôÊàøÊö¥ÊúõÊüêÊ£íÂÜíÁ¥°ËÇ™ËÜ®Ë¨ÄË≤åË≤øÈâæÈò≤Âê†È†¨ÂåóÂÉïÂçúÂ¢®Êí≤Êú¥ÁâßÁù¶Á©ÜÈá¶ÂãÉÊ≤°ÊÆÜÂ†ÄÂπåÂ•îÊú¨ÁøªÂá°ÁõÜÊë©Á£®È≠îÈ∫ªÂüãÂ¶πÊòßÊûöÊØéÂì©ÊßôÂπïËÜúÊûïÈÆ™ÊüæÈ±íÊ°ù‰∫¶‰ø£ÂèàÊäπÊú´Ê≤´ËøÑ‰æ≠Áπ≠È∫ø‰∏áÊÖ¢Ê∫Ä"],["cca1","Êº´ËîìÂë≥Êú™È≠ÖÂ∑≥ÁÆïÂ≤¨ÂØÜËúúÊπäËìëÁ®îËÑàÂ¶ôÁ≤çÊ∞ëÁú†ÂãôÂ§¢ÁÑ°ÁâüÁüõÈúßÈµ°Ê§ãÂ©øÂ®òÂÜ•ÂêçÂëΩÊòéÁõüËø∑ÈäòÈ≥¥Âß™ÁâùÊªÖÂÖçÊ£âÁ∂øÁ∑¨Èù¢È∫∫Êë∏Ê®°ËåÇÂ¶ÑÂ≠üÊØõÁåõÁõ≤Á∂≤ËÄóËíôÂÑ≤Êú®ÈªôÁõÆÊù¢ÂãøÈ§ÖÂ∞§ÊàªÁ±æË≤∞ÂïèÊÇ∂Á¥ãÈñÄÂåÅ‰πüÂÜ∂Â§úÁà∫ËÄ∂ÈáéÂº•Áü¢ÂéÑÂΩπÁ¥ÑËñ¨Ë®≥Ë∫çÈùñÊü≥ËñÆÈëìÊÑâÊÑàÊ≤πÁôí"],["cda1","Ë´≠Ëº∏ÂîØ‰ΩëÂÑ™ÂãáÂèãÂÆ•ÂπΩÊÇ†ÊÜÇÊèñÊúâÊüöÊπßÊ∂åÁå∂Áå∑Áî±Á•êË£ïË™òÈÅäÈÇëÈÉµÈõÑËûçÂ§ï‰∫à‰Ωô‰∏éË™âËºøÈ†êÂÇ≠ÂπºÂ¶ñÂÆπÂ∫∏ÊèöÊè∫ÊìÅÊõúÊ•äÊßòÊ¥ãÊ∫∂ÁÜîÁî®Á™ØÁæäËÄÄËëâËìâË¶ÅË¨°Ë∏äÈÅ•ÈôΩÈ§äÊÖæÊäëÊ¨≤Ê≤ÉÊµ¥ÁøåÁøºÊ∑ÄÁæÖËû∫Ë£∏Êù•Ëé±È†ºÈõ∑Ê¥õÁµ°ËêΩÈÖ™‰π±ÂçµÂµêÊ¨ÑÊø´ËóçËò≠Ë¶ßÂà©ÂêèÂ±•ÊùéÊ¢®ÁêÜÁíÉ"],["cea1","Áó¢Ë£èË£°ÈáåÈõ¢Èô∏ÂæãÁéáÁ´ãËëéÊé†Áï•ÂäâÊµÅÊ∫úÁêâÁïôÁ°´Á≤íÈöÜÁ´úÈæç‰æ∂ÊÖÆÊóÖËôú‰∫Ü‰∫ÆÂÉö‰∏°ÂáåÂØÆÊñôÊ¢ÅÊ∂ºÁåüÁôÇÁû≠Á®úÁ≥ßËâØË´íÈÅºÈáèÈôµÈ†òÂäõÁ∑ëÂÄ´ÂéòÊûóÊ∑ãÁáêÁê≥Ëá®Ëº™Èö£È±óÈ∫üÁë†Â°ÅÊ∂ôÁ¥ØÈ°û‰ª§‰º∂‰æãÂÜ∑Âä±Â∂∫ÊÄúÁé≤Á§ºËãìÈà¥Èö∑Èõ∂ÈúäÈ∫óÈΩ¢Êö¶Ê≠¥ÂàóÂä£ÁÉàË£ÇÂªâÊÅãÊÜêÊº£ÁÖâÁ∞æÁ∑¥ËÅØ"],["cfa1","ËìÆÈÄ£Èå¨ÂëÇÈ≠ØÊ´ìÁÇâË≥ÇË∑ØÈú≤Âä¥Â©ÅÂªäÂºÑÊúóÊ•ºÊ¶îÊµ™ÊºèÁâ¢ÁãºÁØ≠ËÄÅËÅæËùãÈÉéÂÖ≠È∫ìÁ¶ÑËÇãÈå≤Ë´ñÂÄ≠ÂíåË©±Ê≠™Ë≥ÑËÑáÊÉëÊû†È∑≤‰∫ô‰∫òÈ∞êË©´ËóÅËï®Ê§ÄÊπæÁ¢óËÖï"],["d0a1","Âºå‰∏ê‰∏ï‰∏™‰∏±‰∏∂‰∏º‰∏ø‰πÇ‰πñ‰πò‰∫Ç‰∫ÖË±´‰∫äËàíÂºç‰∫é‰∫û‰∫ü‰∫†‰∫¢‰∫∞‰∫≥‰∫∂‰ªé‰ªç‰ªÑ‰ªÜ‰ªÇ‰ªó‰ªû‰ª≠‰ªü‰ª∑‰ºâ‰Ωö‰º∞‰Ωõ‰Ωù‰Ωó‰Ωá‰Ω∂‰æà‰æè‰æò‰Ωª‰Ω©‰Ω∞‰æë‰ΩØ‰æÜ‰æñÂÑò‰øî‰øü‰øé‰øò‰øõ‰øë‰øö‰øê‰ø§‰ø•ÂÄöÂÄ®ÂÄîÂÄ™ÂÄ•ÂÄÖ‰ºú‰ø∂ÂÄ°ÂÄ©ÂÄ¨‰øæ‰øØÂÄëÂÄÜÂÅÉÂÅáÊúÉÂÅïÂÅêÂÅàÂÅöÂÅñÂÅ¨ÂÅ∏ÂÇÄÂÇöÂÇÖÂÇ¥ÂÇ≤"],["d1a1","ÂÉâÂÉäÂÇ≥ÂÉÇÂÉñÂÉûÂÉ•ÂÉ≠ÂÉ£ÂÉÆÂÉπÂÉµÂÑâÂÑÅÂÑÇÂÑñÂÑïÂÑîÂÑöÂÑ°ÂÑ∫ÂÑ∑ÂÑºÂÑªÂÑøÂÖÄÂÖíÂÖåÂÖîÂÖ¢Á´∏ÂÖ©ÂÖ™ÂÖÆÂÜÄÂÜÇÂõòÂÜåÂÜâÂÜèÂÜëÂÜìÂÜïÂÜñÂÜ§ÂÜ¶ÂÜ¢ÂÜ©ÂÜ™ÂÜ´ÂÜ≥ÂÜ±ÂÜ≤ÂÜ∞ÂÜµÂÜΩÂáÖÂáâÂáõÂá†ËôïÂá©Âá≠Âá∞ÂáµÂáæÂàÑÂàãÂàîÂàéÂàßÂà™ÂàÆÂà≥ÂàπÂâèÂâÑÂâãÂâåÂâûÂâîÂâ™Ââ¥Ââ©Ââ≥ÂâøÂâΩÂäçÂäîÂäíÂâ±ÂäàÂäëËæ®"],["d2a1","ËæßÂä¨Âä≠ÂäºÂäµÂãÅÂãçÂãóÂãûÂã£Âã¶È£≠Âã†Âã≥ÂãµÂã∏ÂãπÂåÜÂåàÁî∏ÂåçÂåêÂåèÂåïÂåöÂå£ÂåØÂå±Âå≥Âå∏ÂçÄÂçÜÂçÖ‰∏óÂçâÂççÂáñÂçûÂç©ÂçÆÂ§òÂçªÂç∑ÂéÇÂéñÂé†Âé¶Âé•ÂéÆÂé∞Âé∂ÂèÉÁ∞íÈõôÂèüÊõºÁáÆÂèÆÂè®Âè≠Âè∫ÂêÅÂêΩÂëÄÂê¨Âê≠ÂêºÂêÆÂê∂Âê©ÂêùÂëéÂíèÂëµÂíéÂëüÂë±Âë∑Âë∞ÂííÂëªÂíÄÂë∂ÂíÑÂíêÂíÜÂìáÂí¢Âí∏Âí•Âí¨ÂìÑÂìàÂí®"],["d3a1","Âí´ÂìÇÂí§ÂíæÂíºÂìòÂì•Âì¶ÂîèÂîîÂìΩÂìÆÂì≠Âì∫Âì¢ÂîπÂïÄÂï£ÂïåÂîÆÂïúÂïÖÂïñÂïóÂî∏Âî≥ÂïùÂñôÂñÄÂíØÂñäÂñüÂïªÂïæÂñòÂñûÂñÆÂïºÂñÉÂñ©ÂñáÂñ®ÂóöÂóÖÂóüÂóÑÂóúÂó§ÂóîÂòîÂó∑ÂòñÂóæÂóΩÂòõÂóπÂôéÂôêÁáüÂò¥Âò∂Âò≤Âò∏Âô´Âô§ÂòØÂô¨Âô™ÂöÜÂöÄÂöäÂö†ÂöîÂöèÂö•ÂöÆÂö∂Âö¥ÂõÇÂöºÂõÅÂõÉÂõÄÂõàÂõéÂõëÂõìÂõóÂõÆÂõπÂúÄÂõøÂúÑÂúâ"],["d4a1","ÂúàÂúãÂúçÂúìÂúòÂúñÂóáÂúúÂú¶Âú∑Âú∏ÂùéÂúªÂùÄÂùèÂù©ÂüÄÂûàÂù°ÂùøÂûâÂûìÂû†Âû≥Âû§Âû™Âû∞ÂüÉÂüÜÂüîÂüíÂüìÂ†äÂüñÂü£Â†ãÂ†ôÂ†ùÂ°≤Â†°Â°¢Â°ãÂ°∞ÊØÄÂ°íÂ†ΩÂ°πÂ¢ÖÂ¢πÂ¢üÂ¢´Â¢∫Â£ûÂ¢ªÂ¢∏Â¢ÆÂ£ÖÂ£ìÂ£ëÂ£óÂ£ôÂ£òÂ£•Â£úÂ£§Â£üÂ£ØÂ£∫Â£πÂ£ªÂ£ºÂ£ΩÂ§ÇÂ§äÂ§êÂ§õÊ¢¶Â§•Â§¨Â§≠Â§≤Â§∏Â§æÁ´íÂ•ïÂ•êÂ•éÂ•öÂ•òÂ•¢Â•†Â•ßÂ•¨Â•©"],["d5a1","Â•∏Â¶ÅÂ¶ù‰Ωû‰æ´Â¶£Â¶≤ÂßÜÂß®ÂßúÂ¶çÂßôÂßöÂ®•Â®üÂ®ëÂ®úÂ®âÂ®öÂ©ÄÂ©¨Â©âÂ®µÂ®∂Â©¢Â©™Â™öÂ™ºÂ™æÂ´ãÂ´ÇÂ™ΩÂ´£Â´óÂ´¶Â´©Â´ñÂ´∫Â´ªÂ¨åÂ¨ãÂ¨ñÂ¨≤Â´êÂ¨™Â¨∂Â¨æÂ≠ÉÂ≠ÖÂ≠ÄÂ≠ëÂ≠ïÂ≠öÂ≠õÂ≠•Â≠©Â≠∞Â≠≥Â≠µÂ≠∏ÊñàÂ≠∫ÂÆÄÂÆÉÂÆ¶ÂÆ∏ÂØÉÂØáÂØâÂØîÂØêÂØ§ÂØ¶ÂØ¢ÂØûÂØ•ÂØ´ÂØ∞ÂØ∂ÂØ≥Â∞ÖÂ∞áÂ∞àÂ∞çÂ∞ìÂ∞†Â∞¢Â∞®Â∞∏Â∞πÂ±ÅÂ±ÜÂ±éÂ±ì"],["d6a1","Â±êÂ±èÂ≠±Â±¨Â±Æ‰π¢Â±∂Â±πÂ≤åÂ≤ëÂ≤îÂ¶õÂ≤´Â≤ªÂ≤∂Â≤ºÂ≤∑Â≥ÖÂ≤æÂ≥áÂ≥ôÂ≥©Â≥ΩÂ≥∫Â≥≠Â∂åÂ≥™Â¥ãÂ¥ïÂ¥óÂµúÂ¥üÂ¥õÂ¥ëÂ¥îÂ¥¢Â¥öÂ¥ôÂ¥òÂµåÂµíÂµéÂµãÂµ¨Âµ≥Âµ∂Â∂áÂ∂ÑÂ∂ÇÂ∂¢Â∂ùÂ∂¨Â∂ÆÂ∂ΩÂ∂êÂ∂∑Â∂ºÂ∑âÂ∑çÂ∑ìÂ∑íÂ∑ñÂ∑õÂ∑´Â∑≤Â∑µÂ∏ãÂ∏öÂ∏ôÂ∏ëÂ∏õÂ∏∂Â∏∑ÂπÑÂπÉÂπÄÂπéÂπóÂπîÂπüÂπ¢Âπ§ÂπáÂπµÂπ∂Âπ∫È∫ºÂπøÂ∫†ÂªÅÂªÇÂªàÂªêÂªè"],["d7a1","ÂªñÂª£ÂªùÂªöÂªõÂª¢Âª°Âª®Âª©Âª¨Âª±Âª≥Âª∞Âª¥Âª∏ÂªæÂºÉÂºâÂΩùÂΩúÂºãÂºëÂºñÂº©Âº≠Âº∏ÂΩÅÂΩàÂΩåÂΩéÂºØÂΩëÂΩñÂΩóÂΩôÂΩ°ÂΩ≠ÂΩ≥ÂΩ∑ÂæÉÂæÇÂΩøÂæäÂæàÂæëÂæáÂæûÂæôÂæòÂæ†Âæ®Âæ≠ÂæºÂøñÂøªÂø§Âø∏Âø±ÂøùÊÇ≥ÂøøÊÄ°ÊÅ†ÊÄôÊÄêÊÄ©ÊÄéÊÄ±ÊÄõÊÄïÊÄ´ÊÄ¶ÊÄèÊÄ∫ÊÅöÊÅÅÊÅ™ÊÅ∑ÊÅüÊÅäÊÅÜÊÅçÊÅ£ÊÅÉÊÅ§ÊÅÇÊÅ¨ÊÅ´ÊÅôÊÇÅÊÇçÊÉßÊÇÉÊÇö"],["d8a1","ÊÇÑÊÇõÊÇñÊÇóÊÇíÊÇßÊÇãÊÉ°ÊÇ∏ÊÉ†ÊÉìÊÇ¥Âø∞ÊÇΩÊÉÜÊÇµÊÉòÊÖçÊÑïÊÑÜÊÉ∂ÊÉ∑ÊÑÄÊÉ¥ÊÉ∫ÊÑÉÊÑ°ÊÉªÊÉ±ÊÑçÊÑéÊÖáÊÑæÊÑ®ÊÑßÊÖäÊÑøÊÑºÊÑ¨ÊÑ¥ÊÑΩÊÖÇÊÖÑÊÖ≥ÊÖ∑ÊÖòÊÖôÊÖöÊÖ´ÊÖ¥ÊÖØÊÖ•ÊÖ±ÊÖüÊÖùÊÖìÊÖµÊÜôÊÜñÊÜáÊÜ¨ÊÜîÊÜöÊÜäÊÜëÊÜ´ÊÜÆÊáåÊáäÊáâÊá∑ÊáàÊáÉÊáÜÊÜ∫ÊáãÁΩπÊáçÊá¶Êá£Êá∂Êá∫Êá¥ÊáøÊáΩÊáºÊáæÊàÄÊààÊàâÊàçÊàåÊàîÊàõ"],["d9a1","ÊàûÊà°Êà™ÊàÆÊà∞Êà≤Êà≥ÊâÅÊâéÊâûÊâ£ÊâõÊâ†Êâ®ÊâºÊäÇÊäâÊâæÊäíÊäìÊäñÊãîÊäÉÊäîÊãóÊãëÊäªÊãèÊãøÊãÜÊìîÊãàÊãúÊãåÊãäÊãÇÊãáÊäõÊãâÊååÊãÆÊã±ÊåßÊåÇÊåàÊãØÊãµÊçêÊåæÊççÊêúÊçèÊéñÊééÊéÄÊé´Êç∂Êé£ÊéèÊéâÊéüÊéµÊç´Êç©ÊéæÊè©ÊèÄÊèÜÊè£ÊèâÊèíÊè∂ÊèÑÊêñÊê¥ÊêÜÊêìÊê¶Êê∂ÊîùÊêóÊê®ÊêèÊëßÊëØÊë∂ÊëéÊî™ÊíïÊíìÊí•Êí©ÊíàÊíº"],["daa1","ÊìöÊìíÊìÖÊìáÊíªÊìòÊìÇÊì±ÊìßËàâÊì†Êì°Êä¨Êì£ÊìØÊî¨Êì∂Êì¥Êì≤Êì∫ÊîÄÊìΩÊîòÊîúÊîÖÊî§Êî£Êî´Êî¥ÊîµÊî∑Êî∂Êî∏ÁïãÊïàÊïñÊïïÊïçÊïòÊïûÊïùÊï≤Êï∏ÊñÇÊñÉËÆäÊñõÊñüÊñ´Êñ∑ÊóÉÊóÜÊóÅÊóÑÊóåÊóíÊóõÊóôÊó†Êó°Êó±Êù≤ÊòäÊòÉÊóªÊù≥ÊòµÊò∂Êò¥ÊòúÊôèÊôÑÊôâÊôÅÊôûÊôùÊô§ÊôßÊô®ÊôüÊô¢Êô∞ÊöÉÊöàÊöéÊöâÊöÑÊöòÊöùÊõÅÊöπÊõâÊöæÊöº"],["dba1","ÊõÑÊö∏ÊõñÊõöÊõ†ÊòøÊõ¶Êõ©Êõ∞ÊõµÊõ∑ÊúèÊúñÊúûÊú¶ÊúßÈú∏ÊúÆÊúøÊú∂ÊùÅÊú∏Êú∑ÊùÜÊùûÊù†ÊùôÊù£Êù§ÊûâÊù∞Êû©ÊùºÊù™ÊûåÊûãÊû¶Êû°ÊûÖÊû∑ÊüØÊû¥Êü¨Êû≥Êü©Êû∏Êü§ÊüûÊüùÊü¢ÊüÆÊûπÊüéÊüÜÊüßÊ™úÊ†ûÊ°ÜÊ†©Ê°ÄÊ°çÊ†≤Ê°éÊ¢≥Ê†´Ê°ôÊ°£Ê°∑Ê°øÊ¢üÊ¢èÊ¢≠Ê¢îÊ¢ùÊ¢õÊ¢ÉÊ™ÆÊ¢πÊ°¥Ê¢µÊ¢†Ê¢∫Ê§èÊ¢çÊ°æÊ§ÅÊ£äÊ§àÊ£òÊ§¢Ê§¶Ê£°Ê§åÊ£ç"],["dca1","Ê£îÊ£ßÊ£ïÊ§∂Ê§íÊ§ÑÊ£óÊ££Ê§•Ê£πÊ£†Ê£ØÊ§®Ê§™Ê§öÊ§£Ê§°Ê£ÜÊ•πÊ•∑Ê•úÊ•∏Ê•´Ê•îÊ•æÊ•ÆÊ§πÊ•¥Ê§ΩÊ•ôÊ§∞Ê•°Ê•ûÊ•ùÊ¶ÅÊ•™Ê¶≤Ê¶ÆÊßêÊ¶øÊßÅÊßìÊ¶æÊßéÂØ®ÊßäÊßùÊ¶ªÊßÉÊ¶ßÊ®ÆÊ¶ëÊ¶†Ê¶úÊ¶ïÊ¶¥ÊßûÊß®Ê®ÇÊ®õÊßøÊ¨äÊßπÊß≤ÊßßÊ®ÖÊ¶±Ê®ûÊß≠Ê®îÊß´Ê®äÊ®íÊ´ÅÊ®£Ê®ìÊ©ÑÊ®åÊ©≤Ê®∂Ê©∏Ê©áÊ©¢Ê©ôÊ©¶Ê©àÊ®∏Ê®¢Ê™êÊ™çÊ™†Ê™ÑÊ™¢Ê™£"],["dda1","Ê™óËòóÊ™ªÊ´ÉÊ´ÇÊ™∏Ê™≥Ê™¨Ê´ûÊ´ëÊ´üÊ™™Ê´öÊ´™Ê´ªÊ¨ÖËòñÊ´∫Ê¨íÊ¨ñÈ¨±Ê¨üÊ¨∏Ê¨∑ÁõúÊ¨πÈ£ÆÊ≠áÊ≠ÉÊ≠âÊ≠êÊ≠ôÊ≠îÊ≠õÊ≠üÊ≠°Ê≠∏Ê≠πÊ≠øÊÆÄÊÆÑÊÆÉÊÆçÊÆòÊÆïÊÆûÊÆ§ÊÆ™ÊÆ´ÊÆØÊÆ≤ÊÆ±ÊÆ≥ÊÆ∑ÊÆºÊØÜÊØãÊØìÊØüÊØ¨ÊØ´ÊØ≥ÊØØÈ∫æÊ∞àÊ∞ìÊ∞îÊ∞õÊ∞§Ê∞£Ê±ûÊ±ïÊ±¢Ê±™Ê≤ÇÊ≤çÊ≤öÊ≤ÅÊ≤õÊ±æÊ±®Ê±≥Ê≤íÊ≤êÊ≥ÑÊ≥±Ê≥ìÊ≤ΩÊ≥óÊ≥ÖÊ≥ùÊ≤ÆÊ≤±Ê≤æ"],["dea1","Ê≤∫Ê≥õÊ≥ØÊ≥ôÊ≥™Ê¥üË°çÊ¥∂Ê¥´Ê¥ΩÊ¥∏Ê¥ôÊ¥µÊ¥≥Ê¥íÊ¥åÊµ£Ê∂ìÊµ§ÊµöÊµπÊµôÊ∂éÊ∂ïÊø§Ê∂ÖÊ∑πÊ∏ïÊ∏äÊ∂µÊ∑áÊ∑¶Ê∂∏Ê∑ÜÊ∑¨Ê∑ûÊ∑åÊ∑®Ê∑íÊ∑ÖÊ∑∫Ê∑ôÊ∑§Ê∑ïÊ∑™Ê∑ÆÊ∏≠ÊπÆÊ∏ÆÊ∏ôÊπ≤ÊπüÊ∏æÊ∏£Êπ´Ê∏´Êπ∂ÊπçÊ∏üÊπÉÊ∏∫ÊπéÊ∏§ÊªøÊ∏ùÊ∏∏Ê∫ÇÊ∫™Ê∫òÊªâÊ∫∑ÊªìÊ∫ΩÊ∫ØÊªÑÊ∫≤ÊªîÊªïÊ∫èÊ∫•ÊªÇÊ∫üÊΩÅÊºëÁÅåÊª¨Êª∏ÊªæÊºøÊª≤Êº±ÊªØÊº≤Êªå"],["dfa1","ÊºæÊºìÊª∑ÊæÜÊΩ∫ÊΩ∏ÊæÅÊæÄÊΩØÊΩõÊø≥ÊΩ≠ÊæÇÊΩºÊΩòÊæéÊæëÊøÇÊΩ¶Êæ≥Êæ£Êæ°Êæ§ÊæπÊøÜÊæ™ÊøüÊøïÊø¨ÊøîÊøòÊø±ÊøÆÊøõÁÄâÁÄãÊø∫ÁÄëÁÄÅÁÄèÊøæÁÄõÁÄöÊΩ¥ÁÄùÁÄòÁÄüÁÄ∞ÁÄæÁÄ≤ÁÅëÁÅ£ÁÇôÁÇíÁÇØÁÉ±ÁÇ¨ÁÇ∏ÁÇ≥ÁÇÆÁÉüÁÉãÁÉùÁÉôÁÑâÁÉΩÁÑúÁÑôÁÖ•ÁÖïÁÜàÁÖ¶ÁÖ¢ÁÖåÁÖñÁÖ¨ÁÜèÁáªÁÜÑÁÜïÁÜ®ÁÜ¨ÁáóÁÜπÁÜæÁáíÁáâÁáîÁáéÁá†Áá¨ÁáßÁáµÁáº"],["e0a1","ÁáπÁáøÁàçÁàêÁàõÁà®Áà≠Áà¨Áà∞Áà≤ÁàªÁàºÁàøÁâÄÁâÜÁâãÁâòÁâ¥ÁâæÁäÇÁäÅÁäáÁäíÁäñÁä¢ÁäßÁäπÁä≤ÁãÉÁãÜÁãÑÁãéÁãíÁã¢Áã†Áã°ÁãπÁã∑ÂÄèÁåóÁåäÁåúÁåñÁåùÁå¥ÁåØÁå©Áå•ÁåæÁçéÁçèÈªòÁçóÁç™Áç®Áç∞Áç∏ÁçµÁçªÁç∫ÁèàÁé≥ÁèéÁéªÁèÄÁè•ÁèÆÁèûÁí¢ÁêÖÁëØÁê•Áè∏Áê≤Áê∫ÁëïÁêøÁëüÁëôÁëÅÁëúÁë©Áë∞Áë£Áë™Áë∂ÁëæÁíãÁíûÁíßÁìäÁìèÁìîÁè±"],["e1a1","Áì†Áì£ÁìßÁì©ÁìÆÁì≤Áì∞Áì±Áì∏Áì∑ÁîÑÁîÉÁîÖÁîåÁîéÁîçÁîïÁîìÁîûÁî¶Áî¨ÁîºÁïÑÁïçÁïäÁïâÁïõÁïÜÁïöÁï©Áï§ÁïßÁï´Áï≠Áï∏Áï∂ÁñÜÁñáÁï¥ÁñäÁñâÁñÇÁñîÁñöÁñùÁñ•Áñ£ÁóÇÁñ≥ÁóÉÁñµÁñΩÁñ∏ÁñºÁñ±ÁóçÁóäÁóíÁóôÁó£ÁóûÁóæÁóøÁóºÁòÅÁó∞Áó∫Áó≤Áó≥ÁòãÁòçÁòâÁòüÁòßÁò†Áò°Áò¢Áò§Áò¥Áò∞ÁòªÁôáÁôàÁôÜÁôúÁôòÁô°Áô¢Áô®Áô©Áô™ÁôßÁô¨Áô∞"],["e2a1","Áô≤Áô∂Áô∏ÁôºÁöÄÁöÉÁöàÁöãÁöéÁöñÁöìÁöôÁööÁö∞Áö¥Áö∏ÁöπÁö∫ÁõÇÁõçÁõñÁõíÁõûÁõ°Áõ•ÁõßÁõ™ËòØÁõªÁúàÁúáÁúÑÁú©Áú§ÁúûÁú•Áú¶ÁúõÁú∑Áú∏ÁùáÁùöÁù®Áù´ÁùõÁù•ÁùøÁùæÁùπÁûéÁûãÁûëÁû†ÁûûÁû∞Áû∂ÁûπÁûøÁûºÁûΩÁûªÁüáÁüçÁüóÁüöÁüúÁü£ÁüÆÁüºÁ†åÁ†íÁ§¶Á††Á§™Á°ÖÁ¢éÁ°¥Á¢ÜÁ°ºÁ¢öÁ¢åÁ¢£Á¢µÁ¢™Á¢ØÁ£ëÁ£ÜÁ£ãÁ£îÁ¢æÁ¢ºÁ£ÖÁ£äÁ£¨"],["e3a1","Á£ßÁ£öÁ£ΩÁ£¥Á§áÁ§íÁ§ëÁ§ôÁ§¨Á§´Á•ÄÁ•†Á•óÁ•üÁ•öÁ•ïÁ•ìÁ•∫Á•øÁ¶äÁ¶ùÁ¶ßÈΩãÁ¶™Á¶ÆÁ¶≥Á¶πÁ¶∫ÁßâÁßïÁßßÁß¨Áß°Áß£Á®àÁ®çÁ®òÁ®ôÁ®†Á®üÁ¶ÄÁ®±Á®ªÁ®æÁ®∑Á©ÉÁ©óÁ©âÁ©°Á©¢Á©©ÈæùÁ©∞Á©πÁ©ΩÁ™àÁ™óÁ™ïÁ™òÁ™ñÁ™©Á´àÁ™∞Á™∂Á´ÖÁ´ÑÁ™øÈÇÉÁ´áÁ´äÁ´çÁ´èÁ´ïÁ´ìÁ´ôÁ´öÁ´ùÁ´°Á´¢Á´¶Á´≠Á´∞Á¨ÇÁ¨èÁ¨äÁ¨ÜÁ¨≥Á¨òÁ¨ôÁ¨ûÁ¨µÁ¨®Á¨∂Á≠ê"],["e4a1","Á≠∫Á¨ÑÁ≠çÁ¨ãÁ≠åÁ≠ÖÁ≠µÁ≠•Á≠¥Á≠ßÁ≠∞Á≠±Á≠¨Á≠ÆÁÆùÁÆòÁÆüÁÆçÁÆúÁÆöÁÆãÁÆíÁÆèÁ≠ùÁÆôÁØãÁØÅÁØåÁØèÁÆ¥ÁØÜÁØùÁØ©Á∞ëÁ∞îÁØ¶ÁØ•Á±†Á∞ÄÁ∞áÁ∞ìÁØ≥ÁØ∑Á∞óÁ∞çÁØ∂Á∞£Á∞ßÁ∞™Á∞üÁ∞∑Á∞´Á∞ΩÁ±åÁ±ÉÁ±îÁ±èÁ±ÄÁ±êÁ±òÁ±üÁ±§Á±ñÁ±•Á±¨Á±µÁ≤ÉÁ≤êÁ≤§Á≤≠Á≤¢Á≤´Á≤°Á≤®Á≤≥Á≤≤Á≤±Á≤ÆÁ≤πÁ≤ΩÁ≥ÄÁ≥ÖÁ≥ÇÁ≥òÁ≥íÁ≥úÁ≥¢È¨ªÁ≥ØÁ≥≤Á≥¥Á≥∂Á≥∫Á¥Ü"],["e5a1","Á¥ÇÁ¥úÁ¥ïÁ¥äÁµÖÁµãÁ¥ÆÁ¥≤Á¥øÁ¥µÁµÜÁµ≥ÁµñÁµéÁµ≤Áµ®ÁµÆÁµèÁµ£Á∂ìÁ∂âÁµõÁ∂èÁµΩÁ∂õÁ∂∫Á∂ÆÁ∂£Á∂µÁ∑áÁ∂ΩÁ∂´Á∏ΩÁ∂¢Á∂ØÁ∑úÁ∂∏Á∂üÁ∂∞Á∑òÁ∑ùÁ∑§Á∑ûÁ∑ªÁ∑≤Á∑°Á∏ÖÁ∏äÁ∏£Á∏°Á∏íÁ∏±Á∏üÁ∏âÁ∏ãÁ∏¢ÁπÜÁπ¶Á∏ªÁ∏µÁ∏πÁπÉÁ∏∑Á∏≤Á∏∫ÁπßÁπùÁπñÁπûÁπôÁπöÁππÁπ™Áπ©ÁπºÁπªÁ∫ÉÁ∑ïÁπΩËæÆÁπøÁ∫àÁ∫âÁ∫åÁ∫íÁ∫êÁ∫ìÁ∫îÁ∫ñÁ∫éÁ∫õÁ∫úÁº∏Áº∫"],["e6a1","ÁΩÖÁΩåÁΩçÁΩéÁΩêÁΩëÁΩïÁΩîÁΩòÁΩüÁΩ†ÁΩ®ÁΩ©ÁΩßÁΩ∏ÁæÇÁæÜÁæÉÁæàÁæáÁæåÁæîÁæûÁæùÁæöÁæ£ÁæØÁæ≤ÁæπÁæÆÁæ∂Áæ∏Ë≠±ÁøÖÁøÜÁøäÁøïÁøîÁø°Áø¶Áø©Áø≥ÁøπÈ£úËÄÜËÄÑËÄãËÄíËÄòËÄôËÄúËÄ°ËÄ®ËÄøËÄªËÅäËÅÜËÅíËÅòËÅöËÅüËÅ¢ËÅ®ËÅ≥ËÅ≤ËÅ∞ËÅ∂ËÅπËÅΩËÅøËÇÑËÇÜËÇÖËÇõËÇìËÇöËÇ≠ÂÜêËÇ¨ËÉõËÉ•ËÉôËÉùËÉÑËÉöËÉñËÑâËÉØËÉ±ËÑõËÑ©ËÑ£ËÑØËÖã"],["e7a1","ÈöãËÖÜËÑæËÖìËÖëËÉºËÖ±ËÖÆËÖ•ËÖ¶ËÖ¥ËÜÉËÜàËÜäËÜÄËÜÇËÜ†ËÜïËÜ§ËÜ£ËÖüËÜìËÜ©ËÜ∞ËÜµËÜæËÜ∏ËÜΩËáÄËáÇËÜ∫ËáâËáçËáëËáôËáòËáàËáöËáüËá†ËáßËá∫ËáªËáæËàÅËàÇËàÖËàáËàäËàçËàêËàñËà©Ëà´Ëà∏Ëà≥ËâÄËâôËâòËâùËâöËâüËâ§Ëâ¢Ëâ®Ëâ™Ëâ´ËàÆËâ±Ëâ∑Ëâ∏ËâæËäçËäíËä´ËäüËäªËä¨Ëã°Ëã£ËãüËãíËã¥Ëã≥Ëã∫ËéìËåÉËãªËãπËãûËåÜËãúËåâËãô"],["e8a1","ËåµËå¥ËåñËå≤Ëå±ËçÄËåπËçêËçÖËåØËå´ËåóËåòËéÖËéöËé™ËéüËé¢ËéñËå£ËééËéáËéäËçºËéµËç≥ËçµËé†ËéâËé®Ëè¥ËêìËè´ËèéËèΩËêÉËèòËêãËèÅËè∑ËêáËè†Ëè≤ËêçËê¢Ëê†ËéΩËê∏ËîÜËèªËë≠Ëê™ËêºËïöËíÑËë∑Ëë´Ëí≠ËëÆËíÇËë©ËëÜËê¨ËëØËëπËêµËìäËë¢ËíπËíøËíüËìôËìçËíªËìöËìêËìÅËìÜËìñËí°Ëî°ËìøËì¥ËîóËîòËî¨ËîüËîïËîîËìºËïÄËï£ËïòËïà"],["e9a1","ËïÅËòÇËïãËïïËñÄËñ§ËñàËñëËñäËñ®Ëï≠ËñîËñõËó™ËñáËñúËï∑ËïæËñêËóâËñ∫ËóèËñπËóêËóïËóùËó•ËóúËóπËòäËòìËòãËóæËó∫ËòÜËò¢ËòöËò∞ËòøËôç‰πïËôîËôüËôßËô±ËöìËö£Ëö©Ëö™ËöãËöåËö∂ËöØËõÑËõÜËö∞ËõâË†£Ëö´ËõîËõûËõ©Ëõ¨ËõüËõõËõØËúíËúÜËúàËúÄËúÉËõªËúëËúâËúçËõπËúäËú¥ËúøËú∑ËúªËú•Ëú©ËúöËù†ËùüËù∏ËùåËùéËù¥ËùóËù®ËùÆËùô"],["eaa1","ËùìËù£Ëù™Ë†ÖËû¢ËûüËûÇËûØËüãËûΩËüÄËüêÈõñËû´ËüÑËû≥ËüáËüÜËûªËüØËü≤Ëü†Ë†èË†çËüæËü∂Ëü∑Ë†éËüíË†ëË†ñË†ïË†¢Ë†°Ë†±Ë†∂Ë†πË†ßË†ªË°ÑË°ÇË°íË°ôË°ûË°¢Ë°´Ë¢ÅË°æË¢ûË°µË°ΩË¢µË°≤Ë¢ÇË¢óË¢íË¢ÆË¢ôË¢¢Ë¢çË¢§Ë¢∞Ë¢øË¢±Ë£ÉË£ÑË£îË£òË£ôË£ùË£πË§ÇË£ºË£¥Ë£®Ë£≤Ë§ÑË§åË§äË§ìË•ÉË§ûË§•Ë§™Ë§´Ë•ÅË•ÑË§ªË§∂Ë§∏Ë•åË§ùË•†Ë•û"],["eba1","Ë•¶Ë•§Ë•≠Ë•™Ë•ØË•¥Ë•∑Ë•æË¶ÉË¶àË¶äË¶ìË¶òË¶°Ë¶©Ë¶¶Ë¶¨Ë¶ØË¶≤Ë¶∫Ë¶ΩË¶øËßÄËßöËßúËßùËßßËß¥Ëß∏Ë®ÉË®ñË®êË®åË®õË®ùË®•Ë®∂Ë©ÅË©õË©íË©ÜË©àË©ºË©≠Ë©¨Ë©¢Ë™ÖË™ÇË™ÑË™®Ë™°Ë™ëË™•Ë™¶Ë™öË™£Ë´ÑË´çË´ÇË´öË´´Ë´≥Ë´ßË´§Ë´±Ë¨îË´†Ë´¢Ë´∑Ë´ûË´õË¨åË¨áË¨öË´°Ë¨ñË¨êË¨óË¨†Ë¨≥Èû´Ë¨¶Ë¨´Ë¨æË¨®Ë≠ÅË≠åË≠èË≠éË≠âË≠ñË≠õË≠öË≠´"],["eca1","Ë≠üË≠¨Ë≠ØË≠¥Ë≠ΩËÆÄËÆåËÆéËÆíËÆìËÆñËÆôËÆöË∞∫Ë±ÅË∞øË±àË±åË±éË±êË±ïË±¢Ë±¨Ë±∏Ë±∫Ë≤ÇË≤âË≤ÖË≤äË≤çË≤éË≤îË±ºË≤òÊàùË≤≠Ë≤™Ë≤ΩË≤≤Ë≤≥Ë≤ÆË≤∂Ë≥àË≥ÅË≥§Ë≥£Ë≥öË≥ΩË≥∫Ë≥ªË¥ÑË¥ÖË¥äË¥áË¥èË¥çË¥êÈΩéË¥ìË≥çË¥îË¥ñËµßËµ≠Ëµ±Ëµ≥Ë∂ÅË∂ôË∑ÇË∂æË∂∫Ë∑èË∑öË∑ñË∑åË∑õË∑ãË∑™Ë∑´Ë∑üË∑£Ë∑ºË∏àË∏âË∑øË∏ùË∏ûË∏êË∏üËπÇË∏µË∏∞Ë∏¥Ëπä"],["eda1","ËπáËπâËπåËπêËπàËπôËπ§Ëπ†Ë∏™Ëπ£ËπïËπ∂Ëπ≤ËπºË∫ÅË∫áË∫ÖË∫ÑË∫ãË∫äË∫ìË∫ëË∫îË∫ôË∫™Ë∫°Ë∫¨Ë∫∞ËªÜË∫±Ë∫æËªÖËªàËªãËªõËª£ËªºËªªËª´ËªæËºäËºÖËºïËºíËºôËºìËºúËºüËºõËºåËº¶Ëº≥ËºªËºπËΩÖËΩÇËºæËΩåËΩâËΩÜËΩéËΩóËΩúËΩ¢ËΩ£ËΩ§ËæúËæüËæ£Ëæ≠ËæØËæ∑ËøöËø•Ëø¢Ëø™ËøØÈÇáËø¥ÈÄÖËøπËø∫ÈÄëÈÄïÈÄ°ÈÄçÈÄûÈÄñÈÄãÈÄßÈÄ∂ÈÄµÈÄπËø∏"],["eea1","ÈÅèÈÅêÈÅëÈÅíÈÄéÈÅâÈÄæÈÅñÈÅòÈÅûÈÅ®ÈÅØÈÅ∂Èö®ÈÅ≤ÈÇÇÈÅΩÈÇÅÈÇÄÈÇäÈÇâÈÇèÈÇ®ÈÇØÈÇ±ÈÇµÈÉ¢ÈÉ§ÊâàÈÉõÈÑÇÈÑíÈÑôÈÑ≤ÈÑ∞ÈÖäÈÖñÈÖòÈÖ£ÈÖ•ÈÖ©ÈÖ≥ÈÖ≤ÈÜãÈÜâÈÜÇÈÜ¢ÈÜ´ÈÜØÈÜ™ÈÜµÈÜ¥ÈÜ∫ÈáÄÈáÅÈáâÈáãÈáêÈáñÈáüÈá°ÈáõÈáºÈáµÈá∂ÈàûÈáøÈàîÈà¨ÈàïÈàëÈâûÈâóÈâÖÈââÈâ§ÈâàÈäïÈàøÈâãÈâêÈäúÈäñÈäìÈäõÈâöÈãèÈäπÈä∑Èã©ÈåèÈã∫ÈçÑÈåÆ"],["efa1","ÈåôÈå¢ÈåöÈå£Èå∫ÈåµÈåªÈçúÈç†ÈçºÈçÆÈçñÈé∞Èé¨Èé≠ÈéîÈéπÈèñÈèóÈè®Èè•ÈèòÈèÉÈèùÈèêÈèàÈè§ÈêöÈêîÈêìÈêÉÈêáÈêêÈê∂Èê´ÈêµÈê°Èê∫ÈëÅÈëíÈëÑÈëõÈë†Èë¢ÈëûÈë™Èà©Èë∞ÈëµÈë∑ÈëΩÈëöÈëºÈëæÈíÅÈëøÈñÇÈñáÈñäÈñîÈññÈñòÈñôÈñ†Èñ®ÈñßÈñ≠ÈñºÈñªÈñπÈñæÈóäÊø∂ÈóÉÈóçÈóåÈóïÈóîÈóñÈóúÈó°Èó•Èó¢Èò°Èò®ÈòÆÈòØÈôÇÈôåÈôèÈôãÈô∑ÈôúÈôû"],["f0a1","ÈôùÈôüÈô¶Èô≤Èô¨ÈöçÈöòÈöïÈöóÈö™ÈößÈö±Èö≤Èö∞Èö¥Èö∂Èö∏ÈöπÈõéÈõãÈõâÈõçË•çÈõúÈúçÈõïÈõπÈúÑÈúÜÈúàÈúìÈúéÈúëÈúèÈúñÈúôÈú§Èú™Èú∞ÈúπÈúΩÈúæÈùÑÈùÜÈùàÈùÇÈùâÈùúÈù†Èù§Èù¶Èù®ÂãíÈù´Èù±ÈùπÈûÖÈùºÈûÅÈù∫ÈûÜÈûãÈûèÈûêÈûúÈû®Èû¶Èû£Èû≥Èû¥ÈüÉÈüÜÈüàÈüãÈüúÈü≠ÈΩèÈü≤Á´üÈü∂ÈüµÈ†èÈ†åÈ†∏È†§È†°È†∑È†ΩÈ°ÜÈ°èÈ°ãÈ°´È°ØÈ°∞"],["f1a1","È°±È°¥È°≥È¢™È¢ØÈ¢±È¢∂È£ÑÈ£ÉÈ£ÜÈ£©È£´È§ÉÈ§âÈ§íÈ§îÈ§òÈ§°È§ùÈ§ûÈ§§È§†È§¨È§ÆÈ§ΩÈ§æÈ•ÇÈ•âÈ•ÖÈ•êÈ•ãÈ•ëÈ•íÈ•åÈ•ïÈ¶óÈ¶òÈ¶•È¶≠È¶ÆÈ¶ºÈßüÈßõÈßùÈßòÈßëÈß≠ÈßÆÈß±Èß≤ÈßªÈß∏È®ÅÈ®èÈ®ÖÈß¢È®ôÈ®´È®∑È©ÖÈ©ÇÈ©ÄÈ©ÉÈ®æÈ©ïÈ©çÈ©õÈ©óÈ©üÈ©¢È©•È©§È©©È©´È©™È™≠È™∞È™ºÈ´ÄÈ´èÈ´ëÈ´ìÈ´îÈ´ûÈ´üÈ´¢È´£È´¶È´ØÈ´´È´ÆÈ´¥È´±È´∑"],["f2a1","È´ªÈ¨ÜÈ¨òÈ¨öÈ¨üÈ¨¢È¨£È¨•È¨ßÈ¨®È¨©È¨™È¨ÆÈ¨ØÈ¨≤È≠ÑÈ≠ÉÈ≠èÈ≠çÈ≠éÈ≠ëÈ≠òÈ≠¥ÈÆìÈÆÉÈÆëÈÆñÈÆóÈÆüÈÆ†ÈÆ®ÈÆ¥ÈØÄÈØäÈÆπÈØÜÈØèÈØëÈØíÈØ£ÈØ¢ÈØ§ÈØîÈØ°È∞∫ÈØ≤ÈØ±ÈØ∞È∞ïÈ∞îÈ∞âÈ∞ìÈ∞åÈ∞ÜÈ∞àÈ∞íÈ∞äÈ∞ÑÈ∞ÆÈ∞õÈ∞•È∞§È∞°È∞∞È±áÈ∞≤È±ÜÈ∞æÈ±öÈ±†È±ßÈ±∂È±∏È≥ßÈ≥¨È≥∞È¥âÈ¥àÈ≥´È¥ÉÈ¥ÜÈ¥™È¥¶È∂ØÈ¥£È¥üÈµÑÈ¥ïÈ¥íÈµÅÈ¥øÈ¥æÈµÜÈµà"],["f3a1","ÈµùÈµûÈµ§ÈµëÈµêÈµôÈµ≤È∂âÈ∂áÈ∂´ÈµØÈµ∫È∂öÈ∂§È∂©È∂≤È∑ÑÈ∑ÅÈ∂ªÈ∂∏È∂∫È∑ÜÈ∑èÈ∑ÇÈ∑ôÈ∑ìÈ∑∏È∑¶È∑≠È∑ØÈ∑ΩÈ∏öÈ∏õÈ∏ûÈπµÈππÈπΩÈ∫ÅÈ∫àÈ∫ãÈ∫åÈ∫íÈ∫ïÈ∫ëÈ∫ùÈ∫•È∫©È∫∏È∫™È∫≠Èù°ÈªåÈªéÈªèÈªêÈªîÈªúÈªûÈªùÈª†Èª•Èª®ÈªØÈª¥Èª∂Èª∑ÈªπÈªªÈªºÈªΩÈºáÈºàÁö∑ÈºïÈº°Èº¨ÈºæÈΩäÈΩíÈΩîÈΩ£ÈΩüÈΩ†ÈΩ°ÈΩ¶ÈΩßÈΩ¨ÈΩ™ÈΩ∑ÈΩ≤ÈΩ∂ÈæïÈæúÈæ†"],["f4a1","Â†ØÊßáÈÅôÁë§ÂáúÁÜô"],["f9a1","Á∫äË§úÈçàÈäàËìú‰øâÁÇªÊò±Ê£àÈãπÊõªÂΩÖ‰∏®‰ª°‰ªº‰ºÄ‰ºÉ‰ºπ‰Ωñ‰æí‰æä‰æö‰æî‰øçÂÅÄÂÄ¢‰øøÂÄûÂÅÜÂÅ∞ÂÅÇÂÇîÂÉ¥ÂÉòÂÖäÂÖ§ÂÜùÂÜæÂá¨ÂàïÂäúÂä¶ÂãÄÂãõÂåÄÂåáÂå§Âç≤ÂéìÂé≤ÂèùÔ®éÂíúÂíäÂí©ÂìøÂñÜÂùôÂù•Âû¨ÂüàÂüáÔ®èÔ®êÂ¢ûÂ¢≤Â§ãÂ•ìÂ•õÂ•ùÂ•£Â¶§Â¶∫Â≠ñÂØÄÁîØÂØòÂØ¨Â∞ûÂ≤¶Â≤∫Â≥µÂ¥ßÂµìÔ®ëÂµÇÂµ≠Â∂∏Â∂πÂ∑êÂº°Âº¥ÂΩßÂæ∑"],["faa1","ÂøûÊÅùÊÇÖÊÇäÊÉûÊÉïÊÑ†ÊÉ≤ÊÑëÊÑ∑ÊÑ∞ÊÜòÊàìÊä¶ÊèµÊë†ÊíùÊìéÊïéÊòÄÊòïÊòªÊòâÊòÆÊòûÊò§Êô•ÊôóÊôôÔ®íÊô≥ÊöôÊö†Êö≤ÊöøÊõ∫ÊúéÔ§©Êù¶ÊûªÊ°íÊüÄÊ†ÅÊ°ÑÊ£èÔ®ìÊ•®Ô®îÊ¶òÊß¢Ê®∞Ê©´Ê©ÜÊ©≥Ê©æÊ´¢Ê´§ÊØñÊ∞øÊ±úÊ≤ÜÊ±ØÊ≥öÊ¥ÑÊ∂áÊµØÊ∂ñÊ∂¨Ê∑èÊ∑∏Ê∑≤Ê∑ºÊ∏πÊπúÊ∏ßÊ∏ºÊ∫øÊæàÊæµÊøµÁÄÖÁÄáÁÄ®ÁÇÖÁÇ´ÁÑèÁÑÑÁÖúÁÖÜÁÖáÔ®ïÁáÅÁáæÁä±"],["fba1","ÁäæÁå§Ô®ñÁç∑ÁéΩÁèâÁèñÁè£ÁèíÁêáÁèµÁê¶Áê™Áê©ÁêÆÁë¢ÁíâÁíüÁîÅÁïØÁöÇÁöúÁöûÁöõÁö¶Ô®óÁùÜÂäØÁ†°Á°éÁ°§Á°∫Á§∞Ô®òÔ®ôÔ®öÁ¶îÔ®õÁ¶õÁ´ëÁ´ßÔ®úÁ´´ÁÆûÔ®ùÁµàÁµúÁ∂∑Á∂†Á∑ñÁπíÁΩáÁæ°Ô®ûËåÅËç¢ËçøËèáËè∂ËëàËí¥ËïìËïôËï´Ô®üËñ∞Ô®†Ô®°Ë†áË£µË®íË®∑Ë©πË™ßË™æË´üÔ®¢Ë´∂Ë≠ìË≠øË≥∞Ë≥¥Ë¥íËµ∂Ô®£ËªèÔ®§Ô®•ÈÅßÈÉûÔ®¶ÈÑïÈÑßÈáö"],["fca1","ÈáóÈáûÈá≠ÈáÆÈá§Èá•ÈàÜÈàêÈàäÈà∫ÈâÄÈàºÈâéÈâôÈâëÈàπÈâßÈäßÈâ∑Èâ∏ÈãßÈãóÈãôÈãêÔ®ßÈãïÈã†ÈãìÈå•Èå°ÈãªÔ®®ÈåûÈãøÈåùÈåÇÈç∞ÈçóÈé§ÈèÜÈèûÈè∏Èê±ÈëÖÈëàÈñíÔßúÔ®©ÈöùÈöØÈú≥ÈúªÈùÉÈùçÈùèÈùëÈùïÈ°óÈ°•Ô®™Ô®´È§ßÔ®¨È¶ûÈ©éÈ´ôÈ´úÈ≠µÈ≠≤ÈÆèÈÆ±ÈÆªÈ∞ÄÈµ∞Èµ´Ô®≠È∏ôÈªë"],["fcf1","‚Ö∞",9,"Ôø¢Ôø§ÔºáÔºÇ"],["8fa2af","ÀòÀá¬∏ÀôÀù¬ØÀõÀöÔΩûŒÑŒÖ"],["8fa2c2","¬°¬¶¬ø"],["8fa2eb","¬∫¬™¬©¬Æ‚Ñ¢¬§‚Ññ"],["8fa6e1","ŒÜŒàŒâŒäŒ™"],["8fa6e7","Œå"],["8fa6e9","ŒéŒ´"],["8fa6ec","Œè"],["8fa6f1","Œ¨Œ≠ŒÆŒØœäŒêœåœÇœçœãŒ∞œé"],["8fa7c2","–Ç",10,"–é–è"],["8fa7f2","—í",10,"—û—ü"],["8fa9a1","√Üƒê"],["8fa9a4","ƒ¶"],["8fa9a6","ƒ≤"],["8fa9a8","≈Åƒø"],["8fa9ab","≈ä√ò≈í"],["8fa9af","≈¶√û"],["8fa9c1","√¶ƒë√∞ƒßƒ±ƒ≥ƒ∏≈Ç≈Ä≈â≈ã√∏≈ì√ü≈ß√æ"],["8faaa1","√Å√Ä√Ñ√ÇƒÇ«çƒÄƒÑ√Ö√ÉƒÜƒàƒå√áƒäƒé√â√à√ã√äƒöƒñƒíƒò"],["8faaba","ƒúƒûƒ¢ƒ†ƒ§√ç√å√è√é«èƒ∞ƒ™ƒÆƒ®ƒ¥ƒ∂ƒπƒΩƒª≈É≈á≈Ö√ë√ì√í√ñ√î«ë≈ê≈å√ï≈î≈ò≈ñ≈ö≈ú≈†≈û≈§≈¢√ö√ô√ú√õ≈¨«ì≈∞≈™≈≤≈Æ≈®«ó«õ«ô«ï≈¥√ù≈∏≈∂≈π≈Ω≈ª"],["8faba1","√°√†√§√¢ƒÉ«éƒÅƒÖ√•√£ƒáƒâƒç√ßƒãƒè√©√®√´√™ƒõƒóƒìƒô«µƒùƒü"],["8fabbd","ƒ°ƒ•√≠√¨√Ø√Æ«ê"],["8fabc5","ƒ´ƒØƒ©ƒµƒ∑ƒ∫ƒæƒº≈Ñ≈à≈Ü√±√≥√≤√∂√¥«í≈ë≈ç√µ≈ï≈ô≈ó≈õ≈ù≈°≈ü≈•≈£√∫√π√º√ª≈≠«î≈±≈´≈≥≈Ø≈©«ò«ú«ö«ñ≈µ√Ω√ø≈∑≈∫≈æ≈º"],["8fb0a1","‰∏Ç‰∏Ñ‰∏Ö‰∏å‰∏í‰∏ü‰∏£‰∏§‰∏®‰∏´‰∏Æ‰∏Ø‰∏∞‰∏µ‰πÄ‰πÅ‰πÑ‰πá‰πë‰πö‰πú‰π£‰π®‰π©‰π¥‰πµ‰ππ‰πø‰∫ç‰∫ñ‰∫ó‰∫ù‰∫Ø‰∫π‰ªÉ‰ªê‰ªö‰ªõ‰ª†‰ª°‰ª¢‰ª®‰ªØ‰ª±‰ª≥‰ªµ‰ªΩ‰ªæ‰ªø‰ºÄ‰ºÇ‰ºÉ‰ºà‰ºã‰ºå‰ºí‰ºï‰ºñ‰ºó‰ºô‰ºÆ‰º±‰Ω†‰º≥‰ºµ‰º∑‰ºπ‰ºª‰ºæ‰ΩÄ‰ΩÇ‰Ωà‰Ωâ‰Ωã‰Ωå‰Ωí‰Ωî‰Ωñ‰Ωò‰Ωü‰Ω£‰Ω™‰Ω¨‰ΩÆ‰Ω±‰Ω∑‰Ω∏‰Ωπ‰Ω∫‰ΩΩ‰Ωæ‰æÅ‰æÇ‰æÑ"],["8fb1a1","‰æÖ‰æâ‰æä‰æå‰æé‰æê‰æí‰æì‰æî‰æó‰æô‰æö‰æû‰æü‰æ≤‰æ∑‰æπ‰æª‰æº‰æΩ‰ææ‰øÄ‰øÅ‰øÖ‰øÜ‰øà‰øâ‰øã‰øå‰øç‰øè‰øí‰øú‰ø†‰ø¢‰ø∞‰ø≤‰øº‰øΩ‰øøÂÄÄÂÄÅÂÄÑÂÄáÂÄäÂÄåÂÄéÂÄêÂÄìÂÄóÂÄòÂÄõÂÄúÂÄùÂÄûÂÄ¢ÂÄßÂÄÆÂÄ∞ÂÄ≤ÂÄ≥ÂÄµÂÅÄÂÅÅÂÅÇÂÅÖÂÅÜÂÅäÂÅåÂÅéÂÅëÂÅíÂÅìÂÅóÂÅôÂÅüÂÅ†ÂÅ¢ÂÅ£ÂÅ¶ÂÅßÂÅ™ÂÅ≠ÂÅ∞ÂÅ±ÂÄªÂÇÅÂÇÉÂÇÑÂÇÜÂÇäÂÇéÂÇèÂÇê"],["8fb2a1","ÂÇíÂÇìÂÇîÂÇñÂÇõÂÇúÂÇû",4,"ÂÇ™ÂÇØÂÇ∞ÂÇπÂÇ∫ÂÇΩÂÉÄÂÉÉÂÉÑÂÉáÂÉåÂÉéÂÉêÂÉìÂÉîÂÉòÂÉúÂÉùÂÉüÂÉ¢ÂÉ§ÂÉ¶ÂÉ®ÂÉ©ÂÉØÂÉ±ÂÉ∂ÂÉ∫ÂÉæÂÑÉÂÑÜÂÑáÂÑàÂÑãÂÑåÂÑçÂÑéÂÉ≤ÂÑêÂÑóÂÑôÂÑõÂÑúÂÑùÂÑûÂÑ£ÂÑßÂÑ®ÂÑ¨ÂÑ≠ÂÑØÂÑ±ÂÑ≥ÂÑ¥ÂÑµÂÑ∏ÂÑπÂÖÇÂÖäÂÖèÂÖìÂÖïÂÖóÂÖòÂÖüÂÖ§ÂÖ¶ÂÖæÂÜÉÂÜÑÂÜãÂÜéÂÜòÂÜùÂÜ°ÂÜ£ÂÜ≠ÂÜ∏ÂÜ∫ÂÜºÂÜæÂÜøÂáÇ"],["8fb3a1","ÂáàÂáèÂáëÂáíÂáìÂáïÂáòÂáûÂá¢Âá•ÂáÆÂá≤Âá≥Âá¥Âá∑ÂàÅÂàÇÂàÖÂàíÂàìÂàïÂàñÂàòÂà¢Âà®Âà±Âà≤ÂàµÂàºÂâÖÂââÂâïÂâóÂâòÂâöÂâúÂâüÂâ†Ââ°Ââ¶ÂâÆÂâ∑Ââ∏ÂâπÂäÄÂäÇÂäÖÂääÂäåÂäìÂäïÂäñÂäóÂäòÂäöÂäúÂä§Âä•Âä¶ÂäßÂäØÂä∞Âä∂Âä∑Âä∏Âä∫ÂäªÂäΩÂãÄÂãÑÂãÜÂãàÂãåÂãèÂãëÂãîÂãñÂãõÂãúÂã°Âã•Âã®Âã©Âã™Âã¨Âã∞Âã±Âã¥Âã∂Âã∑ÂåÄÂåÉÂåäÂåã"],["8fb4a1","ÂååÂåëÂåìÂåòÂåõÂåúÂåûÂåüÂå•ÂåßÂå®Âå©Âå´Âå¨Âå≠Âå∞Âå≤ÂåµÂåºÂåΩÂåæÂçÇÂçåÂçãÂçôÂçõÂç°Âç£Âç•Âç¨Âç≠Âç≤ÂçπÂçæÂéÉÂéáÂéàÂééÂéìÂéîÂéôÂéùÂé°Âé§Âé™Âé´ÂéØÂé≤Âé¥ÂéµÂé∑Âé∏Âé∫ÂéΩÂèÄÂèÖÂèèÂèíÂèìÂèïÂèöÂèùÂèûÂè†Âè¶ÂèßÂèµÂêÇÂêìÂêöÂê°ÂêßÂê®Âê™ÂêØÂê±Âê¥ÂêµÂëÉÂëÑÂëáÂëçÂëèÂëûÂë¢Âë§Âë¶ÂëßÂë©Âë´Âë≠ÂëÆÂë¥Âëø"],["8fb5a1","ÂíÅÂíÉÂíÖÂíàÂíâÂíçÂíëÂíïÂíñÂíúÂíüÂí°Âí¶ÂíßÂí©Âí™Âí≠ÂíÆÂí±Âí∑ÂíπÂí∫ÂíªÂíøÂìÜÂìäÂìçÂìéÂì†Âì™Âì¨ÂìØÂì∂ÂìºÂìæÂìøÂîÄÂîÅÂîÖÂîàÂîâÂîåÂîçÂîéÂîïÂî™Âî´Âî≤ÂîµÂî∂ÂîªÂîºÂîΩÂïÅÂïáÂïâÂïäÂïçÂïêÂïëÂïòÂïöÂïõÂïûÂï†Âï°Âï§Âï¶ÂïøÂñÅÂñÇÂñÜÂñàÂñéÂñèÂñëÂñíÂñìÂñîÂñóÂñ£Âñ§Âñ≠Âñ≤ÂñøÂóÅÂóÉÂóÜÂóâÂóãÂóåÂóéÂóëÂóí"],["8fb6a1","ÂóìÂóóÂóòÂóõÂóûÂó¢Âó©Âó∂ÂóøÂòÖÂòàÂòäÂòç",5,"ÂòôÂò¨Âò∞Âò≥ÂòµÂò∑ÂòπÂòªÂòºÂòΩÂòøÂôÄÂôÅÂôÉÂôÑÂôÜÂôâÂôãÂôçÂôèÂôîÂôûÂô†Âô°Âô¢Âô£Âô¶Âô©Âô≠ÂôØÂô±Âô≤ÂôµÂöÑÂöÖÂöàÂöãÂöåÂöïÂöôÂööÂöùÂöûÂöüÂö¶ÂößÂö®Âö©Âö´Âö¨Âö≠Âö±Âö≥Âö∑ÂöæÂõÖÂõâÂõäÂõãÂõèÂõêÂõåÂõçÂõôÂõúÂõùÂõüÂõ°Âõ§",4,"Âõ±Âõ´Âõ≠"],["8fb7a1","Âõ∂Âõ∑ÂúÅÂúÇÂúáÂúäÂúåÂúëÂúïÂúöÂúõÂúùÂú†Âú¢Âú£Âú§Âú•Âú©Âú™Âú¨ÂúÆÂúØÂú≥Âú¥ÂúΩÂúæÂúøÂùÖÂùÜÂùåÂùçÂùíÂù¢Âù•ÂùßÂù®Âù´Âù≠",4,"Âù≥Âù¥ÂùµÂù∑ÂùπÂù∫ÂùªÂùºÂùæÂûÅÂûÉÂûåÂûîÂûóÂûôÂûöÂûúÂûùÂûûÂûüÂû°ÂûïÂûßÂû®Âû©Âû¨Âû∏ÂûΩÂüáÂüàÂüåÂüèÂüïÂüùÂüûÂü§Âü¶ÂüßÂü©Âü≠Âü∞ÂüµÂü∂Âü∏ÂüΩÂüæÂüøÂ†ÉÂ†ÑÂ†àÂ†âÂü°"],["8fb8a1","Â†åÂ†çÂ†õÂ†ûÂ†üÂ††Â†¶Â†ßÂ†≠Â†≤Â†πÂ†øÂ°âÂ°åÂ°çÂ°èÂ°êÂ°ïÂ°üÂ°°Â°§Â°ßÂ°®Â°∏Â°ºÂ°øÂ¢ÄÂ¢ÅÂ¢áÂ¢àÂ¢âÂ¢äÂ¢åÂ¢çÂ¢èÂ¢êÂ¢îÂ¢ñÂ¢ùÂ¢†Â¢°Â¢¢Â¢¶Â¢©Â¢±Â¢≤Â£ÑÂ¢ºÂ£ÇÂ£àÂ£çÂ£éÂ£êÂ£íÂ£îÂ£ñÂ£öÂ£ùÂ£°Â£¢Â£©Â£≥Â§ÖÂ§ÜÂ§ãÂ§åÂ§íÂ§ìÂ§îËôÅÂ§ùÂ§°Â§£Â§§Â§®Â§ØÂ§∞Â§≥Â§µÂ§∂Â§øÂ•ÉÂ•ÜÂ•íÂ•ìÂ•ôÂ•õÂ•ùÂ•ûÂ•üÂ•°Â•£Â•´Â•≠"],["8fb9a1","Â•ØÂ•≤Â•µÂ•∂Â•πÂ•ªÂ•ºÂ¶ãÂ¶åÂ¶éÂ¶íÂ¶ïÂ¶óÂ¶üÂ¶§Â¶ßÂ¶≠Â¶ÆÂ¶ØÂ¶∞Â¶≥Â¶∑Â¶∫Â¶ºÂßÅÂßÉÂßÑÂßàÂßäÂßçÂßíÂßùÂßûÂßüÂß£Âß§ÂßßÂßÆÂßØÂß±Âß≤Âß¥Âß∑Â®ÄÂ®ÑÂ®åÂ®çÂ®éÂ®íÂ®ìÂ®ûÂ®£Â®§Â®ßÂ®®Â®™Â®≠Â®∞Â©ÑÂ©ÖÂ©áÂ©àÂ©åÂ©êÂ©ïÂ©ûÂ©£Â©•Â©ßÂ©≠Â©∑Â©∫Â©ªÂ©æÂ™ãÂ™êÂ™ìÂ™ñÂ™ôÂ™úÂ™ûÂ™üÂ™†Â™¢Â™ßÂ™¨Â™±Â™≤Â™≥Â™µÂ™∏Â™∫Â™ªÂ™ø"],["8fbaa1","Â´ÑÂ´ÜÂ´àÂ´èÂ´öÂ´úÂ´†Â´•Â´™Â´ÆÂ´µÂ´∂Â´ΩÂ¨ÄÂ¨ÅÂ¨àÂ¨óÂ¨¥Â¨ôÂ¨õÂ¨ùÂ¨°Â¨•Â¨≠Â¨∏Â≠ÅÂ≠ãÂ≠åÂ≠íÂ≠ñÂ≠ûÂ≠®Â≠ÆÂ≠ØÂ≠ºÂ≠ΩÂ≠æÂ≠øÂÆÅÂÆÑÂÆÜÂÆäÂÆéÂÆêÂÆëÂÆìÂÆîÂÆñÂÆ®ÂÆ©ÂÆ¨ÂÆ≠ÂÆØÂÆ±ÂÆ≤ÂÆ∑ÂÆ∫ÂÆºÂØÄÂØÅÂØçÂØèÂØñ",4,"ÂØ†ÂØØÂØ±ÂØ¥ÂØΩÂ∞åÂ∞óÂ∞ûÂ∞üÂ∞£Â∞¶Â∞©Â∞´Â∞¨Â∞ÆÂ∞∞Â∞≤Â∞µÂ∞∂Â±ôÂ±öÂ±úÂ±¢Â±£Â±ßÂ±®Â±©"],["8fbba1","Â±≠Â±∞Â±¥Â±µÂ±∫Â±ªÂ±ºÂ±ΩÂ≤áÂ≤àÂ≤äÂ≤èÂ≤íÂ≤ùÂ≤üÂ≤†Â≤¢Â≤£Â≤¶Â≤™Â≤≤Â≤¥Â≤µÂ≤∫Â≥âÂ≥ãÂ≥íÂ≥ùÂ≥óÂ≥ÆÂ≥±Â≥≤Â≥¥Â¥ÅÂ¥ÜÂ¥çÂ¥íÂ¥´Â¥£Â¥§Â¥¶Â¥ßÂ¥±Â¥¥Â¥πÂ¥ΩÂ¥øÂµÇÂµÉÂµÜÂµàÂµïÂµëÂµôÂµäÂµüÂµ†Âµ°Âµ¢Âµ§Âµ™Âµ≠Âµ∞ÂµπÂµ∫ÂµæÂµøÂ∂ÅÂ∂ÉÂ∂àÂ∂äÂ∂íÂ∂ìÂ∂îÂ∂ïÂ∂ôÂ∂õÂ∂üÂ∂†Â∂ßÂ∂´Â∂∞Â∂¥Â∂∏Â∂πÂ∑ÉÂ∑áÂ∑ãÂ∑êÂ∑éÂ∑òÂ∑ôÂ∑†Â∑§"],["8fbca1","Â∑©Â∑∏Â∑πÂ∏ÄÂ∏áÂ∏çÂ∏íÂ∏îÂ∏ïÂ∏òÂ∏üÂ∏†Â∏ÆÂ∏®Â∏≤Â∏µÂ∏æÂπãÂπêÂπâÂπëÂπñÂπòÂπõÂπúÂπûÂπ®Âπ™",4,"Âπ∞Â∫ÄÂ∫ãÂ∫éÂ∫¢Â∫§Â∫•Â∫®Â∫™Â∫¨Â∫±Â∫≥Â∫ΩÂ∫æÂ∫øÂªÜÂªåÂªãÂªéÂªëÂªíÂªîÂªïÂªúÂªûÂª•Âª´ÂºÇÂºÜÂºáÂºàÂºéÂºôÂºúÂºùÂº°Âº¢Âº£Âº§Âº®Âº´Âº¨ÂºÆÂº∞Âº¥Âº∂ÂºªÂºΩÂºøÂΩÄÂΩÑÂΩÖÂΩáÂΩçÂΩêÂΩîÂΩòÂΩõÂΩ†ÂΩ£ÂΩ§ÂΩß"],["8fbda1","ÂΩØÂΩ≤ÂΩ¥ÂΩµÂΩ∏ÂΩ∫ÂΩΩÂΩæÂæâÂæçÂæèÂæñÂæúÂæùÂæ¢ÂæßÂæ´Âæ§Âæ¨ÂæØÂæ∞Âæ±Âæ∏ÂøÑÂøáÂøàÂøâÂøãÂøê",4,"ÂøûÂø°Âø¢Âø®Âø©Âø™Âø¨Âø≠ÂøÆÂøØÂø≤Âø≥Âø∂Âø∫ÂøºÊÄáÊÄäÊÄçÊÄìÊÄîÊÄóÊÄòÊÄöÊÄüÊÄ§ÊÄ≠ÊÄ≥ÊÄµÊÅÄÊÅáÊÅàÊÅâÊÅåÊÅëÊÅîÊÅñÊÅóÊÅùÊÅ°ÊÅßÊÅ±ÊÅæÊÅøÊÇÇÊÇÜÊÇàÊÇäÊÇéÊÇëÊÇìÊÇïÊÇòÊÇùÊÇûÊÇ¢ÊÇ§ÊÇ•ÊÇ®ÊÇ∞ÊÇ±ÊÇ∑"],["8fbea1","ÊÇªÊÇæÊÉÇÊÉÑÊÉàÊÉâÊÉäÊÉãÊÉéÊÉèÊÉîÊÉïÊÉôÊÉõÊÉùÊÉûÊÉ¢ÊÉ•ÊÉ≤ÊÉµÊÉ∏ÊÉºÊÉΩÊÑÇÊÑáÊÑäÊÑåÊÑê",4,"ÊÑñÊÑóÊÑôÊÑúÊÑûÊÑ¢ÊÑ™ÊÑ´ÊÑ∞ÊÑ±ÊÑµÊÑ∂ÊÑ∑ÊÑπÊÖÅÊÖÖÊÖÜÊÖâÊÖûÊÖ†ÊÖ¨ÊÖ≤ÊÖ∏ÊÖªÊÖºÊÖøÊÜÄÊÜÅÊÜÉÊÜÑÊÜãÊÜçÊÜíÊÜìÊÜóÊÜòÊÜúÊÜùÊÜüÊÜ†ÊÜ•ÊÜ®ÊÜ™ÊÜ≠ÊÜ∏ÊÜπÊÜºÊáÄÊáÅÊáÇÊáéÊáèÊáïÊáúÊáùÊáûÊáüÊá°Êá¢ÊáßÊá©Êá•"],["8fbfa1","Êá¨Êá≠ÊáØÊàÅÊàÉÊàÑÊàáÊàìÊàïÊàúÊà†Êà¢Êà£ÊàßÊà©Êà´ÊàπÊàΩÊâÇÊâÉÊâÑÊâÜÊâåÊâêÊâëÊâíÊâîÊâñÊâöÊâúÊâ§Êâ≠ÊâØÊâ≥Êâ∫ÊâΩÊäçÊäéÊäèÊäêÊä¶Êä®Êä≥Êä∂Êä∑Êä∫ÊäæÊäøÊãÑÊãéÊãïÊãñÊãöÊã™Êã≤Êã¥ÊãºÊãΩÊåÉÊåÑÊåäÊåãÊåçÊåêÊåìÊåñÊåòÊå©Êå™Êå≠ÊåµÊå∂ÊåπÊåºÊçÅÊçÇÊçÉÊçÑÊçÜÊçäÊçãÊçéÊçíÊçìÊçîÊçòÊçõÊç•Êç¶Êç¨Êç≠Êç±Êç¥Êçµ"],["8fc0a1","Êç∏ÊçºÊçΩÊçøÊéÇÊéÑÊéáÊéäÊéêÊéîÊéïÊéôÊéöÊéûÊé§Êé¶Êé≠ÊéÆÊéØÊéΩÊèÅÊèÖÊèàÊèéÊèëÊèìÊèîÊèïÊèúÊè†Êè•Êè™Êè¨Êè≤Êè≥ÊèµÊè∏ÊèπÊêâÊêäÊêêÊêíÊêîÊêòÊêûÊê†Êê¢Êê§Êê•Êê©Êê™ÊêØÊê∞ÊêµÊêΩÊêøÊëãÊëèÊëëÊëíÊëìÊëîÊëöÊëõÊëúÊëùÊëüÊë†Êë°Êë£Êë≠Êë≥Êë¥ÊëªÊëΩÊíÖÊíáÊíèÊíêÊíëÊíòÊíôÊíõÊíùÊíüÊí°Êí£Êí¶Êí®Êí¨Êí≥ÊíΩÊíæÊíø"],["8fc1a1","ÊìÑÊìâÊìäÊìãÊìåÊìéÊìêÊìëÊìïÊìóÊì§Êì•Êì©Êì™Êì≠Êì∞ÊìµÊì∑ÊìªÊìøÊîÅÊîÑÊîàÊîâÊîäÊîèÊîìÊîîÊîñÊîôÊîõÊîûÊîüÊî¢Êî¶Êî©ÊîÆÊî±Êî∫ÊîºÊîΩÊïÉÊïáÊïâÊïêÊïíÊïîÊïüÊï†ÊïßÊï´Êï∫ÊïΩÊñÅÊñÖÊñäÊñíÊñïÊñòÊñùÊñ†Êñ£Êñ¶ÊñÆÊñ≤Êñ≥Êñ¥ÊñøÊóÇÊóàÊóâÊóéÊóêÊóîÊóñÊóòÊóüÊó∞Êó≤Êó¥ÊóµÊóπÊóæÊóøÊòÄÊòÑÊòàÊòâÊòçÊòëÊòíÊòïÊòñÊòù"],["8fc2a1","ÊòûÊò°Êò¢Êò£Êò§Êò¶Êò©Êò™Êò´Êò¨ÊòÆÊò∞Êò±Êò≥ÊòπÊò∑ÊôÄÊôÖÊôÜÊôäÊôåÊôëÊôéÊôóÊôòÊôôÊôõÊôúÊô†Êô°ÊõªÊô™Êô´Êô¨ÊôæÊô≥ÊôµÊôøÊô∑Êô∏ÊôπÊôªÊöÄÊôºÊöãÊöåÊöçÊöêÊöíÊöôÊööÊöõÊöúÊöüÊö†Êö§Êö≠Êö±Êö≤ÊöµÊöªÊöøÊõÄÊõÇÊõÉÊõàÊõåÊõéÊõèÊõîÊõõÊõüÊõ®Êõ´Êõ¨ÊõÆÊõ∫ÊúÖÊúáÊúéÊúìÊúôÊúúÊú†Êú¢Êú≥ÊúæÊùÖÊùáÊùàÊùåÊùîÊùïÊùù"],["8fc3a1","Êù¶Êù¨ÊùÆÊù¥Êù∂ÊùªÊûÅÊûÑÊûéÊûèÊûëÊûìÊûñÊûòÊûôÊûõÊû∞Êû±Êû≤ÊûµÊûªÊûºÊûΩÊüπÊüÄÊüÇÊüÉÊüÖÊüàÊüâÊüíÊüóÊüôÊüúÊü°Êü¶Êü∞Êü≤Êü∂Êü∑Ê°íÊ†îÊ†ôÊ†ùÊ†üÊ†®Ê†ßÊ†¨Ê†≠Ê†ØÊ†∞Ê†±Ê†≥Ê†ªÊ†øÊ°ÑÊ°ÖÊ°äÊ°åÊ°ïÊ°óÊ°òÊ°õÊ°´Ê°Æ",4,"Ê°µÊ°πÊ°∫Ê°ªÊ°ºÊ¢ÇÊ¢ÑÊ¢ÜÊ¢àÊ¢ñÊ¢òÊ¢öÊ¢úÊ¢°Ê¢£Ê¢•Ê¢©Ê¢™Ê¢ÆÊ¢≤Ê¢ªÊ£ÖÊ£àÊ£åÊ£è"],["8fc4a1","Ê£êÊ£ëÊ£ìÊ£ñÊ£ôÊ£úÊ£ùÊ£•Ê£®Ê£™Ê£´Ê£¨Ê£≠Ê£∞Ê£±Ê£µÊ£∂Ê£ªÊ£ºÊ£ΩÊ§ÜÊ§âÊ§äÊ§êÊ§ëÊ§ìÊ§ñÊ§óÊ§±Ê§≥Ê§µÊ§∏Ê§ªÊ•ÇÊ•ÖÊ•âÊ•éÊ•óÊ•õÊ•£Ê•§Ê••Ê•¶Ê•®Ê•©Ê•¨Ê•∞Ê•±Ê•≤Ê•∫Ê•ªÊ•øÊ¶ÄÊ¶çÊ¶íÊ¶ñÊ¶òÊ¶°Ê¶•Ê¶¶Ê¶®Ê¶´Ê¶≠Ê¶ØÊ¶∑Ê¶∏Ê¶∫Ê¶ºÊßÖÊßàÊßëÊßñÊßóÊß¢Êß•ÊßÆÊßØÊß±Êß≥ÊßµÊßæÊ®ÄÊ®ÅÊ®ÉÊ®èÊ®ëÊ®ïÊ®öÊ®ùÊ®†Ê®§Ê®®Ê®∞Ê®≤"],["8fc5a1","Ê®¥Ê®∑Ê®ªÊ®æÊ®øÊ©ÖÊ©ÜÊ©âÊ©äÊ©éÊ©êÊ©ëÊ©íÊ©ïÊ©ñÊ©õÊ©§Ê©ßÊ©™Ê©±Ê©≥Ê©æÊ™ÅÊ™ÉÊ™ÜÊ™áÊ™âÊ™ãÊ™ëÊ™õÊ™ùÊ™ûÊ™üÊ™•Ê™´Ê™ØÊ™∞Ê™±Ê™¥Ê™ΩÊ™æÊ™øÊ´ÜÊ´âÊ´àÊ´åÊ´êÊ´îÊ´ïÊ´ñÊ´úÊ´ùÊ´§Ê´ßÊ´¨Ê´∞Ê´±Ê´≤Ê´ºÊ´ΩÊ¨ÇÊ¨ÉÊ¨ÜÊ¨áÊ¨âÊ¨èÊ¨êÊ¨ëÊ¨óÊ¨õÊ¨ûÊ¨§Ê¨®Ê¨´Ê¨¨Ê¨ØÊ¨µÊ¨∂Ê¨ªÊ¨øÊ≠ÜÊ≠äÊ≠çÊ≠íÊ≠ñÊ≠òÊ≠ùÊ≠†Ê≠ßÊ≠´Ê≠ÆÊ≠∞Ê≠µÊ≠Ω"],["8fc6a1","Ê≠æÊÆÇÊÆÖÊÆóÊÆõÊÆüÊÆ†ÊÆ¢ÊÆ£ÊÆ®ÊÆ©ÊÆ¨ÊÆ≠ÊÆÆÊÆ∞ÊÆ∏ÊÆπÊÆΩÊÆæÊØÉÊØÑÊØâÊØåÊØñÊØöÊØ°ÊØ£ÊØ¶ÊØßÊØÆÊØ±ÊØ∑ÊØπÊØøÊ∞ÇÊ∞ÑÊ∞ÖÊ∞âÊ∞çÊ∞éÊ∞êÊ∞íÊ∞ôÊ∞üÊ∞¶Ê∞ßÊ∞®Ê∞¨Ê∞ÆÊ∞≥Ê∞µÊ∞∂Ê∞∫Ê∞ªÊ∞øÊ±äÊ±ãÊ±çÊ±èÊ±íÊ±îÊ±ôÊ±õÊ±úÊ±´Ê±≠Ê±ØÊ±¥Ê±∂Ê±∏Ê±πÊ±ªÊ≤ÖÊ≤ÜÊ≤áÊ≤âÊ≤îÊ≤ïÊ≤óÊ≤òÊ≤úÊ≤üÊ≤∞Ê≤≤Ê≤¥Ê≥ÇÊ≥ÜÊ≥çÊ≥èÊ≥êÊ≥ëÊ≥íÊ≥îÊ≥ñ"],["8fc7a1","Ê≥öÊ≥úÊ≥†Ê≥ßÊ≥©Ê≥´Ê≥¨Ê≥ÆÊ≥≤Ê≥¥Ê¥ÑÊ¥áÊ¥äÊ¥éÊ¥èÊ¥ëÊ¥ìÊ¥öÊ¥¶Ê¥ßÊ¥®Ê±ßÊ¥ÆÊ¥ØÊ¥±Ê¥πÊ¥ºÊ¥øÊµóÊµûÊµüÊµ°Êµ•ÊµßÊµØÊµ∞ÊµºÊ∂ÇÊ∂áÊ∂ëÊ∂íÊ∂îÊ∂ñÊ∂óÊ∂òÊ∂™Ê∂¨Ê∂¥Ê∂∑Ê∂πÊ∂ΩÊ∂øÊ∑ÑÊ∑àÊ∑äÊ∑éÊ∑èÊ∑ñÊ∑õÊ∑ùÊ∑üÊ∑†Ê∑¢Ê∑•Ê∑©Ê∑ØÊ∑∞Ê∑¥Ê∑∂Ê∑ºÊ∏ÄÊ∏ÑÊ∏ûÊ∏¢Ê∏ßÊ∏≤Ê∏∂Ê∏πÊ∏ªÊ∏ºÊπÑÊπÖÊπàÊπâÊπãÊπèÊπëÊπíÊπìÊπîÊπóÊπúÊπùÊπû"],["8fc8a1","Êπ¢Êπ£Êπ®Êπ≥ÊπªÊπΩÊ∫çÊ∫ìÊ∫ôÊ∫†Ê∫ßÊ∫≠Ê∫ÆÊ∫±Ê∫≥Ê∫ªÊ∫øÊªÄÊªÅÊªÉÊªáÊªàÊªäÊªçÊªéÊªèÊª´Êª≠ÊªÆÊªπÊªªÊªΩÊºÑÊºàÊºäÊºåÊºçÊºñÊºòÊºöÊºõÊº¶Êº©Êº™ÊºØÊº∞Êº≥Êº∂ÊºªÊººÊº≠ÊΩèÊΩëÊΩíÊΩìÊΩóÊΩôÊΩöÊΩùÊΩûÊΩ°ÊΩ¢ÊΩ®ÊΩ¨ÊΩΩÊΩæÊæÉÊæáÊæàÊæãÊæåÊæçÊæêÊæíÊæìÊæîÊæñÊæöÊæüÊæ†Êæ•Êæ¶ÊæßÊæ®ÊæÆÊæØÊæ∞ÊæµÊæ∂ÊæºÊøÖÊøáÊøàÊøä"],["8fc9a1","ÊøöÊøûÊø®Êø©Êø∞ÊøµÊøπÊøºÊøΩÁÄÄÁÄÖÁÄÜÁÄáÁÄçÁÄóÁÄ†ÁÄ£ÁÄØÁÄ¥ÁÄ∑ÁÄπÁÄºÁÅÉÁÅÑÁÅàÁÅâÁÅäÁÅãÁÅîÁÅïÁÅùÁÅûÁÅéÁÅ§ÁÅ•ÁÅ¨ÁÅÆÁÅµÁÅ∂ÁÅæÁÇÅÁÇÖÁÇÜÁÇî",4,"ÁÇõÁÇ§ÁÇ´ÁÇ∞ÁÇ±ÁÇ¥ÁÇ∑ÁÉäÁÉëÁÉìÁÉîÁÉïÁÉñÁÉòÁÉúÁÉ§ÁÉ∫ÁÑÉ",4,"ÁÑãÁÑåÁÑèÁÑûÁÑ†ÁÑ´ÁÑ≠ÁÑØÁÑ∞ÁÑ±ÁÑ∏ÁÖÅÁÖÖÁÖÜÁÖáÁÖäÁÖãÁÖêÁÖíÁÖóÁÖöÁÖúÁÖûÁÖ†"],["8fcaa1","ÁÖ®ÁÖπÁÜÄÁÜÖÁÜáÁÜåÁÜíÁÜöÁÜõÁÜ†ÁÜ¢ÁÜØÁÜ∞ÁÜ≤ÁÜ≥ÁÜ∫ÁÜøÁáÄÁáÅÁáÑÁáãÁáåÁáìÁáñÁáôÁáöÁáúÁá∏ÁáæÁàÄÁàáÁààÁàâÁàìÁàóÁàöÁàùÁàüÁà§Áà´ÁàØÁà¥Áà∏ÁàπÁâÅÁâÇÁâÉÁâÖÁâéÁâèÁâêÁâìÁâïÁâñÁâöÁâúÁâûÁâ†Áâ£Áâ®Áâ´ÁâÆÁâØÁâ±Áâ∑Áâ∏ÁâªÁâºÁâøÁäÑÁäâÁäçÁäéÁäìÁäõÁä®Áä≠ÁäÆÁä±Áä¥ÁäæÁãÅÁãáÁãâÁãåÁãïÁãñÁãòÁãüÁã•Áã≥Áã¥Áã∫Áãª"],["8fcba1","ÁãæÁåÇÁåÑÁåÖÁåáÁåãÁåçÁåíÁåìÁåòÁåôÁåûÁå¢Áå§ÁåßÁå®Áå¨Áå±Áå≤ÁåµÁå∫ÁåªÁåΩÁçÉÁççÁçêÁçíÁçñÁçòÁçùÁçûÁçüÁç†Áç¶ÁçßÁç©Áç´Áç¨ÁçÆÁçØÁç±Áç∑ÁçπÁçºÁéÄÁéÅÁéÉÁéÖÁéÜÁééÁéêÁéìÁéïÁéóÁéòÁéúÁéûÁéüÁé†Áé¢Áé•Áé¶Áé™Áé´Áé≠ÁéµÁé∑ÁéπÁéºÁéΩÁéøÁèÖÁèÜÁèâÁèãÁèåÁèèÁèíÁèìÁèñÁèôÁèùÁè°Áè£Áè¶ÁèßÁè©Áè¥ÁèµÁè∑ÁèπÁè∫ÁèªÁèΩ"],["8fcca1","ÁèøÁêÄÁêÅÁêÑÁêáÁêäÁêëÁêöÁêõÁê§Áê¶Áê®",9,"ÁêπÁëÄÁëÉÁëÑÁëÜÁëáÁëãÁëçÁëëÁëíÁëóÁëùÁë¢Áë¶ÁëßÁë®Áë´Áë≠ÁëÆÁë±Áë≤ÁíÄÁíÅÁíÖÁíÜÁíáÁíâÁíèÁíêÁíëÁííÁíòÁíôÁíöÁíúÁíüÁí†Áí°Áí£Áí¶Áí®Áí©Áí™Áí´ÁíÆÁíØÁí±Áí≤ÁíµÁíπÁíªÁíøÁìàÁìâÁìåÁìêÁììÁìòÁìöÁìõÁìûÁìüÁì§Áì®Áì™Áì´ÁìØÁì¥Áì∫ÁìªÁìºÁìøÁîÜ"],["8fcda1","ÁîíÁîñÁîóÁî†Áî°Áî§ÁîßÁî©Áî™ÁîØÁî∂ÁîπÁîΩÁîæÁîøÁïÄÁïÉÁïáÁïàÁïéÁïêÁïíÁïóÁïûÁïüÁï°ÁïØÁï±Áïπ",5,"ÁñÅÁñÖÁñêÁñíÁñìÁñïÁñôÁñúÁñ¢Áñ§Áñ¥Áñ∫ÁñøÁóÄÁóÅÁóÑÁóÜÁóåÁóéÁóèÁóóÁóúÁóüÁó†Áó°Áó§ÁóßÁó¨ÁóÆÁóØÁó±ÁóπÁòÄÁòÇÁòÉÁòÑÁòáÁòàÁòäÁòåÁòèÁòíÁòìÁòïÁòñÁòôÁòõÁòúÁòùÁòûÁò£Áò•Áò¶Áò©Áò≠Áò≤Áò≥ÁòµÁò∏Áòπ"],["8fcea1","Áò∫ÁòºÁôäÁôÄÁôÅÁôÉÁôÑÁôÖÁôâÁôãÁôïÁôôÁôüÁô§Áô•Áô≠ÁôÆÁôØÁô±Áô¥ÁöÅÁöÖÁöåÁöçÁöïÁöõÁöúÁöùÁöüÁö†Áö¢",6,"Áö™Áö≠ÁöΩÁõÅÁõÖÁõâÁõãÁõåÁõéÁõîÁõôÁõ†Áõ¶Áõ®Áõ¨Áõ∞Áõ±Áõ∂ÁõπÁõºÁúÄÁúÜÁúäÁúéÁúíÁúîÁúïÁúóÁúôÁúöÁúúÁú¢Áú®Áú≠ÁúÆÁúØÁú¥ÁúµÁú∂ÁúπÁúΩÁúæÁùÇÁùÖÁùÜÁùäÁùçÁùéÁùèÁùíÁùñÁùóÁùúÁùûÁùüÁù†Áù¢"],["8fcfa1","Áù§ÁùßÁù™Áù¨Áù∞Áù≤Áù≥Áù¥Áù∫ÁùΩÁûÄÁûÑÁûåÁûçÁûîÁûïÁûñÁûöÁûüÁû¢ÁûßÁû™ÁûÆÁûØÁû±ÁûµÁûæÁüÉÁüâÁüëÁüíÁüïÁüôÁüûÁüüÁü†Áü§Áü¶Áü™Áü¨Áü∞Áü±Áü¥Áü∏ÁüªÁ†ÖÁ†ÜÁ†âÁ†çÁ†éÁ†ëÁ†ùÁ†°Á†¢Á†£Á†≠Á†ÆÁ†∞Á†µÁ†∑Á°ÉÁ°ÑÁ°áÁ°àÁ°åÁ°éÁ°íÁ°úÁ°ûÁ°†Á°°Á°£Á°§Á°®Á°™Á°ÆÁ°∫Á°æÁ¢äÁ¢èÁ¢îÁ¢òÁ¢°Á¢ùÁ¢ûÁ¢üÁ¢§Á¢®Á¢¨Á¢≠Á¢∞Á¢±Á¢≤Á¢≥"],["8fd0a1","Á¢ªÁ¢ΩÁ¢øÁ£áÁ£àÁ£âÁ£åÁ£éÁ£íÁ£ìÁ£ïÁ£ñÁ£§Á£õÁ£üÁ£†Á£°Á£¶Á£™Á£≤Á£≥Á§ÄÁ£∂Á£∑Á£∫Á£ªÁ£øÁ§ÜÁ§åÁ§êÁ§öÁ§úÁ§ûÁ§üÁ§†Á§•Á§ßÁ§©Á§≠Á§±Á§¥Á§µÁ§ªÁ§ΩÁ§øÁ•ÑÁ•ÖÁ•ÜÁ•äÁ•ãÁ•èÁ•ëÁ•îÁ•òÁ•õÁ•úÁ•ßÁ•©Á•´Á•≤Á•πÁ•ªÁ•ºÁ•æÁ¶ãÁ¶åÁ¶ëÁ¶ìÁ¶îÁ¶ïÁ¶ñÁ¶òÁ¶õÁ¶úÁ¶°Á¶®Á¶©Á¶´Á¶ØÁ¶±Á¶¥Á¶∏Á¶ªÁßÇÁßÑÁßáÁßàÁßäÁßèÁßîÁßñÁßöÁßùÁßû"],["8fd1a1","Áß†Áß¢Áß•Áß™Áß´Áß≠Áß±Áß∏ÁßºÁ®ÇÁ®ÉÁ®áÁ®âÁ®äÁ®åÁ®ëÁ®ïÁ®õÁ®ûÁ®°Á®ßÁ®´Á®≠Á®ØÁ®∞Á®¥Á®µÁ®∏Á®πÁ®∫Á©ÑÁ©ÖÁ©áÁ©àÁ©åÁ©ïÁ©ñÁ©ôÁ©úÁ©ùÁ©üÁ©†Á©•Á©ßÁ©™Á©≠Á©µÁ©∏Á©æÁ™ÄÁ™ÇÁ™ÖÁ™ÜÁ™äÁ™ãÁ™êÁ™ëÁ™îÁ™ûÁ™†Á™£Á™¨Á™≥Á™µÁ™πÁ™ªÁ™ºÁ´ÜÁ´âÁ´åÁ´éÁ´ëÁ´õÁ´®Á´©Á´´Á´¨Á´±Á´¥Á´ªÁ´ΩÁ´æÁ¨áÁ¨îÁ¨üÁ¨£Á¨ßÁ¨©Á¨™Á¨´Á¨≠Á¨ÆÁ¨ØÁ¨∞"],["8fd2a1","Á¨±Á¨¥Á¨ΩÁ¨øÁ≠ÄÁ≠ÅÁ≠áÁ≠éÁ≠ïÁ≠†Á≠§Á≠¶Á≠©Á≠™Á≠≠Á≠ØÁ≠≤Á≠≥Á≠∑ÁÆÑÁÆâÁÆéÁÆêÁÆëÁÆñÁÆõÁÆûÁÆ†ÁÆ•ÁÆ¨ÁÆØÁÆ∞ÁÆ≤ÁÆµÁÆ∂ÁÆ∫ÁÆªÁÆºÁÆΩÁØÇÁØÖÁØàÁØäÁØîÁØñÁØóÁØôÁØöÁØõÁØ®ÁØ™ÁØ≤ÁØ¥ÁØµÁØ∏ÁØπÁØ∫ÁØºÁØæÁ∞ÅÁ∞ÇÁ∞ÉÁ∞ÑÁ∞ÜÁ∞âÁ∞ãÁ∞åÁ∞éÁ∞èÁ∞ôÁ∞õÁ∞†Á∞•Á∞¶Á∞®Á∞¨Á∞±Á∞≥Á∞¥Á∞∂Á∞πÁ∞∫Á±ÜÁ±äÁ±ïÁ±ëÁ±íÁ±ìÁ±ô",5],["8fd3a1","Á±°Á±£Á±ßÁ±©Á±≠Á±ÆÁ±∞Á±≤Á±πÁ±ºÁ±ΩÁ≤ÜÁ≤áÁ≤èÁ≤îÁ≤ûÁ≤†Á≤¶Á≤∞Á≤∂Á≤∑Á≤∫Á≤ªÁ≤ºÁ≤øÁ≥ÑÁ≥áÁ≥àÁ≥âÁ≥çÁ≥èÁ≥ìÁ≥îÁ≥ïÁ≥óÁ≥ôÁ≥öÁ≥ùÁ≥¶Á≥©Á≥´Á≥µÁ¥ÉÁ¥áÁ¥àÁ¥âÁ¥èÁ¥ëÁ¥íÁ¥ìÁ¥ñÁ¥ùÁ¥ûÁ¥£Á¥¶Á¥™Á¥≠Á¥±Á¥ºÁ¥ΩÁ¥æÁµÄÁµÅÁµáÁµàÁµçÁµëÁµìÁµóÁµôÁµöÁµúÁµùÁµ•ÁµßÁµ™Áµ∞Áµ∏Áµ∫ÁµªÁµøÁ∂ÅÁ∂ÇÁ∂ÉÁ∂ÖÁ∂ÜÁ∂àÁ∂ãÁ∂åÁ∂çÁ∂ëÁ∂ñÁ∂óÁ∂ù"],["8fd4a1","Á∂ûÁ∂¶Á∂ßÁ∂™Á∂≥Á∂∂Á∂∑Á∂πÁ∑Ç",4,"Á∑åÁ∑çÁ∑éÁ∑óÁ∑ôÁ∏ÄÁ∑¢Á∑•Á∑¶Á∑™Á∑´Á∑≠Á∑±Á∑µÁ∑∂Á∑πÁ∑∫Á∏àÁ∏êÁ∏ëÁ∏ïÁ∏óÁ∏úÁ∏ùÁ∏†Á∏ßÁ∏®Á∏¨Á∏≠Á∏ØÁ∏≥Á∏∂Á∏øÁπÑÁπÖÁπáÁπéÁπêÁπíÁπòÁπüÁπ°Áπ¢Áπ•Áπ´ÁπÆÁπØÁπ≥Áπ∏ÁπæÁ∫ÅÁ∫ÜÁ∫áÁ∫äÁ∫çÁ∫ëÁ∫ïÁ∫òÁ∫öÁ∫ùÁ∫ûÁººÁºªÁºΩÁºæÁºøÁΩÉÁΩÑÁΩáÁΩèÁΩíÁΩìÁΩõÁΩúÁΩùÁΩ°ÁΩ£ÁΩ§ÁΩ•ÁΩ¶ÁΩ≠"],["8fd5a1","ÁΩ±ÁΩΩÁΩæÁΩøÁæÄÁæãÁæçÁæèÁæêÁæëÁæñÁæóÁæúÁæ°Áæ¢Áæ¶Áæ™Áæ≠Áæ¥ÁæºÁæøÁøÄÁøÉÁøàÁøéÁøèÁøõÁøüÁø£Áø•Áø®Áø¨ÁøÆÁøØÁø≤Áø∫ÁøΩÁøæÁøøËÄáËÄàËÄäËÄçËÄéËÄèËÄëËÄìËÄîËÄñËÄùËÄûËÄüËÄ†ËÄ§ËÄ¶ËÄ¨ËÄÆËÄ∞ËÄ¥ËÄµËÄ∑ËÄπËÄ∫ËÄºËÄæËÅÄËÅÑËÅ†ËÅ§ËÅ¶ËÅ≠ËÅ±ËÅµËÇÅËÇàËÇéËÇúËÇûËÇ¶ËÇßËÇ´ËÇ∏ËÇπËÉàËÉçËÉèËÉíËÉîËÉïËÉóËÉòËÉ†ËÉ≠ËÉÆ"],["8fd6a1","ËÉ∞ËÉ≤ËÉ≥ËÉ∂ËÉπËÉ∫ËÉæËÑÉËÑãËÑñËÑóËÑòËÑúËÑûËÑ†ËÑ§ËÑßËÑ¨ËÑ∞ËÑµËÑ∫ËÑºËÖÖËÖáËÖäËÖåËÖíËÖóËÖ†ËÖ°ËÖßËÖ®ËÖ©ËÖ≠ËÖØËÖ∑ËÜÅËÜêËÜÑËÜÖËÜÜËÜãËÜéËÜñËÜòËÜõËÜûËÜ¢ËÜÆËÜ≤ËÜ¥ËÜªËáãËáÉËáÖËáäËáéËáèËáïËáóËáõËáùËáûËá°Ëá§Ëá´Ëá¨Ëá∞Ëá±Ëá≤ËáµËá∂Ëá∏ËáπËáΩËáøËàÄËàÉËàèËàìËàîËàôËàöËàùËà°Ëà¢Ëà®Ëà≤Ëà¥Ëà∫ËâÉËâÑËâÖËâÜ"],["8fd7a1","ËâãËâéËâèËâëËâñËâúËâ†Ëâ£ËâßËâ≠Ëâ¥ËâªËâΩËâøËäÄËäÅËäÉËäÑËäáËäâËääËäéËäëËäîËäñËäòËäöËäõËä†Ëä°Ëä£Ëä§ËäßËä®Ëä©Ëä™ËäÆËä∞Ëä≤Ëä¥Ëä∑Ëä∫ËäºËäæËäøËãÜËãêËãïËãöËã†Ëã¢Ëã§Ëã®Ëã™Ëã≠ËãØËã∂Ëã∑ËãΩËãæËåÄËåÅËåáËåàËåäËåãËçîËåõËåùËåûËåüËå°Ëå¢Ëå¨Ëå≠ËåÆËå∞Ëå≥Ëå∑Ëå∫ËåºËåΩËçÇËçÉËçÑËçáËççËçéËçëËçïËçñËçóËç∞Ëç∏"],["8fd8a1","ËçΩËçøËéÄËéÇËéÑËéÜËéçËéíËéîËéïËéòËéôËéõËéúËéùËé¶ËéßËé©Ëé¨ËéæËéøËèÄËèáËèâËèèËèêËèëËèîËèùËçìËè®Ëè™Ëè∂Ëè∏ËèπËèºËêÅËêÜËêäËêèËêëËêïËêôËé≠ËêØËêπËëÖËëáËëàËëäËëçËëèËëëËëíËëñËëòËëôËëöËëúËë†Ëë§Ëë•ËëßËë™Ëë∞Ëë≥Ëë¥Ëë∂Ëë∏ËëºËëΩËíÅËíÖËííËíìËíïËíûËí¶Ëí®Ëí©Ëí™ËíØËí±Ëí¥Ëí∫ËíΩËíæËìÄËìÇËìáËìàËìåËìèËìì"],["8fd9a1","ËìúËìßËì™ËìØËì∞Ëì±Ëì≤Ëì∑Ëî≤Ëì∫ËìªËìΩËîÇËîÉËîáËîåËîéËîêËîúËîûËî¢Ëî£Ëî§Ëî•ËîßËî™Ëî´ËîØËî≥Ëî¥Ëî∂ËîøËïÜËïè",4,"ËïñËïôËïú",6,"Ëï§Ëï´ËïØËïπËï∫ËïªËïΩËïøËñÅËñÖËñÜËñâËñãËñåËñèËñìËñòËñùËñüËñ†Ëñ¢Ëñ•ËñßËñ¥Ëñ∂Ëñ∑Ëñ∏ËñºËñΩËñæËñøËóÇËóáËóäËóãËóéËñ≠ËóòËóöËóüËó†Ëó¶Ëó®Ëó≠Ëó≥Ëó∂Ëóº"],["8fdaa1","ËóøËòÄËòÑËòÖËòçËòéËòêËòëËòíËòòËòôËòõËòûËò°ËòßËò©Ëò∂Ëò∏Ëò∫ËòºËòΩËôÄËôÇËôÜËôíËôìËôñËôóËôòËôôËôùËô†",4,"Ëô©Ëô¨ËôØËôµËô∂Ëô∑Ëô∫ËöçËöëËöñËöòËööËöúËö°Ëö¶ËößËö®Ëö≠Ëö±Ëö≥Ëö¥ËöµËö∑Ëö∏ËöπËöøËõÄËõÅËõÉËõÖËõëËõíËõïËõóËõöËõúËõ†Ëõ£Ëõ•ËõßËöàËõ∫ËõºËõΩËúÑËúÖËúáËúãËúéËúèËúêËúìËúîËúôËúûËúüËú°Ëú£"],["8fdba1","Ëú®ËúÆËúØËú±Ëú≤ËúπËú∫ËúºËúΩËúæËùÄËùÉËùÖËùçËùòËùùËù°Ëù§Ëù•ËùØËù±Ëù≤ËùªËûÉ",6,"ËûãËûåËûêËûìËûïËûóËûòËûôËûûËû†Ëû£ËûßËû¨Ëû≠ËûÆËû±ËûµËûæËûøËüÅËüàËüâËüäËüéËüïËüñËüôËüöËüúËüüËü¢Ëü£Ëü§Ëü™Ëü´Ëü≠Ëü±Ëü≥Ëü∏Ëü∫ËüøË†ÅË†ÉË†ÜË†âË†äË†ãË†êË†ôË†íË†ìË†îË†òË†öË†õË†úË†ûË†üË†®Ë†≠Ë†ÆË†∞Ë†≤Ë†µ"],["8fdca1","Ë†∫Ë†ºË°ÅË°ÉË°ÖË°àË°âË°äË°ãË°éË°ëË°ïË°ñË°òË°öË°úË°üË°†Ë°§Ë°©Ë°±Ë°πË°ªË¢ÄË¢òË¢öË¢õË¢úË¢üË¢†Ë¢®Ë¢™Ë¢∫Ë¢ΩË¢æË£ÄË£ä",4,"Ë£ëË£íË£ìË£õË£ûË£ßË£ØË£∞Ë£±Ë£µË£∑Ë§ÅË§ÜË§çË§éË§èË§ïË§ñË§òË§ôË§öË§úË§†Ë§¶Ë§ßË§®Ë§∞Ë§±Ë§≤Ë§µË§πË§∫Ë§æË•ÄË•ÇË•ÖË•ÜË•âË•èË•íË•óË•öË•õË•úË•°Ë•¢Ë•£Ë•´Ë•ÆË•∞Ë•≥Ë•µË•∫"],["8fdda1","Ë•ªË•ºË•ΩË¶âË¶çË¶êË¶îË¶ïË¶õË¶úË¶üË¶†Ë¶•Ë¶∞Ë¶¥Ë¶µË¶∂Ë¶∑Ë¶ºËßî",4,"Ëß•Ëß©Ëß´Ëß≠Ëß±Ëß≥Ëß∂ËßπËßΩËßøË®ÑË®ÖË®áË®èË®ëË®íË®îË®ïË®ûË®†Ë®¢Ë®§Ë®¶Ë®´Ë®¨Ë®ØË®µË®∑Ë®ΩË®æË©ÄË©ÉË©ÖË©áË©âË©çË©éË©ìË©ñË©óË©òË©úË©ùË©°Ë©•Ë©ßË©µË©∂Ë©∑Ë©πË©∫Ë©ªË©æË©øË™ÄË™ÉË™ÜË™ãË™èË™êË™íË™ñË™óË™ôË™üË™ßË™©Ë™ÆË™ØË™≥"],["8fdea1","Ë™∂Ë™∑Ë™ªË™æË´ÉË´ÜË´àË´âË´äË´ëË´ìË´îË´ïË´óË´ùË´üË´¨Ë´∞Ë´¥Ë´µË´∂Ë´ºË´øË¨ÖË¨ÜË¨ãË¨ëË¨úË¨ûË¨üË¨äË¨≠Ë¨∞Ë¨∑Ë¨ºË≠Ç",4,"Ë≠àË≠íË≠ìË≠îË≠ôË≠çË≠ûË≠£Ë≠≠Ë≠∂Ë≠∏Ë≠πË≠ºË≠æËÆÅËÆÑËÆÖËÆãËÆçËÆèËÆîËÆïËÆúËÆûËÆüË∞∏Ë∞πË∞ΩË∞æË±ÖË±áË±âË±ãË±èË±ëË±ìË±îË±óË±òË±õË±ùË±ôË±£Ë±§Ë±¶Ë±®Ë±©Ë±≠Ë±≥Ë±µË±∂Ë±ªË±æË≤Ü"],["8fdfa1","Ë≤áË≤ãË≤êË≤íË≤ìË≤ôË≤õË≤úË≤§Ë≤πË≤∫Ë≥ÖË≥ÜË≥âË≥ãË≥èË≥ñË≥ïË≥ôË≥ùË≥°Ë≥®Ë≥¨Ë≥ØË≥∞Ë≥≤Ë≥µË≥∑Ë≥∏Ë≥æË≥øË¥ÅË¥ÉË¥âË¥íË¥óË¥õËµ•Ëµ©Ëµ¨ËµÆËµøË∂ÇË∂ÑË∂àË∂çË∂êË∂ëË∂ïË∂ûË∂üË∂†Ë∂¶Ë∂´Ë∂¨Ë∂ØË∂≤Ë∂µË∂∑Ë∂πË∂ªË∑ÄË∑ÖË∑ÜË∑áË∑àË∑äË∑éË∑ëË∑îË∑ïË∑óË∑ôË∑§Ë∑•Ë∑ßË∑¨Ë∑∞Ë∂ºË∑±Ë∑≤Ë∑¥Ë∑ΩË∏ÅË∏ÑË∏ÖË∏ÜË∏ãË∏ëË∏îË∏ñË∏†Ë∏°Ë∏¢"],["8fe0a1","Ë∏£Ë∏¶Ë∏ßË∏±Ë∏≥Ë∏∂Ë∏∑Ë∏∏Ë∏πË∏ΩËπÄËπÅËπãËπçËπéËπèËπîËπõËπúËπùËπûËπ°Ëπ¢Ëπ©Ëπ¨Ëπ≠ËπØËπ∞Ëπ±ËππËπ∫ËπªË∫ÇË∫ÉË∫âË∫êË∫íË∫ïË∫öË∫õË∫ùË∫ûË∫¢Ë∫ßË∫©Ë∫≠Ë∫ÆË∫≥Ë∫µË∫∫Ë∫ªËªÄËªÅËªÉËªÑËªáËªèËªëËªîËªúËª®ËªÆËª∞Ëª±Ëª∑ËªπËª∫Ëª≠ËºÄËºÇËºáËºàËºèËºêËºñËºóËºòËºûËº†Ëº°Ëº£Ëº•ËºßËº®Ëº¨Ëº≠ËºÆËº¥ËºµËº∂Ëº∑Ëº∫ËΩÄËΩÅ"],["8fe1a1","ËΩÉËΩáËΩèËΩë",4,"ËΩòËΩùËΩûËΩ•ËæùËæ†Ëæ°Ëæ§Ëæ•Ëæ¶ËæµËæ∂Ëæ∏ËææËøÄËøÅËøÜËøäËøãËøçËøêËøíËøìËøïËø†Ëø£Ëø§Ëø®ËøÆËø±ËøµËø∂ËøªËøæÈÄÇÈÄÑÈÄàÈÄåÈÄòÈÄõÈÄ®ÈÄ©ÈÄØÈÄ™ÈÄ¨ÈÄ≠ÈÄ≥ÈÄ¥ÈÄ∑ÈÄøÈÅÉÈÅÑÈÅåÈÅõÈÅùÈÅ¢ÈÅ¶ÈÅßÈÅ¨ÈÅ∞ÈÅ¥ÈÅπÈÇÖÈÇàÈÇãÈÇåÈÇéÈÇêÈÇïÈÇóÈÇòÈÇôÈÇõÈÇ†ÈÇ°ÈÇ¢ÈÇ•ÈÇ∞ÈÇ≤ÈÇ≥ÈÇ¥ÈÇ∂ÈÇΩÈÉåÈÇæÈÉÉ"],["8fe2a1","ÈÉÑÈÉÖÈÉáÈÉàÈÉïÈÉóÈÉòÈÉôÈÉúÈÉùÈÉüÈÉ•ÈÉíÈÉ∂ÈÉ´ÈÉØÈÉ∞ÈÉ¥ÈÉæÈÉøÈÑÄÈÑÑÈÑÖÈÑÜÈÑàÈÑçÈÑêÈÑîÈÑñÈÑóÈÑòÈÑöÈÑúÈÑûÈÑ†ÈÑ•ÈÑ¢ÈÑ£ÈÑßÈÑ©ÈÑÆÈÑØÈÑ±ÈÑ¥ÈÑ∂ÈÑ∑ÈÑπÈÑ∫ÈÑºÈÑΩÈÖÉÈÖáÈÖàÈÖèÈÖìÈÖóÈÖôÈÖöÈÖõÈÖ°ÈÖ§ÈÖßÈÖ≠ÈÖ¥ÈÖπÈÖ∫ÈÖªÈÜÅÈÜÉÈÜÖÈÜÜÈÜäÈÜéÈÜëÈÜìÈÜîÈÜïÈÜòÈÜûÈÜ°ÈÜ¶ÈÜ®ÈÜ¨ÈÜ≠ÈÜÆÈÜ∞ÈÜ±ÈÜ≤ÈÜ≥ÈÜ∂ÈÜªÈÜºÈÜΩÈÜø"],["8fe3a1","ÈáÇÈáÉÈáÖÈáìÈáîÈáóÈáôÈáöÈáûÈá§Èá•Èá©Èá™Èá¨",5,"Èá∑ÈáπÈáªÈáΩÈàÄÈàÅÈàÑÈàÖÈàÜÈàáÈàâÈàäÈàåÈàêÈàíÈàìÈàñÈàòÈàúÈàùÈà£Èà§Èà•Èà¶Èà®ÈàÆÈàØÈà∞Èà≥ÈàµÈà∂Èà∏ÈàπÈà∫ÈàºÈàæÈâÄÈâÇÈâÉÈâÜÈâáÈâäÈâçÈâéÈâèÈâëÈâòÈâôÈâúÈâùÈâ†Èâ°Èâ•ÈâßÈâ®Èâ©ÈâÆÈâØÈâ∞Èâµ",4,"ÈâªÈâºÈâΩÈâøÈäàÈäâÈääÈäçÈäéÈäíÈäó"],["8fe4a1","ÈäôÈäüÈä†Èä§Èä•ÈäßÈä®Èä´ÈäØÈä≤Èä∂Èä∏Èä∫ÈäªÈäºÈäΩÈäø",4,"ÈãÖÈãÜÈãáÈãàÈããÈãåÈãçÈãéÈãêÈãìÈãïÈãóÈãòÈãôÈãúÈãùÈãüÈã†Èã°Èã£Èã•ÈãßÈã®Èã¨ÈãÆÈã∞ÈãπÈãªÈãøÈåÄÈåÇÈåàÈåçÈåëÈåîÈåïÈåúÈåùÈåûÈåüÈå°Èå§Èå•ÈåßÈå©Èå™Èå≥Èå¥Èå∂Èå∑ÈçáÈçàÈçâÈçêÈçëÈçíÈçïÈçóÈçòÈçöÈçûÈç§Èç•ÈçßÈç©Èç™Èç≠ÈçØÈç∞Èç±Èç≥Èç¥Èç∂"],["8fe5a1","Èç∫ÈçΩÈçøÈéÄÈéÅÈéÇÈéàÈéäÈéãÈéçÈéèÈéíÈéïÈéòÈéõÈéûÈé°Èé£Èé§Èé¶Èé®Èé´Èé¥ÈéµÈé∂Èé∫Èé©ÈèÅÈèÑÈèÖÈèÜÈèáÈèâ",4,"ÈèìÈèôÈèúÈèûÈèüÈè¢Èè¶ÈèßÈèπÈè∑Èè∏Èè∫ÈèªÈèΩÈêÅÈêÇÈêÑÈêàÈêâÈêçÈêéÈêèÈêïÈêñÈêóÈêüÈêÆÈêØÈê±Èê≤Èê≥Èê¥ÈêªÈêøÈêΩÈëÉÈëÖÈëàÈëäÈëåÈëïÈëôÈëúÈëüÈë°Èë£Èë®Èë´Èë≠ÈëÆÈëØÈë±Èë≤ÈíÑÈíÉÈï∏Èïπ"],["8fe6a1","ÈïæÈñÑÈñàÈñåÈñçÈñéÈñùÈñûÈñüÈñ°Èñ¶Èñ©Èñ´Èñ¨Èñ¥Èñ∂Èñ∫ÈñΩÈñøÈóÜÈóàÈóâÈóãÈóêÈóëÈóíÈóìÈóôÈóöÈóùÈóûÈóüÈó†Èó§Èó¶ÈòùÈòûÈò¢Èò§Èò•Èò¶Èò¨Èò±Èò≥Èò∑Èò∏ÈòπÈò∫ÈòºÈòΩÈôÅÈôíÈôîÈôñÈôóÈôòÈô°ÈôÆÈô¥ÈôªÈôºÈôæÈôøÈöÅÈöÇÈöÉÈöÑÈöâÈöëÈöñÈööÈöùÈöüÈö§Èö•Èö¶Èö©ÈöÆÈöØÈö≥Èö∫ÈõäÈõíÂ∂≤ÈõòÈõöÈõùÈõûÈõüÈõ©ÈõØÈõ±Èõ∫ÈúÇ"],["8fe7a1","ÈúÉÈúÖÈúâÈúöÈúõÈúùÈú°Èú¢Èú£Èú®Èú±Èú≥ÈùÅÈùÉÈùäÈùéÈùèÈùïÈùóÈùòÈùöÈùõÈù£ÈùßÈù™ÈùÆÈù≥Èù∂Èù∑Èù∏ÈùªÈùΩÈùøÈûÄÈûâÈûïÈûñÈûóÈûôÈûöÈûûÈûüÈû¢Èû¨ÈûÆÈû±Èû≤ÈûµÈû∂Èû∏ÈûπÈû∫ÈûºÈûæÈûøÈüÅÈüÑÈüÖÈüáÈüâÈüäÈüåÈüçÈüéÈüêÈüëÈüîÈüóÈüòÈüôÈüùÈüûÈü†ÈüõÈü°Èü§ÈüØÈü±Èü¥Èü∑Èü∏Èü∫È†áÈ†äÈ†ôÈ†çÈ†éÈ†îÈ†ñÈ†úÈ†ûÈ††È†£È†¶"],["8fe8a1","È†´È†ÆÈ†ØÈ†∞È†≤È†≥È†µÈ†•È†æÈ°ÑÈ°áÈ°äÈ°ëÈ°íÈ°ìÈ°ñÈ°óÈ°ôÈ°öÈ°¢È°£È°•È°¶È°™È°¨È¢´È¢≠È¢ÆÈ¢∞È¢¥È¢∑È¢∏È¢∫È¢ªÈ¢øÈ£ÇÈ£ÖÈ£àÈ£åÈ£°È££È£•È£¶È£ßÈ£™È£≥È£∂È§ÇÈ§áÈ§àÈ§ëÈ§ïÈ§ñÈ§óÈ§öÈ§õÈ§úÈ§üÈ§¢È§¶È§ßÈ§´È§±",4,"È§πÈ§∫È§ªÈ§ºÈ•ÄÈ•ÅÈ•ÜÈ•áÈ•àÈ•çÈ•éÈ•îÈ•òÈ•ôÈ•õÈ•úÈ•ûÈ•üÈ•†È¶õÈ¶ùÈ¶üÈ¶¶È¶∞È¶±È¶≤È¶µ"],["8fe9a1","È¶πÈ¶∫È¶ΩÈ¶øÈßÉÈßâÈßìÈßîÈßôÈßöÈßúÈßûÈßßÈß™Èß´Èß¨Èß∞Èß¥ÈßµÈßπÈßΩÈßæÈ®ÇÈ®ÉÈ®ÑÈ®ãÈ®åÈ®êÈ®ëÈ®ñÈ®ûÈ®†È®¢È®£È®§È®ßÈ®≠È®ÆÈ®≥È®µÈ®∂È®∏È©áÈ©ÅÈ©ÑÈ©äÈ©ãÈ©åÈ©éÈ©ëÈ©îÈ©ñÈ©ùÈ™™È™¨È™ÆÈ™ØÈ™≤È™¥È™µÈ™∂È™πÈ™ªÈ™æÈ™øÈ´ÅÈ´ÉÈ´ÜÈ´àÈ´éÈ´êÈ´íÈ´ïÈ´ñÈ´óÈ´õÈ´úÈ´†È´§È´•È´ßÈ´©È´¨È´≤È´≥È´µÈ´πÈ´∫È´ΩÈ´ø",4],["8feaa1","È¨ÑÈ¨ÖÈ¨àÈ¨âÈ¨ãÈ¨åÈ¨çÈ¨éÈ¨êÈ¨íÈ¨ñÈ¨ôÈ¨õÈ¨úÈ¨†È¨¶È¨´È¨≠È¨≥È¨¥È¨µÈ¨∑È¨πÈ¨∫È¨ΩÈ≠àÈ≠ãÈ≠åÈ≠ïÈ≠ñÈ≠óÈ≠õÈ≠ûÈ≠°È≠£È≠•È≠¶È≠®È≠™",4,"È≠≥È≠µÈ≠∑È≠∏È≠πÈ≠øÈÆÄÈÆÑÈÆÖÈÆÜÈÆáÈÆâÈÆäÈÆãÈÆçÈÆèÈÆêÈÆîÈÆöÈÆùÈÆûÈÆ¶ÈÆßÈÆ©ÈÆ¨ÈÆ∞ÈÆ±ÈÆ≤ÈÆ∑ÈÆ∏ÈÆªÈÆºÈÆæÈÆøÈØÅÈØáÈØàÈØéÈØêÈØóÈØòÈØùÈØüÈØ•ÈØßÈØ™ÈØ´ÈØØÈØ≥ÈØ∑ÈØ∏"],["8feba1","ÈØπÈØ∫ÈØΩÈØøÈ∞ÄÈ∞ÇÈ∞ãÈ∞èÈ∞ëÈ∞ñÈ∞òÈ∞ôÈ∞öÈ∞úÈ∞ûÈ∞¢È∞£È∞¶",4,"È∞±È∞µÈ∞∂È∞∑È∞ΩÈ±ÅÈ±ÉÈ±ÑÈ±ÖÈ±âÈ±äÈ±éÈ±èÈ±êÈ±ìÈ±îÈ±ñÈ±òÈ±õÈ±ùÈ±ûÈ±üÈ±£È±©È±™È±úÈ±´È±®È±ÆÈ±∞È±≤È±µÈ±∑È±ªÈ≥¶È≥≤È≥∑È≥πÈ¥ãÈ¥ÇÈ¥ëÈ¥óÈ¥òÈ¥úÈ¥ùÈ¥ûÈ¥ØÈ¥∞È¥≤È¥≥È¥¥È¥∫È¥ºÈµÖÈ¥ΩÈµÇÈµÉÈµáÈµäÈµìÈµîÈµüÈµ£Èµ¢Èµ•Èµ©Èµ™Èµ´Èµ∞Èµ∂Èµ∑Èµª"],["8feca1","ÈµºÈµæÈ∂ÉÈ∂ÑÈ∂ÜÈ∂äÈ∂çÈ∂éÈ∂íÈ∂ìÈ∂ïÈ∂ñÈ∂óÈ∂òÈ∂°È∂™È∂¨È∂ÆÈ∂±È∂µÈ∂πÈ∂ºÈ∂øÈ∑ÉÈ∑áÈ∑âÈ∑äÈ∑îÈ∑ïÈ∑ñÈ∑óÈ∑öÈ∑ûÈ∑üÈ∑†È∑•È∑ßÈ∑©È∑´È∑ÆÈ∑∞È∑≥È∑¥È∑æÈ∏äÈ∏ÇÈ∏áÈ∏éÈ∏êÈ∏ëÈ∏íÈ∏ïÈ∏ñÈ∏ôÈ∏úÈ∏ùÈπ∫ÈπªÈπºÈ∫ÄÈ∫ÇÈ∫ÉÈ∫ÑÈ∫ÖÈ∫áÈ∫éÈ∫èÈ∫ñÈ∫òÈ∫õÈ∫ûÈ∫§È∫®È∫¨È∫ÆÈ∫ØÈ∫∞È∫≥È∫¥È∫µÈªÜÈªàÈªãÈªïÈªüÈª§ÈªßÈª¨Èª≠ÈªÆÈª∞Èª±Èª≤Èªµ"],["8feda1","Èª∏ÈªøÈºÇÈºÉÈºâÈºèÈºêÈºëÈºíÈºîÈºñÈºóÈºôÈºöÈºõÈºüÈº¢Èº¶Èº™Èº´ÈºØÈº±Èº≤Èº¥Èº∑ÈºπÈº∫ÈººÈºΩÈºøÈΩÅÈΩÉ",4,"ÈΩìÈΩïÈΩñÈΩóÈΩòÈΩöÈΩùÈΩûÈΩ®ÈΩ©ÈΩ≠",4,"ÈΩ≥ÈΩµÈΩ∫ÈΩΩÈæèÈæêÈæëÈæíÈæîÈæñÈæóÈæûÈæ°Èæ¢Èæ£Èæ•"]]');

/***/ }),

/***/ 52499:
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('{"uChars":[128,165,169,178,184,216,226,235,238,244,248,251,253,258,276,284,300,325,329,334,364,463,465,467,469,471,473,475,477,506,594,610,712,716,730,930,938,962,970,1026,1104,1106,8209,8215,8218,8222,8231,8241,8244,8246,8252,8365,8452,8454,8458,8471,8482,8556,8570,8596,8602,8713,8720,8722,8726,8731,8737,8740,8742,8748,8751,8760,8766,8777,8781,8787,8802,8808,8816,8854,8858,8870,8896,8979,9322,9372,9548,9588,9616,9622,9634,9652,9662,9672,9676,9680,9702,9735,9738,9793,9795,11906,11909,11913,11917,11928,11944,11947,11951,11956,11960,11964,11979,12284,12292,12312,12319,12330,12351,12436,12447,12535,12543,12586,12842,12850,12964,13200,13215,13218,13253,13263,13267,13270,13384,13428,13727,13839,13851,14617,14703,14801,14816,14964,15183,15471,15585,16471,16736,17208,17325,17330,17374,17623,17997,18018,18212,18218,18301,18318,18760,18811,18814,18820,18823,18844,18848,18872,19576,19620,19738,19887,40870,59244,59336,59367,59413,59417,59423,59431,59437,59443,59452,59460,59478,59493,63789,63866,63894,63976,63986,64016,64018,64021,64025,64034,64037,64042,65074,65093,65107,65112,65127,65132,65375,65510,65536],"gbChars":[0,36,38,45,50,81,89,95,96,100,103,104,105,109,126,133,148,172,175,179,208,306,307,308,309,310,311,312,313,341,428,443,544,545,558,741,742,749,750,805,819,820,7922,7924,7925,7927,7934,7943,7944,7945,7950,8062,8148,8149,8152,8164,8174,8236,8240,8262,8264,8374,8380,8381,8384,8388,8390,8392,8393,8394,8396,8401,8406,8416,8419,8424,8437,8439,8445,8482,8485,8496,8521,8603,8936,8946,9046,9050,9063,9066,9076,9092,9100,9108,9111,9113,9131,9162,9164,9218,9219,11329,11331,11334,11336,11346,11361,11363,11366,11370,11372,11375,11389,11682,11686,11687,11692,11694,11714,11716,11723,11725,11730,11736,11982,11989,12102,12336,12348,12350,12384,12393,12395,12397,12510,12553,12851,12962,12973,13738,13823,13919,13933,14080,14298,14585,14698,15583,15847,16318,16434,16438,16481,16729,17102,17122,17315,17320,17402,17418,17859,17909,17911,17915,17916,17936,17939,17961,18664,18703,18814,18962,19043,33469,33470,33471,33484,33485,33490,33497,33501,33505,33513,33520,33536,33550,37845,37921,37948,38029,38038,38064,38065,38066,38069,38075,38076,38078,39108,39109,39113,39114,39115,39116,39265,39394,189000]}');

/***/ }),

/***/ 48560:
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('[["a140","ÓìÜ",62],["a180","ÓîÖ",32],["a240","Óî¶",62],["a280","Óï•",32],["a2ab","Óù¶",5],["a2e3","‚Ç¨Óù≠"],["a2ef","ÓùÆÓùØ"],["a2fd","Óù∞Óù±"],["a340","ÓñÜ",62],["a380","ÓóÖ",31,"„ÄÄ"],["a440","Óó¶",62],["a480","Óò•",32],["a4f4","Óù≤",10],["a540","ÓôÜ",62],["a580","ÓöÖ",32],["a5f7","ÓùΩ",7],["a640","Óö¶",62],["a680","Óõ•",32],["a6b9","ÓûÖ",7],["a6d9","Óûç",6],["a6ec","ÓûîÓûï"],["a6f3","Óûñ"],["a6f6","Óûó",8],["a740","ÓúÜ",62],["a780","ÓùÖ",32],["a7c2","Óû†",14],["a7f2","ÓûØ",12],["a896","Óûº",10],["a8bc","Óüá"],["a8bf","«π"],["a8c1","ÓüâÓüäÓüãÓüå"],["a8ea","Óüç",20],["a958","Óü¢"],["a95b","Óü£"],["a95d","Óü§Óü•Óü¶"],["a989","„Äæ‚ø∞",11],["a997","Óü¥",12],["a9f0","Ó†Å",14],["aaa1","ÓÄÄ",93],["aba1","ÓÅû",93],["aca1","ÓÇº",93],["ada1","ÓÑö",93],["aea1","ÓÖ∏",93],["afa1","Óáñ",93],["d7fa","Ó†ê",4],["f8a1","Óà¥",93],["f9a1","Óäí",93],["faa1","Óã∞",93],["fba1","Óçé",93],["fca1","Óé¨",93],["fda1","Óêä",93],["fe50","‚∫ÅÓ†ñÓ†óÓ†ò‚∫Ñ„ë≥„ëá‚∫à‚∫ãÓ†û„ñû„òö„òé‚∫å‚∫ó„•Æ„§òÓ†¶„ßè„ßü„©≥„ßêÓ†´Ó†¨„≠é„±Æ„≥†‚∫ßÓ†±Ó†≤‚∫™‰Åñ‰Öü‚∫Æ‰å∑‚∫≥‚∫∂‚∫∑Ó†ª‰é±‰é¨‚∫ª‰èù‰ìñ‰ô°‰ôåÓ°É"],["fe80","‰ú£‰ú©‰ùº‰ûç‚ªä‰•á‰•∫‰•Ω‰¶Ç‰¶É‰¶Ö‰¶Ü‰¶ü‰¶õ‰¶∑‰¶∂Ó°îÓ°ï‰≤£‰≤ü‰≤†‰≤°‰±∑‰≤¢‰¥ì",6,"‰∂ÆÓ°§Óë®",93]]');

/***/ }),

/***/ 98565:
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('[["0","\\u0000",128],["a1","ÔΩ°",62],["8140","„ÄÄ„ÄÅ„ÄÇÔºåÔºé„ÉªÔºöÔºõÔºüÔºÅ„Çõ„Çú¬¥ÔΩÄ¬®ÔºæÔø£Ôºø„ÉΩ„Éæ„Çù„Çû„ÄÉ‰ªù„ÄÖ„ÄÜ„Äá„Éº‚Äï‚ÄêÔºèÔººÔΩû‚à•ÔΩú‚Ä¶‚Ä•‚Äò‚Äô‚Äú‚ÄùÔºàÔºâ„Äî„ÄïÔºªÔºΩÔΩõÔΩù„Äà",9,"ÔºãÔºç¬±√ó"],["8180","√∑Ôºù‚â†ÔºúÔºû‚â¶‚âß‚àû‚à¥‚ôÇ‚ôÄ¬∞‚Ä≤‚Ä≥‚ÑÉÔø•ÔºÑÔø†Ôø°ÔºÖÔºÉÔºÜÔºäÔº†¬ß‚òÜ‚òÖ‚óã‚óè‚óé‚óá‚óÜ‚ñ°‚ñ†‚ñ≥‚ñ≤‚ñΩ‚ñº‚Äª„Äí‚Üí‚Üê‚Üë‚Üì„Äì"],["81b8","‚àà‚àã‚äÜ‚äá‚äÇ‚äÉ‚à™‚à©"],["81c8","‚àß‚à®Ôø¢‚áí‚áî‚àÄ‚àÉ"],["81da","‚à†‚ä•‚åí‚àÇ‚àá‚â°‚âí‚â™‚â´‚àö‚àΩ‚àù‚àµ‚à´‚à¨"],["81f0","‚Ñ´‚Ä∞‚ôØ‚ô≠‚ô™‚Ä†‚Ä°¬∂"],["81fc","‚óØ"],["824f","Ôºê",9],["8260","Ôº°",25],["8281","ÔΩÅ",25],["829f","„ÅÅ",82],["8340","„Ç°",62],["8380","„É†",22],["839f","Œë",16,"Œ£",6],["83bf","Œ±",16,"œÉ",6],["8440","–ê",5,"–Å–ñ",25],["8470","–∞",5,"—ë–∂",7],["8480","–æ",17],["849f","‚îÄ‚îÇ‚îå‚îê‚îò‚îî‚îú‚î¨‚î§‚î¥‚îº‚îÅ‚îÉ‚îè‚îì‚îõ‚îó‚î£‚î≥‚î´‚îª‚ïã‚î†‚îØ‚î®‚î∑‚îø‚îù‚î∞‚î•‚î∏‚ïÇ"],["8740","‚ë†",19,"‚Ö†",9],["875f","„çâ„åî„å¢„çç„åò„åß„åÉ„å∂„çë„çó„åç„å¶„å£„å´„çä„åª„éú„éù„éû„éé„éè„èÑ„é°"],["877e","„çª"],["8780","„Äù„Äü‚Ññ„èç‚Ñ°„ä§",4,"„à±„à≤„àπ„çæ„çΩ„çº‚âí‚â°‚à´‚àÆ‚àë‚àö‚ä•‚à†‚àü‚äø‚àµ‚à©‚à™"],["889f","‰∫úÂîñÂ®ÉÈòøÂìÄÊÑõÊå®Âß∂ÈÄ¢ËëµËåúÁ©êÊÇ™Êè°Ê∏•Êó≠Ëë¶Ëä¶ÈØµÊ¢ìÂúßÊñ°Êâ±ÂÆõÂßêËôªÈ£¥Áµ¢Á∂æÈÆéÊàñÁ≤üË¢∑ÂÆâÂ∫µÊåâÊöóÊ°àÈóáÈûçÊùè‰ª•‰ºä‰Ωç‰æùÂÅâÂõ≤Â§∑ÂßîÂ®ÅÂ∞âÊÉüÊÑèÊÖ∞ÊòìÊ§ÖÁÇ∫ÁïèÁï∞ÁßªÁ∂≠Á∑ØËÉÉËêéË°£Ë¨ÇÈÅïÈÅ∫Âåª‰∫ï‰∫•ÂüüËÇ≤ÈÉÅÁ£Ø‰∏ÄÂ£±Ê∫¢ÈÄ∏Á®≤Ëå®ËäãÈ∞ØÂÖÅÂç∞ÂíΩÂì°Âõ†ÂßªÂºïÈ£≤Ê∑´ËÉ§Ëî≠"],["8940","Èô¢Èô∞Èö†ÈüªÂêãÂè≥ÂÆáÁÉèÁæΩËøÇÈõ®ÂçØÈµúÁ™∫‰∏ëÁ¢ìËáºÊ∏¶ÂòòÂîÑÊ¨ùËîöÈ∞ªÂß•Âé©Êµ¶ÁìúÈñèÂôÇ‰∫ëÈÅãÈõ≤ËçèÈ§åÂè°Âñ∂Â¨∞ÂΩ±Êò†Êõ≥Ê†ÑÊ∞∏Ê≥≥Ê¥©ÁëõÁõàÁ©éÈ†¥Ëã±Ë°õË©†Èã≠Ê∂≤Áñ´ÁõäÈßÖÊÇ¶Ë¨ÅË∂äÈñ≤Ê¶éÂé≠ÂÜÜ"],["8980","ÂúíÂ†∞Â•ÑÂÆ¥Âª∂ÊÄ®Êé©Êè¥Ê≤øÊºîÁÇéÁÑîÁÖôÁáïÁåøÁ∏ÅËâ∂ËãëËñóÈÅ†ÈâõÈ¥õÂ°©ÊñºÊ±öÁî•ÂáπÂ§ÆÂ••ÂæÄÂøúÊäºÊó∫Ê®™Ê¨ßÊÆ¥ÁéãÁøÅË•ñÈ¥¨È¥éÈªÑÂ≤°Ê≤ñËçªÂÑÑÂ±ãÊÜ∂ËáÜÊ°∂Áâ°‰πô‰ø∫Âç∏ÊÅ©Ê∏©Á©èÈü≥‰∏ãÂåñ‰ªÆ‰Ωï‰ºΩ‰æ°‰Ω≥Âä†ÂèØÂòâÂ§èÂ´ÅÂÆ∂ÂØ°ÁßëÊöáÊûúÊû∂Ê≠åÊ≤≥ÁÅ´ÁèÇÁ¶çÁ¶æÁ®ºÁÆáËä±ËãõËåÑËç∑ËèØËèìËù¶Ë™≤Âò©Ë≤®Ëø¶ÈÅéÈúûËöä‰øÑÂ≥®ÊàëÁâôÁîªËá•ËäΩËõæË≥ÄÈõÖÈ§ìÈßï‰ªã‰ºöËß£ÂõûÂ°äÂ£äÂªªÂø´ÊÄ™ÊÇîÊÅ¢ÊáêÊàíÊãêÊîπ"],["8a40","È≠ÅÊô¶Ê¢∞Êµ∑ÁÅ∞ÁïåÁöÜÁµµËä•ËüπÈñãÈöéË≤ùÂá±ÂäæÂ§ñÂí≥ÂÆ≥Â¥ñÊÖ®Ê¶ÇÊ∂ØÁ¢çËìãË°óË©≤ÈéßÈ™∏Êµ¨È¶®ËõôÂû£ÊüøËõéÈàéÂäÉÂöáÂêÑÂªìÊã°ÊíπÊ†ºÊ†∏ÊÆªÁç≤Á¢∫Á©´Ë¶öËßíËµ´ËºÉÈÉ≠Èñ£ÈöîÈù©Â≠¶Â≤≥Ê•ΩÈ°çÈ°éÊéõÁ¨†Ê®´"],["8a80","Ê©øÊ¢∂È∞çÊΩüÂâ≤ÂñùÊÅ∞Êã¨Ê¥ªÊ∏áÊªëËëõË§êËΩÑ‰∏îÈ∞πÂè∂Ê§õÊ®∫ÈûÑÊ†™ÂÖúÁ´ÉËí≤ÈáúÈéåÂôõÈ¥®Ê†¢ËåÖËê±Á≤•ÂààËãÖÁì¶‰πæ‰æÉÂÜ†ÂØíÂàäÂãòÂãßÂ∑ªÂñöÂ†™Âß¶ÂÆåÂÆòÂØõÂπ≤ÂππÊÇ£ÊÑüÊÖ£ÊÜæÊèõÊï¢ÊüëÊ°ìÊ£∫Ê¨æÊ≠ìÊ±óÊº¢ÊæóÊΩÖÁí∞ÁîòÁõ£ÁúãÁ´øÁÆ°Á∞°Á∑©Áº∂Áø∞ËÇùËâ¶ËéûË¶≥Ë´åË≤´ÈÇÑÈëëÈñìÈñëÈñ¢Èô•ÈüìÈ§®Ëàò‰∏∏Âê´Â≤∏Â∑åÁé©ÁôåÁúºÂ≤©Áø´Ë¥ãÈõÅÈ†ëÈ°îÈ°ò‰ºÅ‰ºéÂç±ÂñúÂô®Âü∫Â•áÂ¨âÂØÑÂ≤êÂ∏åÂπæÂøåÊèÆÊú∫ÊóóÊó¢ÊúüÊ£ãÊ£Ñ"],["8b40","Ê©üÂ∏∞ÊØÖÊ∞óÊ±ΩÁïøÁ•àÂ≠£Á®ÄÁ¥ÄÂæΩË¶èË®òË≤¥Ëµ∑ËªåËºùÈ£¢È®éÈ¨º‰∫ÄÂÅΩÂÑÄÂ¶ìÂÆúÊàØÊäÄÊì¨Ê¨∫Áä†ÁñëÁ•áÁæ©ËüªË™ºË≠∞Êé¨ËèäÈû†ÂêâÂêÉÂñ´Ê°îÊ©òË©∞Á†ßÊùµÈªçÂç¥ÂÆ¢ËÑöËôêÈÄÜ‰∏ò‰πÖ‰ªá‰ºëÂèäÂê∏ÂÆÆÂºìÊÄ•Êïë"],["8b80","ÊúΩÊ±ÇÊ±≤Ê≥£ÁÅ∏ÁêÉÁ©∂Á™ÆÁ¨àÁ¥öÁ≥æÁµ¶ÊóßÁâõÂéªÂ±ÖÂ∑®ÊãíÊã†ÊåôÊ∏†ËôöË®±Ë∑ùÈã∏ÊºÅÁ¶¶È≠ö‰∫®‰∫´‰∫¨‰æõ‰æ†ÂÉëÂÖáÁ´∂ÂÖ±Âá∂ÂçîÂå°ÂçøÂè´Âñ¨Â¢ÉÂ≥°Âº∑ÂΩäÊÄØÊÅêÊÅ≠ÊåüÊïôÊ©ãÊ≥ÅÁãÇÁã≠ÁüØËÉ∏ËÑÖËààËïéÈÉ∑Èè°ÈüøÈ•óÈ©ö‰ª∞ÂáùÂ∞≠ÊöÅÊ•≠Â±ÄÊõ≤Ê•µÁéâÊ°êÁ≤ÅÂÉÖÂã§ÂùáÂ∑æÈå¶Êñ§Ê¨£Ê¨ΩÁê¥Á¶ÅÁ¶ΩÁ≠ãÁ∑äËäπËèåË°øË•üË¨πËøëÈáëÂêüÈäÄ‰πùÂÄ∂Âè•Âå∫ÁãóÁéñÁü©Ëã¶Ë∫ØÈßÜÈßàÈßíÂÖ∑ÊÑöËôûÂñ∞Á©∫ÂÅ∂ÂØìÈÅáÈöÖ‰∏≤Ê´õÈáßÂ±ëÂ±à"],["8c40","ÊéòÁ™üÊ≤ìÈù¥ËΩ°Á™™ÁÜäÈöàÁ≤ÇÊ†óÁπ∞Ê°ëÈç¨Âã≤ÂêõËñ´Ë®ìÁæ§ËªçÈÉ°Âç¶Ë¢àÁ•Å‰øÇÂÇæÂàëÂÖÑÂïìÂú≠Áè™ÂûãÂ•ëÂΩ¢ÂæÑÊÅµÊÖ∂ÊÖßÊÜ©Êé≤Êê∫Êï¨ÊôØÊ°ÇÊ∏ìÁï¶Á®ΩÁ≥ªÁµåÁ∂ôÁπãÁΩ´ËåéËçäËõçË®àË©£Ë≠¶ËªΩÈ†öÈ∂èËä∏ËøéÈØ®"],["8c80","ÂäáÊàüÊíÉÊøÄÈöôÊ°ÅÂÇëÊ¨†Ê±∫ÊΩîÁ©¥ÁµêË°ÄË®£Êúà‰ª∂ÂÄπÂÄ¶ÂÅ•ÂÖºÂà∏Ââ£ÂñßÂúèÂ†ÖÂ´åÂª∫ÊÜ≤Êá∏Êã≥Êç≤Ê§úÊ®©ÁâΩÁä¨ÁåÆÁ†îÁ°ØÁµπÁúåËÇ©Ë¶ãË¨ôË≥¢ËªíÈÅ£ÈçµÈô∫È°ïÈ®ìÈπ∏ÂÖÉÂéüÂé≥ÂπªÂº¶Ê∏õÊ∫êÁéÑÁèæÁµÉËà∑Ë®ÄË´∫Èôê‰πéÂÄãÂè§ÂëºÂõ∫ÂßëÂ≠§Â∑±Â∫´ÂºßÊà∏ÊïÖÊûØÊπñÁãêÁ≥äË¢¥ËÇ°ËÉ°Ëè∞ËôéË™áË∑®Èà∑ÈõáÈ°ßÈºì‰∫î‰∫í‰ºçÂçàÂëâÂêæÂ®ØÂæåÂæ°ÊÇüÊ¢ßÊ™éÁëöÁ¢ÅË™ûË™§Ë≠∑ÈÜê‰πûÈØâ‰∫§‰Ωº‰æØÂÄôÂÄñÂÖâÂÖ¨ÂäüÂäπÂãæÂéöÂè£Âêë"],["8d40","ÂêéÂñâÂùëÂû¢Â•ΩÂ≠îÂ≠ùÂÆèÂ∑•Â∑ßÂ∑∑Âπ∏Â∫ÉÂ∫öÂ∫∑ÂºòÊÅíÊÖåÊäóÊãòÊéßÊîªÊòÇÊôÉÊõ¥Êù≠Ê†°Ê¢óÊßãÊ±üÊ¥™Êµ©Ê∏ØÊ∫ùÁî≤ÁöáÁ°¨Á®øÁ≥†Á¥ÖÁ¥òÁµûÁ∂±ËÄïËÄÉËÇØËÇ±ËÖîËÜèËà™ËçíË°åË°°Ë¨õË≤¢Ë≥ºÈÉäÈÖµÈâ±Á†øÈãºÈñ§Èôç"],["8d80","È†ÖÈ¶ôÈ´òÈ¥ªÂâõÂä´Âè∑ÂêàÂ£ïÊã∑Êø†Ë±™ËΩüÈ∫πÂÖãÂàªÂëäÂõΩÁ©ÄÈÖ∑Èµ†ÈªíÁçÑÊºâËÖ∞ÁîëÂøΩÊÉöÈ™®ÁãõËæºÊ≠§È†É‰ªäÂõ∞Âù§Â¢æÂ©öÊÅ®ÊááÊòèÊòÜÊ†πÊ¢±Ê∑∑ÁóïÁ¥∫ËâÆÈ≠Ç‰∫õ‰ΩêÂèâÂîÜÂµØÂ∑¶Â∑ÆÊüªÊ≤ôÁë≥Á†ÇË©êÈéñË£üÂùêÂ∫ßÊå´ÂÇµÂÇ¨ÂÜçÊúÄÂìâÂ°ûÂ¶ªÂÆ∞ÂΩ©ÊâçÊé°Ê†ΩÊ≠≥Ê∏àÁÅΩÈááÁäÄÁ†ïÁ†¶Á•≠ÊñéÁ¥∞ËèúË£ÅËºâÈöõÂâ§Âú®ÊùêÁΩ™Ë≤°ÂÜ¥ÂùÇÈò™Â†∫Ê¶äËÇ¥Âí≤Â¥éÂüºÁ¢ïÈ∑∫‰ΩúÂâäÂíãÊêæÊò®ÊúîÊüµÁ™ÑÁ≠ñÁ¥¢ÈåØÊ°úÈÆ≠Á¨πÂåôÂÜäÂà∑"],["8e40","ÂØüÊã∂ÊíÆÊì¶Êú≠ÊÆ∫Ëñ©ÈõëÁöêÈØñÊçåÈåÜÈÆ´ÁöøÊôí‰∏âÂÇòÂèÇÂ±±ÊÉ®ÊííÊï£Ê°üÁá¶ÁèäÁî£ÁÆóÁ∫ÇËöïËÆÉË≥õÈÖ∏È§êÊñ¨Êö´ÊÆã‰ªï‰ªî‰º∫‰ΩøÂà∫Âè∏Âè≤Âó£ÂõõÂ£´ÂßãÂßâÂßøÂ≠êÂ±çÂ∏ÇÂ∏´ÂøóÊÄùÊåáÊîØÂ≠úÊñØÊñΩÊó®ÊûùÊ≠¢"],["8e80","Ê≠ªÊ∞èÁçÖÁ•âÁßÅÁ≥∏Á¥ôÁ¥´ËÇ¢ËÑÇËá≥Ë¶ñË©ûË©©Ë©¶Ë™åË´ÆË≥áË≥úÈõåÈ£ºÊ≠Ø‰∫ã‰ºº‰æçÂÖêÂ≠óÂØ∫ÊÖàÊåÅÊôÇÊ¨°ÊªãÊ≤ªÁàæÁíΩÁóîÁ£ÅÁ§∫ËÄåËÄ≥Ëá™ËíîËæûÊ±êÈπøÂºèË≠òÈ¥´Á´∫Ëª∏ÂÆçÈõ´‰∏ÉÂè±Âü∑Â§±Â´âÂÆ§ÊÇâÊπøÊºÜÁñæË≥™ÂÆüËîÄÁØ†ÂÅ≤Êü¥ËäùÂ±°ËïäÁ∏ûËàéÂÜôÂ∞ÑÊç®Ëµ¶ÊñúÁÖÆÁ§æÁ¥óËÄÖË¨ùËªäÈÅÆËõáÈÇ™ÂÄüÂã∫Â∞∫ÊùìÁÅºÁàµÈÖåÈáàÈå´Ëã•ÂØÇÂº±ÊÉπ‰∏ªÂèñÂÆàÊâãÊú±ÊÆäÁã©Áè†Á®ÆËÖ´Ë∂£ÈÖíÈ¶ñÂÑíÂèóÂë™ÂØøÊéàÊ®πÁ∂¨ÈúÄÂõöÂèéÂë®"],["8f40","ÂÆóÂ∞±Â∑û‰øÆÊÑÅÊãæÊ¥≤ÁßÄÁßãÁµÇÁπçÁøíËá≠ËàüËíêË°ÜË•≤ËÆêËπ¥ËºØÈÄ±ÈÖãÈÖ¨ÈõÜÈÜú‰ªÄ‰ΩèÂÖÖÂçÅÂæìÊàéÊüîÊ±ÅÊ∏ãÁç£Á∏¶ÈáçÈäÉÂèîÂ§ôÂÆøÊ∑ëÁ•ùÁ∏ÆÁ≤õÂ°æÁÜüÂá∫Ë°ìËø∞‰øäÂ≥ªÊò•Áû¨Á´£ËàúÈßøÂáÜÂæ™Êó¨Ê•ØÊÆâÊ∑≥"],["8f80","Ê∫ñÊΩ§ÁõæÁ¥îÂ∑°ÈÅµÈÜáÈ†ÜÂá¶ÂàùÊâÄÊöëÊõôÊ∏öÂ∫∂Á∑íÁΩ≤Êõ∏ËñØËó∑Ë´∏Âä©ÂèôÂ•≥Â∫èÂæêÊÅïÈã§Èô§ÂÇ∑ÂÑüÂãùÂå†ÂçáÂè¨Âì®ÂïÜÂî±ÂòóÂ•®Â¶æÂ®ºÂÆµÂ∞ÜÂ∞èÂ∞ëÂ∞öÂ∫ÑÂ∫äÂª†ÂΩ∞ÊâøÊäÑÊãõÊéåÊç∑ÊòáÊòåÊò≠Êô∂ÊùæÊ¢¢Ê®üÊ®µÊ≤ºÊ∂àÊ∏âÊπòÁÑºÁÑ¶ÁÖßÁóáÁúÅÁ°ùÁ§ÅÁ••Áß∞Á´†Á¨ëÁ≤ßÁ¥πËÇñËèñËíãËïâË°ùË£≥Ë®üË®ºË©îË©≥Ë±°Ë≥ûÈÜ§Èâ¶ÈçæÈêòÈöúÈûò‰∏ä‰∏à‰∏û‰πóÂÜóÂâ∞ÂüéÂ†¥Â£åÂ¨¢Â∏∏ÊÉÖÊìæÊù°ÊùñÊµÑÁä∂Áï≥Á©£Ëí∏Ë≠≤ÈÜ∏Èå†Âò±Âü¥È£æ"],["9040","Êã≠Ê§çÊÆñÁá≠ÁπîËÅ∑Ëâ≤Ëß¶È£üËùïËæ±Â∞ª‰º∏‰ø°‰æµÂîáÂ®†ÂØùÂØ©ÂøÉÊÖéÊåØÊñ∞ÊôãÊ£ÆÊ¶õÊµ∏Ê∑±Áî≥ÁñπÁúüÁ•ûÁß¶Á¥≥Ëá£ËäØËñ™Ë¶™Ë®∫Ë∫´ËæõÈÄ≤ÈáùÈúá‰∫∫‰ªÅÂàÉÂ°µÂ£¨Â∞ãÁîöÂ∞ΩËÖéË®äËøÖÈô£Èù≠Á¨•Ë´èÈ†àÈÖ¢Âõ≥Âé®"],["9080","ÈÄóÂêπÂûÇÂ∏•Êé®Ê∞¥ÁÇäÁù°Á≤ãÁø†Ë°∞ÈÅÇÈÖîÈåêÈåòÈöèÁëûÈ´ÑÂ¥áÂµ©Êï∞Êû¢Ë∂®ÈõõÊçÆÊùâÊ§ôËèÖÈ†óÈõÄË£æÊæÑÊë∫ÂØ∏‰∏ñÁÄ¨ÁïùÊòØÂáÑÂà∂Âã¢ÂßìÂæÅÊÄßÊàêÊîøÊï¥ÊòüÊô¥Ê£≤Ê†ñÊ≠£Ê∏ÖÁâ≤ÁîüÁõõÁ≤æËÅñÂ£∞Ë£ΩË•øË™†Ë™ìË´ãÈÄùÈÜíÈùíÈùôÊñâÁ®éËÑÜÈöªÂ∏≠ÊÉúÊàöÊñ•ÊòîÊûêÁü≥Á©çÁ±çÁ∏æËÑäË≤¨Ëµ§Ë∑°ËπüÁ¢©ÂàáÊãôÊé•ÊëÇÊäòË®≠Á™ÉÁØÄË™¨Èõ™Áµ∂ËàåËùâ‰ªôÂÖàÂçÉÂç†ÂÆ£Â∞ÇÂ∞ñÂ∑ùÊà¶ÊâáÊí∞Ê†ìÊ†¥Ê≥âÊµÖÊ¥óÊüìÊΩúÁÖéÁÖΩÊóãÁ©øÁÆ≠Á∑ö"],["9140","ÁπäÁæ®ËÖ∫ËàõËàπËñ¶Ë©ÆË≥éË∑µÈÅ∏ÈÅ∑Èä≠ÈäëÈñÉÈÆÆÂâçÂñÑÊº∏ÁÑ∂ÂÖ®Á¶ÖÁπïËÜ≥Á≥éÂôåÂ°ëÂ≤®Êé™ÊõæÊõΩÊ•öÁãôÁñèÁñéÁ§éÁ•ñÁßüÁ≤óÁ¥†ÁµÑËòáË®¥ÈòªÈÅ°Èº†ÂÉßÂâµÂèåÂè¢ÂÄâÂñ™Â£ÆÂ•èÁàΩÂÆãÂ±§ÂåùÊÉ£ÊÉ≥ÊçúÊéÉÊåøÊéª"],["9180","ÊìçÊó©ÊõπÂ∑£ÊßçÊßΩÊºïÁá•‰∫âÁó©Áõ∏Á™ìÁ≥üÁ∑èÁ∂úËÅ°ËçâËçòËë¨ËíºËóªË£ÖËµ∞ÈÄÅÈÅ≠ÈéóÈúúÈ®íÂÉèÂ¢óÊÜéËáìËîµË¥àÈÄ†‰øÉÂÅ¥ÂâáÂç≥ÊÅØÊçâÊùüÊ∏¨Ë∂≥ÈÄü‰øóÂ±ûË≥äÊóèÁ∂öÂçíË¢ñÂÖ∂ÊèÉÂ≠òÂ≠´Â∞äÊêçÊùëÈÅú‰ªñÂ§öÂ§™Ê±∞Ë©ëÂîæÂ†ïÂ¶•ÊÉ∞ÊâìÊüÅËàµÊ•ïÈôÄÈßÑÈ®®‰ΩìÂ†ÜÂØæËÄêÂ≤±Â∏ØÂæÖÊÄ†ÊÖãÊà¥ÊõøÊ≥∞ÊªûËÉéËÖøËãîË¢ãË≤∏ÈÄÄÈÄÆÈöäÈªõÈØõ‰ª£Âè∞Â§ßÁ¨¨ÈÜçÈ°åÈ∑πÊªùÁÄßÂçìÂïÑÂÆÖÊâòÊäûÊãìÊ≤¢ÊøØÁê¢Ë®óÈê∏ÊøÅË´æËå∏ÂáßËõ∏Âè™"],["9240","Âè©‰ΩÜÈÅîËæ∞Â•™ËÑ±Â∑ΩÁ´™ËæøÊ£öË∞∑Áã∏È±àÊ®ΩË™∞‰∏πÂçòÂòÜÂù¶ÊãÖÊé¢Êó¶Ê≠éÊ∑°ÊπõÁÇ≠Áü≠Á´ØÁÆ™Á∂ªËÄΩËÉÜËõãË™ïÈçõÂõ£Â£áÂºæÊñ≠ÊöñÊ™ÄÊÆµÁî∑Ë´áÂÄ§Áü•Âú∞ÂºõÊÅ•Êô∫Ê±†Áó¥Á®öÁΩÆËá¥ËúòÈÅÖÈ¶≥ÁØâÁïúÁ´πÁ≠ëËìÑ"],["9280","ÈÄêÁß©Á™íËå∂Â´°ÁùÄ‰∏≠‰ª≤ÂÆôÂø†ÊäΩÊòºÊü±Ê≥®Ëô´Ë°∑Ë®ªÈÖéÈã≥ÈßêÊ®óÁÄ¶Áå™ËãßËëóË≤Ø‰∏ÅÂÖÜÂáãÂñãÂØµÂ∏ñÂ∏≥Â∫ÅÂºîÂºµÂΩ´Âæ¥Êá≤ÊåëÊö¢ÊúùÊΩÆÁâíÁî∫Áú∫ËÅ¥ËÑπËÖ∏Ëù∂Ë™øË´úË∂ÖË∑≥ÈäöÈï∑È†ÇÈ≥•ÂãÖÊçóÁõ¥ÊúïÊ≤àÁèçË≥ÉÈéÆÈô≥Ê¥•Â¢úÊ§éÊßåËøΩÈéöÁóõÈÄöÂ°öÊ†ÇÊé¥Êßª‰ΩÉÊº¨ÊüòËæªËî¶Á∂¥ÈçîÊ§øÊΩ∞Âù™Â£∑Â¨¨Á¥¨Áà™ÂêäÈá£È∂¥‰∫≠‰ΩéÂÅúÂÅµÂâÉË≤ûÂëàÂ†§ÂÆöÂ∏ùÂ∫ïÂ∫≠Âª∑ÂºüÊÇåÊäµÊå∫ÊèêÊ¢ØÊ±ÄÁ¢áÁ¶éÁ®ãÁ∑†ËâáË®ÇË´¶ËπÑÈÄì"],["9340","ÈÇ∏ÈÑ≠ÈáòÈºéÊ≥•ÊëòÊì¢ÊïµÊª¥ÁöÑÁ¨õÈÅ©ÈèëÊ∫∫Âì≤ÂæπÊí§ËΩçËø≠ÈâÑÂÖ∏Â°´Â§©Â±ïÂ∫óÊ∑ªÁ∫èÁîúË≤ºËª¢È°õÁÇπ‰ºùÊÆøÊæ±Áî∞ÈõªÂÖéÂêêÂ†µÂ°óÂ¶¨Â±†ÂæíÊñóÊùúÊ∏°ÁôªËèüË≥≠ÈÄîÈÉΩÈççÁ†•Á†∫Âä™Â∫¶ÂúüÂ•¥ÊÄíÂÄíÂÖöÂÜ¨"],["9380","ÂáçÂàÄÂîêÂ°îÂ°òÂ•óÂÆïÂ≥∂Â∂ãÊÇºÊäïÊê≠Êù±Ê°ÉÊ¢ºÊ£üÁõóÊ∑òÊπØÊ∂õÁÅØÁáàÂΩìÁóòÁ•∑Á≠âÁ≠îÁ≠íÁ≥ñÁµ±Âà∞Ëë£Ëï©Ëó§Ë®éË¨ÑË±ÜË∏èÈÄÉÈÄèÈêôÈô∂È†≠È®∞ÈóòÂÉçÂãïÂêåÂ†ÇÂ∞éÊÜßÊíûÊ¥ûÁû≥Á´•ËÉ¥ËêÑÈÅìÈäÖÂ≥†È¥áÂåøÂæóÂæ≥Ê∂úÁâπÁù£Á¶øÁØ§ÊØíÁã¨Ë™≠Ê†ÉÊ©°Âá∏Á™ÅÊ§¥Â±äÈ≥∂Ëã´ÂØÖÈÖâÁÄûÂô∏Â±ØÊÉáÊï¶Ê≤åË±öÈÅÅÈ†ìÂëëÊõáÈàçÂ•àÈÇ£ÂÜÖ‰πçÂá™ËñôË¨éÁÅòÊç∫ÈçãÊ•¢È¶¥Á∏ÑÁï∑ÂçóÊ•†ËªüÈõ£Ê±ù‰∫åÂ∞ºÂºêËø©ÂåÇË≥ëËÇâËôπÂªøÊó•‰π≥ÂÖ•"],["9440","Â¶ÇÂ∞øÈüÆ‰ªªÂ¶äÂøçË™çÊø°Á¶∞Á•¢ÂØßËë±Áå´ÁÜ±Âπ¥ÂøµÊçªÊíöÁáÉÁ≤ò‰πÉÂªº‰πãÂüúÂö¢ÊÇ©ÊøÉÁ¥çËÉΩËÑ≥ËÜøËæ≤Ë¶óËö§Â∑¥ÊääÊí≠Ë¶áÊù∑Ê≥¢Ê¥æÁê∂Á†¥Â©ÜÁΩµËä≠È¶¨‰ø≥ÂªÉÊãùÊéíÊïóÊùØÁõÉÁâåËÉåËÇ∫Ëº©ÈÖçÂÄçÂüπÂ™íÊ¢Ö"],["9480","Ê•≥ÁÖ§ÁãΩË≤∑Â£≤Ë≥†Èô™ÈÄôËùøÁß§ÁüßËê©‰ºØÂâ•ÂçöÊãçÊüèÊ≥äÁôΩÁÆîÁ≤ïËà∂ËñÑËø´ÊõùÊº†ÁàÜÁ∏õËé´ÈßÅÈ∫¶ÂáΩÁÆ±Á°≤ÁÆ∏ËÇáÁ≠àÊ´®Âπ°ËÇåÁïëÁï†ÂÖ´Èâ¢Ê∫åÁô∫ÈÜóÈ´™‰ºêÁΩ∞ÊäúÁ≠èÈñ•È≥©Âô∫Â°ôËõ§Èöº‰º¥Âà§ÂçäÂèçÂèõÂ∏ÜÊê¨ÊñëÊùøÊ∞æÊ±éÁâàÁäØÁè≠ÁïîÁπÅËà¨Ëó©Ë≤©ÁØÑÈáÜÁÖ©È†íÈ£ØÊåΩÊô©Áï™Áõ§Á£êËïÉËõÆÂå™ÂçëÂê¶Â¶ÉÂ∫áÂΩºÊÇ≤ÊââÊâπÊä´ÊñêÊØîÊ≥åÁñ≤ÁöÆÁ¢ëÁßòÁ∑ãÁΩ∑ËÇ•Ë¢´Ë™πË≤ªÈÅøÈùûÈ£õÊ®ãÁ∞∏ÂÇôÂ∞æÂæÆÊûáÊØòÁêµÁúâÁæé"],["9540","ÈºªÊüäÁ®óÂåπÁñãÈ´≠ÂΩ¶ËÜùËè±ËÇòÂººÂøÖÁï¢Á≠ÜÈÄºÊ°ßÂß´Â™õÁ¥êÁôæË¨¨‰øµÂΩ™Ê®ôÊ∞∑ÊºÇÁì¢Á•®Ë°®Ë©ïË±πÂªüÊèèÁóÖÁßíËãóÈå®Èã≤ËíúËõ≠È∞≠ÂìÅÂΩ¨ÊñåÊµúÁÄïË≤ßË≥ìÈ†ªÊïèÁì∂‰∏ç‰ªòÂü†Â§´Â©¶ÂØåÂÜ®Â∏ÉÂ∫úÊÄñÊâ∂Êï∑"],["9580","ÊñßÊôÆÊµÆÁà∂Á¨¶ËÖêËÜöËäôË≠úË≤†Ë≥¶Ëµ¥ÈòúÈôÑ‰æÆÊí´Ê≠¶ËàûËë°Ëï™ÈÉ®Â∞ÅÊ•ìÈ¢®Ëë∫Ëïó‰ºèÂâØÂæ©ÂπÖÊúçÁ¶èËÖπË§áË¶ÜÊ∑µÂºóÊâïÊ≤∏‰ªèÁâ©ÈÆíÂàÜÂêªÂô¥Â¢≥ÊÜ§ÊâÆÁÑöÂ•ÆÁ≤âÁ≥ûÁ¥õÈõ∞ÊñáËÅû‰∏ô‰ΩµÂÖµÂ°ÄÂπ£Âπ≥ÂºäÊüÑ‰∏¶ËîΩÈñâÈôõÁ±≥È†ÅÂÉªÂ£ÅÁôñÁ¢ßÂà•Áû•ËîëÁÆÜÂÅèÂ§âÁâáÁØáÁ∑®Ëæ∫ËøîÈÅç‰æøÂãâÂ®©ÂºÅÈû≠‰øùËàóÈã™ÂúÉÊçïÊ≠©Áî´Ë£úËºîÁ©ÇÂãüÂ¢ìÊÖïÊàäÊöÆÊØçÁ∞øËè©ÂÄ£‰ø∏ÂåÖÂëÜÂ†±Â•âÂÆùÂ≥∞Â≥ØÂ¥©Â∫ñÊä±ÊçßÊîæÊñπÊúã"],["9640","Ê≥ïÊ≥°ÁÉπÁ†≤Á∏´ËÉûËä≥ËêåËì¨ËúÇË§íË®™Ë±äÈÇ¶ÈãíÈ£ΩÈ≥≥Èµ¨‰πè‰∫°ÂÇçÂâñÂùäÂ¶®Â∏ΩÂøòÂøôÊàøÊö¥ÊúõÊüêÊ£íÂÜíÁ¥°ËÇ™ËÜ®Ë¨ÄË≤åË≤øÈâæÈò≤Âê†È†¨ÂåóÂÉïÂçúÂ¢®Êí≤Êú¥ÁâßÁù¶Á©ÜÈá¶ÂãÉÊ≤°ÊÆÜÂ†ÄÂπåÂ•îÊú¨ÁøªÂá°ÁõÜ"],["9680","Êë©Á£®È≠îÈ∫ªÂüãÂ¶πÊòßÊûöÊØéÂì©ÊßôÂπïËÜúÊûïÈÆ™ÊüæÈ±íÊ°ù‰∫¶‰ø£ÂèàÊäπÊú´Ê≤´ËøÑ‰æ≠Áπ≠È∫ø‰∏áÊÖ¢Ê∫ÄÊº´ËîìÂë≥Êú™È≠ÖÂ∑≥ÁÆïÂ≤¨ÂØÜËúúÊπäËìëÁ®îËÑàÂ¶ôÁ≤çÊ∞ëÁú†ÂãôÂ§¢ÁÑ°ÁâüÁüõÈúßÈµ°Ê§ãÂ©øÂ®òÂÜ•ÂêçÂëΩÊòéÁõüËø∑ÈäòÈ≥¥Âß™ÁâùÊªÖÂÖçÊ£âÁ∂øÁ∑¨Èù¢È∫∫Êë∏Ê®°ËåÇÂ¶ÑÂ≠üÊØõÁåõÁõ≤Á∂≤ËÄóËíôÂÑ≤Êú®ÈªôÁõÆÊù¢ÂãøÈ§ÖÂ∞§ÊàªÁ±æË≤∞ÂïèÊÇ∂Á¥ãÈñÄÂåÅ‰πüÂÜ∂Â§úÁà∫ËÄ∂ÈáéÂº•Áü¢ÂéÑÂΩπÁ¥ÑËñ¨Ë®≥Ë∫çÈùñÊü≥ËñÆÈëìÊÑâÊÑàÊ≤πÁôí"],["9740","Ë´≠Ëº∏ÂîØ‰ΩëÂÑ™ÂãáÂèãÂÆ•ÂπΩÊÇ†ÊÜÇÊèñÊúâÊüöÊπßÊ∂åÁå∂Áå∑Áî±Á•êË£ïË™òÈÅäÈÇëÈÉµÈõÑËûçÂ§ï‰∫à‰Ωô‰∏éË™âËºøÈ†êÂÇ≠ÂπºÂ¶ñÂÆπÂ∫∏ÊèöÊè∫ÊìÅÊõúÊ•äÊßòÊ¥ãÊ∫∂ÁÜîÁî®Á™ØÁæäËÄÄËëâËìâË¶ÅË¨°Ë∏äÈÅ•ÈôΩÈ§äÊÖæÊäëÊ¨≤"],["9780","Ê≤ÉÊµ¥ÁøåÁøºÊ∑ÄÁæÖËû∫Ë£∏Êù•Ëé±È†ºÈõ∑Ê¥õÁµ°ËêΩÈÖ™‰π±ÂçµÂµêÊ¨ÑÊø´ËóçËò≠Ë¶ßÂà©ÂêèÂ±•ÊùéÊ¢®ÁêÜÁíÉÁó¢Ë£èË£°ÈáåÈõ¢Èô∏ÂæãÁéáÁ´ãËëéÊé†Áï•ÂäâÊµÅÊ∫úÁêâÁïôÁ°´Á≤íÈöÜÁ´úÈæç‰æ∂ÊÖÆÊóÖËôú‰∫Ü‰∫ÆÂÉö‰∏°ÂáåÂØÆÊñôÊ¢ÅÊ∂ºÁåüÁôÇÁû≠Á®úÁ≥ßËâØË´íÈÅºÈáèÈôµÈ†òÂäõÁ∑ëÂÄ´ÂéòÊûóÊ∑ãÁáêÁê≥Ëá®Ëº™Èö£È±óÈ∫üÁë†Â°ÅÊ∂ôÁ¥ØÈ°û‰ª§‰º∂‰æãÂÜ∑Âä±Â∂∫ÊÄúÁé≤Á§ºËãìÈà¥Èö∑Èõ∂ÈúäÈ∫óÈΩ¢Êö¶Ê≠¥ÂàóÂä£ÁÉàË£ÇÂªâÊÅãÊÜêÊº£ÁÖâÁ∞æÁ∑¥ËÅØ"],["9840","ËìÆÈÄ£Èå¨ÂëÇÈ≠ØÊ´ìÁÇâË≥ÇË∑ØÈú≤Âä¥Â©ÅÂªäÂºÑÊúóÊ•ºÊ¶îÊµ™ÊºèÁâ¢ÁãºÁØ≠ËÄÅËÅæËùãÈÉéÂÖ≠È∫ìÁ¶ÑËÇãÈå≤Ë´ñÂÄ≠ÂíåË©±Ê≠™Ë≥ÑËÑáÊÉëÊû†È∑≤‰∫ô‰∫òÈ∞êË©´ËóÅËï®Ê§ÄÊπæÁ¢óËÖï"],["989f","Âºå‰∏ê‰∏ï‰∏™‰∏±‰∏∂‰∏º‰∏ø‰πÇ‰πñ‰πò‰∫Ç‰∫ÖË±´‰∫äËàíÂºç‰∫é‰∫û‰∫ü‰∫†‰∫¢‰∫∞‰∫≥‰∫∂‰ªé‰ªç‰ªÑ‰ªÜ‰ªÇ‰ªó‰ªû‰ª≠‰ªü‰ª∑‰ºâ‰Ωö‰º∞‰Ωõ‰Ωù‰Ωó‰Ωá‰Ω∂‰æà‰æè‰æò‰Ωª‰Ω©‰Ω∞‰æë‰ΩØ‰æÜ‰æñÂÑò‰øî‰øü‰øé‰øò‰øõ‰øë‰øö‰øê‰ø§‰ø•ÂÄöÂÄ®ÂÄîÂÄ™ÂÄ•ÂÄÖ‰ºú‰ø∂ÂÄ°ÂÄ©ÂÄ¨‰øæ‰øØÂÄëÂÄÜÂÅÉÂÅáÊúÉÂÅïÂÅêÂÅàÂÅöÂÅñÂÅ¨ÂÅ∏ÂÇÄÂÇöÂÇÖÂÇ¥ÂÇ≤"],["9940","ÂÉâÂÉäÂÇ≥ÂÉÇÂÉñÂÉûÂÉ•ÂÉ≠ÂÉ£ÂÉÆÂÉπÂÉµÂÑâÂÑÅÂÑÇÂÑñÂÑïÂÑîÂÑöÂÑ°ÂÑ∫ÂÑ∑ÂÑºÂÑªÂÑøÂÖÄÂÖíÂÖåÂÖîÂÖ¢Á´∏ÂÖ©ÂÖ™ÂÖÆÂÜÄÂÜÇÂõòÂÜåÂÜâÂÜèÂÜëÂÜìÂÜïÂÜñÂÜ§ÂÜ¶ÂÜ¢ÂÜ©ÂÜ™ÂÜ´ÂÜ≥ÂÜ±ÂÜ≤ÂÜ∞ÂÜµÂÜΩÂáÖÂáâÂáõÂá†ËôïÂá©Âá≠"],["9980","Âá∞ÂáµÂáæÂàÑÂàãÂàîÂàéÂàßÂà™ÂàÆÂà≥ÂàπÂâèÂâÑÂâãÂâåÂâûÂâîÂâ™Ââ¥Ââ©Ââ≥ÂâøÂâΩÂäçÂäîÂäíÂâ±ÂäàÂäëËæ®ËæßÂä¨Âä≠ÂäºÂäµÂãÅÂãçÂãóÂãûÂã£Âã¶È£≠Âã†Âã≥ÂãµÂã∏ÂãπÂåÜÂåàÁî∏ÂåçÂåêÂåèÂåïÂåöÂå£ÂåØÂå±Âå≥Âå∏ÂçÄÂçÜÂçÖ‰∏óÂçâÂççÂáñÂçûÂç©ÂçÆÂ§òÂçªÂç∑ÂéÇÂéñÂé†Âé¶Âé•ÂéÆÂé∞Âé∂ÂèÉÁ∞íÈõôÂèüÊõºÁáÆÂèÆÂè®Âè≠Âè∫ÂêÅÂêΩÂëÄÂê¨Âê≠ÂêºÂêÆÂê∂Âê©ÂêùÂëéÂíèÂëµÂíéÂëüÂë±Âë∑Âë∞ÂííÂëªÂíÄÂë∂ÂíÑÂíêÂíÜÂìáÂí¢Âí∏Âí•Âí¨ÂìÑÂìàÂí®"],["9a40","Âí´ÂìÇÂí§ÂíæÂíºÂìòÂì•Âì¶ÂîèÂîîÂìΩÂìÆÂì≠Âì∫Âì¢ÂîπÂïÄÂï£ÂïåÂîÆÂïúÂïÖÂïñÂïóÂî∏Âî≥ÂïùÂñôÂñÄÂíØÂñäÂñüÂïªÂïæÂñòÂñûÂñÆÂïºÂñÉÂñ©ÂñáÂñ®ÂóöÂóÖÂóüÂóÑÂóúÂó§ÂóîÂòîÂó∑ÂòñÂóæÂóΩÂòõÂóπÂôéÂôêÁáüÂò¥Âò∂Âò≤Âò∏"],["9a80","Âô´Âô§ÂòØÂô¨Âô™ÂöÜÂöÄÂöäÂö†ÂöîÂöèÂö•ÂöÆÂö∂Âö¥ÂõÇÂöºÂõÅÂõÉÂõÄÂõàÂõéÂõëÂõìÂõóÂõÆÂõπÂúÄÂõøÂúÑÂúâÂúàÂúãÂúçÂúìÂúòÂúñÂóáÂúúÂú¶Âú∑Âú∏ÂùéÂúªÂùÄÂùèÂù©ÂüÄÂûàÂù°ÂùøÂûâÂûìÂû†Âû≥Âû§Âû™Âû∞ÂüÉÂüÜÂüîÂüíÂüìÂ†äÂüñÂü£Â†ãÂ†ôÂ†ùÂ°≤Â†°Â°¢Â°ãÂ°∞ÊØÄÂ°íÂ†ΩÂ°πÂ¢ÖÂ¢πÂ¢üÂ¢´Â¢∫Â£ûÂ¢ªÂ¢∏Â¢ÆÂ£ÖÂ£ìÂ£ëÂ£óÂ£ôÂ£òÂ£•Â£úÂ£§Â£üÂ£ØÂ£∫Â£πÂ£ªÂ£ºÂ£ΩÂ§ÇÂ§äÂ§êÂ§õÊ¢¶Â§•Â§¨Â§≠Â§≤Â§∏Â§æÁ´íÂ•ïÂ•êÂ•éÂ•öÂ•òÂ•¢Â•†Â•ßÂ•¨Â•©"],["9b40","Â•∏Â¶ÅÂ¶ù‰Ωû‰æ´Â¶£Â¶≤ÂßÜÂß®ÂßúÂ¶çÂßôÂßöÂ®•Â®üÂ®ëÂ®úÂ®âÂ®öÂ©ÄÂ©¨Â©âÂ®µÂ®∂Â©¢Â©™Â™öÂ™ºÂ™æÂ´ãÂ´ÇÂ™ΩÂ´£Â´óÂ´¶Â´©Â´ñÂ´∫Â´ªÂ¨åÂ¨ãÂ¨ñÂ¨≤Â´êÂ¨™Â¨∂Â¨æÂ≠ÉÂ≠ÖÂ≠ÄÂ≠ëÂ≠ïÂ≠öÂ≠õÂ≠•Â≠©Â≠∞Â≠≥Â≠µÂ≠∏ÊñàÂ≠∫ÂÆÄ"],["9b80","ÂÆÉÂÆ¶ÂÆ∏ÂØÉÂØáÂØâÂØîÂØêÂØ§ÂØ¶ÂØ¢ÂØûÂØ•ÂØ´ÂØ∞ÂØ∂ÂØ≥Â∞ÖÂ∞áÂ∞àÂ∞çÂ∞ìÂ∞†Â∞¢Â∞®Â∞∏Â∞πÂ±ÅÂ±ÜÂ±éÂ±ìÂ±êÂ±èÂ≠±Â±¨Â±Æ‰π¢Â±∂Â±πÂ≤åÂ≤ëÂ≤îÂ¶õÂ≤´Â≤ªÂ≤∂Â≤ºÂ≤∑Â≥ÖÂ≤æÂ≥áÂ≥ôÂ≥©Â≥ΩÂ≥∫Â≥≠Â∂åÂ≥™Â¥ãÂ¥ïÂ¥óÂµúÂ¥üÂ¥õÂ¥ëÂ¥îÂ¥¢Â¥öÂ¥ôÂ¥òÂµåÂµíÂµéÂµãÂµ¨Âµ≥Âµ∂Â∂áÂ∂ÑÂ∂ÇÂ∂¢Â∂ùÂ∂¨Â∂ÆÂ∂ΩÂ∂êÂ∂∑Â∂ºÂ∑âÂ∑çÂ∑ìÂ∑íÂ∑ñÂ∑õÂ∑´Â∑≤Â∑µÂ∏ãÂ∏öÂ∏ôÂ∏ëÂ∏õÂ∏∂Â∏∑ÂπÑÂπÉÂπÄÂπéÂπóÂπîÂπüÂπ¢Âπ§ÂπáÂπµÂπ∂Âπ∫È∫ºÂπøÂ∫†ÂªÅÂªÇÂªàÂªêÂªè"],["9c40","ÂªñÂª£ÂªùÂªöÂªõÂª¢Âª°Âª®Âª©Âª¨Âª±Âª≥Âª∞Âª¥Âª∏ÂªæÂºÉÂºâÂΩùÂΩúÂºãÂºëÂºñÂº©Âº≠Âº∏ÂΩÅÂΩàÂΩåÂΩéÂºØÂΩëÂΩñÂΩóÂΩôÂΩ°ÂΩ≠ÂΩ≥ÂΩ∑ÂæÉÂæÇÂΩøÂæäÂæàÂæëÂæáÂæûÂæôÂæòÂæ†Âæ®Âæ≠ÂæºÂøñÂøªÂø§Âø∏Âø±ÂøùÊÇ≥ÂøøÊÄ°ÊÅ†"],["9c80","ÊÄôÊÄêÊÄ©ÊÄéÊÄ±ÊÄõÊÄïÊÄ´ÊÄ¶ÊÄèÊÄ∫ÊÅöÊÅÅÊÅ™ÊÅ∑ÊÅüÊÅäÊÅÜÊÅçÊÅ£ÊÅÉÊÅ§ÊÅÇÊÅ¨ÊÅ´ÊÅôÊÇÅÊÇçÊÉßÊÇÉÊÇöÊÇÑÊÇõÊÇñÊÇóÊÇíÊÇßÊÇãÊÉ°ÊÇ∏ÊÉ†ÊÉìÊÇ¥Âø∞ÊÇΩÊÉÜÊÇµÊÉòÊÖçÊÑïÊÑÜÊÉ∂ÊÉ∑ÊÑÄÊÉ¥ÊÉ∫ÊÑÉÊÑ°ÊÉªÊÉ±ÊÑçÊÑéÊÖáÊÑæÊÑ®ÊÑßÊÖäÊÑøÊÑºÊÑ¨ÊÑ¥ÊÑΩÊÖÇÊÖÑÊÖ≥ÊÖ∑ÊÖòÊÖôÊÖöÊÖ´ÊÖ¥ÊÖØÊÖ•ÊÖ±ÊÖüÊÖùÊÖìÊÖµÊÜôÊÜñÊÜáÊÜ¨ÊÜîÊÜöÊÜäÊÜëÊÜ´ÊÜÆÊáåÊáäÊáâÊá∑ÊáàÊáÉÊáÜÊÜ∫ÊáãÁΩπÊáçÊá¶Êá£Êá∂Êá∫Êá¥ÊáøÊáΩÊáºÊáæÊàÄÊààÊàâÊàçÊàåÊàîÊàõ"],["9d40","ÊàûÊà°Êà™ÊàÆÊà∞Êà≤Êà≥ÊâÅÊâéÊâûÊâ£ÊâõÊâ†Êâ®ÊâºÊäÇÊäâÊâæÊäíÊäìÊäñÊãîÊäÉÊäîÊãóÊãëÊäªÊãèÊãøÊãÜÊìîÊãàÊãúÊãåÊãäÊãÇÊãáÊäõÊãâÊååÊãÆÊã±ÊåßÊåÇÊåàÊãØÊãµÊçêÊåæÊççÊêúÊçèÊéñÊééÊéÄÊé´Êç∂Êé£ÊéèÊéâÊéüÊéµÊç´"],["9d80","Êç©ÊéæÊè©ÊèÄÊèÜÊè£ÊèâÊèíÊè∂ÊèÑÊêñÊê¥ÊêÜÊêìÊê¶Êê∂ÊîùÊêóÊê®ÊêèÊëßÊëØÊë∂ÊëéÊî™ÊíïÊíìÊí•Êí©ÊíàÊíºÊìöÊìíÊìÖÊìáÊíªÊìòÊìÇÊì±ÊìßËàâÊì†Êì°Êä¨Êì£ÊìØÊî¨Êì∂Êì¥Êì≤Êì∫ÊîÄÊìΩÊîòÊîúÊîÖÊî§Êî£Êî´Êî¥ÊîµÊî∑Êî∂Êî∏ÁïãÊïàÊïñÊïïÊïçÊïòÊïûÊïùÊï≤Êï∏ÊñÇÊñÉËÆäÊñõÊñüÊñ´Êñ∑ÊóÉÊóÜÊóÅÊóÑÊóåÊóíÊóõÊóôÊó†Êó°Êó±Êù≤ÊòäÊòÉÊóªÊù≥ÊòµÊò∂Êò¥ÊòúÊôèÊôÑÊôâÊôÅÊôûÊôùÊô§ÊôßÊô®ÊôüÊô¢Êô∞ÊöÉÊöàÊöéÊöâÊöÑÊöòÊöùÊõÅÊöπÊõâÊöæÊöº"],["9e40","ÊõÑÊö∏ÊõñÊõöÊõ†ÊòøÊõ¶Êõ©Êõ∞ÊõµÊõ∑ÊúèÊúñÊúûÊú¶ÊúßÈú∏ÊúÆÊúøÊú∂ÊùÅÊú∏Êú∑ÊùÜÊùûÊù†ÊùôÊù£Êù§ÊûâÊù∞Êû©ÊùºÊù™ÊûåÊûãÊû¶Êû°ÊûÖÊû∑ÊüØÊû¥Êü¨Êû≥Êü©Êû∏Êü§ÊüûÊüùÊü¢ÊüÆÊûπÊüéÊüÜÊüßÊ™úÊ†ûÊ°ÜÊ†©Ê°ÄÊ°çÊ†≤Ê°é"],["9e80","Ê¢≥Ê†´Ê°ôÊ°£Ê°∑Ê°øÊ¢üÊ¢èÊ¢≠Ê¢îÊ¢ùÊ¢õÊ¢ÉÊ™ÆÊ¢πÊ°¥Ê¢µÊ¢†Ê¢∫Ê§èÊ¢çÊ°æÊ§ÅÊ£äÊ§àÊ£òÊ§¢Ê§¶Ê£°Ê§åÊ£çÊ£îÊ£ßÊ£ïÊ§∂Ê§íÊ§ÑÊ£óÊ££Ê§•Ê£πÊ£†Ê£ØÊ§®Ê§™Ê§öÊ§£Ê§°Ê£ÜÊ•πÊ•∑Ê•úÊ•∏Ê•´Ê•îÊ•æÊ•ÆÊ§πÊ•¥Ê§ΩÊ•ôÊ§∞Ê•°Ê•ûÊ•ùÊ¶ÅÊ•™Ê¶≤Ê¶ÆÊßêÊ¶øÊßÅÊßìÊ¶æÊßéÂØ®ÊßäÊßùÊ¶ªÊßÉÊ¶ßÊ®ÆÊ¶ëÊ¶†Ê¶úÊ¶ïÊ¶¥ÊßûÊß®Ê®ÇÊ®õÊßøÊ¨äÊßπÊß≤ÊßßÊ®ÖÊ¶±Ê®ûÊß≠Ê®îÊß´Ê®äÊ®íÊ´ÅÊ®£Ê®ìÊ©ÑÊ®åÊ©≤Ê®∂Ê©∏Ê©áÊ©¢Ê©ôÊ©¶Ê©àÊ®∏Ê®¢Ê™êÊ™çÊ™†Ê™ÑÊ™¢Ê™£"],["9f40","Ê™óËòóÊ™ªÊ´ÉÊ´ÇÊ™∏Ê™≥Ê™¨Ê´ûÊ´ëÊ´üÊ™™Ê´öÊ´™Ê´ªÊ¨ÖËòñÊ´∫Ê¨íÊ¨ñÈ¨±Ê¨üÊ¨∏Ê¨∑ÁõúÊ¨πÈ£ÆÊ≠áÊ≠ÉÊ≠âÊ≠êÊ≠ôÊ≠îÊ≠õÊ≠üÊ≠°Ê≠∏Ê≠πÊ≠øÊÆÄÊÆÑÊÆÉÊÆçÊÆòÊÆïÊÆûÊÆ§ÊÆ™ÊÆ´ÊÆØÊÆ≤ÊÆ±ÊÆ≥ÊÆ∑ÊÆºÊØÜÊØãÊØìÊØüÊØ¨ÊØ´ÊØ≥ÊØØ"],["9f80","È∫æÊ∞àÊ∞ìÊ∞îÊ∞õÊ∞§Ê∞£Ê±ûÊ±ïÊ±¢Ê±™Ê≤ÇÊ≤çÊ≤öÊ≤ÅÊ≤õÊ±æÊ±®Ê±≥Ê≤íÊ≤êÊ≥ÑÊ≥±Ê≥ìÊ≤ΩÊ≥óÊ≥ÖÊ≥ùÊ≤ÆÊ≤±Ê≤æÊ≤∫Ê≥õÊ≥ØÊ≥ôÊ≥™Ê¥üË°çÊ¥∂Ê¥´Ê¥ΩÊ¥∏Ê¥ôÊ¥µÊ¥≥Ê¥íÊ¥åÊµ£Ê∂ìÊµ§ÊµöÊµπÊµôÊ∂éÊ∂ïÊø§Ê∂ÖÊ∑πÊ∏ïÊ∏äÊ∂µÊ∑áÊ∑¶Ê∂∏Ê∑ÜÊ∑¨Ê∑ûÊ∑åÊ∑®Ê∑íÊ∑ÖÊ∑∫Ê∑ôÊ∑§Ê∑ïÊ∑™Ê∑ÆÊ∏≠ÊπÆÊ∏ÆÊ∏ôÊπ≤ÊπüÊ∏æÊ∏£Êπ´Ê∏´Êπ∂ÊπçÊ∏üÊπÉÊ∏∫ÊπéÊ∏§ÊªøÊ∏ùÊ∏∏Ê∫ÇÊ∫™Ê∫òÊªâÊ∫∑ÊªìÊ∫ΩÊ∫ØÊªÑÊ∫≤ÊªîÊªïÊ∫èÊ∫•ÊªÇÊ∫üÊΩÅÊºëÁÅåÊª¨Êª∏ÊªæÊºøÊª≤Êº±ÊªØÊº≤Êªå"],["e040","ÊºæÊºìÊª∑ÊæÜÊΩ∫ÊΩ∏ÊæÅÊæÄÊΩØÊΩõÊø≥ÊΩ≠ÊæÇÊΩºÊΩòÊæéÊæëÊøÇÊΩ¶Êæ≥Êæ£Êæ°Êæ§ÊæπÊøÜÊæ™ÊøüÊøïÊø¨ÊøîÊøòÊø±ÊøÆÊøõÁÄâÁÄãÊø∫ÁÄëÁÄÅÁÄèÊøæÁÄõÁÄöÊΩ¥ÁÄùÁÄòÁÄüÁÄ∞ÁÄæÁÄ≤ÁÅëÁÅ£ÁÇôÁÇíÁÇØÁÉ±ÁÇ¨ÁÇ∏ÁÇ≥ÁÇÆÁÉüÁÉãÁÉù"],["e080","ÁÉôÁÑâÁÉΩÁÑúÁÑôÁÖ•ÁÖïÁÜàÁÖ¶ÁÖ¢ÁÖåÁÖñÁÖ¨ÁÜèÁáªÁÜÑÁÜïÁÜ®ÁÜ¨ÁáóÁÜπÁÜæÁáíÁáâÁáîÁáéÁá†Áá¨ÁáßÁáµÁáºÁáπÁáøÁàçÁàêÁàõÁà®Áà≠Áà¨Áà∞Áà≤ÁàªÁàºÁàøÁâÄÁâÜÁâãÁâòÁâ¥ÁâæÁäÇÁäÅÁäáÁäíÁäñÁä¢ÁäßÁäπÁä≤ÁãÉÁãÜÁãÑÁãéÁãíÁã¢Áã†Áã°ÁãπÁã∑ÂÄèÁåóÁåäÁåúÁåñÁåùÁå¥ÁåØÁå©Áå•ÁåæÁçéÁçèÈªòÁçóÁç™Áç®Áç∞Áç∏ÁçµÁçªÁç∫ÁèàÁé≥ÁèéÁéªÁèÄÁè•ÁèÆÁèûÁí¢ÁêÖÁëØÁê•Áè∏Áê≤Áê∫ÁëïÁêøÁëüÁëôÁëÅÁëúÁë©Áë∞Áë£Áë™Áë∂ÁëæÁíãÁíûÁíßÁìäÁìèÁìîÁè±"],["e140","Áì†Áì£ÁìßÁì©ÁìÆÁì≤Áì∞Áì±Áì∏Áì∑ÁîÑÁîÉÁîÖÁîåÁîéÁîçÁîïÁîìÁîûÁî¶Áî¨ÁîºÁïÑÁïçÁïäÁïâÁïõÁïÜÁïöÁï©Áï§ÁïßÁï´Áï≠Áï∏Áï∂ÁñÜÁñáÁï¥ÁñäÁñâÁñÇÁñîÁñöÁñùÁñ•Áñ£ÁóÇÁñ≥ÁóÉÁñµÁñΩÁñ∏ÁñºÁñ±ÁóçÁóäÁóíÁóôÁó£ÁóûÁóæÁóø"],["e180","ÁóºÁòÅÁó∞Áó∫Áó≤Áó≥ÁòãÁòçÁòâÁòüÁòßÁò†Áò°Áò¢Áò§Áò¥Áò∞ÁòªÁôáÁôàÁôÜÁôúÁôòÁô°Áô¢Áô®Áô©Áô™ÁôßÁô¨Áô∞Áô≤Áô∂Áô∏ÁôºÁöÄÁöÉÁöàÁöãÁöéÁöñÁöìÁöôÁööÁö∞Áö¥Áö∏ÁöπÁö∫ÁõÇÁõçÁõñÁõíÁõûÁõ°Áõ•ÁõßÁõ™ËòØÁõªÁúàÁúáÁúÑÁú©Áú§ÁúûÁú•Áú¶ÁúõÁú∑Áú∏ÁùáÁùöÁù®Áù´ÁùõÁù•ÁùøÁùæÁùπÁûéÁûãÁûëÁû†ÁûûÁû∞Áû∂ÁûπÁûøÁûºÁûΩÁûªÁüáÁüçÁüóÁüöÁüúÁü£ÁüÆÁüºÁ†åÁ†íÁ§¶Á††Á§™Á°ÖÁ¢éÁ°¥Á¢ÜÁ°ºÁ¢öÁ¢åÁ¢£Á¢µÁ¢™Á¢ØÁ£ëÁ£ÜÁ£ãÁ£îÁ¢æÁ¢ºÁ£ÖÁ£äÁ£¨"],["e240","Á£ßÁ£öÁ£ΩÁ£¥Á§áÁ§íÁ§ëÁ§ôÁ§¨Á§´Á•ÄÁ•†Á•óÁ•üÁ•öÁ•ïÁ•ìÁ•∫Á•øÁ¶äÁ¶ùÁ¶ßÈΩãÁ¶™Á¶ÆÁ¶≥Á¶πÁ¶∫ÁßâÁßïÁßßÁß¨Áß°Áß£Á®àÁ®çÁ®òÁ®ôÁ®†Á®üÁ¶ÄÁ®±Á®ªÁ®æÁ®∑Á©ÉÁ©óÁ©âÁ©°Á©¢Á©©ÈæùÁ©∞Á©πÁ©ΩÁ™àÁ™óÁ™ïÁ™òÁ™ñÁ™©Á´àÁ™∞"],["e280","Á™∂Á´ÖÁ´ÑÁ™øÈÇÉÁ´áÁ´äÁ´çÁ´èÁ´ïÁ´ìÁ´ôÁ´öÁ´ùÁ´°Á´¢Á´¶Á´≠Á´∞Á¨ÇÁ¨èÁ¨äÁ¨ÜÁ¨≥Á¨òÁ¨ôÁ¨ûÁ¨µÁ¨®Á¨∂Á≠êÁ≠∫Á¨ÑÁ≠çÁ¨ãÁ≠åÁ≠ÖÁ≠µÁ≠•Á≠¥Á≠ßÁ≠∞Á≠±Á≠¨Á≠ÆÁÆùÁÆòÁÆüÁÆçÁÆúÁÆöÁÆãÁÆíÁÆèÁ≠ùÁÆôÁØãÁØÅÁØåÁØèÁÆ¥ÁØÜÁØùÁØ©Á∞ëÁ∞îÁØ¶ÁØ•Á±†Á∞ÄÁ∞áÁ∞ìÁØ≥ÁØ∑Á∞óÁ∞çÁØ∂Á∞£Á∞ßÁ∞™Á∞üÁ∞∑Á∞´Á∞ΩÁ±åÁ±ÉÁ±îÁ±èÁ±ÄÁ±êÁ±òÁ±üÁ±§Á±ñÁ±•Á±¨Á±µÁ≤ÉÁ≤êÁ≤§Á≤≠Á≤¢Á≤´Á≤°Á≤®Á≤≥Á≤≤Á≤±Á≤ÆÁ≤πÁ≤ΩÁ≥ÄÁ≥ÖÁ≥ÇÁ≥òÁ≥íÁ≥úÁ≥¢È¨ªÁ≥ØÁ≥≤Á≥¥Á≥∂Á≥∫Á¥Ü"],["e340","Á¥ÇÁ¥úÁ¥ïÁ¥äÁµÖÁµãÁ¥ÆÁ¥≤Á¥øÁ¥µÁµÜÁµ≥ÁµñÁµéÁµ≤Áµ®ÁµÆÁµèÁµ£Á∂ìÁ∂âÁµõÁ∂èÁµΩÁ∂õÁ∂∫Á∂ÆÁ∂£Á∂µÁ∑áÁ∂ΩÁ∂´Á∏ΩÁ∂¢Á∂ØÁ∑úÁ∂∏Á∂üÁ∂∞Á∑òÁ∑ùÁ∑§Á∑ûÁ∑ªÁ∑≤Á∑°Á∏ÖÁ∏äÁ∏£Á∏°Á∏íÁ∏±Á∏üÁ∏âÁ∏ãÁ∏¢ÁπÜÁπ¶Á∏ªÁ∏µÁ∏πÁπÉÁ∏∑"],["e380","Á∏≤Á∏∫ÁπßÁπùÁπñÁπûÁπôÁπöÁππÁπ™Áπ©ÁπºÁπªÁ∫ÉÁ∑ïÁπΩËæÆÁπøÁ∫àÁ∫âÁ∫åÁ∫íÁ∫êÁ∫ìÁ∫îÁ∫ñÁ∫éÁ∫õÁ∫úÁº∏Áº∫ÁΩÖÁΩåÁΩçÁΩéÁΩêÁΩëÁΩïÁΩîÁΩòÁΩüÁΩ†ÁΩ®ÁΩ©ÁΩßÁΩ∏ÁæÇÁæÜÁæÉÁæàÁæáÁæåÁæîÁæûÁæùÁæöÁæ£ÁæØÁæ≤ÁæπÁæÆÁæ∂Áæ∏Ë≠±ÁøÖÁøÜÁøäÁøïÁøîÁø°Áø¶Áø©Áø≥ÁøπÈ£úËÄÜËÄÑËÄãËÄíËÄòËÄôËÄúËÄ°ËÄ®ËÄøËÄªËÅäËÅÜËÅíËÅòËÅöËÅüËÅ¢ËÅ®ËÅ≥ËÅ≤ËÅ∞ËÅ∂ËÅπËÅΩËÅøËÇÑËÇÜËÇÖËÇõËÇìËÇöËÇ≠ÂÜêËÇ¨ËÉõËÉ•ËÉôËÉùËÉÑËÉöËÉñËÑâËÉØËÉ±ËÑõËÑ©ËÑ£ËÑØËÖã"],["e440","ÈöãËÖÜËÑæËÖìËÖëËÉºËÖ±ËÖÆËÖ•ËÖ¶ËÖ¥ËÜÉËÜàËÜäËÜÄËÜÇËÜ†ËÜïËÜ§ËÜ£ËÖüËÜìËÜ©ËÜ∞ËÜµËÜæËÜ∏ËÜΩËáÄËáÇËÜ∫ËáâËáçËáëËáôËáòËáàËáöËáüËá†ËáßËá∫ËáªËáæËàÅËàÇËàÖËàáËàäËàçËàêËàñËà©Ëà´Ëà∏Ëà≥ËâÄËâôËâòËâùËâöËâüËâ§"],["e480","Ëâ¢Ëâ®Ëâ™Ëâ´ËàÆËâ±Ëâ∑Ëâ∏ËâæËäçËäíËä´ËäüËäªËä¨Ëã°Ëã£ËãüËãíËã¥Ëã≥Ëã∫ËéìËåÉËãªËãπËãûËåÜËãúËåâËãôËåµËå¥ËåñËå≤Ëå±ËçÄËåπËçêËçÖËåØËå´ËåóËåòËéÖËéöËé™ËéüËé¢ËéñËå£ËééËéáËéäËçºËéµËç≥ËçµËé†ËéâËé®Ëè¥ËêìËè´ËèéËèΩËêÉËèòËêãËèÅËè∑ËêáËè†Ëè≤ËêçËê¢Ëê†ËéΩËê∏ËîÜËèªËë≠Ëê™ËêºËïöËíÑËë∑Ëë´Ëí≠ËëÆËíÇËë©ËëÜËê¨ËëØËëπËêµËìäËë¢ËíπËíøËíüËìôËìçËíªËìöËìêËìÅËìÜËìñËí°Ëî°ËìøËì¥ËîóËîòËî¨ËîüËîïËîîËìºËïÄËï£ËïòËïà"],["e540","ËïÅËòÇËïãËïïËñÄËñ§ËñàËñëËñäËñ®Ëï≠ËñîËñõËó™ËñáËñúËï∑ËïæËñêËóâËñ∫ËóèËñπËóêËóïËóùËó•ËóúËóπËòäËòìËòãËóæËó∫ËòÜËò¢ËòöËò∞ËòøËôç‰πïËôîËôüËôßËô±ËöìËö£Ëö©Ëö™ËöãËöåËö∂ËöØËõÑËõÜËö∞ËõâË†£Ëö´ËõîËõûËõ©Ëõ¨"],["e580","ËõüËõõËõØËúíËúÜËúàËúÄËúÉËõªËúëËúâËúçËõπËúäËú¥ËúøËú∑ËúªËú•Ëú©ËúöËù†ËùüËù∏ËùåËùéËù¥ËùóËù®ËùÆËùôËùìËù£Ëù™Ë†ÖËû¢ËûüËûÇËûØËüãËûΩËüÄËüêÈõñËû´ËüÑËû≥ËüáËüÜËûªËüØËü≤Ëü†Ë†èË†çËüæËü∂Ëü∑Ë†éËüíË†ëË†ñË†ïË†¢Ë†°Ë†±Ë†∂Ë†πË†ßË†ªË°ÑË°ÇË°íË°ôË°ûË°¢Ë°´Ë¢ÅË°æË¢ûË°µË°ΩË¢µË°≤Ë¢ÇË¢óË¢íË¢ÆË¢ôË¢¢Ë¢çË¢§Ë¢∞Ë¢øË¢±Ë£ÉË£ÑË£îË£òË£ôË£ùË£πË§ÇË£ºË£¥Ë£®Ë£≤Ë§ÑË§åË§äË§ìË•ÉË§ûË§•Ë§™Ë§´Ë•ÅË•ÑË§ªË§∂Ë§∏Ë•åË§ùË•†Ë•û"],["e640","Ë•¶Ë•§Ë•≠Ë•™Ë•ØË•¥Ë•∑Ë•æË¶ÉË¶àË¶äË¶ìË¶òË¶°Ë¶©Ë¶¶Ë¶¨Ë¶ØË¶≤Ë¶∫Ë¶ΩË¶øËßÄËßöËßúËßùËßßËß¥Ëß∏Ë®ÉË®ñË®êË®åË®õË®ùË®•Ë®∂Ë©ÅË©õË©íË©ÜË©àË©ºË©≠Ë©¨Ë©¢Ë™ÖË™ÇË™ÑË™®Ë™°Ë™ëË™•Ë™¶Ë™öË™£Ë´ÑË´çË´ÇË´öË´´Ë´≥Ë´ß"],["e680","Ë´§Ë´±Ë¨îË´†Ë´¢Ë´∑Ë´ûË´õË¨åË¨áË¨öË´°Ë¨ñË¨êË¨óË¨†Ë¨≥Èû´Ë¨¶Ë¨´Ë¨æË¨®Ë≠ÅË≠åË≠èË≠éË≠âË≠ñË≠õË≠öË≠´Ë≠üË≠¨Ë≠ØË≠¥Ë≠ΩËÆÄËÆåËÆéËÆíËÆìËÆñËÆôËÆöË∞∫Ë±ÅË∞øË±àË±åË±éË±êË±ïË±¢Ë±¨Ë±∏Ë±∫Ë≤ÇË≤âË≤ÖË≤äË≤çË≤éË≤îË±ºË≤òÊàùË≤≠Ë≤™Ë≤ΩË≤≤Ë≤≥Ë≤ÆË≤∂Ë≥àË≥ÅË≥§Ë≥£Ë≥öË≥ΩË≥∫Ë≥ªË¥ÑË¥ÖË¥äË¥áË¥èË¥çË¥êÈΩéË¥ìË≥çË¥îË¥ñËµßËµ≠Ëµ±Ëµ≥Ë∂ÅË∂ôË∑ÇË∂æË∂∫Ë∑èË∑öË∑ñË∑åË∑õË∑ãË∑™Ë∑´Ë∑üË∑£Ë∑ºË∏àË∏âË∑øË∏ùË∏ûË∏êË∏üËπÇË∏µË∏∞Ë∏¥Ëπä"],["e740","ËπáËπâËπåËπêËπàËπôËπ§Ëπ†Ë∏™Ëπ£ËπïËπ∂Ëπ≤ËπºË∫ÅË∫áË∫ÖË∫ÑË∫ãË∫äË∫ìË∫ëË∫îË∫ôË∫™Ë∫°Ë∫¨Ë∫∞ËªÜË∫±Ë∫æËªÖËªàËªãËªõËª£ËªºËªªËª´ËªæËºäËºÖËºïËºíËºôËºìËºúËºüËºõËºåËº¶Ëº≥ËºªËºπËΩÖËΩÇËºæËΩåËΩâËΩÜËΩéËΩóËΩú"],["e780","ËΩ¢ËΩ£ËΩ§ËæúËæüËæ£Ëæ≠ËæØËæ∑ËøöËø•Ëø¢Ëø™ËøØÈÇáËø¥ÈÄÖËøπËø∫ÈÄëÈÄïÈÄ°ÈÄçÈÄûÈÄñÈÄãÈÄßÈÄ∂ÈÄµÈÄπËø∏ÈÅèÈÅêÈÅëÈÅíÈÄéÈÅâÈÄæÈÅñÈÅòÈÅûÈÅ®ÈÅØÈÅ∂Èö®ÈÅ≤ÈÇÇÈÅΩÈÇÅÈÇÄÈÇäÈÇâÈÇèÈÇ®ÈÇØÈÇ±ÈÇµÈÉ¢ÈÉ§ÊâàÈÉõÈÑÇÈÑíÈÑôÈÑ≤ÈÑ∞ÈÖäÈÖñÈÖòÈÖ£ÈÖ•ÈÖ©ÈÖ≥ÈÖ≤ÈÜãÈÜâÈÜÇÈÜ¢ÈÜ´ÈÜØÈÜ™ÈÜµÈÜ¥ÈÜ∫ÈáÄÈáÅÈáâÈáãÈáêÈáñÈáüÈá°ÈáõÈáºÈáµÈá∂ÈàûÈáøÈàîÈà¨ÈàïÈàëÈâûÈâóÈâÖÈââÈâ§ÈâàÈäïÈàøÈâãÈâêÈäúÈäñÈäìÈäõÈâöÈãèÈäπÈä∑Èã©ÈåèÈã∫ÈçÑÈåÆ"],["e840","ÈåôÈå¢ÈåöÈå£Èå∫ÈåµÈåªÈçúÈç†ÈçºÈçÆÈçñÈé∞Èé¨Èé≠ÈéîÈéπÈèñÈèóÈè®Èè•ÈèòÈèÉÈèùÈèêÈèàÈè§ÈêöÈêîÈêìÈêÉÈêáÈêêÈê∂Èê´ÈêµÈê°Èê∫ÈëÅÈëíÈëÑÈëõÈë†Èë¢ÈëûÈë™Èà©Èë∞ÈëµÈë∑ÈëΩÈëöÈëºÈëæÈíÅÈëøÈñÇÈñáÈñäÈñîÈññÈñòÈñô"],["e880","Èñ†Èñ®ÈñßÈñ≠ÈñºÈñªÈñπÈñæÈóäÊø∂ÈóÉÈóçÈóåÈóïÈóîÈóñÈóúÈó°Èó•Èó¢Èò°Èò®ÈòÆÈòØÈôÇÈôåÈôèÈôãÈô∑ÈôúÈôûÈôùÈôüÈô¶Èô≤Èô¨ÈöçÈöòÈöïÈöóÈö™ÈößÈö±Èö≤Èö∞Èö¥Èö∂Èö∏ÈöπÈõéÈõãÈõâÈõçË•çÈõúÈúçÈõïÈõπÈúÑÈúÜÈúàÈúìÈúéÈúëÈúèÈúñÈúôÈú§Èú™Èú∞ÈúπÈúΩÈúæÈùÑÈùÜÈùàÈùÇÈùâÈùúÈù†Èù§Èù¶Èù®ÂãíÈù´Èù±ÈùπÈûÖÈùºÈûÅÈù∫ÈûÜÈûãÈûèÈûêÈûúÈû®Èû¶Èû£Èû≥Èû¥ÈüÉÈüÜÈüàÈüãÈüúÈü≠ÈΩèÈü≤Á´üÈü∂ÈüµÈ†èÈ†åÈ†∏È†§È†°È†∑È†ΩÈ°ÜÈ°èÈ°ãÈ°´È°ØÈ°∞"],["e940","È°±È°¥È°≥È¢™È¢ØÈ¢±È¢∂È£ÑÈ£ÉÈ£ÜÈ£©È£´È§ÉÈ§âÈ§íÈ§îÈ§òÈ§°È§ùÈ§ûÈ§§È§†È§¨È§ÆÈ§ΩÈ§æÈ•ÇÈ•âÈ•ÖÈ•êÈ•ãÈ•ëÈ•íÈ•åÈ•ïÈ¶óÈ¶òÈ¶•È¶≠È¶ÆÈ¶ºÈßüÈßõÈßùÈßòÈßëÈß≠ÈßÆÈß±Èß≤ÈßªÈß∏È®ÅÈ®èÈ®ÖÈß¢È®ôÈ®´È®∑È©ÖÈ©ÇÈ©ÄÈ©É"],["e980","È®æÈ©ïÈ©çÈ©õÈ©óÈ©üÈ©¢È©•È©§È©©È©´È©™È™≠È™∞È™ºÈ´ÄÈ´èÈ´ëÈ´ìÈ´îÈ´ûÈ´üÈ´¢È´£È´¶È´ØÈ´´È´ÆÈ´¥È´±È´∑È´ªÈ¨ÜÈ¨òÈ¨öÈ¨üÈ¨¢È¨£È¨•È¨ßÈ¨®È¨©È¨™È¨ÆÈ¨ØÈ¨≤È≠ÑÈ≠ÉÈ≠èÈ≠çÈ≠éÈ≠ëÈ≠òÈ≠¥ÈÆìÈÆÉÈÆëÈÆñÈÆóÈÆüÈÆ†ÈÆ®ÈÆ¥ÈØÄÈØäÈÆπÈØÜÈØèÈØëÈØíÈØ£ÈØ¢ÈØ§ÈØîÈØ°È∞∫ÈØ≤ÈØ±ÈØ∞È∞ïÈ∞îÈ∞âÈ∞ìÈ∞åÈ∞ÜÈ∞àÈ∞íÈ∞äÈ∞ÑÈ∞ÆÈ∞õÈ∞•È∞§È∞°È∞∞È±áÈ∞≤È±ÜÈ∞æÈ±öÈ±†È±ßÈ±∂È±∏È≥ßÈ≥¨È≥∞È¥âÈ¥àÈ≥´È¥ÉÈ¥ÜÈ¥™È¥¶È∂ØÈ¥£È¥üÈµÑÈ¥ïÈ¥íÈµÅÈ¥øÈ¥æÈµÜÈµà"],["ea40","ÈµùÈµûÈµ§ÈµëÈµêÈµôÈµ≤È∂âÈ∂áÈ∂´ÈµØÈµ∫È∂öÈ∂§È∂©È∂≤È∑ÑÈ∑ÅÈ∂ªÈ∂∏È∂∫È∑ÜÈ∑èÈ∑ÇÈ∑ôÈ∑ìÈ∑∏È∑¶È∑≠È∑ØÈ∑ΩÈ∏öÈ∏õÈ∏ûÈπµÈππÈπΩÈ∫ÅÈ∫àÈ∫ãÈ∫åÈ∫íÈ∫ïÈ∫ëÈ∫ùÈ∫•È∫©È∫∏È∫™È∫≠Èù°ÈªåÈªéÈªèÈªêÈªîÈªúÈªûÈªùÈª†Èª•Èª®ÈªØ"],["ea80","Èª¥Èª∂Èª∑ÈªπÈªªÈªºÈªΩÈºáÈºàÁö∑ÈºïÈº°Èº¨ÈºæÈΩäÈΩíÈΩîÈΩ£ÈΩüÈΩ†ÈΩ°ÈΩ¶ÈΩßÈΩ¨ÈΩ™ÈΩ∑ÈΩ≤ÈΩ∂ÈæïÈæúÈæ†Â†ØÊßáÈÅôÁë§ÂáúÁÜô"],["ed40","Á∫äË§úÈçàÈäàËìú‰øâÁÇªÊò±Ê£àÈãπÊõªÂΩÖ‰∏®‰ª°‰ªº‰ºÄ‰ºÉ‰ºπ‰Ωñ‰æí‰æä‰æö‰æî‰øçÂÅÄÂÄ¢‰øøÂÄûÂÅÜÂÅ∞ÂÅÇÂÇîÂÉ¥ÂÉòÂÖäÂÖ§ÂÜùÂÜæÂá¨ÂàïÂäúÂä¶ÂãÄÂãõÂåÄÂåáÂå§Âç≤ÂéìÂé≤ÂèùÔ®éÂíúÂíäÂí©ÂìøÂñÜÂùôÂù•Âû¨ÂüàÂüáÔ®è"],["ed80","Ô®êÂ¢ûÂ¢≤Â§ãÂ•ìÂ•õÂ•ùÂ•£Â¶§Â¶∫Â≠ñÂØÄÁîØÂØòÂØ¨Â∞ûÂ≤¶Â≤∫Â≥µÂ¥ßÂµìÔ®ëÂµÇÂµ≠Â∂∏Â∂πÂ∑êÂº°Âº¥ÂΩßÂæ∑ÂøûÊÅùÊÇÖÊÇäÊÉûÊÉïÊÑ†ÊÉ≤ÊÑëÊÑ∑ÊÑ∞ÊÜòÊàìÊä¶ÊèµÊë†ÊíùÊìéÊïéÊòÄÊòïÊòªÊòâÊòÆÊòûÊò§Êô•ÊôóÊôôÔ®íÊô≥ÊöôÊö†Êö≤ÊöøÊõ∫ÊúéÔ§©Êù¶ÊûªÊ°íÊüÄÊ†ÅÊ°ÑÊ£èÔ®ìÊ•®Ô®îÊ¶òÊß¢Ê®∞Ê©´Ê©ÜÊ©≥Ê©æÊ´¢Ê´§ÊØñÊ∞øÊ±úÊ≤ÜÊ±ØÊ≥öÊ¥ÑÊ∂áÊµØÊ∂ñÊ∂¨Ê∑èÊ∑∏Ê∑≤Ê∑ºÊ∏πÊπúÊ∏ßÊ∏ºÊ∫øÊæàÊæµÊøµÁÄÖÁÄáÁÄ®ÁÇÖÁÇ´ÁÑèÁÑÑÁÖúÁÖÜÁÖáÔ®ïÁáÅÁáæÁä±"],["ee40","ÁäæÁå§Ô®ñÁç∑ÁéΩÁèâÁèñÁè£ÁèíÁêáÁèµÁê¶Áê™Áê©ÁêÆÁë¢ÁíâÁíüÁîÅÁïØÁöÇÁöúÁöûÁöõÁö¶Ô®óÁùÜÂäØÁ†°Á°éÁ°§Á°∫Á§∞Ô®òÔ®ôÔ®öÁ¶îÔ®õÁ¶õÁ´ëÁ´ßÔ®úÁ´´ÁÆûÔ®ùÁµàÁµúÁ∂∑Á∂†Á∑ñÁπíÁΩáÁæ°Ô®ûËåÅËç¢ËçøËèáËè∂ËëàËí¥ËïìËïô"],["ee80","Ëï´Ô®üËñ∞Ô®†Ô®°Ë†áË£µË®íË®∑Ë©πË™ßË™æË´üÔ®¢Ë´∂Ë≠ìË≠øË≥∞Ë≥¥Ë¥íËµ∂Ô®£ËªèÔ®§Ô®•ÈÅßÈÉûÔ®¶ÈÑïÈÑßÈáöÈáóÈáûÈá≠ÈáÆÈá§Èá•ÈàÜÈàêÈàäÈà∫ÈâÄÈàºÈâéÈâôÈâëÈàπÈâßÈäßÈâ∑Èâ∏ÈãßÈãóÈãôÈãêÔ®ßÈãïÈã†ÈãìÈå•Èå°ÈãªÔ®®ÈåûÈãøÈåùÈåÇÈç∞ÈçóÈé§ÈèÜÈèûÈè∏Èê±ÈëÖÈëàÈñíÔßúÔ®©ÈöùÈöØÈú≥ÈúªÈùÉÈùçÈùèÈùëÈùïÈ°óÈ°•Ô®™Ô®´È§ßÔ®¨È¶ûÈ©éÈ´ôÈ´úÈ≠µÈ≠≤ÈÆèÈÆ±ÈÆªÈ∞ÄÈµ∞Èµ´Ô®≠È∏ôÈªë"],["eeef","‚Ö∞",9,"Ôø¢Ôø§ÔºáÔºÇ"],["f040","ÓÄÄ",62],["f080","ÓÄø",124],["f140","ÓÇº",62],["f180","ÓÉª",124],["f240","ÓÖ∏",62],["f280","ÓÜ∑",124],["f340","Óà¥",62],["f380","Óâ≥",124],["f440","Óã∞",62],["f480","ÓåØ",124],["f540","Óé¨",62],["f580","Óè´",124],["f640","Óë®",62],["f680","Óíß",124],["f740","Óî§",62],["f780","Óï£",124],["f840","Óó†",62],["f880","Óòü",124],["f940","Óöú"],["fa40","‚Ö∞",9,"‚Ö†",9,"Ôø¢Ôø§ÔºáÔºÇ„à±‚Ññ‚Ñ°‚àµÁ∫äË§úÈçàÈäàËìú‰øâÁÇªÊò±Ê£àÈãπÊõªÂΩÖ‰∏®‰ª°‰ªº‰ºÄ‰ºÉ‰ºπ‰Ωñ‰æí‰æä‰æö‰æî‰øçÂÅÄÂÄ¢‰øøÂÄûÂÅÜÂÅ∞ÂÅÇÂÇîÂÉ¥ÂÉòÂÖä"],["fa80","ÂÖ§ÂÜùÂÜæÂá¨ÂàïÂäúÂä¶ÂãÄÂãõÂåÄÂåáÂå§Âç≤ÂéìÂé≤ÂèùÔ®éÂíúÂíäÂí©ÂìøÂñÜÂùôÂù•Âû¨ÂüàÂüáÔ®èÔ®êÂ¢ûÂ¢≤Â§ãÂ•ìÂ•õÂ•ùÂ•£Â¶§Â¶∫Â≠ñÂØÄÁîØÂØòÂØ¨Â∞ûÂ≤¶Â≤∫Â≥µÂ¥ßÂµìÔ®ëÂµÇÂµ≠Â∂∏Â∂πÂ∑êÂº°Âº¥ÂΩßÂæ∑ÂøûÊÅùÊÇÖÊÇäÊÉûÊÉïÊÑ†ÊÉ≤ÊÑëÊÑ∑ÊÑ∞ÊÜòÊàìÊä¶ÊèµÊë†ÊíùÊìéÊïéÊòÄÊòïÊòªÊòâÊòÆÊòûÊò§Êô•ÊôóÊôôÔ®íÊô≥ÊöôÊö†Êö≤ÊöøÊõ∫ÊúéÔ§©Êù¶ÊûªÊ°íÊüÄÊ†ÅÊ°ÑÊ£èÔ®ìÊ•®Ô®îÊ¶òÊß¢Ê®∞Ê©´Ê©ÜÊ©≥Ê©æÊ´¢Ê´§ÊØñÊ∞øÊ±úÊ≤ÜÊ±ØÊ≥öÊ¥ÑÊ∂áÊµØ"],["fb40","Ê∂ñÊ∂¨Ê∑èÊ∑∏Ê∑≤Ê∑ºÊ∏πÊπúÊ∏ßÊ∏ºÊ∫øÊæàÊæµÊøµÁÄÖÁÄáÁÄ®ÁÇÖÁÇ´ÁÑèÁÑÑÁÖúÁÖÜÁÖáÔ®ïÁáÅÁáæÁä±ÁäæÁå§Ô®ñÁç∑ÁéΩÁèâÁèñÁè£ÁèíÁêáÁèµÁê¶Áê™Áê©ÁêÆÁë¢ÁíâÁíüÁîÅÁïØÁöÇÁöúÁöûÁöõÁö¶Ô®óÁùÜÂäØÁ†°Á°éÁ°§Á°∫Á§∞Ô®òÔ®ô"],["fb80","Ô®öÁ¶îÔ®õÁ¶õÁ´ëÁ´ßÔ®úÁ´´ÁÆûÔ®ùÁµàÁµúÁ∂∑Á∂†Á∑ñÁπíÁΩáÁæ°Ô®ûËåÅËç¢ËçøËèáËè∂ËëàËí¥ËïìËïôËï´Ô®üËñ∞Ô®†Ô®°Ë†áË£µË®íË®∑Ë©πË™ßË™æË´üÔ®¢Ë´∂Ë≠ìË≠øË≥∞Ë≥¥Ë¥íËµ∂Ô®£ËªèÔ®§Ô®•ÈÅßÈÉûÔ®¶ÈÑïÈÑßÈáöÈáóÈáûÈá≠ÈáÆÈá§Èá•ÈàÜÈàêÈàäÈà∫ÈâÄÈàºÈâéÈâôÈâëÈàπÈâßÈäßÈâ∑Èâ∏ÈãßÈãóÈãôÈãêÔ®ßÈãïÈã†ÈãìÈå•Èå°ÈãªÔ®®ÈåûÈãøÈåùÈåÇÈç∞ÈçóÈé§ÈèÜÈèûÈè∏Èê±ÈëÖÈëàÈñíÔßúÔ®©ÈöùÈöØÈú≥ÈúªÈùÉÈùçÈùèÈùëÈùïÈ°óÈ°•Ô®™Ô®´È§ßÔ®¨È¶ûÈ©éÈ´ô"],["fc40","È´úÈ≠µÈ≠≤ÈÆèÈÆ±ÈÆªÈ∞ÄÈµ∞Èµ´Ô®≠È∏ôÈªë"]]');

/***/ }),

/***/ 80056:
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('{"name":"dotenv","version":"17.2.3","description":"Loads environment variables from .env file","main":"lib/main.js","types":"lib/main.d.ts","exports":{".":{"types":"./lib/main.d.ts","require":"./lib/main.js","default":"./lib/main.js"},"./config":"./config.js","./config.js":"./config.js","./lib/env-options":"./lib/env-options.js","./lib/env-options.js":"./lib/env-options.js","./lib/cli-options":"./lib/cli-options.js","./lib/cli-options.js":"./lib/cli-options.js","./package.json":"./package.json"},"scripts":{"dts-check":"tsc --project tests/types/tsconfig.json","lint":"standard","pretest":"npm run lint && npm run dts-check","test":"tap run tests/**/*.js --allow-empty-coverage --disable-coverage --timeout=60000","test:coverage":"tap run tests/**/*.js --show-full-coverage --timeout=60000 --coverage-report=text --coverage-report=lcov","prerelease":"npm test","release":"standard-version"},"repository":{"type":"git","url":"git://github.com/motdotla/dotenv.git"},"homepage":"https://github.com/motdotla/dotenv#readme","funding":"https://dotenvx.com","keywords":["dotenv","env",".env","environment","variables","config","settings"],"readmeFilename":"README.md","license":"BSD-2-Clause","devDependencies":{"@types/node":"^18.11.3","decache":"^4.6.2","sinon":"^14.0.1","standard":"^17.0.0","standard-version":"^9.5.0","tap":"^19.2.0","typescript":"^4.8.4"},"engines":{"node":">=12"},"browser":{"fs":false}}');

/***/ }),

/***/ 10570:
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('{"name":"joi","description":"Object schema validation","version":"18.0.2","repository":{"url":"git://github.com/hapijs/joi","type":"git"},"engines":{"node":">= 20"},"main":"lib/index.js","types":"lib/index.d.ts","browser":"dist/joi-browser.min.js","files":["lib/**/*","dist/*"],"keywords":["schema","validation"],"dependencies":{"@hapi/address":"^5.1.1","@hapi/formula":"^3.0.2","@hapi/hoek":"^11.0.7","@hapi/pinpoint":"^2.0.1","@hapi/tlds":"^1.1.1","@hapi/topo":"^6.0.2","@standard-schema/spec":"^1.0.0"},"devDependencies":{"@hapi/bourne":"^3.0.0","@hapi/code":"^9.0.3","@hapi/eslint-plugin":"^7.0.0","@hapi/joi-legacy-test":"npm:@hapi/joi@15.x.x","@hapi/lab":"^26.0.0","@types/node":"^20.17.47","typescript":"^5.8.3"},"scripts":{"prepublishOnly":"cd browser && npm install && npm run build","test":"lab -t 100 -a @hapi/code -L -Y","test-cov-html":"lab -r html -o coverage.html -a @hapi/code"},"license":"BSD-3-Clause"}');

/***/ }),

/***/ 81813:
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('{"application/1d-interleaved-parityfec":{"source":"iana"},"application/3gpdash-qoe-report+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/3gpp-ims+xml":{"source":"iana","compressible":true},"application/3gpphal+json":{"source":"iana","compressible":true},"application/3gpphalforms+json":{"source":"iana","compressible":true},"application/a2l":{"source":"iana"},"application/ace+cbor":{"source":"iana"},"application/activemessage":{"source":"iana"},"application/activity+json":{"source":"iana","compressible":true},"application/alto-costmap+json":{"source":"iana","compressible":true},"application/alto-costmapfilter+json":{"source":"iana","compressible":true},"application/alto-directory+json":{"source":"iana","compressible":true},"application/alto-endpointcost+json":{"source":"iana","compressible":true},"application/alto-endpointcostparams+json":{"source":"iana","compressible":true},"application/alto-endpointprop+json":{"source":"iana","compressible":true},"application/alto-endpointpropparams+json":{"source":"iana","compressible":true},"application/alto-error+json":{"source":"iana","compressible":true},"application/alto-networkmap+json":{"source":"iana","compressible":true},"application/alto-networkmapfilter+json":{"source":"iana","compressible":true},"application/alto-updatestreamcontrol+json":{"source":"iana","compressible":true},"application/alto-updatestreamparams+json":{"source":"iana","compressible":true},"application/aml":{"source":"iana"},"application/andrew-inset":{"source":"iana","extensions":["ez"]},"application/applefile":{"source":"iana"},"application/applixware":{"source":"apache","extensions":["aw"]},"application/at+jwt":{"source":"iana"},"application/atf":{"source":"iana"},"application/atfx":{"source":"iana"},"application/atom+xml":{"source":"iana","compressible":true,"extensions":["atom"]},"application/atomcat+xml":{"source":"iana","compressible":true,"extensions":["atomcat"]},"application/atomdeleted+xml":{"source":"iana","compressible":true,"extensions":["atomdeleted"]},"application/atomicmail":{"source":"iana"},"application/atomsvc+xml":{"source":"iana","compressible":true,"extensions":["atomsvc"]},"application/atsc-dwd+xml":{"source":"iana","compressible":true,"extensions":["dwd"]},"application/atsc-dynamic-event-message":{"source":"iana"},"application/atsc-held+xml":{"source":"iana","compressible":true,"extensions":["held"]},"application/atsc-rdt+json":{"source":"iana","compressible":true},"application/atsc-rsat+xml":{"source":"iana","compressible":true,"extensions":["rsat"]},"application/atxml":{"source":"iana"},"application/auth-policy+xml":{"source":"iana","compressible":true},"application/bacnet-xdd+zip":{"source":"iana","compressible":false},"application/batch-smtp":{"source":"iana"},"application/bdoc":{"compressible":false,"extensions":["bdoc"]},"application/beep+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/calendar+json":{"source":"iana","compressible":true},"application/calendar+xml":{"source":"iana","compressible":true,"extensions":["xcs"]},"application/call-completion":{"source":"iana"},"application/cals-1840":{"source":"iana"},"application/captive+json":{"source":"iana","compressible":true},"application/cbor":{"source":"iana"},"application/cbor-seq":{"source":"iana"},"application/cccex":{"source":"iana"},"application/ccmp+xml":{"source":"iana","compressible":true},"application/ccxml+xml":{"source":"iana","compressible":true,"extensions":["ccxml"]},"application/cdfx+xml":{"source":"iana","compressible":true,"extensions":["cdfx"]},"application/cdmi-capability":{"source":"iana","extensions":["cdmia"]},"application/cdmi-container":{"source":"iana","extensions":["cdmic"]},"application/cdmi-domain":{"source":"iana","extensions":["cdmid"]},"application/cdmi-object":{"source":"iana","extensions":["cdmio"]},"application/cdmi-queue":{"source":"iana","extensions":["cdmiq"]},"application/cdni":{"source":"iana"},"application/cea":{"source":"iana"},"application/cea-2018+xml":{"source":"iana","compressible":true},"application/cellml+xml":{"source":"iana","compressible":true},"application/cfw":{"source":"iana"},"application/city+json":{"source":"iana","compressible":true},"application/clr":{"source":"iana"},"application/clue+xml":{"source":"iana","compressible":true},"application/clue_info+xml":{"source":"iana","compressible":true},"application/cms":{"source":"iana"},"application/cnrp+xml":{"source":"iana","compressible":true},"application/coap-group+json":{"source":"iana","compressible":true},"application/coap-payload":{"source":"iana"},"application/commonground":{"source":"iana"},"application/conference-info+xml":{"source":"iana","compressible":true},"application/cose":{"source":"iana"},"application/cose-key":{"source":"iana"},"application/cose-key-set":{"source":"iana"},"application/cpl+xml":{"source":"iana","compressible":true,"extensions":["cpl"]},"application/csrattrs":{"source":"iana"},"application/csta+xml":{"source":"iana","compressible":true},"application/cstadata+xml":{"source":"iana","compressible":true},"application/csvm+json":{"source":"iana","compressible":true},"application/cu-seeme":{"source":"apache","extensions":["cu"]},"application/cwt":{"source":"iana"},"application/cybercash":{"source":"iana"},"application/dart":{"compressible":true},"application/dash+xml":{"source":"iana","compressible":true,"extensions":["mpd"]},"application/dash-patch+xml":{"source":"iana","compressible":true,"extensions":["mpp"]},"application/dashdelta":{"source":"iana"},"application/davmount+xml":{"source":"iana","compressible":true,"extensions":["davmount"]},"application/dca-rft":{"source":"iana"},"application/dcd":{"source":"iana"},"application/dec-dx":{"source":"iana"},"application/dialog-info+xml":{"source":"iana","compressible":true},"application/dicom":{"source":"iana"},"application/dicom+json":{"source":"iana","compressible":true},"application/dicom+xml":{"source":"iana","compressible":true},"application/dii":{"source":"iana"},"application/dit":{"source":"iana"},"application/dns":{"source":"iana"},"application/dns+json":{"source":"iana","compressible":true},"application/dns-message":{"source":"iana"},"application/docbook+xml":{"source":"apache","compressible":true,"extensions":["dbk"]},"application/dots+cbor":{"source":"iana"},"application/dskpp+xml":{"source":"iana","compressible":true},"application/dssc+der":{"source":"iana","extensions":["dssc"]},"application/dssc+xml":{"source":"iana","compressible":true,"extensions":["xdssc"]},"application/dvcs":{"source":"iana"},"application/ecmascript":{"source":"iana","compressible":true,"extensions":["es","ecma"]},"application/edi-consent":{"source":"iana"},"application/edi-x12":{"source":"iana","compressible":false},"application/edifact":{"source":"iana","compressible":false},"application/efi":{"source":"iana"},"application/elm+json":{"source":"iana","charset":"UTF-8","compressible":true},"application/elm+xml":{"source":"iana","compressible":true},"application/emergencycalldata.cap+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/emergencycalldata.comment+xml":{"source":"iana","compressible":true},"application/emergencycalldata.control+xml":{"source":"iana","compressible":true},"application/emergencycalldata.deviceinfo+xml":{"source":"iana","compressible":true},"application/emergencycalldata.ecall.msd":{"source":"iana"},"application/emergencycalldata.providerinfo+xml":{"source":"iana","compressible":true},"application/emergencycalldata.serviceinfo+xml":{"source":"iana","compressible":true},"application/emergencycalldata.subscriberinfo+xml":{"source":"iana","compressible":true},"application/emergencycalldata.veds+xml":{"source":"iana","compressible":true},"application/emma+xml":{"source":"iana","compressible":true,"extensions":["emma"]},"application/emotionml+xml":{"source":"iana","compressible":true,"extensions":["emotionml"]},"application/encaprtp":{"source":"iana"},"application/epp+xml":{"source":"iana","compressible":true},"application/epub+zip":{"source":"iana","compressible":false,"extensions":["epub"]},"application/eshop":{"source":"iana"},"application/exi":{"source":"iana","extensions":["exi"]},"application/expect-ct-report+json":{"source":"iana","compressible":true},"application/express":{"source":"iana","extensions":["exp"]},"application/fastinfoset":{"source":"iana"},"application/fastsoap":{"source":"iana"},"application/fdt+xml":{"source":"iana","compressible":true,"extensions":["fdt"]},"application/fhir+json":{"source":"iana","charset":"UTF-8","compressible":true},"application/fhir+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/fido.trusted-apps+json":{"compressible":true},"application/fits":{"source":"iana"},"application/flexfec":{"source":"iana"},"application/font-sfnt":{"source":"iana"},"application/font-tdpfr":{"source":"iana","extensions":["pfr"]},"application/font-woff":{"source":"iana","compressible":false},"application/framework-attributes+xml":{"source":"iana","compressible":true},"application/geo+json":{"source":"iana","compressible":true,"extensions":["geojson"]},"application/geo+json-seq":{"source":"iana"},"application/geopackage+sqlite3":{"source":"iana"},"application/geoxacml+xml":{"source":"iana","compressible":true},"application/gltf-buffer":{"source":"iana"},"application/gml+xml":{"source":"iana","compressible":true,"extensions":["gml"]},"application/gpx+xml":{"source":"apache","compressible":true,"extensions":["gpx"]},"application/gxf":{"source":"apache","extensions":["gxf"]},"application/gzip":{"source":"iana","compressible":false,"extensions":["gz"]},"application/h224":{"source":"iana"},"application/held+xml":{"source":"iana","compressible":true},"application/hjson":{"extensions":["hjson"]},"application/http":{"source":"iana"},"application/hyperstudio":{"source":"iana","extensions":["stk"]},"application/ibe-key-request+xml":{"source":"iana","compressible":true},"application/ibe-pkg-reply+xml":{"source":"iana","compressible":true},"application/ibe-pp-data":{"source":"iana"},"application/iges":{"source":"iana"},"application/im-iscomposing+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/index":{"source":"iana"},"application/index.cmd":{"source":"iana"},"application/index.obj":{"source":"iana"},"application/index.response":{"source":"iana"},"application/index.vnd":{"source":"iana"},"application/inkml+xml":{"source":"iana","compressible":true,"extensions":["ink","inkml"]},"application/iotp":{"source":"iana"},"application/ipfix":{"source":"iana","extensions":["ipfix"]},"application/ipp":{"source":"iana"},"application/isup":{"source":"iana"},"application/its+xml":{"source":"iana","compressible":true,"extensions":["its"]},"application/java-archive":{"source":"apache","compressible":false,"extensions":["jar","war","ear"]},"application/java-serialized-object":{"source":"apache","compressible":false,"extensions":["ser"]},"application/java-vm":{"source":"apache","compressible":false,"extensions":["class"]},"application/javascript":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["js","mjs"]},"application/jf2feed+json":{"source":"iana","compressible":true},"application/jose":{"source":"iana"},"application/jose+json":{"source":"iana","compressible":true},"application/jrd+json":{"source":"iana","compressible":true},"application/jscalendar+json":{"source":"iana","compressible":true},"application/json":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["json","map"]},"application/json-patch+json":{"source":"iana","compressible":true},"application/json-seq":{"source":"iana"},"application/json5":{"extensions":["json5"]},"application/jsonml+json":{"source":"apache","compressible":true,"extensions":["jsonml"]},"application/jwk+json":{"source":"iana","compressible":true},"application/jwk-set+json":{"source":"iana","compressible":true},"application/jwt":{"source":"iana"},"application/kpml-request+xml":{"source":"iana","compressible":true},"application/kpml-response+xml":{"source":"iana","compressible":true},"application/ld+json":{"source":"iana","compressible":true,"extensions":["jsonld"]},"application/lgr+xml":{"source":"iana","compressible":true,"extensions":["lgr"]},"application/link-format":{"source":"iana"},"application/load-control+xml":{"source":"iana","compressible":true},"application/lost+xml":{"source":"iana","compressible":true,"extensions":["lostxml"]},"application/lostsync+xml":{"source":"iana","compressible":true},"application/lpf+zip":{"source":"iana","compressible":false},"application/lxf":{"source":"iana"},"application/mac-binhex40":{"source":"iana","extensions":["hqx"]},"application/mac-compactpro":{"source":"apache","extensions":["cpt"]},"application/macwriteii":{"source":"iana"},"application/mads+xml":{"source":"iana","compressible":true,"extensions":["mads"]},"application/manifest+json":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["webmanifest"]},"application/marc":{"source":"iana","extensions":["mrc"]},"application/marcxml+xml":{"source":"iana","compressible":true,"extensions":["mrcx"]},"application/mathematica":{"source":"iana","extensions":["ma","nb","mb"]},"application/mathml+xml":{"source":"iana","compressible":true,"extensions":["mathml"]},"application/mathml-content+xml":{"source":"iana","compressible":true},"application/mathml-presentation+xml":{"source":"iana","compressible":true},"application/mbms-associated-procedure-description+xml":{"source":"iana","compressible":true},"application/mbms-deregister+xml":{"source":"iana","compressible":true},"application/mbms-envelope+xml":{"source":"iana","compressible":true},"application/mbms-msk+xml":{"source":"iana","compressible":true},"application/mbms-msk-response+xml":{"source":"iana","compressible":true},"application/mbms-protection-description+xml":{"source":"iana","compressible":true},"application/mbms-reception-report+xml":{"source":"iana","compressible":true},"application/mbms-register+xml":{"source":"iana","compressible":true},"application/mbms-register-response+xml":{"source":"iana","compressible":true},"application/mbms-schedule+xml":{"source":"iana","compressible":true},"application/mbms-user-service-description+xml":{"source":"iana","compressible":true},"application/mbox":{"source":"iana","extensions":["mbox"]},"application/media-policy-dataset+xml":{"source":"iana","compressible":true,"extensions":["mpf"]},"application/media_control+xml":{"source":"iana","compressible":true},"application/mediaservercontrol+xml":{"source":"iana","compressible":true,"extensions":["mscml"]},"application/merge-patch+json":{"source":"iana","compressible":true},"application/metalink+xml":{"source":"apache","compressible":true,"extensions":["metalink"]},"application/metalink4+xml":{"source":"iana","compressible":true,"extensions":["meta4"]},"application/mets+xml":{"source":"iana","compressible":true,"extensions":["mets"]},"application/mf4":{"source":"iana"},"application/mikey":{"source":"iana"},"application/mipc":{"source":"iana"},"application/missing-blocks+cbor-seq":{"source":"iana"},"application/mmt-aei+xml":{"source":"iana","compressible":true,"extensions":["maei"]},"application/mmt-usd+xml":{"source":"iana","compressible":true,"extensions":["musd"]},"application/mods+xml":{"source":"iana","compressible":true,"extensions":["mods"]},"application/moss-keys":{"source":"iana"},"application/moss-signature":{"source":"iana"},"application/mosskey-data":{"source":"iana"},"application/mosskey-request":{"source":"iana"},"application/mp21":{"source":"iana","extensions":["m21","mp21"]},"application/mp4":{"source":"iana","extensions":["mp4s","m4p"]},"application/mpeg4-generic":{"source":"iana"},"application/mpeg4-iod":{"source":"iana"},"application/mpeg4-iod-xmt":{"source":"iana"},"application/mrb-consumer+xml":{"source":"iana","compressible":true},"application/mrb-publish+xml":{"source":"iana","compressible":true},"application/msc-ivr+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/msc-mixer+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/msword":{"source":"iana","compressible":false,"extensions":["doc","dot"]},"application/mud+json":{"source":"iana","compressible":true},"application/multipart-core":{"source":"iana"},"application/mxf":{"source":"iana","extensions":["mxf"]},"application/n-quads":{"source":"iana","extensions":["nq"]},"application/n-triples":{"source":"iana","extensions":["nt"]},"application/nasdata":{"source":"iana"},"application/news-checkgroups":{"source":"iana","charset":"US-ASCII"},"application/news-groupinfo":{"source":"iana","charset":"US-ASCII"},"application/news-transmission":{"source":"iana"},"application/nlsml+xml":{"source":"iana","compressible":true},"application/node":{"source":"iana","extensions":["cjs"]},"application/nss":{"source":"iana"},"application/oauth-authz-req+jwt":{"source":"iana"},"application/oblivious-dns-message":{"source":"iana"},"application/ocsp-request":{"source":"iana"},"application/ocsp-response":{"source":"iana"},"application/octet-stream":{"source":"iana","compressible":false,"extensions":["bin","dms","lrf","mar","so","dist","distz","pkg","bpk","dump","elc","deploy","exe","dll","deb","dmg","iso","img","msi","msp","msm","buffer"]},"application/oda":{"source":"iana","extensions":["oda"]},"application/odm+xml":{"source":"iana","compressible":true},"application/odx":{"source":"iana"},"application/oebps-package+xml":{"source":"iana","compressible":true,"extensions":["opf"]},"application/ogg":{"source":"iana","compressible":false,"extensions":["ogx"]},"application/omdoc+xml":{"source":"apache","compressible":true,"extensions":["omdoc"]},"application/onenote":{"source":"apache","extensions":["onetoc","onetoc2","onetmp","onepkg"]},"application/opc-nodeset+xml":{"source":"iana","compressible":true},"application/oscore":{"source":"iana"},"application/oxps":{"source":"iana","extensions":["oxps"]},"application/p21":{"source":"iana"},"application/p21+zip":{"source":"iana","compressible":false},"application/p2p-overlay+xml":{"source":"iana","compressible":true,"extensions":["relo"]},"application/parityfec":{"source":"iana"},"application/passport":{"source":"iana"},"application/patch-ops-error+xml":{"source":"iana","compressible":true,"extensions":["xer"]},"application/pdf":{"source":"iana","compressible":false,"extensions":["pdf"]},"application/pdx":{"source":"iana"},"application/pem-certificate-chain":{"source":"iana"},"application/pgp-encrypted":{"source":"iana","compressible":false,"extensions":["pgp"]},"application/pgp-keys":{"source":"iana","extensions":["asc"]},"application/pgp-signature":{"source":"iana","extensions":["asc","sig"]},"application/pics-rules":{"source":"apache","extensions":["prf"]},"application/pidf+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/pidf-diff+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/pkcs10":{"source":"iana","extensions":["p10"]},"application/pkcs12":{"source":"iana"},"application/pkcs7-mime":{"source":"iana","extensions":["p7m","p7c"]},"application/pkcs7-signature":{"source":"iana","extensions":["p7s"]},"application/pkcs8":{"source":"iana","extensions":["p8"]},"application/pkcs8-encrypted":{"source":"iana"},"application/pkix-attr-cert":{"source":"iana","extensions":["ac"]},"application/pkix-cert":{"source":"iana","extensions":["cer"]},"application/pkix-crl":{"source":"iana","extensions":["crl"]},"application/pkix-pkipath":{"source":"iana","extensions":["pkipath"]},"application/pkixcmp":{"source":"iana","extensions":["pki"]},"application/pls+xml":{"source":"iana","compressible":true,"extensions":["pls"]},"application/poc-settings+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/postscript":{"source":"iana","compressible":true,"extensions":["ai","eps","ps"]},"application/ppsp-tracker+json":{"source":"iana","compressible":true},"application/problem+json":{"source":"iana","compressible":true},"application/problem+xml":{"source":"iana","compressible":true},"application/provenance+xml":{"source":"iana","compressible":true,"extensions":["provx"]},"application/prs.alvestrand.titrax-sheet":{"source":"iana"},"application/prs.cww":{"source":"iana","extensions":["cww"]},"application/prs.cyn":{"source":"iana","charset":"7-BIT"},"application/prs.hpub+zip":{"source":"iana","compressible":false},"application/prs.nprend":{"source":"iana"},"application/prs.plucker":{"source":"iana"},"application/prs.rdf-xml-crypt":{"source":"iana"},"application/prs.xsf+xml":{"source":"iana","compressible":true},"application/pskc+xml":{"source":"iana","compressible":true,"extensions":["pskcxml"]},"application/pvd+json":{"source":"iana","compressible":true},"application/qsig":{"source":"iana"},"application/raml+yaml":{"compressible":true,"extensions":["raml"]},"application/raptorfec":{"source":"iana"},"application/rdap+json":{"source":"iana","compressible":true},"application/rdf+xml":{"source":"iana","compressible":true,"extensions":["rdf","owl"]},"application/reginfo+xml":{"source":"iana","compressible":true,"extensions":["rif"]},"application/relax-ng-compact-syntax":{"source":"iana","extensions":["rnc"]},"application/remote-printing":{"source":"iana"},"application/reputon+json":{"source":"iana","compressible":true},"application/resource-lists+xml":{"source":"iana","compressible":true,"extensions":["rl"]},"application/resource-lists-diff+xml":{"source":"iana","compressible":true,"extensions":["rld"]},"application/rfc+xml":{"source":"iana","compressible":true},"application/riscos":{"source":"iana"},"application/rlmi+xml":{"source":"iana","compressible":true},"application/rls-services+xml":{"source":"iana","compressible":true,"extensions":["rs"]},"application/route-apd+xml":{"source":"iana","compressible":true,"extensions":["rapd"]},"application/route-s-tsid+xml":{"source":"iana","compressible":true,"extensions":["sls"]},"application/route-usd+xml":{"source":"iana","compressible":true,"extensions":["rusd"]},"application/rpki-ghostbusters":{"source":"iana","extensions":["gbr"]},"application/rpki-manifest":{"source":"iana","extensions":["mft"]},"application/rpki-publication":{"source":"iana"},"application/rpki-roa":{"source":"iana","extensions":["roa"]},"application/rpki-updown":{"source":"iana"},"application/rsd+xml":{"source":"apache","compressible":true,"extensions":["rsd"]},"application/rss+xml":{"source":"apache","compressible":true,"extensions":["rss"]},"application/rtf":{"source":"iana","compressible":true,"extensions":["rtf"]},"application/rtploopback":{"source":"iana"},"application/rtx":{"source":"iana"},"application/samlassertion+xml":{"source":"iana","compressible":true},"application/samlmetadata+xml":{"source":"iana","compressible":true},"application/sarif+json":{"source":"iana","compressible":true},"application/sarif-external-properties+json":{"source":"iana","compressible":true},"application/sbe":{"source":"iana"},"application/sbml+xml":{"source":"iana","compressible":true,"extensions":["sbml"]},"application/scaip+xml":{"source":"iana","compressible":true},"application/scim+json":{"source":"iana","compressible":true},"application/scvp-cv-request":{"source":"iana","extensions":["scq"]},"application/scvp-cv-response":{"source":"iana","extensions":["scs"]},"application/scvp-vp-request":{"source":"iana","extensions":["spq"]},"application/scvp-vp-response":{"source":"iana","extensions":["spp"]},"application/sdp":{"source":"iana","extensions":["sdp"]},"application/secevent+jwt":{"source":"iana"},"application/senml+cbor":{"source":"iana"},"application/senml+json":{"source":"iana","compressible":true},"application/senml+xml":{"source":"iana","compressible":true,"extensions":["senmlx"]},"application/senml-etch+cbor":{"source":"iana"},"application/senml-etch+json":{"source":"iana","compressible":true},"application/senml-exi":{"source":"iana"},"application/sensml+cbor":{"source":"iana"},"application/sensml+json":{"source":"iana","compressible":true},"application/sensml+xml":{"source":"iana","compressible":true,"extensions":["sensmlx"]},"application/sensml-exi":{"source":"iana"},"application/sep+xml":{"source":"iana","compressible":true},"application/sep-exi":{"source":"iana"},"application/session-info":{"source":"iana"},"application/set-payment":{"source":"iana"},"application/set-payment-initiation":{"source":"iana","extensions":["setpay"]},"application/set-registration":{"source":"iana"},"application/set-registration-initiation":{"source":"iana","extensions":["setreg"]},"application/sgml":{"source":"iana"},"application/sgml-open-catalog":{"source":"iana"},"application/shf+xml":{"source":"iana","compressible":true,"extensions":["shf"]},"application/sieve":{"source":"iana","extensions":["siv","sieve"]},"application/simple-filter+xml":{"source":"iana","compressible":true},"application/simple-message-summary":{"source":"iana"},"application/simplesymbolcontainer":{"source":"iana"},"application/sipc":{"source":"iana"},"application/slate":{"source":"iana"},"application/smil":{"source":"iana"},"application/smil+xml":{"source":"iana","compressible":true,"extensions":["smi","smil"]},"application/smpte336m":{"source":"iana"},"application/soap+fastinfoset":{"source":"iana"},"application/soap+xml":{"source":"iana","compressible":true},"application/sparql-query":{"source":"iana","extensions":["rq"]},"application/sparql-results+xml":{"source":"iana","compressible":true,"extensions":["srx"]},"application/spdx+json":{"source":"iana","compressible":true},"application/spirits-event+xml":{"source":"iana","compressible":true},"application/sql":{"source":"iana"},"application/srgs":{"source":"iana","extensions":["gram"]},"application/srgs+xml":{"source":"iana","compressible":true,"extensions":["grxml"]},"application/sru+xml":{"source":"iana","compressible":true,"extensions":["sru"]},"application/ssdl+xml":{"source":"apache","compressible":true,"extensions":["ssdl"]},"application/ssml+xml":{"source":"iana","compressible":true,"extensions":["ssml"]},"application/stix+json":{"source":"iana","compressible":true},"application/swid+xml":{"source":"iana","compressible":true,"extensions":["swidtag"]},"application/tamp-apex-update":{"source":"iana"},"application/tamp-apex-update-confirm":{"source":"iana"},"application/tamp-community-update":{"source":"iana"},"application/tamp-community-update-confirm":{"source":"iana"},"application/tamp-error":{"source":"iana"},"application/tamp-sequence-adjust":{"source":"iana"},"application/tamp-sequence-adjust-confirm":{"source":"iana"},"application/tamp-status-query":{"source":"iana"},"application/tamp-status-response":{"source":"iana"},"application/tamp-update":{"source":"iana"},"application/tamp-update-confirm":{"source":"iana"},"application/tar":{"compressible":true},"application/taxii+json":{"source":"iana","compressible":true},"application/td+json":{"source":"iana","compressible":true},"application/tei+xml":{"source":"iana","compressible":true,"extensions":["tei","teicorpus"]},"application/tetra_isi":{"source":"iana"},"application/thraud+xml":{"source":"iana","compressible":true,"extensions":["tfi"]},"application/timestamp-query":{"source":"iana"},"application/timestamp-reply":{"source":"iana"},"application/timestamped-data":{"source":"iana","extensions":["tsd"]},"application/tlsrpt+gzip":{"source":"iana"},"application/tlsrpt+json":{"source":"iana","compressible":true},"application/tnauthlist":{"source":"iana"},"application/token-introspection+jwt":{"source":"iana"},"application/toml":{"compressible":true,"extensions":["toml"]},"application/trickle-ice-sdpfrag":{"source":"iana"},"application/trig":{"source":"iana","extensions":["trig"]},"application/ttml+xml":{"source":"iana","compressible":true,"extensions":["ttml"]},"application/tve-trigger":{"source":"iana"},"application/tzif":{"source":"iana"},"application/tzif-leap":{"source":"iana"},"application/ubjson":{"compressible":false,"extensions":["ubj"]},"application/ulpfec":{"source":"iana"},"application/urc-grpsheet+xml":{"source":"iana","compressible":true},"application/urc-ressheet+xml":{"source":"iana","compressible":true,"extensions":["rsheet"]},"application/urc-targetdesc+xml":{"source":"iana","compressible":true,"extensions":["td"]},"application/urc-uisocketdesc+xml":{"source":"iana","compressible":true},"application/vcard+json":{"source":"iana","compressible":true},"application/vcard+xml":{"source":"iana","compressible":true},"application/vemmi":{"source":"iana"},"application/vividence.scriptfile":{"source":"apache"},"application/vnd.1000minds.decision-model+xml":{"source":"iana","compressible":true,"extensions":["1km"]},"application/vnd.3gpp-prose+xml":{"source":"iana","compressible":true},"application/vnd.3gpp-prose-pc3ch+xml":{"source":"iana","compressible":true},"application/vnd.3gpp-v2x-local-service-information":{"source":"iana"},"application/vnd.3gpp.5gnas":{"source":"iana"},"application/vnd.3gpp.access-transfer-events+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.bsf+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.gmop+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.gtpc":{"source":"iana"},"application/vnd.3gpp.interworking-data":{"source":"iana"},"application/vnd.3gpp.lpp":{"source":"iana"},"application/vnd.3gpp.mc-signalling-ear":{"source":"iana"},"application/vnd.3gpp.mcdata-affiliation-command+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcdata-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcdata-payload":{"source":"iana"},"application/vnd.3gpp.mcdata-service-config+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcdata-signalling":{"source":"iana"},"application/vnd.3gpp.mcdata-ue-config+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcdata-user-profile+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-affiliation-command+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-floor-request+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-location-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-mbms-usage-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-service-config+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-signed+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-ue-config+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-ue-init-config+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-user-profile+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-affiliation-command+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-affiliation-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-location-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-mbms-usage-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-service-config+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-transmission-request+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-ue-config+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-user-profile+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mid-call+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.ngap":{"source":"iana"},"application/vnd.3gpp.pfcp":{"source":"iana"},"application/vnd.3gpp.pic-bw-large":{"source":"iana","extensions":["plb"]},"application/vnd.3gpp.pic-bw-small":{"source":"iana","extensions":["psb"]},"application/vnd.3gpp.pic-bw-var":{"source":"iana","extensions":["pvb"]},"application/vnd.3gpp.s1ap":{"source":"iana"},"application/vnd.3gpp.sms":{"source":"iana"},"application/vnd.3gpp.sms+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.srvcc-ext+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.srvcc-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.state-and-event-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.ussd+xml":{"source":"iana","compressible":true},"application/vnd.3gpp2.bcmcsinfo+xml":{"source":"iana","compressible":true},"application/vnd.3gpp2.sms":{"source":"iana"},"application/vnd.3gpp2.tcap":{"source":"iana","extensions":["tcap"]},"application/vnd.3lightssoftware.imagescal":{"source":"iana"},"application/vnd.3m.post-it-notes":{"source":"iana","extensions":["pwn"]},"application/vnd.accpac.simply.aso":{"source":"iana","extensions":["aso"]},"application/vnd.accpac.simply.imp":{"source":"iana","extensions":["imp"]},"application/vnd.acucobol":{"source":"iana","extensions":["acu"]},"application/vnd.acucorp":{"source":"iana","extensions":["atc","acutc"]},"application/vnd.adobe.air-application-installer-package+zip":{"source":"apache","compressible":false,"extensions":["air"]},"application/vnd.adobe.flash.movie":{"source":"iana"},"application/vnd.adobe.formscentral.fcdt":{"source":"iana","extensions":["fcdt"]},"application/vnd.adobe.fxp":{"source":"iana","extensions":["fxp","fxpl"]},"application/vnd.adobe.partial-upload":{"source":"iana"},"application/vnd.adobe.xdp+xml":{"source":"iana","compressible":true,"extensions":["xdp"]},"application/vnd.adobe.xfdf":{"source":"iana","extensions":["xfdf"]},"application/vnd.aether.imp":{"source":"iana"},"application/vnd.afpc.afplinedata":{"source":"iana"},"application/vnd.afpc.afplinedata-pagedef":{"source":"iana"},"application/vnd.afpc.cmoca-cmresource":{"source":"iana"},"application/vnd.afpc.foca-charset":{"source":"iana"},"application/vnd.afpc.foca-codedfont":{"source":"iana"},"application/vnd.afpc.foca-codepage":{"source":"iana"},"application/vnd.afpc.modca":{"source":"iana"},"application/vnd.afpc.modca-cmtable":{"source":"iana"},"application/vnd.afpc.modca-formdef":{"source":"iana"},"application/vnd.afpc.modca-mediummap":{"source":"iana"},"application/vnd.afpc.modca-objectcontainer":{"source":"iana"},"application/vnd.afpc.modca-overlay":{"source":"iana"},"application/vnd.afpc.modca-pagesegment":{"source":"iana"},"application/vnd.age":{"source":"iana","extensions":["age"]},"application/vnd.ah-barcode":{"source":"iana"},"application/vnd.ahead.space":{"source":"iana","extensions":["ahead"]},"application/vnd.airzip.filesecure.azf":{"source":"iana","extensions":["azf"]},"application/vnd.airzip.filesecure.azs":{"source":"iana","extensions":["azs"]},"application/vnd.amadeus+json":{"source":"iana","compressible":true},"application/vnd.amazon.ebook":{"source":"apache","extensions":["azw"]},"application/vnd.amazon.mobi8-ebook":{"source":"iana"},"application/vnd.americandynamics.acc":{"source":"iana","extensions":["acc"]},"application/vnd.amiga.ami":{"source":"iana","extensions":["ami"]},"application/vnd.amundsen.maze+xml":{"source":"iana","compressible":true},"application/vnd.android.ota":{"source":"iana"},"application/vnd.android.package-archive":{"source":"apache","compressible":false,"extensions":["apk"]},"application/vnd.anki":{"source":"iana"},"application/vnd.anser-web-certificate-issue-initiation":{"source":"iana","extensions":["cii"]},"application/vnd.anser-web-funds-transfer-initiation":{"source":"apache","extensions":["fti"]},"application/vnd.antix.game-component":{"source":"iana","extensions":["atx"]},"application/vnd.apache.arrow.file":{"source":"iana"},"application/vnd.apache.arrow.stream":{"source":"iana"},"application/vnd.apache.thrift.binary":{"source":"iana"},"application/vnd.apache.thrift.compact":{"source":"iana"},"application/vnd.apache.thrift.json":{"source":"iana"},"application/vnd.api+json":{"source":"iana","compressible":true},"application/vnd.aplextor.warrp+json":{"source":"iana","compressible":true},"application/vnd.apothekende.reservation+json":{"source":"iana","compressible":true},"application/vnd.apple.installer+xml":{"source":"iana","compressible":true,"extensions":["mpkg"]},"application/vnd.apple.keynote":{"source":"iana","extensions":["key"]},"application/vnd.apple.mpegurl":{"source":"iana","extensions":["m3u8"]},"application/vnd.apple.numbers":{"source":"iana","extensions":["numbers"]},"application/vnd.apple.pages":{"source":"iana","extensions":["pages"]},"application/vnd.apple.pkpass":{"compressible":false,"extensions":["pkpass"]},"application/vnd.arastra.swi":{"source":"iana"},"application/vnd.aristanetworks.swi":{"source":"iana","extensions":["swi"]},"application/vnd.artisan+json":{"source":"iana","compressible":true},"application/vnd.artsquare":{"source":"iana"},"application/vnd.astraea-software.iota":{"source":"iana","extensions":["iota"]},"application/vnd.audiograph":{"source":"iana","extensions":["aep"]},"application/vnd.autopackage":{"source":"iana"},"application/vnd.avalon+json":{"source":"iana","compressible":true},"application/vnd.avistar+xml":{"source":"iana","compressible":true},"application/vnd.balsamiq.bmml+xml":{"source":"iana","compressible":true,"extensions":["bmml"]},"application/vnd.balsamiq.bmpr":{"source":"iana"},"application/vnd.banana-accounting":{"source":"iana"},"application/vnd.bbf.usp.error":{"source":"iana"},"application/vnd.bbf.usp.msg":{"source":"iana"},"application/vnd.bbf.usp.msg+json":{"source":"iana","compressible":true},"application/vnd.bekitzur-stech+json":{"source":"iana","compressible":true},"application/vnd.bint.med-content":{"source":"iana"},"application/vnd.biopax.rdf+xml":{"source":"iana","compressible":true},"application/vnd.blink-idb-value-wrapper":{"source":"iana"},"application/vnd.blueice.multipass":{"source":"iana","extensions":["mpm"]},"application/vnd.bluetooth.ep.oob":{"source":"iana"},"application/vnd.bluetooth.le.oob":{"source":"iana"},"application/vnd.bmi":{"source":"iana","extensions":["bmi"]},"application/vnd.bpf":{"source":"iana"},"application/vnd.bpf3":{"source":"iana"},"application/vnd.businessobjects":{"source":"iana","extensions":["rep"]},"application/vnd.byu.uapi+json":{"source":"iana","compressible":true},"application/vnd.cab-jscript":{"source":"iana"},"application/vnd.canon-cpdl":{"source":"iana"},"application/vnd.canon-lips":{"source":"iana"},"application/vnd.capasystems-pg+json":{"source":"iana","compressible":true},"application/vnd.cendio.thinlinc.clientconf":{"source":"iana"},"application/vnd.century-systems.tcp_stream":{"source":"iana"},"application/vnd.chemdraw+xml":{"source":"iana","compressible":true,"extensions":["cdxml"]},"application/vnd.chess-pgn":{"source":"iana"},"application/vnd.chipnuts.karaoke-mmd":{"source":"iana","extensions":["mmd"]},"application/vnd.ciedi":{"source":"iana"},"application/vnd.cinderella":{"source":"iana","extensions":["cdy"]},"application/vnd.cirpack.isdn-ext":{"source":"iana"},"application/vnd.citationstyles.style+xml":{"source":"iana","compressible":true,"extensions":["csl"]},"application/vnd.claymore":{"source":"iana","extensions":["cla"]},"application/vnd.cloanto.rp9":{"source":"iana","extensions":["rp9"]},"application/vnd.clonk.c4group":{"source":"iana","extensions":["c4g","c4d","c4f","c4p","c4u"]},"application/vnd.cluetrust.cartomobile-config":{"source":"iana","extensions":["c11amc"]},"application/vnd.cluetrust.cartomobile-config-pkg":{"source":"iana","extensions":["c11amz"]},"application/vnd.coffeescript":{"source":"iana"},"application/vnd.collabio.xodocuments.document":{"source":"iana"},"application/vnd.collabio.xodocuments.document-template":{"source":"iana"},"application/vnd.collabio.xodocuments.presentation":{"source":"iana"},"application/vnd.collabio.xodocuments.presentation-template":{"source":"iana"},"application/vnd.collabio.xodocuments.spreadsheet":{"source":"iana"},"application/vnd.collabio.xodocuments.spreadsheet-template":{"source":"iana"},"application/vnd.collection+json":{"source":"iana","compressible":true},"application/vnd.collection.doc+json":{"source":"iana","compressible":true},"application/vnd.collection.next+json":{"source":"iana","compressible":true},"application/vnd.comicbook+zip":{"source":"iana","compressible":false},"application/vnd.comicbook-rar":{"source":"iana"},"application/vnd.commerce-battelle":{"source":"iana"},"application/vnd.commonspace":{"source":"iana","extensions":["csp"]},"application/vnd.contact.cmsg":{"source":"iana","extensions":["cdbcmsg"]},"application/vnd.coreos.ignition+json":{"source":"iana","compressible":true},"application/vnd.cosmocaller":{"source":"iana","extensions":["cmc"]},"application/vnd.crick.clicker":{"source":"iana","extensions":["clkx"]},"application/vnd.crick.clicker.keyboard":{"source":"iana","extensions":["clkk"]},"application/vnd.crick.clicker.palette":{"source":"iana","extensions":["clkp"]},"application/vnd.crick.clicker.template":{"source":"iana","extensions":["clkt"]},"application/vnd.crick.clicker.wordbank":{"source":"iana","extensions":["clkw"]},"application/vnd.criticaltools.wbs+xml":{"source":"iana","compressible":true,"extensions":["wbs"]},"application/vnd.cryptii.pipe+json":{"source":"iana","compressible":true},"application/vnd.crypto-shade-file":{"source":"iana"},"application/vnd.cryptomator.encrypted":{"source":"iana"},"application/vnd.cryptomator.vault":{"source":"iana"},"application/vnd.ctc-posml":{"source":"iana","extensions":["pml"]},"application/vnd.ctct.ws+xml":{"source":"iana","compressible":true},"application/vnd.cups-pdf":{"source":"iana"},"application/vnd.cups-postscript":{"source":"iana"},"application/vnd.cups-ppd":{"source":"iana","extensions":["ppd"]},"application/vnd.cups-raster":{"source":"iana"},"application/vnd.cups-raw":{"source":"iana"},"application/vnd.curl":{"source":"iana"},"application/vnd.curl.car":{"source":"apache","extensions":["car"]},"application/vnd.curl.pcurl":{"source":"apache","extensions":["pcurl"]},"application/vnd.cyan.dean.root+xml":{"source":"iana","compressible":true},"application/vnd.cybank":{"source":"iana"},"application/vnd.cyclonedx+json":{"source":"iana","compressible":true},"application/vnd.cyclonedx+xml":{"source":"iana","compressible":true},"application/vnd.d2l.coursepackage1p0+zip":{"source":"iana","compressible":false},"application/vnd.d3m-dataset":{"source":"iana"},"application/vnd.d3m-problem":{"source":"iana"},"application/vnd.dart":{"source":"iana","compressible":true,"extensions":["dart"]},"application/vnd.data-vision.rdz":{"source":"iana","extensions":["rdz"]},"application/vnd.datapackage+json":{"source":"iana","compressible":true},"application/vnd.dataresource+json":{"source":"iana","compressible":true},"application/vnd.dbf":{"source":"iana","extensions":["dbf"]},"application/vnd.debian.binary-package":{"source":"iana"},"application/vnd.dece.data":{"source":"iana","extensions":["uvf","uvvf","uvd","uvvd"]},"application/vnd.dece.ttml+xml":{"source":"iana","compressible":true,"extensions":["uvt","uvvt"]},"application/vnd.dece.unspecified":{"source":"iana","extensions":["uvx","uvvx"]},"application/vnd.dece.zip":{"source":"iana","extensions":["uvz","uvvz"]},"application/vnd.denovo.fcselayout-link":{"source":"iana","extensions":["fe_launch"]},"application/vnd.desmume.movie":{"source":"iana"},"application/vnd.dir-bi.plate-dl-nosuffix":{"source":"iana"},"application/vnd.dm.delegation+xml":{"source":"iana","compressible":true},"application/vnd.dna":{"source":"iana","extensions":["dna"]},"application/vnd.document+json":{"source":"iana","compressible":true},"application/vnd.dolby.mlp":{"source":"apache","extensions":["mlp"]},"application/vnd.dolby.mobile.1":{"source":"iana"},"application/vnd.dolby.mobile.2":{"source":"iana"},"application/vnd.doremir.scorecloud-binary-document":{"source":"iana"},"application/vnd.dpgraph":{"source":"iana","extensions":["dpg"]},"application/vnd.dreamfactory":{"source":"iana","extensions":["dfac"]},"application/vnd.drive+json":{"source":"iana","compressible":true},"application/vnd.ds-keypoint":{"source":"apache","extensions":["kpxx"]},"application/vnd.dtg.local":{"source":"iana"},"application/vnd.dtg.local.flash":{"source":"iana"},"application/vnd.dtg.local.html":{"source":"iana"},"application/vnd.dvb.ait":{"source":"iana","extensions":["ait"]},"application/vnd.dvb.dvbisl+xml":{"source":"iana","compressible":true},"application/vnd.dvb.dvbj":{"source":"iana"},"application/vnd.dvb.esgcontainer":{"source":"iana"},"application/vnd.dvb.ipdcdftnotifaccess":{"source":"iana"},"application/vnd.dvb.ipdcesgaccess":{"source":"iana"},"application/vnd.dvb.ipdcesgaccess2":{"source":"iana"},"application/vnd.dvb.ipdcesgpdd":{"source":"iana"},"application/vnd.dvb.ipdcroaming":{"source":"iana"},"application/vnd.dvb.iptv.alfec-base":{"source":"iana"},"application/vnd.dvb.iptv.alfec-enhancement":{"source":"iana"},"application/vnd.dvb.notif-aggregate-root+xml":{"source":"iana","compressible":true},"application/vnd.dvb.notif-container+xml":{"source":"iana","compressible":true},"application/vnd.dvb.notif-generic+xml":{"source":"iana","compressible":true},"application/vnd.dvb.notif-ia-msglist+xml":{"source":"iana","compressible":true},"application/vnd.dvb.notif-ia-registration-request+xml":{"source":"iana","compressible":true},"application/vnd.dvb.notif-ia-registration-response+xml":{"source":"iana","compressible":true},"application/vnd.dvb.notif-init+xml":{"source":"iana","compressible":true},"application/vnd.dvb.pfr":{"source":"iana"},"application/vnd.dvb.service":{"source":"iana","extensions":["svc"]},"application/vnd.dxr":{"source":"iana"},"application/vnd.dynageo":{"source":"iana","extensions":["geo"]},"application/vnd.dzr":{"source":"iana"},"application/vnd.easykaraoke.cdgdownload":{"source":"iana"},"application/vnd.ecdis-update":{"source":"iana"},"application/vnd.ecip.rlp":{"source":"iana"},"application/vnd.eclipse.ditto+json":{"source":"iana","compressible":true},"application/vnd.ecowin.chart":{"source":"iana","extensions":["mag"]},"application/vnd.ecowin.filerequest":{"source":"iana"},"application/vnd.ecowin.fileupdate":{"source":"iana"},"application/vnd.ecowin.series":{"source":"iana"},"application/vnd.ecowin.seriesrequest":{"source":"iana"},"application/vnd.ecowin.seriesupdate":{"source":"iana"},"application/vnd.efi.img":{"source":"iana"},"application/vnd.efi.iso":{"source":"iana"},"application/vnd.emclient.accessrequest+xml":{"source":"iana","compressible":true},"application/vnd.enliven":{"source":"iana","extensions":["nml"]},"application/vnd.enphase.envoy":{"source":"iana"},"application/vnd.eprints.data+xml":{"source":"iana","compressible":true},"application/vnd.epson.esf":{"source":"iana","extensions":["esf"]},"application/vnd.epson.msf":{"source":"iana","extensions":["msf"]},"application/vnd.epson.quickanime":{"source":"iana","extensions":["qam"]},"application/vnd.epson.salt":{"source":"iana","extensions":["slt"]},"application/vnd.epson.ssf":{"source":"iana","extensions":["ssf"]},"application/vnd.ericsson.quickcall":{"source":"iana"},"application/vnd.espass-espass+zip":{"source":"iana","compressible":false},"application/vnd.eszigno3+xml":{"source":"iana","compressible":true,"extensions":["es3","et3"]},"application/vnd.etsi.aoc+xml":{"source":"iana","compressible":true},"application/vnd.etsi.asic-e+zip":{"source":"iana","compressible":false},"application/vnd.etsi.asic-s+zip":{"source":"iana","compressible":false},"application/vnd.etsi.cug+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvcommand+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvdiscovery+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvprofile+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvsad-bc+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvsad-cod+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvsad-npvr+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvservice+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvsync+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvueprofile+xml":{"source":"iana","compressible":true},"application/vnd.etsi.mcid+xml":{"source":"iana","compressible":true},"application/vnd.etsi.mheg5":{"source":"iana"},"application/vnd.etsi.overload-control-policy-dataset+xml":{"source":"iana","compressible":true},"application/vnd.etsi.pstn+xml":{"source":"iana","compressible":true},"application/vnd.etsi.sci+xml":{"source":"iana","compressible":true},"application/vnd.etsi.simservs+xml":{"source":"iana","compressible":true},"application/vnd.etsi.timestamp-token":{"source":"iana"},"application/vnd.etsi.tsl+xml":{"source":"iana","compressible":true},"application/vnd.etsi.tsl.der":{"source":"iana"},"application/vnd.eu.kasparian.car+json":{"source":"iana","compressible":true},"application/vnd.eudora.data":{"source":"iana"},"application/vnd.evolv.ecig.profile":{"source":"iana"},"application/vnd.evolv.ecig.settings":{"source":"iana"},"application/vnd.evolv.ecig.theme":{"source":"iana"},"application/vnd.exstream-empower+zip":{"source":"iana","compressible":false},"application/vnd.exstream-package":{"source":"iana"},"application/vnd.ezpix-album":{"source":"iana","extensions":["ez2"]},"application/vnd.ezpix-package":{"source":"iana","extensions":["ez3"]},"application/vnd.f-secure.mobile":{"source":"iana"},"application/vnd.familysearch.gedcom+zip":{"source":"iana","compressible":false},"application/vnd.fastcopy-disk-image":{"source":"iana"},"application/vnd.fdf":{"source":"iana","extensions":["fdf"]},"application/vnd.fdsn.mseed":{"source":"iana","extensions":["mseed"]},"application/vnd.fdsn.seed":{"source":"iana","extensions":["seed","dataless"]},"application/vnd.ffsns":{"source":"iana"},"application/vnd.ficlab.flb+zip":{"source":"iana","compressible":false},"application/vnd.filmit.zfc":{"source":"iana"},"application/vnd.fints":{"source":"iana"},"application/vnd.firemonkeys.cloudcell":{"source":"iana"},"application/vnd.flographit":{"source":"iana","extensions":["gph"]},"application/vnd.fluxtime.clip":{"source":"iana","extensions":["ftc"]},"application/vnd.font-fontforge-sfd":{"source":"iana"},"application/vnd.framemaker":{"source":"iana","extensions":["fm","frame","maker","book"]},"application/vnd.frogans.fnc":{"source":"iana","extensions":["fnc"]},"application/vnd.frogans.ltf":{"source":"iana","extensions":["ltf"]},"application/vnd.fsc.weblaunch":{"source":"iana","extensions":["fsc"]},"application/vnd.fujifilm.fb.docuworks":{"source":"iana"},"application/vnd.fujifilm.fb.docuworks.binder":{"source":"iana"},"application/vnd.fujifilm.fb.docuworks.container":{"source":"iana"},"application/vnd.fujifilm.fb.jfi+xml":{"source":"iana","compressible":true},"application/vnd.fujitsu.oasys":{"source":"iana","extensions":["oas"]},"application/vnd.fujitsu.oasys2":{"source":"iana","extensions":["oa2"]},"application/vnd.fujitsu.oasys3":{"source":"iana","extensions":["oa3"]},"application/vnd.fujitsu.oasysgp":{"source":"iana","extensions":["fg5"]},"application/vnd.fujitsu.oasysprs":{"source":"iana","extensions":["bh2"]},"application/vnd.fujixerox.art-ex":{"source":"iana"},"application/vnd.fujixerox.art4":{"source":"iana"},"application/vnd.fujixerox.ddd":{"source":"iana","extensions":["ddd"]},"application/vnd.fujixerox.docuworks":{"source":"iana","extensions":["xdw"]},"application/vnd.fujixerox.docuworks.binder":{"source":"iana","extensions":["xbd"]},"application/vnd.fujixerox.docuworks.container":{"source":"iana"},"application/vnd.fujixerox.hbpl":{"source":"iana"},"application/vnd.fut-misnet":{"source":"iana"},"application/vnd.futoin+cbor":{"source":"iana"},"application/vnd.futoin+json":{"source":"iana","compressible":true},"application/vnd.fuzzysheet":{"source":"iana","extensions":["fzs"]},"application/vnd.genomatix.tuxedo":{"source":"iana","extensions":["txd"]},"application/vnd.gentics.grd+json":{"source":"iana","compressible":true},"application/vnd.geo+json":{"source":"iana","compressible":true},"application/vnd.geocube+xml":{"source":"iana","compressible":true},"application/vnd.geogebra.file":{"source":"iana","extensions":["ggb"]},"application/vnd.geogebra.slides":{"source":"iana"},"application/vnd.geogebra.tool":{"source":"iana","extensions":["ggt"]},"application/vnd.geometry-explorer":{"source":"iana","extensions":["gex","gre"]},"application/vnd.geonext":{"source":"iana","extensions":["gxt"]},"application/vnd.geoplan":{"source":"iana","extensions":["g2w"]},"application/vnd.geospace":{"source":"iana","extensions":["g3w"]},"application/vnd.gerber":{"source":"iana"},"application/vnd.globalplatform.card-content-mgt":{"source":"iana"},"application/vnd.globalplatform.card-content-mgt-response":{"source":"iana"},"application/vnd.gmx":{"source":"iana","extensions":["gmx"]},"application/vnd.google-apps.document":{"compressible":false,"extensions":["gdoc"]},"application/vnd.google-apps.presentation":{"compressible":false,"extensions":["gslides"]},"application/vnd.google-apps.spreadsheet":{"compressible":false,"extensions":["gsheet"]},"application/vnd.google-earth.kml+xml":{"source":"iana","compressible":true,"extensions":["kml"]},"application/vnd.google-earth.kmz":{"source":"iana","compressible":false,"extensions":["kmz"]},"application/vnd.gov.sk.e-form+xml":{"source":"iana","compressible":true},"application/vnd.gov.sk.e-form+zip":{"source":"iana","compressible":false},"application/vnd.gov.sk.xmldatacontainer+xml":{"source":"iana","compressible":true},"application/vnd.grafeq":{"source":"iana","extensions":["gqf","gqs"]},"application/vnd.gridmp":{"source":"iana"},"application/vnd.groove-account":{"source":"iana","extensions":["gac"]},"application/vnd.groove-help":{"source":"iana","extensions":["ghf"]},"application/vnd.groove-identity-message":{"source":"iana","extensions":["gim"]},"application/vnd.groove-injector":{"source":"iana","extensions":["grv"]},"application/vnd.groove-tool-message":{"source":"iana","extensions":["gtm"]},"application/vnd.groove-tool-template":{"source":"iana","extensions":["tpl"]},"application/vnd.groove-vcard":{"source":"iana","extensions":["vcg"]},"application/vnd.hal+json":{"source":"iana","compressible":true},"application/vnd.hal+xml":{"source":"iana","compressible":true,"extensions":["hal"]},"application/vnd.handheld-entertainment+xml":{"source":"iana","compressible":true,"extensions":["zmm"]},"application/vnd.hbci":{"source":"iana","extensions":["hbci"]},"application/vnd.hc+json":{"source":"iana","compressible":true},"application/vnd.hcl-bireports":{"source":"iana"},"application/vnd.hdt":{"source":"iana"},"application/vnd.heroku+json":{"source":"iana","compressible":true},"application/vnd.hhe.lesson-player":{"source":"iana","extensions":["les"]},"application/vnd.hl7cda+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/vnd.hl7v2+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/vnd.hp-hpgl":{"source":"iana","extensions":["hpgl"]},"application/vnd.hp-hpid":{"source":"iana","extensions":["hpid"]},"application/vnd.hp-hps":{"source":"iana","extensions":["hps"]},"application/vnd.hp-jlyt":{"source":"iana","extensions":["jlt"]},"application/vnd.hp-pcl":{"source":"iana","extensions":["pcl"]},"application/vnd.hp-pclxl":{"source":"iana","extensions":["pclxl"]},"application/vnd.httphone":{"source":"iana"},"application/vnd.hydrostatix.sof-data":{"source":"iana","extensions":["sfd-hdstx"]},"application/vnd.hyper+json":{"source":"iana","compressible":true},"application/vnd.hyper-item+json":{"source":"iana","compressible":true},"application/vnd.hyperdrive+json":{"source":"iana","compressible":true},"application/vnd.hzn-3d-crossword":{"source":"iana"},"application/vnd.ibm.afplinedata":{"source":"iana"},"application/vnd.ibm.electronic-media":{"source":"iana"},"application/vnd.ibm.minipay":{"source":"iana","extensions":["mpy"]},"application/vnd.ibm.modcap":{"source":"iana","extensions":["afp","listafp","list3820"]},"application/vnd.ibm.rights-management":{"source":"iana","extensions":["irm"]},"application/vnd.ibm.secure-container":{"source":"iana","extensions":["sc"]},"application/vnd.iccprofile":{"source":"iana","extensions":["icc","icm"]},"application/vnd.ieee.1905":{"source":"iana"},"application/vnd.igloader":{"source":"iana","extensions":["igl"]},"application/vnd.imagemeter.folder+zip":{"source":"iana","compressible":false},"application/vnd.imagemeter.image+zip":{"source":"iana","compressible":false},"application/vnd.immervision-ivp":{"source":"iana","extensions":["ivp"]},"application/vnd.immervision-ivu":{"source":"iana","extensions":["ivu"]},"application/vnd.ims.imsccv1p1":{"source":"iana"},"application/vnd.ims.imsccv1p2":{"source":"iana"},"application/vnd.ims.imsccv1p3":{"source":"iana"},"application/vnd.ims.lis.v2.result+json":{"source":"iana","compressible":true},"application/vnd.ims.lti.v2.toolconsumerprofile+json":{"source":"iana","compressible":true},"application/vnd.ims.lti.v2.toolproxy+json":{"source":"iana","compressible":true},"application/vnd.ims.lti.v2.toolproxy.id+json":{"source":"iana","compressible":true},"application/vnd.ims.lti.v2.toolsettings+json":{"source":"iana","compressible":true},"application/vnd.ims.lti.v2.toolsettings.simple+json":{"source":"iana","compressible":true},"application/vnd.informedcontrol.rms+xml":{"source":"iana","compressible":true},"application/vnd.informix-visionary":{"source":"iana"},"application/vnd.infotech.project":{"source":"iana"},"application/vnd.infotech.project+xml":{"source":"iana","compressible":true},"application/vnd.innopath.wamp.notification":{"source":"iana"},"application/vnd.insors.igm":{"source":"iana","extensions":["igm"]},"application/vnd.intercon.formnet":{"source":"iana","extensions":["xpw","xpx"]},"application/vnd.intergeo":{"source":"iana","extensions":["i2g"]},"application/vnd.intertrust.digibox":{"source":"iana"},"application/vnd.intertrust.nncp":{"source":"iana"},"application/vnd.intu.qbo":{"source":"iana","extensions":["qbo"]},"application/vnd.intu.qfx":{"source":"iana","extensions":["qfx"]},"application/vnd.iptc.g2.catalogitem+xml":{"source":"iana","compressible":true},"application/vnd.iptc.g2.conceptitem+xml":{"source":"iana","compressible":true},"application/vnd.iptc.g2.knowledgeitem+xml":{"source":"iana","compressible":true},"application/vnd.iptc.g2.newsitem+xml":{"source":"iana","compressible":true},"application/vnd.iptc.g2.newsmessage+xml":{"source":"iana","compressible":true},"application/vnd.iptc.g2.packageitem+xml":{"source":"iana","compressible":true},"application/vnd.iptc.g2.planningitem+xml":{"source":"iana","compressible":true},"application/vnd.ipunplugged.rcprofile":{"source":"iana","extensions":["rcprofile"]},"application/vnd.irepository.package+xml":{"source":"iana","compressible":true,"extensions":["irp"]},"application/vnd.is-xpr":{"source":"iana","extensions":["xpr"]},"application/vnd.isac.fcs":{"source":"iana","extensions":["fcs"]},"application/vnd.iso11783-10+zip":{"source":"iana","compressible":false},"application/vnd.jam":{"source":"iana","extensions":["jam"]},"application/vnd.japannet-directory-service":{"source":"iana"},"application/vnd.japannet-jpnstore-wakeup":{"source":"iana"},"application/vnd.japannet-payment-wakeup":{"source":"iana"},"application/vnd.japannet-registration":{"source":"iana"},"application/vnd.japannet-registration-wakeup":{"source":"iana"},"application/vnd.japannet-setstore-wakeup":{"source":"iana"},"application/vnd.japannet-verification":{"source":"iana"},"application/vnd.japannet-verification-wakeup":{"source":"iana"},"application/vnd.jcp.javame.midlet-rms":{"source":"iana","extensions":["rms"]},"application/vnd.jisp":{"source":"iana","extensions":["jisp"]},"application/vnd.joost.joda-archive":{"source":"iana","extensions":["joda"]},"application/vnd.jsk.isdn-ngn":{"source":"iana"},"application/vnd.kahootz":{"source":"iana","extensions":["ktz","ktr"]},"application/vnd.kde.karbon":{"source":"iana","extensions":["karbon"]},"application/vnd.kde.kchart":{"source":"iana","extensions":["chrt"]},"application/vnd.kde.kformula":{"source":"iana","extensions":["kfo"]},"application/vnd.kde.kivio":{"source":"iana","extensions":["flw"]},"application/vnd.kde.kontour":{"source":"iana","extensions":["kon"]},"application/vnd.kde.kpresenter":{"source":"iana","extensions":["kpr","kpt"]},"application/vnd.kde.kspread":{"source":"iana","extensions":["ksp"]},"application/vnd.kde.kword":{"source":"iana","extensions":["kwd","kwt"]},"application/vnd.kenameaapp":{"source":"iana","extensions":["htke"]},"application/vnd.kidspiration":{"source":"iana","extensions":["kia"]},"application/vnd.kinar":{"source":"iana","extensions":["kne","knp"]},"application/vnd.koan":{"source":"iana","extensions":["skp","skd","skt","skm"]},"application/vnd.kodak-descriptor":{"source":"iana","extensions":["sse"]},"application/vnd.las":{"source":"iana"},"application/vnd.las.las+json":{"source":"iana","compressible":true},"application/vnd.las.las+xml":{"source":"iana","compressible":true,"extensions":["lasxml"]},"application/vnd.laszip":{"source":"iana"},"application/vnd.leap+json":{"source":"iana","compressible":true},"application/vnd.liberty-request+xml":{"source":"iana","compressible":true},"application/vnd.llamagraphics.life-balance.desktop":{"source":"iana","extensions":["lbd"]},"application/vnd.llamagraphics.life-balance.exchange+xml":{"source":"iana","compressible":true,"extensions":["lbe"]},"application/vnd.logipipe.circuit+zip":{"source":"iana","compressible":false},"application/vnd.loom":{"source":"iana"},"application/vnd.lotus-1-2-3":{"source":"iana","extensions":["123"]},"application/vnd.lotus-approach":{"source":"iana","extensions":["apr"]},"application/vnd.lotus-freelance":{"source":"iana","extensions":["pre"]},"application/vnd.lotus-notes":{"source":"iana","extensions":["nsf"]},"application/vnd.lotus-organizer":{"source":"iana","extensions":["org"]},"application/vnd.lotus-screencam":{"source":"iana","extensions":["scm"]},"application/vnd.lotus-wordpro":{"source":"iana","extensions":["lwp"]},"application/vnd.macports.portpkg":{"source":"iana","extensions":["portpkg"]},"application/vnd.mapbox-vector-tile":{"source":"iana","extensions":["mvt"]},"application/vnd.marlin.drm.actiontoken+xml":{"source":"iana","compressible":true},"application/vnd.marlin.drm.conftoken+xml":{"source":"iana","compressible":true},"application/vnd.marlin.drm.license+xml":{"source":"iana","compressible":true},"application/vnd.marlin.drm.mdcf":{"source":"iana"},"application/vnd.mason+json":{"source":"iana","compressible":true},"application/vnd.maxar.archive.3tz+zip":{"source":"iana","compressible":false},"application/vnd.maxmind.maxmind-db":{"source":"iana"},"application/vnd.mcd":{"source":"iana","extensions":["mcd"]},"application/vnd.medcalcdata":{"source":"iana","extensions":["mc1"]},"application/vnd.mediastation.cdkey":{"source":"iana","extensions":["cdkey"]},"application/vnd.meridian-slingshot":{"source":"iana"},"application/vnd.mfer":{"source":"iana","extensions":["mwf"]},"application/vnd.mfmp":{"source":"iana","extensions":["mfm"]},"application/vnd.micro+json":{"source":"iana","compressible":true},"application/vnd.micrografx.flo":{"source":"iana","extensions":["flo"]},"application/vnd.micrografx.igx":{"source":"iana","extensions":["igx"]},"application/vnd.microsoft.portable-executable":{"source":"iana"},"application/vnd.microsoft.windows.thumbnail-cache":{"source":"iana"},"application/vnd.miele+json":{"source":"iana","compressible":true},"application/vnd.mif":{"source":"iana","extensions":["mif"]},"application/vnd.minisoft-hp3000-save":{"source":"iana"},"application/vnd.mitsubishi.misty-guard.trustweb":{"source":"iana"},"application/vnd.mobius.daf":{"source":"iana","extensions":["daf"]},"application/vnd.mobius.dis":{"source":"iana","extensions":["dis"]},"application/vnd.mobius.mbk":{"source":"iana","extensions":["mbk"]},"application/vnd.mobius.mqy":{"source":"iana","extensions":["mqy"]},"application/vnd.mobius.msl":{"source":"iana","extensions":["msl"]},"application/vnd.mobius.plc":{"source":"iana","extensions":["plc"]},"application/vnd.mobius.txf":{"source":"iana","extensions":["txf"]},"application/vnd.mophun.application":{"source":"iana","extensions":["mpn"]},"application/vnd.mophun.certificate":{"source":"iana","extensions":["mpc"]},"application/vnd.motorola.flexsuite":{"source":"iana"},"application/vnd.motorola.flexsuite.adsi":{"source":"iana"},"application/vnd.motorola.flexsuite.fis":{"source":"iana"},"application/vnd.motorola.flexsuite.gotap":{"source":"iana"},"application/vnd.motorola.flexsuite.kmr":{"source":"iana"},"application/vnd.motorola.flexsuite.ttc":{"source":"iana"},"application/vnd.motorola.flexsuite.wem":{"source":"iana"},"application/vnd.motorola.iprm":{"source":"iana"},"application/vnd.mozilla.xul+xml":{"source":"iana","compressible":true,"extensions":["xul"]},"application/vnd.ms-3mfdocument":{"source":"iana"},"application/vnd.ms-artgalry":{"source":"iana","extensions":["cil"]},"application/vnd.ms-asf":{"source":"iana"},"application/vnd.ms-cab-compressed":{"source":"iana","extensions":["cab"]},"application/vnd.ms-color.iccprofile":{"source":"apache"},"application/vnd.ms-excel":{"source":"iana","compressible":false,"extensions":["xls","xlm","xla","xlc","xlt","xlw"]},"application/vnd.ms-excel.addin.macroenabled.12":{"source":"iana","extensions":["xlam"]},"application/vnd.ms-excel.sheet.binary.macroenabled.12":{"source":"iana","extensions":["xlsb"]},"application/vnd.ms-excel.sheet.macroenabled.12":{"source":"iana","extensions":["xlsm"]},"application/vnd.ms-excel.template.macroenabled.12":{"source":"iana","extensions":["xltm"]},"application/vnd.ms-fontobject":{"source":"iana","compressible":true,"extensions":["eot"]},"application/vnd.ms-htmlhelp":{"source":"iana","extensions":["chm"]},"application/vnd.ms-ims":{"source":"iana","extensions":["ims"]},"application/vnd.ms-lrm":{"source":"iana","extensions":["lrm"]},"application/vnd.ms-office.activex+xml":{"source":"iana","compressible":true},"application/vnd.ms-officetheme":{"source":"iana","extensions":["thmx"]},"application/vnd.ms-opentype":{"source":"apache","compressible":true},"application/vnd.ms-outlook":{"compressible":false,"extensions":["msg"]},"application/vnd.ms-package.obfuscated-opentype":{"source":"apache"},"application/vnd.ms-pki.seccat":{"source":"apache","extensions":["cat"]},"application/vnd.ms-pki.stl":{"source":"apache","extensions":["stl"]},"application/vnd.ms-playready.initiator+xml":{"source":"iana","compressible":true},"application/vnd.ms-powerpoint":{"source":"iana","compressible":false,"extensions":["ppt","pps","pot"]},"application/vnd.ms-powerpoint.addin.macroenabled.12":{"source":"iana","extensions":["ppam"]},"application/vnd.ms-powerpoint.presentation.macroenabled.12":{"source":"iana","extensions":["pptm"]},"application/vnd.ms-powerpoint.slide.macroenabled.12":{"source":"iana","extensions":["sldm"]},"application/vnd.ms-powerpoint.slideshow.macroenabled.12":{"source":"iana","extensions":["ppsm"]},"application/vnd.ms-powerpoint.template.macroenabled.12":{"source":"iana","extensions":["potm"]},"application/vnd.ms-printdevicecapabilities+xml":{"source":"iana","compressible":true},"application/vnd.ms-printing.printticket+xml":{"source":"apache","compressible":true},"application/vnd.ms-printschematicket+xml":{"source":"iana","compressible":true},"application/vnd.ms-project":{"source":"iana","extensions":["mpp","mpt"]},"application/vnd.ms-tnef":{"source":"iana"},"application/vnd.ms-windows.devicepairing":{"source":"iana"},"application/vnd.ms-windows.nwprinting.oob":{"source":"iana"},"application/vnd.ms-windows.printerpairing":{"source":"iana"},"application/vnd.ms-windows.wsd.oob":{"source":"iana"},"application/vnd.ms-wmdrm.lic-chlg-req":{"source":"iana"},"application/vnd.ms-wmdrm.lic-resp":{"source":"iana"},"application/vnd.ms-wmdrm.meter-chlg-req":{"source":"iana"},"application/vnd.ms-wmdrm.meter-resp":{"source":"iana"},"application/vnd.ms-word.document.macroenabled.12":{"source":"iana","extensions":["docm"]},"application/vnd.ms-word.template.macroenabled.12":{"source":"iana","extensions":["dotm"]},"application/vnd.ms-works":{"source":"iana","extensions":["wps","wks","wcm","wdb"]},"application/vnd.ms-wpl":{"source":"iana","extensions":["wpl"]},"application/vnd.ms-xpsdocument":{"source":"iana","compressible":false,"extensions":["xps"]},"application/vnd.msa-disk-image":{"source":"iana"},"application/vnd.mseq":{"source":"iana","extensions":["mseq"]},"application/vnd.msign":{"source":"iana"},"application/vnd.multiad.creator":{"source":"iana"},"application/vnd.multiad.creator.cif":{"source":"iana"},"application/vnd.music-niff":{"source":"iana"},"application/vnd.musician":{"source":"iana","extensions":["mus"]},"application/vnd.muvee.style":{"source":"iana","extensions":["msty"]},"application/vnd.mynfc":{"source":"iana","extensions":["taglet"]},"application/vnd.nacamar.ybrid+json":{"source":"iana","compressible":true},"application/vnd.ncd.control":{"source":"iana"},"application/vnd.ncd.reference":{"source":"iana"},"application/vnd.nearst.inv+json":{"source":"iana","compressible":true},"application/vnd.nebumind.line":{"source":"iana"},"application/vnd.nervana":{"source":"iana"},"application/vnd.netfpx":{"source":"iana"},"application/vnd.neurolanguage.nlu":{"source":"iana","extensions":["nlu"]},"application/vnd.nimn":{"source":"iana"},"application/vnd.nintendo.nitro.rom":{"source":"iana"},"application/vnd.nintendo.snes.rom":{"source":"iana"},"application/vnd.nitf":{"source":"iana","extensions":["ntf","nitf"]},"application/vnd.noblenet-directory":{"source":"iana","extensions":["nnd"]},"application/vnd.noblenet-sealer":{"source":"iana","extensions":["nns"]},"application/vnd.noblenet-web":{"source":"iana","extensions":["nnw"]},"application/vnd.nokia.catalogs":{"source":"iana"},"application/vnd.nokia.conml+wbxml":{"source":"iana"},"application/vnd.nokia.conml+xml":{"source":"iana","compressible":true},"application/vnd.nokia.iptv.config+xml":{"source":"iana","compressible":true},"application/vnd.nokia.isds-radio-presets":{"source":"iana"},"application/vnd.nokia.landmark+wbxml":{"source":"iana"},"application/vnd.nokia.landmark+xml":{"source":"iana","compressible":true},"application/vnd.nokia.landmarkcollection+xml":{"source":"iana","compressible":true},"application/vnd.nokia.n-gage.ac+xml":{"source":"iana","compressible":true,"extensions":["ac"]},"application/vnd.nokia.n-gage.data":{"source":"iana","extensions":["ngdat"]},"application/vnd.nokia.n-gage.symbian.install":{"source":"iana","extensions":["n-gage"]},"application/vnd.nokia.ncd":{"source":"iana"},"application/vnd.nokia.pcd+wbxml":{"source":"iana"},"application/vnd.nokia.pcd+xml":{"source":"iana","compressible":true},"application/vnd.nokia.radio-preset":{"source":"iana","extensions":["rpst"]},"application/vnd.nokia.radio-presets":{"source":"iana","extensions":["rpss"]},"application/vnd.novadigm.edm":{"source":"iana","extensions":["edm"]},"application/vnd.novadigm.edx":{"source":"iana","extensions":["edx"]},"application/vnd.novadigm.ext":{"source":"iana","extensions":["ext"]},"application/vnd.ntt-local.content-share":{"source":"iana"},"application/vnd.ntt-local.file-transfer":{"source":"iana"},"application/vnd.ntt-local.ogw_remote-access":{"source":"iana"},"application/vnd.ntt-local.sip-ta_remote":{"source":"iana"},"application/vnd.ntt-local.sip-ta_tcp_stream":{"source":"iana"},"application/vnd.oasis.opendocument.chart":{"source":"iana","extensions":["odc"]},"application/vnd.oasis.opendocument.chart-template":{"source":"iana","extensions":["otc"]},"application/vnd.oasis.opendocument.database":{"source":"iana","extensions":["odb"]},"application/vnd.oasis.opendocument.formula":{"source":"iana","extensions":["odf"]},"application/vnd.oasis.opendocument.formula-template":{"source":"iana","extensions":["odft"]},"application/vnd.oasis.opendocument.graphics":{"source":"iana","compressible":false,"extensions":["odg"]},"application/vnd.oasis.opendocument.graphics-template":{"source":"iana","extensions":["otg"]},"application/vnd.oasis.opendocument.image":{"source":"iana","extensions":["odi"]},"application/vnd.oasis.opendocument.image-template":{"source":"iana","extensions":["oti"]},"application/vnd.oasis.opendocument.presentation":{"source":"iana","compressible":false,"extensions":["odp"]},"application/vnd.oasis.opendocument.presentation-template":{"source":"iana","extensions":["otp"]},"application/vnd.oasis.opendocument.spreadsheet":{"source":"iana","compressible":false,"extensions":["ods"]},"application/vnd.oasis.opendocument.spreadsheet-template":{"source":"iana","extensions":["ots"]},"application/vnd.oasis.opendocument.text":{"source":"iana","compressible":false,"extensions":["odt"]},"application/vnd.oasis.opendocument.text-master":{"source":"iana","extensions":["odm"]},"application/vnd.oasis.opendocument.text-template":{"source":"iana","extensions":["ott"]},"application/vnd.oasis.opendocument.text-web":{"source":"iana","extensions":["oth"]},"application/vnd.obn":{"source":"iana"},"application/vnd.ocf+cbor":{"source":"iana"},"application/vnd.oci.image.manifest.v1+json":{"source":"iana","compressible":true},"application/vnd.oftn.l10n+json":{"source":"iana","compressible":true},"application/vnd.oipf.contentaccessdownload+xml":{"source":"iana","compressible":true},"application/vnd.oipf.contentaccessstreaming+xml":{"source":"iana","compressible":true},"application/vnd.oipf.cspg-hexbinary":{"source":"iana"},"application/vnd.oipf.dae.svg+xml":{"source":"iana","compressible":true},"application/vnd.oipf.dae.xhtml+xml":{"source":"iana","compressible":true},"application/vnd.oipf.mippvcontrolmessage+xml":{"source":"iana","compressible":true},"application/vnd.oipf.pae.gem":{"source":"iana"},"application/vnd.oipf.spdiscovery+xml":{"source":"iana","compressible":true},"application/vnd.oipf.spdlist+xml":{"source":"iana","compressible":true},"application/vnd.oipf.ueprofile+xml":{"source":"iana","compressible":true},"application/vnd.oipf.userprofile+xml":{"source":"iana","compressible":true},"application/vnd.olpc-sugar":{"source":"iana","extensions":["xo"]},"application/vnd.oma-scws-config":{"source":"iana"},"application/vnd.oma-scws-http-request":{"source":"iana"},"application/vnd.oma-scws-http-response":{"source":"iana"},"application/vnd.oma.bcast.associated-procedure-parameter+xml":{"source":"iana","compressible":true},"application/vnd.oma.bcast.drm-trigger+xml":{"source":"iana","compressible":true},"application/vnd.oma.bcast.imd+xml":{"source":"iana","compressible":true},"application/vnd.oma.bcast.ltkm":{"source":"iana"},"application/vnd.oma.bcast.notification+xml":{"source":"iana","compressible":true},"application/vnd.oma.bcast.provisioningtrigger":{"source":"iana"},"application/vnd.oma.bcast.sgboot":{"source":"iana"},"application/vnd.oma.bcast.sgdd+xml":{"source":"iana","compressible":true},"application/vnd.oma.bcast.sgdu":{"source":"iana"},"application/vnd.oma.bcast.simple-symbol-container":{"source":"iana"},"application/vnd.oma.bcast.smartcard-trigger+xml":{"source":"iana","compressible":true},"application/vnd.oma.bcast.sprov+xml":{"source":"iana","compressible":true},"application/vnd.oma.bcast.stkm":{"source":"iana"},"application/vnd.oma.cab-address-book+xml":{"source":"iana","compressible":true},"application/vnd.oma.cab-feature-handler+xml":{"source":"iana","compressible":true},"application/vnd.oma.cab-pcc+xml":{"source":"iana","compressible":true},"application/vnd.oma.cab-subs-invite+xml":{"source":"iana","compressible":true},"application/vnd.oma.cab-user-prefs+xml":{"source":"iana","compressible":true},"application/vnd.oma.dcd":{"source":"iana"},"application/vnd.oma.dcdc":{"source":"iana"},"application/vnd.oma.dd2+xml":{"source":"iana","compressible":true,"extensions":["dd2"]},"application/vnd.oma.drm.risd+xml":{"source":"iana","compressible":true},"application/vnd.oma.group-usage-list+xml":{"source":"iana","compressible":true},"application/vnd.oma.lwm2m+cbor":{"source":"iana"},"application/vnd.oma.lwm2m+json":{"source":"iana","compressible":true},"application/vnd.oma.lwm2m+tlv":{"source":"iana"},"application/vnd.oma.pal+xml":{"source":"iana","compressible":true},"application/vnd.oma.poc.detailed-progress-report+xml":{"source":"iana","compressible":true},"application/vnd.oma.poc.final-report+xml":{"source":"iana","compressible":true},"application/vnd.oma.poc.groups+xml":{"source":"iana","compressible":true},"application/vnd.oma.poc.invocation-descriptor+xml":{"source":"iana","compressible":true},"application/vnd.oma.poc.optimized-progress-report+xml":{"source":"iana","compressible":true},"application/vnd.oma.push":{"source":"iana"},"application/vnd.oma.scidm.messages+xml":{"source":"iana","compressible":true},"application/vnd.oma.xcap-directory+xml":{"source":"iana","compressible":true},"application/vnd.omads-email+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/vnd.omads-file+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/vnd.omads-folder+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/vnd.omaloc-supl-init":{"source":"iana"},"application/vnd.onepager":{"source":"iana"},"application/vnd.onepagertamp":{"source":"iana"},"application/vnd.onepagertamx":{"source":"iana"},"application/vnd.onepagertat":{"source":"iana"},"application/vnd.onepagertatp":{"source":"iana"},"application/vnd.onepagertatx":{"source":"iana"},"application/vnd.openblox.game+xml":{"source":"iana","compressible":true,"extensions":["obgx"]},"application/vnd.openblox.game-binary":{"source":"iana"},"application/vnd.openeye.oeb":{"source":"iana"},"application/vnd.openofficeorg.extension":{"source":"apache","extensions":["oxt"]},"application/vnd.openstreetmap.data+xml":{"source":"iana","compressible":true,"extensions":["osm"]},"application/vnd.opentimestamps.ots":{"source":"iana"},"application/vnd.openxmlformats-officedocument.custom-properties+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.customxmlproperties+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.drawing+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.drawingml.chart+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.drawingml.diagramcolors+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.drawingml.diagramdata+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.drawingml.diagramlayout+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.drawingml.diagramstyle+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.extended-properties+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.commentauthors+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.comments+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.handoutmaster+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.notesmaster+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.notesslide+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.presentation":{"source":"iana","compressible":false,"extensions":["pptx"]},"application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.presprops+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.slide":{"source":"iana","extensions":["sldx"]},"application/vnd.openxmlformats-officedocument.presentationml.slide+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.slidelayout+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.slidemaster+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.slideshow":{"source":"iana","extensions":["ppsx"]},"application/vnd.openxmlformats-officedocument.presentationml.slideshow.main+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.slideupdateinfo+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.tablestyles+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.tags+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.template":{"source":"iana","extensions":["potx"]},"application/vnd.openxmlformats-officedocument.presentationml.template.main+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.viewprops+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.calcchain+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.externallink+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcachedefinition+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcacherecords+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.pivottable+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.querytable+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.revisionheaders+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.revisionlog+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.sharedstrings+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet":{"source":"iana","compressible":false,"extensions":["xlsx"]},"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.sheetmetadata+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.tablesinglecells+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.template":{"source":"iana","extensions":["xltx"]},"application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.usernames+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.volatiledependencies+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.theme+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.themeoverride+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.vmldrawing":{"source":"iana"},"application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.document":{"source":"iana","compressible":false,"extensions":["docx"]},"application/vnd.openxmlformats-officedocument.wordprocessingml.document.glossary+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.endnotes+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.fonttable+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.template":{"source":"iana","extensions":["dotx"]},"application/vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.websettings+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-package.core-properties+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-package.digital-signature-xmlsignature+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-package.relationships+xml":{"source":"iana","compressible":true},"application/vnd.oracle.resource+json":{"source":"iana","compressible":true},"application/vnd.orange.indata":{"source":"iana"},"application/vnd.osa.netdeploy":{"source":"iana"},"application/vnd.osgeo.mapguide.package":{"source":"iana","extensions":["mgp"]},"application/vnd.osgi.bundle":{"source":"iana"},"application/vnd.osgi.dp":{"source":"iana","extensions":["dp"]},"application/vnd.osgi.subsystem":{"source":"iana","extensions":["esa"]},"application/vnd.otps.ct-kip+xml":{"source":"iana","compressible":true},"application/vnd.oxli.countgraph":{"source":"iana"},"application/vnd.pagerduty+json":{"source":"iana","compressible":true},"application/vnd.palm":{"source":"iana","extensions":["pdb","pqa","oprc"]},"application/vnd.panoply":{"source":"iana"},"application/vnd.paos.xml":{"source":"iana"},"application/vnd.patentdive":{"source":"iana"},"application/vnd.patientecommsdoc":{"source":"iana"},"application/vnd.pawaafile":{"source":"iana","extensions":["paw"]},"application/vnd.pcos":{"source":"iana"},"application/vnd.pg.format":{"source":"iana","extensions":["str"]},"application/vnd.pg.osasli":{"source":"iana","extensions":["ei6"]},"application/vnd.piaccess.application-licence":{"source":"iana"},"application/vnd.picsel":{"source":"iana","extensions":["efif"]},"application/vnd.pmi.widget":{"source":"iana","extensions":["wg"]},"application/vnd.poc.group-advertisement+xml":{"source":"iana","compressible":true},"application/vnd.pocketlearn":{"source":"iana","extensions":["plf"]},"application/vnd.powerbuilder6":{"source":"iana","extensions":["pbd"]},"application/vnd.powerbuilder6-s":{"source":"iana"},"application/vnd.powerbuilder7":{"source":"iana"},"application/vnd.powerbuilder7-s":{"source":"iana"},"application/vnd.powerbuilder75":{"source":"iana"},"application/vnd.powerbuilder75-s":{"source":"iana"},"application/vnd.preminet":{"source":"iana"},"application/vnd.previewsystems.box":{"source":"iana","extensions":["box"]},"application/vnd.proteus.magazine":{"source":"iana","extensions":["mgz"]},"application/vnd.psfs":{"source":"iana"},"application/vnd.publishare-delta-tree":{"source":"iana","extensions":["qps"]},"application/vnd.pvi.ptid1":{"source":"iana","extensions":["ptid"]},"application/vnd.pwg-multiplexed":{"source":"iana"},"application/vnd.pwg-xhtml-print+xml":{"source":"iana","compressible":true},"application/vnd.qualcomm.brew-app-res":{"source":"iana"},"application/vnd.quarantainenet":{"source":"iana"},"application/vnd.quark.quarkxpress":{"source":"iana","extensions":["qxd","qxt","qwd","qwt","qxl","qxb"]},"application/vnd.quobject-quoxdocument":{"source":"iana"},"application/vnd.radisys.moml+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-audit+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-audit-conf+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-audit-conn+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-audit-dialog+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-audit-stream+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-conf+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-dialog+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-dialog-base+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-dialog-fax-detect+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-dialog-fax-sendrecv+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-dialog-group+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-dialog-speech+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-dialog-transform+xml":{"source":"iana","compressible":true},"application/vnd.rainstor.data":{"source":"iana"},"application/vnd.rapid":{"source":"iana"},"application/vnd.rar":{"source":"iana","extensions":["rar"]},"application/vnd.realvnc.bed":{"source":"iana","extensions":["bed"]},"application/vnd.recordare.musicxml":{"source":"iana","extensions":["mxl"]},"application/vnd.recordare.musicxml+xml":{"source":"iana","compressible":true,"extensions":["musicxml"]},"application/vnd.renlearn.rlprint":{"source":"iana"},"application/vnd.resilient.logic":{"source":"iana"},"application/vnd.restful+json":{"source":"iana","compressible":true},"application/vnd.rig.cryptonote":{"source":"iana","extensions":["cryptonote"]},"application/vnd.rim.cod":{"source":"apache","extensions":["cod"]},"application/vnd.rn-realmedia":{"source":"apache","extensions":["rm"]},"application/vnd.rn-realmedia-vbr":{"source":"apache","extensions":["rmvb"]},"application/vnd.route66.link66+xml":{"source":"iana","compressible":true,"extensions":["link66"]},"application/vnd.rs-274x":{"source":"iana"},"application/vnd.ruckus.download":{"source":"iana"},"application/vnd.s3sms":{"source":"iana"},"application/vnd.sailingtracker.track":{"source":"iana","extensions":["st"]},"application/vnd.sar":{"source":"iana"},"application/vnd.sbm.cid":{"source":"iana"},"application/vnd.sbm.mid2":{"source":"iana"},"application/vnd.scribus":{"source":"iana"},"application/vnd.sealed.3df":{"source":"iana"},"application/vnd.sealed.csf":{"source":"iana"},"application/vnd.sealed.doc":{"source":"iana"},"application/vnd.sealed.eml":{"source":"iana"},"application/vnd.sealed.mht":{"source":"iana"},"application/vnd.sealed.net":{"source":"iana"},"application/vnd.sealed.ppt":{"source":"iana"},"application/vnd.sealed.tiff":{"source":"iana"},"application/vnd.sealed.xls":{"source":"iana"},"application/vnd.sealedmedia.softseal.html":{"source":"iana"},"application/vnd.sealedmedia.softseal.pdf":{"source":"iana"},"application/vnd.seemail":{"source":"iana","extensions":["see"]},"application/vnd.seis+json":{"source":"iana","compressible":true},"application/vnd.sema":{"source":"iana","extensions":["sema"]},"application/vnd.semd":{"source":"iana","extensions":["semd"]},"application/vnd.semf":{"source":"iana","extensions":["semf"]},"application/vnd.shade-save-file":{"source":"iana"},"application/vnd.shana.informed.formdata":{"source":"iana","extensions":["ifm"]},"application/vnd.shana.informed.formtemplate":{"source":"iana","extensions":["itp"]},"application/vnd.shana.informed.interchange":{"source":"iana","extensions":["iif"]},"application/vnd.shana.informed.package":{"source":"iana","extensions":["ipk"]},"application/vnd.shootproof+json":{"source":"iana","compressible":true},"application/vnd.shopkick+json":{"source":"iana","compressible":true},"application/vnd.shp":{"source":"iana"},"application/vnd.shx":{"source":"iana"},"application/vnd.sigrok.session":{"source":"iana"},"application/vnd.simtech-mindmapper":{"source":"iana","extensions":["twd","twds"]},"application/vnd.siren+json":{"source":"iana","compressible":true},"application/vnd.smaf":{"source":"iana","extensions":["mmf"]},"application/vnd.smart.notebook":{"source":"iana"},"application/vnd.smart.teacher":{"source":"iana","extensions":["teacher"]},"application/vnd.snesdev-page-table":{"source":"iana"},"application/vnd.software602.filler.form+xml":{"source":"iana","compressible":true,"extensions":["fo"]},"application/vnd.software602.filler.form-xml-zip":{"source":"iana"},"application/vnd.solent.sdkm+xml":{"source":"iana","compressible":true,"extensions":["sdkm","sdkd"]},"application/vnd.spotfire.dxp":{"source":"iana","extensions":["dxp"]},"application/vnd.spotfire.sfs":{"source":"iana","extensions":["sfs"]},"application/vnd.sqlite3":{"source":"iana"},"application/vnd.sss-cod":{"source":"iana"},"application/vnd.sss-dtf":{"source":"iana"},"application/vnd.sss-ntf":{"source":"iana"},"application/vnd.stardivision.calc":{"source":"apache","extensions":["sdc"]},"application/vnd.stardivision.draw":{"source":"apache","extensions":["sda"]},"application/vnd.stardivision.impress":{"source":"apache","extensions":["sdd"]},"application/vnd.stardivision.math":{"source":"apache","extensions":["smf"]},"application/vnd.stardivision.writer":{"source":"apache","extensions":["sdw","vor"]},"application/vnd.stardivision.writer-global":{"source":"apache","extensions":["sgl"]},"application/vnd.stepmania.package":{"source":"iana","extensions":["smzip"]},"application/vnd.stepmania.stepchart":{"source":"iana","extensions":["sm"]},"application/vnd.street-stream":{"source":"iana"},"application/vnd.sun.wadl+xml":{"source":"iana","compressible":true,"extensions":["wadl"]},"application/vnd.sun.xml.calc":{"source":"apache","extensions":["sxc"]},"application/vnd.sun.xml.calc.template":{"source":"apache","extensions":["stc"]},"application/vnd.sun.xml.draw":{"source":"apache","extensions":["sxd"]},"application/vnd.sun.xml.draw.template":{"source":"apache","extensions":["std"]},"application/vnd.sun.xml.impress":{"source":"apache","extensions":["sxi"]},"application/vnd.sun.xml.impress.template":{"source":"apache","extensions":["sti"]},"application/vnd.sun.xml.math":{"source":"apache","extensions":["sxm"]},"application/vnd.sun.xml.writer":{"source":"apache","extensions":["sxw"]},"application/vnd.sun.xml.writer.global":{"source":"apache","extensions":["sxg"]},"application/vnd.sun.xml.writer.template":{"source":"apache","extensions":["stw"]},"application/vnd.sus-calendar":{"source":"iana","extensions":["sus","susp"]},"application/vnd.svd":{"source":"iana","extensions":["svd"]},"application/vnd.swiftview-ics":{"source":"iana"},"application/vnd.sycle+xml":{"source":"iana","compressible":true},"application/vnd.syft+json":{"source":"iana","compressible":true},"application/vnd.symbian.install":{"source":"apache","extensions":["sis","sisx"]},"application/vnd.syncml+xml":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["xsm"]},"application/vnd.syncml.dm+wbxml":{"source":"iana","charset":"UTF-8","extensions":["bdm"]},"application/vnd.syncml.dm+xml":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["xdm"]},"application/vnd.syncml.dm.notification":{"source":"iana"},"application/vnd.syncml.dmddf+wbxml":{"source":"iana"},"application/vnd.syncml.dmddf+xml":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["ddf"]},"application/vnd.syncml.dmtnds+wbxml":{"source":"iana"},"application/vnd.syncml.dmtnds+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/vnd.syncml.ds.notification":{"source":"iana"},"application/vnd.tableschema+json":{"source":"iana","compressible":true},"application/vnd.tao.intent-module-archive":{"source":"iana","extensions":["tao"]},"application/vnd.tcpdump.pcap":{"source":"iana","extensions":["pcap","cap","dmp"]},"application/vnd.think-cell.ppttc+json":{"source":"iana","compressible":true},"application/vnd.tmd.mediaflex.api+xml":{"source":"iana","compressible":true},"application/vnd.tml":{"source":"iana"},"application/vnd.tmobile-livetv":{"source":"iana","extensions":["tmo"]},"application/vnd.tri.onesource":{"source":"iana"},"application/vnd.trid.tpt":{"source":"iana","extensions":["tpt"]},"application/vnd.triscape.mxs":{"source":"iana","extensions":["mxs"]},"application/vnd.trueapp":{"source":"iana","extensions":["tra"]},"application/vnd.truedoc":{"source":"iana"},"application/vnd.ubisoft.webplayer":{"source":"iana"},"application/vnd.ufdl":{"source":"iana","extensions":["ufd","ufdl"]},"application/vnd.uiq.theme":{"source":"iana","extensions":["utz"]},"application/vnd.umajin":{"source":"iana","extensions":["umj"]},"application/vnd.unity":{"source":"iana","extensions":["unityweb"]},"application/vnd.uoml+xml":{"source":"iana","compressible":true,"extensions":["uoml"]},"application/vnd.uplanet.alert":{"source":"iana"},"application/vnd.uplanet.alert-wbxml":{"source":"iana"},"application/vnd.uplanet.bearer-choice":{"source":"iana"},"application/vnd.uplanet.bearer-choice-wbxml":{"source":"iana"},"application/vnd.uplanet.cacheop":{"source":"iana"},"application/vnd.uplanet.cacheop-wbxml":{"source":"iana"},"application/vnd.uplanet.channel":{"source":"iana"},"application/vnd.uplanet.channel-wbxml":{"source":"iana"},"application/vnd.uplanet.list":{"source":"iana"},"application/vnd.uplanet.list-wbxml":{"source":"iana"},"application/vnd.uplanet.listcmd":{"source":"iana"},"application/vnd.uplanet.listcmd-wbxml":{"source":"iana"},"application/vnd.uplanet.signal":{"source":"iana"},"application/vnd.uri-map":{"source":"iana"},"application/vnd.valve.source.material":{"source":"iana"},"application/vnd.vcx":{"source":"iana","extensions":["vcx"]},"application/vnd.vd-study":{"source":"iana"},"application/vnd.vectorworks":{"source":"iana"},"application/vnd.vel+json":{"source":"iana","compressible":true},"application/vnd.verimatrix.vcas":{"source":"iana"},"application/vnd.veritone.aion+json":{"source":"iana","compressible":true},"application/vnd.veryant.thin":{"source":"iana"},"application/vnd.ves.encrypted":{"source":"iana"},"application/vnd.vidsoft.vidconference":{"source":"iana"},"application/vnd.visio":{"source":"iana","extensions":["vsd","vst","vss","vsw"]},"application/vnd.visionary":{"source":"iana","extensions":["vis"]},"application/vnd.vividence.scriptfile":{"source":"iana"},"application/vnd.vsf":{"source":"iana","extensions":["vsf"]},"application/vnd.wap.sic":{"source":"iana"},"application/vnd.wap.slc":{"source":"iana"},"application/vnd.wap.wbxml":{"source":"iana","charset":"UTF-8","extensions":["wbxml"]},"application/vnd.wap.wmlc":{"source":"iana","extensions":["wmlc"]},"application/vnd.wap.wmlscriptc":{"source":"iana","extensions":["wmlsc"]},"application/vnd.webturbo":{"source":"iana","extensions":["wtb"]},"application/vnd.wfa.dpp":{"source":"iana"},"application/vnd.wfa.p2p":{"source":"iana"},"application/vnd.wfa.wsc":{"source":"iana"},"application/vnd.windows.devicepairing":{"source":"iana"},"application/vnd.wmc":{"source":"iana"},"application/vnd.wmf.bootstrap":{"source":"iana"},"application/vnd.wolfram.mathematica":{"source":"iana"},"application/vnd.wolfram.mathematica.package":{"source":"iana"},"application/vnd.wolfram.player":{"source":"iana","extensions":["nbp"]},"application/vnd.wordperfect":{"source":"iana","extensions":["wpd"]},"application/vnd.wqd":{"source":"iana","extensions":["wqd"]},"application/vnd.wrq-hp3000-labelled":{"source":"iana"},"application/vnd.wt.stf":{"source":"iana","extensions":["stf"]},"application/vnd.wv.csp+wbxml":{"source":"iana"},"application/vnd.wv.csp+xml":{"source":"iana","compressible":true},"application/vnd.wv.ssp+xml":{"source":"iana","compressible":true},"application/vnd.xacml+json":{"source":"iana","compressible":true},"application/vnd.xara":{"source":"iana","extensions":["xar"]},"application/vnd.xfdl":{"source":"iana","extensions":["xfdl"]},"application/vnd.xfdl.webform":{"source":"iana"},"application/vnd.xmi+xml":{"source":"iana","compressible":true},"application/vnd.xmpie.cpkg":{"source":"iana"},"application/vnd.xmpie.dpkg":{"source":"iana"},"application/vnd.xmpie.plan":{"source":"iana"},"application/vnd.xmpie.ppkg":{"source":"iana"},"application/vnd.xmpie.xlim":{"source":"iana"},"application/vnd.yamaha.hv-dic":{"source":"iana","extensions":["hvd"]},"application/vnd.yamaha.hv-script":{"source":"iana","extensions":["hvs"]},"application/vnd.yamaha.hv-voice":{"source":"iana","extensions":["hvp"]},"application/vnd.yamaha.openscoreformat":{"source":"iana","extensions":["osf"]},"application/vnd.yamaha.openscoreformat.osfpvg+xml":{"source":"iana","compressible":true,"extensions":["osfpvg"]},"application/vnd.yamaha.remote-setup":{"source":"iana"},"application/vnd.yamaha.smaf-audio":{"source":"iana","extensions":["saf"]},"application/vnd.yamaha.smaf-phrase":{"source":"iana","extensions":["spf"]},"application/vnd.yamaha.through-ngn":{"source":"iana"},"application/vnd.yamaha.tunnel-udpencap":{"source":"iana"},"application/vnd.yaoweme":{"source":"iana"},"application/vnd.yellowriver-custom-menu":{"source":"iana","extensions":["cmp"]},"application/vnd.youtube.yt":{"source":"iana"},"application/vnd.zul":{"source":"iana","extensions":["zir","zirz"]},"application/vnd.zzazz.deck+xml":{"source":"iana","compressible":true,"extensions":["zaz"]},"application/voicexml+xml":{"source":"iana","compressible":true,"extensions":["vxml"]},"application/voucher-cms+json":{"source":"iana","compressible":true},"application/vq-rtcpxr":{"source":"iana"},"application/wasm":{"source":"iana","compressible":true,"extensions":["wasm"]},"application/watcherinfo+xml":{"source":"iana","compressible":true,"extensions":["wif"]},"application/webpush-options+json":{"source":"iana","compressible":true},"application/whoispp-query":{"source":"iana"},"application/whoispp-response":{"source":"iana"},"application/widget":{"source":"iana","extensions":["wgt"]},"application/winhlp":{"source":"apache","extensions":["hlp"]},"application/wita":{"source":"iana"},"application/wordperfect5.1":{"source":"iana"},"application/wsdl+xml":{"source":"iana","compressible":true,"extensions":["wsdl"]},"application/wspolicy+xml":{"source":"iana","compressible":true,"extensions":["wspolicy"]},"application/x-7z-compressed":{"source":"apache","compressible":false,"extensions":["7z"]},"application/x-abiword":{"source":"apache","extensions":["abw"]},"application/x-ace-compressed":{"source":"apache","extensions":["ace"]},"application/x-amf":{"source":"apache"},"application/x-apple-diskimage":{"source":"apache","extensions":["dmg"]},"application/x-arj":{"compressible":false,"extensions":["arj"]},"application/x-authorware-bin":{"source":"apache","extensions":["aab","x32","u32","vox"]},"application/x-authorware-map":{"source":"apache","extensions":["aam"]},"application/x-authorware-seg":{"source":"apache","extensions":["aas"]},"application/x-bcpio":{"source":"apache","extensions":["bcpio"]},"application/x-bdoc":{"compressible":false,"extensions":["bdoc"]},"application/x-bittorrent":{"source":"apache","extensions":["torrent"]},"application/x-blorb":{"source":"apache","extensions":["blb","blorb"]},"application/x-bzip":{"source":"apache","compressible":false,"extensions":["bz"]},"application/x-bzip2":{"source":"apache","compressible":false,"extensions":["bz2","boz"]},"application/x-cbr":{"source":"apache","extensions":["cbr","cba","cbt","cbz","cb7"]},"application/x-cdlink":{"source":"apache","extensions":["vcd"]},"application/x-cfs-compressed":{"source":"apache","extensions":["cfs"]},"application/x-chat":{"source":"apache","extensions":["chat"]},"application/x-chess-pgn":{"source":"apache","extensions":["pgn"]},"application/x-chrome-extension":{"extensions":["crx"]},"application/x-cocoa":{"source":"nginx","extensions":["cco"]},"application/x-compress":{"source":"apache"},"application/x-conference":{"source":"apache","extensions":["nsc"]},"application/x-cpio":{"source":"apache","extensions":["cpio"]},"application/x-csh":{"source":"apache","extensions":["csh"]},"application/x-deb":{"compressible":false},"application/x-debian-package":{"source":"apache","extensions":["deb","udeb"]},"application/x-dgc-compressed":{"source":"apache","extensions":["dgc"]},"application/x-director":{"source":"apache","extensions":["dir","dcr","dxr","cst","cct","cxt","w3d","fgd","swa"]},"application/x-doom":{"source":"apache","extensions":["wad"]},"application/x-dtbncx+xml":{"source":"apache","compressible":true,"extensions":["ncx"]},"application/x-dtbook+xml":{"source":"apache","compressible":true,"extensions":["dtb"]},"application/x-dtbresource+xml":{"source":"apache","compressible":true,"extensions":["res"]},"application/x-dvi":{"source":"apache","compressible":false,"extensions":["dvi"]},"application/x-envoy":{"source":"apache","extensions":["evy"]},"application/x-eva":{"source":"apache","extensions":["eva"]},"application/x-font-bdf":{"source":"apache","extensions":["bdf"]},"application/x-font-dos":{"source":"apache"},"application/x-font-framemaker":{"source":"apache"},"application/x-font-ghostscript":{"source":"apache","extensions":["gsf"]},"application/x-font-libgrx":{"source":"apache"},"application/x-font-linux-psf":{"source":"apache","extensions":["psf"]},"application/x-font-pcf":{"source":"apache","extensions":["pcf"]},"application/x-font-snf":{"source":"apache","extensions":["snf"]},"application/x-font-speedo":{"source":"apache"},"application/x-font-sunos-news":{"source":"apache"},"application/x-font-type1":{"source":"apache","extensions":["pfa","pfb","pfm","afm"]},"application/x-font-vfont":{"source":"apache"},"application/x-freearc":{"source":"apache","extensions":["arc"]},"application/x-futuresplash":{"source":"apache","extensions":["spl"]},"application/x-gca-compressed":{"source":"apache","extensions":["gca"]},"application/x-glulx":{"source":"apache","extensions":["ulx"]},"application/x-gnumeric":{"source":"apache","extensions":["gnumeric"]},"application/x-gramps-xml":{"source":"apache","extensions":["gramps"]},"application/x-gtar":{"source":"apache","extensions":["gtar"]},"application/x-gzip":{"source":"apache"},"application/x-hdf":{"source":"apache","extensions":["hdf"]},"application/x-httpd-php":{"compressible":true,"extensions":["php"]},"application/x-install-instructions":{"source":"apache","extensions":["install"]},"application/x-iso9660-image":{"source":"apache","extensions":["iso"]},"application/x-iwork-keynote-sffkey":{"extensions":["key"]},"application/x-iwork-numbers-sffnumbers":{"extensions":["numbers"]},"application/x-iwork-pages-sffpages":{"extensions":["pages"]},"application/x-java-archive-diff":{"source":"nginx","extensions":["jardiff"]},"application/x-java-jnlp-file":{"source":"apache","compressible":false,"extensions":["jnlp"]},"application/x-javascript":{"compressible":true},"application/x-keepass2":{"extensions":["kdbx"]},"application/x-latex":{"source":"apache","compressible":false,"extensions":["latex"]},"application/x-lua-bytecode":{"extensions":["luac"]},"application/x-lzh-compressed":{"source":"apache","extensions":["lzh","lha"]},"application/x-makeself":{"source":"nginx","extensions":["run"]},"application/x-mie":{"source":"apache","extensions":["mie"]},"application/x-mobipocket-ebook":{"source":"apache","extensions":["prc","mobi"]},"application/x-mpegurl":{"compressible":false},"application/x-ms-application":{"source":"apache","extensions":["application"]},"application/x-ms-shortcut":{"source":"apache","extensions":["lnk"]},"application/x-ms-wmd":{"source":"apache","extensions":["wmd"]},"application/x-ms-wmz":{"source":"apache","extensions":["wmz"]},"application/x-ms-xbap":{"source":"apache","extensions":["xbap"]},"application/x-msaccess":{"source":"apache","extensions":["mdb"]},"application/x-msbinder":{"source":"apache","extensions":["obd"]},"application/x-mscardfile":{"source":"apache","extensions":["crd"]},"application/x-msclip":{"source":"apache","extensions":["clp"]},"application/x-msdos-program":{"extensions":["exe"]},"application/x-msdownload":{"source":"apache","extensions":["exe","dll","com","bat","msi"]},"application/x-msmediaview":{"source":"apache","extensions":["mvb","m13","m14"]},"application/x-msmetafile":{"source":"apache","extensions":["wmf","wmz","emf","emz"]},"application/x-msmoney":{"source":"apache","extensions":["mny"]},"application/x-mspublisher":{"source":"apache","extensions":["pub"]},"application/x-msschedule":{"source":"apache","extensions":["scd"]},"application/x-msterminal":{"source":"apache","extensions":["trm"]},"application/x-mswrite":{"source":"apache","extensions":["wri"]},"application/x-netcdf":{"source":"apache","extensions":["nc","cdf"]},"application/x-ns-proxy-autoconfig":{"compressible":true,"extensions":["pac"]},"application/x-nzb":{"source":"apache","extensions":["nzb"]},"application/x-perl":{"source":"nginx","extensions":["pl","pm"]},"application/x-pilot":{"source":"nginx","extensions":["prc","pdb"]},"application/x-pkcs12":{"source":"apache","compressible":false,"extensions":["p12","pfx"]},"application/x-pkcs7-certificates":{"source":"apache","extensions":["p7b","spc"]},"application/x-pkcs7-certreqresp":{"source":"apache","extensions":["p7r"]},"application/x-pki-message":{"source":"iana"},"application/x-rar-compressed":{"source":"apache","compressible":false,"extensions":["rar"]},"application/x-redhat-package-manager":{"source":"nginx","extensions":["rpm"]},"application/x-research-info-systems":{"source":"apache","extensions":["ris"]},"application/x-sea":{"source":"nginx","extensions":["sea"]},"application/x-sh":{"source":"apache","compressible":true,"extensions":["sh"]},"application/x-shar":{"source":"apache","extensions":["shar"]},"application/x-shockwave-flash":{"source":"apache","compressible":false,"extensions":["swf"]},"application/x-silverlight-app":{"source":"apache","extensions":["xap"]},"application/x-sql":{"source":"apache","extensions":["sql"]},"application/x-stuffit":{"source":"apache","compressible":false,"extensions":["sit"]},"application/x-stuffitx":{"source":"apache","extensions":["sitx"]},"application/x-subrip":{"source":"apache","extensions":["srt"]},"application/x-sv4cpio":{"source":"apache","extensions":["sv4cpio"]},"application/x-sv4crc":{"source":"apache","extensions":["sv4crc"]},"application/x-t3vm-image":{"source":"apache","extensions":["t3"]},"application/x-tads":{"source":"apache","extensions":["gam"]},"application/x-tar":{"source":"apache","compressible":true,"extensions":["tar"]},"application/x-tcl":{"source":"apache","extensions":["tcl","tk"]},"application/x-tex":{"source":"apache","extensions":["tex"]},"application/x-tex-tfm":{"source":"apache","extensions":["tfm"]},"application/x-texinfo":{"source":"apache","extensions":["texinfo","texi"]},"application/x-tgif":{"source":"apache","extensions":["obj"]},"application/x-ustar":{"source":"apache","extensions":["ustar"]},"application/x-virtualbox-hdd":{"compressible":true,"extensions":["hdd"]},"application/x-virtualbox-ova":{"compressible":true,"extensions":["ova"]},"application/x-virtualbox-ovf":{"compressible":true,"extensions":["ovf"]},"application/x-virtualbox-vbox":{"compressible":true,"extensions":["vbox"]},"application/x-virtualbox-vbox-extpack":{"compressible":false,"extensions":["vbox-extpack"]},"application/x-virtualbox-vdi":{"compressible":true,"extensions":["vdi"]},"application/x-virtualbox-vhd":{"compressible":true,"extensions":["vhd"]},"application/x-virtualbox-vmdk":{"compressible":true,"extensions":["vmdk"]},"application/x-wais-source":{"source":"apache","extensions":["src"]},"application/x-web-app-manifest+json":{"compressible":true,"extensions":["webapp"]},"application/x-www-form-urlencoded":{"source":"iana","compressible":true},"application/x-x509-ca-cert":{"source":"iana","extensions":["der","crt","pem"]},"application/x-x509-ca-ra-cert":{"source":"iana"},"application/x-x509-next-ca-cert":{"source":"iana"},"application/x-xfig":{"source":"apache","extensions":["fig"]},"application/x-xliff+xml":{"source":"apache","compressible":true,"extensions":["xlf"]},"application/x-xpinstall":{"source":"apache","compressible":false,"extensions":["xpi"]},"application/x-xz":{"source":"apache","extensions":["xz"]},"application/x-zmachine":{"source":"apache","extensions":["z1","z2","z3","z4","z5","z6","z7","z8"]},"application/x400-bp":{"source":"iana"},"application/xacml+xml":{"source":"iana","compressible":true},"application/xaml+xml":{"source":"apache","compressible":true,"extensions":["xaml"]},"application/xcap-att+xml":{"source":"iana","compressible":true,"extensions":["xav"]},"application/xcap-caps+xml":{"source":"iana","compressible":true,"extensions":["xca"]},"application/xcap-diff+xml":{"source":"iana","compressible":true,"extensions":["xdf"]},"application/xcap-el+xml":{"source":"iana","compressible":true,"extensions":["xel"]},"application/xcap-error+xml":{"source":"iana","compressible":true},"application/xcap-ns+xml":{"source":"iana","compressible":true,"extensions":["xns"]},"application/xcon-conference-info+xml":{"source":"iana","compressible":true},"application/xcon-conference-info-diff+xml":{"source":"iana","compressible":true},"application/xenc+xml":{"source":"iana","compressible":true,"extensions":["xenc"]},"application/xhtml+xml":{"source":"iana","compressible":true,"extensions":["xhtml","xht"]},"application/xhtml-voice+xml":{"source":"apache","compressible":true},"application/xliff+xml":{"source":"iana","compressible":true,"extensions":["xlf"]},"application/xml":{"source":"iana","compressible":true,"extensions":["xml","xsl","xsd","rng"]},"application/xml-dtd":{"source":"iana","compressible":true,"extensions":["dtd"]},"application/xml-external-parsed-entity":{"source":"iana"},"application/xml-patch+xml":{"source":"iana","compressible":true},"application/xmpp+xml":{"source":"iana","compressible":true},"application/xop+xml":{"source":"iana","compressible":true,"extensions":["xop"]},"application/xproc+xml":{"source":"apache","compressible":true,"extensions":["xpl"]},"application/xslt+xml":{"source":"iana","compressible":true,"extensions":["xsl","xslt"]},"application/xspf+xml":{"source":"apache","compressible":true,"extensions":["xspf"]},"application/xv+xml":{"source":"iana","compressible":true,"extensions":["mxml","xhvml","xvml","xvm"]},"application/yang":{"source":"iana","extensions":["yang"]},"application/yang-data+json":{"source":"iana","compressible":true},"application/yang-data+xml":{"source":"iana","compressible":true},"application/yang-patch+json":{"source":"iana","compressible":true},"application/yang-patch+xml":{"source":"iana","compressible":true},"application/yin+xml":{"source":"iana","compressible":true,"extensions":["yin"]},"application/zip":{"source":"iana","compressible":false,"extensions":["zip"]},"application/zlib":{"source":"iana"},"application/zstd":{"source":"iana"},"audio/1d-interleaved-parityfec":{"source":"iana"},"audio/32kadpcm":{"source":"iana"},"audio/3gpp":{"source":"iana","compressible":false,"extensions":["3gpp"]},"audio/3gpp2":{"source":"iana"},"audio/aac":{"source":"iana"},"audio/ac3":{"source":"iana"},"audio/adpcm":{"source":"apache","extensions":["adp"]},"audio/amr":{"source":"iana","extensions":["amr"]},"audio/amr-wb":{"source":"iana"},"audio/amr-wb+":{"source":"iana"},"audio/aptx":{"source":"iana"},"audio/asc":{"source":"iana"},"audio/atrac-advanced-lossless":{"source":"iana"},"audio/atrac-x":{"source":"iana"},"audio/atrac3":{"source":"iana"},"audio/basic":{"source":"iana","compressible":false,"extensions":["au","snd"]},"audio/bv16":{"source":"iana"},"audio/bv32":{"source":"iana"},"audio/clearmode":{"source":"iana"},"audio/cn":{"source":"iana"},"audio/dat12":{"source":"iana"},"audio/dls":{"source":"iana"},"audio/dsr-es201108":{"source":"iana"},"audio/dsr-es202050":{"source":"iana"},"audio/dsr-es202211":{"source":"iana"},"audio/dsr-es202212":{"source":"iana"},"audio/dv":{"source":"iana"},"audio/dvi4":{"source":"iana"},"audio/eac3":{"source":"iana"},"audio/encaprtp":{"source":"iana"},"audio/evrc":{"source":"iana"},"audio/evrc-qcp":{"source":"iana"},"audio/evrc0":{"source":"iana"},"audio/evrc1":{"source":"iana"},"audio/evrcb":{"source":"iana"},"audio/evrcb0":{"source":"iana"},"audio/evrcb1":{"source":"iana"},"audio/evrcnw":{"source":"iana"},"audio/evrcnw0":{"source":"iana"},"audio/evrcnw1":{"source":"iana"},"audio/evrcwb":{"source":"iana"},"audio/evrcwb0":{"source":"iana"},"audio/evrcwb1":{"source":"iana"},"audio/evs":{"source":"iana"},"audio/flexfec":{"source":"iana"},"audio/fwdred":{"source":"iana"},"audio/g711-0":{"source":"iana"},"audio/g719":{"source":"iana"},"audio/g722":{"source":"iana"},"audio/g7221":{"source":"iana"},"audio/g723":{"source":"iana"},"audio/g726-16":{"source":"iana"},"audio/g726-24":{"source":"iana"},"audio/g726-32":{"source":"iana"},"audio/g726-40":{"source":"iana"},"audio/g728":{"source":"iana"},"audio/g729":{"source":"iana"},"audio/g7291":{"source":"iana"},"audio/g729d":{"source":"iana"},"audio/g729e":{"source":"iana"},"audio/gsm":{"source":"iana"},"audio/gsm-efr":{"source":"iana"},"audio/gsm-hr-08":{"source":"iana"},"audio/ilbc":{"source":"iana"},"audio/ip-mr_v2.5":{"source":"iana"},"audio/isac":{"source":"apache"},"audio/l16":{"source":"iana"},"audio/l20":{"source":"iana"},"audio/l24":{"source":"iana","compressible":false},"audio/l8":{"source":"iana"},"audio/lpc":{"source":"iana"},"audio/melp":{"source":"iana"},"audio/melp1200":{"source":"iana"},"audio/melp2400":{"source":"iana"},"audio/melp600":{"source":"iana"},"audio/mhas":{"source":"iana"},"audio/midi":{"source":"apache","extensions":["mid","midi","kar","rmi"]},"audio/mobile-xmf":{"source":"iana","extensions":["mxmf"]},"audio/mp3":{"compressible":false,"extensions":["mp3"]},"audio/mp4":{"source":"iana","compressible":false,"extensions":["m4a","mp4a"]},"audio/mp4a-latm":{"source":"iana"},"audio/mpa":{"source":"iana"},"audio/mpa-robust":{"source":"iana"},"audio/mpeg":{"source":"iana","compressible":false,"extensions":["mpga","mp2","mp2a","mp3","m2a","m3a"]},"audio/mpeg4-generic":{"source":"iana"},"audio/musepack":{"source":"apache"},"audio/ogg":{"source":"iana","compressible":false,"extensions":["oga","ogg","spx","opus"]},"audio/opus":{"source":"iana"},"audio/parityfec":{"source":"iana"},"audio/pcma":{"source":"iana"},"audio/pcma-wb":{"source":"iana"},"audio/pcmu":{"source":"iana"},"audio/pcmu-wb":{"source":"iana"},"audio/prs.sid":{"source":"iana"},"audio/qcelp":{"source":"iana"},"audio/raptorfec":{"source":"iana"},"audio/red":{"source":"iana"},"audio/rtp-enc-aescm128":{"source":"iana"},"audio/rtp-midi":{"source":"iana"},"audio/rtploopback":{"source":"iana"},"audio/rtx":{"source":"iana"},"audio/s3m":{"source":"apache","extensions":["s3m"]},"audio/scip":{"source":"iana"},"audio/silk":{"source":"apache","extensions":["sil"]},"audio/smv":{"source":"iana"},"audio/smv-qcp":{"source":"iana"},"audio/smv0":{"source":"iana"},"audio/sofa":{"source":"iana"},"audio/sp-midi":{"source":"iana"},"audio/speex":{"source":"iana"},"audio/t140c":{"source":"iana"},"audio/t38":{"source":"iana"},"audio/telephone-event":{"source":"iana"},"audio/tetra_acelp":{"source":"iana"},"audio/tetra_acelp_bb":{"source":"iana"},"audio/tone":{"source":"iana"},"audio/tsvcis":{"source":"iana"},"audio/uemclip":{"source":"iana"},"audio/ulpfec":{"source":"iana"},"audio/usac":{"source":"iana"},"audio/vdvi":{"source":"iana"},"audio/vmr-wb":{"source":"iana"},"audio/vnd.3gpp.iufp":{"source":"iana"},"audio/vnd.4sb":{"source":"iana"},"audio/vnd.audiokoz":{"source":"iana"},"audio/vnd.celp":{"source":"iana"},"audio/vnd.cisco.nse":{"source":"iana"},"audio/vnd.cmles.radio-events":{"source":"iana"},"audio/vnd.cns.anp1":{"source":"iana"},"audio/vnd.cns.inf1":{"source":"iana"},"audio/vnd.dece.audio":{"source":"iana","extensions":["uva","uvva"]},"audio/vnd.digital-winds":{"source":"iana","extensions":["eol"]},"audio/vnd.dlna.adts":{"source":"iana"},"audio/vnd.dolby.heaac.1":{"source":"iana"},"audio/vnd.dolby.heaac.2":{"source":"iana"},"audio/vnd.dolby.mlp":{"source":"iana"},"audio/vnd.dolby.mps":{"source":"iana"},"audio/vnd.dolby.pl2":{"source":"iana"},"audio/vnd.dolby.pl2x":{"source":"iana"},"audio/vnd.dolby.pl2z":{"source":"iana"},"audio/vnd.dolby.pulse.1":{"source":"iana"},"audio/vnd.dra":{"source":"iana","extensions":["dra"]},"audio/vnd.dts":{"source":"iana","extensions":["dts"]},"audio/vnd.dts.hd":{"source":"iana","extensions":["dtshd"]},"audio/vnd.dts.uhd":{"source":"iana"},"audio/vnd.dvb.file":{"source":"iana"},"audio/vnd.everad.plj":{"source":"iana"},"audio/vnd.hns.audio":{"source":"iana"},"audio/vnd.lucent.voice":{"source":"iana","extensions":["lvp"]},"audio/vnd.ms-playready.media.pya":{"source":"iana","extensions":["pya"]},"audio/vnd.nokia.mobile-xmf":{"source":"iana"},"audio/vnd.nortel.vbk":{"source":"iana"},"audio/vnd.nuera.ecelp4800":{"source":"iana","extensions":["ecelp4800"]},"audio/vnd.nuera.ecelp7470":{"source":"iana","extensions":["ecelp7470"]},"audio/vnd.nuera.ecelp9600":{"source":"iana","extensions":["ecelp9600"]},"audio/vnd.octel.sbc":{"source":"iana"},"audio/vnd.presonus.multitrack":{"source":"iana"},"audio/vnd.qcelp":{"source":"iana"},"audio/vnd.rhetorex.32kadpcm":{"source":"iana"},"audio/vnd.rip":{"source":"iana","extensions":["rip"]},"audio/vnd.rn-realaudio":{"compressible":false},"audio/vnd.sealedmedia.softseal.mpeg":{"source":"iana"},"audio/vnd.vmx.cvsd":{"source":"iana"},"audio/vnd.wave":{"compressible":false},"audio/vorbis":{"source":"iana","compressible":false},"audio/vorbis-config":{"source":"iana"},"audio/wav":{"compressible":false,"extensions":["wav"]},"audio/wave":{"compressible":false,"extensions":["wav"]},"audio/webm":{"source":"apache","compressible":false,"extensions":["weba"]},"audio/x-aac":{"source":"apache","compressible":false,"extensions":["aac"]},"audio/x-aiff":{"source":"apache","extensions":["aif","aiff","aifc"]},"audio/x-caf":{"source":"apache","compressible":false,"extensions":["caf"]},"audio/x-flac":{"source":"apache","extensions":["flac"]},"audio/x-m4a":{"source":"nginx","extensions":["m4a"]},"audio/x-matroska":{"source":"apache","extensions":["mka"]},"audio/x-mpegurl":{"source":"apache","extensions":["m3u"]},"audio/x-ms-wax":{"source":"apache","extensions":["wax"]},"audio/x-ms-wma":{"source":"apache","extensions":["wma"]},"audio/x-pn-realaudio":{"source":"apache","extensions":["ram","ra"]},"audio/x-pn-realaudio-plugin":{"source":"apache","extensions":["rmp"]},"audio/x-realaudio":{"source":"nginx","extensions":["ra"]},"audio/x-tta":{"source":"apache"},"audio/x-wav":{"source":"apache","extensions":["wav"]},"audio/xm":{"source":"apache","extensions":["xm"]},"chemical/x-cdx":{"source":"apache","extensions":["cdx"]},"chemical/x-cif":{"source":"apache","extensions":["cif"]},"chemical/x-cmdf":{"source":"apache","extensions":["cmdf"]},"chemical/x-cml":{"source":"apache","extensions":["cml"]},"chemical/x-csml":{"source":"apache","extensions":["csml"]},"chemical/x-pdb":{"source":"apache"},"chemical/x-xyz":{"source":"apache","extensions":["xyz"]},"font/collection":{"source":"iana","extensions":["ttc"]},"font/otf":{"source":"iana","compressible":true,"extensions":["otf"]},"font/sfnt":{"source":"iana"},"font/ttf":{"source":"iana","compressible":true,"extensions":["ttf"]},"font/woff":{"source":"iana","extensions":["woff"]},"font/woff2":{"source":"iana","extensions":["woff2"]},"image/aces":{"source":"iana","extensions":["exr"]},"image/apng":{"compressible":false,"extensions":["apng"]},"image/avci":{"source":"iana","extensions":["avci"]},"image/avcs":{"source":"iana","extensions":["avcs"]},"image/avif":{"source":"iana","compressible":false,"extensions":["avif"]},"image/bmp":{"source":"iana","compressible":true,"extensions":["bmp"]},"image/cgm":{"source":"iana","extensions":["cgm"]},"image/dicom-rle":{"source":"iana","extensions":["drle"]},"image/emf":{"source":"iana","extensions":["emf"]},"image/fits":{"source":"iana","extensions":["fits"]},"image/g3fax":{"source":"iana","extensions":["g3"]},"image/gif":{"source":"iana","compressible":false,"extensions":["gif"]},"image/heic":{"source":"iana","extensions":["heic"]},"image/heic-sequence":{"source":"iana","extensions":["heics"]},"image/heif":{"source":"iana","extensions":["heif"]},"image/heif-sequence":{"source":"iana","extensions":["heifs"]},"image/hej2k":{"source":"iana","extensions":["hej2"]},"image/hsj2":{"source":"iana","extensions":["hsj2"]},"image/ief":{"source":"iana","extensions":["ief"]},"image/jls":{"source":"iana","extensions":["jls"]},"image/jp2":{"source":"iana","compressible":false,"extensions":["jp2","jpg2"]},"image/jpeg":{"source":"iana","compressible":false,"extensions":["jpeg","jpg","jpe"]},"image/jph":{"source":"iana","extensions":["jph"]},"image/jphc":{"source":"iana","extensions":["jhc"]},"image/jpm":{"source":"iana","compressible":false,"extensions":["jpm"]},"image/jpx":{"source":"iana","compressible":false,"extensions":["jpx","jpf"]},"image/jxr":{"source":"iana","extensions":["jxr"]},"image/jxra":{"source":"iana","extensions":["jxra"]},"image/jxrs":{"source":"iana","extensions":["jxrs"]},"image/jxs":{"source":"iana","extensions":["jxs"]},"image/jxsc":{"source":"iana","extensions":["jxsc"]},"image/jxsi":{"source":"iana","extensions":["jxsi"]},"image/jxss":{"source":"iana","extensions":["jxss"]},"image/ktx":{"source":"iana","extensions":["ktx"]},"image/ktx2":{"source":"iana","extensions":["ktx2"]},"image/naplps":{"source":"iana"},"image/pjpeg":{"compressible":false},"image/png":{"source":"iana","compressible":false,"extensions":["png"]},"image/prs.btif":{"source":"iana","extensions":["btif"]},"image/prs.pti":{"source":"iana","extensions":["pti"]},"image/pwg-raster":{"source":"iana"},"image/sgi":{"source":"apache","extensions":["sgi"]},"image/svg+xml":{"source":"iana","compressible":true,"extensions":["svg","svgz"]},"image/t38":{"source":"iana","extensions":["t38"]},"image/tiff":{"source":"iana","compressible":false,"extensions":["tif","tiff"]},"image/tiff-fx":{"source":"iana","extensions":["tfx"]},"image/vnd.adobe.photoshop":{"source":"iana","compressible":true,"extensions":["psd"]},"image/vnd.airzip.accelerator.azv":{"source":"iana","extensions":["azv"]},"image/vnd.cns.inf2":{"source":"iana"},"image/vnd.dece.graphic":{"source":"iana","extensions":["uvi","uvvi","uvg","uvvg"]},"image/vnd.djvu":{"source":"iana","extensions":["djvu","djv"]},"image/vnd.dvb.subtitle":{"source":"iana","extensions":["sub"]},"image/vnd.dwg":{"source":"iana","extensions":["dwg"]},"image/vnd.dxf":{"source":"iana","extensions":["dxf"]},"image/vnd.fastbidsheet":{"source":"iana","extensions":["fbs"]},"image/vnd.fpx":{"source":"iana","extensions":["fpx"]},"image/vnd.fst":{"source":"iana","extensions":["fst"]},"image/vnd.fujixerox.edmics-mmr":{"source":"iana","extensions":["mmr"]},"image/vnd.fujixerox.edmics-rlc":{"source":"iana","extensions":["rlc"]},"image/vnd.globalgraphics.pgb":{"source":"iana"},"image/vnd.microsoft.icon":{"source":"iana","compressible":true,"extensions":["ico"]},"image/vnd.mix":{"source":"iana"},"image/vnd.mozilla.apng":{"source":"iana"},"image/vnd.ms-dds":{"compressible":true,"extensions":["dds"]},"image/vnd.ms-modi":{"source":"iana","extensions":["mdi"]},"image/vnd.ms-photo":{"source":"apache","extensions":["wdp"]},"image/vnd.net-fpx":{"source":"iana","extensions":["npx"]},"image/vnd.pco.b16":{"source":"iana","extensions":["b16"]},"image/vnd.radiance":{"source":"iana"},"image/vnd.sealed.png":{"source":"iana"},"image/vnd.sealedmedia.softseal.gif":{"source":"iana"},"image/vnd.sealedmedia.softseal.jpg":{"source":"iana"},"image/vnd.svf":{"source":"iana"},"image/vnd.tencent.tap":{"source":"iana","extensions":["tap"]},"image/vnd.valve.source.texture":{"source":"iana","extensions":["vtf"]},"image/vnd.wap.wbmp":{"source":"iana","extensions":["wbmp"]},"image/vnd.xiff":{"source":"iana","extensions":["xif"]},"image/vnd.zbrush.pcx":{"source":"iana","extensions":["pcx"]},"image/webp":{"source":"apache","extensions":["webp"]},"image/wmf":{"source":"iana","extensions":["wmf"]},"image/x-3ds":{"source":"apache","extensions":["3ds"]},"image/x-cmu-raster":{"source":"apache","extensions":["ras"]},"image/x-cmx":{"source":"apache","extensions":["cmx"]},"image/x-freehand":{"source":"apache","extensions":["fh","fhc","fh4","fh5","fh7"]},"image/x-icon":{"source":"apache","compressible":true,"extensions":["ico"]},"image/x-jng":{"source":"nginx","extensions":["jng"]},"image/x-mrsid-image":{"source":"apache","extensions":["sid"]},"image/x-ms-bmp":{"source":"nginx","compressible":true,"extensions":["bmp"]},"image/x-pcx":{"source":"apache","extensions":["pcx"]},"image/x-pict":{"source":"apache","extensions":["pic","pct"]},"image/x-portable-anymap":{"source":"apache","extensions":["pnm"]},"image/x-portable-bitmap":{"source":"apache","extensions":["pbm"]},"image/x-portable-graymap":{"source":"apache","extensions":["pgm"]},"image/x-portable-pixmap":{"source":"apache","extensions":["ppm"]},"image/x-rgb":{"source":"apache","extensions":["rgb"]},"image/x-tga":{"source":"apache","extensions":["tga"]},"image/x-xbitmap":{"source":"apache","extensions":["xbm"]},"image/x-xcf":{"compressible":false},"image/x-xpixmap":{"source":"apache","extensions":["xpm"]},"image/x-xwindowdump":{"source":"apache","extensions":["xwd"]},"message/cpim":{"source":"iana"},"message/delivery-status":{"source":"iana"},"message/disposition-notification":{"source":"iana","extensions":["disposition-notification"]},"message/external-body":{"source":"iana"},"message/feedback-report":{"source":"iana"},"message/global":{"source":"iana","extensions":["u8msg"]},"message/global-delivery-status":{"source":"iana","extensions":["u8dsn"]},"message/global-disposition-notification":{"source":"iana","extensions":["u8mdn"]},"message/global-headers":{"source":"iana","extensions":["u8hdr"]},"message/http":{"source":"iana","compressible":false},"message/imdn+xml":{"source":"iana","compressible":true},"message/news":{"source":"iana"},"message/partial":{"source":"iana","compressible":false},"message/rfc822":{"source":"iana","compressible":true,"extensions":["eml","mime"]},"message/s-http":{"source":"iana"},"message/sip":{"source":"iana"},"message/sipfrag":{"source":"iana"},"message/tracking-status":{"source":"iana"},"message/vnd.si.simp":{"source":"iana"},"message/vnd.wfa.wsc":{"source":"iana","extensions":["wsc"]},"model/3mf":{"source":"iana","extensions":["3mf"]},"model/e57":{"source":"iana"},"model/gltf+json":{"source":"iana","compressible":true,"extensions":["gltf"]},"model/gltf-binary":{"source":"iana","compressible":true,"extensions":["glb"]},"model/iges":{"source":"iana","compressible":false,"extensions":["igs","iges"]},"model/mesh":{"source":"iana","compressible":false,"extensions":["msh","mesh","silo"]},"model/mtl":{"source":"iana","extensions":["mtl"]},"model/obj":{"source":"iana","extensions":["obj"]},"model/step":{"source":"iana"},"model/step+xml":{"source":"iana","compressible":true,"extensions":["stpx"]},"model/step+zip":{"source":"iana","compressible":false,"extensions":["stpz"]},"model/step-xml+zip":{"source":"iana","compressible":false,"extensions":["stpxz"]},"model/stl":{"source":"iana","extensions":["stl"]},"model/vnd.collada+xml":{"source":"iana","compressible":true,"extensions":["dae"]},"model/vnd.dwf":{"source":"iana","extensions":["dwf"]},"model/vnd.flatland.3dml":{"source":"iana"},"model/vnd.gdl":{"source":"iana","extensions":["gdl"]},"model/vnd.gs-gdl":{"source":"apache"},"model/vnd.gs.gdl":{"source":"iana"},"model/vnd.gtw":{"source":"iana","extensions":["gtw"]},"model/vnd.moml+xml":{"source":"iana","compressible":true},"model/vnd.mts":{"source":"iana","extensions":["mts"]},"model/vnd.opengex":{"source":"iana","extensions":["ogex"]},"model/vnd.parasolid.transmit.binary":{"source":"iana","extensions":["x_b"]},"model/vnd.parasolid.transmit.text":{"source":"iana","extensions":["x_t"]},"model/vnd.pytha.pyox":{"source":"iana"},"model/vnd.rosette.annotated-data-model":{"source":"iana"},"model/vnd.sap.vds":{"source":"iana","extensions":["vds"]},"model/vnd.usdz+zip":{"source":"iana","compressible":false,"extensions":["usdz"]},"model/vnd.valve.source.compiled-map":{"source":"iana","extensions":["bsp"]},"model/vnd.vtu":{"source":"iana","extensions":["vtu"]},"model/vrml":{"source":"iana","compressible":false,"extensions":["wrl","vrml"]},"model/x3d+binary":{"source":"apache","compressible":false,"extensions":["x3db","x3dbz"]},"model/x3d+fastinfoset":{"source":"iana","extensions":["x3db"]},"model/x3d+vrml":{"source":"apache","compressible":false,"extensions":["x3dv","x3dvz"]},"model/x3d+xml":{"source":"iana","compressible":true,"extensions":["x3d","x3dz"]},"model/x3d-vrml":{"source":"iana","extensions":["x3dv"]},"multipart/alternative":{"source":"iana","compressible":false},"multipart/appledouble":{"source":"iana"},"multipart/byteranges":{"source":"iana"},"multipart/digest":{"source":"iana"},"multipart/encrypted":{"source":"iana","compressible":false},"multipart/form-data":{"source":"iana","compressible":false},"multipart/header-set":{"source":"iana"},"multipart/mixed":{"source":"iana"},"multipart/multilingual":{"source":"iana"},"multipart/parallel":{"source":"iana"},"multipart/related":{"source":"iana","compressible":false},"multipart/report":{"source":"iana"},"multipart/signed":{"source":"iana","compressible":false},"multipart/vnd.bint.med-plus":{"source":"iana"},"multipart/voice-message":{"source":"iana"},"multipart/x-mixed-replace":{"source":"iana"},"text/1d-interleaved-parityfec":{"source":"iana"},"text/cache-manifest":{"source":"iana","compressible":true,"extensions":["appcache","manifest"]},"text/calendar":{"source":"iana","extensions":["ics","ifb"]},"text/calender":{"compressible":true},"text/cmd":{"compressible":true},"text/coffeescript":{"extensions":["coffee","litcoffee"]},"text/cql":{"source":"iana"},"text/cql-expression":{"source":"iana"},"text/cql-identifier":{"source":"iana"},"text/css":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["css"]},"text/csv":{"source":"iana","compressible":true,"extensions":["csv"]},"text/csv-schema":{"source":"iana"},"text/directory":{"source":"iana"},"text/dns":{"source":"iana"},"text/ecmascript":{"source":"iana"},"text/encaprtp":{"source":"iana"},"text/enriched":{"source":"iana"},"text/fhirpath":{"source":"iana"},"text/flexfec":{"source":"iana"},"text/fwdred":{"source":"iana"},"text/gff3":{"source":"iana"},"text/grammar-ref-list":{"source":"iana"},"text/html":{"source":"iana","compressible":true,"extensions":["html","htm","shtml"]},"text/jade":{"extensions":["jade"]},"text/javascript":{"source":"iana","compressible":true},"text/jcr-cnd":{"source":"iana"},"text/jsx":{"compressible":true,"extensions":["jsx"]},"text/less":{"compressible":true,"extensions":["less"]},"text/markdown":{"source":"iana","compressible":true,"extensions":["markdown","md"]},"text/mathml":{"source":"nginx","extensions":["mml"]},"text/mdx":{"compressible":true,"extensions":["mdx"]},"text/mizar":{"source":"iana"},"text/n3":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["n3"]},"text/parameters":{"source":"iana","charset":"UTF-8"},"text/parityfec":{"source":"iana"},"text/plain":{"source":"iana","compressible":true,"extensions":["txt","text","conf","def","list","log","in","ini"]},"text/provenance-notation":{"source":"iana","charset":"UTF-8"},"text/prs.fallenstein.rst":{"source":"iana"},"text/prs.lines.tag":{"source":"iana","extensions":["dsc"]},"text/prs.prop.logic":{"source":"iana"},"text/raptorfec":{"source":"iana"},"text/red":{"source":"iana"},"text/rfc822-headers":{"source":"iana"},"text/richtext":{"source":"iana","compressible":true,"extensions":["rtx"]},"text/rtf":{"source":"iana","compressible":true,"extensions":["rtf"]},"text/rtp-enc-aescm128":{"source":"iana"},"text/rtploopback":{"source":"iana"},"text/rtx":{"source":"iana"},"text/sgml":{"source":"iana","extensions":["sgml","sgm"]},"text/shaclc":{"source":"iana"},"text/shex":{"source":"iana","extensions":["shex"]},"text/slim":{"extensions":["slim","slm"]},"text/spdx":{"source":"iana","extensions":["spdx"]},"text/strings":{"source":"iana"},"text/stylus":{"extensions":["stylus","styl"]},"text/t140":{"source":"iana"},"text/tab-separated-values":{"source":"iana","compressible":true,"extensions":["tsv"]},"text/troff":{"source":"iana","extensions":["t","tr","roff","man","me","ms"]},"text/turtle":{"source":"iana","charset":"UTF-8","extensions":["ttl"]},"text/ulpfec":{"source":"iana"},"text/uri-list":{"source":"iana","compressible":true,"extensions":["uri","uris","urls"]},"text/vcard":{"source":"iana","compressible":true,"extensions":["vcard"]},"text/vnd.a":{"source":"iana"},"text/vnd.abc":{"source":"iana"},"text/vnd.ascii-art":{"source":"iana"},"text/vnd.curl":{"source":"iana","extensions":["curl"]},"text/vnd.curl.dcurl":{"source":"apache","extensions":["dcurl"]},"text/vnd.curl.mcurl":{"source":"apache","extensions":["mcurl"]},"text/vnd.curl.scurl":{"source":"apache","extensions":["scurl"]},"text/vnd.debian.copyright":{"source":"iana","charset":"UTF-8"},"text/vnd.dmclientscript":{"source":"iana"},"text/vnd.dvb.subtitle":{"source":"iana","extensions":["sub"]},"text/vnd.esmertec.theme-descriptor":{"source":"iana","charset":"UTF-8"},"text/vnd.familysearch.gedcom":{"source":"iana","extensions":["ged"]},"text/vnd.ficlab.flt":{"source":"iana"},"text/vnd.fly":{"source":"iana","extensions":["fly"]},"text/vnd.fmi.flexstor":{"source":"iana","extensions":["flx"]},"text/vnd.gml":{"source":"iana"},"text/vnd.graphviz":{"source":"iana","extensions":["gv"]},"text/vnd.hans":{"source":"iana"},"text/vnd.hgl":{"source":"iana"},"text/vnd.in3d.3dml":{"source":"iana","extensions":["3dml"]},"text/vnd.in3d.spot":{"source":"iana","extensions":["spot"]},"text/vnd.iptc.newsml":{"source":"iana"},"text/vnd.iptc.nitf":{"source":"iana"},"text/vnd.latex-z":{"source":"iana"},"text/vnd.motorola.reflex":{"source":"iana"},"text/vnd.ms-mediapackage":{"source":"iana"},"text/vnd.net2phone.commcenter.command":{"source":"iana"},"text/vnd.radisys.msml-basic-layout":{"source":"iana"},"text/vnd.senx.warpscript":{"source":"iana"},"text/vnd.si.uricatalogue":{"source":"iana"},"text/vnd.sosi":{"source":"iana"},"text/vnd.sun.j2me.app-descriptor":{"source":"iana","charset":"UTF-8","extensions":["jad"]},"text/vnd.trolltech.linguist":{"source":"iana","charset":"UTF-8"},"text/vnd.wap.si":{"source":"iana"},"text/vnd.wap.sl":{"source":"iana"},"text/vnd.wap.wml":{"source":"iana","extensions":["wml"]},"text/vnd.wap.wmlscript":{"source":"iana","extensions":["wmls"]},"text/vtt":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["vtt"]},"text/x-asm":{"source":"apache","extensions":["s","asm"]},"text/x-c":{"source":"apache","extensions":["c","cc","cxx","cpp","h","hh","dic"]},"text/x-component":{"source":"nginx","extensions":["htc"]},"text/x-fortran":{"source":"apache","extensions":["f","for","f77","f90"]},"text/x-gwt-rpc":{"compressible":true},"text/x-handlebars-template":{"extensions":["hbs"]},"text/x-java-source":{"source":"apache","extensions":["java"]},"text/x-jquery-tmpl":{"compressible":true},"text/x-lua":{"extensions":["lua"]},"text/x-markdown":{"compressible":true,"extensions":["mkd"]},"text/x-nfo":{"source":"apache","extensions":["nfo"]},"text/x-opml":{"source":"apache","extensions":["opml"]},"text/x-org":{"compressible":true,"extensions":["org"]},"text/x-pascal":{"source":"apache","extensions":["p","pas"]},"text/x-processing":{"compressible":true,"extensions":["pde"]},"text/x-sass":{"extensions":["sass"]},"text/x-scss":{"extensions":["scss"]},"text/x-setext":{"source":"apache","extensions":["etx"]},"text/x-sfv":{"source":"apache","extensions":["sfv"]},"text/x-suse-ymp":{"compressible":true,"extensions":["ymp"]},"text/x-uuencode":{"source":"apache","extensions":["uu"]},"text/x-vcalendar":{"source":"apache","extensions":["vcs"]},"text/x-vcard":{"source":"apache","extensions":["vcf"]},"text/xml":{"source":"iana","compressible":true,"extensions":["xml"]},"text/xml-external-parsed-entity":{"source":"iana"},"text/yaml":{"compressible":true,"extensions":["yaml","yml"]},"video/1d-interleaved-parityfec":{"source":"iana"},"video/3gpp":{"source":"iana","extensions":["3gp","3gpp"]},"video/3gpp-tt":{"source":"iana"},"video/3gpp2":{"source":"iana","extensions":["3g2"]},"video/av1":{"source":"iana"},"video/bmpeg":{"source":"iana"},"video/bt656":{"source":"iana"},"video/celb":{"source":"iana"},"video/dv":{"source":"iana"},"video/encaprtp":{"source":"iana"},"video/ffv1":{"source":"iana"},"video/flexfec":{"source":"iana"},"video/h261":{"source":"iana","extensions":["h261"]},"video/h263":{"source":"iana","extensions":["h263"]},"video/h263-1998":{"source":"iana"},"video/h263-2000":{"source":"iana"},"video/h264":{"source":"iana","extensions":["h264"]},"video/h264-rcdo":{"source":"iana"},"video/h264-svc":{"source":"iana"},"video/h265":{"source":"iana"},"video/iso.segment":{"source":"iana","extensions":["m4s"]},"video/jpeg":{"source":"iana","extensions":["jpgv"]},"video/jpeg2000":{"source":"iana"},"video/jpm":{"source":"apache","extensions":["jpm","jpgm"]},"video/jxsv":{"source":"iana"},"video/mj2":{"source":"iana","extensions":["mj2","mjp2"]},"video/mp1s":{"source":"iana"},"video/mp2p":{"source":"iana"},"video/mp2t":{"source":"iana","extensions":["ts"]},"video/mp4":{"source":"iana","compressible":false,"extensions":["mp4","mp4v","mpg4"]},"video/mp4v-es":{"source":"iana"},"video/mpeg":{"source":"iana","compressible":false,"extensions":["mpeg","mpg","mpe","m1v","m2v"]},"video/mpeg4-generic":{"source":"iana"},"video/mpv":{"source":"iana"},"video/nv":{"source":"iana"},"video/ogg":{"source":"iana","compressible":false,"extensions":["ogv"]},"video/parityfec":{"source":"iana"},"video/pointer":{"source":"iana"},"video/quicktime":{"source":"iana","compressible":false,"extensions":["qt","mov"]},"video/raptorfec":{"source":"iana"},"video/raw":{"source":"iana"},"video/rtp-enc-aescm128":{"source":"iana"},"video/rtploopback":{"source":"iana"},"video/rtx":{"source":"iana"},"video/scip":{"source":"iana"},"video/smpte291":{"source":"iana"},"video/smpte292m":{"source":"iana"},"video/ulpfec":{"source":"iana"},"video/vc1":{"source":"iana"},"video/vc2":{"source":"iana"},"video/vnd.cctv":{"source":"iana"},"video/vnd.dece.hd":{"source":"iana","extensions":["uvh","uvvh"]},"video/vnd.dece.mobile":{"source":"iana","extensions":["uvm","uvvm"]},"video/vnd.dece.mp4":{"source":"iana"},"video/vnd.dece.pd":{"source":"iana","extensions":["uvp","uvvp"]},"video/vnd.dece.sd":{"source":"iana","extensions":["uvs","uvvs"]},"video/vnd.dece.video":{"source":"iana","extensions":["uvv","uvvv"]},"video/vnd.directv.mpeg":{"source":"iana"},"video/vnd.directv.mpeg-tts":{"source":"iana"},"video/vnd.dlna.mpeg-tts":{"source":"iana"},"video/vnd.dvb.file":{"source":"iana","extensions":["dvb"]},"video/vnd.fvt":{"source":"iana","extensions":["fvt"]},"video/vnd.hns.video":{"source":"iana"},"video/vnd.iptvforum.1dparityfec-1010":{"source":"iana"},"video/vnd.iptvforum.1dparityfec-2005":{"source":"iana"},"video/vnd.iptvforum.2dparityfec-1010":{"source":"iana"},"video/vnd.iptvforum.2dparityfec-2005":{"source":"iana"},"video/vnd.iptvforum.ttsavc":{"source":"iana"},"video/vnd.iptvforum.ttsmpeg2":{"source":"iana"},"video/vnd.motorola.video":{"source":"iana"},"video/vnd.motorola.videop":{"source":"iana"},"video/vnd.mpegurl":{"source":"iana","extensions":["mxu","m4u"]},"video/vnd.ms-playready.media.pyv":{"source":"iana","extensions":["pyv"]},"video/vnd.nokia.interleaved-multimedia":{"source":"iana"},"video/vnd.nokia.mp4vr":{"source":"iana"},"video/vnd.nokia.videovoip":{"source":"iana"},"video/vnd.objectvideo":{"source":"iana"},"video/vnd.radgamettools.bink":{"source":"iana"},"video/vnd.radgamettools.smacker":{"source":"iana"},"video/vnd.sealed.mpeg1":{"source":"iana"},"video/vnd.sealed.mpeg4":{"source":"iana"},"video/vnd.sealed.swf":{"source":"iana"},"video/vnd.sealedmedia.softseal.mov":{"source":"iana"},"video/vnd.uvvu.mp4":{"source":"iana","extensions":["uvu","uvvu"]},"video/vnd.vivo":{"source":"iana","extensions":["viv"]},"video/vnd.youtube.yt":{"source":"iana"},"video/vp8":{"source":"iana"},"video/vp9":{"source":"iana"},"video/webm":{"source":"apache","compressible":false,"extensions":["webm"]},"video/x-f4v":{"source":"apache","extensions":["f4v"]},"video/x-fli":{"source":"apache","extensions":["fli"]},"video/x-flv":{"source":"apache","compressible":false,"extensions":["flv"]},"video/x-m4v":{"source":"apache","extensions":["m4v"]},"video/x-matroska":{"source":"apache","compressible":false,"extensions":["mkv","mk3d","mks"]},"video/x-mng":{"source":"apache","extensions":["mng"]},"video/x-ms-asf":{"source":"apache","extensions":["asf","asx"]},"video/x-ms-vob":{"source":"apache","extensions":["vob"]},"video/x-ms-wm":{"source":"apache","extensions":["wm"]},"video/x-ms-wmv":{"source":"apache","compressible":false,"extensions":["wmv"]},"video/x-ms-wmx":{"source":"apache","extensions":["wmx"]},"video/x-ms-wvx":{"source":"apache","extensions":["wvx"]},"video/x-msvideo":{"source":"apache","extensions":["avi"]},"video/x-sgi-movie":{"source":"apache","extensions":["movie"]},"video/x-smv":{"source":"apache","extensions":["smv"]},"x-conference/x-cooltalk":{"source":"apache","extensions":["ice"]},"x-shader/x-fragment":{"compressible":true},"x-shader/x-vertex":{"compressible":true}}');

/***/ }),

/***/ 1315:
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('[["8740","‰è∞‰∞≤‰òÉ‰ñ¶‰ï∏ßâß‰µ∑‰ñ≥ß≤±‰≥¢ß≥Ö„Æï‰ú∂‰ùÑ‰±á‰±Ä§äø£òóßçí¶∫ãßÉí‰±ó™çë‰ùè‰óö‰≤Öß±¨‰¥á‰™§‰ö°¶¨£Áà••©î°©££∏Ü£Ω°ÊôçÂõª"],["8767","Á∂ïÂ§ù®Æπ„∑¥Èú¥ßØØÂØõ°µûÂ™§„ò•©∫∞Â´ëÂÆ∑Â≥ºÊùÆËñì©•ÖÁë°Áíù„°µ°µì£öû¶Ä°„ª¨"],["87a1","•£û„´µÁ´ºÈæó§Ö°®§ç£á™†™ä£âû‰åäËíÑÈæñÈêØ‰§∞ËòìÂ¢ñÈùäÈàòÁßêÁ®≤Êô†Ê®©Ë¢ùÁëåÁØÖÊûÇÁ®¨ÂâèÈÅÜ„ì¶ÁèÑ•∂πÁìÜÈøáÂû≥‰§ØÂëå‰Ñ±£öéÂ†òÁ©≤ß≠•ËÆè‰öÆ¶∫à‰ÜÅ•∂ôÁÆÆ¢íºÈøà¢ìÅ¢ìâ¢ìåÈøâËîÑ£ñª‰Ç¥Èøä‰ì°™∑øÊãÅÁÅÆÈøã"],["8840","„áÄ",4,"†Ñå„áÖ†Éë†Éç„áÜ„áá†Éã°ø®„áà†Éä„áâ„áä„áã„áå†Ñé„áç„áéƒÄ√Å«ç√Äƒí√âƒö√à≈å√ì«ë√í‡øø√äÃÑ·∫æ‡øø√äÃå·ªÄ√äƒÅ√°«é√†…ëƒì√©ƒõ√®ƒ´√≠«ê√¨≈ç√≥«í√≤≈´√∫«î√π«ñ«ò«ö"],["88a1","«ú√º‡øø√™ÃÑ·∫ø‡øø√™Ãå·ªÅ√™…°‚èö‚èõ"],["8940","™é©°ÖÖ"],["8943","Êîä"],["8946","‰∏ΩÊªùÈµéÈáü"],["894c","ßúµÊíë‰ºö‰º®‰æ®ÂÖñÂÖ¥ÂÜúÂá§Âä°Âä®ÂåªÂçéÂèëÂèòÂõ¢Â£∞Â§ÑÂ§áÂ§≤Â§¥Â≠¶ÂÆûÂÆüÂ≤öÂ∫ÜÊÄªÊñâÊüæÊ†ÑÊ°•ÊµéÁÇºÁîµÁ∫§Á∫¨Á∫∫ÁªáÁªèÁªüÁºÜÁº∑Ëâ∫ËãèËçØËßÜËÆæËØ¢ËΩ¶ËΩßËΩÆ"],["89a1","ÁêëÁ≥ºÁ∑çÊ•ÜÁ´âÂàß"],["89ab","ÈÜåÁ¢∏ÈÖûËÇº"],["89b0","Ë¥ãËÉ∂†ßß"],["89b5","ËÇüÈªá‰≥çÈ∑âÈ∏å‰∞æ©∑∂ßÄéÈ∏ä™Ñ≥„óÅ"],["89c1","Ê∫öËàæÁîô"],["89c5","‰§ëÈ©¨È™èÈæôÁ¶á®ë¨°∑ä†óê¢´¶‰∏§‰∫Å‰∫Ä‰∫á‰∫ø‰ª´‰º∑„ëå‰æΩ„πàÂÄÉÂÇà„ëΩ„íì„í•ÂÜÜÂ§ÖÂáõÂáºÂàÖ‰∫âÂâπÂäêÂåß„óáÂé©„ïëÂé∞„ïìÂèÇÂê£„ï≠„ï≤„öÅÂíìÂí£Âí¥ÂíπÂìêÂìØÂîòÂî£Âî®„ñòÂîø„ñ•„ñøÂóó„óÖ"],["8a40","ß∂ÑÂî•"],["8a43","†±Ç†¥ï•Ñ´Âñê¢≥Ü„ß¨†çÅËπÜ§∂∏©ì•‰Åì®ÇæÁù∫¢∞∏„®¥‰üï®Öù¶ß≤§∑™Êìù†µº†æ¥†≥ï°É¥ÊíçËπæ†∫ñ†∞ã†Ω§¢≤©®âñ§ìì"],["8a64","†µÜ©©ç®É©‰ü¥§∫ß¢≥ÇÈ™≤„©ß©ó¥„ø≠„îÜ•ãá©üîß£à¢µÑÈµÆÈ†ï"],["8a76","‰èô¶Ç•Êí¥Âì£¢µå¢Øä°Å∑„ßª°ÅØ"],["8aa1","¶õö¶úñß¶†Êì™•Åí†±ÉËπ®¢Ü°®≠å†ú±"],["8aac","‰†ã†Ü©„ø∫Â°≥¢∂ç"],["8ab2","§óà†ìº¶Çó†Ωå†∂ñÂïπ‰Çª‰é∫"],["8abb","‰™¥¢©¶°ÇùËÜ™È£µ†∂úÊçπ„ßæ¢ùµË∑ÄÂö°Êëº„πÉ"],["8ac9","™òÅ†∏â¢´è¢≥â"],["8ace","°Éà£ßÇ„¶í„®Ü®äõ„ï∏•πâ¢ÉáÂôí†º±¢≤≤©ú†„íºÊ∞Ω§∏ª"],["8adf","ßï¥¢∫ã¢àà™ôõ®≥ç†π∫†∞¥¶†úÁæì°Éè¢†É¢§π„óª•á£†∫å†æç†∫™„æì†º∞†µá°Öè†πå"],["8af6","†∫´†Æ©†µà°ÉÄ°ÑΩ„øπ¢öñÊê≤†æ≠"],["8b40","£è¥ßòπ¢Øé†µæ†µø¢±ë¢±ï„®ò†∫ò°Éá†ºÆ™ò≤¶≠ê®≥í®∂ô®≥äÈñ™ÂìåËãÑÂñπ"],["8b55","©ªÉÈ∞¶È™∂ßùû¢∑ÆÁÖÄËÖ≠ËÉ¨Â∞ú¶ï≤ËÑ¥„ûóÂçü®ÇΩÈÜ∂†ª∫†∏è†π∑†ªª„óù§∑´„òâ†≥ñÂöØ¢ûµ°Éâ†∏ê†π∏°Å∏°Öà®àá°ëï†ππ§πê¢∂§Â©î°Äù°Äû°Éµ°É∂Âûú†∏ë"],["8ba1","ßöî®ãç†æµ†πª•Öæ„úÉ†æ∂°ÜÄ•ãò™äΩ§ßö°†∫§Ö∑®âºÂ¢ôÂâ®„òö•úΩÁÆ≤Â≠®‰†Ä‰¨¨Èºß‰ßßÈ∞üÈÆç•≠¥£ÑΩÂóª„ó≤Âöâ‰∏®Â§Ç°ØÅØ°∏Èùë†ÇÜ‰πõ‰∫ª„îæÂ∞£ÂΩëÂøÑ„£∫ÊâåÊîµÊ≠∫Ê∞µÊ∞∫ÁÅ¨Áà´‰∏¨Áä≠§£©ÁΩíÁ§ªÁ≥πÁΩì¶â™„ìÅ"],["8bde","¶çãËÄÇËÇÄ¶òí¶•ëÂçùË°§ËßÅß¢≤ËÆ†Ë¥ùÈíÖÈï∏ÈïøÈó®®∏èÈü¶È°µÈ£éÈ£ûÈ•£©†êÈ±ºÈ∏üÈªÑÊ≠ØÔ§á‰∏∑†ÇáÈòùÊà∑Èí¢"],["8c40","ÂÄªÊ∑æ©±≥Èæ¶„∑âË¢è§ÖéÁÅ∑Â≥µ‰¨†•áç„ïô•¥∞ÊÑ¢®®≤ËæßÈá∂ÁÜëÊúôÁé∫£äÅ™Ñá„≤ã°¶Ä‰¨êÁ£§ÁêÇÂÜÆ®úè‰ÄâÊ©£™ä∫‰à£Ëòè†©ØÁ®™©•á®´™ÈùïÁÅçÂå§¢ÅæÈè¥Áõô®ß£ÈæßÁüù‰∫£‰ø∞ÂÇº‰∏Ø‰ºóÈæ®Âê¥Á∂ãÂ¢íÂ£ê°∂∂Â∫íÂ∫ôÂøÇ¢úíÊñã"],["8ca1","£èπÊ§ôÊ©É£±£Ê≥ø"],["8ca7","ÁàÄ§îÖÁéå„ªõ§®ìÂ¨ïÁíπËÆÉ•≤§•öïÁ™ìÁØ¨Á≥ÉÁπ¨Ëã∏ËñóÈæ©Ë¢êÈæ™Ë∫πÈæ´ËøèËïüÈß†Èà°Èæ¨®∂π°êø‰Å±‰ä¢Â®ö"],["8cc9","È°®Êù´‰â∂ÂúΩ"],["8cce","Ëóñ§•ªËäøßÑç‰≤Å¶µ¥Âµª¶¨ï¶ææÈæ≠ÈæÆÂÆñÈæØÊõßÁπõÊπóÁßä„∂à‰ìÉ£âñ¢ûñ‰éö‰î∂"],["8ce6","Â≥ï£¨öË´πÂ±∏„¥í£ïëÂµ∏Èæ≤ÁÖó‰ïò§É¨°∏£‰±∑„•∏„ëä†Ü§¶±ÅË´å‰æ¥†àπÂ¶øËÖ¨È°ñ©£∫Âºª"],["8d40","†Æü"],["8d42","¢áÅ®•≠‰ÑÇ‰öª©Åπ„ºáÈæ≥™Üµ‰É∏„üñ‰õ∑¶±Ü‰Öº®ö≤ßèø‰ï≠„£î•íö‰ï°‰îõ‰∂â‰±ª‰µ∂‰ó™„øà§¨è„ô°‰ìû‰íΩ‰á≠Â¥æÂµàÂµñ„∑º„†èÂ∂§Â∂π„††„†∏ÂπÇÂ∫ΩÂº•ÂæÉ„§à„§î„§ø„•çÊÉóÊÑΩÂ≥•„¶âÊÜ∑ÊÜπÊáè„¶∏Êà¨ÊäêÊã•Êåò„ß∏Âö±"],["8da1","„®ÉÊè¢ÊèªÊêáÊëö„©ãÊìÄÂ¥ïÂò°Èæü„™óÊñÜ„™ΩÊóøÊôì„´≤Êöí„¨¢Êúñ„≠ÇÊû§Ê†Ä„≠òÊ°äÊ¢Ñ„≠≤„≠±„≠ªÊ§âÊ•ÉÁâúÊ•§Ê¶üÊ¶Ö„ÆºÊßñ„ØùÊ©•Ê©¥Ê©±Ê™Ç„Ø¨Ê™ô„Ø≤Ê™´Ê™µÊ´îÊ´∂ÊÆÅÊØÅÊØ™Ê±µÊ≤™„≥ãÊ¥ÇÊ¥ÜÊ¥¶Ê∂Å„≥ØÊ∂§Ê∂±Ê∏ïÊ∏òÊ∏©Ê∫Ü®ßÄÊ∫ªÊª¢ÊªöÈΩøÊª®Êª©Êº§Êº¥„µÜ£ΩÅÊæÅÊææ„µ™„µµÁÜ∑Â≤ô„∂äÁÄ¨„∂ëÁÅêÁÅîÁÅØÁÅøÁÇâ†å•‰èÅ„ó±†ªò"],["8e40","£ªóÂûæ¶ªìÁÑæ•ü†„ôéÊ¶¢®Ø©Â≠¥Á©â•£°©ìôÁ©•Á©Ω•¶¨Á™ªÁ™∞Á´ÇÁ´ÉÁáë¶íç‰áäÁ´öÁ´ùÁ´™‰áØÂí≤•∞ÅÁ¨ãÁ≠ïÁ¨©•åé•≥æÁÆ¢Á≠ØËéú•Æ¥¶±øÁØêËê°ÁÆíÁÆ∏•¥†„∂≠•±•ËííÁØ∫Á∞ÜÁ∞µ•≥ÅÁ±ÑÁ≤É§¢ÇÁ≤¶ÊôΩ§ï∏Á≥âÁ≥áÁ≥¶Á±¥Á≥≥Á≥µÁ≥é"],["8ea1","Áπß‰îù¶πÑÁµù¶ªñÁíçÁ∂âÁ∂´ÁÑµÁ∂≥Á∑í§Åó¶Ä©Á∑§„¥ìÁ∑µ°üπÁ∑•®ç≠Á∏ù¶Ñ°¶ÖöÁπÆÁ∫í‰å´Èë¨Á∏ßÁΩÄÁΩÅÁΩáÁ§∂¶ãêÈß°Áæó¶çëÁæ£°ô°†Å®‰ïú£ù¶‰îÉ®å∫Áø∫¶íâËÄÖËÄàËÄùËÄ®ËÄØ™Çá¶≥ÉËÄªËÄºËÅ°¢úî‰¶â¶ò¶£∑£¶õ®Êú•ËÇß®©àËÑáËÑöÂ¢∞¢õ∂Ê±ø¶íò§æ∏Êìß°íäËàò°°ûÊ©ì§©•§™ï‰ë∫Ëà©†¨ç¶©í£µæ‰øπ°ìΩËì¢Ëç¢¶¨ä§¶ß£î∞°ù≥£∑∏Ëä™Ê§õØ¶î‰áõ"],["8f40","ËïãËãêËåö†∏ñ°û¥„õÅ£ÖΩ£ïöËâªËã¢Ëåò£∫ã¶∂£¶¨Ö¶Æó£óé„∂øËåùÂó¨ËéÖ‰îã¶∂•Ëé¨ËèÅËèì„ëæ¶ªîÊ©óËïö„íñ¶πÇ¢ªØËëò•Ø§Ëë±„∑ì‰ì§Ê™ßËëä£≤µÁ•òËí®¶Æñ¶π∑¶πÉËìûËêèËéë‰í†ËíìËì§•≤ë‰âÄ•≥Ä‰ïÉËî¥Â´≤¶∫ô‰îßËï≥‰îñÊûøËòñ"],["8fa1","®ò•®òªËóÅßÇàËòÇ°ñÇßÉçØ¶≤‰ï™Ëò®„ôà°¢¢Âè∑ßéöËôæËù±™É∏ËüÆ¢∞ßËû±ËüöË†èÂô°Ëô¨Ê°ñ‰òèË°ÖË°Üßó†£∂πßó§Ë°ûË¢ú‰ôõË¢¥Ë¢µÊèÅË£ÖÁù∑ßúèË¶áË¶äË¶¶Ë¶©Ë¶ßË¶º®®•Ëßßß§§ß™ΩË™úÁûìÈáæË™êß©ôÁ´©ß¨∫£æè‰úìß¨∏ÁÖºË¨åË¨ü•ê∞•ï•Ë¨øË≠åË≠çË™©§©∫ËÆêËÆõË™Ø°õü‰òïË°èË≤õßµîß∂èØßî„ú•ßµìË≥ñß∂òß∂ΩË¥íË¥É°§êË≥õÁÅúË¥ë§≥â„ªêËµ∑"],["9040","Ë∂©®ÄÇ°Äî§¶ä„≠º®ÜºßÑåÁ´ßË∫≠Ë∫∂ËªÉÈãîËºôËº≠®ç•®êíËæ•ÈåÉ™äü†©êËæ≥‰§™®ßû®îΩ£∂ªÂª∏£â¢Ëøπ™Äî®öº®îÅ¢å•„¶Ä¶ªóÈÄ∑®îºß™æÈÅ°®ï¨®òãÈÇ®®úìÈÉÑ®õ¶ÈÇÆÈÉΩÈÖß„´∞ÈÜ©ÈáÑÁ≤¨®§≥°∫âÈàéÊ≤üÈâÅÈâ¢•ñπÈäπ®´Ü£≤õ®¨å•óõ"],["90a1","†¥±Èå¨Èç´®´°®Ø´ÁÇèÂ´É®´¢®´•‰••ÈâÑ®Ø¨®∞π®ØøÈç≥ÈëõË∫ºÈñÖÈñ¶Èê¶Èñ†Êø∂‰äπ¢ô∫®õò°âº£∏Æ‰ßüÊ∞úÈôªÈöñ‰Ö¨Èö£¶ªïÊáöÈö∂Á£µ®´†ÈöΩÂèå‰¶°¶≤∏†â¥¶êê©ÇØ©É•§´ë°§ï£åäÈú±ËôÇÈú∂‰®è‰îΩ‰ñÖ§´©ÁÅµÂ≠ÅÈúõÈùú©áïÈùóÂ≠ä©á´ÈùüÈê•ÂÉê£Ç∑£ÇºÈûâÈûüÈû±ÈûæÈüÄÈüíÈü†•ë¨ÈüÆÁêú©ê≥ÈüøÈüµ©êùß•∫‰´ëÈ†¥È†≥È°ãÈ°¶„¨éßÖµ„µë†ò∞§Öú"],["9140","•úÜÈ£äÈ¢∑È£àÈ£á‰´ø¶¥ß°õìÂñ∞È£°È£¶È£¨Èç∏È§π§®©‰≠≤©°ó©§ÖÈßµÈ®åÈ®ªÈ®êÈ©ò•ú•„õÑ©Ç±©ØïÈ´†È´¢©¨ÖÈ´¥‰∞éÈ¨îÈ¨≠®òÄÂÄ¥È¨¥¶¶®„£É£ÅΩÈ≠êÈ≠Ä©¥æÂ©Ö°°£ÈÆé§âãÈ∞ÇÈØøÈ∞å©π®È∑î©æ∑™Üí™Ü´™É°™Ñ£™áüÈµæÈ∂É™Ñ¥È∏éÊ¢à"],["91a1","È∑Ñ¢Öõ™Üì™à†°§ª™à≥È¥π™Çπ™ä¥È∫êÈ∫ïÈ∫ûÈ∫¢‰¥¥È∫™È∫Ø§ç§ÈªÅ„≠†„ß•„¥ù‰º≤„ûæ®∞´ÈºÇÈºà‰ÆñÈê§¶∂¢ÈºóÈºñÈºπÂöüÂöäÈΩÖÈ¶∏©ÇãÈü≤ËëøÈΩ¢ÈΩ©Á´úÈæéÁàñ‰Ææ§•µ§¶ªÁÖ∑§ß∏§çà§©ëÁéû®Øö°£∫Á¶ü®•æ®∏∂Èç©Èè≥®©ÑÈã¨ÈéÅÈèã®•¨§íπÁàó„ª´Áù≤Á©ÉÁÉê§ë≥§è∏ÁÖæ°üØÁÇ£°¢æ£ñô„ªá°¢Ö•êØ°ü∏„ú¢°õª°†π„õ°°ù¥°£ë•Ωã„ú£°õÄÂùõ§®•°èæ°ä®"],["9240","°èÜ°í∂ËîÉ£ö¶ËîÉËëï§¶îßÖ•£∏±•ïú£ªªßÅí‰ì¥£õÆ©¶ù¶º¶Êüπ„ú≥„∞ï„∑ßÂ°¨°§¢Ê†ê‰Åó£úø§É°§Çã§Ñè¶∞°ÂìãÂöû¶ö±Âöí†øü†Æ®†∏çÈèÜ®¨ìÈéú‰ª∏ÂÑ´„†ô§ê∂‰∫º†ë•†çø‰Ωã‰æä•ôëÂ©®†Ü´†èã„¶ô†åä†êî„êµ‰º©†ãÄ®∫≥†âµË´ö†àå‰∫ò"],["92a1","ÂÉçÂÑç‰æ¢‰ºÉ§®é£∫ä‰ΩÇÂÄÆÂÅ¨ÂÇÅ‰øå‰ø•ÂÅòÂÉºÂÖôÂÖõÂÖùÂÖûÊπ∂£ñï£∏π£∫øÊµ≤°¢Ñ£∫âÂÜ®ÂáÉ†ó†‰ìù†í£†íí†íëËµ∫®™ú†úéÂâôÂä§†°≥Âã°ÈçÆ‰ô∫ÁÜå§éå†∞†§¶¨°É§Êßë†∏ùÁëπ„ªûÁíôÁêîÁëñÁéò‰Æé§™º§ÇçÂèê„ñÑÁàè§ÉâÂñ¥†çÖÂìç†ØÜÂúùÈâùÈõ¥Èç¶ÂüùÂûçÂùø„òæÂ£ãÂ™ô®©Ü°õ∫°ùØ°úêÂ®¨Â¶∏ÈäèÂ©æÂ´èÂ®í••Ü°ß≥°°°§äï„õµÊ¥ÖÁëÉÂ®°•∫É"],["9340","Â™Å®Øó†êìÈè†Áíå°åÉÁÑÖ‰•≤Èêà®ßªÈéΩ„û†Â∞ûÂ≤ûÂπûÂπà°¶ñ°•º£´ÆÂªçÂ≠è°§É°§Ñ„úÅ°¢†„õù°õæ„õìËÑ™®©á°∂∫£ë≤®¶®ÂºåÂºé°§ß°û´Â©´°úªÂ≠ÑËòîßóΩË°†ÊÅæ¢°†¢ò´Âøõ„∫∏¢ñØ¢ñæ©Çà¶Ω≥ÊáÄ†Äæ†ÅÜ¢òõÊÜôÊÜòÊÅµ¢≤õ¢¥á§õî©Öç"],["93a1","Êë±§ô•¢≠™„®©¢¨¢£ëê©£™¢π∏Êå∑™ëõÊí∂Êå±Êèë§ß£¢µßÊä§¢≤°ÊêªÊï´Ê•≤„Ø¥£Çé£ä≠§¶â£ä´Âîç£ã†°£ô©êøÊõé£äâ£Ü≥„´†‰Üê•ñÑ®¨¢•ñè°õº•ïõ•ê•Á£Æ£ÑÉ°†™£à¥„ë§£àè£ÜÇ§ãâÊöé¶¥§Êô´‰ÆìÊò∞ß°∞°∑´Êô££ãí£ã°Êòû•°≤„£ë£†∫£ûº„Æô£û¢£èæÁìê„ÆñÊûè§ò™Ê¢∂Ê†û„ØÑÊ™æ„°££üï§íáÊ®≥Ê©íÊ´âÊ¨Ö°§íÊîëÊ¢òÊ©å„ØóÊ©∫Ê≠ó£øÄ£≤öÈé†Èã≤®Ø™®´ã"],["9440","Èäâ®Äû®ßúÈëßÊ∂•Êºã§ß¨Êµß£Ωø„∂èÊ∏Ñ§ÄºÂ®ΩÊ∏äÂ°áÊ¥§Á°ÇÁÑª§åö§â∂ÁÉ±ÁâêÁäáÁäî§ûè§ú•ÂÖπ§™§†ó´Áë∫£ª∏£ôü§©ä§§ó•ø°„ºÜ„∫±§´ü®∞££ºµÊÇß„ª≥ÁìåÁêºÈéáÁê∑‰íü¶∑™‰ïëÁñÉ„Ω£§≥ô§¥Ü„ΩòÁïïÁô≥™óÜ„¨ôÁë®®´å§¶´§¶é„´ª"],["94a1","„∑ç§©é„ªø§ßÖ§£≥Èá∫Âú≤ÈçÇ®´£°°§ÂÉü•à°•áßÁù∏£à≤ÁúéÁúèÁùª§öó£ûÅ„©û§£∞Áê∏Áíõ„∫ø§™∫§´á‰Éà§™ñ¶ÜÆÈåá•ñÅÁ†ûÁ¢çÁ¢àÁ£íÁèêÁ•ôßùÅ•õ£‰ÑéÁ¶õËíñÁ¶•Ê®≠£ª∫Á®∫Áß¥‰ÖÆ°õ¶‰Ñ≤ÈàµÁß±†µå§¶å†äô£∂∫°ùÆ„ñóÂï´„ï∞„ö™†áî†∞çÁ´¢Â©ô¢õµ•™Ø•™úÂ®ç†âõÁ£∞Â®™•ØÜÁ´æ‰áπÁ±ùÁ±≠‰àë•Æ≥•∫º•∫¶Á≥ç§ßπ°û∞Á≤éÁ±ºÁ≤ÆÊ™≤Á∑úÁ∏áÁ∑ìÁΩé¶â°"],["9540","¶Öúß≠àÁ∂ó•∫Ç‰â™¶≠µ†§ñÊüñ†Åé£óèÂüÑ¶êí¶è∏§•¢ÁøùÁ¨ß††¨•´©•µÉÁ¨å•∏éÈß¶ËôÖÈ©£Ê®ú£êø„ß¢§ß∑¶ñ≠È®ü¶ñ†ËíÄßÑß¶≥ë‰ì™ËÑ∑‰êÇËÉÜËÑâËÖÇ¶û¥È£É¶©ÇËâ¢Ëâ•¶©ëËëì¶∂ßËòêßàõÂ™Ü‰Öø°°ÄÂ¨´°¢°Â´§°£òËö†Ø¶º£∂èË†≠ßê¢Â®Ç"],["95a1","Ë°Æ‰ΩÖË¢áË¢øË£¶Ë••Ë•ç•öÉË•îßûÖßûÑ®Øµ®Øô®Æú®ßπ„∫≠Ëí£‰õµ‰õè„ü≤Ë®ΩË®ú©ëàÂΩçÈà´§äÑÊóîÁÑ©ÁÉÑ°°ÖÈµ≠Ë≤üË≥©ß∑úÂ¶öÁüÉÂß∞‰çÆ„õîË∏™Ë∫ß§∞âËº∞ËΩä‰ã¥Ê±òÊæª¢å°‰¢õÊΩπÊ∫ã°üöÈØ©„öµ§§ØÈÇªÈÇóÂï±‰§ÜÈÜªÈêÑ®©ã‰Å¢®´ºÈêß®∞ù®∞ªËì•Ë®´ÈñôÈñßÈñóÈññ®¥¥ÁëÖ„ªÇ§£ø§©Ç§è™„ªß£à•Èöè®ªß®π¶®π•„ªå§ß≠§©∏£øÆÁêíÁë´„ªºÈùÅ©Ç∞"],["9640","Ê°á‰®ù©Çì•üüÈùùÈç®®¶â®∞¶®¨Ø¶éæÈä∫Â¨ëË≠©‰§ºÁèπ§àõÈûõÈù±È§∏†º¶Â∑Å®ØÖ§™≤È†ü©ìöÈã∂©óóÈá•‰ìÄ®≠ê§©ß®≠§È£ú®©Ö„ºÄÈà™‰§•ËêîÈ§ªÈ•çß¨Ü„∑ΩÈ¶õ‰≠ØÈ¶™È©ú®≠••£àÊ™èÈ®°Â´æÈ®Ø©£±‰Æê©•àÈ¶º‰ÆΩ‰ÆóÈçΩÂ°≤°åÇÂ†¢§¶∏"],["96a1","°ì®Á°Ñ¢úü£∂∏Ê£Ö„µΩÈëò„§ßÊÖê¢ûÅ¢•´ÊÑáÈ±èÈ±ìÈ±ªÈ∞µÈ∞êÈ≠øÈØè©∏≠ÈÆü™áµ™ÉæÈ¥°‰≤Æ§ÑÑÈ∏ò‰≤∞È¥å™Ü¥™É≠™É≥©§ØÈ∂•ËíΩ¶∏í¶øü¶ÆÇËóº‰î≥¶∂§¶∫Ñ¶∑∞Ëê†ËóÆ¶∏Ä£üó¶Å§Áß¢£ñú£ôÄ‰§≠§ßû„µ¢ÈèõÈäæÈçà†äøÁ¢πÈâ∑Èëç‰ø§„ëÄÈÅ§•ïùÁ†ΩÁ°îÁ¢∂Á°ã°ùó£áâ§•Å„öö‰Ω≤ÊøöÊøôÁÄûÁÄûÂêî§ÜµÂûªÂ£≥ÂûäÈ¥ñÂüóÁÑ¥„íØ§Ü¨Áá´¶±Ä§æóÂ¨®°ûµ®©â"],["9740","ÊÑåÂ´éÂ®ã‰äº§íà„ú¨‰≠ª®ßºÈéªÈé∏°£ñ†ºùËë≤¶≥Ä°êì§ã∫¢∞¶§èÅÂ¶î£∂∑¶ùÅÁ∂®¶Öõ¶Ç§§¶π§¶ã®ß∫Èã•Áè¢„ª©Áí¥®≠£°¢ü„ª°§™≥Ê´òÁè≥Áèª„ªñ§®æ§™î°üô§©¶†éß°ê§§ß•Áëà§§ñÁÇ•§•∂ÈäÑÁè¶Èçü†ìæÈå±®´é®®ñÈéÜ®Øß•óï‰§µ®™ÇÁÖ´"],["97a1","§•É†≥øÂö§†òö†Ø´†≤∏ÂîÇÁßÑ°ü∫Á∑æ°õÇ§©ê°°í‰îÆÈêÅ„úä®´Ä§¶≠Â¶∞°¢ø°¢ÉßíÑÂ™°„õ¢£µõ„ö∞ÈâüÂ©π®™Å°°¢Èç¥„≥ç†™¥‰™ñ„¶äÂÉ¥„µ©„µå°éúÁÖµ‰ãª®àòÊ∏è©É§‰ì´ÊµóßπèÁÅßÊ≤Ø„≥ñ£ø≠£∏≠Ê∏ÇÊºå„µØ†èµÁïë„öº„ìà‰öÄ„ªö‰°±ÂßÑÈâÆ‰§æËΩÅ®∞ú¶ØÄÂ†íÂüà„õñ°ëíÁÉæ§ç¢§©±¢ø£°ä∞¢éΩÊ¢πÊ•ß°éò£ì•ßØ¥£õü®™É£üñ£è∫§≤üÊ®ö£ö≠¶≤∑Ëêæ‰ìü‰ìé"],["9840","¶¥¶¶µë¶≤Ç¶øûÊºóßÑâËåΩ°ú∫Ëè≠¶≤ÄßÅì°üõÂ¶âÂ™Ç°û≥Â©°Â©±°§Ö§áº„ú≠ÂßØ°úº„õáÁÜéÈéêÊöö§ä•Â©ÆÂ®´§äìÊ®´£ªπßú∂§ëõ§ãäÁÑù§âô®ß°‰æ∞¶¥®Â≥Ç§ìéßπç§éΩÊ®å§âñ°åÑÁÇ¶ÁÑ≥§è©„∂•Ê≥üØ†•§©èÁπ•Âß´Â¥Ø„∑≥ÂΩú§©ù°üüÁ∂§Ëê¶"],["98a1","ÂíÖ£´∫£åÄ†àîÂùæ†£ï†òô„ø•°æû™ä∂ÁÄÉ©ÖõÂµ∞ÁéèÁ≥ì®©ô©ê†‰øàÁøßÁãçÁåêß´¥Áå∏Áåπ•õ∂ÁçÅÁçà„∫©ß¨òÈÅ¨Ááµ§£≤Áè°Ëá∂„ªäÁúå„ªëÊ≤¢ÂõΩÁêôÁêûÁêü„ª¢„ª∞„ª¥„ª∫Áìì„ºé„ΩìÁïÇÁï≠Áï≤Áñç„ΩºÁóàÁóú„øÄÁôç„øóÁô¥„øúÁô∫§ΩúÁÜàÂò£Ë¶ÄÂ°©‰ÄùÁùÉ‰ÄπÊù°‰ÅÖ„óõÁûò‰Å™‰ÅØÂ±ûÁûæÁüãÂ£≤Á†òÁÇπÁ†ú‰Ç®Á†πÁ°áÁ°ëÁ°¶Ëëà•îµÁ§≥Ê†ÉÁ§≤‰ÑÉ"],["9940","‰ÑâÁ¶ëÁ¶ôËæªÁ®ÜËæº‰ÖßÁ™ë‰Ü≤Á™ºËâπ‰áÑÁ´èÁ´õ‰áè‰∏°Á≠¢Á≠¨Á≠ªÁ∞íÁ∞õ‰â†‰â∫Á±ªÁ≤ú‰äåÁ≤∏‰äîÁ≥≠ËæìÁÉÄ†≥èÁ∑èÁ∑îÁ∑êÁ∑ΩÁæÆÁæ¥Áäü‰éóËÄ†ËÄ•Á¨πËÄÆËÄ±ËÅî„∑åÂû¥ÁÇ†ËÇ∑ËÉ©‰è≠ËÑåÁå™ËÑéËÑíÁï†ËÑî‰êÅ„¨πËÖñËÖôËÖö"],["99a1","‰êìÂ†∫ËÖºËÜÑ‰ê•ËÜì‰ê≠ËÜ•ÂüØËáÅËá§Ëâî‰íèËä¶Ëâ∂ËãäËãòËãø‰í∞ËçóÈô©Ê¶äËêÖÁÉµËë§ÊÉ£Ëíà‰îÑËíæËì°Ëì∏ËîêËî∏Ëïí‰îªËïØËï∞Ëó†‰ï∑Ëô≤ËöíËö≤ËõØÈôÖËûã‰òÜ‰òóË¢ÆË£øË§§Ë•áË¶ëß•ßË®©Ë®∏Ë™îË™¥Ë±ëË≥îË≥≤Ë¥ú‰ûòÂ°üË∑É‰ü≠‰ªÆË∏∫ÂóòÂùîËπ±ÂóµË∫∞‰†∑ËªéËª¢Ëª§Ëª≠Ëª≤Ëæ∑ËøÅËøäËøåÈÄ≥ÈßÑ‰¢≠È£†Èàì‰§ûÈà®ÈâòÈâ´Èä±ÈäÆÈäø"],["9a40","Èã£Èã´Èã≥Èã¥ÈãΩÈçÉÈéÑÈé≠‰•Ö‰•ëÈ∫øÈêóÂåÅÈêùÈê≠Èêæ‰•™ÈëîÈëπÈî≠Èñ¢‰¶ßÈó¥Èò≥‰ß•Êû†‰®§ÈùÄ‰®µÈû≤ÈüÇÂôî‰´§ÊÉ®È¢π‰¨ôÈ£±Â°ÑÈ§éÈ§ôÂÜ¥È§úÈ§∑È•ÇÈ•ùÈ•¢‰≠∞ÈßÖ‰ÆùÈ®ºÈ¨èÁ™ÉÈ≠©ÈÆÅÈØùÈØ±ÈØ¥‰±≠È∞†„ùØ°ØÇÈµâÈ∞∫"],["9aa1","ÈªæÂôêÈ∂ìÈ∂ΩÈ∑ÄÈ∑ºÈì∂Ëæ∂ÈπªÈ∫¨È∫±È∫ΩÈªÜÈìúÈª¢Èª±Èª∏Á´àÈΩÑ†Çî†ä∑†é†Ê§öÈìÉÂ¶¨†ìóÂ°ÄÈìÅ„ûπ†óï†òï†ô∂°ö∫ÂùóÁÖ≥†´Ç†´ç†ÆøÂë™Ø†ª†ØãÂíû†Øª†∞ª†±ì†±•†±ºÊÉß†≤çÂô∫†≤µ†≥ù†≥≠†µØ†∂≤†∑àÊ•ïÈ∞ØËû•†∏Ñ†∏é†ªó†æê†º≠†π≥Â∞††æºÂ∏ã°Åú°Åè°Å∂Êúû°Åª°Çà°Çñ„ôá°Çø°Éì°ÑØ°ÑªÂç§Ëí≠°ã£°çµ°å∂ËÆÅ°ï∑°òô°üÉ°üá‰π∏ÁÇª°†≠°•™"],["9b40","°®≠°©Ö°∞™°±∞°≤¨°ªàÊãÉ°ªï°ºïÁÜòÊ°ï¢ÅÖÊß©„õà¢âº¢èó¢è∫¢ú™¢°±¢•èËãΩ¢•ß¢¶ì¢´ïË¶•¢´®Ëæ†¢¨éÈû∏¢¨øÈ°áÈ™Ω¢±å"],["9b62","¢≤à¢≤∑•Ø®¢¥à¢¥í¢∂∑¢∂ï¢πÇ¢Ω¥¢øå£Ä≥£Å¶£åü£èûÂæ±ÊôàÊöøß©π£ïß£ó≥ÁàÅ§¶∫Áüó£òö£úñÁ∫á†çÜÂ¢µÊúé"],["9ba1","Ê§ò£™ßßôó•ø¢£∏ë£∫πßóæ¢Çö‰£ê‰™∏§Ñô®™ö§ãÆ§åç§Äª§å¥§éñ§©Ö†óäÂáí†òëÂ¶ü°∫®„Ææ£≥ø§êÑ§ìñÂûà§ô¥„¶õ§úØ®ó®©ßâ„ù¢¢áÉË≠û®≠éÈßñ§†í§£ª§®ïÁàâ§´Ä†±∏Â••§∫•§æÜ†ùπËªö•Ä¨ÂäèÂúøÁÖ±•äô•êô£Ωä§™ßÂñº•ëÜ•ëÆ¶≠íÈáî„ë≥•îøßò≤•ïû‰úò•ï¢•ï¶•üá§§ø•°ùÂÅ¶„ìª£èåÊÉû•§É‰ùº®•à•™Æ•Æâ•∞Ü°∂êÂû°ÁÖëÊæ∂¶ÑÇß∞íÈÅñ¶Ü≤§æöË≠¢¶êÇ¶ëä"],["9c40","Âµõ¶Ø∑Ëº∂¶íÑ°§úË´™§ß∂¶íà£øØ¶îí‰ØÄ¶ñø¶öµ¢úõÈë••ü°ÊÜïÂ®ßØ£ç‰æªÂöπ§î°¶õº‰π™§§¥ÈôñÊ∂è¶≤Ω„òòË•∑¶ûô¶°Æ¶êë¶°ûÁáü¶£áÁ≠Ç©ÉÄ†®ë¶§¶ÈÑÑ¶§πÁ©ÖÈ∑∞¶ß∫È®¶¶®≠„ôü¶ë©†Ä°Á¶É¶®¥¶≠õÂ¥¨£îôËèè¶Æù‰õê¶≤§ÁîªË°•¶∂ÆÂ¢∂"],["9ca1","„úú¢ñçßÅãßáç„±îßäÄßäÖÈäÅ¢Ö∫ßäãÈå∞ßã¶§ßêÊ∞πÈíüßëê†ª∏Ë†ßË£µ¢§¶®ë≥°û±Ê∫∏§®™°††„¶§„öπÂ∞êÁß£‰îøÊö∂©≤≠©¢§Ë•Éßüåß°òÂõñ‰Éü°òä„¶°£úØ®É®°èÖÁÜ≠Ëç¶ßßù©Ü®Â©ß‰≤∑ßÇØ®¶´ßßΩß®äß¨ãßµ¶§Ö∫Á≠ÉÁ•æ®ÄâÊæµ™ãüÊ®É®åòÂé¢¶∏áÈéøÊ†∂Èùù®ÖØ®Ä£¶¶µ°è≠£àØ®ÅàÂ∂Ö®∞∞®ÇÉÂúïÈ†£®•âÂ∂´§¶àÊñæÊßïÂèí§™•£æÅ„∞ëÊú∂®Çê®É¥®ÑÆ°æ°®Öè"],["9d40","®Üâ®ÜØ®àö®åÜ®åØ®éä„óä®ë®®ö™‰£∫Êè¶®•ñÁ†àÈâï®¶∏‰è≤®ßß‰èü®ß®®≠Ü®ØîÂß∏®∞âËºã®øÖ©É¨Á≠ë©Ñê©Ñº„∑∑©Öû§´äËøêÁäèÂöã©ìß©ó©©ñ∞©ñ∏©ú≤©£ë©•â©•™©ßÉ©®®©¨é©µö©∂õÁ∫ü©ª∏©º£‰≤§Èïá™äìÁÜ¢™ãø‰∂ëÈÄí™óã‰∂ú†≤úËææÂóÅ"],["9da1","Ëæ∫¢í∞Ëæπ§™ì‰îâÁπøÊΩñÊ™±‰ª™„ì§®¨¨ß¢ù„ú∫Ë∫Ä°üµ®Ä§®≠¨®Æôß®æ¶öØ„∑´ßôï£≤∑•òµ••ñ‰∫ö•∫Å¶âòÂöø†π≠Ë∏éÂ≠≠£∫à§≤ûÊèûÊãê°ü∂°°ªÊî∞Âò≠•±äÂêö•åë„∑Ü©∂ò‰±ΩÂò¢ÂòûÁΩâ•ªòÂ•µ£µÄËù∞‰∏ú†ø™†µâ£ö∫ËÑóÈµûË¥òÁòªÈ±ÖÁôéÁûπÈçÖÂê≤ËÖàËã∑Âò•ËÑ≤ËêòËÇΩÂó™Á•¢ÂôÉÂêñ†∫ù„óéÂòÖÂó±Êõ±®ã¢„ò≠Áî¥Âó∞Âñ∫ÂíóÂï≤†±Å†≤ñÂªê•Öà†π∂¢±¢"],["9e40","†∫¢È∫´ÁµöÂóû°ÅµÊäùÈù≠ÂíîË≥çÁá∂ÈÖ∂ÊèºÊéπÊèæÂï©¢≠ÉÈ±≤¢∫≥ÂÜö„ìü†∂ßÂÜßÂëçÂîûÂîìÁô¶Ë∏≠¶¢äÁñ±ËÇ∂Ë†ÑËûÜË£áËÜ∂Ëêú°ÉÅ‰ì¨ÁåÑ§úÜÂÆêËåã¶¢ìÂôª¢õ¥ß¥Ø§Ü£ßµ≥¶ªêßä∂ÈÖ∞°áôÈàà£≥º™ö©†∫¨†ªπÁâ¶°≤¢‰ùé§øÇßøπ†ø´‰É∫"],["9ea1","È±ùÊîü¢∂†‰£≥§ü†©µº†ø¨†∏äÊÅ¢ßñ£†ø≠"],["9ead","¶Åà°ÜáÁÜ£Á∫éÈµê‰∏ö‰∏Ñ„ï∑Â¨çÊ≤≤Âçß„ö¨„ßúÂçΩ„ö•§òòÂ¢ö§≠ÆËà≠ÂëãÂû™•™ï†•π"],["9ec5","„©í¢ë•Áç¥©∫¨‰¥âÈØ≠£≥æ©º∞‰±õ§æ©©ñû©øûËëú£∂∂ßä≤¶û≥£ú†ÊåÆÁ¥•£ª∑£∏¨„®™ÈÄàÂãå„π¥„ô∫‰ó©†íéÁôÄÂ´∞†∫∂Á°∫ßºÆÂ¢ß‰ÇøÂôºÈÆãÂµ¥Áôî™ê¥È∫Ö‰≥°Áóπ„üªÊÑô£Éö§è≤"],["9ef5","Âôù°ä©Âûß§•£©∏ÜÂà¥ßÇÆ„ñ≠Ê±äÈµº"],["9f40","Á±ñÈ¨πÂüû°ù¨Â±ìÊìì©ìê¶åµßÖ§Ëö≠†¥®¶¥¢§´¢†µ±"],["9f4f","Âáæ°ºèÂ∂éÈúÉ°∑ëÈ∫ÅÈÅåÁ¨üÈ¨ÇÂ≥ëÁÆ£Êâ®ÊåµÈ´øÁØèÈ¨™Á±æÈ¨ÆÁ±ÇÁ≤ÜÈ∞ïÁØºÈ¨âÈºóÈ∞õ§§æÈΩöÂï≥ÂØÉ‰øΩÈ∫ò‰ø≤Ââ†„∏ÜÂãëÂùßÂÅñÂ¶∑Â∏íÈüàÈ∂´ËΩúÂë©Èû¥È•ÄÈû∫Âå¨ÊÑ∞"],["9fa1","Ê§¨ÂèöÈ∞äÈ¥Ç‰∞ªÈôÅÊ¶ÄÂÇ¶ÁïÜ°ù≠ÈßöÂâ≥"],["9fae","ÈÖôÈöÅÈÖú"],["9fb2","ÈÖë®∫óÊçø¶¥£Ê´äÂòëÈÜéÁï∫ÊäÖ†èºÁçèÁ±∞•∞°£≥Ω"],["9fc1","§§ôÁõñÈÆù‰∏™†≥îËéæË°Ç"],["9fc9","Â±äÊßÄÂÉ≠Âù∫ÂàüÂ∑µ‰ªéÊ∞±†á≤‰ºπÂíúÂìöÂäöË∂Ç„óæÂºå„ó≥"],["9fdb","Ê≠íÈÖºÈæ•ÈÆóÈ†ÆÈ¢¥È™∫È∫®È∫ÑÁÖ∫Á¨î"],["9fe7","ÊØ∫Ë†òÁΩ∏"],["9feb","Âò†™ôäËπ∑ÈΩì"],["9ff0","Ë∑îËπèÈ∏úË∏ÅÊäÇ®çΩË∏®ËπµÁ´ì§©∑Á®æÁ£òÊ≥™Ë©ßÁòá"],["a040","®©öÈº¶Ê≥éËüñÁóÉ™ä≤Á°ìØ°ÄË¥åÁã¢Áç±Ë¨≠ÁåÇÁì±Ë≥´§™ªËòØÂæ∫Ë¢†‰í∑"],["a055","°†ª¶∏Ö"],["a058","Ë©æ¢îõ"],["a05b","ÊÉΩÁôßÈ´óÈµÑÈçÆÈÆèËüµ"],["a063","Ë†èË≥∑Áå¨Èú°ÈÆ∞„óñÁä≤‰∞áÁ±ëÈ•ä¶ÖôÊÖô‰∞ÑÈ∫ñÊÖΩ"],["a073","ÂùüÊÖØÊä¶ÊàπÊãé„©úÊá¢Âé™£èµÊç§Ê†Ç„óí"],["a0a1","Âµó®ØÇËøö®∏π"],["a0a6","ÂÉô°µÜÁ§ÜÂå≤Èò∏†ºª‰Å•"],["a0ae","Áüæ"],["a0b0","Á≥Ç•ºöÁ≥öÁ®≠ËÅ¶ËÅ£ÁµçÁîÖÁì≤Ë¶îËàöÊúåËÅ¢ßíÜËÅõÁì∞ËÑÉÁú§Ë¶â¶üåÁïì¶ªëËû©ËüéËáàËûåË©âË≤≠Ë≠ÉÁú´Áì∏Ëìö„òµÊ¶≤Ë∂¶"],["a0d4","Ë¶©Áë®Ê∂πËüÅ§ÄëÁìß„∑õÁÖ∂ÊÇ§ÊÜú„≥ëÁÖ¢ÊÅ∑"],["a0e2","ÁΩ±®¨≠ÁâêÊÉ©‰≠æÂà†„∞ò£≥á•ªóßôñ•î±°•Ñ°ãæ©§É¶∑úßÇ≠Â≥Å¶Ü≠®®è£ô∑†ÉÆ¶°Ü§ºé‰ï¢Â¨ü¶çåÈΩêÈ∫¶¶â´"],["a3c0","‚êÄ",31,"‚ê°"],["c6a1","‚ë†",9,"‚ë¥",9,"‚Ö∞",9,"‰∏∂‰∏ø‰∫Ö‰∫†ÂÜÇÂÜñÂÜ´ÂãπÂå∏Âç©Âé∂Â§äÂÆÄÂ∑õ‚º≥ÂπøÂª¥ÂΩêÂΩ°Êî¥Êó†ÁñíÁô∂ËæµÈö∂¬®ÀÜ„ÉΩ„Éæ„Çù„Çû„ÄÉ‰ªù„ÄÖ„ÄÜ„Äá„ÉºÔºªÔºΩ‚úΩ„ÅÅ",23],["c740","„Åô",58,"„Ç°„Ç¢„Ç£„Ç§"],["c7a1","„Ç•",81,"–ê",5,"–Å–ñ",4],["c840","–õ",26,"—ë–∂",25,"‚áß‚Ü∏‚Üπ„áè†Éå‰πö†ÇäÂàÇ‰íë"],["c8a1","Èæ∞ÂÜàÈæ±ßòá"],["c8cd","Ôø¢Ôø§ÔºáÔºÇ„à±‚Ññ‚Ñ°„Çõ„Çú‚∫Ä‚∫Ñ‚∫Ü‚∫á‚∫à‚∫ä‚∫å‚∫ç‚∫ï‚∫ú‚∫ù‚∫•‚∫ß‚∫™‚∫¨‚∫Æ‚∫∂‚∫º‚∫æ‚ªÜ‚ªä‚ªå‚ªç‚ªè‚ªñ‚ªó‚ªû‚ª£"],["c8f5"," É…ê…õ…î…µ≈ì√∏≈ã ä…™"],["f9fe","Ôø≠"],["fa40","†ïáÈãõ†óü£øÖËïå‰äµÁèØÂÜµ„ôâ§•Ç®ß§ÈçÑ°ßõËãÆ£≥àÁ†ºÊùÑÊãü§§≥®¶™†ä†¶Æ≥°åÖ‰æ´¢ì≠ÂÄà¶¥©ß™Ñ£òÄ§™±¢îìÂÄ©†çæÂæ§†éÄ†çáÊªõ†êüÂÅΩÂÑÅ„ë∫ÂÑéÈ°¨„ùÉËêñ§¶§†íáÂÖ†£é¥ÂÖ™†Øø¢Éº†ã•¢î∞†ñé£à≥°¶ÉÂÆÇËùΩ†ñ≥£≤ôÂÜ≤ÂÜ∏"],["faa1","È¥¥ÂáâÂáèÂáë„≥úÂáì§™¶ÂÜ≥Âá¢ÂçÇÂá≠ËèçÊ§æ£ú≠ÂΩªÂàãÂà¶ÂàºÂäµÂâóÂäîÂäπÂãÖÁ∞ïËïÇÂã†Ëòç¶¨ìÂåÖ®´ûÂïâÊªô£æÄ†•î£ø¨Âå≥ÂçÑ†Ø¢Ê≥ã°ú¶Ê†õÁèïÊÅä„∫™„£å°õ®Ááù‰í¢Âç≠Âç¥®ö´ÂçæÂçø°ññ°òìÁü¶Âéì®™õÂé†Âé´ÂéÆÁéß•ù≤„ΩôÁéúÂèÅÂèÖÊ±â‰πâÂüæÂèô„™´†ÆèÂè†£ø´¢∂£Âè∂†±∑ÂêìÁÅπÂî´ÊôóÊµõÂë≠¶≠ì†µ¥ÂïùÂíèÂí§‰û¶°úç†ªù„∂¥†µç"],["fb40","®¶º¢öòÂïá‰≥≠ÂêØÁêóÂñÜÂñ©ÂòÖ°£ó§Ä∫‰ïí§êµÊö≥°Ç¥Âò∑Êõç£ääÊö§Êö≠ÂôçÂôèÁ£±Âõ±ÈûáÂèæÂúÄÂõØÂõ≠®≠¶„ò£°âèÂùÜ§Ü•Ê±ÆÁÇãÂùÇ„ö±¶±æÂü¶°êñÂ†É°ëî§ç£Â†¶§ØµÂ°úÂ¢™„ï°Â£†Â£ú°àºÂ£ªÂØøÂùÉ™Öê§â∏Èèì„ñ°Â§üÊ¢¶„õÉÊπô"],["fba1","°òæÂ®§Âïì°öíËîÖÂßâ†µé¶≤Å¶¥™°üúÂßô°üª°û≤¶∂¶Êµ±°†®°õïÂßπ¶πÖÂ™´Â©£„õ¶§¶©Â©∑„úàÂ™ñÁë•Â´ì¶æ°¢ïî„∂Ö°§ë„ú≤°ö∏Â∫ÉÂãêÂ≠∂ÊñàÂ≠ºß®é‰ÄÑ‰°ù†àÑÂØïÊÖ†°®¥•ßå†ñ•ÂØ≥ÂÆù‰¥êÂ∞Ö°≠ÑÂ∞ìÁèéÂ∞î°≤•¶¨®Â±â‰£ùÂ≤ÖÂ≥©Â≥ØÂ∂ã°∑π°∏∑Â¥êÂ¥òÂµÜ°∫§Â≤∫Â∑óËãº„†≠§§Å¢Åâ¢Ö≥Ëäá„†∂„ØÇÂ∏ÆÊ™äÂπµÂπ∫§íº†≥ìÂé¶‰∫∑ÂªêÂé®°ù±Â∏âÂª¥®íÇ"],["fc40","ÂªπÂªª„¢†ÂªºÊ†æÈêõÂºç†áÅØ¢î„´û‰¢Æ°å∫Âº∫¶¢à¢èêÂΩò¢ë±ÂΩ£ÈûΩ¶πÆÂΩ≤ÈçÄ®®∂ÂæßÂ∂∂„µü•âê°Ω™ßÉ∏¢ô®Èáñ†äû®®©ÊÄ±ÊöÖ°°∑„•£„∑á„òπÂûê¢û¥Á•±„πÄÊÇûÊÇ§ÊÇ≥§¶Ç§¶èß©ìÁí§ÂÉ°Â™†ÊÖ§Ëê§ÊÖÇØ¢¶¶ªíÊÜÅÂá¥†ôñÊÜáÂÆ™£æ∑"],["fca1","¢°üÊáì®Æù©•ùÊáê„§≤¢¶Ä¢£ÅÊÄ£ÊÖúÊîûÊéã†ÑòÊãÖ°ù∞Êãï¢∏çÊç¨§ßü„®óÊê∏Êè∏°éé°üºÊíêÊæä¢∏∂È†î§Çå•úùÊì°Êì•Èëª„©¶Êê∫„©óÊïçÊºñ§®®§®£ÊñÖÊï≠Êïü£ÅæÊñµ§•Ä‰¨∑Êóë‰Éò°†©Êó†Êó£Âøü£êÄÊòò£á∑£á∏ÊôÑ£Ü§£Ü•Êôã†πµÊôß•á¶Êô≥Êô¥°∏Ω£à±®ó¥£áà•åìÁüÖ¢£∑È¶§ÊúÇ§éú§®°„¨´Êß∫£üÇÊùûÊùßÊù¢§áç©É≠Êüó‰ì©Ê†¢ÊπêÈàºÊ†Å£è¶¶∂†Ê°ù"],["fd40","£ëØÊß°Ê®ã®´üÊ•≥Ê£É£óçÊ§ÅÊ§Ä„¥≤„®Å£òº„ÆÄÊû¨Ê•°®©ä‰ãºÊ§∂Ê¶ò„Æ°†èâËç£ÂÇêÊßπ£ôô¢Ñ™Ê©Ö£úÉÊ™ù„Ø≥Êû±Ê´à©Üú„∞çÊ¨ù†§£ÊÉûÊ¨µÊ≠¥¢üçÊ∫µ£´õ†éµ°•ò„ùÄÂê°£≠öÊØ°£ªºÊØúÊ∞∑¢íã§£±¶≠ëÊ±öËà¶Ê±π£∂º‰ìÖ£∂Ω§Ü§§§å§§Ä"],["fda1","£≥â„õ•„≥´†¥≤ÈÆÉ£áπ¢íëÁæèÊ†∑¶¥•¶∂°¶∑´Ê∂ñÊµúÊπºÊºÑ§•ø§ÇÖ¶π≤Ëî≥¶Ω¥ÂááÊ≤úÊ∏ùËêÆ®¨°Ê∏Ø£∏ØÁëì£æÇÁßåÊπèÂ™ë£ÅãÊø∏„úçÊæù£∏∞Êª∫°íó§ÄΩ‰ïïÈè∞ÊΩÑÊΩú„µéÊΩ¥©Ö∞„¥ªÊæü§ÖÑÊøì§Çë§Öï§Äπ£ø∞£æ¥§ÑøÂáü§Öñ§Öó§ÖÄ¶áùÁÅãÁÅæÁÇßÁÇÅÁÉåÁÉïÁÉñÁÉü‰ÑÑ„∑®ÁÜ¥ÁÜñ§â∑ÁÑ´ÁÖÖÂ™àÁÖäÁÖÆÂ≤ú§ç•ÁÖèÈç¢§ãÅÁÑ¨§ëö§®ß§®¢ÁÜ∫®Ø®ÁÇΩÁàé"],["fe40","ÈëÇÁàïÂ§ëÈëÉÁà§ÈçÅ•òÖÁàÆÁâÄ§•¥Ê¢ΩÁâïÁâó„πï£ÅÑÊ†çÊºΩÁäÇÁå™Áå´§†£®†´‰£≠®†ÑÁå®ÁåÆÁèèÁé™†∞∫¶®ÆÁèâÁëâ§á¢°õß§®§Êò£„õÖ§¶∑§¶ç§ßªÁè∑ÁêïÊ§É§®¶Áêπ†óÉ„ªóÁëú¢¢≠Áë†®∫≤ÁëáÁè§Áë∂ËéπÁë¨„ú∞Áë¥Èè±Ê®¨ÁíÇ‰•ì§™å"],["fea1","§Öü§©π®ÆèÂ≠Ü®∞É°¢ûÁìà°¶àÁîéÁì©Áîû®ªô°©ãÂØó®∫¨ÈéÖÁïçÁïäÁïßÁïÆ§æÇ„ºÑ§¥ìÁñéÁëùÁñûÁñ¥ÁòÇÁò¨ÁôëÁôèÁôØÁô∂¶èµÁöêËáØ„ü∏¶§ë¶§éÁö°Áö•Áö∑Áõå¶æüËë¢•Çù•ÖΩ°∏úÁúûÁú¶ÁùÄÊíØ•à†Áùò£ä¨ÁûØ®•§®•®°õÅÁü¥Á†â°ç∂§®íÊ£äÁ¢ØÁ£áÁ£ìÈö•Á§Æ•ó†Á£óÁ§¥Á¢±ßòåËæ∏Ë¢Ñ®¨´¶ÇÉ¢òúÁ¶ÜË§ÄÊ§ÇÁ¶Ä•°óÁ¶ùß¨πÁ§ºÁ¶©Ê∏™ßÑ¶„∫®ÁßÜ©ÑçÁßî"]]');

/***/ }),

/***/ 952:
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('[["0","\\u0000",127,"‚Ç¨"],["8140","‰∏Ç‰∏Ñ‰∏Ö‰∏Ü‰∏è‰∏í‰∏ó‰∏ü‰∏†‰∏°‰∏£‰∏¶‰∏©‰∏Æ‰∏Ø‰∏±‰∏≥‰∏µ‰∏∑‰∏º‰πÄ‰πÅ‰πÇ‰πÑ‰πÜ‰πä‰πë‰πï‰πó‰πö‰πõ‰π¢‰π£‰π§‰π•‰πß‰π®‰π™",5,"‰π≤‰π¥",9,"‰πø",6,"‰∫á‰∫ä"],["8180","‰∫ê‰∫ñ‰∫ó‰∫ô‰∫ú‰∫ù‰∫û‰∫£‰∫™‰∫Ø‰∫∞‰∫±‰∫¥‰∫∂‰∫∑‰∫∏‰∫π‰∫º‰∫Ω‰∫æ‰ªà‰ªå‰ªè‰ªê‰ªí‰ªö‰ªõ‰ªú‰ª†‰ª¢‰ª¶‰ªß‰ª©‰ª≠‰ªÆ‰ªØ‰ª±‰ª¥‰ª∏‰ªπ‰ª∫‰ªº‰ªæ‰ºÄ‰ºÇ",6,"‰ºã‰ºå‰ºí",4,"‰ºú‰ºù‰º°‰º£‰º®‰º©‰º¨‰º≠‰ºÆ‰º±‰º≥‰ºµ‰º∑‰ºπ‰ºª‰ºæ",4,"‰ΩÑ‰ΩÖ‰Ωá",5,"‰Ωí‰Ωî‰Ωñ‰Ω°‰Ω¢‰Ω¶‰Ω®‰Ω™‰Ω´‰Ω≠‰ΩÆ‰Ω±‰Ω≤‰Ωµ‰Ω∑‰Ω∏‰Ωπ‰Ω∫‰ΩΩ‰æÄ‰æÅ‰æÇ‰æÖ‰æÜ‰æá‰æä‰æå‰æé‰æê‰æí‰æì‰æï‰æñ‰æò‰æô‰æö‰æú‰æû‰æü‰æ°‰æ¢"],["8240","‰æ§‰æ´‰æ≠‰æ∞",4,"‰æ∂",8,"‰øÄ‰øÅ‰øÇ‰øÜ‰øá‰øà‰øâ‰øã‰øå‰øç‰øí",4,"‰øô‰øõ‰ø†‰ø¢‰ø§‰ø•‰øß‰ø´‰ø¨‰ø∞‰ø≤‰ø¥‰øµ‰ø∂‰ø∑‰øπ‰øª‰øº‰øΩ‰øø",11],["8280","ÂÄãÂÄéÂÄêÂÄëÂÄìÂÄïÂÄñÂÄóÂÄõÂÄùÂÄûÂÄ†ÂÄ¢ÂÄ£ÂÄ§ÂÄßÂÄ´ÂÄØ",10,"ÂÄªÂÄΩÂÄøÂÅÄÂÅÅÂÅÇÂÅÑÂÅÖÂÅÜÂÅâÂÅäÂÅãÂÅçÂÅê",4,"ÂÅñÂÅóÂÅòÂÅôÂÅõÂÅù",7,"ÂÅ¶",5,"ÂÅ≠",8,"ÂÅ∏ÂÅπÂÅ∫ÂÅºÂÅΩÂÇÅÂÇÇÂÇÉÂÇÑÂÇÜÂÇáÂÇâÂÇäÂÇãÂÇåÂÇé",20,"ÂÇ§ÂÇ¶ÂÇ™ÂÇ´ÂÇ≠",4,"ÂÇ≥",6,"ÂÇº"],["8340","ÂÇΩ",17,"ÂÉê",5,"ÂÉóÂÉòÂÉôÂÉõ",10,"ÂÉ®ÂÉ©ÂÉ™ÂÉ´ÂÉØÂÉ∞ÂÉ±ÂÉ≤ÂÉ¥ÂÉ∂",4,"ÂÉº",9,"ÂÑà"],["8380","ÂÑâÂÑäÂÑå",5,"ÂÑì",13,"ÂÑ¢",28,"ÂÖÇÂÖáÂÖäÂÖåÂÖéÂÖèÂÖêÂÖíÂÖìÂÖóÂÖòÂÖôÂÖõÂÖù",4,"ÂÖ£ÂÖ§ÂÖ¶ÂÖßÂÖ©ÂÖ™ÂÖØÂÖ≤ÂÖ∫ÂÖæÂÖøÂÜÉÂÜÑÂÜÜÂÜáÂÜäÂÜãÂÜéÂÜèÂÜêÂÜëÂÜìÂÜîÂÜòÂÜöÂÜùÂÜûÂÜüÂÜ°ÂÜ£ÂÜ¶",4,"ÂÜ≠ÂÜÆÂÜ¥ÂÜ∏ÂÜπÂÜ∫ÂÜæÂÜøÂáÅÂáÇÂáÉÂáÖÂáàÂáäÂáçÂáéÂáêÂáí",5],["8440","ÂáòÂáôÂáöÂáúÂáûÂáüÂá¢Âá£Âá•",5,"Âá¨ÂáÆÂá±Âá≤Âá¥Âá∑ÂáæÂàÑÂàÖÂàâÂàãÂàåÂàèÂàêÂàìÂàîÂàïÂàúÂàûÂàüÂà°Âà¢Âà£Âà•Âà¶ÂàßÂà™Âà¨ÂàØÂà±Âà≤Âà¥ÂàµÂàºÂàæÂâÑ",5,"ÂâãÂâéÂâèÂâíÂâìÂâïÂâóÂâò"],["8480","ÂâôÂâöÂâõÂâùÂâüÂâ†Ââ¢Ââ£Ââ§Ââ¶Ââ®Ââ´Ââ¨Ââ≠ÂâÆÂâ∞Ââ±Ââ≥",9,"ÂâæÂäÄÂäÉ",4,"Âäâ",6,"ÂäëÂäíÂäî",6,"ÂäúÂä§Âä•Âä¶ÂäßÂäÆÂäØÂä∞Âä¥",9,"ÂãÄÂãÅÂãÇÂãÑÂãÖÂãÜÂãàÂãäÂãåÂãçÂãéÂãèÂãëÂãìÂãîÂãïÂãóÂãô",5,"Âã†Âã°Âã¢Âã£Âã•",10,"Âã±",7,"ÂãªÂãºÂãΩÂåÅÂåÇÂåÉÂåÑÂåáÂåâÂåäÂåãÂååÂåé"],["8540","ÂåëÂåíÂåìÂåîÂåòÂåõÂåúÂåûÂåüÂå¢Âå§Âå•ÂåßÂå®Âå©Âå´Âå¨Âå≠ÂåØ",9,"ÂåºÂåΩÂçÄÂçÇÂçÑÂçÜÂçãÂçåÂççÂçêÂçîÂçòÂçôÂçõÂçùÂç•Âç®Âç™Âç¨Âç≠Âç≤Âç∂ÂçπÂçªÂçºÂçΩÂçæÂéÄÂéÅÂéÉÂéáÂéàÂéäÂééÂéè"],["8580","Âéê",4,"ÂéñÂéóÂéôÂéõÂéúÂéûÂé†Âé°Âé§ÂéßÂé™Âé´Âé¨Âé≠ÂéØ",6,"Âé∑Âé∏ÂéπÂé∫ÂéºÂéΩÂéæÂèÄÂèÉ",4,"ÂèéÂèèÂèêÂèíÂèìÂèïÂèöÂèúÂèùÂèûÂè°Âè¢ÂèßÂè¥Âè∫ÂèæÂèøÂêÄÂêÇÂêÖÂêáÂêãÂêîÂêòÂêôÂêöÂêúÂê¢Âê§Âê•Âê™Âê∞Âê≥Âê∂Âê∑Âê∫ÂêΩÂêøÂëÅÂëÇÂëÑÂëÖÂëáÂëâÂëåÂëçÂëéÂëèÂëëÂëöÂëù",4,"Âë£Âë•ÂëßÂë©",7,"Âë¥ÂëπÂë∫ÂëæÂëøÂíÅÂíÉÂíÖÂíáÂíàÂíâÂíäÂíçÂíëÂíìÂíóÂíòÂíúÂíûÂíüÂí†Âí°"],["8640","Âí¢Âí•ÂíÆÂí∞Âí≤ÂíµÂí∂Âí∑ÂíπÂí∫ÂíºÂíæÂìÉÂìÖÂìäÂìãÂìñÂìòÂìõÂì†",4,"Âì´Âì¨ÂìØÂì∞Âì±Âì¥",5,"ÂìªÂìæÂîÄÂîÇÂîÉÂîÑÂîÖÂîàÂîä",4,"ÂîíÂîìÂîï",5,"ÂîúÂîùÂîûÂîüÂî°Âî•Âî¶"],["8680","Âî®Âî©Âî´Âî≠Âî≤Âî¥ÂîµÂî∂Âî∏ÂîπÂî∫ÂîªÂîΩÂïÄÂïÇÂïÖÂïáÂïàÂïã",4,"ÂïëÂïíÂïìÂïîÂïó",4,"ÂïùÂïûÂïüÂï†Âï¢Âï£Âï®Âï©Âï´ÂïØ",5,"ÂïπÂï∫ÂïΩÂïøÂñÖÂñÜÂñåÂñçÂñéÂñêÂñíÂñìÂñïÂññÂñóÂñöÂñõÂñûÂñ†",6,"Âñ®",8,"Âñ≤Âñ¥Âñ∂Âñ∏Âñ∫ÂñºÂñø",4,"ÂóÜÂóáÂóàÂóäÂóãÂóéÂóèÂóêÂóïÂóó",4,"ÂóûÂó†Âó¢ÂóßÂó©Âó≠ÂóÆÂó∞Âó±Âó¥Âó∂Âó∏",4,"ÂóøÂòÇÂòÉÂòÑÂòÖ"],["8740","ÂòÜÂòáÂòäÂòãÂòçÂòê",7,"ÂòôÂòöÂòúÂòùÂò†Âò°Âò¢Âò•Âò¶Âò®Âò©Âò™Âò´ÂòÆÂòØÂò∞Âò≥ÂòµÂò∑Âò∏Âò∫ÂòºÂòΩÂòæÂôÄ",11,"Âôè",4,"ÂôïÂôñÂôöÂôõÂôù",4],["8780","Âô£Âô•Âô¶ÂôßÂô≠ÂôÆÂôØÂô∞Âô≤Âô≥Âô¥ÂôµÂô∑Âô∏ÂôπÂô∫ÂôΩ",7,"Âöá",6,"ÂöêÂöëÂöíÂöî",14,"Âö§",10,"Âö∞",6,"Âö∏ÂöπÂö∫ÂöªÂöΩ",12,"Âõã",8,"ÂõïÂõñÂõòÂõôÂõúÂõ£Âõ•",5,"Âõ¨ÂõÆÂõØÂõ≤Âõ≥Âõ∂Âõ∑Âõ∏ÂõªÂõºÂúÄÂúÅÂúÇÂúÖÂúáÂúã",6],["8840","Âúí",9,"ÂúùÂúûÂú†Âú°Âú¢Âú§Âú•Âú¶ÂúßÂú´Âú±Âú≤Âú¥",4,"ÂúºÂúΩÂúøÂùÅÂùÉÂùÑÂùÖÂùÜÂùàÂùâÂùãÂùí",4,"ÂùòÂùôÂù¢Âù£Âù•ÂùßÂù¨ÂùÆÂù∞Âù±Âù≤Âù¥ÂùµÂù∏ÂùπÂù∫ÂùΩÂùæÂùøÂûÄ"],["8880","ÂûÅÂûáÂûàÂûâÂûäÂûç",4,"Âûî",6,"ÂûúÂûùÂûûÂûüÂû•Âû®Âû™Âû¨ÂûØÂû∞Âû±Âû≥ÂûµÂû∂Âû∑Âûπ",8,"ÂüÑ",6,"ÂüåÂüçÂüêÂüëÂüìÂüñÂüóÂüõÂüúÂüûÂü°Âü¢Âü£Âü•",7,"ÂüÆÂü∞Âü±Âü≤Âü≥ÂüµÂü∂Âü∑ÂüªÂüºÂüæÂüøÂ†ÅÂ†ÉÂ†ÑÂ†ÖÂ†àÂ†âÂ†äÂ†åÂ†éÂ†èÂ†êÂ†íÂ†ìÂ†îÂ†ñÂ†óÂ†òÂ†öÂ†õÂ†úÂ†ùÂ†üÂ†¢Â†£Â†•",4,"Â†´",4,"Â†±Â†≤Â†≥Â†¥Â†∂",7],["8940","Â†æ",5,"Â°Ö",6,"Â°éÂ°èÂ°êÂ°íÂ°ìÂ°ïÂ°ñÂ°óÂ°ô",4,"Â°ü",5,"Â°¶",4,"Â°≠",16,"Â°øÂ¢ÇÂ¢ÑÂ¢ÜÂ¢áÂ¢àÂ¢äÂ¢ãÂ¢å"],["8980","Â¢ç",4,"Â¢î",4,"Â¢õÂ¢úÂ¢ùÂ¢†",7,"Â¢™",17,"Â¢ΩÂ¢æÂ¢øÂ£ÄÂ£ÇÂ£ÉÂ£ÑÂ£Ü",10,"Â£íÂ£ìÂ£îÂ£ñ",13,"Â£•",5,"Â£≠Â£ØÂ£±Â£≤Â£¥Â£µÂ£∑Â£∏Â£∫",7,"Â§ÉÂ§ÖÂ§ÜÂ§à",4,"Â§éÂ§êÂ§ëÂ§íÂ§ìÂ§óÂ§òÂ§õÂ§ùÂ§ûÂ§†Â§°Â§¢Â§£Â§¶Â§®Â§¨Â§∞Â§≤Â§≥Â§µÂ§∂Â§ª"],["8a40","Â§ΩÂ§æÂ§øÂ•ÄÂ•ÉÂ•ÖÂ•ÜÂ•äÂ•åÂ•çÂ•êÂ•íÂ•ìÂ•ôÂ•õ",4,"Â•°Â•£Â•§Â•¶",12,"Â•µÂ•∑Â•∫Â•ªÂ•ºÂ•æÂ•øÂ¶ÄÂ¶ÖÂ¶âÂ¶ãÂ¶åÂ¶éÂ¶èÂ¶êÂ¶ëÂ¶îÂ¶ïÂ¶òÂ¶öÂ¶õÂ¶úÂ¶ùÂ¶üÂ¶†Â¶°Â¶¢Â¶¶"],["8a80","Â¶ßÂ¶¨Â¶≠Â¶∞Â¶±Â¶≥",5,"Â¶∫Â¶ºÂ¶ΩÂ¶ø",6,"ÂßáÂßàÂßâÂßåÂßçÂßéÂßèÂßïÂßñÂßôÂßõÂßû",4,"Âß§Âß¶ÂßßÂß©Âß™Âß´Âß≠",11,"Âß∫ÂßºÂßΩÂßæÂ®ÄÂ®ÇÂ®äÂ®ãÂ®çÂ®éÂ®èÂ®êÂ®íÂ®îÂ®ïÂ®ñÂ®óÂ®ôÂ®öÂ®õÂ®ùÂ®ûÂ®°Â®¢Â®§Â®¶Â®ßÂ®®Â®™",6,"Â®≥Â®µÂ®∑",4,"Â®ΩÂ®æÂ®øÂ©Å",4,"Â©áÂ©àÂ©ã",9,"Â©ñÂ©óÂ©òÂ©ôÂ©õ",5],["8b40","Â©°Â©£Â©§Â©•Â©¶Â©®Â©©Â©´",8,"Â©∏Â©πÂ©ªÂ©ºÂ©ΩÂ©æÂ™Ä",17,"Â™ì",6,"Â™ú",13,"Â™´Â™¨"],["8b80","Â™≠",4,"Â™¥Â™∂Â™∑Â™π",4,"Â™øÂ´ÄÂ´É",5,"Â´äÂ´ãÂ´ç",4,"Â´ìÂ´ïÂ´óÂ´ôÂ´öÂ´õÂ´ùÂ´ûÂ´üÂ´¢Â´§Â´•Â´ßÂ´®Â´™Â´¨",4,"Â´≤",22,"Â¨ä",11,"Â¨ò",25,"Â¨≥Â¨µÂ¨∂Â¨∏",7,"Â≠Å",6],["8c40","Â≠à",7,"Â≠íÂ≠ñÂ≠ûÂ≠†Â≠°Â≠ßÂ≠®Â≠´Â≠≠Â≠ÆÂ≠ØÂ≠≤Â≠¥Â≠∂Â≠∑Â≠∏Â≠πÂ≠ªÂ≠ºÂ≠æÂ≠øÂÆÇÂÆÜÂÆäÂÆçÂÆéÂÆêÂÆëÂÆíÂÆîÂÆñÂÆüÂÆßÂÆ®ÂÆ©ÂÆ¨ÂÆ≠ÂÆÆÂÆØÂÆ±ÂÆ≤ÂÆ∑ÂÆ∫ÂÆªÂÆºÂØÄÂØÅÂØÉÂØàÂØâÂØäÂØãÂØçÂØéÂØè"],["8c80","ÂØëÂØî",8,"ÂØ†ÂØ¢ÂØ£ÂØ¶ÂØßÂØ©",4,"ÂØØÂØ±",6,"ÂØΩÂØæÂ∞ÄÂ∞ÇÂ∞ÉÂ∞ÖÂ∞áÂ∞àÂ∞ãÂ∞åÂ∞çÂ∞éÂ∞êÂ∞íÂ∞ìÂ∞óÂ∞ôÂ∞õÂ∞ûÂ∞üÂ∞†Â∞°Â∞£Â∞¶Â∞®Â∞©Â∞™Â∞´Â∞≠Â∞ÆÂ∞ØÂ∞∞Â∞≤Â∞≥Â∞µÂ∞∂Â∞∑Â±ÉÂ±ÑÂ±ÜÂ±áÂ±åÂ±çÂ±íÂ±ìÂ±îÂ±ñÂ±óÂ±òÂ±öÂ±õÂ±úÂ±ùÂ±üÂ±¢Â±§Â±ß",6,"Â±∞Â±≤",6,"Â±ªÂ±ºÂ±ΩÂ±æÂ≤ÄÂ≤É",4,"Â≤âÂ≤äÂ≤ãÂ≤éÂ≤èÂ≤íÂ≤ìÂ≤ïÂ≤ù",4,"Â≤§",4],["8d40","Â≤™Â≤ÆÂ≤ØÂ≤∞Â≤≤Â≤¥Â≤∂Â≤πÂ≤∫Â≤ªÂ≤ºÂ≤æÂ≥ÄÂ≥ÇÂ≥ÉÂ≥Ö",5,"Â≥å",5,"Â≥ì",5,"Â≥ö",6,"Â≥¢Â≥£Â≥ßÂ≥©Â≥´Â≥¨Â≥ÆÂ≥ØÂ≥±",9,"Â≥º",4],["8d80","Â¥ÅÂ¥ÑÂ¥ÖÂ¥à",5,"Â¥è",4,"Â¥ïÂ¥óÂ¥òÂ¥ôÂ¥öÂ¥úÂ¥ùÂ¥ü",4,"Â¥•Â¥®Â¥™Â¥´Â¥¨Â¥Ø",4,"Â¥µ",7,"Â¥ø",7,"ÂµàÂµâÂµç",10,"ÂµôÂµöÂµúÂµû",10,"Âµ™Âµ≠ÂµÆÂµ∞Âµ±Âµ≤Âµ≥Âµµ",12,"Â∂É",21,"Â∂öÂ∂õÂ∂úÂ∂ûÂ∂üÂ∂†"],["8e40","Â∂°",21,"Â∂∏",12,"Â∑Ü",6,"Â∑é",12,"Â∑úÂ∑üÂ∑†Â∑£Â∑§Â∑™Â∑¨Â∑≠"],["8e80","Â∑∞Â∑µÂ∑∂Â∑∏",4,"Â∑øÂ∏ÄÂ∏ÑÂ∏áÂ∏âÂ∏äÂ∏ãÂ∏çÂ∏éÂ∏íÂ∏ìÂ∏óÂ∏û",7,"Â∏®",4,"Â∏ØÂ∏∞Â∏≤",4,"Â∏πÂ∏∫Â∏æÂ∏øÂπÄÂπÅÂπÉÂπÜ",5,"Âπç",6,"Âπñ",4,"ÂπúÂπùÂπüÂπ†Âπ£",14,"ÂπµÂπ∑ÂππÂπæÂ∫ÅÂ∫ÇÂ∫ÉÂ∫ÖÂ∫àÂ∫âÂ∫åÂ∫çÂ∫éÂ∫íÂ∫òÂ∫õÂ∫ùÂ∫°Â∫¢Â∫£Â∫§Â∫®",4,"Â∫Æ",4,"Â∫¥Â∫∫Â∫ªÂ∫ºÂ∫ΩÂ∫ø",6],["8f40","ÂªÜÂªáÂªàÂªã",5,"ÂªîÂªïÂªóÂªòÂªôÂªöÂªú",11,"Âª©Âª´",8,"ÂªµÂª∏ÂªπÂªªÂªºÂªΩÂºÖÂºÜÂºáÂºâÂºåÂºçÂºéÂºêÂºíÂºîÂºñÂºôÂºöÂºúÂºùÂºûÂº°Âº¢Âº£Âº§"],["8f80","Âº®Âº´Âº¨ÂºÆÂº∞Âº≤",6,"ÂºªÂºΩÂºæÂºøÂΩÅ",14,"ÂΩëÂΩîÂΩôÂΩöÂΩõÂΩúÂΩûÂΩüÂΩ†ÂΩ£ÂΩ•ÂΩßÂΩ®ÂΩ´ÂΩÆÂΩØÂΩ≤ÂΩ¥ÂΩµÂΩ∂ÂΩ∏ÂΩ∫ÂΩΩÂΩæÂΩøÂæÉÂæÜÂæçÂæéÂæèÂæëÂæìÂæîÂæñÂæöÂæõÂæùÂæûÂæüÂæ†Âæ¢",5,"Âæ©Âæ´Âæ¨ÂæØ",5,"Âæ∂Âæ∏ÂæπÂæ∫ÂæªÂææ",4,"ÂøáÂøàÂøäÂøãÂøéÂøìÂøîÂøïÂøöÂøõÂøúÂøûÂøüÂø¢Âø£Âø•Âø¶Âø®Âø©Âø¨ÂøØÂø∞Âø≤Âø≥Âø¥Âø∂Âø∑ÂøπÂø∫ÂøºÊÄá"],["9040","ÊÄàÊÄâÊÄãÊÄåÊÄêÊÄëÊÄìÊÄóÊÄòÊÄöÊÄûÊÄüÊÄ¢ÊÄ£ÊÄ§ÊÄ¨ÊÄ≠ÊÄÆÊÄ∞",4,"ÊÄ∂",4,"ÊÄΩÊÄæÊÅÄÊÅÑ",6,"ÊÅåÊÅéÊÅèÊÅëÊÅìÊÅîÊÅñÊÅóÊÅòÊÅõÊÅúÊÅûÊÅüÊÅ†ÊÅ°ÊÅ•ÊÅ¶ÊÅÆÊÅ±ÊÅ≤ÊÅ¥ÊÅµÊÅ∑ÊÅæÊÇÄ"],["9080","ÊÇÅÊÇÇÊÇÖÊÇÜÊÇáÊÇàÊÇäÊÇãÊÇéÊÇèÊÇêÊÇëÊÇìÊÇïÊÇóÊÇòÊÇôÊÇúÊÇûÊÇ°ÊÇ¢ÊÇ§ÊÇ•ÊÇßÊÇ©ÊÇ™ÊÇÆÊÇ∞ÊÇ≥ÊÇµÊÇ∂ÊÇ∑ÊÇπÊÇ∫ÊÇΩ",7,"ÊÉáÊÉàÊÉâÊÉå",4,"ÊÉíÊÉìÊÉîÊÉñÊÉóÊÉôÊÉõÊÉûÊÉ°",4,"ÊÉ™ÊÉ±ÊÉ≤ÊÉµÊÉ∑ÊÉ∏ÊÉª",4,"ÊÑÇÊÑÉÊÑÑÊÑÖÊÑáÊÑäÊÑãÊÑåÊÑê",4,"ÊÑñÊÑóÊÑòÊÑôÊÑõÊÑúÊÑùÊÑûÊÑ°ÊÑ¢ÊÑ•ÊÑ®ÊÑ©ÊÑ™ÊÑ¨",18,"ÊÖÄ",6],["9140","ÊÖáÊÖâÊÖãÊÖçÊÖèÊÖêÊÖíÊÖìÊÖîÊÖñ",6,"ÊÖûÊÖüÊÖ†ÊÖ°ÊÖ£ÊÖ§ÊÖ•ÊÖ¶ÊÖ©",6,"ÊÖ±ÊÖ≤ÊÖ≥ÊÖ¥ÊÖ∂ÊÖ∏",18,"ÊÜåÊÜçÊÜè",4,"ÊÜï"],["9180","ÊÜñ",6,"ÊÜû",8,"ÊÜ™ÊÜ´ÊÜ≠",9,"ÊÜ∏",5,"ÊÜøÊáÄÊáÅÊáÉ",4,"ÊáâÊáå",4,"ÊáìÊáï",16,"Êáß",13,"Êá∂",8,"ÊàÄ",5,"ÊàáÊàâÊàìÊàîÊàôÊàúÊàùÊàûÊà†Êà£Êà¶ÊàßÊà®Êà©Êà´Êà≠ÊàØÊà∞Êà±Êà≤ÊàµÊà∂Êà∏",4,"ÊâÇÊâÑÊâÖÊâÜÊâä"],["9240","ÊâèÊâêÊâïÊâñÊâóÊâôÊâöÊâú",6,"Êâ§Êâ•Êâ®Êâ±Êâ≤Êâ¥ÊâµÊâ∑Êâ∏Êâ∫ÊâªÊâΩÊäÅÊäÇÊäÉÊäÖÊäÜÊäáÊäàÊäã",5,"ÊäîÊäôÊäúÊäùÊäûÊä£Êä¶ÊäßÊä©Êä™Êä≠ÊäÆÊäØÊä∞Êä≤Êä≥Êä¥Êä∂Êä∑Êä∏Êä∫ÊäæÊãÄÊãÅ"],["9280","ÊãÉÊããÊãèÊãëÊãïÊãùÊãûÊã†Êã°Êã§Êã™Êã´Êã∞Êã≤ÊãµÊã∏ÊãπÊã∫ÊãªÊåÄÊåÉÊåÑÊåÖÊåÜÊåäÊåãÊååÊåçÊåèÊåêÊåíÊåìÊåîÊåïÊåóÊåòÊåôÊåúÊå¶ÊåßÊå©Êå¨Êå≠ÊåÆÊå∞Êå±Êå≥",5,"ÊåªÊåºÊåæÊåøÊçÄÊçÅÊçÑÊçáÊçàÊçäÊçëÊçíÊçìÊçîÊçñ",7,"Êç†Êç§Êç•Êç¶Êç®Êç™Êç´Êç¨ÊçØÊç∞Êç≤Êç≥Êç¥ÊçµÊç∏ÊçπÊçºÊçΩÊçæÊçøÊéÅÊéÉÊéÑÊéÖÊéÜÊéãÊéçÊéëÊéìÊéîÊéïÊéóÊéô",6,"Êé°Êé§Êé¶Êé´ÊéØÊé±Êé≤ÊéµÊé∂ÊéπÊéªÊéΩÊéøÊèÄ"],["9340","ÊèÅÊèÇÊèÉÊèÖÊèáÊèàÊèäÊèãÊèåÊèëÊèìÊèîÊèïÊèó",6,"ÊèüÊè¢Êè§",4,"Êè´Êè¨ÊèÆÊèØÊè∞Êè±Êè≥ÊèµÊè∑ÊèπÊè∫ÊèªÊèºÊèæÊêÉÊêÑÊêÜ",4,"ÊêçÊêéÊêëÊêíÊêï",5,"ÊêùÊêüÊê¢Êê£Êê§"],["9380","Êê•ÊêßÊê®Êê©Êê´ÊêÆ",5,"Êêµ",4,"ÊêªÊêºÊêæÊëÄÊëÇÊëÉÊëâÊëã",6,"ÊëìÊëïÊëñÊëóÊëô",4,"Êëü",7,"Êë®Êë™Êë´Êë¨ÊëÆ",9,"Êëª",6,"ÊíÉÊíÜÊíà",8,"ÊíìÊíîÊíóÊíòÊíöÊíõÊíúÊíùÊíü",4,"Êí•Êí¶ÊíßÊí®Êí™Êí´ÊíØÊí±Êí≤Êí≥Êí¥Êí∂ÊíπÊíªÊíΩÊíæÊíøÊìÅÊìÉÊìÑÊìÜ",6,"ÊìèÊìëÊììÊìîÊìïÊìñÊìôÊìö"],["9440","ÊìõÊìúÊìùÊìüÊì†Êì°Êì£Êì•Êìß",24,"ÊîÅ",7,"Êîä",7,"Êîì",4,"Êîô",8],["9480","Êî¢Êî£Êî§Êî¶",4,"Êî¨Êî≠Êî∞Êî±Êî≤Êî≥Êî∑Êî∫ÊîºÊîΩÊïÄ",4,"ÊïÜÊïáÊïäÊïãÊïçÊïéÊïêÊïíÊïìÊïîÊïóÊïòÊïöÊïúÊïüÊï†Êï°Êï§Êï•ÊïßÊï®Êï©Êï™Êï≠ÊïÆÊïØÊï±Êï≥ÊïµÊï∂Êï∏",14,"ÊñàÊñâÊñäÊñçÊñéÊñèÊñíÊñîÊñïÊññÊñòÊñöÊñùÊñûÊñ†Êñ¢Êñ£Êñ¶Êñ®Êñ™Êñ¨ÊñÆÊñ±",7,"Êñ∫ÊñªÊñæÊñøÊóÄÊóÇÊóáÊóàÊóâÊóäÊóçÊóêÊóëÊóìÊóîÊóïÊóò",7,"Êó°Êó£Êó§Êó™Êó´"],["9540","Êó≤Êó≥Êó¥ÊóµÊó∏ÊóπÊóª",4,"ÊòÅÊòÑÊòÖÊòáÊòàÊòâÊòãÊòçÊòêÊòëÊòíÊòñÊòóÊòòÊòöÊòõÊòúÊòûÊò°Êò¢Êò£Êò§Êò¶Êò©Êò™Êò´Êò¨ÊòÆÊò∞Êò≤Êò≥Êò∑",4,"ÊòΩÊòøÊôÄÊôÇÊôÑ",6,"ÊôçÊôéÊôêÊôëÊôò"],["9580","ÊôôÊôõÊôúÊôùÊôûÊô†Êô¢Êô£Êô•ÊôßÊô©",4,"Êô±Êô≤Êô≥ÊôµÊô∏ÊôπÊôªÊôºÊôΩÊôøÊöÄÊöÅÊöÉÊöÖÊöÜÊöàÊöâÊöäÊöãÊöçÊöéÊöèÊöêÊöíÊöìÊöîÊöïÊöò",4,"Êöû",8,"Êö©",4,"ÊöØ",4,"ÊöµÊö∂Êö∑Êö∏Êö∫ÊöªÊöºÊöΩÊöø",25,"ÊõöÊõû",7,"ÊõßÊõ®Êõ™",5,"Êõ±ÊõµÊõ∂Êõ∏Êõ∫ÊõªÊõΩÊúÅÊúÇÊúÉ"],["9640","ÊúÑÊúÖÊúÜÊúáÊúåÊúéÊúèÊúëÊúíÊúìÊúñÊúòÊúôÊúöÊúúÊúûÊú†",5,"ÊúßÊú©ÊúÆÊú∞Êú≤Êú≥Êú∂Êú∑Êú∏ÊúπÊúªÊúºÊúæÊúøÊùÅÊùÑÊùÖÊùáÊùäÊùãÊùçÊùíÊùîÊùïÊùó",4,"ÊùùÊù¢Êù£Êù§Êù¶ÊùßÊù´Êù¨ÊùÆÊù±Êù¥Êù∂"],["9680","Êù∏ÊùπÊù∫ÊùªÊùΩÊûÄÊûÇÊûÉÊûÖÊûÜÊûàÊûäÊûåÊûçÊûéÊûèÊûëÊûíÊûìÊûîÊûñÊûôÊûõÊûüÊû†Êû°Êû§Êû¶Êû©Êû¨ÊûÆÊû±Êû≤Êû¥Êûπ",7,"ÊüÇÊüÖ",9,"ÊüïÊüñÊüóÊüõÊüüÊü°Êü£Êü§Êü¶ÊüßÊü®Êü™Êü´Êü≠ÊüÆÊü≤Êüµ",7,"ÊüæÊ†ÅÊ†ÇÊ†ÉÊ†ÑÊ†ÜÊ†çÊ†êÊ†íÊ†îÊ†ïÊ†ò",4,"Ê†ûÊ†üÊ††Ê†¢",6,"Ê†´",6,"Ê†¥Ê†µÊ†∂Ê†∫Ê†ªÊ†øÊ°áÊ°ãÊ°çÊ°èÊ°íÊ°ñ",5],["9740","Ê°úÊ°ùÊ°ûÊ°üÊ°™Ê°¨",7,"Ê°µÊ°∏",8,"Ê¢ÇÊ¢ÑÊ¢á",7,"Ê¢êÊ¢ëÊ¢íÊ¢îÊ¢ïÊ¢ñÊ¢ò",9,"Ê¢£Ê¢§Ê¢•Ê¢©Ê¢™Ê¢´Ê¢¨Ê¢ÆÊ¢±Ê¢≤Ê¢¥Ê¢∂Ê¢∑Ê¢∏"],["9780","Ê¢π",6,"Ê£ÅÊ£É",5,"Ê£äÊ£åÊ£éÊ£èÊ£êÊ£ëÊ£ìÊ£îÊ£ñÊ£óÊ£ôÊ£õ",4,"Ê£°Ê£¢Ê£§",9,"Ê£ØÊ£≤Ê£≥Ê£¥Ê£∂Ê£∑Ê£∏Ê£ªÊ£ΩÊ£æÊ£øÊ§ÄÊ§ÇÊ§ÉÊ§ÑÊ§Ü",4,"Ê§åÊ§èÊ§ëÊ§ì",11,"Ê§°Ê§¢Ê§£Ê§•",7,"Ê§ÆÊ§ØÊ§±Ê§≤Ê§≥Ê§µÊ§∂Ê§∑Ê§∏Ê§∫Ê§ªÊ§ºÊ§æÊ•ÄÊ•ÅÊ•É",16,"Ê•ïÊ•ñÊ•òÊ•ôÊ•õÊ•úÊ•ü"],["9840","Ê•°Ê•¢Ê•§Ê••Ê•ßÊ•®Ê•©Ê•™Ê•¨Ê•≠Ê•ØÊ•∞Ê•≤",4,"Ê•∫Ê•ªÊ•ΩÊ•æÊ•øÊ¶ÅÊ¶ÉÊ¶ÖÊ¶äÊ¶ãÊ¶åÊ¶é",5,"Ê¶ñÊ¶óÊ¶ôÊ¶öÊ¶ù",9,"Ê¶©Ê¶™Ê¶¨Ê¶ÆÊ¶ØÊ¶∞Ê¶≤Ê¶≥Ê¶µÊ¶∂Ê¶∏Ê¶πÊ¶∫Ê¶ºÊ¶Ω"],["9880","Ê¶æÊ¶øÊßÄÊßÇ",7,"ÊßãÊßçÊßèÊßëÊßíÊßìÊßï",5,"ÊßúÊßùÊßûÊß°",11,"ÊßÆÊßØÊß∞Êß±Êß≥",9,"ÊßæÊ®Ä",9,"Ê®ã",11,"Ê®ô",5,"Ê®†Ê®¢",5,"Ê®©Ê®´Ê®¨Ê®≠Ê®ÆÊ®∞Ê®≤Ê®≥Ê®¥Ê®∂",6,"Ê®ø",4,"Ê©ÖÊ©ÜÊ©à",7,"Ê©ë",6,"Ê©ö"],["9940","Ê©ú",4,"Ê©¢Ê©£Ê©§Ê©¶",10,"Ê©≤",6,"Ê©∫Ê©ªÊ©ΩÊ©æÊ©øÊ™ÅÊ™ÇÊ™ÉÊ™Ö",8,"Ê™èÊ™í",4,"Ê™ò",7,"Ê™°",5],["9980","Ê™ßÊ™®Ê™™Ê™≠",114,"Ê¨•Ê¨¶Ê¨®",6],["9a40","Ê¨ØÊ¨∞Ê¨±Ê¨≥Ê¨¥Ê¨µÊ¨∂Ê¨∏Ê¨ªÊ¨ºÊ¨ΩÊ¨øÊ≠ÄÊ≠ÅÊ≠ÇÊ≠ÑÊ≠ÖÊ≠àÊ≠äÊ≠ãÊ≠ç",11,"Ê≠ö",7,"Ê≠®Ê≠©Ê≠´",13,"Ê≠∫Ê≠ΩÊ≠æÊ≠øÊÆÄÊÆÖÊÆà"],["9a80","ÊÆåÊÆéÊÆèÊÆêÊÆëÊÆîÊÆïÊÆóÊÆòÊÆôÊÆú",4,"ÊÆ¢",7,"ÊÆ´",7,"ÊÆ∂ÊÆ∏",6,"ÊØÄÊØÉÊØÑÊØÜ",4,"ÊØåÊØéÊØêÊØëÊØòÊØöÊØú",4,"ÊØ¢",7,"ÊØ¨ÊØ≠ÊØÆÊØ∞ÊØ±ÊØ≤ÊØ¥ÊØ∂ÊØ∑ÊØ∏ÊØ∫ÊØªÊØºÊØæ",6,"Ê∞à",4,"Ê∞éÊ∞íÊ∞óÊ∞úÊ∞ùÊ∞ûÊ∞†Ê∞£Ê∞•Ê∞´Ê∞¨Ê∞≠Ê∞±Ê∞≥Ê∞∂Ê∞∑Ê∞πÊ∞∫Ê∞ªÊ∞ºÊ∞æÊ∞øÊ±ÉÊ±ÑÊ±ÖÊ±àÊ±ã",4,"Ê±ëÊ±íÊ±ìÊ±ñÊ±ò"],["9b40","Ê±ôÊ±öÊ±¢Ê±£Ê±•Ê±¶Ê±ßÊ±´",4,"Ê±±Ê±≥Ê±µÊ±∑Ê±∏Ê±∫Ê±ªÊ±ºÊ±øÊ≤ÄÊ≤ÑÊ≤áÊ≤äÊ≤ãÊ≤çÊ≤éÊ≤ëÊ≤íÊ≤ïÊ≤ñÊ≤óÊ≤òÊ≤öÊ≤úÊ≤ùÊ≤ûÊ≤†Ê≤¢Ê≤®Ê≤¨Ê≤ØÊ≤∞Ê≤¥Ê≤µÊ≤∂Ê≤∑Ê≤∫Ê≥ÄÊ≥ÅÊ≥ÇÊ≥ÉÊ≥ÜÊ≥áÊ≥àÊ≥ãÊ≥çÊ≥éÊ≥èÊ≥ëÊ≥íÊ≥ò"],["9b80","Ê≥ôÊ≥öÊ≥úÊ≥ùÊ≥üÊ≥§Ê≥¶Ê≥ßÊ≥©Ê≥¨Ê≥≠Ê≥≤Ê≥¥Ê≥πÊ≥øÊ¥ÄÊ¥ÇÊ¥ÉÊ¥ÖÊ¥ÜÊ¥àÊ¥âÊ¥äÊ¥çÊ¥èÊ¥êÊ¥ëÊ¥ìÊ¥îÊ¥ïÊ¥ñÊ¥òÊ¥úÊ¥ùÊ¥ü",5,"Ê¥¶Ê¥®Ê¥©Ê¥¨Ê¥≠Ê¥ØÊ¥∞Ê¥¥Ê¥∂Ê¥∑Ê¥∏Ê¥∫Ê¥øÊµÄÊµÇÊµÑÊµâÊµåÊµêÊµïÊµñÊµóÊµòÊµõÊµùÊµüÊµ°Êµ¢Êµ§Êµ•ÊµßÊµ®Êµ´Êµ¨Êµ≠Êµ∞Êµ±Êµ≤Êµ≥ÊµµÊµ∂ÊµπÊµ∫ÊµªÊµΩ",4,"Ê∂ÉÊ∂ÑÊ∂ÜÊ∂áÊ∂äÊ∂ãÊ∂çÊ∂èÊ∂êÊ∂íÊ∂ñ",4,"Ê∂úÊ∂¢Ê∂•Ê∂¨Ê∂≠Ê∂∞Ê∂±Ê∂≥Ê∂¥Ê∂∂Ê∂∑Ê∂π",5,"Ê∑ÅÊ∑ÇÊ∑ÉÊ∑àÊ∑âÊ∑ä"],["9c40","Ê∑çÊ∑éÊ∑èÊ∑êÊ∑íÊ∑ìÊ∑îÊ∑ïÊ∑óÊ∑öÊ∑õÊ∑úÊ∑üÊ∑¢Ê∑£Ê∑•Ê∑ßÊ∑®Ê∑©Ê∑™Ê∑≠Ê∑ØÊ∑∞Ê∑≤Ê∑¥Ê∑µÊ∑∂Ê∑∏Ê∑∫Ê∑Ω",7,"Ê∏ÜÊ∏áÊ∏àÊ∏âÊ∏ãÊ∏èÊ∏íÊ∏ìÊ∏ïÊ∏òÊ∏ôÊ∏õÊ∏úÊ∏ûÊ∏üÊ∏¢Ê∏¶Ê∏ßÊ∏®Ê∏™Ê∏¨Ê∏ÆÊ∏∞Ê∏±Ê∏≥Ê∏µ"],["9c80","Ê∏∂Ê∏∑Ê∏πÊ∏ª",7,"ÊπÖ",7,"ÊπèÊπêÊπëÊπíÊπïÊπóÊπôÊπöÊπúÊπùÊπûÊπ†",10,"Êπ¨Êπ≠ÊπØ",14,"Ê∫ÄÊ∫ÅÊ∫ÇÊ∫ÑÊ∫áÊ∫àÊ∫ä",4,"Ê∫ë",6,"Ê∫ôÊ∫öÊ∫õÊ∫ùÊ∫ûÊ∫†Ê∫°Ê∫£Ê∫§Ê∫¶Ê∫®Ê∫©Ê∫´Ê∫¨Ê∫≠Ê∫ÆÊ∫∞Ê∫≥Ê∫µÊ∫∏Ê∫πÊ∫ºÊ∫æÊ∫øÊªÄÊªÉÊªÑÊªÖÊªÜÊªàÊªâÊªäÊªåÊªçÊªéÊªêÊªíÊªñÊªòÊªôÊªõÊªúÊªùÊª£ÊªßÊª™",5],["9d40","Êª∞Êª±Êª≤Êª≥ÊªµÊª∂Êª∑Êª∏Êª∫",7,"ÊºÉÊºÑÊºÖÊºáÊºàÊºä",4,"ÊºêÊºëÊºíÊºñ",9,"Êº°Êº¢Êº£Êº•Êº¶ÊºßÊº®Êº¨ÊºÆÊº∞Êº≤Êº¥ÊºµÊº∑",6,"ÊºøÊΩÄÊΩÅÊΩÇ"],["9d80","ÊΩÉÊΩÑÊΩÖÊΩàÊΩâÊΩäÊΩåÊΩé",9,"ÊΩôÊΩöÊΩõÊΩùÊΩüÊΩ†ÊΩ°ÊΩ£ÊΩ§ÊΩ•ÊΩß",5,"ÊΩØÊΩ∞ÊΩ±ÊΩ≥ÊΩµÊΩ∂ÊΩ∑ÊΩπÊΩªÊΩΩ",6,"ÊæÖÊæÜÊæáÊæäÊæãÊæè",12,"ÊæùÊæûÊæüÊæ†Êæ¢",4,"Êæ®",10,"Êæ¥ÊæµÊæ∑Êæ∏Êæ∫",5,"ÊøÅÊøÉ",5,"Êøä",6,"Êøì",10,"ÊøüÊø¢Êø£Êø§Êø•"],["9e40","Êø¶",7,"Êø∞",32,"ÁÄí",7,"ÁÄú",6,"ÁÄ§",6],["9e80","ÁÄ´",9,"ÁÄ∂ÁÄ∑ÁÄ∏ÁÄ∫",17,"ÁÅçÁÅéÁÅê",13,"ÁÅü",11,"ÁÅÆÁÅ±ÁÅ≤ÁÅ≥ÁÅ¥ÁÅ∑ÁÅπÁÅ∫ÁÅªÁÅΩÁÇÅÁÇÇÁÇÉÁÇÑÁÇÜÁÇáÁÇàÁÇãÁÇåÁÇçÁÇèÁÇêÁÇëÁÇìÁÇóÁÇòÁÇöÁÇõÁÇû",12,"ÁÇ∞ÁÇ≤ÁÇ¥ÁÇµÁÇ∂ÁÇ∫ÁÇæÁÇøÁÉÑÁÉÖÁÉÜÁÉáÁÉâÁÉã",12,"ÁÉö"],["9f40","ÁÉúÁÉùÁÉûÁÉ†ÁÉ°ÁÉ¢ÁÉ£ÁÉ•ÁÉ™ÁÉÆÁÉ∞",6,"ÁÉ∏ÁÉ∫ÁÉªÁÉºÁÉæ",10,"ÁÑã",4,"ÁÑëÁÑíÁÑîÁÑóÁÑõ",10,"ÁÑß",7,"ÁÑ≤ÁÑ≥ÁÑ¥"],["9f80","ÁÑµÁÑ∑",13,"ÁÖÜÁÖáÁÖàÁÖâÁÖãÁÖçÁÖè",12,"ÁÖùÁÖü",4,"ÁÖ•ÁÖ©",4,"ÁÖØÁÖ∞ÁÖ±ÁÖ¥ÁÖµÁÖ∂ÁÖ∑ÁÖπÁÖªÁÖºÁÖæ",5,"ÁÜÖ",4,"ÁÜãÁÜåÁÜçÁÜéÁÜêÁÜëÁÜíÁÜìÁÜïÁÜñÁÜóÁÜö",4,"ÁÜ°",6,"ÁÜ©ÁÜ™ÁÜ´ÁÜ≠",5,"ÁÜ¥ÁÜ∂ÁÜ∑ÁÜ∏ÁÜ∫",8,"ÁáÑ",9,"Ááè",4],["a040","Ááñ",9,"Áá°Áá¢Áá£Áá§Áá¶Áá®",5,"ÁáØ",9,"Áá∫",11,"Áàá",19],["a080","ÁàõÁàúÁàû",9,"Áà©Áà´Áà≠ÁàÆÁàØÁà≤Áà≥Áà¥Áà∫ÁàºÁàæÁâÄ",6,"ÁââÁâäÁâãÁâéÁâèÁâêÁâëÁâìÁâîÁâïÁâóÁâòÁâöÁâúÁâûÁâ†Áâ£Áâ§Áâ•Áâ®Áâ™Áâ´Áâ¨Áâ≠Áâ∞Áâ±Áâ≥Áâ¥Áâ∂Áâ∑Áâ∏ÁâªÁâºÁâΩÁäÇÁäÉÁäÖ",4,"ÁäåÁäéÁäêÁäëÁäì",11,"Áä†",11,"ÁäÆÁä±Áä≤Áä≥ÁäµÁä∫",6,"ÁãÖÁãÜÁãáÁãâÁãäÁããÁãåÁãèÁãëÁãìÁãîÁãïÁãñÁãòÁãöÁãõ"],["a1a1","„ÄÄ„ÄÅ„ÄÇ¬∑ÀâÀá¬®„ÄÉ„ÄÖ‚ÄîÔΩû‚Äñ‚Ä¶‚Äò‚Äô‚Äú‚Äù„Äî„Äï„Äà",7,"„Äñ„Äó„Äê„Äë¬±√ó√∑‚à∂‚àß‚à®‚àë‚àè‚à™‚à©‚àà‚à∑‚àö‚ä•‚à•‚à†‚åí‚äô‚à´‚àÆ‚â°‚âå‚âà‚àΩ‚àù‚â†‚âÆ‚âØ‚â§‚â•‚àû‚àµ‚à¥‚ôÇ‚ôÄ¬∞‚Ä≤‚Ä≥‚ÑÉÔºÑ¬§Ôø†Ôø°‚Ä∞¬ß‚Ññ‚òÜ‚òÖ‚óã‚óè‚óé‚óá‚óÜ‚ñ°‚ñ†‚ñ≥‚ñ≤‚Äª‚Üí‚Üê‚Üë‚Üì„Äì"],["a2a1","‚Ö∞",9],["a2b1","‚íà",19,"‚ë¥",19,"‚ë†",9],["a2e5","„à†",9],["a2f1","‚Ö†",11],["a3a1","ÔºÅÔºÇÔºÉÔø•ÔºÖ",88,"Ôø£"],["a4a1","„ÅÅ",82],["a5a1","„Ç°",85],["a6a1","Œë",16,"Œ£",6],["a6c1","Œ±",16,"œÉ",6],["a6e0","Ô∏µÔ∏∂Ô∏πÔ∏∫Ô∏øÔπÄÔ∏ΩÔ∏æÔπÅÔπÇÔπÉÔπÑ"],["a6ee","Ô∏ªÔ∏ºÔ∏∑Ô∏∏Ô∏±"],["a6f4","Ô∏≥Ô∏¥"],["a7a1","–ê",5,"–Å–ñ",25],["a7d1","–∞",5,"—ë–∂",25],["a840","ÀäÀãÀô‚Äì‚Äï‚Ä•‚Äµ‚ÑÖ‚Ñâ‚Üñ‚Üó‚Üò‚Üô‚àï‚àü‚à£‚âí‚â¶‚âß‚äø‚ïê",35,"‚ñÅ",6],["a880","‚ñà",7,"‚ñì‚ñî‚ñï‚ñº‚ñΩ‚ó¢‚ó£‚ó§‚ó•‚òâ‚äï„Äí„Äù„Äû"],["a8a1","ƒÅ√°«é√†ƒì√©ƒõ√®ƒ´√≠«ê√¨≈ç√≥«í√≤≈´√∫«î√π«ñ«ò«ö«ú√º√™…ë"],["a8bd","≈Ñ≈à"],["a8c0","…°"],["a8c5","„ÑÖ",36],["a940","„Ä°",8,"„ä£„éé„éè„éú„éù„éû„é°„èÑ„èé„èë„èí„èïÔ∏∞Ôø¢Ôø§"],["a959","‚Ñ°„à±"],["a95c","‚Äê"],["a960","„Éº„Çõ„Çú„ÉΩ„Éæ„ÄÜ„Çù„ÇûÔπâ",9,"ÔπîÔπïÔπñÔπóÔπô",8],["a980","Ôπ¢",4,"Ôπ®Ôπ©Ôπ™Ôπ´"],["a996","„Äá"],["a9a4","‚îÄ",75],["aa40","ÁãúÁãùÁãüÁã¢",5,"Áã™Áã´ÁãµÁã∂ÁãπÁãΩÁãæÁãøÁåÄÁåÇÁåÑ",5,"ÁåãÁååÁåçÁåèÁåêÁåëÁåíÁåîÁåòÁåôÁåöÁåüÁå†Áå£Áå§Áå¶ÁåßÁå®Áå≠ÁåØÁå∞Áå≤Áå≥ÁåµÁå∂Áå∫ÁåªÁåºÁåΩÁçÄ",8],["aa80","ÁçâÁçäÁçãÁçåÁçéÁçèÁçëÁçìÁçîÁçïÁçñÁçò",7,"Áç°",10,"ÁçÆÁç∞Áç±"],["ab40","Áç≤",11,"Áçø",4,"ÁéÖÁéÜÁéàÁéäÁéåÁéçÁéèÁéêÁéíÁéìÁéîÁéïÁéóÁéòÁéôÁéöÁéúÁéùÁéûÁé†Áé°Áé£",5,"Áé™Áé¨Áé≠Áé±Áé¥ÁéµÁé∂Áé∏ÁéπÁéºÁéΩÁéæÁéøÁèÅÁèÉ",4],["ab80","ÁèãÁèåÁèéÁèí",6,"ÁèöÁèõÁèúÁèùÁèüÁè°Áè¢Áè£Áè§Áè¶Áè®Áè™Áè´Áè¨ÁèÆÁèØÁè∞Áè±Áè≥",4],["ac40","Áè∏",10,"ÁêÑÁêáÁêàÁêãÁêåÁêçÁêéÁêë",8,"Áêú",5,"Áê£Áê§ÁêßÁê©Áê´Áê≠ÁêØÁê±Áê≤Áê∑",4,"ÁêΩÁêæÁêøÁëÄÁëÇ",11],["ac80","Áëé",6,"ÁëñÁëòÁëùÁë†",12,"ÁëÆÁëØÁë±",4,"Áë∏ÁëπÁë∫"],["ad40","ÁëªÁëºÁëΩÁëøÁíÇÁíÑÁíÖÁíÜÁíàÁíâÁíäÁíåÁíçÁíèÁíë",10,"ÁíùÁíü",7,"Áí™",15,"Áíª",12],["ad80","Áìà",9,"Áìì",8,"ÁìùÁìüÁì°Áì•Áìß",6,"Áì∞Áì±Áì≤"],["ae40","Áì≥ÁìµÁì∏",6,"ÁîÄÁîÅÁîÇÁîÉÁîÖ",7,"ÁîéÁîêÁîíÁîîÁîïÁîñÁîóÁîõÁîùÁîûÁî†",4,"Áî¶ÁîßÁî™ÁîÆÁî¥Áî∂ÁîπÁîºÁîΩÁîøÁïÅÁïÇÁïÉÁïÑÁïÜÁïáÁïâÁïäÁïçÁïêÁïëÁïíÁïìÁïïÁïñÁïóÁïò"],["ae80","Áïù",7,"ÁïßÁï®Áï©Áï´",6,"Áï≥ÁïµÁï∂Áï∑Áï∫",4,"ÁñÄÁñÅÁñÇÁñÑÁñÖÁñá"],["af40","ÁñàÁñâÁñäÁñåÁñçÁñéÁñêÁñìÁñïÁñòÁñõÁñúÁñûÁñ¢Áñ¶",4,"Áñ≠Áñ∂Áñ∑Áñ∫ÁñªÁñøÁóÄÁóÅÁóÜÁóãÁóåÁóéÁóèÁóêÁóëÁóìÁóóÁóôÁóöÁóúÁóùÁóüÁó†Áó°Áó•Áó©Áó¨Áó≠ÁóÆÁóØÁó≤Áó≥ÁóµÁó∂Áó∑Áó∏Áó∫ÁóªÁóΩÁóæÁòÇÁòÑÁòÜÁòá"],["af80","ÁòàÁòâÁòãÁòçÁòéÁòèÁòëÁòíÁòìÁòîÁòñÁòöÁòúÁòùÁòûÁò°Áò£ÁòßÁò®Áò¨ÁòÆÁòØÁò±Áò≤Áò∂Áò∑ÁòπÁò∫ÁòªÁòΩÁôÅÁôÇÁôÑ"],["b040","ÁôÖ",6,"Áôé",5,"ÁôïÁôó",4,"ÁôùÁôüÁô†Áô°Áô¢Áô§",6,"Áô¨Áô≠ÁôÆÁô∞",7,"ÁôπÁô∫ÁôºÁôøÁöÄÁöÅÁöÉÁöÖÁöâÁöäÁöåÁöçÁöèÁöêÁöíÁöîÁöïÁöóÁöòÁööÁöõ"],["b080","Áöú",7,"Áö•",8,"ÁöØÁö∞Áö≥Áöµ",9,"ÁõÄÁõÅÁõÉÂïäÈòøÂüÉÊå®ÂìéÂîâÂìÄÁöëÁôåËîºÁüÆËâæÁ¢çÁà±ÈöòÈûçÊ∞®ÂÆâ‰ø∫ÊåâÊöóÂ≤∏ËÉ∫Ê°àËÇÆÊòÇÁõéÂáπÊïñÁÜ¨Áø±Ë¢ÑÂÇ≤Â••ÊáäÊæ≥Ëä≠ÊçåÊâíÂè≠ÂêßÁ¨ÜÂÖ´Áñ§Â∑¥ÊãîË∑ãÈù∂ÊääËÄôÂùùÈú∏ÁΩ¢Áà∏ÁôΩÊüèÁôæÊëÜ‰Ω∞Ë¥•ÊãúÁ®óÊñëÁè≠Êê¨Êâ≥Ëà¨È¢ÅÊùøÁâàÊâÆÊãå‰º¥Áì£ÂçäÂäûÁªäÈÇ¶Â∏ÆÊ¢ÜÊ¶úËÜÄÁªëÊ£íÁ£ÖËöåÈïëÂÇçË∞§ËãûËÉûÂåÖË§íÂâ•"],["b140","ÁõÑÁõáÁõâÁõãÁõåÁõìÁõïÁõôÁõöÁõúÁõùÁõûÁõ†",4,"Áõ¶",7,"Áõ∞Áõ≥ÁõµÁõ∂Áõ∑Áõ∫ÁõªÁõΩÁõøÁúÄÁúÇÁúÉÁúÖÁúÜÁúäÁúåÁúé",10,"ÁúõÁúúÁúùÁúûÁú°Áú£Áú§Áú•ÁúßÁú™Áú´"],["b180","Áú¨ÁúÆÁú∞",4,"ÁúπÁúªÁúΩÁúæÁúøÁùÇÁùÑÁùÖÁùÜÁùà",7,"Áùí",7,"ÁùúËñÑÈõπ‰øùÂ†°È•±ÂÆùÊä±Êä•Êö¥Ë±πÈ≤çÁàÜÊùØÁ¢ëÊÇ≤ÂçëÂåóËæàËÉåË¥ùÈí°ÂÄçÁãàÂ§áÊÉ´ÁÑôË¢´Â•îËãØÊú¨Á¨®Â¥©Áª∑Áî≠Ê≥µËπ¶Ëø∏ÈÄºÈºªÊØîÈÑôÁ¨îÂΩºÁ¢ßËìñËîΩÊØïÊØôÊØñÂ∏ÅÂ∫áÁóπÈó≠ÊïùÂºäÂøÖËæüÂ£ÅËáÇÈÅøÈôõÈû≠ËæπÁºñË¥¨ÊâÅ‰æøÂèòÂçûËæ®Ëæ©Ëæ´ÈÅçÊ†áÂΩ™ËÜòË°®È≥ñÊÜãÂà´Áò™ÂΩ¨ÊñåÊøíÊª®ÂÆæÊëàÂÖµÂÜ∞ÊüÑ‰∏ôÁßâÈ•ºÁÇ≥"],["b240","ÁùùÁùûÁùüÁù†Áù§ÁùßÁù©Áù™Áù≠",11,"Áù∫ÁùªÁùºÁûÅÁûÇÁûÉÁûÜ",5,"ÁûèÁûêÁûì",11,"Áû°Áû£Áû§Áû¶Áû®Áû´Áû≠ÁûÆÁûØÁû±Áû≤Áû¥Áû∂",4],["b280","ÁûºÁûæÁüÄ",12,"Áüé",8,"ÁüòÁüôÁüöÁüù",4,"Áü§ÁóÖÂπ∂ÁéªËè†Êí≠Êã®ÈíµÊ≥¢ÂçöÂãÉÊêèÈìÇÁÆî‰ºØÂ∏õËà∂ËÑñËÜäÊ∏§Ê≥äÈ©≥ÊçïÂçúÂì∫Ë°•Âü†‰∏çÂ∏ÉÊ≠•Á∞øÈÉ®ÊÄñÊì¶ÁåúË£ÅÊùêÊâçË¥¢Áù¨Ë∏©ÈááÂΩ©ËèúËî°È§êÂèÇËöïÊÆãÊÉ≠ÊÉ®ÁÅøËãçËà±‰ªìÊ≤ßËóèÊìçÁ≥ôÊßΩÊõπËçâÂéïÁ≠ñ‰æßÂÜåÊµãÂ±ÇËπ≠ÊèíÂèâËå¨Ëå∂Êü•Á¢¥ÊêΩÂØüÂ≤îÂ∑ÆËØßÊãÜÊü¥Ë±∫ÊêÄÊé∫ËùâÈ¶ãË∞óÁº†Èì≤‰∫ßÈòêÈ¢§ÊòåÁåñ"],["b340","Áü¶Áü®Áü™ÁüØÁü∞Áü±Áü≤Áü¥ÁüµÁü∑ÁüπÁü∫ÁüªÁüºÁ†É",5,"Á†äÁ†ãÁ†éÁ†èÁ†êÁ†ìÁ†ïÁ†ôÁ†õÁ†ûÁ††Á†°Á†¢Á†§Á†®Á†™Á†´Á†ÆÁ†ØÁ†±Á†≤Á†≥Á†µÁ†∂Á†ΩÁ†øÁ°ÅÁ°ÇÁ°ÉÁ°ÑÁ°ÜÁ°àÁ°âÁ°äÁ°ãÁ°çÁ°èÁ°ëÁ°ìÁ°îÁ°òÁ°ôÁ°ö"],["b380","Á°õÁ°úÁ°û",11,"Á°Ø",7,"Á°∏Á°πÁ°∫Á°ªÁ°Ω",6,"Âú∫Â∞ùÂ∏∏ÈïøÂÅøËÇ†ÂéÇÊïûÁïÖÂî±ÂÄ°Ë∂ÖÊäÑÈíûÊúùÂò≤ÊΩÆÂ∑¢ÂêµÁÇíËΩ¶ÊâØÊí§Êé£ÂΩªÊæàÈÉ¥Ëá£Ëæ∞Â∞òÊô®Âø±Ê≤âÈôàË∂ÅË°¨ÊíëÁß∞ÂüéÊ©ôÊàêÂëà‰πòÁ®ãÊÉ©ÊæÑËØöÊâøÈÄûÈ™ãÁß§ÂêÉÁó¥ÊåÅÂåôÊ±†ËøüÂºõÈ©∞ËÄªÈΩø‰æàÂ∞∫Ëµ§ÁøÖÊñ•ÁÇΩÂÖÖÂÜ≤Ëô´Â¥áÂÆ†ÊäΩÈÖ¨Áï¥Ë∏åÁ®†ÊÑÅÁ≠π‰ªáÁª∏ÁûÖ‰∏ëËá≠ÂàùÂá∫Ê©±Âé®Ë∫áÈîÑÈõèÊªÅÈô§Ê•ö"],["b440","Á¢ÑÁ¢ÖÁ¢ÜÁ¢àÁ¢äÁ¢ãÁ¢èÁ¢êÁ¢íÁ¢îÁ¢ïÁ¢ñÁ¢ôÁ¢ùÁ¢ûÁ¢†Á¢¢Á¢§Á¢¶Á¢®",7,"Á¢µÁ¢∂Á¢∑Á¢∏Á¢∫Á¢ªÁ¢ºÁ¢ΩÁ¢øÁ£ÄÁ£ÇÁ£ÉÁ£ÑÁ£ÜÁ£áÁ£àÁ£åÁ£çÁ£éÁ£èÁ£ëÁ£íÁ£ìÁ£ñÁ£óÁ£òÁ£ö",9],["b480","Á£§Á£•Á£¶Á£ßÁ£©Á£™Á£´Á£≠",4,"Á£≥Á£µÁ£∂Á£∏Á£πÁ£ª",5,"Á§ÇÁ§ÉÁ§ÑÁ§Ü",6,"Á°ÄÂÇ®ÁüóÊêêËß¶Â§ÑÊè£Â∑ùÁ©øÊ§Ω‰º†ËàπÂñò‰∏≤ÁñÆÁ™óÂπ¢Â∫äÈóØÂàõÂêπÁÇäÊç∂Èî§ÂûÇÊò•Ê§øÈÜáÂîáÊ∑≥Á∫ØË†¢Êà≥Áª∞ÁñµËå®Á£ÅÈõåËæûÊÖàÁì∑ËØçÊ≠§Âà∫ËµêÊ¨°ËÅ™Ëë±Âõ±ÂåÜ‰ªé‰∏õÂáëÁ≤óÈÜãÁ∞á‰øÉËπøÁØ°Á™úÊëßÂ¥îÂÇ¨ËÑÜÁòÅÁ≤πÊ∑¨Áø†ÊùëÂ≠òÂØ∏Á£ãÊíÆÊêìÊé™Êå´ÈîôÊê≠ËææÁ≠îÁò©ÊâìÂ§ßÂëÜÊ≠πÂÇ£Êà¥Â∏¶ÊÆÜ‰ª£Ë¥∑Ë¢ãÂæÖÈÄÆ"],["b540","Á§ç",5,"Á§î",9,"Á§ü",4,"Á§•",14,"Á§µ",4,"Á§ΩÁ§øÁ•ÇÁ•ÉÁ•ÑÁ•ÖÁ•áÁ•ä",8,"Á•îÁ•ïÁ•òÁ•ôÁ•°Á•£"],["b580","Á•§Á•¶Á•©Á•™Á•´Á•¨Á•ÆÁ•∞",6,"Á•πÁ•ª",4,"Á¶ÇÁ¶ÉÁ¶ÜÁ¶áÁ¶àÁ¶âÁ¶ãÁ¶åÁ¶çÁ¶éÁ¶êÁ¶ëÁ¶íÊÄ†ËÄΩÊãÖ‰∏πÂçïÈÉ∏Êé∏ËÉÜÊó¶Ê∞Æ‰ΩÜÊÉÆÊ∑°ËØûÂºπËõãÂΩìÊå°ÂÖöËç°Ê°£ÂàÄÊç£ËπàÂÄíÂ≤õÁ•∑ÂØºÂà∞Á®ªÊÇºÈÅìÁõóÂæ∑ÂæóÁöÑËπ¨ÁÅØÁôªÁ≠âÁû™Âá≥ÈÇìÂ†§‰ΩéÊª¥Ëø™ÊïåÁ¨õÁãÑÊ∂§ÁøüÂ´°ÊäµÂ∫ïÂú∞ËíÇÁ¨¨Â∏ùÂºüÈÄíÁºîÈ¢†ÊéÇÊªáÁ¢òÁÇπÂÖ∏ÈùõÂû´Áîµ‰ΩÉÁî∏Â∫óÊÉ¶Â•†Ê∑ÄÊÆøÁ¢âÂèºÈõïÂáãÂàÅÊéâÂêäÈíìË∞ÉË∑åÁàπÁ¢üËù∂Ëø≠Ë∞çÂè†"],["b640","Á¶ì",6,"Á¶õ",11,"Á¶®",10,"Á¶¥",4,"Á¶ºÁ¶øÁßÇÁßÑÁßÖÁßáÁßàÁßäÁßåÁßéÁßèÁßêÁßìÁßîÁßñÁßóÁßô",5,"Áß†Áß°Áß¢Áß•Áß®Áß™"],["b680","Áß¨ÁßÆÁß±",6,"ÁßπÁß∫ÁßºÁßæÁßøÁ®ÅÁ®ÑÁ®ÖÁ®áÁ®àÁ®âÁ®äÁ®åÁ®è",4,"Á®ïÁ®ñÁ®òÁ®ôÁ®õÁ®ú‰∏ÅÁõØÂèÆÈíâÈ°∂ÈºéÈî≠ÂÆöËÆ¢‰∏¢‰∏úÂÜ¨Ëë£ÊáÇÂä®Ê†ã‰æóÊÅ´ÂÜªÊ¥ûÂÖúÊäñÊñóÈô°Ë±ÜÈÄóÁóòÈÉΩÁù£ÊØíÁääÁã¨ËØªÂ†µÁùπËµåÊùúÈïÄËÇöÂ∫¶Ê∏°Â¶íÁ´ØÁü≠ÈîªÊÆµÊñ≠ÁºéÂ†ÜÂÖëÈòüÂØπÂ¢©Âê®Ëπ≤Êï¶È°øÂõ§ÈíùÁõæÈÅÅÊéáÂìÜÂ§öÂ§∫ÂûõË∫≤ÊúµË∑∫ËàµÂâÅÊÉ∞Â†ïËõæÂ≥®ÈπÖ‰øÑÈ¢ùËÆπÂ®•ÊÅ∂ÂéÑÊâºÈÅèÈÑÇÈ•øÊÅ©ËÄåÂÑøËÄ≥Â∞îÈ•µÊ¥±‰∫å"],["b740","Á®ùÁ®üÁ®°Á®¢Á®§",14,"Á®¥Á®µÁ®∂Á®∏Á®∫Á®æÁ©Ä",5,"Á©á",9,"Á©í",4,"Á©ò",16],["b780","Á©©",6,"Á©±Á©≤Á©≥Á©µÁ©ªÁ©ºÁ©ΩÁ©æÁ™ÇÁ™ÖÁ™áÁ™âÁ™äÁ™ãÁ™åÁ™éÁ™èÁ™êÁ™ìÁ™îÁ™ôÁ™öÁ™õÁ™ûÁ™°Á™¢Ë¥∞ÂèëÁΩöÁ≠è‰ºê‰πèÈòÄÊ≥ïÁèêËó©Â∏ÜÁï™ÁøªÊ®äÁüæÈííÁπÅÂá°ÁÉ¶ÂèçËøîËåÉË¥©ÁäØÈ•≠Ê≥õÂùäËä≥ÊñπËÇ™ÊàøÈò≤Â¶®‰ªøËÆøÁ∫∫ÊîæËè≤ÈùûÂï°È£ûËÇ•Âå™ËØΩÂê†ËÇ∫Â∫üÊ≤∏Ë¥πËä¨ÈÖöÂê©Ê∞õÂàÜÁ∫∑ÂùüÁÑöÊ±æÁ≤âÂ•ã‰ªΩÂøøÊÑ§Á≤™‰∏∞Â∞ÅÊû´ËúÇÂ≥∞ÈîãÈ£éÁñØÁÉΩÈÄ¢ÂÜØÁºùËÆΩÂ•âÂá§‰ΩõÂê¶Â§´Êï∑ËÇ§Â≠µÊâ∂ÊãÇËæêÂπÖÊ∞üÁ¨¶‰ºè‰øòÊúç"],["b840","Á™£Á™§Á™ßÁ™©Á™™Á™´Á™Æ",4,"Á™¥",10,"Á´Ä",10,"Á´å",9,"Á´óÁ´òÁ´öÁ´õÁ´úÁ´ùÁ´°Á´¢Á´§Á´ß",5,"Á´ÆÁ´∞Á´±Á´≤Á´≥"],["b880","Á´¥",4,"Á´ªÁ´ºÁ´æÁ¨ÄÁ¨ÅÁ¨ÇÁ¨ÖÁ¨áÁ¨âÁ¨åÁ¨çÁ¨éÁ¨êÁ¨íÁ¨ìÁ¨ñÁ¨óÁ¨òÁ¨öÁ¨úÁ¨ùÁ¨üÁ¨°Á¨¢Á¨£Á¨ßÁ¨©Á¨≠ÊµÆÊ∂™Á¶èË¢±ÂºóÁî´ÊäöËæÖ‰øØÈáúÊñßËÑØËÖëÂ∫úËÖêËµ¥ÂâØË¶ÜËµãÂ§çÂÇÖ‰ªòÈòúÁà∂ËÖπË¥üÂØåËÆ£ÈôÑÂ¶áÁºöÂíêÂô∂ÂòéËØ•ÊîπÊ¶ÇÈíôÁõñÊ∫âÂπ≤ÁîòÊùÜÊüëÁ´øËÇùËµ∂ÊÑüÁßÜÊï¢Ëµ£ÂÜàÂàöÈí¢Áº∏ËÇõÁ∫≤Â≤óÊ∏ØÊù†ÁØôÁöãÈ´òËÜèÁæîÁ≥ïÊêûÈïêÁ®øÂëäÂì•Ê≠åÊêÅÊààÈ∏ΩËÉ≥ÁñôÂâ≤Èù©ËëõÊ†ºËõ§ÈòÅÈöîÈì¨‰∏™ÂêÑÁªôÊ†πË∑üËÄïÊõ¥Â∫öÁæπ"],["b940","Á¨ØÁ¨∞Á¨≤Á¨¥Á¨µÁ¨∂Á¨∑Á¨πÁ¨ªÁ¨ΩÁ¨ø",5,"Á≠ÜÁ≠àÁ≠äÁ≠çÁ≠éÁ≠ìÁ≠ïÁ≠óÁ≠ôÁ≠úÁ≠ûÁ≠üÁ≠°Á≠£",10,"Á≠ØÁ≠∞Á≠≥Á≠¥Á≠∂Á≠∏Á≠∫Á≠ºÁ≠ΩÁ≠øÁÆÅÁÆÇÁÆÉÁÆÑÁÆÜ",6,"ÁÆéÁÆè"],["b980","ÁÆëÁÆíÁÆìÁÆñÁÆòÁÆôÁÆöÁÆõÁÆûÁÆüÁÆ†ÁÆ£ÁÆ§ÁÆ•ÁÆÆÁÆØÁÆ∞ÁÆ≤ÁÆ≥ÁÆµÁÆ∂ÁÆ∑ÁÆπ",7,"ÁØÇÁØÉÁØÑÂüÇËÄøÊ¢óÂ∑•ÊîªÂäüÊÅ≠Èæö‰æõË∫¨ÂÖ¨ÂÆ´ÂºìÂ∑©Ê±ûÊã±Ë¥°ÂÖ±Èí©ÂãæÊ≤üËãüÁãóÂû¢ÊûÑË¥≠Â§üËæúËèáÂíïÁÆç‰º∞Ê≤ΩÂ≠§ÂßëÈºìÂè§ËõäÈ™®Ë∞∑ËÇ°ÊïÖÈ°æÂõ∫ÈõáÂàÆÁìúÂâêÂØ°ÊåÇË§Ç‰πñÊãêÊÄ™Ê£∫ÂÖ≥ÂÆòÂÜ†ËßÇÁÆ°È¶ÜÁΩêÊÉØÁÅåË¥ØÂÖâÂπøÈÄõÁë∞ËßÑÂú≠Á°ÖÂΩíÈæüÈó∫ËΩ®È¨ºËØ°Áô∏Ê°ÇÊüúË∑™Ë¥µÂàΩËæäÊªöÊ£çÈîÖÈÉ≠ÂõΩÊûúË£πËøáÂìà"],["ba40","ÁØÖÁØàÁØâÁØäÁØãÁØçÁØéÁØèÁØêÁØíÁØî",4,"ÁØõÁØúÁØûÁØüÁØ†ÁØ¢ÁØ£ÁØ§ÁØßÁØ®ÁØ©ÁØ´ÁØ¨ÁØ≠ÁØØÁØ∞ÁØ≤",4,"ÁØ∏ÁØπÁØ∫ÁØªÁØΩÁØø",7,"Á∞àÁ∞âÁ∞äÁ∞çÁ∞éÁ∞ê",5,"Á∞óÁ∞òÁ∞ô"],["ba80","Á∞ö",4,"Á∞†",5,"Á∞®Á∞©Á∞´",12,"Á∞π",5,"Á±ÇÈ™∏Â≠©Êµ∑Ê∞¶‰∫•ÂÆ≥È™áÈÖ£ÊÜ®ÈÇØÈü©Âê´Ê∂µÂØíÂáΩÂñäÁΩïÁø∞ÊíºÊççÊó±ÊÜæÊÇçÁÑäÊ±óÊ±âÂ§ØÊù≠Ëà™Â£ïÂöéË±™ÊØ´ÈÉùÂ•ΩËÄóÂè∑Êµ©ÂëµÂñùËç∑ËèèÊ†∏Á¶æÂíå‰ΩïÂêàÁõíË≤âÈòÇÊ≤≥Ê∂∏Ëµ´Ë§êÈπ§Ë¥∫ÂòøÈªëÁóïÂæàÁã†ÊÅ®Âìº‰∫®Ê®™Ë°°ÊÅíËΩ∞ÂìÑÁÉòËôπÈ∏øÊ¥™ÂÆèÂºòÁ∫¢Âñâ‰æØÁå¥ÂêºÂéöÂÄôÂêéÂëº‰πéÂøΩÁëöÂ£∂Ëë´ËÉ°Ëù¥ÁãêÁ≥äÊπñ"],["bb40","Á±É",9,"Á±é",36,"Á±µ",5,"Á±æ",9],["bb80","Á≤àÁ≤ä",6,"Á≤ìÁ≤îÁ≤ñÁ≤ôÁ≤öÁ≤õÁ≤†Á≤°Á≤£Á≤¶Á≤ßÁ≤®Á≤©Á≤´Á≤¨Á≤≠Á≤ØÁ≤∞Á≤¥",4,"Á≤∫Á≤ªÂºßËôéÂî¨Êä§‰∫íÊ≤™Êà∑Ëä±ÂìóÂçéÁåæÊªëÁîªÂàíÂåñËØùÊßêÂæäÊÄÄÊ∑ÆÂùèÊ¨¢ÁéØÊ°ìËøòÁºìÊç¢ÊÇ£Âî§Áó™Ë±¢ÁÑïÊ∂£ÂÆ¶ÂπªËçíÊÖåÈªÑÁ£∫ËùóÁ∞ßÁöáÂá∞ÊÉ∂ÁÖåÊôÉÂπåÊÅçË∞éÁÅ∞Êå•ËæâÂæΩÊÅ¢ËõîÂõûÊØÅÊÇîÊÖßÂçâÊÉ†Êô¶Ë¥øÁßΩ‰ºöÁÉ©Ê±áËÆ≥ËØ≤ÁªòËç§ÊòèÂ©öÈ≠ÇÊµëÊ∑∑Ë±ÅÊ¥ª‰ºôÁÅ´Ëé∑ÊàñÊÉëÈúçË¥ßÁ•∏ÂáªÂúæÂü∫Êú∫Áï∏Á®ΩÁßØÁÆï"],["bc40","Á≤øÁ≥ÄÁ≥ÇÁ≥ÉÁ≥ÑÁ≥ÜÁ≥âÁ≥ãÁ≥é",6,"Á≥òÁ≥öÁ≥õÁ≥ùÁ≥ûÁ≥°",6,"Á≥©",5,"Á≥∞",7,"Á≥πÁ≥∫Á≥º",13,"Á¥ã",5],["bc80","Á¥ë",14,"Á¥°Á¥£Á¥§Á¥•Á¥¶Á¥®Á¥©Á¥™Á¥¨Á¥≠Á¥ÆÁ¥∞",6,"ËÇåÈ••ËøπÊøÄËÆ•È∏°Âß¨Áª©ÁºâÂêâÊûÅÊ£òËæëÁ±çÈõÜÂèäÊÄ•ÁñæÊ±≤Âç≥Â´âÁ∫ßÊå§Âá†ËÑäÂ∑±ËìüÊäÄÂÜÄÂ≠£‰ºéÁ•≠ÂâÇÊÇ∏ÊµéÂØÑÂØÇËÆ°ËÆ∞Êó¢ÂøåÈôÖÂ¶ìÁªßÁ∫™ÂòâÊû∑Â§π‰Ω≥ÂÆ∂Âä†ËçöÈ¢äË¥æÁî≤ÈíæÂÅáÁ®º‰ª∑Êû∂È©æÂ´ÅÊ≠ºÁõëÂùöÂ∞ñÁ¨∫Èó¥ÁÖéÂÖºËÇ©Ëâ∞Â•∏ÁºÑËåßÊ£ÄÊü¨Á¢±Á°∑Êã£Êç°ÁÆÄ‰ø≠Ââ™ÂáèËçêÊßõÈâ¥Ë∑µË¥±ËßÅÈîÆÁÆ≠‰ª∂"],["bd40","Á¥∑",54,"ÁµØ",7],["bd80","Áµ∏",32,"ÂÅ•Ëà∞ÂâëÈ•ØÊ∏êÊ∫ÖÊ∂ßÂª∫ÂÉµÂßúÂ∞ÜÊµÜÊ±üÁñÜËíãÊ°®Â•ñËÆ≤Âå†ÈÖ±ÈôçËïâÊ§íÁ§ÅÁÑ¶ËÉ∂‰∫§ÈÉäÊµáÈ™ÑÂ®áÂöºÊêÖÈì∞Áü´‰æ•ËÑöÁã°ËßíÈ•∫Áº¥ÁªûÂâøÊïôÈÖµËΩøËæÉÂè´Á™ñÊè≠Êé•ÁöÜÁß∏Ë°óÈò∂Êà™Âä´ËäÇÊ°îÊù∞Êç∑Áù´Á´≠Ê¥ÅÁªìËß£ÂßêÊàíËóâËä•ÁïåÂÄü‰ªãÁñ•ËØ´Â±äÂ∑æÁ≠ãÊñ§Èáë‰ªäÊ¥•Ë•üÁ¥ßÈî¶‰ªÖË∞®ËøõÈù≥ÊôãÁ¶ÅËøëÁÉ¨Êµ∏"],["be40","Á∂ô",12,"Á∂ß",6,"Á∂Ø",42],["be80","Á∑ö",32,"Â∞ΩÂä≤ËçÜÂÖ¢ËåéÁùõÊô∂È≤∏‰∫¨ÊÉäÁ≤æÁ≤≥Áªè‰∫ïË≠¶ÊôØÈ¢àÈùôÂ¢ÉÊï¨ÈïúÂæÑÁóâÈùñÁ´üÁ´ûÂáÄÁÇØÁ™òÊè™Á©∂Á∫†ÁéñÈü≠‰πÖÁÅ∏‰πùÈÖíÂé©ÊïëÊóßËáºËàÖÂíéÂ∞±ÁñöÈû†ÊãòÁãôÁñΩÂ±ÖÈ©πËèäÂ±ÄÂíÄÁü©‰∏æÊ≤ÆËÅöÊãíÊçÆÂ∑®ÂÖ∑Ë∑ùË∏ûÈîØ‰ø±Âè•ÊÉßÁÇ¨ÂâßÊçêÈπÉÂ®üÂÄ¶Áú∑Âç∑Áª¢ÊíÖÊî´ÊäâÊéòÂÄîÁàµËßâÂÜ≥ËØÄÁªùÂùáËèåÈíßÂÜõÂêõÂ≥ª"],["bf40","Á∑ª",62],["bf80","Á∏∫Á∏º",4,"ÁπÇ",4,"Áπà",21,"‰øäÁ´£ÊµöÈÉ°È™èÂñÄÂíñÂç°ÂíØÂºÄÊè©Ê•∑ÂáØÊÖ®ÂàäÂ†™ÂãòÂùéÁ†çÁúãÂ∫∑ÊÖ∑Á≥†ÊâõÊäó‰∫¢ÁÇïËÄÉÊã∑ÁÉ§Èù†Âù∑ËãõÊüØÊ£µÁ£ïÈ¢óÁßëÂ£≥Âí≥ÂèØÊ∏¥ÂÖãÂàªÂÆ¢ËØæËÇØÂïÉÂû¶ÊÅ≥ÂùëÂê≠Á©∫ÊÅêÂ≠îÊéßÊä†Âè£Êâ£ÂØáÊûØÂì≠Á™üËã¶ÈÖ∑Â∫ìË£§Â§∏ÂûÆÊåéË∑®ËÉØÂùóÁ≠∑‰æ©Âø´ÂÆΩÊ¨æÂå°Á≠êÁãÇÊ°ÜÁüøÁú∂Êó∑ÂÜµ‰∫èÁõîÂ≤øÁ™•ËëµÂ•éÈ≠ÅÂÇÄ"],["c040","Áπû",35,"Á∫É",23,"Á∫úÁ∫ùÁ∫û"],["c080","Á∫ÆÁ∫¥Á∫ªÁ∫ºÁªñÁª§Áª¨ÁªπÁºäÁºêÁºûÁº∑ÁºπÁºª",6,"ÁΩÉÁΩÜ",9,"ÁΩíÁΩìÈ¶àÊÑßÊ∫ÉÂù§ÊòÜÊçÜÂõ∞Êã¨Êâ©ÂªìÈòîÂûÉÊãâÂñáËú°ËÖäËæ£Âï¶Ëé±Êù•ËµñËìùÂ©™Ê†èÊã¶ÁØÆÈòëÂÖ∞ÊæúË∞∞ÊèΩËßàÊáíÁºÜÁÉÇÊª•ÁêÖÊ¶îÁãºÂªäÈÉéÊúóÊµ™ÊçûÂä≥Áâ¢ËÄÅ‰Ω¨Âß•ÈÖ™ÁÉôÊ∂ùÂãí‰πêÈõ∑Èï≠ËïæÁ£äÁ¥ØÂÑ°ÂûíÊìÇËÇãÁ±ªÊ≥™Ê£±Ê•ûÂÜ∑ÂéòÊ¢®ÁäÅÈªéÁØ±Áã∏Á¶ªÊºìÁêÜÊùéÈáåÈ≤§Á§ºËéâËçîÂêèÊ†ó‰∏ΩÂéâÂä±Á†æÂéÜÂà©ÂÇà‰æã‰øê"],["c140","ÁΩñÁΩôÁΩõÁΩúÁΩùÁΩûÁΩ†ÁΩ£",4,"ÁΩ´ÁΩ¨ÁΩ≠ÁΩØÁΩ∞ÁΩ≥ÁΩµÁΩ∂ÁΩ∑ÁΩ∏ÁΩ∫ÁΩªÁΩºÁΩΩÁΩøÁæÄÁæÇ",7,"ÁæãÁæçÁæè",4,"Áæï",4,"ÁæõÁæúÁæ†Áæ¢Áæ£Áæ•Áæ¶Áæ®",6,"Áæ±"],["c180","Áæ≥",4,"Áæ∫ÁæªÁææÁøÄÁøÇÁøÉÁøÑÁøÜÁøáÁøàÁøâÁøãÁøçÁøè",4,"ÁøñÁøóÁøô",5,"Áø¢Áø£Áó¢Á´ãÁ≤íÊ≤•Èö∂ÂäõÁíÉÂì©‰ø©ËÅîËé≤ËøûÈï∞ÂªâÊÄúÊ∂üÂ∏òÊïõËÑ∏ÈìæÊÅãÁÇºÁªÉÁ≤ÆÂáâÊ¢ÅÁ≤±ËâØ‰∏§ËæÜÈáèÊôæ‰∫ÆË∞ÖÊí©ËÅäÂÉöÁñóÁáéÂØ•ËæΩÊΩ¶‰∫ÜÊíÇÈï£ÂªñÊñôÂàóË£ÇÁÉàÂä£ÁåéÁê≥ÊûóÁ£∑Èúñ‰∏¥ÈÇªÈ≥ûÊ∑ãÂáõËµÅÂêùÊãéÁé≤Ëè±Èõ∂ÈæÑÈìÉ‰º∂ÁæöÂáåÁÅµÈôµÂ≤≠È¢ÜÂè¶‰ª§Ê∫úÁêâÊ¶¥Á°´È¶èÁïôÂàòÁò§ÊµÅÊü≥ÂÖ≠ÈæôËÅãÂíôÁ¨ºÁ™ø"],["c240","Áø§ÁøßÁø®Áø™Áø´Áø¨Áø≠ÁøØÁø≤Áø¥",6,"ÁøΩÁøæÁøøËÄÇËÄáËÄàËÄâËÄäËÄéËÄèËÄëËÄìËÄöËÄõËÄùËÄûËÄüËÄ°ËÄ£ËÄ§ËÄ´",5,"ËÄ≤ËÄ¥ËÄπËÄ∫ËÄºËÄæËÅÄËÅÅËÅÑËÅÖËÅáËÅàËÅâËÅéËÅèËÅêËÅëËÅìËÅïËÅñËÅó"],["c280","ËÅôËÅõ",13,"ËÅ´",5,"ËÅ≤",11,"ÈöÜÂûÑÊã¢ÈôáÊ•ºÂ®ÑÊêÇÁØìÊºèÈôãËä¶Âç¢È¢ÖÂ∫êÁÇâÊé≥Âç§ËôèÈ≤ÅÈ∫ìÁ¢åÈú≤Ë∑ØËµÇÈπøÊΩûÁ¶ÑÂΩïÈôÜÊàÆÈ©¥ÂêïÈìù‰æ£ÊóÖÂ±•Â±°ÁºïËôëÊ∞ØÂæãÁéáÊª§ÁªøÂ≥¶ÊåõÂ≠™Êª¶Âçµ‰π±Êé†Áï•Êä°ËΩÆ‰º¶‰ªëÊ≤¶Á∫∂ËÆ∫ËêùËû∫ÁΩóÈÄªÈî£ÁÆ©È™°Ë£∏ËêΩÊ¥õÈ™ÜÁªúÂ¶àÈ∫ªÁéõÁ†ÅËöÇÈ©¨È™ÇÂòõÂêóÂüã‰π∞È∫¶ÂçñËøàËÑâÁûíÈ¶íËõÆÊª°ËîìÊõºÊÖ¢Êº´"],["c340","ËÅæËÇÅËÇÇËÇÖËÇàËÇäËÇç",5,"ËÇîËÇïËÇóËÇôËÇûËÇ£ËÇ¶ËÇßËÇ®ËÇ¨ËÇ∞ËÇ≥ËÇµËÇ∂ËÇ∏ËÇπËÇªËÉÖËÉá",4,"ËÉè",6,"ËÉòËÉüËÉ†ËÉ¢ËÉ£ËÉ¶ËÉÆËÉµËÉ∑ËÉπËÉªËÉæËÉøËÑÄËÑÅËÑÉËÑÑËÑÖËÑáËÑàËÑã"],["c380","ËÑåËÑïËÑóËÑôËÑõËÑúËÑùËÑü",12,"ËÑ≠ËÑÆËÑ∞ËÑ≥ËÑ¥ËÑµËÑ∑ËÑπ",4,"ËÑøË∞©ËäíËå´Áõ≤Ê∞ìÂøôËéΩÁå´ËåÖÈîöÊØõÁüõÈìÜÂçØËåÇÂÜíÂ∏ΩË≤åË¥∏‰πàÁé´ÊûöÊ¢ÖÈÖ∂ÈúâÁÖ§Ê≤°ÁúâÂ™íÈïÅÊØèÁæéÊòßÂØêÂ¶πÂ™öÈó®Èó∑‰ª¨ËêåËíôÊ™¨ÁõüÈî∞ÁåõÊ¢¶Â≠üÁúØÈÜöÈù°Á≥úËø∑Ë∞úÂº•Á±≥ÁßòËßÖÊ≥åËúúÂØÜÂπÇÊ£âÁú†ÁªµÂÜïÂÖçÂãâÂ®©ÁºÖÈù¢ËãóÊèèÁûÑËóêÁßíÊ∏∫Â∫ôÂ¶ôËîëÁÅ≠Ê∞ëÊäøÁöøÊïèÊÇØÈóΩÊòéËûüÈ∏£Èì≠ÂêçÂëΩË∞¨Êë∏"],["c440","ËÖÄ",5,"ËÖáËÖâËÖçËÖéËÖèËÖíËÖñËÖóËÖòËÖõ",4,"ËÖ°ËÖ¢ËÖ£ËÖ§ËÖ¶ËÖ®ËÖ™ËÖ´ËÖ¨ËÖØËÖ≤ËÖ≥ËÖµËÖ∂ËÖ∑ËÖ∏ËÜÅËÜÉ",4,"ËÜâËÜãËÜåËÜçËÜéËÜêËÜí",5,"ËÜôËÜöËÜû",4,"ËÜ§ËÜ•"],["c480","ËÜßËÜ©ËÜ´",7,"ËÜ¥",5,"ËÜºËÜΩËÜæËÜøËáÑËáÖËááËáàËáâËáãËáç",6,"ÊëπËòëÊ®°ËÜúÁ£®Êë©È≠îÊäπÊú´Ëé´Â¢®ÈªòÊ≤´Êº†ÂØûÈôåË∞ãÁâüÊüêÊãáÁâ°‰∫©ÂßÜÊØçÂ¢ìÊöÆÂπïÂãüÊÖïÊú®ÁõÆÁù¶ÁâßÁ©ÜÊãøÂì™ÂëêÈí†ÈÇ£Â®úÁ∫≥Ê∞ñ‰πÉÂ•∂ËÄêÂ•àÂçóÁî∑ÈöæÂõäÊå†ËÑëÊÅºÈóπÊ∑ñÂë¢È¶ÅÂÜÖÂ´©ËÉΩÂ¶ÆÈúìÂÄ™Ê≥•Â∞ºÊãü‰Ω†ÂåøËÖªÈÄÜÊ∫∫Ëî´ÊãàÂπ¥Á¢æÊíµÊçªÂøµÂ®òÈÖøÈ∏üÂ∞øÊçèËÅÇÂ≠ΩÂïÆÈïäÈïçÊ∂ÖÊÇ®Êü†ÁãûÂáùÂÆÅ"],["c540","Ëáî",14,"Ëá§Ëá•Ëá¶Ëá®Ëá©Ëá´ËáÆ",4,"Ëáµ",5,"ËáΩËáøËàÉËàá",4,"ËàéËàèËàëËàìËàï",5,"ËàùËà†Ëà§Ëà•Ëà¶ËàßËà©ËàÆËà≤Ëà∫ËàºËàΩËàø"],["c580","ËâÄËâÅËâÇËâÉËâÖËâÜËâàËâäËâåËâçËâéËâê",7,"ËâôËâõËâúËâùËâûËâ†",7,"Ëâ©ÊãßÊ≥ûÁâõÊâ≠ÈíÆÁ∫ΩËÑìÊµìÂÜúÂºÑÂ•¥Âä™ÊÄíÂ•≥ÊöñËôêÁñüÊå™Êá¶Á≥ØËØ∫Âì¶Ê¨ßÈ∏•ÊÆ¥ËóïÂëïÂÅ∂Ê≤§Âï™Ë∂¥Áà¨Â∏ïÊÄïÁê∂ÊãçÊéíÁâåÂæòÊπÉÊ¥æÊîÄÊΩòÁõòÁ£êÁõºÁïîÂà§Âèõ‰πìÂ∫ûÊóÅËÄ™ËÉñÊäõÂíÜÂà®ÁÇÆË¢çË∑ëÊ≥°Âë∏ËÉöÂüπË£¥ËµîÈô™ÈÖç‰Ω©Ê≤õÂñ∑ÁõÜÁ†∞Êä®ÁÉπÊæéÂΩ≠Ëì¨Ê£öÁ°ºÁØ∑ËÜ®ÊúãÈπèÊçßÁ¢∞ÂùØÁ†íÈúπÊâπÊä´ÂäàÁêµÊØó"],["c640","Ëâ™Ëâ´Ëâ¨Ëâ≠Ëâ±ËâµËâ∂Ëâ∑Ëâ∏ËâªËâºËäÄËäÅËäÉËäÖËäÜËäáËäâËäåËäêËäìËäîËäïËäñËäöËäõËäûËä†Ëä¢Ëä£ËäßËä≤ËäµËä∂Ëä∫ËäªËäºËäøËãÄËãÇËãÉËãÖËãÜËãâËãêËãñËãôËãöËãùËã¢ËãßËã®Ëã©Ëã™Ëã¨Ëã≠ËãÆËã∞Ëã≤Ëã≥ËãµËã∂Ëã∏"],["c680","Ëã∫Ëãº",4,"ËåäËåãËåçËåêËåíËåìËåñËåòËåôËåù",9,"Ëå©Ëå™ËåÆËå∞Ëå≤Ëå∑ËåªËåΩÂï§ËÑæÁñ≤ÁöÆÂåπÁóûÂÉªÂ±ÅË≠¨ÁØáÂÅèÁâáÈ™óÈ£òÊºÇÁì¢Á•®ÊíáÁû•ÊãºÈ¢ëË¥´ÂìÅËÅò‰πíÂù™ËãπËêçÂπ≥Âá≠Áì∂ËØÑÂ±èÂù°Ê≥ºÈ¢áÂ©ÜÁ†¥È≠ÑËø´Á≤ïÂâñÊâëÈì∫‰ªÜËéÜËë°Ëè©Ëí≤ÂüîÊú¥ÂúÉÊôÆÊµ¶Ë∞±ÊõùÁÄëÊúüÊ¨∫Ê†ñÊàöÂ¶ª‰∏ÉÂáÑÊºÜÊüíÊ≤èÂÖ∂Ê£ãÂ•áÊ≠ßÁï¶Â¥éËÑêÈΩêÊóóÁ•àÁ•ÅÈ™ëËµ∑Â≤Ç‰πû‰ºÅÂêØÂ•ëÁ†åÂô®Ê∞îËøÑÂºÉÊ±ΩÊ≥£ËÆ´Êéê"],["c740","ËåæËåøËçÅËçÇËçÑËçÖËçàËçä",4,"ËçìËçï",4,"ËçùËç¢Ëç∞",6,"ËçπËç∫Ëçæ",6,"ËéáËéàËéäËéãËéåËéçËéèËéêËéëËéîËéïËéñËéóËéôËéöËéùËéüËé°",6,"Ëé¨Ëé≠ËéÆ"],["c780","ËéØËéµËéªËéæËéøËèÇËèÉËèÑËèÜËèàËèâËèãËèçËèéËèêËèëËèíËèìËèïËèóËèôËèöËèõËèûËè¢Ëè£Ëè§Ëè¶ËèßËè®Ëè´Ëè¨Ëè≠ÊÅ∞Ê¥ΩÁâµÊâ¶ÈíéÈìÖÂçÉËøÅÁ≠æ‰ªüË∞¶‰πæÈªîÈí±Èí≥ÂâçÊΩúÈÅ£ÊµÖË∞¥Â†ëÂµåÊ¨†Ê≠âÊû™ÂëõËÖîÁæåÂ¢ôËî∑Âº∫Êä¢Ê©áÈîπÊï≤ÊÇÑÊ°•Áûß‰πî‰æ®Â∑ßÈûòÊí¨ÁøòÂ≥≠‰øèÁ™çÂàáËåÑ‰∏îÊÄØÁ™ÉÈí¶‰æµ‰∫≤Áß¶Áê¥Âã§ËäπÊìíÁ¶ΩÂØùÊ≤ÅÈùíËΩªÊ∞¢ÂÄæÂçøÊ∏ÖÊìéÊô¥Ê∞∞ÊÉÖÈ°∑ËØ∑Â∫ÜÁêºÁ©∑Áßã‰∏òÈÇ±ÁêÉÊ±ÇÂõöÈÖãÊ≥ÖË∂ãÂå∫ËõÜÊõ≤Ë∫ØÂ±àÈ©±Ê∏†"],["c840","ËèÆËèØËè≥",4,"Ëè∫ËèªËèºËèæËèøËêÄËêÇËêÖËêáËêàËêâËêäËêêËêí",5,"ËêôËêöËêõËêû",5,"Ëê©",7,"Ëê≤",5,"ËêπËê∫ËêªËêæ",7,"ËëáËëàËëâ"],["c880","Ëëä",6,"Ëëí",4,"ËëòËëùËëûËëüËë†Ëë¢Ëë§",4,"Ëë™ËëÆËëØËë∞Ëë≤Ëë¥Ëë∑ËëπËëªËëºÂèñÂ®∂ÈæãË∂£ÂéªÂúàÈ¢ßÊùÉÈÜõÊ≥âÂÖ®ÁóäÊã≥Áä¨Âà∏ÂäùÁº∫ÁÇîÁò∏Âç¥ÈπäÊ¶∑Á°ÆÈõÄË£ôÁæ§ÁÑ∂ÁáÉÂÜâÊüìÁì§Â£§ÊîòÂö∑ËÆ©È•∂Êâ∞ÁªïÊÉπÁÉ≠Â£¨‰ªÅ‰∫∫ÂøçÈüß‰ªªËÆ§ÂàÉÂ¶äÁ∫´Êâî‰ªçÊó•ÊàéËå∏ËìâËç£ËûçÁÜîÊ∫∂ÂÆπÁªíÂÜóÊèâÊüîËÇâËåπË†ïÂÑíÂ≠∫Â¶ÇËæ±‰π≥Ê±ùÂÖ•Ë§•ËΩØÈòÆËïäÁëûÈîêÈó∞Ê∂¶Ëã•Âº±ÊííÊ¥íËê®ËÖÆÈ≥ÉÂ°ûËµõ‰∏âÂèÅ"],["c940","ËëΩ",4,"ËíÉËíÑËíÖËíÜËíäËíçËíè",7,"ËíòËíöËíõËíùËíûËíüËí†Ëí¢",12,"Ëí∞Ëí±Ëí≥ËíµËí∂Ëí∑ËíªËíºËíæËìÄËìÇËìÉËìÖËìÜËìáËìàËìãËìåËìéËìèËìíËìîËìïËìó"],["c980","Ëìò",4,"ËìûËì°Ëì¢Ëì§Ëìß",4,"Ëì≠ËìÆËìØËì±",10,"ËìΩËìæËîÄËîÅËîÇ‰ºûÊï£Ê°ëÂóì‰∏ßÊêîÈ™öÊâ´Â´ÇÁëüËâ≤Ê∂©Ê£ÆÂÉßËééÁ†ÇÊùÄÂàπÊ≤ôÁ∫±ÂÇªÂï•ÁÖûÁ≠õÊôíÁèäËã´ÊùâÂ±±Âà†ÁÖΩË°´Èó™ÈôïÊìÖËµ°ËÜ≥ÂñÑÊ±ïÊâáÁºÆÂ¢í‰º§ÂïÜËµèÊôå‰∏äÂ∞öË£≥Ê¢¢ÊçéÁ®çÁÉßËäçÂã∫Èü∂Â∞ëÂì®ÈÇµÁªçÂ•¢ËµäËõáËàåËàçËµ¶ÊëÑÂ∞ÑÊÖëÊ∂âÁ§æËÆæÁ†∑Áî≥Âëª‰º∏Ë∫´Ê∑±Â®†ÁªÖÁ•ûÊ≤àÂÆ°Â©∂ÁîöËÇæÊÖéÊ∏óÂ£∞ÁîüÁî•Áâ≤ÂçáÁª≥"],["ca40","ËîÉ",8,"ËîçËîéËîèËîêËîíËîîËîïËîñËîòËîôËîõËîúËîùËîûËî†Ëî¢",8,"Ëî≠",9,"Ëîæ",4,"ËïÑËïÖËïÜËïáËïã",10],["ca80","ËïóËïòËïöËïõËïúËïùËïü",4,"Ëï•Ëï¶ËïßËï©",8,"Ëï≥ËïµËï∂Ëï∑Ëï∏ËïºËïΩËïøËñÄËñÅÁúÅÁõõÂâ©ËÉúÂú£Â∏àÂ§±ÁãÆÊñΩÊπøËØóÂ∞∏Ëô±ÂçÅÁü≥ÊãæÊó∂‰ªÄÈ£üËöÄÂÆûËØÜÂè≤Áü¢‰ΩøÂ±éÈ©∂ÂßãÂºèÁ§∫Â£´‰∏ñÊüø‰∫ãÊã≠Ë™ìÈÄùÂäøÊòØÂóúÂô¨ÈÄÇ‰ªï‰æçÈáäÈ•∞Ê∞èÂ∏ÇÊÅÉÂÆ§ËßÜËØïÊî∂ÊâãÈ¶ñÂÆàÂØøÊéàÂîÆÂèóÁò¶ÂÖΩËî¨Êû¢Ê¢≥ÊÆäÊäíËæìÂèîËàíÊ∑ëÁñè‰π¶ËµéÂ≠∞ÁÜüËñØÊöëÊõôÁΩ≤ËúÄÈªçÈº†Â±ûÊúØËø∞Ê†ëÊùüÊàçÁ´ñÂ¢ÖÂ∫∂Êï∞Êº±"],["cb40","ËñÇËñÉËñÜËñà",6,"Ëñê",10,"Ëñù",6,"Ëñ•Ëñ¶ËñßËñ©Ëñ´Ëñ¨Ëñ≠Ëñ±",5,"Ëñ∏Ëñ∫",6,"ËóÇ",6,"Ëóä",4,"ËóëËóí"],["cb80","ËóîËóñ",5,"Ëóù",6,"Ëó•Ëó¶ËóßËó®Ëó™",14,"ÊÅïÂà∑ËÄçÊëîË°∞Áî©Â∏ÖÊ†ìÊã¥ÈúúÂèåÁàΩË∞ÅÊ∞¥Áù°Á®éÂêÆÁû¨È°∫ËàúËØ¥Á°ïÊúîÁÉÅÊñØÊíïÂò∂ÊÄùÁßÅÂè∏‰∏ùÊ≠ªËÇÜÂØ∫Âó£Âõõ‰º∫‰ººÈ•≤Â∑≥ÊùæËÄ∏ÊÄÇÈ¢ÇÈÄÅÂÆãËÆºËØµÊêúËâòÊìûÂóΩËãèÈÖ•‰øóÁ¥†ÈÄüÁ≤üÂÉ≥Â°ëÊ∫ØÂÆøËØâËÇÉÈÖ∏ËíúÁÆóËôΩÈöãÈöèÁª•È´ìÁ¢éÂ≤ÅÁ©óÈÅÇÈößÁ•üÂ≠ôÊçüÁ¨ãËìëÊ¢≠ÂîÜÁº©ÁêêÁ¥¢ÈîÅÊâÄÂ°å‰ªñÂÆÉÂ•πÂ°î"],["cc40","ËóπËó∫ËóºËóΩËóæËòÄ",4,"ËòÜ",10,"ËòíËòìËòîËòïËòó",15,"Ëò®Ëò™",13,"ËòπËò∫ËòªËòΩËòæËòøËôÄ"],["cc80","ËôÅ",11,"ËôíËôìËôï",4,"ËôõËôúËôùËôüËô†Ëô°Ëô£",7,"Áç≠ÊåûËπãË∏èËÉéËãîÊä¨Âè∞Ê≥∞ÈÖûÂ§™ÊÄÅÊ±∞ÂùçÊëäË¥™Áò´Êª©ÂùõÊ™ÄÁó∞ÊΩ≠Ë∞≠Ë∞àÂù¶ÊØØË¢íÁ¢≥Êé¢ÂèπÁÇ≠Ê±§Â°òÊê™Â†ÇÊ£†ËÜõÂîêÁ≥ñÂÄòË∫∫Ê∑åË∂üÁÉ´ÊéèÊ∂õÊªîÁª¶ËêÑÊ°ÉÈÄÉÊ∑òÈô∂ËÆ®Â•óÁâπËó§ËÖæÁñºË™äÊ¢ØÂâîË∏¢ÈîëÊèêÈ¢òËπÑÂïº‰ΩìÊõøÂöèÊÉïÊ∂ïÂâÉÂ±âÂ§©Ê∑ªÂ°´Áî∞ÁîúÊÅ¨ËàîËÖÜÊåëÊù°Ëø¢Áú∫Ë∑≥Ë¥¥ÈìÅÂ∏ñÂéÖÂê¨ÁÉÉ"],["cd40","Ëô≠ËôØËô∞Ëô≤",6,"ËöÉ",6,"Ëöé",4,"ËöîËöñ",5,"Ëöû",4,"Ëö•Ëö¶Ëö´Ëö≠ËöÆËö≤Ëö≥Ëö∑Ëö∏ËöπËöª",4,"ËõÅËõÇËõÉËõÖËõàËõåËõçËõíËõìËõïËõñËõóËõöËõú"],["cd80","ËõùËõ†Ëõ°Ëõ¢Ëõ£Ëõ•Ëõ¶ËõßËõ®Ëõ™Ëõ´Ëõ¨ËõØËõµËõ∂Ëõ∑Ëõ∫ËõªËõºËõΩËõøËúÅËúÑËúÖËúÜËúãËúåËúéËúèËúêËúëËúîËúñÊ±ÄÂª∑ÂÅú‰∫≠Â∫≠Êå∫ËâáÈÄöÊ°êÈÖÆÁû≥ÂêåÈìúÂΩ§Á´•Ê°∂ÊçÖÁ≠íÁªüÁóõÂÅ∑ÊäïÂ§¥ÈÄèÂá∏ÁßÉÁ™ÅÂõæÂæíÈÄîÊ∂ÇÂ±†ÂúüÂêêÂÖîÊπçÂõ¢Êé®È¢ìËÖøËúïË§™ÈÄÄÂêûÂ±ØËáÄÊãñÊâòËÑ±È∏µÈôÄÈ©ÆÈ©ºÊ§≠Â¶•ÊãìÂîæÊåñÂìáËõôÊ¥ºÂ®ÉÁì¶Ë¢úÊ≠™Â§ñË±åÂºØÊπæÁé©È°Ω‰∏∏ÁÉ∑ÂÆåÁ¢óÊåΩÊôöÁöñÊÉãÂÆõÂ©â‰∏áËÖïÊ±™Áéã‰∫°ÊûâÁΩëÂæÄÊó∫ÊúõÂøòÂ¶ÑÂ®Å"],["ce40","ËúôËúõËúùËúüËú†Ëú§Ëú¶ËúßËú®Ëú™Ëú´Ëú¨Ëú≠ËúØËú∞Ëú≤Ëú≥ËúµËú∂Ëú∏ËúπËú∫ËúºËúΩËùÄ",6,"ËùäËùãËùçËùèËùêËùëËùíËùîËùïËùñËùòËùö",5,"Ëù°Ëù¢Ëù¶",7,"ËùØËù±Ëù≤Ëù≥Ëùµ"],["ce80","Ëù∑Ëù∏ËùπËù∫ËùøËûÄËûÅËûÑËûÜËûáËûâËûäËûåËûé",4,"ËûîËûïËûñËûò",6,"Ëû†",4,"Â∑çÂæÆÂç±Èü¶ËøùÊ°ÖÂõ¥ÂîØÊÉü‰∏∫ÊΩçÁª¥ËãáËêéÂßî‰ºü‰º™Â∞æÁ∫¨Êú™ËîöÂë≥ÁïèËÉÉÂñÇÈ≠è‰ΩçÊ∏≠Ë∞ìÂ∞âÊÖ∞Âç´ÁòüÊ∏©ËöäÊñáÈóªÁ∫πÂêªÁ®≥Á¥äÈóÆÂó°ÁøÅÁìÆÊåùËúóÊ∂°Á™ùÊàëÊñ°ÂçßÊè°Ê≤ÉÂ∑´ÂëúÈí®‰πåÊ±°ËØ¨Â±ãÊó†ËäúÊ¢ßÂêæÂê¥ÊØãÊ≠¶‰∫îÊçÇÂçàËàû‰ºç‰æÆÂùûÊàäÈõæÊô§Áâ©ÂãøÂä°ÊÇüËØØÊòîÁÜôÊûêË•øÁ°íÁüΩÊô∞ÂòªÂê∏Èî°Áâ∫"],["cf40","Ëû•Ëû¶ËûßËû©Ëû™ËûÆËû∞Ëû±Ëû≤Ëû¥Ëû∂Ëû∑Ëû∏ËûπËûªËûºËûæËûøËüÅ",4,"ËüáËüàËüâËüå",4,"Ëüî",6,"ËüúËüùËüûËüüËü°Ëü¢Ëü£Ëü§Ëü¶ËüßËü®Ëü©Ëü´Ëü¨Ëü≠ËüØ",9],["cf80","Ëü∫ËüªËüºËüΩËüøË†ÄË†ÅË†ÇË†Ñ",5,"Ë†ã",7,"Ë†îË†óË†òË†ôË†öË†ú",4,"Ë†£Á®ÄÊÅØÂ∏åÊÇâËÜùÂ§ïÊÉúÁÜÑÁÉØÊ∫™Ê±êÁäÄÊ™ÑË¢≠Â∏≠‰π†Â™≥ÂñúÈì£Ê¥óÁ≥ªÈöôÊàèÁªÜÁûéËôæÂå£ÈúûËæñÊöáÂ≥°‰æ†Áã≠‰∏ãÂé¶Â§èÂêìÊéÄÈî®ÂÖà‰ªôÈ≤úÁ∫§Âí∏Ë¥§Ë°îËà∑Èó≤Ê∂éÂº¶Â´åÊòæÈô©Áé∞ÁåÆÂéøËÖ∫È¶ÖÁæ°ÂÆ™Èô∑ÈôêÁ∫øÁõ∏Âé¢Èï∂È¶ôÁÆ±Ë•ÑÊπò‰π°ÁøîÁ••ËØ¶ÊÉ≥Âìç‰∫´È°πÂ∑∑Ê©°ÂÉèÂêëË±°ËêßÁ°ùÈúÑÂâäÂìÆÂö£ÈîÄÊ∂àÂÆµÊ∑ÜÊôì"],["d040","Ë†§",13,"Ë†≥",5,"Ë†∫Ë†ªË†ΩË†æË†øË°ÅË°ÇË°ÉË°Ü",5,"Ë°é",5,"Ë°ïË°ñË°òË°ö",6,"Ë°¶Ë°ßË°™Ë°≠Ë°ØË°±Ë°≥Ë°¥Ë°µË°∂Ë°∏Ë°πË°∫"],["d080","Ë°ªË°ºË¢ÄË¢ÉË¢ÜË¢áË¢âË¢äË¢åË¢éË¢èË¢êË¢ëË¢ìË¢îË¢ïË¢ó",4,"Ë¢ù",4,"Ë¢£Ë¢•",5,"Â∞èÂ≠ùÊ†°ËÇñÂï∏Á¨ëÊïàÊ•î‰∫õÊ≠áËùéÈûãÂçèÊåüÊê∫ÈÇ™ÊñúËÉÅË∞êÂÜôÊ¢∞Âç∏ËüπÊáàÊ≥ÑÊ≥ªË∞¢Â±ëËñ™ËäØÈîåÊ¨£ËæõÊñ∞ÂøªÂøÉ‰ø°Ë°ÖÊòüËÖ•Áå©ÊÉ∫ÂÖ¥ÂàëÂûãÂΩ¢ÈÇ¢Ë°åÈÜíÂπ∏ÊùèÊÄßÂßìÂÖÑÂá∂ËÉ∏ÂåàÊ±πÈõÑÁÜä‰ºë‰øÆÁæûÊúΩÂóÖÈîàÁßÄË¢ñÁª£Â¢üÊàåÈúÄËôöÂòòÈ°ªÂæêËÆ∏ËìÑÈÖóÂèôÊó≠Â∫èÁïúÊÅ§ÁµÆÂ©øÁª™Áª≠ËΩ©ÂñßÂÆ£ÊÇ¨ÊóãÁéÑ"],["d140","Ë¢¨Ë¢ÆË¢ØË¢∞Ë¢≤",4,"Ë¢∏Ë¢πË¢∫Ë¢ªË¢ΩË¢æË¢øË£ÄË£ÉË£ÑË£áË£àË£äË£ãË£åË£çË£èË£êË£ëË£ìË£ñË£óË£ö",4,"Ë£†Ë£°Ë£¶Ë£ßË£©",6,"Ë£≤Ë£µË£∂Ë£∑Ë£∫Ë£ªË£ΩË£øË§ÄË§ÅË§É",5],["d180","Ë§âË§ã",4,"Ë§ëË§î",4,"Ë§ú",4,"Ë§¢Ë§£Ë§§Ë§¶Ë§ßË§®Ë§©Ë§¨Ë§≠Ë§ÆË§ØË§±Ë§≤Ë§≥Ë§µË§∑ÈÄâÁô£Áú©ÁªöÈù¥ËñõÂ≠¶Á©¥Èõ™Ë°ÄÂããÁÜèÂæ™Êó¨ËØ¢ÂØªÈ©ØÂ∑°ÊÆâÊ±õËÆ≠ËÆØÈÄäËøÖÂéãÊäºÈ∏¶È∏≠ÂëÄ‰∏´ËäΩÁâôËöúÂ¥ñË°ôÊ∂ØÈõÖÂìë‰∫öËÆ∂ÁÑâÂíΩÈòâÁÉüÊ∑πÁõê‰∏•Á†îËúíÂ≤©Âª∂Ë®ÄÈ¢úÈòéÁÇéÊ≤øÂ•ÑÊé©ÁúºË°çÊºîËâ≥Â†∞ÁáïÂéåÁ†öÈõÅÂîÅÂΩ¶ÁÑ∞ÂÆ¥Ë∞öÈ™åÊÆÉÂ§ÆÈ∏ØÁßßÊù®Êâ¨‰ΩØÁñ°ÁæäÊ¥ãÈò≥Ê∞ß‰ª∞ÁóíÂÖªÊ†∑ÊºæÈÇÄËÖ∞Â¶ñÁë∂"],["d240","Ë§∏",8,"Ë•ÇË•ÉË•Ö",24,"Ë•†",5,"Ë•ß",19,"Ë•º"],["d280","Ë•ΩË•æË¶ÄË¶ÇË¶ÑË¶ÖË¶á",26,"ÊëáÂ∞ßÈÅ•Á™ëË∞£ÂßöÂí¨ËàÄËçØË¶ÅËÄÄÊ§∞ÂôéËÄ∂Áà∑ÈáéÂÜ∂‰πüÈ°µÊéñ‰∏öÂè∂Êõ≥ËÖãÂ§úÊ∂≤‰∏ÄÂ£πÂåªÊèñÈì±‰æù‰ºäË°£È¢êÂ§∑ÈÅóÁßª‰ª™ËÉ∞ÁñëÊ≤ÇÂÆúÂß®ÂΩùÊ§ÖËöÅÂÄöÂ∑≤‰πôÁü£‰ª•Ëâ∫ÊäëÊòìÈÇëÂ±π‰∫øÂΩπËáÜÈÄ∏ËÇÑÁñ´‰∫¶Ë£îÊÑèÊØÖÂøÜ‰πâÁõäÊ∫¢ËØ£ËÆÆË∞äËØëÂºÇÁøºÁøåÁªéËåµËç´Âõ†ÊÆ∑Èü≥Èò¥ÂßªÂêüÈì∂Ê∑´ÂØÖÈ•ÆÂ∞πÂºïÈöê"],["d340","Ë¶¢",30,"ËßÉËßçËßìËßîËßïËßóËßòËßôËßõËßùËßüËß†Ëß°Ëß¢Ëß§ËßßËß®Ëß©Ëß™Ëß¨Ëß≠ËßÆËß∞Ëß±Ëß≤Ëß¥",6],["d380","Ëßª",4,"Ë®Å",5,"Ë®à",21,"Âç∞Ëã±Ê®±Â©¥Èπ∞Â∫îÁº®ËéπËê§Ëê•ËçßËùáËøéËµ¢ÁõàÂΩ±È¢ñÁ°¨Êò†ÂìüÊã•‰Ω£ËáÉÁóàÂ∫∏ÈõçË∏äËõπÂíèÊ≥≥Ê∂åÊ∞∏ÊÅøÂãáÁî®ÂπΩ‰ºòÊÇ†ÂøßÂ∞§Áî±ÈÇÆÈìÄÁäπÊ≤πÊ∏∏ÈÖâÊúâÂèãÂè≥‰ΩëÈáâËØ±ÂèàÂπºËøÇÊ∑§‰∫éÁõÇÊ¶ÜËôûÊÑöËàÜ‰Ωô‰øûÈÄæÈ±ºÊÑâÊ∏ùÊ∏îÈöÖ‰∫àÂ®±Èõ®‰∏éÂ±øÁ¶πÂÆáËØ≠ÁæΩÁéâÂüüËäãÈÉÅÂêÅÈÅáÂñªÂ≥™Âæ°ÊÑàÊ¨≤Áã±ËÇ≤Ë™â"],["d440","Ë®û",31,"Ë®ø",8,"Ë©â",21],["d480","Ë©ü",25,"Ë©∫",6,"Êµ¥ÂØìË£ïÈ¢ÑË±´È©≠È∏≥Ê∏äÂÜ§ÂÖÉÂû£Ë¢ÅÂéüÊè¥ËæïÂõ≠ÂëòÂúÜÁåøÊ∫êÁºòËøúËãëÊÑøÊÄ®Èô¢Êõ∞Á∫¶Ë∂äË∑ÉÈí•Â≤≥Á≤§ÊúàÊÇ¶ÈòÖËÄò‰∫ëÈÉßÂåÄÈô®ÂÖÅËøêËï¥ÈÖùÊôïÈüµÂ≠ïÂåùÁ†∏ÊùÇÊ†ΩÂìâÁÅæÂÆ∞ËΩΩÂÜçÂú®Âí±ÊîíÊöÇËµûËµÉËÑèËë¨ÈÅ≠Á≥üÂáøËóªÊû£Êó©Êæ°Ëö§Ë∫ÅÂô™ÈÄ†ÁöÇÁÅ∂Áá•Ë¥£Êã©ÂàôÊ≥ΩË¥ºÊÄéÂ¢ûÊÜéÊõæËµ†ÊâéÂñ≥Ê∏£Êú≠ËΩß"],["d540","Ë™Å",7,"Ë™ã",7,"Ë™î",46],["d580","Ë´É",32,"Èì°Èó∏Áú®Ê†ÖÊ¶®Âíã‰πçÁÇ∏ËØàÊëòÊñãÂÆÖÁ™ÑÂÄ∫ÂØ®ÁûªÊØ°Ë©πÁ≤òÊ≤æÁõèÊñ©ËæóÂ¥≠Â±ïËò∏Ê†àÂç†ÊàòÁ´ôÊπõÁªΩÊ®üÁ´†ÂΩ∞Êº≥Âº†ÊéåÊ∂®Êùñ‰∏àÂ∏êË¥¶‰ªóËÉÄÁò¥ÈöúÊãõÊò≠ÊâæÊ≤ºËµµÁÖßÁΩ©ÂÖÜËÇáÂè¨ÈÅÆÊäòÂì≤Ëõ∞ËæôËÄÖÈîóËîóËøôÊµôÁèçÊñüÁúüÁîÑÁ†ßËáªË¥ûÈíà‰æ¶ÊûïÁñπËØäÈúáÊåØÈïáÈòµËí∏Êå£ÁùÅÂæÅÁã∞‰∫âÊÄîÊï¥ÊãØÊ≠£Êîø"],["d640","Ë´§",34,"Ë¨à",27],["d680","Ë¨§Ë¨•Ë¨ß",30,"Â∏ßÁóáÈÉëËØÅËäùÊûùÊîØÂê±ËúòÁü•ËÇ¢ËÑÇÊ±Å‰πãÁªáËÅåÁõ¥Ê§çÊÆñÊâßÂÄº‰æÑÂùÄÊåáÊ≠¢Ë∂æÂè™Êó®Á∫∏ÂøóÊåöÊé∑Ëá≥Ëá¥ÁΩÆÂ∏úÂ≥ôÂà∂Êô∫Áß©Á®öË¥®ÁÇôÁóîÊªûÊ≤ªÁ™í‰∏≠ÁõÖÂø†ÈíüË°∑ÁªàÁßçËÇøÈáç‰ª≤‰ºóËàüÂë®Â∑ûÊ¥≤ËØåÁ≤•ËΩ¥ËÇòÂ∏öÂííÁö±ÂÆôÊòºÈ™§Áè†Ê†™ËõõÊú±Áå™ËØ∏ËØõÈÄêÁ´πÁÉõÁÖÆÊãÑÁû©Âò±‰∏ªËëóÊü±Âä©ËõÄË¥ÆÈì∏Á≠ë"],["d740","Ë≠Ü",31,"Ë≠ß",4,"Ë≠≠",25],["d780","ËÆá",24,"ËÆ¨ËÆ±ËÆªËØáËØêËØ™Ë∞âË∞û‰ΩèÊ≥®Á•ùÈ©ªÊäìÁà™ÊãΩ‰∏ìÁ†ñËΩ¨Êí∞ËµöÁØÜÊ°©Â∫ÑË£ÖÂ¶ÜÊíûÂ£ÆÁä∂Ê§éÈî•ËøΩËµòÂù†ÁºÄË∞ÜÂáÜÊçâÊãôÂçìÊ°åÁê¢ËåÅÈÖåÂïÑÁùÄÁÅºÊµäÂÖπÂí®ËµÑÂßøÊªãÊ∑ÑÂ≠úÁ¥´‰ªîÁ±ΩÊªìÂ≠êËá™Ê∏çÂ≠óÈ¨ÉÊ£ïË∏™ÂÆóÁªºÊÄªÁ∫µÈÇπËµ∞Â•èÊèçÁßüË∂≥ÂçíÊóèÁ•ñËØÖÈòªÁªÑÈíªÁ∫ÇÂò¥ÈÜâÊúÄÁΩ™Â∞äÈÅµÊò®Â∑¶‰ΩêÊüûÂÅö‰ΩúÂùêÂ∫ß"],["d840","Ë∞∏",8,"Ë±ÇË±ÉË±ÑË±ÖË±àË±äË±ãË±ç",7,"Ë±ñË±óË±òË±ôË±õ",5,"Ë±£",6,"Ë±¨",6,"Ë±¥Ë±µË±∂Ë±∑Ë±ª",6,"Ë≤ÉË≤ÑË≤ÜË≤á"],["d880","Ë≤àË≤ãË≤ç",6,"Ë≤ïË≤ñË≤óË≤ô",20,"‰∫ç‰∏åÂÖÄ‰∏êÂªøÂçÖ‰∏ï‰∫ò‰∏ûÈ¨≤Â≠¨Âô©‰∏®Á¶∫‰∏øÂåï‰πáÂ§≠ÁàªÂçÆÊ∞êÂõüËÉ§È¶óÊØìÁùæÈºó‰∏∂‰∫üÈºê‰πú‰π©‰∫ìËäàÂ≠õÂï¨Âòè‰ªÑÂéçÂéùÂé£Âé•ÂéÆÈù•ËµùÂåöÂèµÂå¶ÂåÆÂåæËµúÂç¶Âç£ÂàÇÂààÂàéÂà≠Âà≥ÂàøÂâÄÂâåÂâûÂâ°ÂâúËíØÂâΩÂäÇÂäÅÂäêÂäìÂÜÇÁΩî‰∫ª‰ªÉ‰ªâ‰ªÇ‰ª®‰ª°‰ª´‰ªû‰ºõ‰ª≥‰º¢‰Ω§‰ªµ‰º•‰ºß‰ºâ‰º´‰Ωû‰ΩßÊî∏‰Ωö‰Ωù"],["d940","Ë≤Æ",62],["d980","Ë≥≠",32,"‰Ωü‰Ωó‰º≤‰ºΩ‰Ω∂‰Ω¥‰æë‰æâ‰æÉ‰æè‰Ωæ‰Ωª‰æ™‰Ωº‰æ¨‰æî‰ø¶‰ø®‰ø™‰øÖ‰øö‰ø£‰øú‰øë‰øü‰ø∏ÂÄ©ÂÅå‰ø≥ÂÄ¨ÂÄèÂÄÆÂÄ≠‰øæÂÄúÂÄåÂÄ•ÂÄ®ÂÅæÂÅÉÂÅïÂÅàÂÅéÂÅ¨ÂÅªÂÇ•ÂÇßÂÇ©ÂÇ∫ÂÉñÂÑÜÂÉ≠ÂÉ¨ÂÉ¶ÂÉÆÂÑáÂÑã‰ªùÊ∞Ω‰Ωò‰Ω•‰øéÈæ†Ê±ÜÁ±¥ÂÖÆÂ∑ΩÈªâÈ¶òÂÜÅÂ§îÂãπÂåçË®áÂåêÂá´Â§ôÂÖï‰∫†ÂÖñ‰∫≥Ë°ÆË¢§‰∫µËÑîË£íÁ¶ÄÂ¨¥Ë†ÉÁæ∏ÂÜ´ÂÜ±ÂÜΩÂÜº"],["da40","Ë¥é",14,"Ë¥†ËµëËµíËµóËµüËµ•Ëµ®Ëµ©Ëµ™Ëµ¨ËµÆËµØËµ±Ëµ≤Ëµ∏",8,"Ë∂ÇË∂ÉË∂ÜË∂áË∂àË∂âË∂å",4,"Ë∂íË∂ìË∂ï",9,"Ë∂†Ë∂°"],["da80","Ë∂¢Ë∂§",12,"Ë∂≤Ë∂∂Ë∂∑Ë∂πË∂ªË∂ΩË∑ÄË∑ÅË∑ÇË∑ÖË∑áË∑àË∑âË∑äË∑çË∑êË∑íË∑ìË∑îÂááÂÜñÂÜ¢ÂÜ•ËÆ†ËÆ¶ËÆßËÆ™ËÆ¥ËÆµËÆ∑ËØÇËØÉËØãËØèËØéËØíËØìËØîËØñËØòËØôËØúËØüËØ†ËØ§ËØ®ËØ©ËØÆËØ∞ËØ≥ËØ∂ËØπËØºËØøË∞ÄË∞ÇË∞ÑË∞áË∞åË∞èË∞ëË∞íË∞îË∞ïË∞ñË∞ôË∞õË∞òË∞ùË∞üË∞†Ë∞°Ë∞•Ë∞ßË∞™Ë∞´Ë∞ÆË∞ØË∞≤Ë∞≥Ë∞µË∞∂Âç©Âç∫ÈòùÈò¢Èò°Èò±Èò™ÈòΩÈòºÈôÇÈôâÈôîÈôüÈôßÈô¨Èô≤Èô¥ÈöàÈöçÈöóÈö∞ÈÇóÈÇõÈÇùÈÇôÈÇ¨ÈÇ°ÈÇ¥ÈÇ≥ÈÇ∂ÈÇ∫"],["db40","Ë∑ïË∑òË∑ôË∑úË∑†Ë∑°Ë∑¢Ë∑•Ë∑¶Ë∑ßË∑©Ë∑≠Ë∑ÆË∑∞Ë∑±Ë∑≤Ë∑¥Ë∑∂Ë∑ºË∑æ",6,"Ë∏ÜË∏áË∏àË∏ãË∏çË∏éË∏êË∏ëË∏íË∏ìË∏ï",7,"Ë∏†Ë∏°Ë∏§",4,"Ë∏´Ë∏≠Ë∏∞Ë∏≤Ë∏≥Ë∏¥Ë∏∂Ë∏∑Ë∏∏Ë∏ªË∏ºË∏æ"],["db80","Ë∏øËπÉËπÖËπÜËπå",4,"Ëπì",5,"Ëπö",11,"ËπßËπ®Ëπ™Ëπ´ËπÆËπ±ÈÇ∏ÈÇ∞ÈÉèÈÉÖÈÇæÈÉêÈÉÑÈÉáÈÉìÈÉ¶ÈÉ¢ÈÉúÈÉóÈÉõÈÉ´ÈÉØÈÉæÈÑÑÈÑ¢ÈÑûÈÑ£ÈÑ±ÈÑØÈÑπÈÖÉÈÖÜÂàçÂ•ÇÂä¢Âä¨Âä≠ÂäæÂìøÂãêÂãñÂã∞ÂèüÁáÆÁüçÂª¥ÂáµÂáºÈ¨ØÂé∂ÂºÅÁïöÂ∑ØÂùåÂû©Âû°Â°æÂ¢ºÂ£ÖÂ£ëÂú©Âú¨Âú™Âú≥ÂúπÂúÆÂúØÂùúÂúªÂùÇÂù©ÂûÖÂù´ÂûÜÂùºÂùªÂù®Âù≠Âù∂Âù≥Âû≠Âû§ÂûåÂû≤ÂüèÂûßÂû¥ÂûìÂû†ÂüïÂüòÂüöÂüôÂüíÂû∏Âü¥ÂüØÂü∏Âü§Âüù"],["dc40","Ëπ≥ËπµËπ∑",4,"ËπΩËπæË∫ÄË∫ÇË∫ÉË∫ÑË∫ÜË∫à",6,"Ë∫ëË∫íË∫ìË∫ï",6,"Ë∫ùË∫ü",11,"Ë∫≠Ë∫ÆË∫∞Ë∫±Ë∫≥",6,"Ë∫ª",7],["dc80","ËªÉ",10,"Ëªè",21,"Â†ãÂ†çÂüΩÂü≠Â†ÄÂ†ûÂ†ôÂ°ÑÂ††Â°•Â°¨Â¢ÅÂ¢âÂ¢öÂ¢ÄÈ¶®ÈºôÊáøËâπËâΩËâøËäèËääËä®ËäÑËäéËäëËäóËäôËä´Ëä∏ËäæËä∞ËãàËãäËã£ËäòËä∑ËäÆËããËãåËãÅËä©Ëä¥Ëä°Ëä™ËäüËãÑËãéËä§Ëã°ËåâËã∑Ëã§ËåèËåáËãúËã¥ËãíËãòËååËãªËãìËåëËåöËåÜËåîËåïËã†ËãïËåúËçëËçõËçúËåàËéíËåºËå¥Ëå±ËéõËçûËåØËçèËçáËçÉËçüËçÄËåóËç†Ëå≠Ëå∫Ëå≥Ëç¶Ëç•"],["dd40","Ëª•",62],["dd80","Ëº§",32,"Ëç®ËåõËç©Ëç¨Ëç™Ëç≠ËçÆËé∞Ëç∏Ëé≥Ëé¥Ëé†Ëé™ËéìËéúËéÖËçºËé∂Ëé©ËçΩËé∏ËçªËéòËéûËé®Ëé∫ËéºËèÅËêÅËè•ËèòÂ†áËêòËêãËèùËèΩËèñËêúËê∏ËêëËêÜËèîËèüËêèËêÉËè∏ËèπËè™ËèÖËèÄËê¶Ëè∞Ëè°ËëúËëëËëöËëôËë≥ËíáËíàËë∫ËíâËë∏ËêºËëÜËë©Ëë∂ËíåËíéËê±Ëë≠ËìÅËìçËìêËì¶ËíΩËììËìäËíøËí∫Ëì†Ëí°ËíπËí¥ËíóËì•Ëì£ËîåÁîçËî∏Ëì∞ËîπËîüËî∫"],["de40","ËΩÖ",32,"ËΩ™ËæÄËæåËæíËæùËæ†Ëæ°Ëæ¢Ëæ§Ëæ•Ëæ¶ËæßËæ™Ëæ¨Ëæ≠ËæÆËæØËæ≤Ëæ≥Ëæ¥ËæµËæ∑Ëæ∏Ëæ∫ËæªËæºËæøËøÄËøÉËøÜ"],["de80","Ëøâ",4,"ËøèËøíËøñËøóËøöËø†Ëø°Ëø£ËøßËø¨ËøØËø±Ëø≤Ëø¥ËøµËø∂Ëø∫ËøªËøºËøæËøøÈÄáÈÄàÈÄåÈÄéÈÄìÈÄïÈÄòËïñËîªËìøËìºËïôËïàËï®Ëï§ËïûËï∫Áû¢ËïÉËï≤ËïªËñ§Ëñ®ËñáËñèËïπËñÆËñúËñÖËñπËñ∑Ëñ∞ËóìËóÅËóúËóøËòßËòÖËò©ËòñËòºÂªæÂºàÂ§ºÂ•ÅËÄ∑Â•ïÂ•öÂ•òÂåèÂ∞¢Â∞•Â∞¨Â∞¥ÊâåÊâ™ÊäüÊäªÊãäÊãöÊãóÊãÆÊå¢Êã∂ÊåπÊçãÊçÉÊé≠Êè∂Êç±Êç∫ÊééÊé¥Êç≠Êé¨ÊéäÊç©ÊéÆÊéºÊè≤Êè∏Êè†ÊèøÊèÑÊèûÊèéÊëíÊèÜÊéæÊëÖÊëÅÊêãÊêõÊê†ÊêåÊê¶Êê°ÊëûÊíÑÊë≠Êíñ"],["df40","ÈÄôÈÄúÈÄ£ÈÄ§ÈÄ•ÈÄß",5,"ÈÄ∞",4,"ÈÄ∑ÈÄπÈÄ∫ÈÄΩÈÄøÈÅÄÈÅÉÈÅÖÈÅÜÈÅà",4,"ÈÅéÈÅîÈÅïÈÅñÈÅôÈÅöÈÅú",5,"ÈÅ§ÈÅ¶ÈÅßÈÅ©ÈÅ™ÈÅ´ÈÅ¨ÈÅØ",4,"ÈÅ∂",6,"ÈÅæÈÇÅ"],["df80","ÈÇÑÈÇÖÈÇÜÈÇáÈÇâÈÇäÈÇå",4,"ÈÇíÈÇîÈÇñÈÇòÈÇöÈÇúÈÇûÈÇüÈÇ†ÈÇ§ÈÇ•ÈÇßÈÇ®ÈÇ©ÈÇ´ÈÇ≠ÈÇ≤ÈÇ∑ÈÇºÈÇΩÈÇøÈÉÄÊë∫Êí∑Êí∏ÊíôÊí∫ÊìÄÊìêÊìóÊì§Êì¢ÊîâÊî•ÊîÆÂºãÂøíÁîôÂºëÂçüÂè±ÂèΩÂè©Âè®ÂèªÂêíÂêñÂêÜÂëãÂëíÂëìÂëîÂëñÂëÉÂê°ÂëóÂëôÂê£Âê≤ÂíÇÂíîÂë∑Âë±Âë§ÂíöÂíõÂíÑÂë∂Âë¶ÂíùÂìêÂí≠ÂìÇÂí¥ÂìíÂíßÂí¶ÂììÂìîÂë≤Âí£ÂìïÂíªÂíøÂìåÂìôÂìöÂìúÂí©Âí™Âí§ÂìùÂìèÂìûÂîõÂìßÂî†ÂìΩÂîîÂì≥Âî¢Âî£ÂîèÂîëÂîßÂî™ÂïßÂñèÂñµÂïâÂï≠ÂïÅÂïïÂîøÂïêÂîº"],["e040","ÈÉÇÈÉÉÈÉÜÈÉàÈÉâÈÉãÈÉåÈÉçÈÉíÈÉîÈÉïÈÉñÈÉòÈÉôÈÉöÈÉûÈÉüÈÉ†ÈÉ£ÈÉ§ÈÉ•ÈÉ©ÈÉ™ÈÉ¨ÈÉÆÈÉ∞ÈÉ±ÈÉ≤ÈÉ≥ÈÉµÈÉ∂ÈÉ∑ÈÉπÈÉ∫ÈÉªÈÉºÈÉøÈÑÄÈÑÅÈÑÉÈÑÖ",19,"ÈÑöÈÑõÈÑú"],["e080","ÈÑùÈÑüÈÑ†ÈÑ°ÈÑ§",10,"ÈÑ∞ÈÑ≤",6,"ÈÑ∫",8,"ÈÖÑÂî∑ÂïñÂïµÂï∂Âï∑Âî≥Âî∞ÂïúÂñãÂóíÂñÉÂñ±ÂñπÂñàÂñÅÂñüÂïæÂóñÂñëÂïªÂóüÂñΩÂñæÂñîÂñôÂó™Âó∑ÂóâÂòüÂóëÂó´Âó¨ÂóîÂó¶ÂóùÂóÑÂóØÂó•Âó≤Âó≥ÂóåÂóçÂó®ÂóµÂó§ËæîÂòûÂòàÂòåÂòÅÂò§Âò£ÂóæÂòÄÂòßÂò≠ÂôòÂòπÂôóÂò¨ÂôçÂô¢ÂôôÂôúÂôåÂôîÂöÜÂô§Âô±Âô´ÂôªÂôºÂöÖÂöìÂöØÂõîÂõóÂõùÂõ°ÂõµÂõ´ÂõπÂõøÂúÑÂúäÂúâÂúúÂ∏èÂ∏ôÂ∏îÂ∏ëÂ∏±Â∏ªÂ∏º"],["e140","ÈÖÖÈÖáÈÖàÈÖëÈÖìÈÖîÈÖïÈÖñÈÖòÈÖôÈÖõÈÖúÈÖüÈÖ†ÈÖ¶ÈÖßÈÖ®ÈÖ´ÈÖ≠ÈÖ≥ÈÖ∫ÈÖªÈÖºÈÜÄ",4,"ÈÜÜÈÜàÈÜäÈÜéÈÜèÈÜì",6,"ÈÜú",5,"ÈÜ§",5,"ÈÜ´ÈÜ¨ÈÜ∞ÈÜ±ÈÜ≤ÈÜ≥ÈÜ∂ÈÜ∑ÈÜ∏ÈÜπÈÜª"],["e180","ÈÜº",10,"ÈáàÈáãÈáêÈáí",9,"Èáù",8,"Â∏∑ÂπÑÂπîÂπõÂπûÂπ°Â≤åÂ±∫Â≤çÂ≤êÂ≤ñÂ≤àÂ≤òÂ≤ôÂ≤ëÂ≤öÂ≤úÂ≤µÂ≤¢Â≤ΩÂ≤¨Â≤´Â≤±Â≤£Â≥ÅÂ≤∑Â≥ÑÂ≥íÂ≥§Â≥ãÂ≥•Â¥ÇÂ¥ÉÂ¥ßÂ¥¶Â¥ÆÂ¥§Â¥ûÂ¥ÜÂ¥õÂµòÂ¥æÂ¥¥Â¥ΩÂµ¨ÂµõÂµØÂµùÂµ´ÂµãÂµäÂµ©Âµ¥Â∂ÇÂ∂ôÂ∂ùË±≥Â∂∑Â∑ÖÂΩ≥ÂΩ∑ÂæÇÂæáÂæâÂæåÂæïÂæôÂæúÂæ®Âæ≠ÂæµÂæºË°¢ÂΩ°Áä≠Áä∞Áä¥Áä∑Áä∏ÁãÉÁãÅÁãéÁãçÁãíÁã®ÁãØÁã©Áã≤Áã¥Áã∑ÁåÅÁã≥ÁåÉÁã∫"],["e240","Èá¶",62],["e280","Èà•",32,"ÁãªÁåóÁåìÁå°ÁåäÁåûÁåùÁåïÁå¢ÁåπÁå•Áå¨Áå∏Áå±ÁçêÁççÁçóÁç†Áç¨ÁçØÁçæËàõÂ§•È£ßÂ§§Â§ÇÈ•£È•ß",5,"È•¥È•∑È•ΩÈ¶ÄÈ¶ÑÈ¶áÈ¶äÈ¶çÈ¶êÈ¶ëÈ¶ìÈ¶îÈ¶ïÂ∫ÄÂ∫ëÂ∫ãÂ∫ñÂ∫•Â∫†Â∫πÂ∫µÂ∫æÂ∫≥ËµìÂªíÂªëÂªõÂª®Âª™ËÜ∫ÂøÑÂøâÂøñÂøèÊÄÉÂøÆÊÄÑÂø°Âø§ÂøæÊÄÖÊÄÜÂø™Âø≠Âø∏ÊÄôÊÄµÊÄ¶ÊÄõÊÄèÊÄçÊÄ©ÊÄ´ÊÄäÊÄøÊÄ°ÊÅ∏ÊÅπÊÅªÊÅ∫ÊÅÇ"],["e340","ÈâÜ",45,"Èâµ",16],["e380","ÈäÜ",7,"Èäè",24,"ÊÅ™ÊÅΩÊÇñÊÇöÊÇ≠ÊÇùÊÇÉÊÇíÊÇåÊÇõÊÉ¨ÊÇªÊÇ±ÊÉùÊÉòÊÉÜÊÉöÊÇ¥ÊÑ†ÊÑ¶ÊÑïÊÑ£ÊÉ¥ÊÑÄÊÑéÊÑ´ÊÖäÊÖµÊÜ¨ÊÜîÊÜßÊÜ∑ÊáîÊáµÂøùÈö≥Èó©Èó´Èó±Èó≥ÈóµÈó∂ÈóºÈóæÈòÉÈòÑÈòÜÈòàÈòäÈòãÈòåÈòçÈòèÈòíÈòïÈòñÈòóÈòôÈòö‰∏¨ÁàøÊàïÊ∞µÊ±îÊ±úÊ±äÊ≤£Ê≤ÖÊ≤êÊ≤îÊ≤åÊ±®Ê±©Ê±¥Ê±∂Ê≤ÜÊ≤©Ê≥êÊ≥îÊ≤≠Ê≥∑Ê≥∏Ê≥±Ê≥óÊ≤≤Ê≥†Ê≥ñÊ≥∫Ê≥´Ê≥ÆÊ≤±Ê≥ìÊ≥ØÊ≥æ"],["e440","Èä®",5,"ÈäØ",24,"Èãâ",31],["e480","Èã©",32,"Ê¥πÊ¥ßÊ¥åÊµÉÊµàÊ¥áÊ¥ÑÊ¥ôÊ¥éÊ¥´ÊµçÊ¥ÆÊ¥µÊ¥öÊµèÊµíÊµîÊ¥≥Ê∂ëÊµØÊ∂ûÊ∂†ÊµûÊ∂ìÊ∂îÊµúÊµ†ÊµºÊµ£Ê∏öÊ∑áÊ∑ÖÊ∑ûÊ∏éÊ∂øÊ∑†Ê∏ëÊ∑¶Ê∑ùÊ∑ôÊ∏ñÊ∂´Ê∏åÊ∂ÆÊ∏´ÊπÆÊπéÊπ´Ê∫≤ÊπüÊ∫ÜÊπìÊπîÊ∏≤Ê∏•ÊπÑÊªüÊ∫±Ê∫òÊª†Êº≠Êª¢Ê∫•Ê∫ßÊ∫ΩÊ∫ªÊ∫∑ÊªóÊ∫¥ÊªèÊ∫èÊªÇÊ∫üÊΩ¢ÊΩÜÊΩáÊº§ÊºïÊªπÊºØÊº∂ÊΩãÊΩ¥Êº™ÊºâÊº©ÊæâÊæçÊæåÊΩ∏ÊΩ≤ÊΩºÊΩ∫Êøë"],["e540","Èåä",51,"Èåø",10],["e580","Èçä",31,"Èç´ÊøâÊæßÊæπÊæ∂ÊøÇÊø°ÊøÆÊøûÊø†ÊøØÁÄöÁÄ£ÁÄõÁÄπÁÄµÁÅèÁÅûÂÆÄÂÆÑÂÆïÂÆìÂÆ•ÂÆ∏ÁîØÈ™ûÊê¥ÂØ§ÂØÆË§∞ÂØ∞ËπáË¨áËæ∂ËøìËøïËø•ËøÆËø§Ëø©Ëø¶Ëø≥Ëø®ÈÄÖÈÄÑÈÄãÈÄ¶ÈÄëÈÄçÈÄñÈÄ°ÈÄµÈÄ∂ÈÄ≠ÈÄØÈÅÑÈÅëÈÅíÈÅêÈÅ®ÈÅòÈÅ¢ÈÅõÊöπÈÅ¥ÈÅΩÈÇÇÈÇàÈÇÉÈÇãÂΩêÂΩóÂΩñÂΩòÂ∞ªÂí´Â±êÂ±ôÂ≠±Â±£Â±¶ÁæºÂº™Âº©Âº≠Ëâ¥ÂººÈ¨ªÂ±ÆÂ¶ÅÂ¶ÉÂ¶çÂ¶©Â¶™Â¶£"],["e640","Èç¨",34,"Èéê",27],["e680","Èé¨",29,"ÈèãÈèåÈèçÂ¶óÂßäÂ¶´Â¶ûÂ¶§ÂßíÂ¶≤Â¶ØÂßóÂ¶æÂ®ÖÂ®ÜÂßùÂ®àÂß£ÂßòÂßπÂ®åÂ®âÂ®≤Â®¥Â®ëÂ®£Â®ìÂ©ÄÂ©ßÂ©äÂ©ïÂ®ºÂ©¢Â©µËÉ¨Â™™Â™õÂ©∑Â©∫Â™æÂ´´Â™≤Â´íÂ´îÂ™∏Â´†Â´£Â´±Â´ñÂ´¶Â´òÂ´úÂ¨âÂ¨óÂ¨ñÂ¨≤Â¨∑Â≠ÄÂ∞ïÂ∞úÂ≠öÂ≠•Â≠≥Â≠ëÂ≠ìÂ≠¢È©µÈ©∑È©∏È©∫È©øÈ©ΩÈ™ÄÈ™ÅÈ™ÖÈ™àÈ™äÈ™êÈ™íÈ™ìÈ™ñÈ™òÈ™õÈ™úÈ™ùÈ™üÈ™†È™¢È™£È™•È™ßÁ∫üÁ∫°Á∫£Á∫•Á∫®Á∫©"],["e740","Èèé",7,"Èèó",54],["e780","Èêé",32,"Á∫≠Á∫∞Á∫æÁªÄÁªÅÁªÇÁªâÁªãÁªåÁªêÁªîÁªóÁªõÁª†Áª°Áª®Áª´ÁªÆÁªØÁª±Áª≤ÁºçÁª∂Áª∫ÁªªÁªæÁºÅÁºÇÁºÉÁºáÁºàÁºãÁºåÁºèÁºëÁºíÁºóÁºôÁºúÁºõÁºüÁº°",6,"Áº™Áº´Áº¨Áº≠ÁºØ",4,"ÁºµÂπ∫ÁïøÂ∑õÁîæÈÇïÁééÁéëÁéÆÁé¢ÁéüÁèèÁèÇÁèëÁé∑Áé≥ÁèÄÁèâÁèàÁè•ÁèôÈ°ºÁêäÁè©ÁèßÁèûÁé∫Áè≤ÁêèÁê™ÁëõÁê¶Áê•Áê®Áê∞ÁêÆÁê¨"],["e840","ÈêØ",14,"Èêø",43,"Èë¨Èë≠ÈëÆÈëØ"],["e880","Èë∞",20,"ÈíëÈíñÈíòÈìáÈìèÈììÈìîÈìöÈì¶ÈìªÈîúÈî†ÁêõÁêöÁëÅÁëúÁëóÁëïÁëôÁë∑Áë≠ÁëæÁíúÁíéÁíÄÁíÅÁíáÁíãÁíûÁí®Áí©ÁíêÁíßÁìíÁí∫Èü™Èü´Èü¨ÊùåÊùìÊùûÊùàÊù©Êû•ÊûáÊù™Êù≥ÊûòÊûßÊùµÊû®ÊûûÊû≠ÊûãÊù∑ÊùºÊü∞Ê†âÊüòÊ†äÊü©Êû∞Ê†åÊüôÊûµÊüöÊû≥ÊüùÊ†ÄÊüÉÊû∏Êü¢Ê†éÊüÅÊüΩÊ†≤Ê†≥Ê°†Ê°°Ê°éÊ°¢Ê°ÑÊ°§Ê¢ÉÊ†ùÊ°ïÊ°¶Ê°ÅÊ°ßÊ°ÄÊ†æÊ°äÊ°âÊ†©Ê¢µÊ¢èÊ°¥Ê°∑Ê¢ìÊ°´Ê£ÇÊ•ÆÊ£ºÊ§üÊ§†Ê£π"],["e940","ÈîßÈî≥ÈîΩÈïÉÈïàÈïãÈïïÈïöÈï†ÈïÆÈï¥ÈïµÈï∑",7,"ÈñÄ",42],["e980","Èñ´",32,"Ê§§Ê£∞Ê§ãÊ§ÅÊ•óÊ££Ê§êÊ•±Ê§πÊ•†Ê•ÇÊ•ùÊ¶ÑÊ•´Ê¶ÄÊ¶òÊ•∏Ê§¥ÊßåÊ¶áÊ¶àÊßéÊ¶âÊ•¶Ê•£Ê•πÊ¶õÊ¶ßÊ¶ªÊ¶´Ê¶≠ÊßîÊ¶±ÊßÅÊßäÊßüÊ¶ïÊß†Ê¶çÊßøÊ®ØÊß≠Ê®óÊ®òÊ©•Êß≤Ê©ÑÊ®æÊ™†Ê©êÊ©õÊ®µÊ™éÊ©πÊ®ΩÊ®®Ê©òÊ©ºÊ™ëÊ™êÊ™©Ê™óÊ™´Áå∑ÁçíÊÆÅÊÆÇÊÆáÊÆÑÊÆíÊÆìÊÆçÊÆöÊÆõÊÆ°ÊÆ™ËΩ´ËΩ≠ËΩ±ËΩ≤ËΩ≥ËΩµËΩ∂ËΩ∏ËΩ∑ËΩπËΩ∫ËΩºËΩæËæÅËæÇËæÑËæáËæã"],["ea40","Èóå",27,"Èó¨ÈóøÈòáÈòìÈòòÈòõÈòûÈò†Èò£",6,"Èò´Èò¨Èò≠ÈòØÈò∞Èò∑Èò∏ÈòπÈò∫ÈòæÈôÅÈôÉÈôäÈôéÈôèÈôëÈôíÈôìÈôñÈôó"],["ea80","ÈôòÈôôÈôöÈôúÈôùÈôûÈô†Èô£Èô•Èô¶Èô´Èô≠",4,"Èô≥Èô∏",12,"ÈöáÈöâÈöäËæçËæéËæèËæòËæöËªéÊàãÊàóÊàõÊàüÊà¢Êà°Êà•Êà§Êà¨ËáßÁìØÁì¥ÁìøÁîèÁîëÁîìÊî¥ÊóÆÊóØÊó∞ÊòäÊòôÊù≤ÊòÉÊòïÊòÄÁÇÖÊõ∑ÊòùÊò¥Êò±Êò∂ÊòµËÄÜÊôüÊôîÊôÅÊôèÊôñÊô°ÊôóÊô∑ÊöÑÊöåÊößÊöùÊöæÊõõÊõúÊõ¶Êõ©Ë¥≤Ë¥≥Ë¥∂Ë¥ªË¥ΩËµÄËµÖËµÜËµàËµâËµáËµçËµïËµôËßáËßäËßãËßåËßéËßèËßêËßëÁâÆÁäüÁâùÁâ¶ÁâØÁâæÁâøÁäÑÁäãÁäçÁäèÁäíÊåàÊå≤Êé∞"],["eb40","ÈöåÈöéÈöëÈöíÈöìÈöïÈöñÈööÈöõÈöù",9,"Èö®",7,"Èö±Èö≤Èö¥ÈöµÈö∑Èö∏Èö∫ÈöªÈöøÈõÇÈõÉÈõàÈõäÈõãÈõêÈõëÈõìÈõîÈõñ",9,"Èõ°",6,"Èõ´"],["eb80","Èõ¨Èõ≠ÈõÆÈõ∞Èõ±Èõ≤Èõ¥ÈõµÈõ∏Èõ∫ÈõªÈõºÈõΩÈõøÈúÇÈúÉÈúÖÈúäÈúãÈúåÈúêÈúëÈúíÈúîÈúïÈúó",4,"ÈúùÈúüÈú†ÊêøÊìòËÄÑÊØ™ÊØ≥ÊØΩÊØµÊØπÊ∞ÖÊ∞áÊ∞ÜÊ∞çÊ∞ïÊ∞òÊ∞ôÊ∞öÊ∞°Ê∞©Ê∞§Ê∞™Ê∞≤ÊîµÊïïÊï´ÁâçÁâíÁâñÁà∞Ëô¢ÂàñËÇüËÇúËÇìËÇºÊúäËÇΩËÇ±ËÇ´ËÇ≠ËÇ¥ËÇ∑ËÉßËÉ®ËÉ©ËÉ™ËÉõËÉÇËÉÑËÉôËÉçËÉóÊúêËÉùËÉ´ËÉ±ËÉ¥ËÉ≠ËÑçËÑéËÉ≤ËÉºÊúïËÑíË±öËÑ∂ËÑûËÑ¨ËÑòËÑ≤ËÖàËÖåËÖìËÖ¥ËÖôËÖöËÖ±ËÖ†ËÖ©ËÖºËÖΩËÖ≠ËÖßÂ°çÂ™µËÜàËÜÇËÜëÊªïËÜ£ËÜ™ËáåÊú¶ËáäËÜª"],["ec40","Èú°",8,"Èú´Èú¨ÈúÆÈúØÈú±Èú≥",4,"Èú∫ÈúªÈúºÈúΩÈúø",18,"ÈùîÈùïÈùóÈùòÈùöÈùúÈùùÈùüÈù£Èù§Èù¶ÈùßÈù®Èù™",7],["ec80","Èù≤ÈùµÈù∑",4,"ÈùΩ",7,"ÈûÜ",4,"ÈûåÈûéÈûèÈûêÈûìÈûïÈûñÈûóÈûô",4,"ËáÅËÜ¶Ê¨§Ê¨∑Ê¨πÊ≠ÉÊ≠ÜÊ≠ôÈ£ëÈ£íÈ£ìÈ£ïÈ£ôÈ£öÊÆ≥ÂΩÄÊØÇËß≥ÊñêÈΩëÊñìÊñºÊóÜÊóÑÊóÉÊóåÊóéÊóíÊóñÁÇÄÁÇúÁÇñÁÇùÁÇªÁÉÄÁÇ∑ÁÇ´ÁÇ±ÁÉ®ÁÉäÁÑêÁÑìÁÑñÁÑØÁÑ±ÁÖ≥ÁÖúÁÖ®ÁÖÖÁÖ≤ÁÖäÁÖ∏ÁÖ∫ÁÜòÁÜ≥ÁÜµÁÜ®ÁÜ†Áá†ÁáîÁáßÁáπÁàùÁà®ÁÅ¨ÁÑòÁÖ¶ÁÜπÊàæÊàΩÊâÉÊâàÊââÁ§ªÁ•ÄÁ•ÜÁ•âÁ•õÁ•úÁ•ìÁ•öÁ•¢Á•óÁ•†Á•ØÁ•ßÁ•∫Á¶ÖÁ¶äÁ¶öÁ¶ßÁ¶≥ÂøëÂøê"],["ed40","ÈûûÈûüÈû°Èû¢Èû§",6,"Èû¨ÈûÆÈû∞Èû±Èû≥Èûµ",46],["ed80","Èü§Èü•Èü®ÈüÆ",4,"Èü¥Èü∑",23,"ÊÄºÊÅùÊÅöÊÅßÊÅÅÊÅôÊÅ£ÊÇ´ÊÑÜÊÑçÊÖùÊÜ©ÊÜùÊáãÊáëÊàÜËÇÄËÅøÊ≤ìÊ≥∂Ê∑ºÁü∂Áü∏Á†ÄÁ†âÁ†óÁ†òÁ†ëÊñ´Á†≠Á†úÁ†ùÁ†πÁ†∫Á†ªÁ†üÁ†ºÁ†•Á†¨Á†£Á†©Á°éÁ°≠Á°ñÁ°óÁ†¶Á°êÁ°áÁ°åÁ°™Á¢õÁ¢ìÁ¢öÁ¢áÁ¢úÁ¢°Á¢£Á¢≤Á¢πÁ¢•Á£îÁ£ôÁ£âÁ£¨Á£≤Á§ÖÁ£¥Á§ìÁ§§Á§ûÁ§¥ÈæõÈªπÈªªÈªºÁõ±ÁúÑÁúçÁõπÁúáÁúàÁúöÁú¢ÁúôÁú≠Áú¶ÁúµÁú∏ÁùêÁùëÁùáÁùÉÁùöÁù®"],["ee40","È†è",62],["ee80","È°é",32,"Áù¢Áù•ÁùøÁûçÁùΩÁûÄÁûåÁûëÁûüÁû†Áû∞ÁûµÁûΩÁî∫ÁïÄÁïéÁïãÁïàÁïõÁï≤ÁïπÁñÉÁΩòÁΩ°ÁΩüË©àÁΩ®ÁΩ¥ÁΩ±ÁΩπÁæÅÁΩæÁõçÁõ•Ë†≤ÈíÖÈíÜÈíáÈíãÈíäÈíåÈíçÈíèÈíêÈíîÈíóÈíïÈíöÈíõÈíúÈí£Èí§Èí´Èí™Èí≠Èí¨ÈíØÈí∞Èí≤Èí¥Èí∂",4,"ÈíºÈíΩÈíøÈìÑÈìà",6,"ÈìêÈìëÈìíÈìïÈìñÈìóÈìôÈìòÈìõÈìûÈìüÈì†Èì¢Èì§Èì•ÈìßÈì®Èì™"],["ef40","È°Ø",5,"È¢ãÈ¢éÈ¢íÈ¢ïÈ¢ôÈ¢£È¢®",37,"È£èÈ£êÈ£îÈ£ñÈ£óÈ£õÈ£úÈ£ùÈ£†",4],["ef80","È£•È£¶È£©",30,"Èì©Èì´ÈìÆÈìØÈì≥Èì¥ÈìµÈì∑ÈìπÈìºÈìΩÈìøÈîÉÈîÇÈîÜÈîáÈîâÈîäÈîçÈîéÈîèÈîí",4,"ÈîòÈîõÈîùÈîûÈîüÈî¢Èî™Èî´Èî©Èî¨Èî±Èî≤Èî¥Èî∂Èî∑Èî∏ÈîºÈîæÈîøÈïÇÈîµÈïÑÈïÖÈïÜÈïâÈïåÈïéÈïèÈïíÈïìÈïîÈïñÈïóÈïòÈïôÈïõÈïûÈïüÈïùÈï°Èï¢Èï§",8,"ÈïØÈï±Èï≤Èï≥Èî∫ÁüßÁü¨ÈõâÁßïÁß≠Áß£Áß´Á®ÜÂµáÁ®ÉÁ®ÇÁ®ûÁ®î"],["f040","È§à",4,"È§éÈ§èÈ§ë",28,"È§Ø",26],["f080","È•ä",9,"È•ñ",12,"È•§È•¶È•≥È•∏È•πÈ•ªÈ•æÈ¶ÇÈ¶ÉÈ¶âÁ®πÁ®∑Á©ëÈªèÈ¶•Á©∞ÁöàÁöéÁöìÁöôÁö§ÁìûÁì†Áî¨È∏†È∏¢È∏®",4,"È∏≤È∏±È∏∂È∏∏È∏∑È∏πÈ∏∫È∏æÈπÅÈπÇÈπÑÈπÜÈπáÈπàÈπâÈπãÈπåÈπéÈπëÈπïÈπóÈπöÈπõÈπúÈπûÈπ£Èπ¶",6,"Èπ±Èπ≠Èπ≥ÁñíÁñîÁññÁñ†ÁñùÁñ¨Áñ£Áñ≥Áñ¥Áñ∏ÁóÑÁñ±Áñ∞ÁóÉÁóÇÁóñÁóçÁó£Áó®Áó¶Áó§Áó´ÁóßÁòÉÁó±ÁóºÁóøÁòêÁòÄÁòÖÁòåÁòóÁòäÁò•ÁòòÁòïÁòô"],["f140","È¶åÈ¶éÈ¶ö",10,"È¶¶È¶ßÈ¶©",47],["f180","Èßô",32,"ÁòõÁòºÁò¢Áò†ÁôÄÁò≠Áò∞ÁòøÁòµÁôÉÁòæÁò≥ÁôçÁôûÁôîÁôúÁôñÁô´ÁôØÁøäÁ´¶Á©∏Á©πÁ™ÄÁ™ÜÁ™àÁ™ïÁ™¶Á™†Á™¨Á™®Á™≠Á™≥Ë°§Ë°©Ë°≤Ë°ΩË°øË¢ÇË¢¢Ë£ÜË¢∑Ë¢ºË£âË£¢Ë£éË££Ë£•Ë£±Ë§öË£ºË£®Ë£æË£∞Ë§°Ë§ôË§ìË§õË§äË§¥Ë§´Ë§∂Ë•ÅË•¶Ë•ªÁñãËÉ•Áö≤Áö¥ÁüúËÄíËÄîËÄñËÄúËÄ†ËÄ¢ËÄ•ËÄ¶ËÄßËÄ©ËÄ®ËÄ±ËÄãËÄµËÅÉËÅÜËÅçËÅíËÅ©ËÅ±Ë¶ÉÈ°∏È¢ÄÈ¢É"],["f240","Èß∫",62],["f280","È®π",32,"È¢âÈ¢åÈ¢çÈ¢èÈ¢îÈ¢öÈ¢õÈ¢ûÈ¢üÈ¢°È¢¢È¢•È¢¶ËôçËôîËô¨ËôÆËôøËô∫ËôºËôªËö®ËöçËöãËö¨ËöùËößËö£Ëö™ËöìËö©Ëö∂ËõÑËöµËõéËö∞Ëö∫Ëö±ËöØËõâËõèËö¥Ëõ©Ëõ±Ëõ≤Ëõ≠Ëõ≥ËõêËúìËõûËõ¥ËõüËõòËõëËúÉËúáËõ∏ËúàËúäËúçËúâËú£ËúªËúûËú•ËúÆËúöËúæËùàËú¥Ëú±Ëú©Ëú∑ËúøËûÇËú¢ËùΩËùæËùªËù†Ëù∞ËùåËùÆËûãËùìËù£ËùºËù§ËùôËù•ËûìËûØËû®Ëüí"],["f340","È©ö",17,"È©≤È™ÉÈ™âÈ™çÈ™éÈ™îÈ™ïÈ™ôÈ™¶È™©",6,"È™≤È™≥È™¥È™µÈ™πÈ™ªÈ™ΩÈ™æÈ™øÈ´ÉÈ´ÑÈ´Ü",4,"È´çÈ´éÈ´èÈ´êÈ´íÈ´îÈ´ïÈ´ñÈ´óÈ´ôÈ´öÈ´õÈ´ú"],["f380","È´ùÈ´ûÈ´†È´¢È´£È´§È´•È´ßÈ´®È´©È´™È´¨È´ÆÈ´∞",8,"È´∫È´º",6,"È¨ÑÈ¨ÖÈ¨ÜËüÜËûàËûÖËû≠ËûóËûÉËû´Ëü•Ëû¨ËûµËû≥ËüãËüìËûΩËüëËüÄËüäËüõËü™Ëü†ËüÆË†ñË†ìËüæË†äË†õË†°Ë†πË†ºÁº∂ÁΩÇÁΩÑÁΩÖËàêÁ´∫Á´ΩÁ¨àÁ¨ÉÁ¨ÑÁ¨ïÁ¨äÁ¨´Á¨èÁ≠áÁ¨∏Á¨™Á¨ôÁ¨ÆÁ¨±Á¨†Á¨•Á¨§Á¨≥Á¨æÁ¨ûÁ≠òÁ≠öÁ≠ÖÁ≠µÁ≠åÁ≠ùÁ≠†Á≠ÆÁ≠ªÁ≠¢Á≠≤Á≠±ÁÆêÁÆ¶ÁÆßÁÆ∏ÁÆ¨ÁÆùÁÆ®ÁÆÖÁÆ™ÁÆúÁÆ¢ÁÆ´ÁÆ¥ÁØëÁØÅÁØåÁØùÁØöÁØ•ÁØ¶ÁØ™Á∞åÁØæÁØºÁ∞èÁ∞ñÁ∞ã"],["f440","È¨áÈ¨â",5,"È¨êÈ¨ëÈ¨íÈ¨î",10,"È¨†È¨°È¨¢È¨§",10,"È¨∞È¨±È¨≥",7,"È¨ΩÈ¨æÈ¨øÈ≠ÄÈ≠ÜÈ≠äÈ≠ãÈ≠åÈ≠éÈ≠êÈ≠íÈ≠ìÈ≠ï",5],["f480","È≠õ",32,"Á∞üÁ∞™Á∞¶Á∞∏Á±ÅÁ±ÄËáæËàÅËàÇËàÑËá¨Ë°ÑËà°Ëà¢Ëà£Ëà≠ËàØËà®Ëà´Ëà∏ËàªËà≥Ëà¥ËàæËâÑËââËâãËâèËâöËâüËâ®Ë°æË¢ÖË¢àË£òË£üË•ûÁæùÁæüÁæßÁæØÁæ∞Áæ≤Á±ºÊïâÁ≤ëÁ≤ùÁ≤úÁ≤ûÁ≤¢Á≤≤Á≤ºÁ≤ΩÁ≥ÅÁ≥áÁ≥åÁ≥çÁ≥àÁ≥ÖÁ≥óÁ≥®ËâÆÊö®ÁæøÁøéÁøïÁø•Áø°Áø¶Áø©ÁøÆÁø≥Á≥∏Áµ∑Á∂¶Á∂ÆÁπáÁ∫õÈ∫∏È∫¥Ëµ≥Ë∂ÑË∂îË∂ëË∂±ËµßËµ≠Ë±áË±âÈÖäÈÖêÈÖéÈÖèÈÖ§"],["f540","È≠º",62],["f580","ÈÆª",32,"ÈÖ¢ÈÖ°ÈÖ∞ÈÖ©ÈÖØÈÖΩÈÖæÈÖ≤ÈÖ¥ÈÖπÈÜåÈÜÖÈÜêÈÜçÈÜëÈÜ¢ÈÜ£ÈÜ™ÈÜ≠ÈÜÆÈÜØÈÜµÈÜ¥ÈÜ∫Ë±ïÈπæË∂∏Ë∑´Ë∏ÖËπôËπ©Ë∂µË∂øË∂ºË∂∫Ë∑ÑË∑ñË∑óË∑öË∑ûË∑éË∑èË∑õË∑ÜË∑¨Ë∑∑Ë∑∏Ë∑£Ë∑πË∑ªË∑§Ë∏âË∑ΩË∏îË∏ùË∏üË∏¨Ë∏ÆË∏£Ë∏ØË∏∫ËπÄË∏πË∏µË∏ΩË∏±ËπâËπÅËπÇËπëËπíËπäËπ∞Ëπ∂ËπºËπØËπ¥Ë∫ÖË∫èË∫îË∫êË∫úË∫ûË±∏Ë≤ÇË≤äË≤ÖË≤òË≤îÊñõËßñËßûËßöËßú"],["f640","ÈØú",62],["f680","È∞õ",32,"Ëß•Ëß´ËßØË®æË¨¶ÈùìÈõ©Èõ≥ÈõØÈúÜÈúÅÈúàÈúèÈúéÈú™Èú≠Èú∞ÈúæÈæÄÈæÉÈæÖ",5,"ÈæåÈªæÈºãÈºçÈöπÈöºÈöΩÈõéÈõíÁûøÈõ†ÈäéÈäÆÈãàÈåæÈç™ÈèäÈéèÈêæÈë´È±øÈ≤ÇÈ≤ÖÈ≤ÜÈ≤áÈ≤àÁ®£È≤ãÈ≤éÈ≤êÈ≤ëÈ≤íÈ≤îÈ≤ïÈ≤öÈ≤õÈ≤û",5,"È≤•",4,"È≤´È≤≠È≤ÆÈ≤∞",7,"È≤∫È≤ªÈ≤ºÈ≤ΩÈ≥ÑÈ≥ÖÈ≥ÜÈ≥áÈ≥äÈ≥ã"],["f740","È∞º",62],["f780","È±ªÈ±ΩÈ±æÈ≤ÄÈ≤ÉÈ≤ÑÈ≤âÈ≤äÈ≤åÈ≤èÈ≤ìÈ≤ñÈ≤óÈ≤òÈ≤ôÈ≤ùÈ≤™È≤¨È≤ØÈ≤πÈ≤æ",4,"È≥àÈ≥âÈ≥ëÈ≥íÈ≥öÈ≥õÈ≥†È≥°È≥å",4,"È≥ìÈ≥îÈ≥ïÈ≥óÈ≥òÈ≥ôÈ≥úÈ≥ùÈ≥üÈ≥¢ÈùºÈûÖÈûëÈûíÈûîÈûØÈû´Èû£Èû≤Èû¥È™±È™∞È™∑ÈπòÈ™∂È™∫È™ºÈ´ÅÈ´ÄÈ´ÖÈ´ÇÈ´ãÈ´åÈ´ëÈ≠ÖÈ≠ÉÈ≠áÈ≠âÈ≠àÈ≠çÈ≠ëÈ£®È§çÈ§ÆÈ•ïÈ•îÈ´üÈ´°È´¶È´ØÈ´´È´ªÈ´≠È´πÈ¨àÈ¨èÈ¨ìÈ¨üÈ¨£È∫ΩÈ∫æÁ∏ªÈ∫ÇÈ∫áÈ∫àÈ∫ãÈ∫íÈèñÈ∫ùÈ∫üÈªõÈªúÈªùÈª†ÈªüÈª¢Èª©ÈªßÈª•Èª™ÈªØÈº¢Èº¨ÈºØÈºπÈº∑ÈºΩÈºæÈΩÑ"],["f840","È≥£",62],["f880","È¥¢",32],["f940","ÈµÉ",62],["f980","È∂Ç",32],["fa40","È∂£",62],["fa80","È∑¢",32],["fb40","È∏É",27,"È∏§È∏ßÈ∏ÆÈ∏∞È∏¥È∏ªÈ∏ºÈπÄÈπçÈπêÈπíÈπìÈπîÈπñÈπôÈπùÈπüÈπ†Èπ°Èπ¢Èπ•ÈπÆÈπØÈπ≤Èπ¥",9,"È∫Ä"],["fb80","È∫ÅÈ∫ÉÈ∫ÑÈ∫ÖÈ∫ÜÈ∫âÈ∫äÈ∫å",5,"È∫î",8,"È∫ûÈ∫†",5,"È∫ßÈ∫®È∫©È∫™"],["fc40","È∫´",8,"È∫µÈ∫∂È∫∑È∫πÈ∫∫È∫ºÈ∫ø",4,"ÈªÖÈªÜÈªáÈªàÈªäÈªãÈªåÈªêÈªíÈªìÈªïÈªñÈªóÈªôÈªöÈªûÈª°Èª£Èª§Èª¶Èª®Èª´Èª¨Èª≠ÈªÆÈª∞",8,"Èª∫ÈªΩÈªø",6],["fc80","ÈºÜ",4,"ÈºåÈºèÈºëÈºíÈºîÈºïÈºñÈºòÈºö",5,"Èº°Èº£",8,"Èº≠ÈºÆÈº∞Èº±"],["fd40","Èº≤",4,"Èº∏Èº∫ÈººÈºø",4,"ÈΩÖ",10,"ÈΩí",38],["fd80","ÈΩπ",5,"ÈæÅÈæÇÈæç",11,"ÈæúÈæùÈæûÈæ°",4,"Ô§¨Ô•πÔ¶ïÔßßÔß±"],["fe40","Ô®åÔ®çÔ®éÔ®èÔ®ëÔ®ìÔ®îÔ®òÔ®üÔ®†Ô®°Ô®£Ô®§Ô®ßÔ®®Ô®©"]]');

/***/ }),

/***/ 3246:
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('[["0","\\u0000",127],["8141","Í∞ÇÍ∞ÉÍ∞ÖÍ∞ÜÍ∞ã",4,"Í∞òÍ∞ûÍ∞üÍ∞°Í∞¢Í∞£Í∞•",6,"Í∞ÆÍ∞≤Í∞≥Í∞¥"],["8161","Í∞µÍ∞∂Í∞∑Í∞∫Í∞ªÍ∞ΩÍ∞æÍ∞øÍ±Å",9,"Í±åÍ±é",5,"Í±ï"],["8181","Í±ñÍ±óÍ±ôÍ±öÍ±õÍ±ù",18,"Í±≤Í±≥Í±µÍ±∂Í±πÍ±ª",4,"Í≤ÇÍ≤áÍ≤àÍ≤çÍ≤éÍ≤èÍ≤ëÍ≤íÍ≤ìÍ≤ï",6,"Í≤ûÍ≤¢",5,"Í≤´Í≤≠Í≤ÆÍ≤±",6,"Í≤∫Í≤æÍ≤øÍ≥ÄÍ≥ÇÍ≥ÉÍ≥ÖÍ≥ÜÍ≥áÍ≥âÍ≥äÍ≥ãÍ≥ç",7,"Í≥ñÍ≥ò",7,"Í≥¢Í≥£Í≥•Í≥¶Í≥©Í≥´Í≥≠Í≥ÆÍ≥≤Í≥¥Í≥∑",4,"Í≥æÍ≥øÍ¥ÅÍ¥ÇÍ¥ÉÍ¥ÖÍ¥á",4,"Í¥éÍ¥êÍ¥íÍ¥ì"],["8241","Í¥îÍ¥ïÍ¥ñÍ¥óÍ¥ôÍ¥öÍ¥õÍ¥ùÍ¥ûÍ¥üÍ¥°",7,"Í¥™Í¥´Í¥Æ",5],["8261","Í¥∂Í¥∑Í¥πÍ¥∫Í¥ªÍ¥Ω",6,"ÍµÜÍµàÍµä",5,"ÍµëÍµíÍµìÍµïÍµñÍµó"],["8281","Íµô",7,"Íµ¢Íµ§",7,"ÍµÆÍµØÍµ±Íµ≤Íµ∑Íµ∏ÍµπÍµ∫ÍµæÍ∂ÄÍ∂É",4,"Í∂äÍ∂ãÍ∂çÍ∂éÍ∂èÍ∂ë",10,"Í∂û",5,"Í∂•",17,"Í∂∏",7,"Í∑ÇÍ∑ÉÍ∑ÖÍ∑ÜÍ∑áÍ∑â",6,"Í∑íÍ∑î",7,"Í∑ùÍ∑ûÍ∑üÍ∑°Í∑¢Í∑£Í∑•",18],["8341","Í∑∫Í∑ªÍ∑ΩÍ∑æÍ∏Ç",5,"Í∏äÍ∏åÍ∏é",5,"Í∏ï",7],["8361","Í∏ù",18,"Í∏≤Í∏≥Í∏µÍ∏∂Í∏πÍ∏ªÍ∏º"],["8381","Í∏ΩÍ∏æÍ∏øÍπÇÍπÑÍπáÍπàÍπâÍπãÍπèÍπëÍπíÍπìÍπïÍπó",4,"ÍπûÍπ¢Íπ£Íπ§Íπ¶ÍπßÍπ™Íπ´Íπ≠ÍπÆÍπØÍπ±",6,"Íπ∫Íπæ",5,"Í∫Ü",5,"Í∫ç",46,"Í∫øÍªÅÍªÇÍªÉÍªÖ",6,"ÍªéÍªí",5,"ÍªöÍªõÍªù",8],["8441","Íª¶ÍªßÍª©Íª™Íª¨ÍªÆ",5,"ÍªµÍª∂Íª∑ÍªπÍª∫ÍªªÍªΩ",8],["8461","ÍºÜÍºâÍºäÍºãÍºåÍºéÍºèÍºë",18],["8481","Íº§",7,"ÍºÆÍºØÍº±Íº≥Íºµ",6,"ÍºæÍΩÄÍΩÑÍΩÖÍΩÜÍΩáÍΩä",5,"ÍΩë",10,"ÍΩû",5,"ÍΩ¶",18,"ÍΩ∫",5,"ÍæÅÍæÇÍæÉÍæÖÍæÜÍæáÍæâ",6,"ÍæíÍæìÍæîÍæñ",5,"Íæù",26,"Íæ∫ÍæªÍæΩÍææ"],["8541","ÍæøÍøÅ",5,"ÍøäÍøåÍøè",4,"Íøï",6,"Íøù",4],["8561","Íø¢",5,"Íø™",5,"Íø≤Íø≥ÍøµÍø∂Íø∑Íøπ",6,"ÎÄÇÎÄÉ"],["8581","ÎÄÖ",6,"ÎÄçÎÄéÎÄèÎÄëÎÄíÎÄìÎÄï",6,"ÎÄû",9,"ÎÄ©",26,"ÎÅÜÎÅáÎÅâÎÅãÎÅçÎÅèÎÅêÎÅëÎÅíÎÅñÎÅòÎÅöÎÅõÎÅúÎÅû",29,"ÎÅæÎÅøÎÇÅÎÇÇÎÇÉÎÇÖ",6,"ÎÇéÎÇêÎÇí",5,"ÎÇõÎÇùÎÇûÎÇ£ÎÇ§"],["8641","ÎÇ•ÎÇ¶ÎÇßÎÇ™ÎÇ∞ÎÇ≤ÎÇ∂ÎÇ∑ÎÇπÎÇ∫ÎÇªÎÇΩ",6,"ÎÉÜÎÉä",5,"ÎÉí"],["8661","ÎÉìÎÉïÎÉñÎÉóÎÉô",6,"ÎÉ°ÎÉ¢ÎÉ£ÎÉ§ÎÉ¶",10],["8681","ÎÉ±",22,"ÎÑäÎÑçÎÑéÎÑèÎÑëÎÑîÎÑïÎÑñÎÑóÎÑöÎÑû",4,"ÎÑ¶ÎÑßÎÑ©ÎÑ™ÎÑ´ÎÑ≠",6,"ÎÑ∂ÎÑ∫",5,"ÎÖÇÎÖÉÎÖÖÎÖÜÎÖáÎÖâ",6,"ÎÖíÎÖìÎÖñÎÖóÎÖôÎÖöÎÖõÎÖùÎÖûÎÖüÎÖ°",22,"ÎÖ∫ÎÖªÎÖΩÎÖæÎÖøÎÜÅÎÜÉ",4,"ÎÜäÎÜåÎÜéÎÜèÎÜêÎÜëÎÜïÎÜñÎÜóÎÜôÎÜöÎÜõÎÜù"],["8741","ÎÜû",9,"ÎÜ©",15],["8761","ÎÜπ",18,"ÎáçÎáéÎáèÎáëÎáíÎáìÎáï"],["8781","Îáñ",5,"ÎáûÎá†",7,"Îá™Îá´Îá≠ÎáÆÎáØÎá±",7,"Îá∫ÎáºÎáæ",5,"ÎàÜÎàáÎàâÎàäÎàç",6,"ÎàñÎàòÎàö",5,"Îà°",18,"Îàµ",6,"ÎàΩ",26,"ÎâôÎâöÎâõÎâùÎâûÎâüÎâ°",6,"Îâ™",4],["8841","ÎâØ",4,"Îâ∂",5,"ÎâΩ",6,"ÎäÜÎäáÎäàÎää",4],["8861","ÎäèÎäíÎäìÎäïÎäñÎäóÎäõ",4,"Îä¢Îä§ÎäßÎä®Îä©Îä´Îä≠ÎäÆÎäØÎä±Îä≤Îä≥ÎäµÎä∂Îä∑"],["8881","Îä∏",15,"ÎãäÎããÎãçÎãéÎãèÎãëÎãì",4,"ÎãöÎãúÎãûÎãüÎã†Îã°Îã£ÎãßÎã©Îã™Îã∞Îã±Îã≤Îã∂ÎãºÎãΩÎãæÎåÇÎåÉÎåÖÎåÜÎåáÎåâ",6,"ÎåíÎåñ",5,"Îåù",54,"ÎçóÎçôÎçöÎçùÎç†Îç°Îç¢Îç£"],["8941","Îç¶Îç®Îç™Îç¨Îç≠ÎçØÎç≤Îç≥ÎçµÎç∂Îç∑Îçπ",6,"ÎéÇÎéÜ",5,"Îéç"],["8961","ÎééÎéèÎéëÎéíÎéìÎéï",10,"Îé¢",5,"Îé©Îé™Îé´Îé≠"],["8981","ÎéÆ",21,"ÎèÜÎèáÎèâÎèäÎèçÎèèÎèëÎèíÎèìÎèñÎèòÎèöÎèúÎèûÎèüÎè°Îè¢Îè£Îè•Îè¶ÎèßÎè©",18,"ÎèΩ",18,"Îêë",6,"ÎêôÎêöÎêõÎêùÎêûÎêüÎê°",6,"Îê™Îê¨",7,"Îêµ",15],["8a41","ÎëÖ",10,"ÎëíÎëìÎëïÎëñÎëóÎëô",6,"Îë¢Îë§Îë¶"],["8a61","Îëß",4,"Îë≠",18,"ÎíÅÎíÇ"],["8a81","ÎíÉ",4,"Îíâ",19,"Îíû",5,"Îí•Îí¶ÎíßÎí©Îí™Îí´Îí≠",7,"Îí∂Îí∏Îí∫",5,"ÎìÅÎìÇÎìÉÎìÖÎìÜÎìáÎìâ",6,"ÎìëÎìíÎììÎìîÎìñ",5,"ÎìûÎìüÎì°Îì¢Îì•Îìß",4,"ÎìÆÎì∞Îì≤",5,"Îìπ",26,"ÎîñÎîóÎîôÎîöÎîù"],["8b41","Îîû",5,"Îî¶Îî´",4,"Îî≤Îî≥ÎîµÎî∂Îî∑Îîπ",6,"ÎïÇÎïÜ"],["8b61","ÎïáÎïàÎïâÎïäÎïéÎïèÎïëÎïíÎïìÎïï",6,"ÎïûÎï¢",8],["8b81","Îï´",52,"Îñ¢Îñ£Îñ•Îñ¶ÎñßÎñ©Îñ¨Îñ≠ÎñÆÎñØÎñ≤Îñ∂",4,"ÎñæÎñøÎóÅÎóÇÎóÉÎóÖ",6,"ÎóéÎóí",5,"Îóô",18,"Îó≠",18],["8c41","ÎòÄ",15,"ÎòíÎòìÎòïÎòñÎòóÎòô",4],["8c61","Îòû",6,"Îò¶",5,"Îò≠",6,"Îòµ",5],["8c81","Îòª",12,"Îôâ",26,"Îô•Îô¶ÎôßÎô©",50,"ÎöûÎöüÎö°Îö¢Îö£Îö•",5,"Îö≠ÎöÆÎöØÎö∞Îö≤",16],["8d41","ÎõÉ",16,"Îõï",8],["8d61","Îõû",17,"Îõ±Îõ≤Îõ≥ÎõµÎõ∂Îõ∑ÎõπÎõ∫"],["8d81","Îõª",4,"ÎúÇÎúÉÎúÑÎúÜ",33,"Îú™Îú´Îú≠ÎúÆÎú±",6,"Îú∫Îúº",7,"ÎùÖÎùÜÎùáÎùâÎùäÎùãÎùç",6,"Îùñ",9,"Îù°Îù¢Îù£Îù•Îù¶ÎùßÎù©",6,"Îù≤Îù¥Îù∂",5,"ÎùæÎùøÎûÅÎûÇÎûÉÎûÖ",6,"ÎûéÎûìÎûîÎûïÎûöÎûõÎûùÎûû"],["8e41","ÎûüÎû°",6,"Îû™ÎûÆ",5,"Îû∂Îû∑Îûπ",8],["8e61","ÎüÇ",4,"ÎüàÎüä",19],["8e81","Îüû",13,"ÎüÆÎüØÎü±Îü≤Îü≥Îüµ",6,"ÎüæÎ†Ç",4,"Î†äÎ†ãÎ†çÎ†éÎ†èÎ†ë",6,"Î†öÎ†úÎ†û",5,"Î†¶Î†ßÎ†©Î†™Î†´Î†≠",6,"Î†∂Î†∫",5,"Î°ÅÎ°ÇÎ°ÉÎ°Ö",11,"Î°íÎ°î",7,"Î°ûÎ°üÎ°°Î°¢Î°£Î°•",6,"Î°ÆÎ°∞Î°≤",5,"Î°πÎ°∫Î°ªÎ°Ω",7],["8f41","Î¢Ö",7,"Î¢é",17],["8f61","Î¢†",7,"Î¢©",6,"Î¢±Î¢≤Î¢≥Î¢µÎ¢∂Î¢∑Î¢π",4],["8f81","Î¢æÎ¢øÎ£ÇÎ£ÑÎ£Ü",5,"Î£çÎ£éÎ£èÎ£ëÎ£íÎ£ìÎ£ï",7,"Î£ûÎ£†Î£¢",5,"Î£™Î£´Î£≠Î£ÆÎ£ØÎ£±",6,"Î£∫Î£ºÎ£æ",5,"Î§Ö",18,"Î§ô",6,"Î§°",26,"Î§æÎ§øÎ•ÅÎ•ÇÎ•ÉÎ•Ö",6,"Î•çÎ•éÎ•êÎ•í",5],["9041","Î•öÎ•õÎ•ùÎ•ûÎ•üÎ•°",6,"Î•™Î•¨Î•Æ",5,"Î•∂Î•∑Î•πÎ•∫Î•ªÎ•Ω"],["9061","Î•æ",5,"Î¶ÜÎ¶àÎ¶ãÎ¶åÎ¶è",15],["9081","Î¶ü",12,"Î¶ÆÎ¶ØÎ¶±Î¶≤Î¶≥Î¶µ",6,"Î¶æÎßÄÎßÇ",5,"ÎßäÎßãÎßçÎßì",4,"ÎßöÎßúÎßüÎß†Îß¢Îß¶ÎßßÎß©Îß™Îß´Îß≠",6,"Îß∂Îßª",4,"Î®Ç",5,"Î®â",11,"Î®ñ",33,"Î®∫Î®ªÎ®ΩÎ®æÎ®øÎ©ÅÎ©ÉÎ©ÑÎ©ÖÎ©Ü"],["9141","Î©áÎ©äÎ©åÎ©èÎ©êÎ©ëÎ©íÎ©ñÎ©óÎ©ôÎ©öÎ©õÎ©ù",6,"Î©¶Î©™",5],["9161","Î©≤Î©≥Î©µÎ©∂Î©∑Î©π",9,"Î™ÜÎ™àÎ™âÎ™äÎ™ãÎ™ç",5],["9181","Î™ì",20,"Î™™Î™≠Î™ÆÎ™ØÎ™±Î™≥",4,"Î™∫Î™ºÎ™æ",5,"Î´ÖÎ´ÜÎ´áÎ´â",14,"Î´ö",33,"Î´ΩÎ´æÎ´øÎ¨ÅÎ¨ÇÎ¨ÉÎ¨Ö",7,"Î¨éÎ¨êÎ¨í",5,"Î¨ôÎ¨öÎ¨õÎ¨ùÎ¨ûÎ¨üÎ¨°",6],["9241","Î¨®Î¨™Î¨¨",7,"Î¨∑Î¨πÎ¨∫Î¨ø",4,"Î≠ÜÎ≠àÎ≠äÎ≠ãÎ≠åÎ≠éÎ≠ëÎ≠í"],["9261","Î≠ìÎ≠ïÎ≠ñÎ≠óÎ≠ô",7,"Î≠¢Î≠§",7,"Î≠≠",4],["9281","Î≠≤",21,"ÎÆâÎÆäÎÆãÎÆçÎÆéÎÆèÎÆë",18,"ÎÆ•ÎÆ¶ÎÆßÎÆ©ÎÆ™ÎÆ´ÎÆ≠",6,"ÎÆµÎÆ∂ÎÆ∏",7,"ÎØÅÎØÇÎØÉÎØÖÎØÜÎØáÎØâ",6,"ÎØëÎØíÎØî",35,"ÎØ∫ÎØªÎØΩÎØæÎ∞Å"],["9341","Î∞É",4,"Î∞äÎ∞éÎ∞êÎ∞íÎ∞ìÎ∞ôÎ∞öÎ∞†Î∞°Î∞¢Î∞£Î∞¶Î∞®Î∞™Î∞´Î∞¨Î∞ÆÎ∞ØÎ∞≤Î∞≥Î∞µ"],["9361","Î∞∂Î∞∑Î∞π",6,"Î±ÇÎ±ÜÎ±áÎ±àÎ±äÎ±ãÎ±éÎ±èÎ±ë",8],["9381","Î±öÎ±õÎ±úÎ±û",37,"Î≤ÜÎ≤áÎ≤âÎ≤äÎ≤çÎ≤è",4,"Î≤ñÎ≤òÎ≤õ",4,"Î≤¢Î≤£Î≤•Î≤¶Î≤©",6,"Î≤≤Î≤∂",5,"Î≤æÎ≤øÎ≥ÅÎ≥ÇÎ≥ÉÎ≥Ö",7,"Î≥éÎ≥íÎ≥ìÎ≥îÎ≥ñÎ≥óÎ≥ôÎ≥öÎ≥õÎ≥ù",22,"Î≥∑Î≥πÎ≥∫Î≥ªÎ≥Ω"],["9441","Î≥æ",5,"Î¥ÜÎ¥àÎ¥ä",5,"Î¥ëÎ¥íÎ¥ìÎ¥ï",8],["9461","Î¥û",5,"Î¥•",6,"Î¥≠",12],["9481","Î¥∫",5,"ÎµÅ",6,"ÎµäÎµãÎµçÎµéÎµèÎµë",6,"Îµö",9,"Îµ•Îµ¶ÎµßÎµ©",22,"Î∂ÇÎ∂ÉÎ∂ÖÎ∂ÜÎ∂ã",4,"Î∂íÎ∂îÎ∂ñÎ∂óÎ∂òÎ∂õÎ∂ù",6,"Î∂•",10,"Î∂±",6,"Î∂π",24],["9541","Î∑íÎ∑ìÎ∑ñÎ∑óÎ∑ôÎ∑öÎ∑õÎ∑ù",11,"Î∑™",5,"Î∑±"],["9561","Î∑≤Î∑≥Î∑µÎ∑∂Î∑∑Î∑π",6,"Î∏ÅÎ∏ÇÎ∏ÑÎ∏Ü",5,"Î∏éÎ∏èÎ∏ëÎ∏íÎ∏ì"],["9581","Î∏ï",6,"Î∏ûÎ∏†",35,"ÎπÜÎπáÎπâÎπäÎπãÎπçÎπè",4,"ÎπñÎπòÎπúÎπùÎπûÎπüÎπ¢Îπ£Îπ•Îπ¶ÎπßÎπ©Îπ´",4,"Îπ≤Îπ∂",4,"ÎπæÎπøÎ∫ÅÎ∫ÇÎ∫ÉÎ∫Ö",6,"Î∫éÎ∫í",5,"Î∫ö",13,"Î∫©",14],["9641","Î∫∏",23,"ÎªíÎªì"],["9661","ÎªïÎªñÎªô",6,"Îª°Îª¢Îª¶",5,"Îª≠",8],["9681","Îª∂",10,"ÎºÇ",5,"Îºä",13,"ÎºöÎºû",33,"ÎΩÇÎΩÉÎΩÖÎΩÜÎΩáÎΩâ",6,"ÎΩíÎΩìÎΩîÎΩñ",44],["9741","ÎæÉ",16,"Îæï",8],["9761","Îæû",17,"Îæ±",7],["9781","Îæπ",11,"ÎøÜ",5,"ÎøéÎøèÎøëÎøíÎøìÎøï",6,"ÎøùÎøûÎø†Îø¢",89,"ÏÄΩÏÄæÏÄø"],["9841","ÏÅÄ",16,"ÏÅí",5,"ÏÅôÏÅöÏÅõ"],["9861","ÏÅùÏÅûÏÅüÏÅ°",6,"ÏÅ™",15],["9881","ÏÅ∫",21,"ÏÇíÏÇìÏÇïÏÇñÏÇóÏÇô",6,"ÏÇ¢ÏÇ§ÏÇ¶",5,"ÏÇÆÏÇ±ÏÇ≤ÏÇ∑",4,"ÏÇæÏÉÇÏÉÉÏÉÑÏÉÜÏÉáÏÉäÏÉãÏÉçÏÉéÏÉèÏÉë",6,"ÏÉöÏÉû",5,"ÏÉ¶ÏÉßÏÉ©ÏÉ™ÏÉ´ÏÉ≠",6,"ÏÉ∂ÏÉ∏ÏÉ∫",5,"ÏÑÅÏÑÇÏÑÉÏÑÖÏÑÜÏÑáÏÑâ",6,"ÏÑëÏÑíÏÑìÏÑîÏÑñ",5,"ÏÑ°ÏÑ¢ÏÑ•ÏÑ®ÏÑ©ÏÑ™ÏÑ´ÏÑÆ"],["9941","ÏÑ≤ÏÑ≥ÏÑ¥ÏÑµÏÑ∑ÏÑ∫ÏÑªÏÑΩÏÑæÏÑøÏÖÅ",6,"ÏÖäÏÖé",5,"ÏÖñÏÖó"],["9961","ÏÖôÏÖöÏÖõÏÖù",6,"ÏÖ¶ÏÖ™",5,"ÏÖ±ÏÖ≤ÏÖ≥ÏÖµÏÖ∂ÏÖ∑ÏÖπÏÖ∫ÏÖª"],["9981","ÏÖº",8,"ÏÜÜ",5,"ÏÜèÏÜëÏÜíÏÜìÏÜïÏÜó",4,"ÏÜûÏÜ†ÏÜ¢ÏÜ£ÏÜ§ÏÜ¶ÏÜßÏÜ™ÏÜ´ÏÜ≠ÏÜÆÏÜØÏÜ±",11,"ÏÜæ",5,"ÏáÖÏáÜÏááÏáâÏáäÏáãÏáç",6,"ÏáïÏáñÏáô",6,"Ïá°Ïá¢Ïá£Ïá•Ïá¶ÏáßÏá©",6,"Ïá≤Ïá¥",7,"ÏáæÏáøÏàÅÏàÇÏàÉÏàÖ",6,"ÏàéÏàêÏàí",5,"ÏàöÏàõÏàùÏàûÏà°Ïà¢Ïà£"],["9a41","Ïà§Ïà•Ïà¶ÏàßÏà™Ïà¨ÏàÆÏà∞Ïà≥Ïàµ",16],["9a61","ÏâÜÏâáÏââ",6,"ÏâíÏâìÏâïÏâñÏâóÏâô",6,"Ïâ°Ïâ¢Ïâ£Ïâ§Ïâ¶"],["9a81","Ïâß",4,"ÏâÆÏâØÏâ±Ïâ≤Ïâ≥Ïâµ",6,"ÏâæÏäÄÏäÇ",5,"Ïää",5,"Ïäë",6,"ÏäôÏäöÏäúÏäû",5,"Ïä¶ÏäßÏä©Ïä™Ïä´ÏäÆ",5,"Ïä∂Ïä∏Ïä∫",33,"ÏãûÏãüÏã°Ïã¢Ïã•",5,"ÏãÆÏã∞Ïã≤Ïã≥Ïã¥ÏãµÏã∑Ïã∫ÏãΩÏãæÏãøÏåÅ",6,"ÏåäÏåãÏåéÏåè"],["9b41","ÏåêÏåëÏåíÏåñÏåóÏåôÏåöÏåõÏåù",6,"Ïå¶ÏåßÏå™",8],["9b61","Ïå≥",17,"ÏçÜ",7],["9b81","Ïçé",25,"Ïç™Ïç´Ïç≠ÏçÆÏçØÏç±Ïç≥",4,"Ïç∫ÏçªÏçæ",5,"ÏéÖÏéÜÏéáÏéâÏéäÏéãÏéç",50,"ÏèÅ",22,"Ïèö"],["9c41","ÏèõÏèùÏèûÏè°Ïè£",4,"Ïè™Ïè´Ïè¨ÏèÆ",5,"Ïè∂Ïè∑Ïèπ",5],["9c61","Ïèø",8,"Ïêâ",6,"Ïêë",9],["9c81","Ïêõ",8,"Ïê•",6,"Ïê≠ÏêÆÏêØÏê±Ïê≤Ïê≥Ïêµ",6,"Ïêæ",9,"Ïëâ",26,"Ïë¶ÏëßÏë©Ïë™Ïë´Ïë≠",6,"Ïë∂Ïë∑Ïë∏Ïë∫",5,"ÏíÅ",18,"Ïíï",6,"Ïíù",12],["9d41","Ïí™",13,"ÏíπÏí∫ÏíªÏíΩ",8],["9d61","ÏìÜ",25],["9d81","Ïì†",8,"Ïì™",5,"Ïì≤Ïì≥ÏìµÏì∂Ïì∑ÏìπÏìªÏìºÏìΩÏìæÏîÇ",9,"ÏîçÏîéÏîèÏîëÏîíÏîìÏîï",6,"Ïîù",10,"Ïî™Ïî´Ïî≠ÏîÆÏîØÏî±",6,"Ïî∫ÏîºÏîæ",5,"ÏïÜÏïáÏïãÏïèÏïêÏïëÏïíÏïñÏïöÏïõÏïúÏïüÏï¢Ïï£Ïï•Ïï¶ÏïßÏï©",6,"Ïï≤Ïï∂",5,"ÏïæÏïøÏñÅÏñÇÏñÉÏñÖÏñÜÏñàÏñâÏñäÏñãÏñéÏñêÏñíÏñìÏñî"],["9e41","ÏññÏñôÏñöÏñõÏñùÏñûÏñüÏñ°",7,"Ïñ™",9,"Ïñ∂"],["9e61","Ïñ∑Ïñ∫Ïñø",4,"ÏóãÏóçÏóèÏóíÏóìÏóïÏóñÏóóÏóô",6,"Ïó¢Ïó§Ïó¶Ïóß"],["9e81","Ïó®Ïó©Ïó™Ïó´ÏóØÏó±Ïó≤Ïó≥ÏóµÏó∏ÏóπÏó∫ÏóªÏòÇÏòÉÏòÑÏòâÏòäÏòãÏòçÏòéÏòèÏòë",6,"ÏòöÏòù",6,"Ïò¶ÏòßÏò©Ïò™Ïò´ÏòØÏò±Ïò≤Ïò∂Ïò∏Ïò∫ÏòºÏòΩÏòæÏòøÏôÇÏôÉÏôÖÏôÜÏôáÏôâ",6,"ÏôíÏôñ",5,"ÏôûÏôüÏô°",10,"Ïô≠ÏôÆÏô∞Ïô≤",5,"Ïô∫ÏôªÏôΩÏôæÏôøÏöÅ",6,"ÏöäÏöåÏöé",5,"ÏöñÏöóÏöôÏööÏöõÏöù",6,"Ïö¶"],["9f41","Ïö®Ïö™",5,"Ïö≤Ïö≥ÏöµÏö∂Ïö∑Ïöª",4,"ÏõÇÏõÑÏõÜ",5,"Ïõé"],["9f61","ÏõèÏõëÏõíÏõìÏõï",6,"ÏõûÏõüÏõ¢",5,"Ïõ™Ïõ´Ïõ≠ÏõÆÏõØÏõ±Ïõ≤"],["9f81","Ïõ≥",4,"Ïõ∫ÏõªÏõºÏõæ",5,"ÏúÜÏúáÏúâÏúäÏúãÏúç",6,"ÏúñÏúòÏúö",5,"Ïú¢Ïú£Ïú•Ïú¶ÏúßÏú©",6,"Ïú≤Ïú¥Ïú∂Ïú∏ÏúπÏú∫ÏúªÏúæÏúøÏùÅÏùÇÏùÉÏùÖ",4,"ÏùãÏùéÏùêÏùôÏùöÏùõÏùùÏùûÏùüÏù°",6,"Ïù©Ïù™Ïù¨",7,"Ïù∂Ïù∑ÏùπÏù∫ÏùªÏùøÏûÄÏûÅÏûÇÏûÜÏûãÏûåÏûçÏûèÏûíÏûìÏûïÏûôÏûõ",4,"Ïû¢Ïûß",4,"ÏûÆÏûØÏû±Ïû≤Ïû≥ÏûµÏû∂Ïû∑"],["a041","Ïû∏ÏûπÏû∫ÏûªÏûæÏüÇ",5,"ÏüäÏüãÏüçÏüèÏüë",6,"ÏüôÏüöÏüõÏüú"],["a061","Ïüû",5,"Ïü•Ïü¶ÏüßÏü©Ïü™Ïü´Ïü≠",13],["a081","Ïüª",4,"Ï†ÇÏ†ÉÏ†ÖÏ†ÜÏ†áÏ†âÏ†ã",4,"Ï†íÏ†îÏ†ó",4,"Ï†ûÏ†üÏ†°Ï†¢Ï†£Ï†•",6,"Ï†ÆÏ†∞Ï†≤",5,"Ï†πÏ†∫Ï†ªÏ†ΩÏ†æÏ†øÏ°Å",6,"Ï°äÏ°ãÏ°é",5,"Ï°ï",26,"Ï°≤Ï°≥Ï°µÏ°∂Ï°∑Ï°πÏ°ª",4,"Ï¢ÇÏ¢ÑÏ¢àÏ¢âÏ¢äÏ¢é",5,"Ï¢ï",7,"Ï¢ûÏ¢†Ï¢¢Ï¢£Ï¢§"],["a141","Ï¢•Ï¢¶Ï¢ßÏ¢©",18,"Ï¢æÏ¢øÏ£ÄÏ£Å"],["a161","Ï£ÇÏ£ÉÏ£ÖÏ£ÜÏ£áÏ£âÏ£äÏ£ãÏ£ç",6,"Ï£ñÏ£òÏ£ö",5,"Ï£¢Ï££Ï£•"],["a181","Ï£¶",14,"Ï£∂",5,"Ï£æÏ£øÏ§ÅÏ§ÇÏ§ÉÏ§á",4,"Ï§é„ÄÄ„ÄÅ„ÄÇ¬∑‚Ä•‚Ä¶¬®„ÄÉ¬≠‚Äï‚à•Ôºº‚àº‚Äò‚Äô‚Äú‚Äù„Äî„Äï„Äà",9,"¬±√ó√∑‚â†‚â§‚â•‚àû‚à¥¬∞‚Ä≤‚Ä≥‚ÑÉ‚Ñ´Ôø†Ôø°Ôø•‚ôÇ‚ôÄ‚à†‚ä•‚åí‚àÇ‚àá‚â°‚âí¬ß‚Äª‚òÜ‚òÖ‚óã‚óè‚óé‚óá‚óÜ‚ñ°‚ñ†‚ñ≥‚ñ≤‚ñΩ‚ñº‚Üí‚Üê‚Üë‚Üì‚Üî„Äì‚â™‚â´‚àö‚àΩ‚àù‚àµ‚à´‚à¨‚àà‚àã‚äÜ‚äá‚äÇ‚äÉ‚à™‚à©‚àß‚à®Ôø¢"],["a241","Ï§êÏ§í",5,"Ï§ô",18],["a261","Ï§≠",6,"Ï§µ",18],["a281","Ï•à",7,"Ï•íÏ•ìÏ•ïÏ•ñÏ•óÏ•ô",6,"Ï•¢Ï•§",7,"Ï•≠Ï•ÆÏ•Ø‚áí‚áî‚àÄ‚àÉ¬¥ÔΩûÀáÀòÀùÀöÀô¬∏Àõ¬°¬øÀê‚àÆ‚àë‚àè¬§‚Ñâ‚Ä∞‚óÅ‚óÄ‚ñ∑‚ñ∂‚ô§‚ô†‚ô°‚ô•‚ôß‚ô£‚äô‚óà‚ñ£‚óê‚óë‚ñí‚ñ§‚ñ•‚ñ®‚ñß‚ñ¶‚ñ©‚ô®‚òè‚òé‚òú‚òû¬∂‚Ä†‚Ä°‚Üï‚Üó‚Üô‚Üñ‚Üò‚ô≠‚ô©‚ô™‚ô¨„âø„àú‚Ññ„èá‚Ñ¢„èÇ„èò‚Ñ°‚Ç¨¬Æ"],["a341","Ï•±Ï•≤Ï•≥Ï•µ",6,"Ï•Ω",10,"Ï¶äÏ¶ãÏ¶çÏ¶éÏ¶è"],["a361","Ï¶ë",6,"Ï¶öÏ¶úÏ¶û",16],["a381","Ï¶Ø",16,"ÏßÇÏßÉÏßÖÏßÜÏßâÏßã",4,"ÏßíÏßîÏßóÏßòÏßõÔºÅ",58,"Ôø¶ÔºΩ",32,"Ôø£"],["a441","ÏßûÏßüÏß°Ïß£Ïß•Ïß¶Ïß®Ïß©Ïß™Ïß´ÏßÆÏß≤",5,"Ïß∫ÏßªÏßΩÏßæÏßøÏ®ÅÏ®ÇÏ®ÉÏ®Ñ"],["a461","Ï®ÖÏ®ÜÏ®áÏ®äÏ®é",5,"Ï®ïÏ®ñÏ®óÏ®ô",12],["a481","Ï®¶Ï®ßÏ®®Ï®™",28,"„Ñ±",93],["a541","Ï©á",4,"Ï©éÏ©èÏ©ëÏ©íÏ©ìÏ©ï",6,"Ï©ûÏ©¢",5,"Ï©©Ï©™"],["a561","Ï©´",17,"Ï©æ",5,"Ï™ÖÏ™Ü"],["a581","Ï™á",16,"Ï™ô",14,"‚Ö∞",9],["a5b0","‚Ö†",9],["a5c1","Œë",16,"Œ£",6],["a5e1","Œ±",16,"œÉ",6],["a641","Ï™®",19,"Ï™æÏ™øÏ´ÅÏ´ÇÏ´ÉÏ´Ö"],["a661","Ï´Ü",5,"Ï´éÏ´êÏ´íÏ´îÏ´ïÏ´ñÏ´óÏ´ö",5,"Ï´°",6],["a681","Ï´®Ï´©Ï´™Ï´´Ï´≠",6,"Ï´µ",18,"Ï¨âÏ¨ä‚îÄ‚îÇ‚îå‚îê‚îò‚îî‚îú‚î¨‚î§‚î¥‚îº‚îÅ‚îÉ‚îè‚îì‚îõ‚îó‚î£‚î≥‚î´‚îª‚ïã‚î†‚îØ‚î®‚î∑‚îø‚îù‚î∞‚î•‚î∏‚ïÇ‚îí‚îë‚îö‚îô‚îñ‚îï‚îé‚îç‚îû‚îü‚î°‚î¢‚î¶‚îß‚î©‚î™‚î≠‚îÆ‚î±‚î≤‚îµ‚î∂‚îπ‚î∫‚îΩ‚îæ‚ïÄ‚ïÅ‚ïÉ",7],["a741","Ï¨ã",4,"Ï¨ëÏ¨íÏ¨ìÏ¨ïÏ¨ñÏ¨óÏ¨ô",6,"Ï¨¢",7],["a761","Ï¨™",22,"Ï≠ÇÏ≠ÉÏ≠Ñ"],["a781","Ï≠ÖÏ≠ÜÏ≠áÏ≠äÏ≠ãÏ≠çÏ≠éÏ≠èÏ≠ë",6,"Ï≠öÏ≠õÏ≠úÏ≠û",5,"Ï≠•",7,"„éï„éñ„éó‚Ñì„éò„èÑ„é£„é§„é•„é¶„éô",9,"„èä„éç„éé„éè„èè„éà„éâ„èà„éß„é®„é∞",9,"„éÄ",4,"„é∫",5,"„éê",4,"‚Ñ¶„èÄ„èÅ„éä„éã„éå„èñ„èÖ„é≠„éÆ„éØ„èõ„é©„é™„é´„é¨„èù„èê„èì„èÉ„èâ„èú„èÜ"],["a841","Ï≠≠",10,"Ï≠∫",14],["a861","ÏÆâ",18,"ÏÆù",6],["a881","ÏÆ§",19,"ÏÆπ",11,"√Ü√ê¬™ƒ¶"],["a8a6","ƒ≤"],["a8a8","ƒø≈Å√ò≈í¬∫√û≈¶≈ä"],["a8b1","„â†",27,"‚ìê",25,"‚ë†",14,"¬Ω‚Öì‚Öî¬º¬æ‚Öõ‚Öú‚Öù‚Öû"],["a941","ÏØÖ",14,"ÏØï",10],["a961","ÏØ†ÏØ°ÏØ¢ÏØ£ÏØ•ÏØ¶ÏØ®ÏØ™",18],["a981","ÏØΩ",14,"Ï∞éÏ∞èÏ∞ëÏ∞íÏ∞ìÏ∞ï",6,"Ï∞ûÏ∞üÏ∞†Ï∞£Ï∞§√¶ƒë√∞ƒßƒ±ƒ≥ƒ∏≈Ä≈Ç√∏≈ì√ü√æ≈ß≈ã≈â„àÄ",27,"‚íú",25,"‚ë¥",14,"¬π¬≤¬≥‚Å¥‚Åø‚ÇÅ‚ÇÇ‚ÇÉ‚ÇÑ"],["aa41","Ï∞•Ï∞¶Ï∞™Ï∞´Ï∞≠Ï∞ØÏ∞±",6,"Ï∞∫Ï∞ø",4,"Ï±ÜÏ±áÏ±âÏ±äÏ±ãÏ±çÏ±é"],["aa61","Ï±è",4,"Ï±ñÏ±ö",5,"Ï±°Ï±¢Ï±£Ï±•Ï±ßÏ±©",6,"Ï±±Ï±≤"],["aa81","Ï±≥Ï±¥Ï±∂",29,"„ÅÅ",82],["ab41","Ï≤îÏ≤ïÏ≤ñÏ≤óÏ≤öÏ≤õÏ≤ùÏ≤ûÏ≤üÏ≤°",6,"Ï≤™Ï≤Æ",5,"Ï≤∂Ï≤∑Ï≤π"],["ab61","Ï≤∫Ï≤ªÏ≤Ω",6,"Ï≥ÜÏ≥àÏ≥ä",5,"Ï≥ëÏ≥íÏ≥ìÏ≥ï",5],["ab81","Ï≥õ",8,"Ï≥•",6,"Ï≥≠Ï≥ÆÏ≥ØÏ≥±",12,"„Ç°",85],["ac41","Ï≥æÏ≥øÏ¥ÄÏ¥Ç",5,"Ï¥äÏ¥ãÏ¥çÏ¥éÏ¥èÏ¥ë",6,"Ï¥öÏ¥úÏ¥ûÏ¥üÏ¥†"],["ac61","Ï¥°Ï¥¢Ï¥£Ï¥•Ï¥¶Ï¥ßÏ¥©Ï¥™Ï¥´Ï¥≠",11,"Ï¥∫",4],["ac81","Ï¥ø",28,"ÏµùÏµûÏµü–ê",5,"–Å–ñ",25],["acd1","–∞",5,"—ë–∂",25],["ad41","Ïµ°Ïµ¢Ïµ£Ïµ•",6,"ÏµÆÏµ∞Ïµ≤",5,"Ïµπ",7],["ad61","Ï∂Å",6,"Ï∂â",10,"Ï∂ñÏ∂óÏ∂ôÏ∂öÏ∂õÏ∂ùÏ∂ûÏ∂ü"],["ad81","Ï∂†Ï∂°Ï∂¢Ï∂£Ï∂¶Ï∂®Ï∂™",5,"Ï∂±",18,"Ï∑Ö"],["ae41","Ï∑Ü",5,"Ï∑çÏ∑éÏ∑èÏ∑ë",16],["ae61","Ï∑¢",5,"Ï∑©Ï∑™Ï∑´Ï∑≠Ï∑ÆÏ∑ØÏ∑±",6,"Ï∑∫Ï∑ºÏ∑æ",4],["ae81","Ï∏ÉÏ∏ÖÏ∏ÜÏ∏áÏ∏âÏ∏äÏ∏ãÏ∏ç",6,"Ï∏ïÏ∏ñÏ∏óÏ∏òÏ∏ö",5,"Ï∏¢Ï∏£Ï∏•Ï∏¶Ï∏ßÏ∏©Ï∏™Ï∏´"],["af41","Ï∏¨Ï∏≠Ï∏ÆÏ∏ØÏ∏≤Ï∏¥Ï∏∂",19],["af61","Ïπä",13,"ÏπöÏπõÏπùÏπûÏπ¢",5,"Ïπ™Ïπ¨"],["af81","ÏπÆ",5,"Ïπ∂Ïπ∑ÏππÏπ∫ÏπªÏπΩ",6,"Ï∫ÜÏ∫àÏ∫ä",5,"Ï∫íÏ∫ìÏ∫ïÏ∫ñÏ∫óÏ∫ô"],["b041","Ï∫ö",5,"Ï∫¢Ï∫¶",5,"Ï∫Æ",12],["b061","Ï∫ª",5,"ÏªÇ",19],["b081","Ïªñ",13,"Ïª¶ÏªßÏª©Ïª™Ïª≠",6,"Ïª∂Ïª∫",5,"Í∞ÄÍ∞ÅÍ∞ÑÍ∞áÍ∞àÍ∞âÍ∞äÍ∞ê",7,"Í∞ô",4,"Í∞†Í∞§Í∞¨Í∞≠Í∞ØÍ∞∞Í∞±Í∞∏Í∞πÍ∞ºÍ±ÄÍ±ãÍ±çÍ±îÍ±òÍ±úÍ±∞Í±±Í±¥Í±∑Í±∏Í±∫Í≤ÄÍ≤ÅÍ≤ÉÍ≤ÑÍ≤ÖÍ≤ÜÍ≤âÍ≤äÍ≤ãÍ≤åÍ≤êÍ≤îÍ≤úÍ≤ùÍ≤üÍ≤†Í≤°Í≤®Í≤©Í≤™Í≤¨Í≤ØÍ≤∞Í≤∏Í≤πÍ≤ªÍ≤ºÍ≤ΩÍ≥ÅÍ≥ÑÍ≥àÍ≥åÍ≥ïÍ≥óÍ≥†Í≥°Í≥§Í≥ßÍ≥®Í≥™Í≥¨Í≥ØÍ≥∞Í≥±Í≥≥Í≥µÍ≥∂Í≥ºÍ≥ΩÍ¥ÄÍ¥ÑÍ¥Ü"],["b141","ÏºÇÏºÉÏºÖÏºÜÏºáÏºâ",6,"ÏºíÏºîÏºñ",5,"ÏºùÏºûÏºüÏº°Ïº¢Ïº£"],["b161","Ïº•",6,"ÏºÆÏº≤",5,"Ïºπ",11],["b181","ÏΩÖ",14,"ÏΩñÏΩóÏΩôÏΩöÏΩõÏΩù",6,"ÏΩ¶ÏΩ®ÏΩ™ÏΩ´ÏΩ¨Í¥åÍ¥çÍ¥èÍ¥ëÍ¥òÍ¥úÍ¥†Í¥©Í¥¨Í¥≠Í¥¥Í¥µÍ¥∏Í¥ºÍµÑÍµÖÍµáÍµâÍµêÍµîÍµòÍµ°Íµ£Íµ¨Íµ≠Íµ∞Íµ≥Íµ¥ÍµµÍµ∂ÍµªÍµºÍµΩÍµøÍ∂ÅÍ∂ÇÍ∂àÍ∂âÍ∂åÍ∂êÍ∂úÍ∂ùÍ∂§Í∂∑Í∑ÄÍ∑ÅÍ∑ÑÍ∑àÍ∑êÍ∑ëÍ∑ìÍ∑úÍ∑†Í∑§Í∑∏Í∑πÍ∑ºÍ∑øÍ∏ÄÍ∏ÅÍ∏àÍ∏âÍ∏ãÍ∏çÍ∏îÍ∏∞Í∏±Í∏¥Í∏∑Í∏∏Í∏∫ÍπÄÍπÅÍπÉÍπÖÍπÜÍπäÍπåÍπçÍπéÍπêÍπîÍπñÍπúÍπùÍπüÍπ†Íπ°Íπ•Íπ®Íπ©Íπ¨Íπ∞Íπ∏"],["b241","ÏΩ≠ÏΩÆÏΩØÏΩ≤ÏΩ≥ÏΩµÏΩ∂ÏΩ∑ÏΩπ",6,"ÏæÅÏæÇÏæÉÏæÑÏæÜ",5,"Ïæç"],["b261","Ïæé",18,"Ïæ¢",5,"Ïæ©"],["b281","Ïæ™",5,"Ïæ±",18,"ÏøÖ",6,"ÍππÍπªÍπºÍπΩÍ∫ÑÍ∫ÖÍ∫åÍ∫ºÍ∫ΩÍ∫æÍªÄÍªÑÍªåÍªçÍªèÍªêÍªëÍªòÍªôÍªúÍª®Íª´Íª≠Íª¥Íª∏ÍªºÍºáÍºàÍºçÍºêÍº¨Íº≠Íº∞Íº≤Íº¥ÍººÍºΩÍºøÍΩÅÍΩÇÍΩÉÍΩàÍΩâÍΩêÍΩúÍΩùÍΩ§ÍΩ•ÍΩπÍæÄÍæÑÍæàÍæêÍæëÍæïÍæúÍæ∏ÍæπÍæºÍøÄÍøáÍøàÍøâÍøãÍøçÍøéÍøîÍøúÍø®Íø©Íø∞Íø±Íø¥Íø∏ÎÄÄÎÄÅÎÄÑÎÄåÎÄêÎÄîÎÄúÎÄùÎÄ®ÎÅÑÎÅÖÎÅàÎÅäÎÅåÎÅéÎÅìÎÅîÎÅïÎÅóÎÅô"],["b341","Ïøå",19,"Ïø¢Ïø£Ïø•Ïø¶ÏøßÏø©"],["b361","Ïø™",5,"Ïø≤Ïø¥Ïø∂",5,"ÏøΩÏøæÏøøÌÄÅÌÄÇÌÄÉÌÄÖ",5],["b381","ÌÄã",5,"ÌÄí",5,"ÌÄô",19,"ÎÅùÎÅºÎÅΩÎÇÄÎÇÑÎÇåÎÇçÎÇèÎÇëÎÇòÎÇôÎÇöÎÇúÎÇüÎÇ†ÎÇ°ÎÇ¢ÎÇ®ÎÇ©ÎÇ´",4,"ÎÇ±ÎÇ≥ÎÇ¥ÎÇµÎÇ∏ÎÇºÎÉÑÎÉÖÎÉáÎÉàÎÉâÎÉêÎÉëÎÉîÎÉòÎÉ†ÎÉ•ÎÑàÎÑâÎÑãÎÑåÎÑêÎÑíÎÑìÎÑòÎÑôÎÑõÎÑúÎÑùÎÑ£ÎÑ§ÎÑ•ÎÑ®ÎÑ¨ÎÑ¥ÎÑµÎÑ∑ÎÑ∏ÎÑπÎÖÄÎÖÅÎÖÑÎÖàÎÖêÎÖëÎÖîÎÖïÎÖòÎÖúÎÖ†ÎÖ∏ÎÖπÎÖºÎÜÄÎÜÇÎÜàÎÜâÎÜãÎÜçÎÜíÎÜìÎÜîÎÜòÎÜúÎÜ®ÎáåÎáêÎáîÎáúÎáù"],["b441","ÌÄÆ",5,"ÌÄ∂ÌÄ∑ÌÄπÌÄ∫ÌÄªÌÄΩ",6,"ÌÅÜÌÅàÌÅä",5],["b461","ÌÅëÌÅíÌÅìÌÅïÌÅñÌÅóÌÅô",6,"ÌÅ°",10,"ÌÅÆÌÅØ"],["b481","ÌÅ±ÌÅ≤ÌÅ≥ÌÅµ",6,"ÌÅæÌÅøÌÇÄÌÇÇ",18,"ÎáüÎá®Îá©Îá¨Îá∞ÎáπÎáªÎáΩÎàÑÎàÖÎààÎàãÎàåÎàîÎàïÎàóÎàôÎà†Îà¥ÎàºÎâòÎâúÎâ†Îâ®Îâ©Îâ¥ÎâµÎâºÎäÑÎäÖÎäâÎäêÎäëÎäîÎäòÎäôÎäöÎä†Îä°Îä£Îä•Îä¶Îä™Îä¨Îä∞Îä¥ÎãàÎãâÎãåÎãêÎãíÎãòÎãôÎãõÎãùÎã¢Îã§Îã•Îã¶Îã®Îã´",4,"Îã≥Îã¥ÎãµÎã∑",4,"ÎãøÎåÄÎåÅÎåÑÎåàÎåêÎåëÎåìÎåîÎåïÎåúÎçîÎçïÎçñÎçòÎçõÎçúÎçûÎçüÎç§Îç•"],["b541","ÌÇï",14,"ÌÇ¶ÌÇßÌÇ©ÌÇ™ÌÇ´ÌÇ≠",5],["b561","ÌÇ≥ÌÇ∂ÌÇ∏ÌÇ∫",5,"ÌÉÇÌÉÉÌÉÖÌÉÜÌÉáÌÉä",5,"ÌÉíÌÉñ",4],["b581","ÌÉõÌÉûÌÉüÌÉ°ÌÉ¢ÌÉ£ÌÉ•",6,"ÌÉÆÌÉ≤",5,"ÌÉπ",11,"ÎçßÎç©Îç´ÎçÆÎç∞Îç±Îç¥Îç∏ÎéÄÎéÅÎéÉÎéÑÎéÖÎéåÎéêÎéîÎé†Îé°Îé®Îé¨ÎèÑÎèÖÎèàÎèãÎèåÎèéÎèêÎèîÎèïÎèóÎèôÎèõÎèùÎè†Îè§Îè®ÎèºÎêêÎêòÎêúÎê†Îê®Îê©Îê´Îê¥ÎëêÎëëÎëîÎëòÎë†Îë°Îë£Îë•Îë¨ÎíÄÎíàÎíùÎí§Îí®Îí¨ÎíµÎí∑ÎíπÎìÄÎìÑÎìàÎìêÎìïÎìúÎìùÎì†Îì£Îì§Îì¶Îì¨Îì≠ÎìØÎì±Îì∏ÎîîÎîïÎîòÎîõÎîúÎî§Îî•ÎîßÎî®Îî©Îî™Îî∞Îî±Îî¥Îî∏"],["b641","ÌÑÖ",7,"ÌÑé",17],["b661","ÌÑ†",15,"ÌÑ≤ÌÑ≥ÌÑµÌÑ∂ÌÑ∑ÌÑπÌÑªÌÑºÌÑΩÌÑæ"],["b681","ÌÑøÌÖÇÌÖÜ",5,"ÌÖéÌÖèÌÖëÌÖíÌÖìÌÖï",6,"ÌÖûÌÖ†ÌÖ¢",5,"ÌÖ©ÌÖ™ÌÖ´ÌÖ≠ÎïÄÎïÅÎïÉÎïÑÎïÖÎïãÎïåÎïçÎïêÎïîÎïúÎïùÎïüÎï†Îï°Îñ†Îñ°Îñ§Îñ®Îñ™Îñ´Îñ∞Îñ±Îñ≥Îñ¥ÎñµÎñªÎñºÎñΩÎóÄÎóÑÎóåÎóçÎóèÎóêÎóëÎóòÎó¨ÎòêÎòëÎòîÎòòÎò•Îò¨Îò¥ÎôàÎô§Îô®ÎöúÎöùÎö†Îö§Îö´Îö¨Îö±ÎõîÎõ∞Îõ¥Îõ∏ÎúÄÎúÅÎúÖÎú®Îú©Îú¨ÎúØÎú∞Îú∏ÎúπÎúªÎùÑÎùàÎùåÎùîÎùïÎù†Îù§Îù®Îù∞Îù±Îù≥ÎùµÎùºÎùΩÎûÄÎûÑÎûåÎûçÎûèÎûêÎûëÎûíÎûñÎûó"],["b741","ÌÖÆ",13,"ÌÖΩ",6,"ÌÜÖÌÜÜÌÜáÌÜâÌÜä"],["b761","ÌÜã",20,"ÌÜ¢ÌÜ£ÌÜ•ÌÜ¶ÌÜß"],["b781","ÌÜ©",6,"ÌÜ≤ÌÜ¥ÌÜ∂ÌÜ∑ÌÜ∏ÌÜπÌÜªÌÜΩÌÜæÌÜøÌáÅ",14,"ÎûòÎûôÎûúÎû†Îû®Îû©Îû´Îû¨Îû≠Îû¥ÎûµÎû∏ÎüáÎüâÎü¨Îü≠Îü∞Îü¥ÎüºÎüΩÎüøÎ†ÄÎ†ÅÎ†áÎ†àÎ†âÎ†åÎ†êÎ†òÎ†ôÎ†õÎ†ùÎ†§Î†•Î†®Î†¨Î†¥Î†µÎ†∑Î†∏Î†πÎ°ÄÎ°ÑÎ°ëÎ°ìÎ°úÎ°ùÎ°†Î°§Î°¨Î°≠Î°ØÎ°±Î°∏Î°ºÎ¢çÎ¢®Î¢∞Î¢¥Î¢∏Î£ÄÎ£ÅÎ£ÉÎ£ÖÎ£åÎ£êÎ£îÎ£ùÎ£üÎ£°Î£®Î£©Î£¨Î£∞Î£∏Î£πÎ£ªÎ£ΩÎ§ÑÎ§òÎ§†Î§ºÎ§ΩÎ•ÄÎ•ÑÎ•åÎ•èÎ•ëÎ•òÎ•ôÎ•úÎ•†Î•®Î•©"],["b841","Ìáê",7,"Ìáô",17],["b861","Ìá´",8,"ÌáµÌá∂Ìá∑Ìáπ",13],["b881","ÌààÌàä",5,"Ìàë",24,"Î•´Î•≠Î•¥Î•µÎ•∏Î•ºÎ¶ÑÎ¶ÖÎ¶áÎ¶âÎ¶äÎ¶çÎ¶éÎ¶¨Î¶≠Î¶∞Î¶¥Î¶ºÎ¶ΩÎ¶øÎßÅÎßàÎßâÎßåÎßé",4,"ÎßòÎßôÎßõÎßùÎßûÎß°Îß£Îß§Îß•Îß®Îß¨Îß¥ÎßµÎß∑Îß∏ÎßπÎß∫Î®ÄÎ®ÅÎ®àÎ®ïÎ®∏Î®πÎ®ºÎ©ÄÎ©ÇÎ©àÎ©âÎ©ãÎ©çÎ©éÎ©ìÎ©îÎ©ïÎ©òÎ©úÎ©§Î©•Î©ßÎ©®Î©©Î©∞Î©±Î©¥Î©∏Î™ÉÎ™ÑÎ™ÖÎ™áÎ™åÎ™®Î™©Î™´Î™¨Î™∞Î™≤Î™∏Î™πÎ™ªÎ™ΩÎ´ÑÎ´àÎ´òÎ´ôÎ´º"],["b941","Ìà™Ìà´ÌàÆÌàØÌà±Ìà≤Ìà≥Ìàµ",6,"ÌàæÌâÄÌâÇ",5,"ÌââÌâäÌâãÌâå"],["b961","Ìâç",14,"Ìâù",6,"Ìâ•Ìâ¶ÌâßÌâ®"],["b981","Ìâ©",22,"ÌäÇÌäÉÌäÖÌäÜÌäáÌäâÌääÌäãÌäåÎ¨ÄÎ¨ÑÎ¨çÎ¨èÎ¨ëÎ¨òÎ¨úÎ¨†Î¨©Î¨´Î¨¥Î¨µÎ¨∂Î¨∏Î¨ªÎ¨ºÎ¨ΩÎ¨æÎ≠ÑÎ≠ÖÎ≠áÎ≠âÎ≠çÎ≠èÎ≠êÎ≠îÎ≠òÎ≠°Î≠£Î≠¨ÎÆàÎÆåÎÆêÎÆ§ÎÆ®ÎÆ¨ÎÆ¥ÎÆ∑ÎØÄÎØÑÎØàÎØêÎØìÎØ∏ÎØπÎØºÎØøÎ∞ÄÎ∞ÇÎ∞àÎ∞âÎ∞ãÎ∞åÎ∞çÎ∞èÎ∞ëÎ∞î",4,"Î∞õ",4,"Î∞§Î∞•Î∞ßÎ∞©Î∞≠Î∞∞Î∞±Î∞¥Î∞∏Î±ÄÎ±ÅÎ±ÉÎ±ÑÎ±ÖÎ±âÎ±åÎ±çÎ±êÎ±ùÎ≤ÑÎ≤ÖÎ≤àÎ≤ãÎ≤åÎ≤éÎ≤îÎ≤ïÎ≤ó"],["ba41","ÌäçÌäéÌäèÌäíÌäìÌäîÌäñ",5,"ÌäùÌäûÌäüÌä°Ìä¢Ìä£Ìä•",6,"Ìä≠"],["ba61","ÌäÆÌäØÌä∞Ìä≤",5,"Ìä∫ÌäªÌäΩÌäæÌãÅÌãÉ",4,"ÌãäÌãå",5],["ba81","ÌãíÌãìÌãïÌãñÌãóÌãôÌãöÌãõÌãù",6,"Ìã¶",9,"Ìã≤Ìã≥ÌãµÌã∂Ìã∑ÌãπÌã∫Î≤ôÎ≤öÎ≤†Î≤°Î≤§Î≤ßÎ≤®Î≤∞Î≤±Î≤≥Î≤¥Î≤µÎ≤ºÎ≤ΩÎ≥ÄÎ≥ÑÎ≥çÎ≥èÎ≥êÎ≥ëÎ≥ïÎ≥òÎ≥úÎ≥¥Î≥µÎ≥∂Î≥∏Î≥ºÎ¥ÑÎ¥ÖÎ¥áÎ¥âÎ¥êÎ¥îÎ¥§Î¥¨ÎµÄÎµàÎµâÎµåÎµêÎµòÎµôÎµ§Îµ®Î∂ÄÎ∂ÅÎ∂ÑÎ∂áÎ∂àÎ∂âÎ∂äÎ∂êÎ∂ëÎ∂ìÎ∂ïÎ∂ôÎ∂öÎ∂úÎ∂§Î∂∞Î∂∏Î∑îÎ∑ïÎ∑òÎ∑úÎ∑©Î∑∞Î∑¥Î∑∏Î∏ÄÎ∏ÉÎ∏ÖÎ∏åÎ∏çÎ∏êÎ∏îÎ∏úÎ∏ùÎ∏üÎπÑÎπÖÎπàÎπåÎπéÎπîÎπïÎπóÎπôÎπöÎπõÎπ†Îπ°Îπ§"],["bb41","Ìãª",4,"ÌåÇÌåÑÌåÜ",5,"ÌåèÌåëÌåíÌåìÌåïÌåó",4,"ÌåûÌå¢Ìå£"],["bb61","Ìå§Ìå¶ÌåßÌå™Ìå´Ìå≠ÌåÆÌåØÌå±",6,"Ìå∫Ìåæ",5,"ÌçÜÌçáÌçàÌçâ"],["bb81","Ìçä",31,"Îπ®Îπ™Îπ∞Îπ±Îπ≥Îπ¥ÎπµÎπªÎπºÎπΩÎ∫ÄÎ∫ÑÎ∫åÎ∫çÎ∫èÎ∫êÎ∫ëÎ∫òÎ∫ôÎ∫®ÎªêÎªëÎªîÎªóÎªòÎª†Îª£Îª§Îª•Îª¨ÎºÅÎºàÎºâÎºòÎºôÎºõÎºúÎºùÎΩÄÎΩÅÎΩÑÎΩàÎΩêÎΩëÎΩïÎæîÎæ∞ÎøÖÎøåÎøçÎøêÎøîÎøúÎøüÎø°ÏÄºÏÅëÏÅòÏÅúÏÅ†ÏÅ®ÏÅ©ÏÇêÏÇëÏÇîÏÇòÏÇ†ÏÇ°ÏÇ£ÏÇ•ÏÇ¨ÏÇ≠ÏÇØÏÇ∞ÏÇ≥ÏÇ¥ÏÇµÏÇ∂ÏÇºÏÇΩÏÇøÏÉÄÏÉÅÏÉÖÏÉàÏÉâÏÉåÏÉêÏÉòÏÉôÏÉõÏÉúÏÉùÏÉ§"],["bc41","Ìç™",17,"ÌçæÌçøÌéÅÌéÇÌéÉÌéÖÌéÜÌéá"],["bc61","ÌéàÌéâÌéäÌéãÌééÌéí",5,"ÌéöÌéõÌéùÌéûÌéüÌé°",6,"Ìé™Ìé¨ÌéÆ"],["bc81","ÌéØ",4,"ÌéµÌé∂Ìé∑ÌéπÌé∫ÌéªÌéΩ",6,"ÌèÜÌèáÌèä",5,"Ìèë",5,"ÏÉ•ÏÉ®ÏÉ¨ÏÉ¥ÏÉµÏÉ∑ÏÉπÏÑÄÏÑÑÏÑàÏÑêÏÑïÏÑú",4,"ÏÑ£ÏÑ§ÏÑ¶ÏÑßÏÑ¨ÏÑ≠ÏÑØÏÑ∞ÏÑ±ÏÑ∂ÏÑ∏ÏÑπÏÑºÏÖÄÏÖàÏÖâÏÖãÏÖåÏÖçÏÖîÏÖïÏÖòÏÖúÏÖ§ÏÖ•ÏÖßÏÖ®ÏÖ©ÏÖ∞ÏÖ¥ÏÖ∏ÏÜÖÏÜåÏÜçÏÜéÏÜêÏÜîÏÜñÏÜúÏÜùÏÜüÏÜ°ÏÜ•ÏÜ®ÏÜ©ÏÜ¨ÏÜ∞ÏÜΩÏáÑÏáàÏáåÏáîÏáóÏáòÏá†Ïá§Ïá®Ïá∞Ïá±Ïá≥ÏáºÏáΩÏàÄÏàÑÏàåÏàçÏàèÏàëÏàòÏàôÏàúÏàüÏà†Ïà®Ïà©Ïà´Ïà≠"],["bd41","ÌèóÌèô",7,"Ìè¢Ìè§",7,"ÌèÆÌèØÌè±Ìè≤Ìè≥ÌèµÌè∂Ìè∑"],["bd61","Ìè∏ÌèπÌè∫ÌèªÌèæÌêÄÌêÇ",5,"Ìêâ",13],["bd81","Ìêó",5,"Ìêû",25,"ÏàØÏà±Ïà≤Ïà¥ÏâàÏâêÏâëÏâîÏâòÏâ†Ïâ•Ïâ¨Ïâ≠Ïâ∞Ïâ¥ÏâºÏâΩÏâøÏäÅÏäàÏäâÏäêÏäòÏäõÏäùÏä§Ïä•Ïä®Ïä¨Ïä≠Ïä¥ÏäµÏä∑ÏäπÏãúÏãùÏã†Ïã£Ïã§Ïã´Ïã¨Ïã≠ÏãØÏã±Ïã∂Ïã∏ÏãπÏãªÏãºÏåÄÏåàÏåâÏååÏåçÏåìÏåîÏåïÏåòÏåúÏå§Ïå•Ïå®Ïå©ÏçÖÏç®Ïç©Ïç¨Ïç∞Ïç≤Ïç∏ÏçπÏçºÏçΩÏéÑÏéàÏéåÏèÄÏèòÏèôÏèúÏèüÏè†Ïè¢Ïè®Ïè©Ïè≠Ïè¥ÏèµÏè∏ÏêàÏêêÏê§Ïê¨Ïê∞"],["be41","Ìê∏",7,"ÌëÅÌëÇÌëÉÌëÖ",14],["be61","Ìëî",7,"ÌëùÌëûÌëüÌë°Ìë¢Ìë£Ìë•",7,"ÌëÆÌë∞Ìë±Ìë≤"],["be81","Ìë≥",4,"Ìë∫ÌëªÌëΩÌëæÌíÅÌíÉ",4,"ÌíäÌíåÌíé",5,"Ìíï",8,"Ïê¥ÏêºÏêΩÏëàÏë§Ïë•Ïë®Ïë¨Ïë¥ÏëµÏëπÏíÄÏíîÏíúÏí∏ÏíºÏì©Ïì∞Ïì±Ïì¥Ïì∏Ïì∫ÏìøÏîÄÏîÅÏîåÏîêÏîîÏîúÏî®Ïî©Ïî¨Ïî∞Ïî∏ÏîπÏîªÏîΩÏïÑÏïÖÏïàÏïâÏïäÏïåÏïçÏïéÏïìÏïîÏïïÏïóÏïòÏïôÏïùÏïûÏï†Ïï°Ïï§Ïï®Ïï∞Ïï±Ïï≥Ïï¥ÏïµÏïºÏïΩÏñÄÏñÑÏñáÏñåÏñçÏñèÏñëÏñïÏñóÏñòÏñúÏñ†Ïñ©Ïñ¥ÏñµÏñ∏ÏñπÏñªÏñºÏñΩÏñæÏóÑ",6,"ÏóåÏóé"],["bf41","Ìíû",10,"Ìí™",14],["bf61","Ìíπ",18,"ÌìçÌìéÌìèÌìëÌìíÌììÌìï"],["bf81","Ììñ",5,"ÌìùÌìûÌì†",7,"Ìì©Ìì™Ìì´Ìì≠ÌìÆÌìØÌì±",6,"ÌìπÌì∫ÌìºÏóêÏóëÏóîÏóòÏó†Ïó°Ïó£Ïó•Ïó¨Ïó≠ÏóÆÏó∞Ïó¥Ïó∂Ïó∑Ïóº",5,"ÏòÖÏòÜÏòáÏòàÏòåÏòêÏòòÏòôÏòõÏòúÏò§Ïò•Ïò®Ïò¨Ïò≠ÏòÆÏò∞Ïò≥Ïò¥ÏòµÏò∑ÏòπÏòªÏôÄÏôÅÏôÑÏôàÏôêÏôëÏôìÏôîÏôïÏôúÏôùÏô†Ïô¨ÏôØÏô±Ïô∏ÏôπÏôºÏöÄÏöàÏöâÏöãÏöçÏöîÏöïÏöòÏöúÏö§Ïö•ÏößÏö©Ïö∞Ïö±Ïö¥Ïö∏ÏöπÏö∫ÏõÄÏõÅÏõÉÏõÖÏõåÏõçÏõêÏõîÏõúÏõùÏõ†Ïõ°Ïõ®"],["c041","Ììæ",5,"ÌîÖÌîÜÌîáÌîâÌîäÌîãÌîç",6,"ÌîñÌîò",5],["c061","Ìîû",25],["c081","Ìî∏ÌîπÌî∫ÌîªÌîæÌîøÌïÅÌïÇÌïÉÌïÖ",6,"ÌïéÌïêÌïí",5,"ÌïöÌïõÌïùÌïûÌïüÌï°Ìï¢Ìï£Ïõ©Ïõ¨Ïõ∞Ïõ∏ÏõπÏõΩÏúÑÏúÖÏúàÏúåÏúîÏúïÏúóÏúôÏú†Ïú°Ïú§Ïú®Ïú∞Ïú±Ïú≥ÏúµÏú∑ÏúºÏúΩÏùÄÏùÑÏùäÏùåÏùçÏùèÏùë",7,"ÏùúÏù†Ïù®Ïù´Ïù¥ÏùµÏù∏ÏùºÏùΩÏùæÏûÉÏûÑÏûÖÏûáÏûàÏûâÏûäÏûéÏûêÏûëÏûîÏûñÏûóÏûòÏûöÏû†Ïû°Ïû£Ïû§Ïû•Ïû¶Ïû¨Ïû≠Ïû∞Ïû¥ÏûºÏûΩÏûøÏüÄÏüÅÏüàÏüâÏüåÏüéÏüêÏüòÏüùÏü§Ïü®Ïü¨Ï†ÄÏ†ÅÏ†ÑÏ†àÏ†ä"],["c141","Ìï§Ìï¶ÌïßÌï™Ìï¨ÌïÆ",5,"Ìï∂Ìï∑ÌïπÌï∫ÌïªÌïΩ",6,"ÌñÜÌñäÌñã"],["c161","ÌñåÌñçÌñéÌñèÌñë",19,"Ìñ¶Ìñß"],["c181","Ìñ®",31,"Ï†êÏ†ëÏ†ìÏ†ïÏ†ñÏ†úÏ†ùÏ††Ï†§Ï†¨Ï†≠Ï†ØÏ†±Ï†∏Ï†ºÏ°ÄÏ°àÏ°âÏ°åÏ°çÏ°îÏ°∞Ï°±Ï°¥Ï°∏Ï°∫Ï¢ÄÏ¢ÅÏ¢ÉÏ¢ÖÏ¢ÜÏ¢áÏ¢ãÏ¢åÏ¢çÏ¢îÏ¢ùÏ¢üÏ¢°Ï¢®Ï¢ºÏ¢ΩÏ£ÑÏ£àÏ£åÏ£îÏ£ïÏ£óÏ£ôÏ£†Ï£°Ï£§Ï£µÏ£ºÏ£ΩÏ§ÄÏ§ÑÏ§ÖÏ§ÜÏ§åÏ§çÏ§èÏ§ëÏ§òÏ§¨Ï§¥Ï•êÏ•ëÏ•îÏ•òÏ•†Ï•°Ï•£Ï•¨Ï•∞Ï•¥Ï•ºÏ¶àÏ¶âÏ¶åÏ¶êÏ¶òÏ¶ôÏ¶õÏ¶ùÏßÄÏßÅÏßÑÏßáÏßàÏßäÏßêÏßëÏßì"],["c241","ÌóäÌóãÌóçÌóéÌóèÌóëÌóì",4,"ÌóöÌóúÌóû",5,"Ìó¶ÌóßÌó©Ìó™Ìó´Ìó≠ÌóÆ"],["c261","ÌóØ",4,"Ìó∂Ìó∏Ìó∫",5,"ÌòÇÌòÉÌòÖÌòÜÌòáÌòâ",6,"Ìòí"],["c281","Ìòñ",5,"ÌòùÌòûÌòüÌò°Ìò¢Ìò£Ìò•",7,"ÌòÆ",9,"Ìò∫ÌòªÏßïÏßñÏßôÏßöÏßúÏßùÏß†Ïß¢Ïß§ÏßßÏß¨Ïß≠ÏßØÏß∞Ïß±Ïß∏ÏßπÏßºÏ®ÄÏ®àÏ®âÏ®ãÏ®åÏ®çÏ®îÏ®òÏ®©Ï©åÏ©çÏ©êÏ©îÏ©úÏ©ùÏ©üÏ©†Ï©°Ï©®Ï©ΩÏ™ÑÏ™òÏ™ºÏ™ΩÏ´ÄÏ´ÑÏ´åÏ´çÏ´èÏ´ëÏ´ìÏ´òÏ´ôÏ´†Ï´¨Ï´¥Ï¨àÏ¨êÏ¨îÏ¨òÏ¨†Ï¨°Ï≠ÅÏ≠àÏ≠âÏ≠åÏ≠êÏ≠òÏ≠ôÏ≠ùÏ≠§Ï≠∏Ï≠πÏÆúÏÆ∏ÏØîÏØ§ÏØßÏØ©Ï∞åÏ∞çÏ∞êÏ∞îÏ∞úÏ∞ùÏ∞°Ï∞¢Ï∞ßÏ∞®Ï∞©Ï∞¨Ï∞ÆÏ∞∞Ï∞∏Ï∞πÏ∞ª"],["c341","ÌòΩÌòæÌòøÌôÅÌôÇÌôÉÌôÑÌôÜÌôáÌôäÌôåÌôéÌôèÌôêÌôíÌôìÌôñÌôóÌôôÌôöÌôõÌôù",4],["c361","Ìô¢",4,"Ìô®Ìô™",5,"Ìô≤Ìô≥Ìôµ",11],["c381","ÌöÅÌöÇÌöÑÌöÜ",5,"ÌöéÌöèÌöëÌöíÌöìÌöï",7,"ÌöûÌö†Ìö¢",5,"Ìö©Ìö™Ï∞ºÏ∞ΩÏ∞æÏ±ÑÏ±ÖÏ±àÏ±åÏ±îÏ±ïÏ±óÏ±òÏ±ôÏ±†Ï±§Ï±¶Ï±®Ï±∞Ï±µÏ≤òÏ≤ôÏ≤úÏ≤†Ï≤®Ï≤©Ï≤´Ï≤¨Ï≤≠Ï≤¥Ï≤µÏ≤∏Ï≤ºÏ≥ÑÏ≥ÖÏ≥áÏ≥âÏ≥êÏ≥îÏ≥§Ï≥¨Ï≥∞Ï¥ÅÏ¥àÏ¥âÏ¥åÏ¥êÏ¥òÏ¥ôÏ¥õÏ¥ùÏ¥§Ï¥®Ï¥¨Ï¥πÏµúÏµ†Ïµ§Ïµ¨Ïµ≠ÏµØÏµ±Ïµ∏Ï∂àÏ∂îÏ∂ïÏ∂òÏ∂úÏ∂§Ï∂•Ï∂ßÏ∂©Ï∂∞Ï∑ÑÏ∑åÏ∑êÏ∑®Ï∑¨Ï∑∞Ï∑∏Ï∑πÏ∑ªÏ∑ΩÏ∏ÑÏ∏àÏ∏åÏ∏îÏ∏ôÏ∏†Ï∏°Ï∏§Ï∏®Ï∏∞Ï∏±Ï∏≥Ï∏µ"],["c441","Ìö´Ìö≠ÌöÆÌöØÌö±",7,"Ìö∫Ìöº",7,"ÌõÜÌõáÌõâÌõäÌõã"],["c461","ÌõçÌõéÌõèÌõêÌõíÌõìÌõïÌõñÌõòÌõö",5,"Ìõ°Ìõ¢Ìõ£Ìõ•Ìõ¶ÌõßÌõ©",4],["c481","ÌõÆÌõØÌõ±Ìõ≤Ìõ≥Ìõ¥Ìõ∂",5,"ÌõæÌõøÌúÅÌúÇÌúÉÌúÖ",11,"ÌúíÌúìÌúîÏπòÏπôÏπúÏπüÏπ†Ïπ°Ïπ®Ïπ©Ïπ´Ïπ≠Ïπ¥ÏπµÏπ∏ÏπºÏ∫ÑÏ∫ÖÏ∫áÏ∫âÏ∫êÏ∫ëÏ∫îÏ∫òÏ∫†Ï∫°Ï∫£Ï∫§Ï∫•Ï∫¨Ï∫≠ÏªÅÏª§Ïª•Ïª®Ïª´Ïª¨Ïª¥ÏªµÏª∑Ïª∏ÏªπÏºÄÏºÅÏºÑÏºàÏºêÏºëÏºìÏºïÏºúÏº†Ïº§Ïº¨Ïº≠ÏºØÏº∞Ïº±Ïº∏ÏΩîÏΩïÏΩòÏΩúÏΩ§ÏΩ•ÏΩßÏΩ©ÏΩ∞ÏΩ±ÏΩ¥ÏΩ∏ÏæÄÏæÖÏæåÏæ°Ïæ®Ïæ∞ÏøÑÏø†Ïø°Ïø§Ïø®Ïø∞Ïø±Ïø≥ÏøµÏøºÌÄÄÌÄÑÌÄëÌÄòÌÄ≠ÌÄ¥ÌÄµÌÄ∏ÌÄº"],["c541","ÌúïÌúñÌúóÌúöÌúõÌúùÌúûÌúüÌú°",6,"Ìú™Ìú¨ÌúÆ",5,"Ìú∂Ìú∑Ìúπ"],["c561","Ìú∫ÌúªÌúΩ",6,"ÌùÖÌùÜÌùàÌùä",5,"ÌùíÌùìÌùïÌùö",4],["c581","ÌùüÌù¢Ìù§Ìù¶ÌùßÌù®Ìù™Ìù´Ìù≠ÌùÆÌùØÌù±Ìù≤Ìù≥Ìùµ",6,"ÌùæÌùøÌûÄÌûÇ",5,"ÌûäÌûãÌÅÑÌÅÖÌÅáÌÅâÌÅêÌÅîÌÅòÌÅ†ÌÅ¨ÌÅ≠ÌÅ∞ÌÅ¥ÌÅºÌÅΩÌÇÅÌÇ§ÌÇ•ÌÇ®ÌÇ¨ÌÇ¥ÌÇµÌÇ∑ÌÇπÌÉÄÌÉÅÌÉÑÌÉàÌÉâÌÉêÌÉëÌÉìÌÉîÌÉïÌÉúÌÉùÌÉ†ÌÉ§ÌÉ¨ÌÉ≠ÌÉØÌÉ∞ÌÉ±ÌÉ∏ÌÑçÌÑ∞ÌÑ±ÌÑ¥ÌÑ∏ÌÑ∫ÌÖÄÌÖÅÌÖÉÌÖÑÌÖÖÌÖåÌÖçÌÖêÌÖîÌÖúÌÖùÌÖüÌÖ°ÌÖ®ÌÖ¨ÌÖºÌÜÑÌÜàÌÜ†ÌÜ°ÌÜ§ÌÜ®ÌÜ∞ÌÜ±ÌÜ≥ÌÜµÌÜ∫ÌÜºÌáÄÌáòÌá¥Ìá∏ÌàáÌàâÌàêÌà¨Ìà≠Ìà∞Ìà¥ÌàºÌàΩÌàøÌâÅÌâàÌâú"],["c641","ÌûçÌûéÌûèÌûë",6,"ÌûöÌûúÌûû",5],["c6a1","Ìâ§ÌäÄÌäÅÌäÑÌäàÌäêÌäëÌäïÌäúÌä†Ìä§Ìä¨Ìä±Ìä∏ÌäπÌäºÌäøÌãÄÌãÇÌãàÌãâÌããÌãîÌãòÌãúÌã§Ìã•Ìã∞Ìã±Ìã¥Ìã∏ÌåÄÌåÅÌåÉÌåÖÌååÌåçÌåéÌåêÌåîÌåñÌåúÌåùÌåüÌå†Ìå°Ìå•Ìå®Ìå©Ìå¨Ìå∞Ìå∏ÌåπÌåªÌåºÌåΩÌçÑÌçÖÌçºÌçΩÌéÄÌéÑÌéåÌéçÌéèÌéêÌéëÌéòÌéôÌéúÌé†Ìé®Ìé©Ìé´Ìé≠Ìé¥Ìé∏ÌéºÌèÑÌèÖÌèàÌèâÌèêÌèòÌè°Ìè£Ìè¨Ìè≠Ìè∞Ìè¥ÌèºÌèΩÌèøÌêÅ"],["c7a1","ÌêàÌêùÌëÄÌëÑÌëúÌë†Ìë§Ìë≠ÌëØÌë∏ÌëπÌëºÌëøÌíÄÌíÇÌíàÌíâÌíãÌíçÌíîÌí©ÌìåÌìêÌìîÌìúÌìüÌì®Ìì¨Ìì∞Ìì∏ÌìªÌìΩÌîÑÌîàÌîåÌîîÌîïÌîóÌîºÌîΩÌïÄÌïÑÌïåÌïçÌïèÌïëÌïòÌïôÌïúÌï†Ìï•Ìï®Ìï©Ìï´Ìï≠Ìï¥ÌïµÌï∏ÌïºÌñÑÌñÖÌñáÌñàÌñâÌñêÌñ•ÌóàÌóâÌóåÌóêÌóíÌóòÌóôÌóõÌóùÌó§Ìó•Ìó®Ìó¨Ìó¥ÌóµÌó∑ÌóπÌòÄÌòÅÌòÑÌòàÌòêÌòëÌòìÌòîÌòïÌòúÌò†"],["c8a1","Ìò§Ìò≠Ìò∏ÌòπÌòºÌôÄÌôÖÌôàÌôâÌôãÌôçÌôëÌôîÌôïÌôòÌôúÌôßÌô©Ìô∞Ìô±Ìô¥ÌöÉÌöÖÌöåÌöçÌöêÌöîÌöùÌöüÌö°Ìö®Ìö¨Ìö∞ÌöπÌöªÌõÑÌõÖÌõàÌõåÌõëÌõîÌõóÌõôÌõ†Ìõ§Ìõ®Ìõ∞ÌõµÌõºÌõΩÌúÄÌúÑÌúëÌúòÌúôÌúúÌú†Ìú®Ìú©Ìú´Ìú≠Ìú¥ÌúµÌú∏ÌúºÌùÑÌùáÌùâÌùêÌùëÌùîÌùñÌùóÌùòÌùôÌù†Ìù°Ìù£Ìù•Ìù©Ìù¨Ìù∞Ìù¥ÌùºÌùΩÌûÅÌûàÌûâÌûåÌûêÌûòÌûôÌûõÌûù"],["caa1","‰ºΩ‰Ω≥ÂÅáÂÉπÂä†ÂèØÂëµÂì•ÂòâÂ´ÅÂÆ∂ÊöáÊû∂Êû∑ÊüØÊ≠åÁèÇÁóÇÁ®ºËãõËåÑË°óË¢àË®∂Ë≥àË∑èËªªËø¶ÈßïÂàªÂç¥ÂêÑÊÅ™ÊÖ§ÊÆºÁèèËÑöË¶∫ËßíÈñ£‰æÉÂàäÂ¢æÂ•∏Âß¶Âπ≤ÂππÊááÊèÄÊùÜÊü¨Ê°øÊæóÁôéÁúãÁ£µÁ®àÁ´øÁ∞°ËÇùËâÆËâ±Ë´´Èñì‰π´ÂñùÊõ∑Ê∏¥Á¢£Á´≠ËëõË§êËùéÈû®ÂãòÂùéÂ†™ÂµåÊÑüÊÜæÊà°Êï¢ÊüëÊ©ÑÊ∏õÁîòÁñ≥Áõ£Áû∞Á¥∫ÈÇØÈëëÈëíÈæï"],["cba1","Âå£Â≤¨Áî≤ËÉõÈâÄÈñòÂâõÂ†àÂßúÂ≤°Â¥óÂ∫∑Âº∫ÂΩäÊÖ∑Ê±üÁï∫ÁñÜÁ≥†Áµ≥Á∂±ÁæåËÖîËà°ËñëË•ÅË¨õÈãºÈôçÈ±á‰ªã‰ª∑ÂÄãÂá±Â°èÊÑ∑ÊÑæÊÖ®ÊîπÊß™ÊºëÁñ•ÁöÜÁõñÁÆáËä•ËìãÔ§ÄÈéßÈñãÂñÄÂÆ¢ÂùëÔ§ÅÁ≤≥ÁæπÈÜµÂÄ®ÂéªÂ±ÖÂ∑®ÊãíÊçÆÊìöÊìßÊ∏†ÁÇ¨Á•õË∑ùË∏ûÔ§ÇÈÅΩÈâÖÈã∏‰πæ‰ª∂ÂÅ•Â∑æÂª∫ÊÑÜÊ•óËÖ±ËôîËπáÈçµÈ®´‰πûÂÇëÊù∞Ê°ÄÂÑâÂäçÂäíÊ™¢"],["cca1","ÁûºÈàêÈªîÂä´ÊÄØËø≤ÂÅàÊÜ©Êè≠ÊìäÊ†ºÊ™ÑÊøÄËÜàË¶°ÈöîÂ†ÖÁâΩÁä¨ÁîÑÁµπÁπ≠ËÇ©Ë¶ãË≠¥ÈÅ£ÈµëÊäâÊ±∫ÊΩîÁµêÁº∫Ë®£ÂÖºÊÖäÁÆùË¨ôÈâóÈéå‰∫¨‰øìÂÄûÂÇæÂÑÜÂãÅÂãçÂçøÂù∞Â¢ÉÂ∫öÂæëÊÖ∂ÊÜ¨ÊìéÊï¨ÊôØÊöªÊõ¥Ê¢óÊ∂áÁÇÖÁÉ±ÁíüÁí•ÁìäÁóôÁ°¨Á£¨Á´üÁ´∂ÁµÖÁ∂ìËÄïËÄøËÑõËéñË≠¶ËºïÈÄïÈè°È†ÉÈ†∏È©öÈØ®‰øÇÂïìÂ†∫Â•ëÂ≠£Â±ÜÊÇ∏ÊàíÊ°ÇÊ¢∞"],["cda1","Ê£®Ê∫™ÁïåÁô∏Á£éÁ®ΩÁ≥ªÁπ´ÁπºË®àË™°Ë∞øÈöéÈ∑ÑÂè§Âè©ÂëäÂë±Âõ∫ÂßëÂ≠§Â∞ªÂ∫´Êã∑Êî∑ÊïÖÊï≤Êö†ÊûØÊßÅÊ≤ΩÁóºÁöêÁùæÁ®øÁæîËÄÉËÇ°ËÜèËã¶ËãΩËè∞ËóÅË†±Ë¢¥Ë™•Ô§ÉËæúÈåÆÈõáÈ°ßÈ´òÈºìÂì≠ÊñõÊõ≤Ê¢èÁ©ÄË∞∑Èµ†Âõ∞Âù§Â¥ëÊòÜÊ¢±Ê£çÊªæÁê®Ë¢ûÈØ§Ê±®Ô§ÑÈ™®‰æõÂÖ¨ÂÖ±ÂäüÂ≠îÂ∑•ÊÅêÊÅ≠Êã±ÊéßÊîªÁèôÁ©∫Ëö£Ë≤¢Èûè‰∏≤ÂØ°ÊààÊûúÁìú"],["cea1","ÁßëËèìË™áË™≤Ë∑®ÈÅéÈçãÈ°ÜÂªìÊß®ËóøÈÉ≠Ô§ÖÂÜ†ÂÆòÂØ¨ÊÖ£Ê£∫Ê¨æÁÅåÁêØÁìòÁÆ°ÁΩêËèÖËßÄË≤´ÈóúÈ§®ÂàÆÊÅùÊã¨ÈÄÇ‰æäÂÖâÂå°Â£ôÂª£Êõ†Ê¥∏ÁÇöÁãÇÁèñÁ≠êËÉ±ÈëõÂç¶ÊéõÁΩ´‰πñÂÇÄÂ°äÂ£ûÊÄ™ÊÑßÊãêÊßêÈ≠ÅÂÆèÁ¥òËÇ±ËΩü‰∫§ÂÉëÂí¨Âñ¨Â¨åÂ∂†Â∑ßÊî™ÊïéÊ†°Ê©ãÁã°ÁöéÁüØÁµûÁøπËÜ†ËïéËõüËºÉËΩéÈÉäÈ§ÉÈ©ïÈÆ´‰∏ò‰πÖ‰πù‰ªá‰ø±ÂÖ∑Âãæ"],["cfa1","ÂçÄÂè£Âè•ÂíéÂòîÂùµÂû¢ÂØáÂ∂áÂªêÊáºÊãòÊïëÊû∏Êü©ÊßãÊ≠êÊØÜÊØ¨Ê±ÇÊ∫ùÁÅ∏ÁãóÁéñÁêÉÁûøÁü©Á©∂ÁµøËÄâËáºËàÖËàäËãüË°¢Ë¨≥Ë≥ºËªÄÈÄëÈÇ±Èâ§Èä∂ÈßíÈ©ÖÈ≥©È∑óÈæúÂúãÂ±ÄËèäÈû†Èû´È∫¥ÂêõÁ™òÁæ§Ë£ôËªçÈÉ°Â†ÄÂ±àÊéòÁ™üÂÆÆÂºìÁ©πÁ™ÆËäéË∫¨ÂÄ¶Âà∏Âã∏Âç∑ÂúàÊã≥Êç≤Ê¨äÊ∑ÉÁú∑Âé•ÁçóËï®Ëπ∂ÈóïÊú∫Ê´ÉÊΩ∞Ë©≠ËªåÈ•ãÔ§ÜÊô∑Ê≠∏Ë≤¥"],["d0a1","È¨ºÔ§áÂè´Âú≠Â•éÊèÜÊßªÁè™Á°ÖÁ™∫Á´ÖÁ≥æËëµË¶èËµ≥ÈÄµÈñ®ÂãªÂùáÁïáÁ≠†ËèåÈàûÔ§àÊ©òÂÖãÂâãÂäáÊàüÊ£òÊ•µÈöôÂÉÖÂä§Âã§ÊáÉÊñ§Ê†πÊßøÁëæÁ≠ãËäπËè´Ë¶≤Ë¨πËøëÈ•âÔ§â‰ªäÂ¶óÊìíÊòëÊ™éÁê¥Á¶ÅÁ¶ΩËä©Ë°æË°øË•üÔ§äÈå¶‰ºãÂèäÊÄ•Êâ±Ê±≤Á¥öÁµ¶‰∫òÂÖ¢ÁüúËÇØ‰ºÅ‰ºéÂÖ∂ÂÜÄÂóúÂô®ÂúªÂü∫ÂüºÂ§îÂ•áÂ¶ìÂØÑÂ≤êÂ¥éÂ∑±ÂπæÂøåÊäÄÊóóÊó£"],["d1a1","ÊúûÊúüÊùûÊ£ãÊ£ÑÊ©üÊ¨∫Ê∞£Ê±ΩÊ≤ÇÊ∑áÁéòÁê¶Áê™ÁíÇÁí£Áï∏ÁïøÁ¢ÅÁ£ØÁ•ÅÁ•áÁ•àÁ•∫ÁÆïÁ¥ÄÁ∂∫ÁæàËÄÜËÄ≠ËÇåË®òË≠èË±àËµ∑Èå°Èå§È£¢È•ëÈ®éÈ®èÈ©•È∫íÁ∑ä‰Ω∂ÂêâÊãÆÊ°îÈáëÂñ´ÂÑ∫Ô§ãÔ§åÂ®úÊá¶Ô§çÊãèÊãøÔ§é",5,"ÈÇ£Ô§î",4,"Ë´æÔ§ôÔ§öÔ§õÔ§úÊöñÔ§ùÁÖñÔ§ûÔ§üÈõ£Ô§†ÊçèÊç∫ÂçóÔ§°ÊûèÊ•†Êπ≥Ô§¢Áî∑Ô§£Ô§§Ô§•"],["d2a1","Á¥çÔ§¶Ô§ßË°≤ÂõäÂ®òÔ§®",4,"‰πÉÔ§≠ÂÖßÂ•àÊü∞ËÄêÔ§ÆÂ•≥Âπ¥ÊíöÁßäÂøµÊÅ¨ÊãàÊçªÂØßÂØóÂä™Ô§ØÂ•¥Âº©ÊÄíÔ§∞Ô§±Ô§≤ÁëôÔ§≥",5,"ÈßëÔ§π",10,"ÊøÉÔ•ÑÔ•ÖËÜøËæ≤ÊÉ±Ô•ÜÔ•áËÖ¶Ô•àÔ•âÂ∞øÔ•ä",7,"Â´©Ë®•ÊùªÁ¥êÔ•í",5,"ËÉΩÔ•òÔ•ôÂ∞ºÊ≥•ÂåøÊ∫∫Â§öËå∂"],["d3a1","‰∏π‰∫∂‰ΩÜÂñÆÂúòÂ£áÂΩñÊñ∑Êó¶Ê™ÄÊÆµÊπçÁü≠Á´ØÁ∞ûÁ∑ûËõãË¢íÈÑ≤ÈçõÊíªÊææÁç∫Áñ∏ÈÅîÂïñÂùçÊÜ∫ÊìîÊõáÊ∑°ÊπõÊΩ≠ÊæπÁó∞ËÅÉËÜΩËïÅË¶ÉË´áË≠öÈåüÊ≤ìÁïìÁ≠îË∏èÈÅùÂîêÂ†ÇÂ°òÂπ¢ÊàáÊíûÊ£†Áï∂Á≥ñËû≥Èª®‰ª£ÂûàÂùÆÂ§ßÂ∞çÂ≤±Â∏∂ÂæÖÊà¥Êì°Áé≥Ëá∫Ë¢ãË≤∏ÈöäÈªõÂÆÖÂæ∑ÊÇ≥ÂÄíÂàÄÂà∞ÂúñÂ†µÂ°óÂ∞éÂ±†Â≥∂Â∂ãÂ∫¶ÂæíÊÇºÊåëÊéâÊêóÊ°É"],["d4a1","Ê£πÊ´ÇÊ∑òÊ∏°ÊªîÊø§ÁáæÁõúÁùπÁ¶±Á®ªËêÑË¶©Ë≥≠Ë∑≥ËπàÈÄÉÈÄîÈÅìÈÉΩÈççÈô∂ÈüúÊØíÁÄÜÁâòÁä¢Áç®Áù£Á¶øÁØ§Á∫õËÆÄÂ¢©ÊÉáÊï¶ÊóΩÊöæÊ≤åÁÑûÁáâË±öÈ†ì‰π≠Á™Å‰ªùÂÜ¨ÂáçÂãïÂêåÊÜßÊù±Ê°êÊ£üÊ¥ûÊΩºÁñºÁû≥Á´•ËÉ¥Ëë£ÈäÖÂÖúÊñóÊùúÊûìÁóòÁ´áËç≥Ô•öË±ÜÈÄóÈ†≠Â±ØËáÄËäöÈÅÅÈÅØÈàçÂæóÂ∂ùÊ©ôÁáàÁôªÁ≠âËó§Ë¨ÑÈÑßÈ®∞ÂñáÊá∂Ô•õÁô©ÁæÖ"],["d5a1","ËòøËû∫Ë£∏ÈÇèÔ•úÊ¥õÁÉôÁèûÁµ°ËêΩÔ•ùÈÖ™Èß±Ô•û‰∫ÇÂçµÊ¨ÑÊ¨íÁÄæÁàõËò≠È∏ûÂâåËæ£ÂµêÊì•Êî¨Ê¨ñÊø´Á±ÉÁ∫úËóçË•§Ë¶ΩÊãâËáòË†üÂªäÊúóÊµ™ÁãºÁêÖÁëØËûÇÈÉû‰æÜÂ¥çÂæ†ËêäÂÜ∑Êé†Áï•‰∫ÆÂÄÜÂÖ©ÂáâÊ¢ÅÊ®ëÁ≤ÆÁ≤±Á≥ßËâØË´íËºõÈáè‰æ∂ÂÑ∑ÂãµÂëÇÂª¨ÊÖÆÊàæÊóÖÊ´öÊøæÁ§™ËóúË†£Èñ≠È©¢È©™È∫óÈªéÂäõÊõÜÊ≠∑ÁÄùÁ§´ËΩ¢ÈùÇÊÜêÊàÄÊî£Êº£"],["d6a1","ÁÖâÁíâÁ∑¥ËÅØËìÆËº¶ÈÄ£ÈçäÂÜΩÂàóÂä£Ê¥åÁÉàË£ÇÂªâÊñÇÊÆÆÊøÇÁ∞æÁçµ‰ª§‰º∂ÂõπÔ•üÂ≤∫Â∂∫ÊÄúÁé≤Á¨≠ÁæöÁøéËÅÜÈÄûÈà¥Èõ∂ÈùàÈ†òÈΩ°‰æãÊæßÁ¶ÆÈÜ¥Èö∑ÂãûÔ•†ÊíàÊìÑÊ´ìÊΩûÁÄòÁàêÁõßËÄÅËòÜËôúË∑ØËºÖÈú≤È≠ØÈ∑∫ÈπµÁ¢åÁ•øÁ∂†ËèâÈåÑÈπøÈ∫ìË´ñÂ£üÂºÑÊúßÁÄßÁìèÁ±†ËÅæÂÑ°ÁÄ®Áâ¢Á£äË≥ÇË≥öË≥¥Èõ∑‰∫ÜÂÉöÂØÆÂªñÊñôÁáéÁôÇÁû≠ËÅäËìº"],["d7a1","ÈÅºÈ¨ßÈæçÂ£òÂ©ÅÂ±¢Ê®ìÊ∑öÊºèÁòªÁ¥ØÁ∏∑ËîûË§∏Èè§ÈôãÂäâÊóíÊü≥Ê¶¥ÊµÅÊ∫úÁÄèÁêâÁë†ÁïôÁò§Á°´Ë¨¨È°ûÂÖ≠ÊàÆÈô∏‰æñÂÄ´Â¥ôÊ∑™Á∂∏Ëº™ÂæãÊÖÑÊ†óÔ•°ÈöÜÂãíËÇãÂáúÂáåÊ•ûÁ®úÁ∂æËè±Èôµ‰øöÂà©ÂéòÂêèÂîéÂ±•ÊÇßÊùéÊ¢®Êµ¨ÁäÅÁã∏ÁêÜÁíÉÔ•¢Áó¢Á±¨ÁΩπÁæ∏ËéâË£èË£°ÈáåÈáêÈõ¢ÈØâÂêùÊΩæÁáêÁíòËó∫Ë∫™Èö£È±óÈ∫üÊûóÊ∑ãÁê≥Ëá®ÈúñÁ†¨"],["d8a1","Á´ãÁ¨†Á≤íÊë©Áë™Áó≤Á¢ºÁ£®È¶¨È≠îÈ∫ªÂØûÂπïÊº†ËÜúËé´ÈÇà‰∏áÂççÂ®©Â∑íÂΩéÊÖ¢ÊåΩÊô©ÊõºÊªøÊº´ÁÅ£ÁûûËê¨ËîìË†ªËºìÈ•ÖÈ∞ªÂîúÊäπÊú´Ê≤´ËåâË•™Èù∫‰∫°Â¶ÑÂøòÂøôÊúõÁ∂≤ÁΩîËäíËå´ËéΩËºûÈÇôÂüãÂ¶πÂ™íÂØêÊòßÊûöÊ¢ÖÊØèÁÖ§ÁΩµË≤∑Ë≥£ÈÇÅÈ≠ÖËÑàË≤äÈôåÈ©ÄÈ∫•Â≠üÊ∞ìÁåõÁõ≤ÁõüËêåÂÜ™Ë¶ìÂÖçÂÜïÂãâÊ£âÊ≤îÁúÑÁú†Á∂øÁ∑¨Èù¢È∫µÊªÖ"],["d9a1","ËîëÂÜ•ÂêçÂëΩÊòéÊöùÊ§ßÊ∫üÁöøÁûëËåóËìÇËûüÈÖ©ÈäòÈ≥¥Ë¢Ç‰æÆÂÜíÂãüÂßÜÂ∏ΩÊÖïÊë∏ÊëπÊöÆÊüêÊ®°ÊØçÊØõÁâüÁâ°ÁëÅÁú∏ÁüõËÄóËäºËåÖË¨ÄË¨®Ë≤åÊú®Ê≤êÁâßÁõÆÁù¶Á©ÜÈ∂©Ê≠øÊ≤íÂ§¢Êú¶ËíôÂçØÂ¢ìÂ¶ôÂªüÊèèÊò¥Êù≥Ê∏∫Áå´Á´óËãóÈå®ÂãôÂ∑´ÊÜÆÊáãÊàäÊãáÊí´Êó†Ê•ôÊ≠¶ÊØãÁÑ°Áè∑ÁïùÁπÜËàûËåÇËï™Ë™£Ë≤øÈúßÈµ°Â¢®ÈªòÂÄëÂàéÂêªÂïèÊñá"],["daa1","Ê±∂Á¥äÁ¥ãËÅûËöäÈñÄÈõØÂãøÊ≤ïÁâ©Âë≥Â™öÂ∞æÂµãÂΩåÂæÆÊú™Ê¢∂Ê•£Ê∏ºÊπÑÁúâÁ±≥ÁæéËñáË¨éËø∑Èù°Èª¥Â≤∑ÊÇ∂ÊÑçÊÜ´ÊïèÊóªÊóºÊ∞ëÊ≥ØÁéüÁèâÁ∑°ÈñîÂØÜËúúË¨êÂâùÂçöÊãçÊêèÊí≤Êú¥Ê®∏Ê≥äÁèÄÁíûÁÆîÁ≤ïÁ∏õËÜäËà∂ËñÑËø´ÈõπÈßÅ‰º¥ÂçäÂèçÂèõÊãåÊê¨ÊîÄÊñëÊßÉÊ≥ÆÊΩòÁè≠ÁïîÁò¢Áõ§ÁõºÁ£êÁ£ªÁ§¨ÁµÜËà¨Ëü†ËøîÈ†íÈ£ØÂãÉÊãîÊí•Ê∏§ÊΩë"],["dba1","ÁôºË∑ãÈÜ±Èâ¢È´ÆÈ≠ÉÂÄ£ÂÇçÂùäÂ¶®Â∞®ÂπáÂΩ∑ÊàøÊîæÊñπÊóÅÊòâÊûãÊ¶úÊªÇÁ£ÖÁ¥°ËÇ™ËÜÄËà´Ëä≥Ëí°ËöåË®™Ë¨óÈÇ¶Èò≤ÈæêÂÄç‰ø≥Ô•£ÂüπÂæòÊãúÊéíÊùØÊπÉÁÑôÁõÉËÉåËÉöË£¥Ë£µË§ôË≥†Ëº©ÈÖçÈô™‰ºØ‰Ω∞Â∏õÊüèÊ†¢ÁôΩÁôæÈ≠ÑÂπ°Ê®äÁÖ©ÁáîÁï™Ô•§ÁπÅËïÉËó©È£ú‰ºêÁ≠èÁΩ∞Èñ•Âá°Â∏ÜÊ¢µÊ∞æÊ±éÊ≥õÁäØÁØÑËåÉÊ≥ïÁê∫ÂÉªÂäàÂ£ÅÊìòÊ™óÁíßÁôñ"],["dca1","Á¢ßËòóÈó¢ÈúπÔ••ÂçûÂºÅËÆäËæ®ËæØÈÇäÂà•Áû•È±âÈºà‰∏ôÂÄÇÂÖµÂ±õÂπ∑ÊòûÊò∫ÊüÑÊ£ÖÁÇ≥ÁîÅÁóÖÁßâÁ´ùËºßÈ§†È®à‰øùÂ†°Â†±ÂØ∂ÊôÆÊ≠•Ê¥ëÊπ∫ÊΩΩÁè§Áî´Ëè©Ë£úË§ìË≠úËºî‰ºèÂÉïÂåêÂçúÂÆìÂæ©ÊúçÁ¶èËÖπËåØËîîË§áË¶ÜËºπËºªÈ¶•È∞íÊú¨‰π∂‰ø∏Â•âÂ∞ÅÂ≥ØÂ≥∞ÊçßÊ£íÁÉΩÁÜ¢Áê´Á∏´Ëì¨ËúÇÈÄ¢ÈãíÈ≥≥‰∏ç‰ªò‰øØÂÇÖÂâñÂâØÂê¶ÂíêÂü†Â§´Â©¶"],["dda1","Â≠öÂ≠µÂØåÂ∫úÔ•¶Êâ∂Êï∑ÊñßÊµÆÊ∫•Áà∂Á¨¶Á∞øÁº∂ËÖêËÖëËÜöËâÄËäôËé©Ë®ÉË≤†Ë≥¶Ë≥ªËµ¥Ë∂∫ÈÉ®ÈáúÈòúÈôÑÈßôÈ≥ßÂåóÂàÜÂê©Âô¥Â¢≥Â•îÂ•ÆÂøøÊÜ§ÊâÆÊòêÊ±æÁÑöÁõÜÁ≤âÁ≥ûÁ¥õËä¨Ë≥ÅÈõ∞Ô•ß‰ΩõÂºóÂΩøÊãÇÂ¥©ÊúãÊ£öÁ°ºÁπÉÈµ¨‰∏ïÂÇôÂåïÂå™ÂçëÂ¶ÉÂ©¢Â∫áÊÇ≤ÊÜäÊââÊâπÊñêÊûáÊ¶ßÊØîÊØñÊØóÊØòÊ≤∏Ô•®ÁêµÁó∫Á†íÁ¢ëÁßïÁßòÁ≤ÉÁ∑ãÁø°ËÇ•"],["dea1","ËÑæËáÇËè≤ËúöË£®Ë™πË≠¨Ë≤ªÈÑôÈùûÈ£õÈºªÂö¨Â¨™ÂΩ¨ÊñåÊ™≥ÊÆØÊµúÊø±ÁÄïÁâùÁé≠Ë≤ßË≥ìÈ†ªÊÜëÊ∞∑ËÅòÈ®Å‰πç‰∫ã‰∫õ‰ªï‰º∫‰ºº‰Ωø‰øüÂÉøÂè≤Âè∏ÂîÜÂó£ÂõõÂ£´Â•¢Â®ëÂØ´ÂØ∫Â∞ÑÂ∑≥Â∏´ÂæôÊÄùÊç®ÊñúÊñØÊü∂ÊüªÊ¢≠Ê≠ªÊ≤ôÊ≥óÊ∏£ÁÄâÁçÖÁ†ÇÁ§æÁ•ÄÁ•†ÁßÅÁØ©Á¥óÁµ≤ËÇÜËàçËééËìëËõáË£üË©êË©ûË¨ùË≥úËµ¶Ëæ≠ÈÇ™È£ºÈßüÈ∫ùÂâäÔ•©ÊúîÔ•™"],["dfa1","ÂÇòÂà™Â±±Êï£Ê±ïÁèäÁî£ÁñùÁÆóËíúÈÖ∏Èú∞‰π∑ÊííÊÆ∫ÁÖûËñ©‰∏âÔ•´ÊùâÊ£ÆÊ∏óËäüËîòË°´Êè∑ÊæÅÈàíÈ¢Ø‰∏äÂÇ∑ÂÉèÂÑüÂïÜÂñ™ÂòóÂ≠ÄÂ∞ôÂ≥†Â∏∏Â∫äÂ∫†ÂªÇÊÉ≥Ê°ëÊ©°ÊπòÁàΩÁâÄÁãÄÁõ∏Á••ÁÆ±ÁøîË£≥Ëß¥Ë©≥Ë±°Ë≥ûÈúúÂ°ûÁíΩË≥ΩÂóáÔ•¨Á©°Á¥¢Ëâ≤Áâ≤ÁîüÁî•Ô•≠Á¨ôÂ¢ÖÂ£ªÂ∂ºÂ∫èÂ∫∂ÂæêÊÅïÊäíÊçøÊïçÊöëÊõôÊõ∏Ê†ñÊ£≤ÁäÄÁëûÁ≠ÆÁµÆÁ∑ñÁΩ≤"],["e0a1","ËÉ•ËàíËñØË•øË™ìÈÄùÈã§ÈªçÈº†Â§ïÂ•≠Â∏≠ÊÉúÊòîÊô≥ÊûêÊ±êÊ∑ÖÊΩüÁü≥Á¢©ËìÜÈáãÈå´‰ªôÂÉäÂÖàÂñÑÂ¨ãÂÆ£ÊâáÊïæÊóãÊ∏≤ÁÖΩÁêÅÁëÑÁíáÁíøÁô¨Á¶™Á∑öÁπïÁæ®ËÖ∫ËÜ≥ËàπËòöËü¨Ë©µË∑£ÈÅ∏ÈäëÈê•È•çÈÆÆÂç®Â±ëÊ•îÊ≥ÑÊ¥©Ê∏´ËàåËñõË§ªË®≠Ë™™Èõ™ÈΩßÂâ°ÊöπÊÆ≤Á∫ñËüæË¥çÈñÉÈôùÊîùÊ∂âÁáÆÔ•ÆÂüéÂßìÂÆ¨ÊÄßÊÉ∫ÊàêÊòüÊôüÁå©ÁèπÁõõÁúÅÁ≠¨"],["e1a1","ËÅñËÅ≤ËÖ•Ë™†ÈÜí‰∏ñÂã¢Ê≠≤Ê¥óÁ®ÖÁ¨πÁ¥∞Ô•ØË≤∞Âè¨ÂòØÂ°ëÂÆµÂ∞èÂ∞ëÂ∑¢ÊâÄÊéÉÊêîÊò≠Ê¢≥Ê≤ºÊ∂àÊ∫ØÁÄüÁÇ§ÁáíÁî¶ÁñèÁñéÁòôÁ¨ëÁØ†Á∞´Á¥†Á¥πËî¨Ëï≠ËòáË®¥ÈÄçÈÅ°ÈÇµÈä∑Èü∂È®∑‰øóÂ±¨ÊùüÊ∂ëÁ≤üÁ∫åË¨ñË¥ñÈÄüÂ≠´Â∑ΩÊêçËìÄÈÅúÈ£°ÁéáÂÆãÊÇöÊùæÊ∑ûË®üË™¶ÈÄÅÈ†åÂà∑Ô•∞ÁÅëÁ¢éÈéñË°∞Èáó‰øÆÂèóÂóΩÂõöÂûÇÂ£ΩÂ´ÇÂÆàÂ≤´Â≥ÄÂ∏•ÊÑÅ"],["e2a1","ÊàçÊâãÊéàÊêúÊî∂Êï∏Ê®πÊÆäÊ∞¥Ê¥ôÊº±ÁáßÁã©Áç∏ÁêáÁí≤Áò¶Áù°ÁßÄÁ©óÁ´™Á≤πÁ∂èÁ∂¨Áπ°ÁæûËÑ©Ëå±ËíêËìöËó™Ë¢ñË™∞ËÆêËº∏ÈÅÇÈÇÉÈÖ¨ÈäñÈäπÈöãÈößÈö®ÈõñÈúÄÈ†àÈ¶ñÈ´ìÈ¨öÂèîÂ°æÂ§ôÂ≠∞ÂÆøÊ∑ëÊΩöÁÜüÁê°ÁíπËÇÖËèΩÂ∑°ÂæáÂæ™ÊÅÇÊó¨Ê†íÊ•ØÊ©ìÊÆâÊ¥µÊ∑≥Áè£ÁõæÁû¨Á≠çÁ¥îËÑ£ËàúËçÄËì¥Ëï£Ë©¢Ë´ÑÈÜáÈåûÈ†ÜÈ¶¥ÊàåË°ìËø∞Èâ•Â¥áÂ¥ß"],["e3a1","Âµ©ÁëüËÜùËù®ÊøïÊãæÁøíË§∂Ë•≤‰∏û‰πòÂÉßÂãùÂçáÊâøÊòáÁπ©Ë†ÖÈôû‰æçÂåôÂò∂ÂßãÂ™§Â∞∏Â±éÂ±çÂ∏ÇÂºëÊÅÉÊñΩÊòØÊôÇÊûæÊü¥ÁåúÁü¢Á§∫ÁøÖËíîËìçË¶ñË©¶Ë©©Ë´°Ë±ïË±∫Âü¥ÂØîÂºèÊÅØÊã≠Ê§çÊÆñÊπúÁÜÑÁØíËùïË≠òËªæÈ£üÈ£æ‰º∏‰æÅ‰ø°ÂëªÂ®†ÂÆ∏ÊÑºÊñ∞Êô®ÁáºÁî≥Á•ûÁ¥≥ËÖéËá£ËéòËñ™ËóéËúÉË®äË∫´ËæõÔ•±ËøÖÂ§±ÂÆ§ÂØ¶ÊÇâÂØ©Â∞ãÂøÉÊ≤Å"],["e4a1","Ô•≤Ê∑±ÁÄãÁîöËäØË´∂‰ªÄÂçÅÔ•≥ÈõôÊ∞è‰∫û‰øÑÂÖíÂïûÂ®•Â≥®ÊàëÁâôËäΩËé™ËõæË°ôË®ùÈòøÈõÖÈ§ìÈ¥âÈµùÂ†äÂ≤≥Â∂ΩÂπÑÊÉ°ÊÑïÊè°Ê®ÇÊ∏•ÈÑÇÈçîÈ°éÈ∞êÈΩ∑ÂÆâÂ≤∏ÊåâÊôèÊ°àÁúºÈõÅÈûçÈ°îÈÆüÊñ°Ë¨ÅËªãÈñºÂîµÂ≤©Â∑ñÂ∫µÊöóÁôåËè¥ÈóáÂ£ìÊäºÁãéÈ¥®‰ª∞Â§ÆÊÄèÊòªÊÆÉÁßßÈ¥¶ÂéìÂìÄÂüÉÂ¥ñÊÑõÊõñÊ∂ØÁ¢çËâæÈöòÈùÑÂéÑÊâºÊéñÊ∂≤Á∏äËÖãÈ°ç"],["e5a1","Ê´ªÁΩåÈ∂ØÈ∏ö‰πüÂÄªÂÜ∂Â§úÊÉπÊè∂Ê§∞Áà∫ËÄ∂Ô•¥ÈáéÂº±Ô•µÔ•∂Á¥ÑËã•ËëØËíªËó•Ë∫çÔ•∑‰ΩØÔ•∏Ô•πÂ£§Â≠ÉÊÅôÊèöÊîòÊï≠ÊöòÔ•∫Ê•äÊ®£Ê¥ãÁÄÅÁÖ¨ÁóíÁòçÁ¶≥Á©∞Ô•ªÁæäÔ•ºË•ÑÔ•ΩËÆìÈáÄÈôΩÔ•æÈ§äÂúÑÂæ°ÊñºÊºÅÁòÄÁ¶¶Ë™ûÈ¶≠È≠öÈΩ¨ÂÑÑÊÜ∂ÊäëÊ™çËáÜÂÅÉÂ†∞ÂΩ¶ÁÑâË®ÄË´∫Â≠ºËòñ‰ø∫ÂÑºÂö¥Â•ÑÊé©Ê∑πÂ∂™Ê•≠ÂÜÜ‰∫à‰ΩôÔ•øÔ¶ÄÔ¶ÅÂ¶ÇÔ¶Ç"],["e6a1","Ô¶ÉÊ≠üÊ±ùÔ¶ÑÁíµÁ§ñÔ¶ÖËàáËâÖËåπËºøËΩùÔ¶ÜÈ§òÔ¶áÔ¶àÔ¶â‰∫¶Ô¶äÂüüÂΩπÊòìÔ¶ãÔ¶åÁñ´ÁππË≠ØÔ¶çÈÄÜÈ©õÂö•Â†ßÂß∏Â®üÂÆ¥Ô¶éÂª∂Ô¶èÔ¶êÊçêÊåªÔ¶ëÊ§ΩÊ≤áÊ≤øÊ∂éÊ∂ìÊ∑µÊºîÔ¶íÁÉüÁÑ∂ÁÖôÔ¶ìÁáÉÁáïÔ¶îÁ°èÁ°ØÔ¶ïÁ≠µÁ∑£Ô¶ñÁ∏ØÔ¶óË°çËªüÔ¶òÔ¶ôÔ¶öÈâõÔ¶õÈ≥∂Ô¶úÔ¶ùÔ¶ûÊÇÖÊ∂ÖÔ¶üÁÜ±Ô¶†Ô¶°Èñ±Âé≠Ô¶¢Ô¶£Ô¶§ÊüìÔ¶•ÁÇéÁÑ∞Áê∞Ëâ∂Ëãí"],["e7a1","Ô¶¶ÈñªÈ´•ÈπΩÊõÑÔ¶ßÁáÅËëâÔ¶®Ô¶©Â°ãÔ¶™Ô¶´Â∂∏ÂΩ±Ô¶¨Êò†ÊöéÊ•πÊ¶ÆÊ∞∏Ê≥≥Ê∏∂ÊΩÅÊøöÁÄõÁÄØÁÖêÁáüÁç∞Ô¶≠ÁëõÔ¶ÆÁìîÁõàÁ©éÁ∫ìÔ¶ØÔ¶∞Ëã±Ë©†ËøéÔ¶±ÈçàÔ¶≤ÈúôÔ¶≥Ô¶¥‰πÇÂÄ™Ô¶µÂààÂè°Êõ≥Ê±≠ÊøäÁåäÁùøÁ©¢ËäÆËóùËòÇÔ¶∂Ë£îË©£Ë≠ΩË±´Ô¶∑Èä≥Ô¶∏ÈúìÈ†ê‰∫î‰ºç‰øâÂÇ≤ÂçàÂêæÂê≥ÂóöÂ°¢Â¢∫Â•ßÂ®õÂØ§ÊÇüÔ¶πÊáäÊïñÊóøÊô§Ê¢ßÊ±öÊæ≥"],["e8a1","ÁÉèÁÜ¨ÁçíÁ≠ΩËúàË™§È∞≤ÈºáÂ±ãÊ≤ÉÁçÑÁéâÈà∫Ê∫´Áë•ÁòüÁ©©Á∏ïËòäÂÖÄÂ£ÖÊìÅÁìÆÁîïÁô∞ÁøÅÈÇïÈõçÈ•îÊ∏¶Áì¶Á™©Á™™Ëá•ËõôËù∏Ë®õÂ©âÂÆåÂÆõÊ¢°Ê§ÄÊµ£Áé©ÁêìÁê¨Á¢óÁ∑©Áø´ËÑòËÖïËéûË±åÈòÆÈ†ëÊõ∞ÂæÄÊó∫ÊûâÊ±™ÁéãÂÄ≠Â®ÉÊ≠™ÁüÆÂ§ñÂµ¨Â∑çÁå•ÁïèÔ¶∫Ô¶ªÂÉ•ÂáπÂ†ØÂ§≠Â¶ñÂßöÂØ•Ô¶ºÔ¶ΩÂ∂¢ÊãóÊêñÊíìÊìæÔ¶æÊõúÔ¶øÊ©àÔßÄÁáøÁë§ÔßÅ"],["e9a1","Á™àÁ™ØÁπáÁπûËÄÄËÖ∞ÔßÇËüØË¶ÅË¨†ÈÅôÔßÉÈÇÄÈ•íÊÖæÊ¨≤Êµ¥Á∏üË§•Ëæ±‰øëÂÇ≠ÂÜóÂãáÂüáÂ¢âÂÆπÂ∫∏ÊÖÇÊ¶ïÊ∂åÊπßÊ∫∂ÁÜîÁë¢Áî®Áî¨ËÅ≥Ëå∏ËìâË∏äÈéîÈèûÔßÑ‰∫é‰ΩëÂÅ∂ÂÑ™ÂèàÂèãÂè≥ÂÆáÂØìÂ∞§ÊÑöÊÜÇÊó¥ÁâõÁéóÁëÄÁõÇÁ•êÁ¶ëÁ¶πÁ¥ÜÁæΩËäãËóïËôûËøÇÈÅáÈÉµÈá™ÈöÖÈõ®Èõ©ÂãñÂΩßÊó≠Êò±Ê†ØÁÖúÁ®∂ÈÉÅÈ†ä‰∫ëÔßÖÊ©íÊÆûÊæêÁÜâËÄòËä∏Ëïì"],["eaa1","ÈÅãÈöïÈõ≤ÈüªËîöÈ¨±‰∫êÁÜäÈõÑÂÖÉÂéüÂì°ÂúìÂúíÂû£Â™õÂ´ÑÂØÉÊÄ®ÊÑøÊè¥Ê≤ÖÊ¥πÊπ≤Ê∫êÁà∞ÁåøÁëóËãëË¢ÅËΩÖÈÅ†ÔßÜÈô¢È°òÈ¥õÊúàË∂äÈâû‰ΩçÂÅâÂÉûÂç±ÂúçÂßîÂ®ÅÂ∞âÊÖ∞ÊöêÊ∏≠Áà≤ÁëãÁ∑ØËÉÉËêéËë¶ËîøËùüË°õË§òË¨ÇÈÅïÈüãÈ≠è‰π≥‰æëÂÑíÂÖ™ÔßáÂîØÂñ©Â≠∫ÂÆ•ÂπºÂπΩÂ∫æÊÇ†ÊÉüÊÑàÊÑâÊèÑÊî∏ÊúâÔßàÊüîÊüöÔßâÊ•°Ê•¢Ê≤πÊ¥ßÔßäÊ∏∏Ôßã"],["eba1","Êø°Áå∂Áå∑ÔßåÁëúÁî±ÔßçÁôíÔßéÔßèÁ∂≠ËáæËê∏Ë£ïË™òË´õË´≠Ë∏∞ËπÇÈÅäÈÄæÈÅ∫ÈÖâÈáâÈçÆÔßêÔßëÂ†âÔßíÊØìËÇâËÇ≤ÔßìÔßîÂÖÅÂ•´Â∞πÔßïÔßñÊΩ§ÁéßËÉ§Ë¥áÔßóÈàóÈñèÔßòÔßôÔßöÔßõËÅøÊàéÁÄúÁµ®ËûçÔßúÂû†ÊÅ©ÊÖáÊÆ∑Ë™æÈäÄÈö±‰πôÂêüÊ∑´Ëî≠Èô∞Èü≥È£ÆÊèñÊ≥£ÈÇëÂáùÊáâËÜ∫È∑π‰æùÂÄöÂÑÄÂÆúÊÑèÊáøÊì¨Ê§ÖÊØÖÁñëÁü£Áæ©Ëâ§ËñèËüªË°£Ë™º"],["eca1","Ë≠∞ÈÜ´‰∫å‰ª•‰ºäÔßùÔßûÂ§∑Âß®ÔßüÂ∑≤ÂºõÂΩõÊÄ°Ôß†Ôß°Ôß¢Ôß£ÁàæÁè•Ôß§Áï∞ÁóçÔß•ÁßªÔß¶ËÄåËÄ≥ËÇÑËã°ËçëÔßßÔß®Ë≤ΩË≤≥ÈÇáÔß©Ôß™È£¥È§åÔß´Ôß¨ÁÄ∑ÁõäÁøäÁøåÁøºË¨ö‰∫∫‰ªÅÂàÉÂç∞Ôß≠ÂíΩÂõ†ÂßªÂØÖÂºïÂøçÊπÆÔßÆÔßØÁµ™ËåµÔß∞ËöìË™çÔß±Èù≠Èù∑Ôß≤Ôß≥‰∏Ä‰Ωö‰ΩæÂ£πÊó•Ê∫¢ÈÄ∏Èé∞È¶π‰ªªÂ£¨Â¶äÂßôÊÅÅÔß¥ÔßµÁ®îÔß∂ËçèË≥ÉÂÖ•ÂçÑ"],["eda1","Ôß∑Ôß∏Ôßπ‰ªçÂâ©Â≠ïËäø‰ªîÂà∫Âí®ÂßâÂßøÂ≠êÂ≠óÂ≠úÊÅ£ÊÖàÊªãÁÇôÁÖÆÁéÜÁì∑ÁñµÁ£ÅÁ¥´ËÄÖËá™Ëå®ËîóËóâË´ÆË≥áÈõå‰ΩúÂã∫ÂöºÊñ´Êò®ÁÅºÁÇ∏ÁàµÁ∂ΩËäçÈÖåÈõÄÈµ≤Â≠±Ê£ßÊÆòÊΩ∫ÁõûÂ≤ëÊö´ÊΩõÁÆ¥Á∞™Ë†∂Èõú‰∏à‰ªóÂå†Â†¥Â¢ªÂ£ØÂ•¨Â∞áÂ∏≥Â∫ÑÂºµÊéåÊö≤ÊùñÊ®üÊ™£Ê¨åÊºøÁâÜÔß∫ÁçêÁíãÁ´†Á≤ßËÖ∏ËáüËáßËéäËë¨Ëî£ËñîËóèË£ùË¥ìÈÜ¨Èï∑"],["eea1","ÈöúÂÜçÂìâÂú®ÂÆ∞ÊâçÊùêÊ†ΩÊ¢ìÊ∏ΩÊªìÁÅΩÁ∏°Ë£ÅË≤°ËºâÈΩãÈΩéÁà≠ÁÆèË´çÈåö‰Ωá‰ΩéÂÑ≤ÂíÄÂßêÂ∫ïÊäµÊùµÊ•ÆÊ®óÊ≤ÆÊ∏öÁãôÁå™ÁñΩÁÆ∏Á¥µËãßËèπËëóËó∑Ë©õË≤ØË∫áÈÄôÈÇ∏ÈõéÈΩüÂã£ÂêäÂ´°ÂØÇÊëòÊïµÊª¥ÁãÑÔßªÁöÑÁ©çÁ¨õÁ±çÁ∏æÁøüËçªË¨´Ë≥äËµ§Ë∑°ËπüËø™ËøπÈÅ©Èèë‰ΩÉ‰Ω∫ÂÇ≥ÂÖ®ÂÖ∏ÂâçÂâ™Â°°Â°ºÂ•†Â∞àÂ±ïÂªõÊÇõÊà∞Ê†ìÊÆøÊ∞àÊæ±"],["efa1","ÁÖéÁê†Áî∞Áî∏ÁïëÁô≤Á≠åÁÆãÁÆ≠ÁØÜÁ∫èË©ÆËºæËΩâÈàøÈäìÈå¢Èê´ÈõªÈ°öÈ°´È§ûÂàáÊà™ÊäòÊµôÁô§Á´äÁØÄÁµ∂Âç†Â≤æÂ∫óÊº∏ÁÇπÁ≤òÈúëÈÆéÈªûÊé•Êë∫Ëù∂‰∏Å‰∫ï‰∫≠ÂÅúÂÅµÂëàÂßÉÂÆöÂπÄÂ∫≠Âª∑ÂæÅÊÉÖÊå∫ÊîøÊï¥ÊóåÊô∂Êô∏ÊüæÊ•®Ê™âÊ≠£Ê±ÄÊ∑ÄÊ∑®Ê∏üÊπûÁÄûÁÇ°ÁééÁèΩÁî∫ÁùõÁ¢áÁ¶éÁ®ãÁ©ΩÁ≤æÁ∂éËâáË®ÇË´™Ë≤ûÈÑ≠ÈÖäÈáòÈâ¶ÈãåÈå†ÈúÜÈùñ"],["f0a1","ÈùúÈ†ÇÈºéÂà∂ÂäëÂïºÂ†§Â∏ùÂºüÊÇåÊèêÊ¢ØÊøüÁ•≠Á¨¨ËáçËñ∫Ë£ΩË´∏ËπÑÈÜçÈô§ÈöõÈúΩÈ°åÈΩä‰øéÂÖÜÂáãÂä©Âò≤ÂºîÂΩ´Êé™ÊìçÊó©ÊôÅÊõ∫ÊõπÊúùÊ¢ùÊ£óÊßΩÊºïÊΩÆÁÖßÁá•Áà™Áí™Áú∫Á•ñÁ•öÁßüÁ®†Á™ïÁ≤óÁ≥üÁµÑÁπ∞ËÇáËóªËö§Ë©îË™øË∂ôË∫ÅÈÄ†ÈÅ≠Èá£ÈòªÈõïÈ≥•ÊóèÁ∞áË∂≥ÈèÉÂ≠òÂ∞äÂçíÊãôÁåùÂÄßÂÆóÂæûÊÇ∞ÊÖ´Ê£ïÊ∑ôÁêÆÁ®ÆÁµÇÁ∂úÁ∏±ËÖ´"],["f1a1","Ë∏™Ë∏µÈçæÈêò‰ΩêÂùêÂ∑¶Â∫ßÊå´ÁΩ™‰∏ª‰Ωè‰æèÂÅöÂßùËÉÑÂë™Âë®ÂóæÂ•èÂÆôÂ∑ûÂªöÊôùÊú±Êü±Ê†™Ê≥®Ê¥≤ÊπäÊæçÁÇ∑Áè†ÁñáÁ±åÁ¥ÇÁ¥¨Á∂¢ËàüËõõË®ªË™ÖËµ∞Ë∫äËº≥ÈÄ±ÈÖéÈÖíÈëÑÈßêÁ´πÁ≤•‰øäÂÑÅÂáÜÂüàÂØØÂ≥ªÊôôÊ®ΩÊµöÊ∫ñÊø¨ÁÑåÁïØÁ´£Ë†¢ÈÄ°ÈÅµÈõãÈßøËåÅ‰∏≠‰ª≤Ë°ÜÈáçÂçΩÊ´õÊ•´Ê±ÅËë∫Â¢ûÊÜéÊõæÊãØÁÉùÁîëÁóáÁπíËí∏Ë≠âË¥à‰πãÂè™"],["f2a1","Âí´Âú∞ÂùÄÂøóÊåÅÊåáÊëØÊîØÊó®Êô∫ÊûùÊû≥Ê≠¢Ê±†Ê≤öÊº¨Áü•Á†•Á•âÁ•óÁ¥ôËÇ¢ËÑÇËá≥ËäùËä∑ËúòË™åÔßºË¥ÑË∂æÈÅ≤Áõ¥Á®ôÁ®∑ÁπîËÅ∑ÂîáÂóîÂ°µÊåØÊê¢ÊôâÊôãÊ°≠Ê¶õÊÆÑÊ¥•Ê∫±ÁèçÁë®Áí°ÁïõÁñπÁõ°ÁúûÁûãÁß¶Á∏âÁ∏ùËáªËîØË¢óË®∫Ë≥ëËª´Ëæ∞ÈÄ≤Èé≠Èô£Èô≥Èúá‰æÑÂè±Âß™Â´âÂ∏ôÊ°éÁìÜÁñæÁß©Á™íËÜ£Ëõ≠Ë≥™Ë∑åËø≠ÊñüÊúïÔßΩÂü∑ÊΩóÁ∑ùËºØ"],["f3a1","Èè∂ÈõÜÂæµÊá≤ÊæÑ‰∏î‰æòÂÄüÂèâÂóüÂµØÂ∑ÆÊ¨°Ê≠§Á£ãÁÆöÔßæËπâËªäÈÅÆÊçâÊêæÁùÄÁ™ÑÈåØÈëøÈΩ™Êí∞ÊæØÁá¶Áí®ÁìöÁ´ÑÁ∞íÁ∫ÇÁ≤≤Á∫òËÆöË¥äÈëΩÈ§êÈ•åÂàπÂØüÊì¶Êú≠Á¥ÆÂÉ≠ÂèÉÂ°πÊÖòÊÖôÊá∫Êñ¨Á´ôËÆíËÆñÂÄâÂÄ°ÂâµÂî±Â®ºÂª†ÂΩ∞ÊÑ¥ÊïûÊòåÊò∂Êö¢ÊßçÊªÑÊº≤ÁåñÁò°Á™ìËÑπËâôËèñËíºÂÇµÂü∞ÂØÄÂØ®ÂΩ©Êé°Á†¶Á∂µËèúËî°ÈááÈáµÂÜäÊüµÁ≠ñ"],["f4a1","Ë≤¨ÂáÑÂ¶ªÊÇΩËôïÂÄúÔßøÂâîÂ∞∫ÊÖΩÊàöÊãìÊì≤Êñ•ÊªåÁò†ËÑäËπ†ÈôüÈöª‰ªüÂçÉÂñòÂ§©Â∑ùÊìÖÊ≥âÊ∑∫ÁéîÁ©øËàõËñ¶Ë≥§Ë∏êÈÅ∑ÈáßÈó°Èò°ÈüÜÂá∏Âì≤ÂñÜÂæπÊí§ÊæàÁ∂¥ËºüËΩçÈêµÂÉâÂ∞ñÊ≤æÊ∑ªÁîõÁûªÁ∞ΩÁ±§Ë©πË´ÇÂ†ûÂ¶æÂ∏ñÊç∑ÁâíÁñäÁù´Ë´úË≤ºËºíÂª≥Êô¥Ê∑∏ËÅΩËèÅË´ãÈùëÈØñÔ®ÄÂâÉÊõøÊ∂ïÊªØÁ∑†Ë´¶ÈÄÆÈÅûÈ´îÂàùÂâøÂì®ÊÜîÊäÑÊãõÊ¢¢"],["f5a1","Ê§íÊ•öÊ®µÁÇíÁÑ¶Á°ùÁ§ÅÁ§éÁßíÁ®çËÇñËâ∏ËãïËçâËïâË≤ÇË∂ÖÈÖ¢ÈÜãÈÜÆ‰øÉÂõëÁá≠ÁüóËúÄËß∏ÂØ∏ÂøñÊùëÈÇ®Âè¢Â°öÂØµÊÇ§ÊÜÅÊë†Á∏ΩËÅ∞Ëî•ÈäÉÊíÆÂÇ¨Â¥îÊúÄÂ¢úÊäΩÊé®Ê§éÊ•∏Ê®ûÊπ´Áö∫ÁßãËäªËê©Ë´èË∂®ËøΩÈÑíÈÖãÈÜúÈåêÈåòÈéöÈõõÈ®∂È∞ç‰∏ëÁïúÁ•ùÁ´∫Á≠ëÁØâÁ∏ÆËìÑËπôËπ¥Ëª∏ÈÄêÊò•Ê§øÁëÉÂá∫ÊúÆÈªúÂÖÖÂø†Ê≤ñËü≤Ë°ùË°∑ÊÇ¥ËÜµËêÉ"],["f6a1","Ë¥ÖÂèñÂêπÂò¥Â®∂Â∞±ÁÇäÁø†ËÅöËÑÜËá≠Ë∂£ÈÜâÈ©üÈ∑≤ÂÅ¥‰ªÑÂé†ÊÉªÊ∏¨Â±§‰æàÂÄ§Âó§Â≥ôÂπüÊÅ•Ê¢îÊ≤ªÊ∑ÑÁÜæÁóîÁó¥Áô°Á®öÁ©âÁ∑áÁ∑ªÁΩÆËá¥Ëö©ËºúÈõâÈ¶≥ÈΩíÂâáÂãÖÈ£≠Ë¶™‰∏ÉÊüíÊºÜ‰æµÂØ¢ÊûïÊ≤àÊµ∏ÁêõÁ†ßÈáùÈçºËüÑÁß§Á®±Âø´‰ªñÂí§ÂîæÂ¢ÆÂ¶•ÊÉ∞ÊâìÊãñÊú∂Ê•ïËàµÈôÄÈ¶±ÈßùÂÄ¨ÂçìÂïÑÂùºÔ®ÅÊâòÔ®ÇÊì¢Êô´ÊüùÊøÅÊøØÁê¢Áê∏Ë®ó"],["f7a1","Èê∏ÂëëÂòÜÂù¶ÂΩàÊÜöÊ≠éÁÅòÁÇ≠Á∂ªË™ïÂ•™ËÑ´Êé¢ÁúàËÄΩË≤™Â°îÊê≠Ê¶ªÂÆïÂ∏ëÊπØÔ®ÉËï©ÂÖåÂè∞Â§™ÊÄ†ÊÖãÊÆÜÊ±∞Ê≥∞Á¨ûËÉéËãîË∑ÜÈÇ∞È¢±Ô®ÑÊìáÊæ§ÊíëÊîÑÂÖéÂêêÂúüË®éÊÖüÊ°∂Ô®ÖÁóõÁ≠íÁµ±ÈÄöÂ†ÜÊßåËÖøË§™ÈÄÄÈ†πÂÅ∏Â•óÂ¶¨ÊäïÈÄèÈ¨™ÊÖùÁâπÈóñÂù°Â©ÜÂ∑¥ÊääÊí≠Êì∫Êù∑Ê≥¢Ê¥æÁà¨Áê∂Á†¥ÁΩ∑Ëä≠Ë∑õÈ†óÂà§ÂùÇÊùøÁâàÁì£Ë≤©Ëæ¶Èàë"],["f8a1","Èò™ÂÖ´Âè≠Êçå‰Ω©ÂîÑÊÇñÊïóÊ≤õÊµøÁâåÁãΩÁ®óË¶áË≤ùÂΩ≠ÊæéÁÉπËÜ®ÊÑé‰æøÂÅèÊâÅÁâáÁØáÁ∑®Áø©ÈÅçÈû≠È®ôË≤∂Âù™Âπ≥Êû∞ËêçË©ïÂê†Â¨ñÂπ£Âª¢ÂºäÊñÉËÇ∫ËîΩÈñâÈôõ‰ΩàÂåÖÂåçÂåèÂíÜÂì∫ÂúÉÂ∏ÉÊÄñÊäõÊä±ÊçïÔ®ÜÊ≥°Êµ¶Áñ±Á†≤ËÉûËÑØËãûËë°Ëí≤Ë¢çË§íÈÄãÈã™È£ΩÈÆëÂπÖÊö¥ÊõùÁÄëÁàÜÔ®á‰øµÂâΩÂΩ™ÊÖìÊùìÊ®ôÊºÇÁì¢Á•®Ë°®Ë±πÈ£áÈ£ÑÈ©É"],["f9a1","ÂìÅÁ®üÊ•ìË´∑Ë±äÈ¢®È¶ÆÂΩºÊä´Áñ≤ÁöÆË¢´ÈÅøÈôÇÂåπÂººÂøÖÊ≥åÁèåÁï¢ÁñãÁ≠ÜËãæÈ¶ù‰πèÈÄº‰∏ã‰ΩïÂé¶Â§èÂªàÊò∞Ê≤≥ÁëïËç∑Ëù¶Ë≥ÄÈÅêÈúûÈ∞ïÂ£ëÂ≠∏ËôêË¨îÈ∂¥ÂØíÊÅ®ÊÇçÊó±Ê±óÊº¢Êæ£ÁÄöÁΩïÁø∞ÈñëÈñíÈôêÈüìÂâ≤ËΩÑÂáΩÂê´Âí∏Âï£ÂñäÊ™ªÊ∂µÁ∑òËâ¶ÈäúÈô∑ÈππÂêàÂìàÁõíËõ§Èñ§ÈóîÈôú‰∫¢‰ºâÂßÆÂ´¶Â∑∑ÊÅíÊäóÊù≠Ê°ÅÊ≤ÜÊ∏ØÁº∏ËÇõËà™"],["faa1","Ô®àÔ®âÈ†Ö‰∫•ÂÅïÂí≥ÂûìÂ•öÂ≠©ÂÆ≥ÊáàÊ•∑Êµ∑ÁÄ£ËüπËß£Ë©≤Ë´ßÈÇÇÈß≠È™∏ÂäæÊ†∏ÂÄñÂπ∏ÊùèËçáË°å‰∫´ÂêëÂöÆÁè¶ÈÑïÈüøÈ§âÈ•óÈ¶ôÂôìÂ¢üËôõË®±ÊÜ≤Ê´∂ÁçªËªíÊ≠áÈö™È©óÂ•ïÁàÄËµ´Èù©‰øîÂ≥¥Âº¶Êá∏ÊôõÊ≥´ÁÇ´ÁéÑÁéπÁèæÁú©ÁùçÁµÉÁµ¢Á∏£Ëà∑Ë°íÔ®äË≥¢ÈââÈ°ØÂ≠ëÁ©¥Ë°ÄÈ†ÅÂ´å‰ø†ÂçîÂ§æÂ≥ΩÊåæÊµπÁãπËÑÖËÑáËé¢ÈãèÈ†∞‰∫®ÂÖÑÂàëÂûã"],["fba1","ÂΩ¢Ê≥ÇÊªéÁÄÖÁÅêÁÇØÁÜíÁè©Áë©ËçäËû¢Ë°°ÈÄàÈÇ¢Èé£È¶®ÂÖÆÂΩóÊÉ†ÊÖßÊö≥ËïôËπäÈÜØÈûã‰πé‰∫íÂëºÂ£ïÂ£∫Â•ΩÂ≤µÂºßÊà∂ÊâàÊòäÊôßÊØ´Êµ©Ê∑èÊπñÊª∏ÊæîÊø†Êø©ÁÅùÁãêÁê•ÁëöÁì†ÁöìÁ•úÁ≥äÁ∏ûËÉ°Ëä¶Ëë´ËíøËôéËôüËù¥Ë≠∑Ë±™Èé¨È†ÄÈ°•ÊÉëÊàñÈÖ∑Â©öÊòèÊ∑∑Ê∏æÁêøÈ≠ÇÂøΩÊÉöÁ¨èÂìÑÂºòÊ±ûÊ≥ìÊ¥™ÁÉòÁ¥ÖËôπË®åÈ¥ªÂåñÂíåÂ¨ÖÊ®∫ÁÅ´Áïµ"],["fca1","Á¶çÁ¶æËä±ËèØË©±Ë≠ÅË≤®Èù¥Ô®ãÊì¥Êî´Á¢∫Á¢ªÁ©´‰∏∏ÂñöÂ•êÂÆ¶ÂπªÊÇ£ÊèõÊ≠°Êô•Ê°ìÊ∏ôÁÖ•Áí∞Á¥àÈÇÑÈ©©È∞•Ê¥ªÊªëÁåæË±ÅÈóäÂá∞ÂπåÂæ®ÊÅçÊÉ∂ÊÑ∞ÊÖåÊôÉÊôÑÊ¶•Ê≥ÅÊπüÊªâÊΩ¢ÁÖåÁíúÁöáÁØÅÁ∞ßËçíËùóÈÅëÈöçÈªÉÂåØÂõûÂªªÂæäÊÅ¢ÊÇîÊá∑Êô¶ÊúÉÊ™úÊ∑ÆÊæÆÁÅ∞Áç™Áπ™ËÜæËå¥ËõîË™®Ë≥ÑÂäÉÁç≤ÂÆñÊ©´ÈêÑÂìÆÂöÜÂ≠ùÊïàÊñÖÊõâÊ¢üÊ∂çÊ∑Ü"],["fda1","ÁàªËÇ¥ÈÖµÈ©ç‰æØÂÄôÂéöÂêéÂêºÂñâÂóÖÂ∏øÂæåÊúΩÁÖ¶ÁèùÈÄÖÂãõÂã≥Â°§Â£éÁÑÑÁÜèÁáªËñ∞Ë®ìÊöàËñ®ÂñßÊöÑÁÖäËê±ÂçâÂñôÊØÅÂΩôÂæΩÊèÆÊöâÁÖáË´±ËºùÈ∫æ‰ºëÊê∫ÁÉãÁï¶ËôßÊÅ§Ë≠éÈ∑∏ÂÖáÂá∂ÂåàÊ¥∂ËÉ∏ÈªëÊòïÊ¨£ÁÇòÁóïÂêÉÂ±πÁ¥áË®ñÊ¨†Ê¨ΩÊ≠ÜÂê∏ÊÅ∞Ê¥ΩÁøïËààÂÉñÂáûÂñúÂô´ÂõçÂß¨Â¨âÂ∏åÊÜôÊÜòÊà±ÊôûÊõ¶ÁÜôÁÜπÁÜ∫ÁäßÁ¶ßÁ®ÄÁæ≤Ë©∞"]]');

/***/ }),

/***/ 61604:
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('[["0","\\u0000",127],["a140","„ÄÄÔºå„ÄÅ„ÄÇÔºé‚ÄßÔºõÔºöÔºüÔºÅÔ∏∞‚Ä¶‚Ä•ÔπêÔπëÔπí¬∑ÔπîÔπïÔπñÔπóÔΩú‚ÄìÔ∏±‚ÄîÔ∏≥‚ï¥Ô∏¥ÔπèÔºàÔºâÔ∏µÔ∏∂ÔΩõÔΩùÔ∏∑Ô∏∏„Äî„ÄïÔ∏πÔ∏∫„Äê„ÄëÔ∏ªÔ∏º„Ää„ÄãÔ∏ΩÔ∏æ„Äà„ÄâÔ∏øÔπÄ„Äå„ÄçÔπÅÔπÇ„Äé„ÄèÔπÉÔπÑÔπôÔπö"],["a1a1","ÔπõÔπúÔπùÔπû‚Äò‚Äô‚Äú‚Äù„Äù„Äû‚Äµ‚Ä≤ÔºÉÔºÜÔºä‚Äª¬ß„ÄÉ‚óã‚óè‚ñ≥‚ñ≤‚óé‚òÜ‚òÖ‚óá‚óÜ‚ñ°‚ñ†‚ñΩ‚ñº„ä£‚ÑÖ¬ØÔø£ÔºøÀçÔπâÔπäÔπçÔπéÔπãÔπåÔπüÔπ†Ôπ°ÔºãÔºç√ó√∑¬±‚àöÔºúÔºûÔºù‚â¶‚âß‚â†‚àû‚âí‚â°Ôπ¢",4,"ÔΩû‚à©‚à™‚ä•‚à†‚àü‚äø„èí„èë‚à´‚àÆ‚àµ‚à¥‚ôÄ‚ôÇ‚äï‚äô‚Üë‚Üì‚Üê‚Üí‚Üñ‚Üó‚Üô‚Üò‚à•‚à£Ôºè"],["a240","Ôºº‚àïÔπ®ÔºÑÔø•„ÄíÔø†Ôø°ÔºÖÔº†‚ÑÉ‚ÑâÔπ©Ôπ™Ôπ´„èï„éú„éù„éû„èé„é°„éé„éè„èÑ¬∞ÂÖôÂÖõÂÖûÂÖùÂÖ°ÂÖ£ÂóßÁì©Á≥é‚ñÅ",7,"‚ñè‚ñé‚ñç‚ñå‚ñã‚ñä‚ñâ‚îº‚î¥‚î¨‚î§‚îú‚ñî‚îÄ‚îÇ‚ñï‚îå‚îê‚îî‚îò‚ï≠"],["a2a1","‚ïÆ‚ï∞‚ïØ‚ïê‚ïû‚ï™‚ï°‚ó¢‚ó£‚ó•‚ó§‚ï±‚ï≤‚ï≥Ôºê",9,"‚Ö†",9,"„Ä°",8,"ÂçÅÂçÑÂçÖÔº°",25,"ÔΩÅ",21],["a340","ÔΩóÔΩòÔΩôÔΩöŒë",16,"Œ£",6,"Œ±",16,"œÉ",6,"„ÑÖ",10],["a3a1","„Ñê",25,"ÀôÀâÀäÀáÀã"],["a3e1","‚Ç¨"],["a440","‰∏Ä‰πô‰∏Å‰∏É‰πÉ‰πù‰∫Ü‰∫å‰∫∫ÂÑøÂÖ•ÂÖ´Âá†ÂàÄÂàÅÂäõÂåïÂçÅÂçúÂèà‰∏â‰∏ã‰∏à‰∏ä‰∏´‰∏∏Âá°‰πÖ‰πà‰πü‰πû‰∫é‰∫°ÂÖÄÂàÉÂã∫ÂçÉÂèâÂè£ÂúüÂ£´Â§ïÂ§ßÂ•≥Â≠êÂ≠ëÂ≠ìÂØ∏Â∞èÂ∞¢Â∞∏Â±±Â∑ùÂ∑•Â∑±Â∑≤Â∑≥Â∑æÂπ≤ÂªæÂºãÂºìÊâç"],["a4a1","‰∏ë‰∏ê‰∏ç‰∏≠‰∏∞‰∏π‰πãÂ∞π‰∫à‰∫ë‰∫ï‰∫í‰∫î‰∫¢‰ªÅ‰ªÄ‰ªÉ‰ªÜ‰ªá‰ªç‰ªä‰ªã‰ªÑÂÖÉÂÖÅÂÖßÂÖ≠ÂÖÆÂÖ¨ÂÜóÂá∂ÂàÜÂàáÂààÂãªÂãæÂãøÂåñÂåπÂçàÂçáÂçÖÂçûÂéÑÂèãÂèäÂèçÂ£¨Â§©Â§´Â§™Â§≠Â≠îÂ∞ëÂ∞§Â∞∫Â±ØÂ∑¥ÂπªÂªøÂºîÂºïÂøÉÊààÊà∂ÊâãÊâéÊîØÊñáÊñóÊñ§ÊñπÊó•Êõ∞ÊúàÊú®Ê¨†Ê≠¢Ê≠πÊØãÊØîÊØõÊ∞èÊ∞¥ÁÅ´Áà™Áà∂ÁàªÁâáÁâôÁâõÁä¨Áéã‰∏ô"],["a540","‰∏ñ‰∏ï‰∏î‰∏ò‰∏ª‰πç‰πè‰πé‰ª•‰ªò‰ªî‰ªï‰ªñ‰ªó‰ª£‰ª§‰ªô‰ªûÂÖÖÂÖÑÂÜâÂÜäÂÜ¨ÂáπÂá∫Âá∏ÂàäÂä†ÂäüÂåÖÂåÜÂåóÂåù‰ªüÂçäÂçâÂç°Âç†ÂçØÂçÆÂéªÂèØÂè§Âè≥Âè¨ÂèÆÂè©Âè®ÂèºÂè∏ÂèµÂè´Âè¶Âè™Âè≤Âè±Âè∞Âè•Âè≠ÂèªÂõõÂõöÂ§ñ"],["a5a1","Â§ÆÂ§±Â•¥Â•∂Â≠ïÂÆÉÂ∞ºÂ∑®Â∑ßÂ∑¶Â∏ÇÂ∏ÉÂπ≥ÂπºÂºÅÂºòÂºóÂøÖÊàäÊâìÊâîÊâíÊâëÊñ•Êó¶ÊúÆÊú¨Êú™Êú´Êú≠Ê≠£ÊØçÊ∞ëÊ∞êÊ∞∏Ê±ÅÊ±ÄÊ∞æÁäØÁéÑÁéâÁìúÁì¶ÁîòÁîüÁî®Áî©Áî∞Áî±Áî≤Áî≥ÁñãÁôΩÁöÆÁöøÁõÆÁüõÁü¢Áü≥Á§∫Á¶æÁ©¥Á´ã‰∏û‰∏ü‰πí‰πì‰π©‰∫ô‰∫§‰∫¶‰∫•‰ªø‰ºâ‰ºô‰ºä‰ºï‰ºç‰ºê‰ºë‰ºè‰ª≤‰ª∂‰ªª‰ª∞‰ª≥‰ªΩ‰ºÅ‰ºãÂÖâÂÖáÂÖÜÂÖàÂÖ®"],["a640","ÂÖ±ÂÜçÂÜ∞ÂàóÂàëÂàíÂàéÂàñÂä£ÂåàÂå°Âå†Âç∞Âç±ÂêâÂêèÂêåÂêäÂêêÂêÅÂêãÂêÑÂêëÂêçÂêàÂêÉÂêéÂêÜÂêíÂõ†ÂõûÂõùÂú≥Âú∞Âú®Âú≠Âú¨ÂúØÂú©Â§ôÂ§öÂ§∑Â§∏Â¶ÑÂ•∏Â¶ÉÂ•ΩÂ•πÂ¶ÇÂ¶ÅÂ≠óÂ≠òÂÆáÂÆàÂÆÖÂÆâÂØ∫Â∞ñÂ±πÂ∑ûÂ∏ÜÂπ∂Âπ¥"],["a6a1","ÂºèÂºõÂøôÂøñÊàéÊàåÊàçÊàêÊâ£ÊâõÊâòÊî∂Êó©Êó®Êó¨Êó≠Êõ≤Êõ≥ÊúâÊúΩÊú¥Êú±ÊúµÊ¨°Ê≠§Ê≠ªÊ∞ñÊ±ùÊ±óÊ±ôÊ±üÊ±†Ê±êÊ±ïÊ±°Ê±õÊ±çÊ±éÁÅ∞ÁâüÁâùÁôæÁ´πÁ±≥Á≥∏Áº∂ÁæäÁæΩËÄÅËÄÉËÄåËÄíËÄ≥ËÅøËÇâËÇãËÇåËá£Ëá™Ëá≥ËáºËàåËàõËàüËâÆËâ≤ËâæËô´Ë°ÄË°åË°£Ë•øÈò°‰∏≤‰∫®‰Ωç‰Ωè‰Ωá‰Ωó‰Ωû‰º¥‰Ωõ‰Ωï‰º∞‰Ωê‰Ωë‰ºΩ‰º∫‰º∏‰ΩÉ‰Ωî‰ºº‰ΩÜ‰Ω£"],["a740","‰Ωú‰Ω†‰ºØ‰Ωé‰º∂‰Ωô‰Ωù‰Ωà‰ΩöÂÖåÂÖãÂÖçÂÖµÂÜ∂ÂÜ∑Âà•Âà§Âà©Âà™Âà®Âä´Âä©Âä™Âä¨Âå£Âç≥ÂçµÂêùÂê≠ÂêûÂêæÂê¶ÂëéÂêßÂëÜÂëÉÂê≥ÂëàÂëÇÂêõÂê©ÂëäÂêπÂêªÂê∏ÂêÆÂêµÂê∂Âê†ÂêºÂëÄÂê±Âê´ÂêüÂê¨Âõ™Âõ∞Âõ§Âõ´ÂùäÂùëÂùÄÂùç"],["a7a1","ÂùáÂùéÂúæÂùêÂùèÂúªÂ£ØÂ§æÂ¶ùÂ¶íÂ¶®Â¶ûÂ¶£Â¶ôÂ¶ñÂ¶çÂ¶§Â¶ìÂ¶äÂ¶•Â≠ùÂ≠úÂ≠öÂ≠õÂÆåÂÆãÂÆèÂ∞¨Â±ÄÂ±ÅÂ∞øÂ∞æÂ≤êÂ≤ëÂ≤îÂ≤åÂ∑´Â∏åÂ∫èÂ∫áÂ∫äÂª∑ÂºÑÂºüÂΩ§ÂΩ¢ÂΩ∑ÂΩπÂøòÂøåÂøóÂøçÂø±Âø´Âø∏Âø™ÊàíÊàëÊäÑÊäóÊäñÊäÄÊâ∂ÊäâÊâ≠ÊääÊâºÊâæÊâπÊâ≥ÊäíÊâØÊäòÊâÆÊäïÊäìÊäëÊäÜÊîπÊîªÊî∏Êó±Êõ¥ÊùüÊùéÊùèÊùêÊùëÊùúÊùñÊùûÊùâÊùÜÊù†"],["a840","ÊùìÊùóÊ≠•ÊØèÊ±ÇÊ±ûÊ≤ôÊ≤ÅÊ≤àÊ≤âÊ≤ÖÊ≤õÊ±™Ê±∫Ê≤êÊ±∞Ê≤åÊ±®Ê≤ñÊ≤íÊ±ΩÊ≤ÉÊ±≤Ê±æÊ±¥Ê≤ÜÊ±∂Ê≤çÊ≤îÊ≤òÊ≤ÇÁÅ∂ÁÅºÁÅΩÁÅ∏Áâ¢Áâ°Áâ†ÁãÑÁãÇÁéñÁî¨Áî´Áî∑Áî∏ÁöÇÁõØÁü£ÁßÅÁßÄÁ¶øÁ©∂Á≥ªÁΩïËÇñËÇìËÇùËÇòËÇõËÇöËÇ≤ËâØËäí"],["a8a1","ËäãËäçË¶ãËßíË®ÄË∞∑Ë±ÜË±ïË≤ùËµ§Ëµ∞Ë∂≥Ë∫´ËªäËæõËæ∞ËøÇËøÜËøÖËøÑÂ∑°ÈÇëÈÇ¢ÈÇ™ÈÇ¶ÈÇ£ÈÖâÈáÜÈáåÈò≤ÈòÆÈò±Èò™Èò¨‰∏¶‰πñ‰π≥‰∫ã‰∫õ‰∫û‰∫´‰∫¨‰ΩØ‰æù‰æç‰Ω≥‰Ωø‰Ω¨‰æõ‰æã‰æÜ‰æÉ‰Ω∞‰Ωµ‰æà‰Ω©‰Ωª‰æñ‰Ωæ‰æè‰æë‰Ω∫ÂÖîÂÖíÂÖïÂÖ©ÂÖ∑ÂÖ∂ÂÖ∏ÂÜΩÂáΩÂàªÂà∏Âà∑Âà∫Âà∞ÂàÆÂà∂ÂâÅÂäæÂäªÂçíÂçîÂçìÂçëÂç¶Âç∑Âç∏ÂçπÂèñÂèîÂèóÂë≥Âëµ"],["a940","ÂíñÂë∏ÂíïÂíÄÂëªÂë∑ÂíÑÂííÂíÜÂëºÂíêÂë±Âë∂ÂíåÂíöÂë¢Âë®ÂíãÂëΩÂíéÂõ∫ÂûÉÂù∑Âù™Âù©Âù°Âù¶Âù§ÂùºÂ§úÂ•âÂ•áÂ•àÂ•ÑÂ•îÂ¶æÂ¶ªÂßîÂ¶πÂ¶ÆÂßëÂßÜÂßêÂßçÂßãÂßìÂßäÂ¶ØÂ¶≥ÂßíÂßÖÂ≠üÂ≠§Â≠£ÂÆóÂÆöÂÆòÂÆúÂÆôÂÆõÂ∞öÂ±àÂ±Ö"],["a9a1","Â±ÜÂ≤∑Â≤°Â≤∏Â≤©Â≤´Â≤±Â≤≥Â∏òÂ∏öÂ∏ñÂ∏ïÂ∏õÂ∏ëÂπ∏Â∫öÂ∫óÂ∫úÂ∫ïÂ∫ñÂª∂Âº¶ÂºßÂº©ÂæÄÂæÅÂΩøÂΩºÂøùÂø†ÂøΩÂøµÂøøÊÄèÊÄîÊÄØÊÄµÊÄñÊÄ™ÊÄïÊÄ°ÊÄßÊÄ©ÊÄ´ÊÄõÊàñÊàïÊàøÊàæÊâÄÊâøÊãâÊãåÊãÑÊäøÊãÇÊäπÊãíÊãõÊä´ÊãìÊãîÊããÊãàÊä®ÊäΩÊäºÊãêÊãôÊãáÊãçÊäµÊãöÊä±ÊãòÊãñÊãóÊãÜÊä¨ÊãéÊîæÊñßÊñºÊó∫ÊòîÊòìÊòåÊòÜÊòÇÊòéÊòÄÊòèÊòïÊòä"],["aa40","ÊòáÊúçÊúãÊù≠ÊûãÊûïÊù±ÊûúÊù≥Êù∑ÊûáÊûùÊûóÊùØÊù∞ÊùøÊûâÊùæÊûêÊùµÊûöÊûìÊùºÊù™Êù≤Ê¨£Ê≠¶Ê≠ßÊ≠øÊ∞ìÊ∞õÊ≥£Ê≥®Ê≥≥Ê≤±Ê≥åÊ≥•Ê≤≥Ê≤ΩÊ≤æÊ≤ºÊ≥¢Ê≤´Ê≥ïÊ≥ìÊ≤∏Ê≥ÑÊ≤πÊ≥ÅÊ≤ÆÊ≥óÊ≥ÖÊ≥±Ê≤øÊ≤ªÊ≥°Ê≥õÊ≥äÊ≤¨Ê≥ØÊ≥úÊ≥ñÊ≥†"],["aaa1","ÁÇïÁÇéÁÇíÁÇäÁÇôÁà¨Áà≠Áà∏ÁâàÁâßÁâ©ÁãÄÁãéÁãôÁãóÁãêÁé©Áé®ÁéüÁé´Áé•ÁîΩÁñùÁñôÁñöÁöÑÁõÇÁõ≤Áõ¥Áü•ÁüΩÁ§æÁ•ÄÁ•ÅÁßâÁßàÁ©∫Á©πÁ´∫Á≥æÁΩîÁæåÁæãËÄÖËÇ∫ËÇ•ËÇ¢ËÇ±ËÇ°ËÇ´ËÇ©ËÇ¥ËÇ™ËÇØËá•ËáæËàçËä≥ËäùËäôËä≠ËäΩËäüËäπËä±Ëä¨Ëä•ËäØËä∏Ëä£Ëä∞ËäæËä∑ËôéËô±ÂàùË°®ËªãËøéËøîËøëÈÇµÈÇ∏ÈÇ±ÈÇ∂ÈááÈáëÈï∑ÈñÄÈòúÈôÄÈòøÈòªÈôÑ"],["ab40","ÈôÇÈöπÈõ®ÈùíÈùû‰∫ü‰∫≠‰∫Æ‰ø°‰æµ‰æØ‰æø‰ø†‰øë‰øè‰øù‰øÉ‰æ∂‰øò‰øü‰øä‰øó‰æÆ‰øê‰øÑ‰øÇ‰øö‰øé‰øû‰æ∑ÂÖóÂÜíÂÜëÂÜ†ÂâéÂâÉÂâäÂâçÂâåÂâãÂâáÂãáÂãâÂãÉÂãÅÂåçÂçóÂçªÂéöÂèõÂí¨ÂìÄÂí®ÂìéÂìâÂí∏Âí¶Âí≥ÂìáÂìÇÂíΩÂí™ÂìÅ"],["aba1","ÂìÑÂìàÂíØÂí´Âí±ÂíªÂí©ÂíßÂíøÂõøÂûÇÂûãÂû†Âû£Âû¢ÂüéÂûÆÂûìÂ•ïÂ•ëÂ•èÂ•éÂ•êÂßúÂßòÂßøÂß£Âß®Â®ÉÂß•Âß™ÂßöÂß¶Â®ÅÂßªÂ≠©ÂÆ£ÂÆ¶ÂÆ§ÂÆ¢ÂÆ•Â∞ÅÂ±éÂ±èÂ±çÂ±ãÂ≥ôÂ≥íÂ∑∑Â∏ùÂ∏•Â∏üÂπΩÂ∫†Â∫¶Âª∫ÂºàÂº≠ÂΩ•ÂæàÂæÖÂæäÂæãÂæáÂæåÂæâÊÄíÊÄùÊÄ†ÊÄ•ÊÄéÊÄ®ÊÅçÊÅ∞ÊÅ®ÊÅ¢ÊÅÜÊÅÉÊÅ¨ÊÅ´ÊÅ™ÊÅ§ÊâÅÊãúÊåñÊåâÊãºÊã≠ÊåÅÊãÆÊãΩÊåáÊã±Êã∑"],["ac40","ÊãØÊã¨ÊãæÊã¥ÊåëÊåÇÊîøÊïÖÊñ´ÊñΩÊó¢Êò•Êò≠Êò†ÊòßÊòØÊòüÊò®Êò±Êò§Êõ∑ÊüøÊüìÊü±ÊüîÊüêÊü¨Êû∂ÊûØÊüµÊü©ÊüØÊüÑÊüëÊû¥ÊüöÊü•Êû∏ÊüèÊüûÊü≥Êû∞ÊüôÊü¢ÊüùÊüíÊ≠™ÊÆÉÊÆÜÊÆµÊØíÊØóÊ∞üÊ≥âÊ¥ãÊ¥≤Ê¥™ÊµÅÊ¥•Ê¥åÊ¥±Ê¥ûÊ¥ó"],["aca1","Ê¥ªÊ¥ΩÊ¥æÊ¥∂Ê¥õÊ≥µÊ¥πÊ¥ßÊ¥∏Ê¥©Ê¥ÆÊ¥µÊ¥éÊ¥´ÁÇ´ÁÇ∫ÁÇ≥ÁÇ¨ÁÇØÁÇ≠ÁÇ∏ÁÇÆÁÇ§Áà∞Áâ≤ÁâØÁâ¥Áã©Áã†Áã°Áé∑ÁèäÁéªÁé≤ÁèçÁèÄÁé≥ÁîöÁî≠ÁïèÁïåÁïéÁïãÁñ´Áñ§Áñ•Áñ¢Áñ£Áô∏ÁöÜÁöáÁöàÁõàÁõÜÁõÉÁõÖÁúÅÁõπÁõ∏ÁúâÁúãÁõæÁõºÁúáÁüúÁ†ÇÁ†îÁ†åÁ†çÁ•ÜÁ•âÁ•àÁ•áÁ¶πÁ¶∫ÁßëÁßíÁßãÁ©øÁ™ÅÁ´øÁ´ΩÁ±ΩÁ¥ÇÁ¥ÖÁ¥ÄÁ¥âÁ¥áÁ¥ÑÁ¥ÜÁº∏ÁæéÁæøËÄÑ"],["ad40","ËÄêËÄçËÄëËÄ∂ËÉñËÉ•ËÉöËÉÉËÉÑËÉåËÉ°ËÉõËÉéËÉûËÉ§ËÉùËá¥Ëà¢ËãßËåÉËåÖËã£ËãõËã¶ËåÑËã•ËåÇËåâËãíËãóËã±ËåÅËãúËãîËãëËãûËãìËãüËãØËåÜËôêËôπËôªËô∫Ë°çË°´Ë¶ÅËßîË®àË®ÇË®ÉË≤ûË≤†Ëµ¥Ëµ≥Ë∂¥ËªçËªåËø∞Ëø¶Ëø¢Ëø™Ëø•"],["ada1","Ëø≠Ëø´Ëø§Ëø®ÈÉäÈÉéÈÉÅÈÉÉÈÖãÈÖäÈáçÈñÇÈôêÈôãÈôåÈôçÈù¢Èù©ÈüãÈü≠Èü≥È†ÅÈ¢®È£õÈ£üÈ¶ñÈ¶ô‰πò‰∫≥ÂÄåÂÄçÂÄ£‰øØÂÄ¶ÂÄ•‰ø∏ÂÄ©ÂÄñÂÄÜÂÄºÂÄüÂÄöÂÄíÂÄë‰ø∫ÂÄÄÂÄîÂÄ®‰ø±ÂÄ°ÂÄãÂÄôÂÄò‰ø≥‰øÆÂÄ≠ÂÄ™‰øæÂÄ´ÂÄâÂÖºÂÜ§ÂÜ•ÂÜ¢ÂáçÂáåÂáÜÂáãÂâñÂâúÂâîÂâõÂâùÂå™ÂçøÂéüÂéùÂèüÂì®ÂîêÂîÅÂî∑ÂìºÂì•Âì≤ÂîÜÂì∫ÂîîÂì©Âì≠Âì°ÂîâÂìÆÂì™"],["ae40","Âì¶ÂîßÂîáÂìΩÂîèÂúÉÂúÑÂüÇÂüîÂüãÂüÉÂ†âÂ§èÂ•óÂ•òÂ•öÂ®ëÂ®òÂ®úÂ®üÂ®õÂ®ìÂß¨Â®†Â®£Â®©Â®•Â®åÂ®âÂ≠´Â±òÂÆ∞ÂÆ≥ÂÆ∂ÂÆ¥ÂÆÆÂÆµÂÆπÂÆ∏Â∞ÑÂ±ëÂ±ïÂ±êÂ≥≠Â≥ΩÂ≥ªÂ≥™Â≥®Â≥∞Â≥∂Â¥ÅÂ≥¥Â∑ÆÂ∏≠Â∏´Â∫´Â∫≠Â∫ßÂº±ÂæíÂæëÂæêÊÅô"],["aea1","ÊÅ£ÊÅ•ÊÅêÊÅïÊÅ≠ÊÅ©ÊÅØÊÇÑÊÇüÊÇöÊÇçÊÇîÊÇåÊÇÖÊÇñÊâáÊã≥ÊåàÊãøÊçéÊåæÊåØÊçïÊçÇÊçÜÊçèÊçâÊå∫ÊçêÊåΩÊå™Êå´Êå®ÊççÊçåÊïàÊïâÊñôÊóÅÊóÖÊôÇÊôâÊôèÊôÉÊôíÊôåÊôÖÊôÅÊõ∏ÊúîÊúïÊúóÊ†°Ê†∏Ê°àÊ°ÜÊ°ìÊ†πÊ°ÇÊ°îÊ†©Ê¢≥Ê†óÊ°åÊ°ëÊ†ΩÊü¥Ê°êÊ°ÄÊ†ºÊ°ÉÊ†™Ê°ÖÊ†ìÊ†òÊ°ÅÊÆäÊÆâÊÆ∑Ê∞£Ê∞ßÊ∞®Ê∞¶Ê∞§Ê≥∞Êµ™Ê∂ïÊ∂àÊ∂áÊµ¶Êµ∏Êµ∑ÊµôÊ∂ì"],["af40","Êµ¨Ê∂âÊµÆÊµöÊµ¥Êµ©Ê∂åÊ∂äÊµπÊ∂ÖÊµ•Ê∂îÁÉäÁÉòÁÉ§ÁÉôÁÉàÁÉèÁàπÁâπÁãºÁãπÁãΩÁã∏Áã∑ÁéÜÁè≠ÁêâÁèÆÁè†Áè™ÁèûÁïîÁïùÁïúÁïöÁïôÁñæÁóÖÁóáÁñ≤Áñ≥ÁñΩÁñºÁñπÁóÇÁñ∏ÁöãÁö∞ÁõäÁõçÁõéÁú©ÁúüÁú†Áú®Áü©Á†∞Á†ßÁ†∏Á†ùÁ†¥Á†∑"],["afa1","Á†•Á†≠Á††Á†üÁ†≤Á•ïÁ•êÁ•†Á•üÁ•ñÁ•ûÁ•ùÁ•óÁ•öÁß§Áß£ÁßßÁßüÁß¶Áß©ÁßòÁ™ÑÁ™àÁ´ôÁ¨ÜÁ¨ëÁ≤âÁ¥°Á¥óÁ¥ãÁ¥äÁ¥†Á¥¢Á¥îÁ¥êÁ¥ïÁ¥öÁ¥úÁ¥çÁ¥ôÁ¥õÁº∫ÁΩüÁæîÁøÖÁøÅËÄÜËÄòËÄïËÄôËÄóËÄΩËÄøËÉ±ËÑÇËÉ∞ËÑÖËÉ≠ËÉ¥ËÑÜËÉ∏ËÉ≥ËÑàËÉΩËÑäËÉºËÉØËá≠Ëá¨ËàÄËàêËà™Ëà´Ëà®Ëà¨ËäªËå´ËçíËçîËçäËå∏ËçêËçâËåµËå¥ËçèËå≤ËåπËå∂ËåóËçÄËå±Ëå®ËçÉ"],["b040","ËôîËöäËö™ËöìËö§Ëö©ËöåËö£ËöúË°∞Ë°∑Ë¢ÅË¢ÇË°ΩË°πË®òË®êË®éË®åË®ïË®äË®óË®ìË®ñË®èË®ëË±àË±∫Ë±πË≤°Ë≤¢Ëµ∑Ë∫¨ËªíËªîËªèËæ±ÈÄÅÈÄÜËø∑ÈÄÄËø∫Ëø¥ÈÄÉËøΩÈÄÖËø∏ÈÇïÈÉ°ÈÉùÈÉ¢ÈÖíÈÖçÈÖåÈáòÈáùÈáóÈáúÈáôÈñÉÈô¢Èô£Èô°"],["b0a1","ÈôõÈôùÈô§ÈôòÈôûÈöªÈ£¢È¶¨È™®È´òÈ¨•È¨≤È¨º‰πæÂÅ∫ÂÅΩÂÅúÂÅáÂÅÉÂÅåÂÅöÂÅâÂÅ•ÂÅ∂ÂÅéÂÅïÂÅµÂÅ¥ÂÅ∑ÂÅèÂÄèÂÅØÂÅ≠ÂÖúÂÜïÂá∞Ââ™ÂâØÂãíÂãôÂãòÂãïÂåêÂåèÂåôÂåøÂçÄÂåæÂèÉÊõºÂïÜÂï™Âï¶ÂïÑÂïûÂï°ÂïÉÂïäÂî±ÂïñÂïèÂïïÂîØÂï§Âî∏ÂîÆÂïúÂî¨Âï£Âî≥ÂïÅÂïóÂúàÂúãÂúâÂüüÂ†ÖÂ†äÂ†ÜÂü†Âü§Âü∫Â†ÇÂ†µÂü∑ÂüπÂ§†Â•¢Â®∂Â©ÅÂ©âÂ©¶Â©™Â©Ä"],["b140","Â®ºÂ©¢Â©öÂ©ÜÂ©äÂ≠∞ÂØáÂØÖÂØÑÂØÇÂÆøÂØÜÂ∞âÂ∞àÂ∞áÂ±†Â±úÂ±ùÂ¥áÂ¥ÜÂ¥éÂ¥õÂ¥ñÂ¥¢Â¥ëÂ¥©Â¥îÂ¥ôÂ¥§Â¥ßÂ¥óÂ∑¢Â∏∏Â∏∂Â∏≥Â∏∑Â∫∑Â∫∏Â∫∂Â∫µÂ∫æÂºµÂº∑ÂΩóÂΩ¨ÂΩ©ÂΩ´ÂæóÂæôÂæûÂæòÂæ°Âæ†ÂæúÊÅøÊÇ£ÊÇâÊÇ†ÊÇ®ÊÉãÊÇ¥ÊÉ¶ÊÇΩ"],["b1a1","ÊÉÖÊÇªÊÇµÊÉúÊÇºÊÉòÊÉïÊÉÜÊÉüÊÇ∏ÊÉöÊÉáÊàöÊàõÊâàÊé†ÊéßÊç≤ÊéñÊé¢Êé•Êç∑ÊçßÊéòÊé™Êç±Êé©ÊéâÊéÉÊéõÊç´Êé®ÊéÑÊéàÊéôÊé°Êé¨ÊéíÊéèÊéÄÊçªÊç©Êç®Êç∫ÊïùÊïñÊïëÊïôÊïóÂïüÊïèÊïòÊïïÊïîÊñúÊñõÊñ¨ÊóèÊóãÊóåÊóéÊôùÊôöÊô§Êô®Êô¶ÊôûÊõπÂãóÊúõÊ¢ÅÊ¢ØÊ¢¢Ê¢ìÊ¢µÊ°øÊ°∂Ê¢±Ê¢ßÊ¢óÊ¢∞Ê¢ÉÊ£ÑÊ¢≠Ê¢ÜÊ¢ÖÊ¢îÊ¢ùÊ¢®Ê¢üÊ¢°Ê¢ÇÊ¨≤ÊÆ∫"],["b240","ÊØ´ÊØ¨Ê∞´Ê∂éÊ∂ºÊ∑≥Ê∑ôÊ∂≤Ê∑°Ê∑åÊ∑§Ê∑ªÊ∑∫Ê∏ÖÊ∑áÊ∑ãÊ∂ØÊ∑ëÊ∂ÆÊ∑ûÊ∑πÊ∂∏Ê∑∑Ê∑µÊ∑ÖÊ∑íÊ∏öÊ∂µÊ∑öÊ∑´Ê∑òÊ∑™Ê∑±Ê∑ÆÊ∑®Ê∑ÜÊ∑ÑÊ∂™Ê∑¨Ê∂øÊ∑¶ÁÉπÁÑâÁÑäÁÉΩÁÉØÁàΩÁâΩÁäÅÁåúÁåõÁåñÁåìÁåôÁéáÁêÖÁêäÁêÉÁêÜÁèæÁêçÁì†Áì∂"],["b2a1","Áì∑ÁîúÁî¢Áï•Áï¶Áï¢Áï∞ÁñèÁóîÁóïÁñµÁóäÁóçÁöéÁõîÁõíÁõõÁú∑ÁúæÁúºÁú∂Áú∏Áú∫Á°´Á°ÉÁ°éÁ••Á•®Á•≠ÁßªÁ™íÁ™ïÁ¨†Á¨®Á¨õÁ¨¨Á¨¶Á¨ôÁ¨ûÁ¨ÆÁ≤íÁ≤óÁ≤ïÁµÜÁµÉÁµ±Á¥ÆÁ¥πÁ¥ºÁµÄÁ¥∞Á¥≥ÁµÑÁ¥ØÁµÇÁ¥≤Á¥±ÁºΩÁæûÁæöÁøåÁøéÁøíËÄúËÅäËÅÜËÑØËÑñËÑ£ËÑ´ËÑ©ËÑ∞ËÑ§ËàÇËàµËà∑Ëà∂ËàπËééËéûËéòËç∏Ëé¢ËéñËéΩËé´ËéíËéäËéìËéâËé†Ëç∑ËçªËçº"],["b340","ËéÜËéßËôïÂΩ™ËõáËõÄËö∂ËõÑËöµËõÜËõãËö±ËöØËõâË°ìË¢ûË¢àË¢´Ë¢íË¢ñË¢çË¢ãË¶ìË¶èË®™Ë®ùË®£Ë®•Ë®±Ë®≠Ë®üË®õË®¢Ë±âË±öË≤©Ë≤¨Ë≤´Ë≤®Ë≤™Ë≤ßËµßËµ¶Ë∂æË∂∫ËªõËªüÈÄôÈÄçÈÄöÈÄóÈÄ£ÈÄüÈÄùÈÄêÈÄïÈÄûÈÄ†ÈÄèÈÄ¢ÈÄñÈÄõÈÄî"],["b3a1","ÈÉ®ÈÉ≠ÈÉΩÈÖóÈáéÈáµÈá¶Èá£ÈáßÈá≠Èá©ÈñâÈô™ÈôµÈô≥Èô∏Èô∞Èô¥Èô∂Èô∑Èô¨ÈõÄÈõ™Èõ©Á´†Á´üÈ†ÇÈ†ÉÈ≠öÈ≥•ÈπµÈπøÈ∫•È∫ªÂÇ¢ÂÇçÂÇÖÂÇôÂÇëÂÇÄÂÇñÂÇòÂÇöÊúÄÂá±Ââ≤Ââ¥ÂâµÂâ©ÂãûÂãùÂãõÂçöÂé•ÂïªÂñÄÂñßÂïºÂñäÂñùÂñòÂñÇÂñúÂñ™ÂñîÂñáÂñãÂñÉÂñ≥ÂñÆÂñüÂîæÂñ≤ÂñöÂñªÂñ¨Âñ±ÂïæÂñâÂñ´ÂñôÂúçÂ†ØÂ†™Â†¥Â†§Â†∞Â†±Â†°Â†ùÂ††Â£πÂ£∫Â•†"],["b440","Â©∑Â™öÂ©øÂ™íÂ™õÂ™ßÂ≠≥Â≠±ÂØíÂØåÂØìÂØêÂ∞äÂ∞ãÂ∞±ÂµåÂµêÂ¥¥ÂµáÂ∑ΩÂπÖÂ∏ΩÂπÄÂπÉÂπæÂªäÂªÅÂªÇÂªÑÂººÂΩ≠Âæ©Âæ™Âæ®ÊÉëÊÉ°ÊÇ≤ÊÇ∂ÊÉ†ÊÑúÊÑ£ÊÉ∫ÊÑïÊÉ∞ÊÉªÊÉ¥ÊÖ®ÊÉ±ÊÑéÊÉ∂ÊÑâÊÑÄÊÑíÊàüÊââÊé£ÊéåÊèèÊèÄÊè©ÊèâÊèÜÊèç"],["b4a1","ÊèíÊè£ÊèêÊè°ÊèñÊè≠ÊèÆÊç∂Êè¥Êè™ÊèõÊëíÊèöÊèπÊïûÊï¶Êï¢Êï£ÊñëÊñêÊñØÊôÆÊô∞Êô¥Êô∂ÊôØÊöëÊô∫ÊôæÊô∑ÊõæÊõøÊúüÊúùÊ£∫Ê£ïÊ£†Ê£òÊ£óÊ§ÖÊ£üÊ£µÊ£ÆÊ£ßÊ£πÊ£íÊ£≤Ê££Ê£ãÊ£çÊ§çÊ§íÊ§éÊ£âÊ£öÊ•ÆÊ£ªÊ¨æÊ¨∫Ê¨ΩÊÆòÊÆñÊÆºÊØØÊ∞ÆÊ∞ØÊ∞¨Ê∏ØÊ∏∏ÊπîÊ∏°Ê∏≤ÊπßÊπäÊ∏†Ê∏•Ê∏£Ê∏õÊπõÊπòÊ∏§ÊπñÊπÆÊ∏≠Ê∏¶ÊπØÊ∏¥ÊπçÊ∏∫Ê∏¨ÊπÉÊ∏ùÊ∏æÊªã"],["b540","Ê∫âÊ∏ôÊπéÊπ£ÊπÑÊπ≤Êπ©ÊπüÁÑôÁÑöÁÑ¶ÁÑ∞ÁÑ°ÁÑ∂ÁÖÆÁÑúÁâåÁäÑÁäÄÁå∂Áå•Áå¥Áå©Áê∫Áê™Áê≥Áê¢Áê•ÁêµÁê∂Áê¥ÁêØÁêõÁê¶Áê®Áî•Áî¶Áï´Áï™Áó¢ÁóõÁó£ÁóôÁóòÁóûÁó†ÁôªÁôºÁöñÁöìÁö¥ÁõúÁùèÁü≠Á°ùÁ°¨Á°ØÁ®çÁ®àÁ®ãÁ®ÖÁ®ÄÁ™ò"],["b5a1","Á™óÁ™ñÁ´•Á´£Á≠âÁ≠ñÁ≠ÜÁ≠êÁ≠íÁ≠îÁ≠çÁ≠ãÁ≠èÁ≠ëÁ≤üÁ≤•ÁµûÁµêÁµ®ÁµïÁ¥´ÁµÆÁµ≤Áµ°Áµ¶Áµ¢Áµ∞Áµ≥ÂñÑÁøîÁøïËÄãËÅíËÇÖËÖïËÖîËÖãËÖëËÖéËÑπËÖÜËÑæËÖåËÖìËÖ¥ËàíËàúËè©ËêÉËè∏ËêçËè†ËèÖËêãËèÅËèØËè±Ëè¥ËëóËêäËè∞ËêåËèåËèΩËè≤ËèäËê∏ËêéËêÑËèúËêáËèîËèüËôõËõüËõôËõ≠ËõîËõõËõ§ËõêËõûË°óË£ÅË£ÇË¢±Ë¶ÉË¶ñË®ªË©†Ë©ïË©ûË®ºË©Å"],["b640","Ë©îË©õË©êË©ÜË®¥Ë®∫Ë®∂Ë©ñË±°Ë≤ÇË≤ØË≤ºË≤≥Ë≤ΩË≥ÅË≤ªË≥ÄË≤¥Ë≤∑Ë≤∂Ë≤øË≤∏Ë∂äË∂ÖË∂ÅË∑éË∑ùË∑ãË∑öË∑ëË∑åË∑õË∑ÜËªªËª∏ËªºËæúÈÄÆÈÄµÈÄ±ÈÄ∏ÈÄ≤ÈÄ∂ÈÑÇÈÉµÈÑâÈÉæÈÖ£ÈÖ•ÈáèÈàîÈàïÈà£ÈàâÈàûÈàçÈàêÈàáÈàëÈñîÈñèÈñãÈñë"],["b6a1","ÈñìÈñíÈñéÈöäÈöéÈöãÈôΩÈöÖÈöÜÈöçÈô≤ÈöÑÈõÅÈõÖÈõÑÈõÜÈõáÈõØÈõ≤ÈüåÈ†ÖÈ†ÜÈ†àÈ£ßÈ£™È£ØÈ£©È£≤È£≠È¶ÆÈ¶≠ÈªÉÈªçÈªë‰∫ÇÂÇ≠ÂÇµÂÇ≤ÂÇ≥ÂÉÖÂÇæÂÇ¨ÂÇ∑ÂÇªÂÇØÂÉáÂâøÂâ∑ÂâΩÂãüÂã¶Âã§Âã¢Âã£ÂåØÂóüÂó®ÂóìÂó¶ÂóéÂóúÂóáÂóëÂó£Âó§ÂóØÂóöÂó°ÂóÖÂóÜÂó•ÂóâÂúíÂúìÂ°ûÂ°ëÂ°òÂ°óÂ°öÂ°îÂ°´Â°åÂ°≠Â°äÂ°¢Â°íÂ°ãÂ•ßÂ´ÅÂ´âÂ´åÂ™æÂ™ΩÂ™º"],["b740","Â™≥Â´ÇÂ™≤Âµ©ÂµØÂπåÂππÂªâÂªàÂºíÂΩôÂæ¨ÂæÆÊÑöÊÑèÊÖàÊÑüÊÉ≥ÊÑõÊÉπÊÑÅÊÑàÊÖéÊÖåÊÖÑÊÖçÊÑæÊÑ¥ÊÑßÊÑçÊÑÜÊÑ∑Êà°Êà¢ÊêìÊêæÊêûÊê™Êê≠ÊêΩÊê¨ÊêèÊêúÊêîÊêçÊê∂ÊêñÊêóÊêÜÊï¨ÊñüÊñ∞ÊöóÊöâÊöáÊöàÊöñÊöÑÊöòÊöçÊúÉÊ¶îÊ•≠"],["b7a1","Ê•öÊ•∑Ê•†Ê•îÊ•µÊ§∞Ê¶ÇÊ•äÊ•®Ê•´Ê•ûÊ•ìÊ•πÊ¶ÜÊ•ùÊ•£Ê•õÊ≠áÊ≠≤ÊØÄÊÆøÊØìÊØΩÊ∫¢Ê∫ØÊªìÊ∫∂ÊªÇÊ∫êÊ∫ùÊªáÊªÖÊ∫•Ê∫òÊ∫ºÊ∫∫Ê∫´ÊªëÊ∫ñÊ∫úÊªÑÊªîÊ∫™Ê∫ßÊ∫¥ÁÖéÁÖôÁÖ©ÁÖ§ÁÖâÁÖßÁÖúÁÖ¨ÁÖ¶ÁÖåÁÖ•ÁÖûÁÖÜÁÖ®ÁÖñÁà∫ÁâíÁå∑ÁçÖÁåøÁåæÁëØÁëöÁëïÁëüÁëûÁëÅÁêøÁëôÁëõÁëúÁï∂Áï∏ÁòÄÁó∞ÁòÅÁó≤Áó±Áó∫ÁóøÁó¥Áó≥ÁõûÁõüÁùõÁù´Áù¶ÁùûÁù£"],["b840","ÁùπÁù™Áù¨ÁùúÁù•Áù®Áù¢ÁüÆÁ¢éÁ¢∞Á¢óÁ¢òÁ¢åÁ¢âÁ°ºÁ¢ëÁ¢ìÁ°øÁ•∫Á•øÁ¶ÅËê¨Á¶ΩÁ®úÁ®öÁ®†Á®îÁ®üÁ®ûÁ™üÁ™†Á≠∑ÁØÄÁ≠†Á≠ÆÁ≠ßÁ≤±Á≤≥Á≤µÁ∂ìÁµπÁ∂ëÁ∂ÅÁ∂èÁµõÁΩÆÁΩ©ÁΩ™ÁΩ≤Áæ©Áæ®Áæ§ËÅñËÅòËÇÜËÇÑËÖ±ËÖ∞ËÖ∏ËÖ•ËÖÆËÖ≥ËÖ´"],["b8a1","ËÖπËÖ∫ËÖ¶ËàÖËâáËíÇËë∑ËêΩËê±ËëµËë¶Ëë´ËëâËë¨ËëõËêºËêµËë°Ëë£Ëë©Ëë≠ËëÜËôûËôúËôüËõπËúìËúàËúáËúÄËõæËõªËúÇËúÉËúÜËúäË°ôË£üË£îË£ôË£úË£òË£ùË£°Ë£äË£ïË£íË¶úËß£Ë©´Ë©≤Ë©≥Ë©¶Ë©©Ë©∞Ë™áË©ºË©£Ë™†Ë©±Ë™ÖË©≠Ë©¢Ë©ÆË©¨Ë©πË©ªË®æË©®Ë±¢Ë≤äË≤âË≥äË≥áË≥àË≥ÑË≤≤Ë≥ÉË≥ÇË≥ÖË∑°Ë∑üË∑®Ë∑ØË∑≥Ë∑∫Ë∑™Ë∑§Ë∑¶Ë∫≤ËºÉËºâËªæËºä"],["b940","ËæüËæ≤ÈÅãÈÅäÈÅìÈÅÇÈÅîÈÄºÈÅïÈÅêÈÅáÈÅèÈÅéÈÅçÈÅëÈÄæÈÅÅÈÑíÈÑóÈÖ¨ÈÖ™ÈÖ©ÈáâÈà∑ÈâóÈà∏ÈàΩÈâÄÈàæÈâõÈâãÈâ§ÈâëÈà¥ÈââÈâçÈâÖÈàπÈàøÈâöÈñòÈöòÈöîÈöïÈõçÈõãÈõâÈõäÈõ∑ÈõªÈõπÈõ∂ÈùñÈù¥Èù∂È†êÈ†ëÈ†ìÈ†äÈ†íÈ†åÈ£ºÈ£¥"],["b9a1","È£ΩÈ£æÈ¶≥È¶±È¶¥È´°È≥©È∫ÇÈºéÈºìÈº†ÂÉßÂÉÆÂÉ•ÂÉñÂÉ≠ÂÉöÂÉïÂÉèÂÉëÂÉ±ÂÉéÂÉ©ÂÖ¢Âá≥ÂäÉÂäÇÂå±Âé≠ÂóæÂòÄÂòõÂòóÂóΩÂòîÂòÜÂòâÂòçÂòéÂó∑ÂòñÂòüÂòàÂòêÂó∂ÂúòÂúñÂ°µÂ°æÂ¢ÉÂ¢ìÂ¢äÂ°πÂ¢ÖÂ°ΩÂ£ΩÂ§•Â§¢Â§§Â•™Â•©Â´°Â´¶Â´©Â´óÂ´ñÂ´òÂ´£Â≠µÂØûÂØßÂØ°ÂØ•ÂØ¶ÂØ®ÂØ¢ÂØ§ÂØüÂ∞çÂ±¢Â∂ÑÂ∂áÂπõÂπ£ÂπïÂπóÂπîÂªìÂªñÂºäÂΩÜÂΩ∞ÂæπÊÖá"],["ba40","ÊÑøÊÖãÊÖ∑ÊÖ¢ÊÖ£ÊÖüÊÖöÊÖòÊÖµÊà™ÊíáÊëòÊëîÊí§Êë∏ÊëüÊë∫ÊëëÊëßÊê¥Êë≠ÊëªÊï≤Êñ°ÊóóÊóñÊö¢Êö®ÊöùÊ¶úÊ¶®Ê¶ïÊßÅÊ¶ÆÊßìÊßãÊ¶õÊ¶∑Ê¶ªÊ¶´Ê¶¥ÊßêÊßçÊ¶≠ÊßåÊ¶¶ÊßÉÊ¶£Ê≠âÊ≠åÊ∞≥Êº≥ÊºîÊªæÊºìÊª¥Êº©ÊºæÊº†Êº¨ÊºèÊºÇÊº¢"],["baa1","ÊªøÊªØÊºÜÊº±Êº∏Êº≤Êº£ÊºïÊº´ÊºØÊæàÊº™Êª¨ÊºÅÊª≤ÊªåÊª∑ÁÜîÁÜôÁÖΩÁÜäÁÜÑÁÜíÁàæÁäíÁäñÁçÑÁçêÁë§Áë£Áë™Áë∞Áë≠ÁîÑÁñëÁòßÁòçÁòãÁòâÁòìÁõ°Áõ£ÁûÑÁùΩÁùøÁù°Á£ÅÁ¢üÁ¢ßÁ¢≥Á¢©Á¢£Á¶éÁ¶èÁ¶çÁ®ÆÁ®±Á™™Á™©Á´≠Á´ØÁÆ°ÁÆïÁÆãÁ≠µÁÆóÁÆùÁÆîÁÆèÁÆ∏ÁÆáÁÆÑÁ≤πÁ≤ΩÁ≤æÁ∂ªÁ∂∞Á∂úÁ∂ΩÁ∂æÁ∂†Á∑äÁ∂¥Á∂≤Á∂±Á∂∫Á∂¢Á∂øÁ∂µÁ∂∏Á∂≠Á∑íÁ∑áÁ∂¨"],["bb40","ÁΩ∞Áø†Áø°ÁøüËÅûËÅöËÇáËÖêËÜÄËÜèËÜàËÜäËÖøËÜÇËáßËá∫ËàáËàîËàûËâãËìâËíøËìÜËìÑËíôËíûËí≤ËíúËìãËí∏ËìÄËììËíêËíºËìëËìäËúøËúúËúªËú¢Ëú•Ëú¥ËúòËùïËú∑Ëú©Ë£≥Ë§ÇË£¥Ë£πË£∏Ë£ΩË£®Ë§öË£ØË™¶Ë™åË™ûË™£Ë™çË™°Ë™ìË™§"],["bba1","Ë™™Ë™•Ë™®Ë™òË™ëË™öË™ßË±™Ë≤çË≤åË≥ìË≥ëË≥íËµ´Ë∂ôË∂ïË∑ºËºîËºíËºïËºìËæ£ÈÅ†ÈÅòÈÅúÈÅ£ÈÅôÈÅûÈÅ¢ÈÅùÈÅõÈÑôÈÑòÈÑûÈÖµÈÖ∏ÈÖ∑ÈÖ¥Èâ∏ÈäÄÈäÖÈäòÈäñÈâªÈäìÈäúÈä®ÈâºÈäëÈñ°Èñ®Èñ©Èñ£Èñ•Èñ§ÈöôÈöúÈöõÈõåÈõíÈúÄÈùºÈûÖÈü∂È†óÈ†òÈ¢ØÈ¢±È§ÉÈ§ÖÈ§åÈ§âÈßÅÈ™ØÈ™∞È´¶È≠ÅÈ≠ÇÈ≥¥È≥∂È≥≥È∫ºÈºªÈΩäÂÑÑÂÑÄÂÉªÂÉµÂÉπÂÑÇÂÑàÂÑâÂÑÖÂáú"],["bc40","ÂäáÂäàÂäâÂäçÂääÂã∞Âé≤ÂòÆÂòªÂòπÂò≤ÂòøÂò¥Âò©ÂôìÂôéÂôóÂô¥Âò∂ÂòØÂò∞Â¢ÄÂ¢üÂ¢ûÂ¢≥Â¢úÂ¢ÆÂ¢©Â¢¶Â•≠Â¨âÂ´ªÂ¨ãÂ´µÂ¨åÂ¨àÂØÆÂØ¨ÂØ©ÂØ´Â±§Â±•Â∂ùÂ∂îÂπ¢ÂπüÂπ°Âª¢ÂªöÂªüÂªùÂª£Âª†ÂΩàÂΩ±Âæ∑ÂæµÊÖ∂ÊÖßÊÖÆÊÖùÊÖïÊÜÇ"],["bca1","ÊÖºÊÖ∞ÊÖ´ÊÖæÊÜßÊÜêÊÜ´ÊÜéÊÜ¨ÊÜöÊÜ§ÊÜîÊÜÆÊàÆÊë©ÊëØÊëπÊíûÊí≤ÊíàÊíêÊí∞Êí•ÊíìÊíïÊí©ÊííÊíÆÊí≠Êí´ÊíöÊí¨ÊíôÊí¢Êí≥ÊïµÊï∑Êï∏ÊöÆÊö´Êö¥Êö±Ê®£Ê®üÊß®Ê®ÅÊ®ûÊ®ôÊßΩÊ®°Ê®ìÊ®äÊß≥Ê®ÇÊ®ÖÊß≠Ê®ëÊ≠êÊ≠éÊÆ§ÊØÖÊØÜÊºøÊΩºÊæÑÊΩëÊΩ¶ÊΩîÊæÜÊΩ≠ÊΩõÊΩ∏ÊΩÆÊæéÊΩ∫ÊΩ∞ÊΩ§ÊæóÊΩòÊªïÊΩØÊΩ†ÊΩüÁÜüÁÜ¨ÁÜ±ÁÜ®ÁâñÁäõÁçéÁçóÁë©ÁíãÁíÉ"],["bd40","ÁëæÁíÄÁïøÁò†Áò©ÁòüÁò§Áò¶Áò°Áò¢ÁööÁö∫Áõ§ÁûéÁûáÁûåÁûëÁûãÁ£ãÁ£ÖÁ¢∫Á£äÁ¢æÁ£ïÁ¢ºÁ£êÁ®øÁ®ºÁ©ÄÁ®ΩÁ®∑Á®ªÁ™ØÁ™ÆÁÆ≠ÁÆ±ÁØÑÁÆ¥ÁØÜÁØáÁØÅÁÆ†ÁØåÁ≥äÁ∑†Á∑¥Á∑ØÁ∑ªÁ∑òÁ∑¨Á∑ùÁ∑®Á∑£Á∑öÁ∑ûÁ∑©Á∂ûÁ∑ôÁ∑≤Á∑πÁΩµÁΩ∑ÁæØ"],["bda1","Áø©ËÄ¶ËÜõËÜúËÜùËÜ†ËÜöËÜòËîóËîΩËîöËìÆËî¨Ëî≠ËîìËîëËî£Ëî°ËîîËì¨Ëî•ËìøËîÜËûÇËù¥Ëù∂Ëù†Ëù¶Ëù∏Ëù®ËùôËùóËùåËùìË°õË°ùË§êË§áË§íË§ìË§ïË§äË™ºË´íË´áË´ÑË™ïË´ãË´∏Ë™≤Ë´âË´ÇË™øË™∞Ë´ñË´çË™∂Ë™πË´õË±åË±éË±¨Ë≥†Ë≥ûË≥¶Ë≥§Ë≥¨Ë≥≠Ë≥¢Ë≥£Ë≥úË≥™Ë≥°Ëµ≠Ë∂üË∂£Ë∏´Ë∏êË∏ùË∏¢Ë∏èË∏©Ë∏üË∏°Ë∏ûË∫∫ËºùËºõËºüËº©Ëº¶Ëº™ËºúËºû"],["be40","Ëº•ÈÅ©ÈÅÆÈÅ®ÈÅ≠ÈÅ∑ÈÑ∞ÈÑ≠ÈÑßÈÑ±ÈÜáÈÜâÈÜãÈÜÉÈãÖÈäªÈä∑Èã™Èä¨Èã§ÈãÅÈä≥ÈäºÈãíÈãáÈã∞Èä≤Èñ≠Èñ±ÈúÑÈúÜÈúáÈúâÈù†ÈûçÈûãÈûèÈ†°È†´È†úÈ¢≥È§äÈ§ìÈ§íÈ§òÈßùÈßêÈßüÈßõÈßëÈßïÈßíÈßôÈ™∑È´ÆÈ´ØÈ¨ßÈ≠ÖÈ≠ÑÈ≠∑È≠ØÈ¥ÜÈ¥â"],["bea1","È¥ÉÈ∫©È∫æÈªéÂ¢®ÈΩíÂÑíÂÑòÂÑîÂÑêÂÑïÂÜÄÂÜ™ÂáùÂäëÂäìÂã≥ÂôôÂô´ÂôπÂô©Âô§Âô∏Âô™Âô®Âô•Âô±ÂôØÂô¨Âô¢Âô∂Â£ÅÂ¢æÂ£áÂ£ÖÂ•ÆÂ¨ùÂ¨¥Â≠∏ÂØ∞Â∞éÂΩäÊÜ≤ÊÜëÊÜ©ÊÜäÊáçÊÜ∂ÊÜæÊáäÊáàÊà∞ÊìÖÊìÅÊìãÊíªÊíºÊìöÊìÑÊìáÊìÇÊìçÊíøÊìíÊìîÊíæÊï¥ÊõÜÊõâÊöπÊõÑÊõáÊö∏Ê®ΩÊ®∏Ê®∫Ê©ôÊ©´Ê©òÊ®πÊ©ÑÊ©¢Ê©°Ê©ãÊ©áÊ®µÊ©üÊ©àÊ≠ôÊ≠∑Ê∞ÖÊøÇÊæ±Êæ°"],["bf40","ÊøÉÊæ§ÊøÅÊæßÊæ≥ÊøÄÊæπÊæ∂Êæ¶Êæ†Êæ¥ÁÜæÁáâÁáêÁáíÁáàÁáïÁÜπÁáéÁáôÁáúÁáÉÁáÑÁç®ÁíúÁí£ÁíòÁíüÁíûÁì¢ÁîåÁîçÁò¥Áò∏Áò∫ÁõßÁõ•Áû†ÁûûÁûüÁû•Á£®Á£öÁ£¨Á£ßÁ¶¶Á©çÁ©éÁ©ÜÁ©åÁ©ãÁ™∫ÁØôÁ∞ëÁØâÁØ§ÁØõÁØ°ÁØ©ÁØ¶Á≥ïÁ≥ñÁ∏ä"],["bfa1","Á∏ëÁ∏àÁ∏õÁ∏£Á∏ûÁ∏ùÁ∏âÁ∏êÁΩπÁæ≤Áø∞Áø±ÁøÆËÄ®ËÜ≥ËÜ©ËÜ®ËáªËààËâòËâôËïäËïôËïàËï®Ëï©ËïÉËïâËï≠Ëï™ËïûËûÉËûüËûûËû¢ËûçË°°Ë§™Ë§≤Ë§•Ë§´Ë§°Ë¶™Ë¶¶Ë´¶Ë´∫Ë´´Ë´±Ë¨ÄË´úË´ßË´ÆË´æË¨ÅË¨ÇË´∑Ë´≠Ë´≥Ë´∂Ë´ºË±´Ë±≠Ë≤ìË≥¥ËπÑË∏±Ë∏¥ËπÇË∏πË∏µËºªËºØËº∏Ëº≥Ëæ®Ëæ¶ÈÅµÈÅ¥ÈÅ∏ÈÅ≤ÈÅºÈÅ∫ÈÑ¥ÈÜíÈå†Èå∂Èã∏Èå≥ÈåØÈå¢ÈãºÈå´ÈåÑÈåö"],["c040","ÈåêÈå¶Èå°ÈåïÈåÆÈåôÈñªÈößÈö®Èö™ÈõïÈúéÈúëÈúñÈúçÈúìÈúèÈùõÈùúÈù¶ÈûòÈ†∞È†∏È†ªÈ†∑È†≠È†πÈ†§È§êÈ§®È§ûÈ§õÈ§°È§öÈß≠Èß¢Èß±È™∏È™ºÈ´ªÈ´≠È¨®ÈÆëÈ¥ïÈ¥£È¥¶È¥®È¥íÈ¥õÈªòÈªîÈæçÈæúÂÑ™ÂÑüÂÑ°ÂÑ≤ÂãµÂöéÂöÄÂöêÂöÖÂöá"],["c0a1","ÂöèÂ£ïÂ£ìÂ£ëÂ£éÂ¨∞Â¨™Â¨§Â≠∫Â∞∑Â±®Â∂ºÂ∂∫Â∂ΩÂ∂∏Âπ´ÂΩåÂæΩÊáâÊáÇÊááÊá¶ÊáãÊà≤Êà¥ÊìéÊìäÊìòÊì†Êì∞Êì¶Êì¨Êì±Êì¢Êì≠ÊñÇÊñÉÊõôÊõñÊ™ÄÊ™îÊ™ÑÊ™¢Ê™úÊ´õÊ™£Ê©æÊ™óÊ™êÊ™†Ê≠úÊÆÆÊØöÊ∞àÊøòÊø±ÊøüÊø†ÊøõÊø§Êø´ÊøØÊæÄÊø¨Êø°Êø©ÊøïÊøÆÊø∞ÁáßÁáüÁáÆÁá¶Áá•Áá≠Áá¨Áá¥Áá†ÁàµÁâÜÁç∞Áç≤Áí©Áí∞Áí¶Áí®ÁôÜÁôÇÁôåÁõ™Áû≥Áû™Áû∞Áû¨"],["c140","ÁûßÁû≠ÁüØÁ£∑Á£∫Á£¥Á£ØÁ§ÅÁ¶ßÁ¶™Á©óÁ™øÁ∞áÁ∞çÁØæÁØ∑Á∞åÁØ†Á≥†Á≥úÁ≥ûÁ≥¢Á≥üÁ≥ôÁ≥ùÁ∏ÆÁ∏æÁπÜÁ∏∑Á∏≤ÁπÉÁ∏´Á∏ΩÁ∏±ÁπÖÁπÅÁ∏¥Á∏πÁπàÁ∏µÁ∏øÁ∏ØÁΩÑÁø≥ÁøºËÅ±ËÅ≤ËÅ∞ËÅØËÅ≥ËáÜËáÉËÜ∫ËáÇËáÄËÜøËÜΩËáâËÜæËá®ËàâËâ±Ëñ™"],["c1a1","ËñÑËïæËñúËñëËñîËñØËñõËñáËñ®ËñäËôßËüÄËüëËû≥ËüíËüÜËû´ËûªËû∫ËüàËüãË§ªË§∂Ë•ÑË§∏Ë§ΩË¶¨Ë¨éË¨óË¨ôË¨õË¨äË¨†Ë¨ùË¨ÑË¨êË±ÅË∞øË±≥Ë≥∫Ë≥ΩË≥ºË≥∏Ë≥ªË∂®ËπâËπãËπàËπäËΩÑËºæËΩÇËΩÖËºøÈÅøÈÅΩÈÇÑÈÇÅÈÇÇÈÇÄÈÑπÈÜ£ÈÜûÈÜúÈççÈéÇÈå®ÈçµÈçäÈç•ÈçãÈåòÈçæÈç¨ÈçõÈç∞ÈçöÈçîÈóäÈóãÈóåÈóàÈóÜÈö±Èö∏ÈõñÈúúÈúûÈû†ÈüìÈ°ÜÈ¢∂È§µÈ®Å"],["c240","ÈßøÈÆÆÈÆ´ÈÆ™ÈÆ≠È¥ªÈ¥øÈ∫ãÈªèÈªûÈªúÈªùÈªõÈºæÈΩãÂè¢ÂöïÂöÆÂ£ôÂ£òÂ¨∏ÂΩùÊá£Êà≥Êì¥Êì≤ÊìæÊîÜÊì∫ÊìªÊì∑Êñ∑ÊõúÊú¶Ê™≥Ê™¨Ê´ÉÊ™ªÊ™∏Ê´ÇÊ™ÆÊ™ØÊ≠üÊ≠∏ÊÆØÁÄâÁÄãÊøæÁÄÜÊø∫ÁÄëÁÄèÁáªÁáºÁáæÁá∏Áç∑ÁçµÁíßÁíøÁîïÁôñÁôò"],["c2a1","ÁôíÁûΩÁûøÁûªÁûºÁ§éÁ¶ÆÁ©°Á©¢Á©†Á´ÑÁ´ÖÁ∞´Á∞ßÁ∞™Á∞ûÁ∞£Á∞°Á≥ßÁπîÁπïÁπûÁπöÁπ°ÁπíÁπôÁΩàÁøπÁøªËÅ∑ËÅ∂ËáçËáèËàäËóèËñ©ËóçËóêËóâËñ∞Ëñ∫ËñπËñ¶ËüØËü¨Ëü≤Ëü†Ë¶ÜË¶≤Ëß¥Ë¨®Ë¨πË¨¨Ë¨´Ë±êË¥ÖËπôËπ£Ëπ¶Ëπ§ËπüËπïËªÄËΩâËΩçÈÇáÈÇÉÈÇàÈÜ´ÈÜ¨ÈáêÈéîÈéäÈéñÈé¢Èé≥ÈéÆÈé¨Èé∞ÈéòÈéöÈéóÈóîÈóñÈóêÈóïÈõ¢ÈõúÈõôÈõõÈõûÈú§Èû£Èû¶"],["c340","Èû≠ÈüπÈ°çÈ°èÈ°åÈ°éÈ°ìÈ¢∫È§æÈ§øÈ§ΩÈ§ÆÈ¶•È®éÈ´ÅÈ¨ÉÈ¨ÜÈ≠èÈ≠éÈ≠çÈØäÈØâÈØΩÈØàÈØÄÈµëÈµùÈµ†Èª†ÈºïÈº¨ÂÑ≥Âö•Â£ûÂ£üÂ£¢ÂØµÈæêÂª¨Êá≤Êá∑Êá∂ÊáµÊîÄÊîèÊõ†ÊõùÊ´•Ê´ùÊ´öÊ´ìÁÄõÁÄüÁÄ®ÁÄöÁÄùÁÄïÁÄòÁàÜÁàçÁâòÁä¢Áç∏"],["c3a1","Áç∫ÁíΩÁìäÁì£ÁñáÁñÜÁôüÁô°ÁüáÁ§ôÁ¶±Á©´Á©©Á∞æÁ∞øÁ∞∏Á∞ΩÁ∞∑Á±ÄÁπ´Áπ≠ÁππÁπ©Áπ™ÁæÖÁπ≥Áæ∂ÁæπÁæ∏ËáòËó©ËóùËó™ËóïËó§Ëó•Ëó∑ËüªË†ÖË†çËüπËüæË•†Ë•üË•ñË•ûË≠ÅË≠úË≠òË≠âË≠öË≠éË≠èË≠ÜË≠ôË¥àË¥äËπºËπ≤Ë∫áËπ∂Ëπ¨Ëπ∫Ëπ¥ËΩîËΩéËæ≠ÈÇäÈÇãÈÜ±ÈÜÆÈè°ÈèëÈèüÈèÉÈèàÈèúÈèùÈèñÈè¢ÈèçÈèòÈè§ÈèóÈè®ÈóúÈö¥Èõ£Èú™ÈúßÈù°ÈüúÈüªÈ°û"],["c440","È°òÈ°õÈ¢ºÈ•ÖÈ•âÈ®ñÈ®ôÈ¨çÈØ®ÈØßÈØñÈØõÈ∂âÈµ°Èµ≤Èµ™Èµ¨È∫íÈ∫óÈ∫ìÈ∫¥Âã∏Âö®Âö∑Âö∂Âö¥ÂöºÂ£§Â≠ÄÂ≠ÉÂ≠ΩÂØ∂Â∑âÊá∏Êá∫ÊîòÊîîÊîôÊõ¶ÊúßÊ´¨ÁÄæÁÄ∞ÁÄ≤ÁàêÁçªÁìèÁô¢Áô•Á§¶Á§™Á§¨Á§´Á´áÁ´∂Á±åÁ±ÉÁ±çÁ≥ØÁ≥∞ËæÆÁπΩÁπº"],["c4a1","Á∫ÇÁΩåËÄÄËáöËâ¶ËóªËóπËòëËó∫ËòÜËòãËòáËòäË†îË†ïË•§Ë¶∫Ëß∏Ë≠∞Ë≠¨Ë≠¶Ë≠ØË≠üË≠´Ë¥èË¥çË∫âË∫ÅË∫ÖË∫ÇÈÜ¥ÈáãÈêòÈêÉÈèΩÈó°Èú∞È£ÑÈ•íÈ•ëÈ¶®È®´È®∞È®∑È®µÈ∞ìÈ∞çÈππÈ∫µÈª®ÈºØÈΩüÈΩ£ÈΩ°ÂÑ∑ÂÑ∏ÂõÅÂõÄÂõÇÂ§îÂ±¨Â∑çÊáºÊáæÊîùÊîúÊñïÊõ©Ê´ªÊ¨ÑÊ´∫ÊÆ≤ÁÅåÁàõÁäßÁìñÁìîÁô©ÁüìÁ±êÁ∫èÁ∫åÁæºËòóËò≠ËòöË†£Ë†¢Ë†°Ë†üË•™Ë•¨Ë¶ΩË≠¥"],["c540","Ë≠∑Ë≠ΩË¥ìË∫äË∫çË∫ãËΩüËæØÈÜ∫ÈêÆÈê≥ÈêµÈê∫Èê∏Èê≤Èê´Èó¢Èú∏ÈúπÈú≤ÈüøÈ°ßÈ°•È•óÈ©ÖÈ©ÉÈ©ÄÈ®æÈ´èÈ≠îÈ≠ëÈ∞≠È∞•È∂ØÈ∂¥È∑ÇÈ∂∏È∫ùÈªØÈºôÈΩúÈΩ¶ÈΩßÂÑºÂÑªÂõàÂõäÂõâÂ≠øÂ∑îÂ∑íÂΩéÊáøÊî§Ê¨äÊ≠°ÁÅëÁÅòÁéÄÁì§ÁñäÁôÆÁô¨"],["c5a1","Á¶≥Á±†Á±üËÅæËÅΩËáüË•≤Ë•ØËßºËÆÄË¥ñË¥óË∫ëË∫ìËΩ°ÈÖàÈëÑÈëëÈëíÈúΩÈúæÈüÉÈüÅÈ°´È•ïÈ©ïÈ©çÈ´íÈ¨öÈ±âÈ∞±È∞æÈ∞ªÈ∑ìÈ∑óÈº¥ÈΩ¨ÈΩ™ÈæîÂõåÂ∑ñÊàÄÊî£Êî´Êî™Êõ¨Ê¨êÁìöÁ´äÁ±§Á±£Á±•Á∫ìÁ∫ñÁ∫îËá¢Ëò∏ËòøË†±ËÆäÈÇêÈÇèÈë£Èë†Èë§Èù®È°ØÈ•úÈ©öÈ©õÈ©óÈ´ìÈ´îÈ´ëÈ±îÈ±óÈ±ñÈ∑•È∫üÈª¥ÂõëÂ£©Êî¨ÁÅûÁô±Áô≤ÁüóÁΩêÁæàË†∂Ë†πË°¢ËÆìËÆí"],["c640","ËÆñËâ∑Ë¥õÈáÄÈë™ÈùÇÈùàÈùÑÈüÜÈ°∞È©üÈ¨¢È≠òÈ±üÈ∑πÈ∑∫ÈπºÈπΩÈºáÈΩ∑ÈΩ≤Âª≥Ê¨ñÁÅ£Á±¨Á±ÆË†ªËßÄË∫°ÈáÅÈë≤Èë∞È°±È•ûÈ´ñÈ¨£ÈªåÁÅ§ÁüöËÆöÈë∑ÈüâÈ©¢È©•Á∫úËÆúË∫™ÈáÖÈëΩÈëæÈëºÈ±∑È±∏Èª∑Ë±îÈëøÈ∏öÁà®È©™È¨±È∏õÈ∏ûÁ±≤"],["c940","‰πÇ‰πúÂáµÂåöÂéÇ‰∏á‰∏å‰πá‰∫çÂõóÔ®åÂ±ÆÂΩ≥‰∏èÂÜá‰∏é‰∏Æ‰∫ì‰ªÇ‰ªâ‰ªàÂÜòÂãºÂç¨ÂéπÂú†Â§ÉÂ§¨Â∞êÂ∑øÊó°ÊÆ≥ÊØåÊ∞îÁàø‰∏±‰∏º‰ª®‰ªú‰ª©‰ª°‰ªù‰ªöÂàåÂåúÂçåÂú¢Âú£Â§óÂ§ØÂÆÅÂÆÑÂ∞íÂ∞ªÂ±¥Â±≥Â∏ÑÂ∫ÄÂ∫ÇÂøâÊàâÊâêÊ∞ï"],["c9a1","Ê∞∂Ê±ÉÊ∞øÊ∞ªÁäÆÁä∞ÁéäÁ¶∏ËÇäÈòû‰ºé‰ºò‰º¨‰ªµ‰ºî‰ª±‰ºÄ‰ª∑‰ºà‰ºù‰ºÇ‰ºÖ‰º¢‰ºì‰ºÑ‰ª¥‰ºíÂÜ±ÂàìÂàâÂàêÂä¶Âå¢ÂåüÂççÂéäÂêáÂõ°ÂõüÂúÆÂú™Âú¥Â§ºÂ¶ÄÂ•ºÂ¶ÖÂ•ªÂ•æÂ•∑Â•øÂ≠ñÂ∞ïÂ∞•Â±ºÂ±∫Â±ªÂ±æÂ∑üÂπµÂ∫ÑÂºÇÂºöÂΩ¥ÂøïÂøîÂøèÊâúÊâûÊâ§Êâ°Êâ¶Êâ¢ÊâôÊâ†ÊâöÊâ•ÊóØÊóÆÊúæÊúπÊú∏ÊúªÊú∫ÊúøÊúºÊú≥Ê∞òÊ±ÜÊ±íÊ±úÊ±èÊ±äÊ±îÊ±ã"],["ca40","Ê±åÁÅ±ÁâûÁä¥ÁäµÁééÁî™ÁôøÁ©µÁΩëËâ∏ËâºËäÄËâΩËâøËôçË•æÈÇôÈÇóÈÇòÈÇõÈÇîÈò¢Èò§Èò†Èò£‰Ωñ‰ºª‰Ω¢‰Ωâ‰Ωì‰Ω§‰ºæ‰Ωß‰Ωí‰Ωü‰ΩÅ‰Ωò‰º≠‰º≥‰ºø‰Ω°ÂÜèÂÜπÂàúÂàûÂà°Âä≠ÂäÆÂåâÂç£Âç≤ÂééÂéèÂê∞Âê∑Âê™ÂëîÂëÖÂêôÂêúÂê•Âêò"],["caa1","ÂêΩÂëèÂëÅÂê®Âê§ÂëáÂõÆÂõßÂõ•ÂùÅÂùÖÂùåÂùâÂùãÂùíÂ§ÜÂ•ÄÂ¶¶Â¶òÂ¶†Â¶óÂ¶éÂ¶¢Â¶êÂ¶èÂ¶ßÂ¶°ÂÆéÂÆíÂ∞®Â∞™Â≤çÂ≤èÂ≤àÂ≤ãÂ≤âÂ≤íÂ≤äÂ≤ÜÂ≤ìÂ≤ïÂ∑†Â∏äÂ∏éÂ∫ãÂ∫âÂ∫åÂ∫àÂ∫çÂºÖÂºùÂΩ∏ÂΩ∂ÂøíÂøëÂøêÂø≠Âø®ÂøÆÂø≥Âø°Âø§Âø£Âø∫ÂøØÂø∑ÂøªÊÄÄÂø¥Êà∫ÊäÉÊäåÊäéÊäèÊäîÊäáÊâ±ÊâªÊâ∫Êâ∞ÊäÅÊäàÊâ∑ÊâΩÊâ≤Êâ¥Êî∑Êó∞Êó¥Êó≥Êó≤ÊóµÊùÖÊùá"],["cb40","ÊùôÊùïÊùåÊùàÊùùÊùçÊùöÊùãÊØêÊ∞ôÊ∞öÊ±∏Ê±ßÊ±´Ê≤ÑÊ≤ãÊ≤èÊ±±Ê±ØÊ±©Ê≤öÊ±≠Ê≤áÊ≤ïÊ≤úÊ±¶Ê±≥Ê±•Ê±ªÊ≤éÁÅ¥ÁÅ∫Áâ£ÁäøÁäΩÁãÉÁãÜÁãÅÁä∫ÁãÖÁéïÁéóÁéìÁéîÁéíÁî∫ÁîπÁñîÁñïÁöÅÁ§ΩËÄ¥ËÇïËÇôËÇêËÇíËÇúËäêËäèËäÖËäéËäëËäì"],["cba1","ËääËäÉËäÑË±∏ËøâËæøÈÇüÈÇ°ÈÇ•ÈÇûÈÇßÈÇ†Èò∞Èò®ÈòØÈò≠‰∏≥‰æò‰Ωº‰æÖ‰ΩΩ‰æÄ‰æá‰Ω∂‰Ω¥‰æâ‰æÑ‰Ω∑‰Ωå‰æó‰Ω™‰æö‰Ωπ‰æÅ‰Ω∏‰æê‰æú‰æî‰æû‰æí‰æÇ‰æï‰Ω´‰ΩÆÂÜûÂÜºÂÜæÂàµÂà≤Âà≥ÂâÜÂà±ÂäºÂåäÂåãÂåºÂéíÂéîÂíáÂëøÂíÅÂíëÂíÇÂíàÂë´Âë∫ÂëæÂë•Âë¨Âë¥Âë¶ÂíçÂëØÂë°Âë†ÂíòÂë£ÂëßÂë§Âõ∑ÂõπÂùØÂù≤Âù≠Âù´Âù±Âù∞Âù∂ÂûÄÂùµÂùªÂù≥Âù¥Âù¢"],["cc40","Âù®ÂùΩÂ§åÂ•ÖÂ¶µÂ¶∫ÂßèÂßéÂ¶≤ÂßåÂßÅÂ¶∂Â¶ºÂßÉÂßñÂ¶±Â¶ΩÂßÄÂßàÂ¶¥ÂßáÂ≠¢Â≠•ÂÆìÂÆïÂ±ÑÂ±áÂ≤ÆÂ≤§Â≤†Â≤µÂ≤ØÂ≤®Â≤¨Â≤üÂ≤£Â≤≠Â≤¢Â≤™Â≤ßÂ≤ùÂ≤•Â≤∂Â≤∞Â≤¶Â∏óÂ∏îÂ∏ôÂº®Âº¢Âº£Âº§ÂΩîÂæÇÂΩæÂΩΩÂøûÂø•ÊÄ≠ÊÄ¶ÊÄôÊÄ≤ÊÄã"],["cca1","ÊÄ¥ÊÄäÊÄóÊÄ≥ÊÄöÊÄûÊÄ¨ÊÄ¢ÊÄçÊÄêÊÄÆÊÄìÊÄëÊÄåÊÄâÊÄúÊàîÊàΩÊä≠Êä¥ÊãëÊäæÊä™Êä∂ÊãäÊäÆÊä≥ÊäØÊäªÊä©Êä∞Êä∏ÊîΩÊñ®ÊñªÊòâÊóºÊòÑÊòíÊòàÊóªÊòÉÊòãÊòçÊòÖÊóΩÊòëÊòêÊõ∂ÊúäÊûÖÊù¨ÊûéÊûíÊù∂ÊùªÊûòÊûÜÊûÑÊù¥ÊûçÊûåÊù∫ÊûüÊûëÊûôÊûÉÊùΩÊûÅÊù∏ÊùπÊûîÊ¨•ÊÆÄÊ≠æÊØûÊ∞ùÊ≤ìÊ≥¨Ê≥´Ê≥ÆÊ≥ôÊ≤∂Ê≥îÊ≤≠Ê≥ßÊ≤∑Ê≥êÊ≥ÇÊ≤∫Ê≥ÉÊ≥ÜÊ≥≠Ê≥≤"],["cd40","Ê≥íÊ≥ùÊ≤¥Ê≤äÊ≤ùÊ≤ÄÊ≥ûÊ≥ÄÊ¥∞Ê≥çÊ≥áÊ≤∞Ê≥πÊ≥èÊ≥©Ê≥ëÁÇîÁÇòÁÇÖÁÇìÁÇÜÁÇÑÁÇëÁÇñÁÇÇÁÇöÁÇÉÁâ™ÁãñÁããÁãòÁãâÁãúÁãíÁãîÁãöÁãåÁãëÁé§Áé°Áé≠Áé¶Áé¢Áé†Áé¨ÁéùÁìùÁì®ÁîøÁïÄÁîæÁñåÁñòÁöØÁõ≥Áõ±Áõ∞ÁõµÁü∏ÁüºÁüπÁüªÁü∫"],["cda1","Áü∑Á•ÇÁ§øÁßÖÁ©∏Á©ªÁ´ªÁ±µÁ≥ΩËÄµËÇèËÇÆËÇ£ËÇ∏ËÇµËÇ≠Ëà†Ëä†ËãÄËä´ËäöËäòËäõËäµËäßËäÆËäºËäûËä∫Ëä¥Ëä®Ëä°Ëä©ËãÇËä§ËãÉËä∂Ëä¢Ëô∞ËôØËô≠ËôÆË±ñËøíËøãËøìËøçËøñËøïËøóÈÇ≤ÈÇ¥ÈÇØÈÇ≥ÈÇ∞ÈòπÈòΩÈòºÈò∫ÈôÉ‰øç‰øÖ‰øì‰æ≤‰øâ‰øã‰øÅ‰øî‰øú‰øô‰æª‰æ≥‰øõ‰øá‰øñ‰æ∫‰øÄ‰æπ‰ø¨ÂâÑÂââÂãÄÂãÇÂåΩÂçºÂéóÂéñÂéôÂéòÂí∫Âí°Âí≠Âí•Âìè"],["ce40","ÂìÉËåçÂí∑ÂíÆÂìñÂí∂ÂìÖÂìÜÂí†Âë∞ÂíºÂí¢ÂíæÂë≤ÂìûÂí∞ÂûµÂûûÂûüÂû§ÂûåÂûóÂûùÂûõÂûîÂûòÂûèÂûôÂû•ÂûöÂûïÂ£¥Â§çÂ•ìÂß°ÂßûÂßÆÂ®ÄÂß±ÂßùÂß∫ÂßΩÂßºÂß∂Âß§Âß≤Âß∑ÂßõÂß©Âß≥ÂßµÂß†ÂßæÂß¥Âß≠ÂÆ®Â±åÂ≥êÂ≥òÂ≥åÂ≥óÂ≥ãÂ≥õ"],["cea1","Â≥ûÂ≥öÂ≥âÂ≥áÂ≥äÂ≥ñÂ≥ìÂ≥îÂ≥èÂ≥àÂ≥ÜÂ≥éÂ≥üÂ≥∏Â∑πÂ∏°Â∏¢Â∏£Â∏†Â∏§Â∫∞Â∫§Â∫¢Â∫õÂ∫£Â∫•ÂºáÂºÆÂΩñÂæÜÊÄ∑ÊÄπÊÅîÊÅ≤ÊÅûÊÅÖÊÅìÊÅáÊÅâÊÅõÊÅåÊÅÄÊÅÇÊÅüÊÄ§ÊÅÑÊÅòÊÅ¶ÊÅÆÊâÇÊâÉÊãèÊåçÊåãÊãµÊåéÊåÉÊã´ÊãπÊåèÊååÊã∏Êã∂ÊåÄÊåìÊåîÊã∫ÊåïÊãªÊã∞ÊïÅÊïÉÊñ™ÊñøÊò∂Êò°Êò≤ÊòµÊòúÊò¶Êò¢Êò≥Êò´Êò∫ÊòùÊò¥ÊòπÊòÆÊúèÊúêÊüÅÊü≤ÊüàÊû∫"],["cf40","ÊüúÊûªÊü∏ÊüòÊüÄÊû∑ÊüÖÊü´Êü§ÊüüÊûµÊüçÊû≥Êü∑Êü∂ÊüÆÊü£ÊüÇÊûπÊüéÊüßÊü∞Êû≤ÊüºÊüÜÊü≠ÊüåÊûÆÊü¶ÊüõÊü∫ÊüâÊüäÊüÉÊü™ÊüãÊ¨®ÊÆÇÊÆÑÊÆ∂ÊØñÊØòÊØ†Ê∞†Ê∞°Ê¥®Ê¥¥Ê¥≠Ê¥üÊ¥ºÊ¥øÊ¥íÊ¥äÊ≥öÊ¥≥Ê¥ÑÊ¥ôÊ¥∫Ê¥öÊ¥ëÊ¥ÄÊ¥ùÊµÇ"],["cfa1","Ê¥ÅÊ¥òÊ¥∑Ê¥ÉÊ¥èÊµÄÊ¥áÊ¥†Ê¥¨Ê¥àÊ¥¢Ê¥âÊ¥êÁÇ∑ÁÇüÁÇæÁÇ±ÁÇ∞ÁÇ°ÁÇ¥ÁÇµÁÇ©ÁâÅÁââÁâäÁâ¨Áâ∞Áâ≥ÁâÆÁãäÁã§Áã®Áã´ÁãüÁã™Áã¶Áã£ÁéÖÁèåÁèÇÁèàÁèÖÁéπÁé∂ÁéµÁé¥Áè´ÁéøÁèáÁéæÁèÉÁèÜÁé∏ÁèãÁì¨ÁìÆÁîÆÁïáÁïàÁñßÁñ™ÁôπÁõÑÁúàÁúÉÁúÑÁúÖÁúäÁõ∑ÁõªÁõ∫ÁüßÁü®Á†ÜÁ†ëÁ†íÁ†ÖÁ†êÁ†èÁ†éÁ†âÁ†ÉÁ†ìÁ•äÁ•åÁ•ãÁ•ÖÁ•ÑÁßïÁßçÁßèÁßñÁßéÁ™Ä"],["d040","Á©æÁ´ëÁ¨ÄÁ¨ÅÁ±∫Á±∏Á±πÁ±øÁ≤ÄÁ≤ÅÁ¥ÉÁ¥àÁ¥ÅÁΩòÁæëÁæçÁææËÄáËÄéËÄèËÄîËÄ∑ËÉòËÉáËÉ†ËÉëËÉàËÉÇËÉêËÉÖËÉ£ËÉôËÉúËÉäËÉïËÉâËÉèËÉóËÉ¶ËÉçËáøËà°ËäîËãôËãæËãπËåáËã®ËåÄËãïËå∫Ëã´ËãñËã¥Ëã¨Ëã°Ëã≤ËãµËååËãªËã∂Ëã∞Ëã™"],["d0a1","Ëã§Ëã†Ëã∫Ëã≥Ëã≠Ëô∑Ëô¥ËôºËô≥Ë°ÅË°éË°ßË°™Ë°©ËßìË®ÑË®áËµ≤Ëø£Ëø°ËøÆËø†ÈÉ±ÈÇΩÈÇøÈÉïÈÉÖÈÇæÈÉáÈÉãÈÉàÈáîÈáìÈôîÈôèÈôëÈôìÈôäÈôéÂÄûÂÄÖÂÄáÂÄìÂÄ¢ÂÄ∞ÂÄõ‰øµ‰ø¥ÂÄ≥ÂÄ∑ÂÄ¨‰ø∂‰ø∑ÂÄóÂÄúÂÄ†ÂÄßÂÄµÂÄØÂÄ±ÂÄéÂÖöÂÜîÂÜìÂáäÂáÑÂáÖÂáàÂáéÂâ°ÂâöÂâíÂâûÂâüÂâïÂâ¢ÂãçÂåéÂéûÂî¶Âì¢ÂîóÂîíÂìßÂì≥Âì§ÂîöÂìøÂîÑÂîàÂì´ÂîëÂîÖÂì±"],["d140","ÂîäÂìªÂì∑Âì∏Âì†ÂîéÂîÉÂîãÂúÅÂúÇÂüåÂ†≤ÂüïÂüíÂû∫ÂüÜÂûΩÂûºÂû∏Âû∂ÂûøÂüáÂüêÂûπÂüÅÂ§éÂ•äÂ®ôÂ®ñÂ®≠Â®ÆÂ®ïÂ®èÂ®óÂ®äÂ®ûÂ®≥Â≠¨ÂÆßÂÆ≠ÂÆ¨Â∞ÉÂ±ñÂ±îÂ≥¨Â≥øÂ≥ÆÂ≥±Â≥∑Â¥ÄÂ≥πÂ∏©Â∏®Â∫®Â∫ÆÂ∫™Â∫¨Âº≥Âº∞ÂΩßÊÅùÊÅöÊÅß"],["d1a1","ÊÅÅÊÇ¢ÊÇàÊÇÄÊÇíÊÇÅÊÇùÊÇÉÊÇïÊÇõÊÇóÊÇáÊÇúÊÇéÊàôÊâÜÊã≤ÊåêÊçñÊå¨ÊçÑÊçÖÊå∂ÊçÉÊè§ÊåπÊçãÊçäÊåºÊå©ÊçÅÊå¥ÊçòÊçîÊçôÊå≠ÊçáÊå≥ÊçöÊçëÊå∏ÊçóÊçÄÊçàÊïäÊïÜÊóÜÊóÉÊóÑÊóÇÊôäÊôüÊôáÊôëÊúíÊúìÊ†üÊ†öÊ°âÊ†≤Ê†≥Ê†ªÊ°ãÊ°èÊ†ñÊ†±Ê†úÊ†µÊ†´Ê†≠Ê†ØÊ°éÊ°ÑÊ†¥Ê†ùÊ†íÊ†îÊ†¶Ê†®Ê†ÆÊ°çÊ†∫Ê†•Ê††Ê¨¨Ê¨ØÊ¨≠Ê¨±Ê¨¥Ê≠≠ËÇÇÊÆàÊØ¶ÊØ§"],["d240","ÊØ®ÊØ£ÊØ¢ÊØßÊ∞•Êµ∫Êµ£Êµ§Êµ∂Ê¥çÊµ°Ê∂íÊµòÊµ¢Êµ≠ÊµØÊ∂ëÊ∂çÊ∑ØÊµøÊ∂ÜÊµûÊµßÊµ†Ê∂óÊµ∞ÊµºÊµüÊ∂ÇÊ∂òÊ¥ØÊµ®Ê∂ãÊµæÊ∂ÄÊ∂ÑÊ¥ñÊ∂ÉÊµªÊµΩÊµµÊ∂êÁÉúÁÉìÁÉëÁÉùÁÉãÁºπÁÉ¢ÁÉóÁÉíÁÉûÁÉ†ÁÉîÁÉçÁÉÖÁÉÜÁÉáÁÉöÁÉéÁÉ°ÁâÇÁâ∏"],["d2a1","Áâ∑Áâ∂ÁåÄÁã∫Áã¥ÁãæÁã∂Áã≥ÁãªÁåÅÁèìÁèôÁè•ÁèñÁéºÁèßÁè£Áè©ÁèúÁèíÁèõÁèîÁèùÁèöÁèóÁèòÁè®ÁìûÁìüÁì¥ÁìµÁî°ÁïõÁïüÁñ∞ÁóÅÁñªÁóÑÁóÄÁñøÁñ∂Áñ∫ÁöäÁõâÁúùÁúõÁúêÁúìÁúíÁú£ÁúëÁúïÁúôÁúöÁú¢ÁúßÁ†£Á†¨Á†¢Á†µÁ†ØÁ†®Á†ÆÁ†´Á†°Á†©Á†≥Á†™Á†±Á•îÁ•õÁ•èÁ•úÁ•ìÁ•íÁ•ëÁß´Áß¨Áß†ÁßÆÁß≠Áß™ÁßúÁßûÁßùÁ™ÜÁ™âÁ™ÖÁ™ãÁ™åÁ™äÁ™áÁ´òÁ¨ê"],["d340","Á¨ÑÁ¨ìÁ¨ÖÁ¨èÁ¨àÁ¨äÁ¨éÁ¨âÁ¨íÁ≤ÑÁ≤ëÁ≤äÁ≤åÁ≤àÁ≤çÁ≤ÖÁ¥ûÁ¥ùÁ¥ëÁ¥éÁ¥òÁ¥ñÁ¥ìÁ¥üÁ¥íÁ¥èÁ¥åÁΩúÁΩ°ÁΩûÁΩ†ÁΩùÁΩõÁæñÁæíÁøÉÁøÇÁøÄËÄñËÄæËÄπËÉ∫ËÉ≤ËÉπËÉµËÑÅËÉªËÑÄËàÅËàØËà•Ëå≥Ëå≠ËçÑËåôËçëËå•ËçñËåøËçÅËå¶ËåúËå¢"],["d3a1","ËçÇËçéËåõËå™ËåàËåºËççËåñËå§Ëå†Ëå∑ËåØËå©ËçáËçÖËçåËçìËåûËå¨ËçãËåßËçàËôìËôíËö¢Ëö®ËöñËöçËöëËöûËöáËöóËöÜËöãËööËöÖËö•ËöôËö°ËößËöïËöòËöéËöùËöêËöîË°ÉË°ÑË°≠Ë°µË°∂Ë°≤Ë¢ÄË°±Ë°øË°ØË¢ÉË°æË°¥Ë°ºË®íË±áË±óË±ªË≤§Ë≤£Ëµ∂Ëµ∏Ë∂µË∂∑Ë∂∂ËªëËªìËøæËøµÈÄÇËøøËøªÈÄÑËøºËø∂ÈÉñÈÉ†ÈÉôÈÉöÈÉ£ÈÉüÈÉ•ÈÉòÈÉõÈÉóÈÉúÈÉ§ÈÖê"],["d440","ÈÖéÈÖèÈáïÈá¢ÈáöÈôúÈôüÈöºÈ££È´üÈ¨Ø‰πøÂÅ∞ÂÅ™ÂÅ°ÂÅûÂÅ†ÂÅìÂÅãÂÅùÂÅ≤ÂÅàÂÅçÂÅÅÂÅõÂÅäÂÅ¢ÂÄïÂÅÖÂÅüÂÅ©ÂÅ´ÂÅ£ÂÅ§ÂÅÜÂÅÄÂÅÆÂÅ≥ÂÅóÂÅëÂáêÂâ´Ââ≠Ââ¨ÂâÆÂãñÂãìÂå≠ÂéúÂïµÂï∂ÂîºÂïçÂïêÂî¥Âî™ÂïëÂï¢Âî∂ÂîµÂî∞ÂïíÂïÖ"],["d4a1","ÂîåÂî≤Âï•ÂïéÂîπÂïàÂî≠ÂîªÂïÄÂïãÂúäÂúáÂüªÂ†îÂü¢Âü∂ÂüúÂü¥Â†ÄÂü≠ÂüΩÂ†àÂü∏Â†ãÂü≥ÂüèÂ†áÂüÆÂü£Âü≤Âü•Âü¨Âü°Â†éÂüºÂ†êÂüßÂ†ÅÂ†åÂü±Âü©Âü∞Â†çÂ†ÑÂ•úÂ©†Â©òÂ©ïÂ©ßÂ©ûÂ®∏Â®µÂ©≠Â©êÂ©üÂ©•Â©¨Â©ìÂ©§Â©óÂ©ÉÂ©ùÂ©íÂ©ÑÂ©õÂ©àÂ™éÂ®æÂ©çÂ®πÂ©åÂ©∞Â©©Â©áÂ©ëÂ©ñÂ©ÇÂ©úÂ≠≤Â≠ÆÂØÅÂØÄÂ±ôÂ¥ûÂ¥ãÂ¥ùÂ¥öÂ¥†Â¥åÂ¥®Â¥çÂ¥¶Â¥•Â¥è"],["d540","Â¥∞Â¥íÂ¥£Â¥üÂ¥ÆÂ∏æÂ∏¥Â∫±Â∫¥Â∫πÂ∫≤Â∫≥Âº∂Âº∏ÂæõÂæñÂæüÊÇäÊÇêÊÇÜÊÇæÊÇ∞ÊÇ∫ÊÉìÊÉîÊÉèÊÉ§ÊÉôÊÉùÊÉàÊÇ±ÊÉõÊÇ∑ÊÉäÊÇøÊÉÉÊÉçÊÉÄÊå≤Êç•ÊéäÊéÇÊçΩÊéΩÊéûÊé≠ÊéùÊéóÊé´ÊééÊçØÊéáÊéêÊçÆÊéØÊçµÊéúÊç≠ÊéÆÊçºÊé§ÊåªÊéü"],["d5a1","Êç∏ÊéÖÊéÅÊéëÊéçÊç∞ÊïìÊóçÊô•Êô°ÊôõÊôôÊôúÊô¢ÊúòÊ°πÊ¢áÊ¢êÊ¢úÊ°≠Ê°ÆÊ¢ÆÊ¢´Ê•ñÊ°ØÊ¢£Ê¢¨Ê¢©Ê°µÊ°¥Ê¢≤Ê¢èÊ°∑Ê¢íÊ°ºÊ°´Ê°≤Ê¢™Ê¢ÄÊ°±Ê°æÊ¢õÊ¢ñÊ¢ãÊ¢†Ê¢âÊ¢§Ê°∏Ê°ªÊ¢ëÊ¢åÊ¢äÊ°ΩÊ¨∂Ê¨≥Ê¨∑Ê¨∏ÊÆëÊÆèÊÆçÊÆéÊÆåÊ∞™Ê∑ÄÊ∂´Ê∂¥Ê∂≥Êπ¥Ê∂¨Ê∑©Ê∑¢Ê∂∑Ê∑∂Ê∑îÊ∏ÄÊ∑àÊ∑†Ê∑üÊ∑ñÊ∂æÊ∑•Ê∑úÊ∑ùÊ∑õÊ∑¥Ê∑äÊ∂ΩÊ∑≠Ê∑∞Ê∂∫Ê∑ïÊ∑ÇÊ∑èÊ∑â"],["d640","Ê∑êÊ∑≤Ê∑ìÊ∑ΩÊ∑óÊ∑çÊ∑£Ê∂ªÁÉ∫ÁÑçÁÉ∑ÁÑóÁÉ¥ÁÑåÁÉ∞ÁÑÑÁÉ≥ÁÑêÁÉºÁÉøÁÑÜÁÑìÁÑÄÁÉ∏ÁÉ∂ÁÑãÁÑÇÁÑéÁâæÁâªÁâºÁâøÁåùÁåóÁåáÁåëÁåòÁåäÁåàÁãøÁåèÁåûÁéàÁè∂Áè∏ÁèµÁêÑÁêÅÁèΩÁêáÁêÄÁè∫ÁèºÁèøÁêåÁêãÁè¥ÁêàÁï§Áï£ÁóéÁóíÁóè"],["d6a1","ÁóãÁóåÁóëÁóêÁöèÁöâÁõìÁúπÁúØÁú≠Áú±Áú≤Áú¥Áú≥ÁúΩÁú•ÁúªÁúµÁ°àÁ°íÁ°âÁ°çÁ°äÁ°åÁ†¶Á°ÖÁ°êÁ•§Á•ßÁ•©Á•™Á•£Á•´Á•°Á¶ªÁß∫Áß∏Áß∂Áß∑Á™èÁ™îÁ™êÁ¨µÁ≠áÁ¨¥Á¨•Á¨∞Á¨¢Á¨§Á¨≥Á¨òÁ¨™Á¨ùÁ¨±Á¨´Á¨≠Á¨ØÁ¨≤Á¨∏Á¨öÁ¨£Á≤îÁ≤òÁ≤ñÁ≤£Á¥µÁ¥ΩÁ¥∏Á¥∂Á¥∫ÁµÖÁ¥¨Á¥©ÁµÅÁµáÁ¥æÁ¥øÁµäÁ¥ªÁ¥®ÁΩ£ÁæïÁæúÁæùÁæõÁøäÁøãÁøçÁøêÁøëÁøáÁøèÁøâËÄü"],["d740","ËÄûËÄõËÅáËÅÉËÅàËÑòËÑ•ËÑôËÑõËÑ≠ËÑüËÑ¨ËÑûËÑ°ËÑïËÑßËÑùËÑ¢ËàëËà∏Ëà≥Ëà∫Ëà¥Ëà≤Ëâ¥ËéêËé£Ëé®ËéçËç∫Ëç≥Ëé§Ëç¥ËéèËéÅËéïËéôËçµËéîËé©ËçΩËéÉËéåËéùËéõËé™ËéãËçæËé•ËéØËéàËéóËé∞ËçøËé¶ËéáËéÆËç∂ËéöËôôËôñËöøËö∑"],["d7a1","ËõÇËõÅËõÖËö∫Ëö∞ËõàËöπËö≥Ëö∏ËõåËö¥ËöªËöºËõÉËöΩËöæË°íË¢âË¢ïË¢®Ë¢¢Ë¢™Ë¢öË¢ëË¢°Ë¢üË¢òË¢ßË¢ôË¢õË¢óË¢§Ë¢¨Ë¢åË¢ìË¢éË¶ÇËßñËßôËßïË®∞Ë®ßË®¨Ë®ûË∞πË∞ªË±úË±ùË±ΩË≤•ËµΩËµªËµπË∂ºË∑ÇË∂πË∂øË∑ÅËªòËªûËªùËªúËªóËª†Ëª°ÈÄ§ÈÄãÈÄëÈÄúÈÄåÈÄ°ÈÉØÈÉ™ÈÉ∞ÈÉ¥ÈÉ≤ÈÉ≥ÈÉîÈÉ´ÈÉ¨ÈÉ©ÈÖñÈÖòÈÖöÈÖìÈÖïÈá¨Èá¥Èá±Èá≥Èá∏Èá§ÈáπÈá™"],["d840","Èá´Èá∑Èá®ÈáÆÈï∫ÈñÜÈñàÈôºÈô≠Èô´Èô±ÈôØÈöøÈù™È†ÑÈ£•È¶óÂÇõÂÇïÂÇîÂÇûÂÇãÂÇ£ÂÇÉÂÇåÂÇéÂÇùÂÅ®ÂÇúÂÇíÂÇÇÂÇáÂÖüÂáîÂåíÂåëÂé§ÂéßÂñëÂñ®Âñ•Âñ≠Âï∑ÂôÖÂñ¢ÂñìÂñàÂñèÂñµÂñÅÂñ£ÂñíÂñ§ÂïΩÂñåÂñ¶ÂïøÂñïÂñ°ÂñéÂúåÂ†©Â†∑"],["d8a1","Â†ôÂ†ûÂ†ßÂ†£Â†®ÂüµÂ°àÂ†•Â†úÂ†õÂ†≥Â†øÂ†∂Â†ÆÂ†πÂ†∏Â†≠Â†¨Â†ªÂ•°Â™ØÂ™îÂ™üÂ©∫Â™¢Â™ûÂ©∏Â™¶Â©ºÂ™•Â™¨Â™ïÂ™ÆÂ®∑Â™ÑÂ™äÂ™óÂ™ÉÂ™ãÂ™©Â©ªÂ©ΩÂ™åÂ™úÂ™èÂ™ìÂ™ùÂØ™ÂØçÂØãÂØîÂØëÂØäÂØéÂ∞åÂ∞∞Â¥∑ÂµÉÂµ´ÂµÅÂµãÂ¥øÂ¥µÂµëÂµéÂµïÂ¥≥Â¥∫ÂµíÂ¥ΩÂ¥±ÂµôÂµÇÂ¥πÂµâÂ¥∏Â¥ºÂ¥≤Â¥∂ÂµÄÂµÖÂπÑÂπÅÂΩòÂæ¶Âæ•Âæ´ÊÉâÊÇπÊÉåÊÉ¢ÊÉéÊÉÑÊÑî"],["d940","ÊÉ≤ÊÑäÊÑñÊÑÖÊÉµÊÑìÊÉ∏ÊÉºÊÉæÊÉÅÊÑÉÊÑòÊÑùÊÑêÊÉøÊÑÑÊÑãÊâäÊéîÊé±Êé∞ÊèéÊè•Êè®ÊèØÊèÉÊíùÊè≥ÊèäÊè†Êè∂ÊèïÊè≤ÊèµÊë°ÊèüÊéæÊèùÊèúÊèÑÊèòÊèìÊèÇÊèáÊèåÊèãÊèàÊè∞ÊèóÊèôÊî≤ÊïßÊï™Êï§ÊïúÊï®Êï•ÊñåÊñùÊñûÊñÆÊóêÊóí"],["d9a1","ÊôºÊô¨ÊôªÊöÄÊô±ÊôπÊô™Êô≤ÊúÅÊ§åÊ£ìÊ§ÑÊ£úÊ§™Ê£¨Ê£™Ê£±Ê§èÊ£ñÊ£∑Ê£´Ê£§Ê£∂Ê§ìÊ§êÊ£≥Ê£°Ê§áÊ£åÊ§àÊ•∞Ê¢¥Ê§ëÊ£ØÊ£ÜÊ§îÊ£∏Ê£êÊ£ΩÊ£ºÊ£®Ê§ãÊ§äÊ§óÊ£éÊ£àÊ£ùÊ£ûÊ£¶Ê£¥Ê£ëÊ§ÜÊ£îÊ£©Ê§ïÊ§•Ê£áÊ¨πÊ¨ªÊ¨øÊ¨ºÊÆîÊÆóÊÆôÊÆïÊÆΩÊØ∞ÊØ≤ÊØ≥Ê∞∞Ê∑ºÊπÜÊπáÊ∏üÊπâÊ∫àÊ∏ºÊ∏ΩÊπÖÊπ¢Ê∏´Ê∏øÊπÅÊπùÊπ≥Ê∏úÊ∏≥ÊπãÊπÄÊπëÊ∏ªÊ∏ÉÊ∏ÆÊπû"],["da40","Êπ®ÊπúÊπ°Ê∏±Ê∏®Êπ†Êπ±Êπ´Ê∏πÊ∏¢Ê∏∞ÊπìÊπ•Ê∏ßÊπ∏Êπ§Êπ∑ÊπïÊππÊπíÊπ¶Ê∏µÊ∏∂ÊπöÁÑ†ÁÑûÁÑØÁÉªÁÑÆÁÑ±ÁÑ£ÁÑ•ÁÑ¢ÁÑ≤ÁÑüÁÑ®ÁÑ∫ÁÑõÁâãÁâöÁäàÁäâÁäÜÁäÖÁäãÁåíÁåãÁå∞Áå¢Áå±Áå≥ÁåßÁå≤Áå≠Áå¶Áå£ÁåµÁååÁêÆÁê¨Áê∞Áê´Áêñ"],["daa1","ÁêöÁê°Áê≠Áê±Áê§Áê£ÁêùÁê©Áê†Áê≤ÁìªÁîØÁïØÁï¨ÁóßÁóöÁó°Áó¶ÁóùÁóüÁó§ÁóóÁöïÁöíÁõöÁùÜÁùáÁùÑÁùçÁùÖÁùäÁùéÁùãÁùåÁüûÁü¨Á°†Á°§Á°•Á°úÁ°≠Á°±Á°™Á°ÆÁ°∞Á°©Á°®Á°ûÁ°¢Á•¥Á•≥Á•≤Á•∞Á®ÇÁ®äÁ®ÉÁ®åÁ®ÑÁ™ôÁ´¶Á´§Á≠äÁ¨ªÁ≠ÑÁ≠àÁ≠åÁ≠éÁ≠ÄÁ≠òÁ≠ÖÁ≤¢Á≤ûÁ≤®Á≤°ÁµòÁµØÁµ£ÁµìÁµñÁµßÁµ™ÁµèÁµ≠ÁµúÁµ´ÁµíÁµîÁµ©ÁµëÁµüÁµéÁºæÁºøÁΩ•"],["db40","ÁΩ¶Áæ¢Áæ†Áæ°ÁøóËÅëËÅèËÅêËÉæËÉîËÖÉËÖäËÖíËÖèËÖáËÑΩËÖçËÑ∫Ëá¶ËáÆËá∑Ëá∏ËáπËàÑËàºËàΩËàøËâµËåªËèèËèπËê£ËèÄËè®ËêíËèßËè§ËèºËè∂ËêêËèÜËèàËè´Ëè£ËéøËêÅËèùËè•ËèòËèøËè°ËèãËèéËèñËèµËèâËêâËêèËèûËêëËêÜËèÇËè≥"],["dba1","ËèïËè∫ËèáËèëËè™ËêìËèÉËè¨ËèÆËèÑËèªËèóËè¢ËêõËèõËèæËõòËõ¢Ëõ¶ËõìËõ£ËõöËõ™ËõùËõ´ËõúËõ¨Ëõ©ËõóËõ®ËõëË°àË°ñË°ïË¢∫Ë£óË¢πË¢∏Ë£ÄË¢æË¢∂Ë¢ºË¢∑Ë¢ΩË¢≤Ë§ÅË£âË¶ïË¶òË¶óËßùËßöËßõË©éË©çË®πË©ôË©ÄË©óË©òË©ÑË©ÖË©íË©àË©ëË©äË©åË©èË±üË≤ÅË≤ÄË≤∫Ë≤æË≤∞Ë≤πË≤µË∂ÑË∂ÄË∂âË∑òË∑ìË∑çË∑áË∑ñË∑úË∑èË∑ïË∑ôË∑àË∑óË∑ÖËªØËª∑Ëª∫"],["dc40","ËªπËª¶ËªÆËª•ËªµËªßËª®Ëª∂Ëª´Ëª±Ëª¨Ëª¥Ëª©ÈÄ≠ÈÄ¥ÈÄØÈÑÜÈÑ¨ÈÑÑÈÉøÈÉºÈÑàÈÉπÈÉªÈÑÅÈÑÄÈÑáÈÑÖÈÑÉÈÖ°ÈÖ§ÈÖüÈÖ¢ÈÖ†ÈàÅÈàäÈà•ÈàÉÈàöÈà¶ÈàèÈàåÈàÄÈàíÈáøÈáΩÈàÜÈàÑÈàßÈàÇÈàúÈà§ÈàôÈàóÈàÖÈàñÈïªÈñçÈñåÈñêÈöáÈôæÈöà"],["dca1","ÈöâÈöÉÈöÄÈõÇÈõàÈõÉÈõ±Èõ∞Èù¨Èù∞ÈùÆÈ†áÈ¢©È£´È≥¶Èªπ‰∫É‰∫Ñ‰∫∂ÂÇΩÂÇøÂÉÜÂÇÆÂÉÑÂÉäÂÇ¥ÂÉàÂÉÇÂÇ∞ÂÉÅÂÇ∫ÂÇ±ÂÉãÂÉâÂÇ∂ÂÇ∏ÂáóÂâ∫Ââ∏ÂâªÂâºÂóÉÂóõÂóåÂóêÂóãÂóäÂóùÂóÄÂóîÂóÑÂó©ÂñøÂóíÂñçÂóèÂóïÂó¢ÂóñÂóàÂó≤ÂóçÂóôÂóÇÂúîÂ°ìÂ°®Â°§Â°èÂ°çÂ°âÂ°ØÂ°ïÂ°éÂ°ùÂ°ôÂ°•Â°õÂ†ΩÂ°£Â°±Â£ºÂ´áÂ´ÑÂ´ãÂ™∫Â™∏Â™±Â™µÂ™∞Â™øÂ´àÂ™ªÂ´Ü"],["dd40","Â™∑Â´ÄÂ´äÂ™¥Â™∂Â´çÂ™πÂ™êÂØñÂØòÂØôÂ∞üÂ∞≥Âµ±Âµ£ÂµäÂµ•Âµ≤Âµ¨ÂµûÂµ®ÂµßÂµ¢Â∑∞ÂπèÂπéÂπäÂπçÂπãÂªÖÂªåÂªÜÂªãÂªáÂΩÄÂæØÂæ≠ÊÉ∑ÊÖâÊÖäÊÑ´ÊÖÖÊÑ∂ÊÑ≤ÊÑÆÊÖÜÊÑØÊÖèÊÑ©ÊÖÄÊà†ÈÖ®Êà£Êà•Êà§ÊèÖÊè±Êè´ÊêêÊêíÊêâÊê†Êê§"],["dda1","Êê≥ÊëÉÊêüÊêïÊêòÊêπÊê∑Êê¢Êê£ÊêåÊê¶Êê∞Êê®ÊëÅÊêµÊêØÊêäÊêöÊëÄÊê•ÊêßÊêãÊèßÊêõÊêÆÊê°ÊêéÊïØÊñíÊóìÊöÜÊöåÊöïÊöêÊöãÊöäÊöôÊöîÊô∏Êú†Ê•¶Ê•üÊ§∏Ê•éÊ•¢Ê•±Ê§øÊ•ÖÊ•™Ê§πÊ•ÇÊ•óÊ•ôÊ•∫Ê•àÊ•âÊ§µÊ•¨Ê§≥Ê§ΩÊ••Ê£∞Ê•∏Ê§¥Ê•©Ê•ÄÊ•ØÊ•ÑÊ•∂Ê•òÊ•ÅÊ•¥Ê•åÊ§ªÊ•ãÊ§∑Ê•úÊ•èÊ•ëÊ§≤Ê•íÊ§ØÊ•ªÊ§ºÊ≠ÜÊ≠ÖÊ≠ÉÊ≠ÇÊ≠àÊ≠ÅÊÆõÔ®çÊØªÊØº"],["de40","ÊØπÊØ∑ÊØ∏Ê∫õÊªñÊªàÊ∫èÊªÄÊ∫üÊ∫ìÊ∫îÊ∫†Ê∫±Ê∫πÊªÜÊªíÊ∫ΩÊªÅÊ∫ûÊªâÊ∫∑Ê∫∞ÊªçÊ∫¶ÊªèÊ∫≤Ê∫æÊªÉÊªúÊªòÊ∫ôÊ∫íÊ∫éÊ∫çÊ∫§Ê∫°Ê∫øÊ∫≥ÊªêÊªäÊ∫óÊ∫ÆÊ∫£ÁÖáÁÖîÁÖíÁÖ£ÁÖ†ÁÖÅÁÖùÁÖ¢ÁÖ≤ÁÖ∏ÁÖ™ÁÖ°ÁÖÇÁÖòÁÖÉÁÖãÁÖ∞ÁÖüÁÖêÁÖì"],["dea1","ÁÖÑÁÖçÁÖöÁâèÁäçÁäåÁäëÁäêÁäéÁåºÁçÇÁåªÁå∫ÁçÄÁçäÁçâÁëÑÁëäÁëãÁëíÁëëÁëóÁëÄÁëèÁëêÁëéÁëÇÁëÜÁëçÁëîÁì°ÁìøÁìæÁìΩÁîùÁïπÁï∑Ê¶ÉÁóØÁòèÁòÉÁó∑ÁóæÁóºÁóπÁó∏ÁòêÁóªÁó∂Áó≠ÁóµÁóΩÁöôÁöµÁõùÁùïÁùüÁù†ÁùíÁùñÁùöÁù©ÁùßÁùîÁùôÁù≠Áü†Á¢áÁ¢öÁ¢îÁ¢èÁ¢ÑÁ¢ïÁ¢ÖÁ¢ÜÁ¢°Á¢ÉÁ°πÁ¢ôÁ¢ÄÁ¢ñÁ°ªÁ•ºÁ¶ÇÁ•ΩÁ•πÁ®ëÁ®òÁ®ôÁ®íÁ®óÁ®ïÁ®¢Á®ì"],["df40","Á®õÁ®êÁ™£Á™¢Á™ûÁ´´Á≠¶Á≠§Á≠≠Á≠¥Á≠©Á≠≤Á≠•Á≠≥Á≠±Á≠∞Á≠°Á≠∏Á≠∂Á≠£Á≤≤Á≤¥Á≤ØÁ∂àÁ∂ÜÁ∂ÄÁ∂çÁµøÁ∂ÖÁµ∫Á∂éÁµªÁ∂ÉÁµºÁ∂åÁ∂îÁ∂ÑÁµΩÁ∂íÁΩ≠ÁΩ´ÁΩßÁΩ®ÁΩ¨Áæ¶Áæ•ÁæßÁøõÁøúËÄ°ËÖ§ËÖ†ËÖ∑ËÖúËÖ©ËÖõËÖ¢ËÖ≤Êú°ËÖûËÖ∂ËÖßËÖØ"],["dfa1","ËÖÑËÖ°ËàùËââËâÑËâÄËâÇËâÖËì±ËêøËëñËë∂ËëπËíèËíçËë•ËëëËëÄËíÜËëßËê∞ËëçËëΩËëöËëôËë¥Ëë≥ËëùËîáËëûËê∑Ëê∫Ëê¥Ëë∫ËëÉËë∏Ëê≤ËëÖËê©ËèôËëãËêØËëÇËê≠ËëüËë∞ËêπËëéËëåËëíËëØËìÖËíéËêªËëáËê∂Ëê≥Ëë®ËëæËëÑËê´Ëë†ËëîËëÆËëêËúãËúÑËõ∑ËúåËõ∫ËõñËõµËùçËõ∏ËúéËúâËúÅËõ∂ËúçËúÖË£ñË£ãË£çË£éË£ûË£õË£öË£åË£êË¶ÖË¶õËßüËß•Ëß§"],["e040","Ëß°Ëß†Ëß¢ËßúËß¶Ë©∂Ë™ÜË©øË©°Ë®øË©∑Ë™ÇË™ÑË©µË™ÉË™ÅË©¥Ë©∫Ë∞ºË±ãË±äË±•Ë±§Ë±¶Ë≤ÜË≤ÑË≤ÖË≥åËµ®Ëµ©Ë∂ëË∂åË∂éË∂èË∂çË∂ìË∂îË∂êË∂íË∑∞Ë∑†Ë∑¨Ë∑±Ë∑ÆË∑êË∑©Ë∑£Ë∑¢Ë∑ßË∑≤Ë∑´Ë∑¥ËºÜËªøËºÅËºÄËºÖËºáËºàËºÇËºãÈÅíÈÄø"],["e0a1","ÈÅÑÈÅâÈÄΩÈÑêÈÑçÈÑèÈÑëÈÑñÈÑîÈÑãÈÑéÈÖÆÈÖØÈâàÈâíÈà∞Èà∫Èâ¶Èà≥Èâ•ÈâûÈäÉÈàÆÈâäÈâÜÈâ≠Èâ¨ÈâèÈâ†ÈâßÈâØÈà∂Èâ°Èâ∞Èà±ÈâîÈâ£ÈâêÈâ≤ÈâéÈâìÈâåÈâñÈà≤ÈñüÈñúÈñûÈñõÈöíÈöìÈöëÈöóÈõéÈõ∫ÈõΩÈõ∏ÈõµÈù≥Èù∑Èù∏Èù≤È†èÈ†çÈ†éÈ¢¨È£∂È£πÈ¶ØÈ¶≤È¶∞È¶µÈ™≠È™´È≠õÈ≥™È≥≠È≥ßÈ∫ÄÈªΩÂÉ¶ÂÉîÂÉóÂÉ®ÂÉ≥ÂÉõÂÉ™ÂÉùÂÉ§ÂÉìÂÉ¨ÂÉ∞ÂÉØÂÉ£ÂÉ†"],["e140","ÂáòÂäÄÂäÅÂã©Âã´Âå∞Âé¨ÂòßÂòïÂòåÂòíÂóºÂòèÂòúÂòÅÂòìÂòÇÂó∫ÂòùÂòÑÂóøÂóπÂ¢âÂ°ºÂ¢êÂ¢òÂ¢ÜÂ¢ÅÂ°øÂ°¥Â¢ãÂ°∫Â¢áÂ¢ëÂ¢éÂ°∂Â¢ÇÂ¢àÂ°ªÂ¢îÂ¢èÂ£æÂ•´Â´úÂ´ÆÂ´•Â´ïÂ´™Â´öÂ´≠Â´´Â´≥Â´¢Â´†Â´õÂ´¨Â´ûÂ´ùÂ´ôÂ´®Â´üÂ≠∑ÂØ†"],["e1a1","ÂØ£Â±£Â∂ÇÂ∂ÄÂµΩÂ∂ÜÂµ∫Â∂ÅÂµ∑Â∂äÂ∂âÂ∂àÂµæÂµºÂ∂çÂµπÂµøÂπòÂπôÂπìÂªòÂªëÂªóÂªéÂªúÂªïÂªôÂªíÂªîÂΩÑÂΩÉÂΩØÂæ∂ÊÑ¨ÊÑ®ÊÖÅÊÖûÊÖ±ÊÖ≥ÊÖíÊÖìÊÖ≤ÊÖ¨ÊÜÄÊÖ¥ÊÖîÊÖ∫ÊÖõÊÖ•ÊÑªÊÖ™ÊÖ°ÊÖñÊà©ÊàßÊà´Êê´ÊëçÊëõÊëùÊë¥Êë∂Êë≤Êë≥ÊëΩÊëµÊë¶Êí¶ÊëéÊíÇÊëûÊëúÊëãÊëìÊë†ÊëêÊëøÊêøÊë¨Êë´ÊëôÊë•Êë∑Êï≥Êñ†Êö°Êö†ÊöüÊúÖÊúÑÊú¢Ê¶±Ê¶∂Êßâ"],["e240","Ê¶†ÊßéÊ¶ñÊ¶∞Ê¶¨Ê¶ºÊ¶ëÊ¶ôÊ¶éÊ¶ßÊ¶çÊ¶©Ê¶æÊ¶ØÊ¶øÊßÑÊ¶ΩÊ¶§ÊßîÊ¶πÊßäÊ¶öÊßèÊ¶≥Ê¶ìÊ¶™Ê¶°Ê¶ûÊßôÊ¶óÊ¶êÊßÇÊ¶µÊ¶•ÊßÜÊ≠äÊ≠çÊ≠ãÊÆûÊÆüÊÆ†ÊØÉÊØÑÊØæÊªéÊªµÊª±ÊºÉÊº•Êª∏Êº∑ÊªªÊºÆÊºâÊΩéÊºôÊºöÊºßÊºòÊºªÊºíÊª≠Êºä"],["e2a1","Êº∂ÊΩ≥ÊªπÊªÆÊº≠ÊΩÄÊº∞ÊººÊºµÊª´ÊºáÊºéÊΩÉÊºÖÊªΩÊª∂ÊºπÊºúÊªºÊº∫ÊºüÊºçÊºûÊºàÊº°ÁÜáÁÜêÁÜâÁÜÄÁÜÖÁÜÇÁÜèÁÖªÁÜÜÁÜÅÁÜóÁâÑÁâìÁäóÁäïÁäìÁçÉÁççÁçëÁçåÁë¢Áë≥Áë±ÁëµÁë≤ÁëßÁëÆÁîÄÁîÇÁîÉÁïΩÁñêÁòñÁòàÁòåÁòïÁòëÁòäÁòîÁö∏ÁûÅÁùºÁûÖÁûÇÁùÆÁûÄÁùØÁùæÁûÉÁ¢≤Á¢™Á¢¥Á¢≠Á¢®Á°æÁ¢´Á¢ûÁ¢•Á¢†Á¢¨Á¢¢Á¢§Á¶òÁ¶äÁ¶ãÁ¶ñÁ¶ïÁ¶îÁ¶ì"],["e340","Á¶óÁ¶àÁ¶íÁ¶êÁ®´Á©äÁ®∞Á®ØÁ®®Á®¶Á™®Á™´Á™¨Á´ÆÁÆàÁÆúÁÆäÁÆëÁÆêÁÆñÁÆçÁÆåÁÆõÁÆéÁÆÖÁÆòÂäÑÁÆôÁÆ§ÁÆÇÁ≤ªÁ≤øÁ≤ºÁ≤∫Á∂ßÁ∂∑Á∑ÇÁ∂£Á∂™Á∑ÅÁ∑ÄÁ∑ÖÁ∂ùÁ∑éÁ∑ÑÁ∑ÜÁ∑ãÁ∑åÁ∂ØÁ∂πÁ∂ñÁ∂ºÁ∂üÁ∂¶Á∂ÆÁ∂©Á∂°Á∑âÁΩ≥Áø¢Áø£Áø•Áøû"],["e3a1","ËÄ§ËÅùËÅúËÜâËÜÜËÜÉËÜáËÜçËÜåËÜãËàïËíóËí§Ëí°ËíüËí∫ËìéËìÇËí¨ËíÆËí´ËíπËí¥ËìÅËìçËí™ËíöËí±ËìêËíùËíßËíªËí¢ËíîËìáËìåËíõËí©ËíØËí®ËìñËíòËí∂ËìèËí†ËìóËìîËìíËìõËí∞ËíëËô°Ëú≥Ëú£Ëú®Ëù´ËùÄËúÆËúûËú°ËúôËúõËùÉËú¨ËùÅËúæËùÜËú†Ëú≤Ëú™Ëú≠ËúºËúíËú∫Ëú±ËúµËùÇËú¶ËúßËú∏Ëú§ËúöËú∞ËúëË£∑Ë£ßË£±Ë£≤Ë£∫Ë£æË£ÆË£ºË£∂Ë£ª"],["e440","Ë£∞Ë£¨Ë£´Ë¶ùË¶°Ë¶üË¶ûËß©Ëß´Ëß®Ë™´Ë™ôË™ãË™íË™èË™ñË∞ΩË±®Ë±©Ë≥ïË≥èË≥óË∂ñË∏âË∏ÇË∑øË∏çË∑ΩË∏äË∏ÉË∏áË∏ÜË∏ÖË∑æË∏ÄË∏ÑËºêËºëËºéËºçÈÑ£ÈÑúÈÑ†ÈÑ¢ÈÑüÈÑùÈÑöÈÑ§ÈÑ°ÈÑõÈÖ∫ÈÖ≤ÈÖπÈÖ≥Èä•Èä§Èâ∂ÈäõÈâ∫Èä†ÈäîÈä™Èäç"],["e4a1","Èä¶ÈäöÈä´ÈâπÈäóÈâøÈä£ÈãÆÈäéÈäÇÈäïÈä¢ÈâΩÈäàÈä°ÈääÈäÜÈäåÈäôÈäßÈâæÈäáÈä©ÈäùÈäãÈà≠ÈöûÈö°ÈõøÈùòÈùΩÈù∫ÈùæÈûÉÈûÄÈûÇÈùªÈûÑÈûÅÈùøÈüéÈüçÈ†ñÈ¢≠È¢ÆÈ§ÇÈ§ÄÈ§áÈ¶ùÈ¶úÈßÉÈ¶πÈ¶ªÈ¶∫ÈßÇÈ¶ΩÈßáÈ™±È´£È´ßÈ¨æÈ¨øÈ≠†È≠°È≠üÈ≥±È≥≤È≥µÈ∫ßÂÉøÂÑÉÂÑ∞ÂÉ∏ÂÑÜÂÑáÂÉ∂ÂÉæÂÑãÂÑåÂÉΩÂÑäÂäãÂäåÂã±ÂãØÂôàÂôÇÂôåÂòµÂôÅÂôäÂôâÂôÜÂôò"],["e540","ÂôöÂôÄÂò≥ÂòΩÂò¨ÂòæÂò∏Âò™Âò∫ÂúöÂ¢´Â¢ùÂ¢±Â¢†Â¢£Â¢ØÂ¢¨Â¢•Â¢°Â£øÂ´øÂ´¥Â´ΩÂ´∑Â´∂Â¨ÉÂ´∏Â¨ÇÂ´πÂ¨ÅÂ¨áÂ¨ÖÂ¨èÂ±ßÂ∂ôÂ∂óÂ∂üÂ∂íÂ∂¢Â∂ìÂ∂ïÂ∂†Â∂úÂ∂°Â∂öÂ∂ûÂπ©ÂπùÂπ†ÂπúÁ∑≥ÂªõÂªûÂª°ÂΩâÂæ≤ÊÜãÊÜÉÊÖπÊÜ±ÊÜ∞ÊÜ¢ÊÜâ"],["e5a1","ÊÜõÊÜìÊÜØÊÜ≠ÊÜüÊÜíÊÜ™ÊÜ°ÊÜçÊÖ¶ÊÜ≥Êà≠ÊëÆÊë∞ÊíñÊí†ÊíÖÊíóÊíúÊíèÊíãÊíäÊíåÊí£ÊíüÊë®Êí±ÊíòÊï∂Êï∫ÊïπÊïªÊñ≤Êñ≥ÊöµÊö∞Êö©Êö≤Êö∑Êö™ÊöØÊ®ÄÊ®ÜÊ®óÊß•Êß∏Ê®ïÊß±Êß§Ê®†ÊßøÊß¨Êß¢Ê®õÊ®ùÊßæÊ®ßÊß≤ÊßÆÊ®îÊß∑ÊßßÊ©ÄÊ®àÊß¶ÊßªÊ®çÊßºÊß´Ê®âÊ®ÑÊ®òÊ®•Ê®èÊß∂Ê®¶Ê®áÊß¥Ê®ñÊ≠ëÊÆ•ÊÆ£ÊÆ¢ÊÆ¶Ê∞ÅÊ∞ÄÊØøÊ∞ÇÊΩÅÊº¶ÊΩæÊæáÊøÜÊæí"],["e640","ÊæçÊæâÊæåÊΩ¢ÊΩèÊæÖÊΩöÊæñÊΩ∂ÊΩ¨ÊæÇÊΩïÊΩ≤ÊΩíÊΩêÊΩóÊæîÊæìÊΩùÊºÄÊΩ°ÊΩ´ÊΩΩÊΩßÊæêÊΩìÊæãÊΩ©ÊΩøÊæïÊΩ£ÊΩ∑ÊΩ™ÊΩªÁÜ≤ÁÜØÁÜõÁÜ∞ÁÜ†ÁÜöÁÜ©ÁÜµÁÜùÁÜ•ÁÜûÁÜ§ÁÜ°ÁÜ™ÁÜúÁÜßÁÜ≥ÁäòÁäöÁçòÁçíÁçûÁçüÁç†ÁçùÁçõÁç°ÁçöÁçô"],["e6a1","Áç¢ÁíáÁíâÁíäÁíÜÁíÅÁëΩÁíÖÁíàÁëºÁëπÁîàÁîáÁïæÁò•ÁòûÁòôÁòùÁòúÁò£ÁòöÁò®ÁòõÁöúÁöùÁöûÁöõÁûçÁûèÁûâÁûàÁ£çÁ¢ªÁ£èÁ£åÁ£ëÁ£éÁ£îÁ£àÁ£ÉÁ£ÑÁ£âÁ¶öÁ¶°Á¶†Á¶úÁ¶¢Á¶õÊ≠∂Á®πÁ™≤Á™¥Á™≥ÁÆ∑ÁØãÁÆæÁÆ¨ÁØéÁÆØÁÆπÁØäÁÆµÁ≥ÖÁ≥àÁ≥åÁ≥ãÁ∑∑Á∑õÁ∑™Á∑ßÁ∑óÁ∑°Á∏ÉÁ∑∫Á∑¶Á∑∂Á∑±Á∑∞Á∑ÆÁ∑üÁΩ∂Áæ¨Áæ∞Áæ≠Áø≠Áø´Áø™Áø¨Áø¶Áø®ËÅ§ËÅßËÜ£ËÜü"],["e740","ËÜûËÜïËÜ¢ËÜôËÜóËàñËâèËâìËâíËâêËâéËâëËî§ËîªËîèËîÄËî©ËîéËîâËîçËîüËîäËîßËîúËìªËî´Ëì∫ËîàËîåËì¥Ëî™Ëì≤ËîïËì∑Ëì´Ëì≥ËìºËîíËì™Ëì©ËîñËìæËî®ËîùËîÆËîÇËìΩËîûËì∂Ëî±Ëî¶ËìßËì®Ëì∞ËìØËìπËîòËî†Ëî∞ËîãËîôËîØËô¢"],["e7a1","ËùñËù£Ëù§Ëù∑Ëü°Ëù≥ËùòËùîËùõËùíËù°ËùöËùëËùûËù≠Ëù™ËùêËùéËùüËùùËùØËù¨Ëù∫ËùÆËùúËù•ËùèËùªËùµËù¢ËùßËù©Ë°öË§ÖË§åË§îË§ãË§óË§òË§ôË§ÜË§ñË§ëË§éË§âË¶¢Ë¶§Ë¶£Ëß≠Ëß∞Ëß¨Ë´èË´ÜË™∏Ë´ìË´ëË´îË´ïË™ªË´óË™æË´ÄË´ÖË´òË´ÉË™∫Ë™ΩË´ôË∞æË±çË≤èË≥•Ë≥üË≥ôË≥®Ë≥öË≥ùË≥ßË∂†Ë∂úË∂°Ë∂õË∏†Ë∏£Ë∏•Ë∏§Ë∏ÆË∏ïË∏õË∏ñË∏ëË∏ôË∏¶Ë∏ß"],["e840","Ë∏îË∏íË∏òË∏ìË∏úË∏óË∏öËº¨Ëº§ËºòËºöËº†Ëº£ËºñËºóÈÅ≥ÈÅ∞ÈÅØÈÅßÈÅ´ÈÑØÈÑ´ÈÑ©ÈÑ™ÈÑ≤ÈÑ¶ÈÑÆÈÜÖÈÜÜÈÜäÈÜÅÈÜÇÈÜÑÈÜÄÈãêÈãÉÈãÑÈãÄÈãôÈä∂ÈãèÈã±ÈãüÈãòÈã©ÈãóÈãùÈãåÈãØÈãÇÈã®ÈãäÈãàÈãéÈã¶ÈãçÈãïÈãâÈã†ÈãûÈãßÈãëÈãì"],["e8a1","ÈäµÈã°ÈãÜÈä¥ÈïºÈñ¨Èñ´ÈñÆÈñ∞Èö§Èö¢ÈõìÈúÖÈúàÈúÇÈùöÈûäÈûéÈûàÈüêÈüèÈ†ûÈ†ùÈ†¶È†©È†®È††È†õÈ†ßÈ¢≤È§àÈ£∫È§ëÈ§îÈ§ñÈ§óÈ§ïÈßúÈßçÈßèÈßìÈßîÈßéÈßâÈßñÈßòÈßãÈßóÈßåÈ™≥È´¨È´´È´≥È´≤È´±È≠ÜÈ≠ÉÈ≠ßÈ≠¥È≠±È≠¶È≠∂È≠µÈ≠∞È≠®È≠§È≠¨È≥ºÈ≥∫È≥ΩÈ≥øÈ≥∑È¥áÈ¥ÄÈ≥πÈ≥ªÈ¥àÈ¥ÖÈ¥ÑÈ∫ÉÈªìÈºèÈºêÂÑúÂÑìÂÑóÂÑöÂÑëÂáûÂå¥Âè°Âô∞Âô†ÂôÆ"],["e940","Âô≥Âô¶Âô£Âô≠Âô≤ÂôûÂô∑ÂúúÂúõÂ£àÂ¢ΩÂ£âÂ¢øÂ¢∫Â£ÇÂ¢ºÂ£ÜÂ¨óÂ¨ôÂ¨õÂ¨°Â¨îÂ¨ìÂ¨êÂ¨ñÂ¨®Â¨öÂ¨†Â¨ûÂØØÂ∂¨Â∂±Â∂©Â∂ßÂ∂µÂ∂∞Â∂ÆÂ∂™Â∂®Â∂≤Â∂≠Â∂ØÂ∂¥ÂπßÂπ®Âπ¶ÂπØÂª©ÂªßÂª¶Âª®Âª•ÂΩãÂæºÊÜùÊÜ®ÊÜñÊáÖÊÜ¥ÊáÜÊáÅÊáåÊÜ∫"],["e9a1","ÊÜøÊÜ∏ÊÜåÊìóÊìñÊìêÊìèÊìâÊíΩÊíâÊìÉÊìõÊì≥ÊìôÊî≥ÊïøÊïºÊñ¢ÊõàÊöæÊõÄÊõäÊõãÊõèÊöΩÊöªÊö∫ÊõåÊú£Ê®¥Ê©¶Ê©âÊ©ßÊ®≤Ê©®Ê®æÊ©ùÊ©≠Ê©∂Ê©õÊ©ëÊ®®Ê©öÊ®ªÊ®øÊ©ÅÊ©™Ê©§Ê©êÊ©èÊ©îÊ©ØÊ©©Ê©†Ê®ºÊ©ûÊ©ñÊ©ïÊ©çÊ©éÊ©ÜÊ≠ïÊ≠îÊ≠ñÊÆßÊÆ™ÊÆ´ÊØàÊØáÊ∞ÑÊ∞ÉÊ∞ÜÊæ≠ÊøãÊæ£ÊøáÊæºÊøéÊøàÊΩûÊøÑÊæΩÊæûÊøäÊæ®ÁÄÑÊæ•ÊæÆÊæ∫Êæ¨Êæ™ÊøèÊæøÊæ∏"],["ea40","Êæ¢ÊøâÊæ´ÊøçÊæØÊæ≤Êæ∞ÁáÖÁáÇÁÜøÁÜ∏ÁáñÁáÄÁáÅÁáãÁáîÁáäÁááÁáèÁÜΩÁáòÁÜºÁáÜÁáöÁáõÁäùÁäûÁç©Áç¶ÁçßÁç¨Áç•Áç´Áç™ÁëøÁíöÁí†ÁíîÁííÁíïÁí°ÁîãÁñÄÁòØÁò≠Áò±ÁòΩÁò≥ÁòºÁòµÁò≤Áò∞ÁöªÁõ¶ÁûöÁûùÁû°ÁûúÁûõÁû¢Áû£ÁûïÁûô"],["eaa1","ÁûóÁ£ùÁ£©Á£•Á£™Á£ûÁ££Á£õÁ£°Á£¢Á£≠Á£üÁ£†Á¶§Á©ÑÁ©àÁ©áÁ™∂Á™∏Á™µÁ™±Á™∑ÁØûÁØ£ÁØßÁØùÁØïÁØ•ÁØöÁØ®ÁØπÁØîÁØ™ÁØ¢ÁØúÁØ´ÁØòÁØüÁ≥íÁ≥îÁ≥óÁ≥êÁ≥ëÁ∏íÁ∏°Á∏óÁ∏åÁ∏üÁ∏†Á∏ìÁ∏éÁ∏úÁ∏ïÁ∏öÁ∏¢Á∏ãÁ∏èÁ∏ñÁ∏çÁ∏îÁ∏•Á∏§ÁΩÉÁΩªÁΩºÁΩ∫Áæ±ÁøØËÄ™ËÄ©ËÅ¨ËÜ±ËÜ¶ËÜÆËÜπËÜµËÜ´ËÜ∞ËÜ¨ËÜ¥ËÜ≤ËÜ∑ËÜßËá≤ËâïËâñËâóËïñËïÖËï´ËïçËïìËï°Ëïò"],["eb40","ËïÄËïÜËï§ËïÅËï¢ËïÑËïëËïáËï£ËîæËïõËï±ËïéËïÆËïµËïïËïßËï†ËñåËï¶ËïùËïîËï•Ëï¨Ëô£Ëô•Ëô§ËûõËûèËûóËûìËûíËûàËûÅËûñËûòËùπËûáËû£ËûÖËûêËûëËûùËûÑËûîËûúËûöËûâË§ûË§¶Ë§∞Ë§≠Ë§ÆË§ßË§±Ë§¢Ë§©Ë§£Ë§ØË§¨Ë§üËß±Ë´†"],["eba1","Ë´¢Ë´≤Ë´¥Ë´µË´ùË¨îË´§Ë´üË´∞Ë´àË´ûË´°Ë´®Ë´øË´ØË´ªË≤ëË≤íË≤êË≥µË≥ÆË≥±Ë≥∞Ë≥≥Ëµ¨ËµÆË∂•Ë∂ßË∏≥Ë∏æË∏∏ËπÄËπÖË∏∂Ë∏ºË∏ΩËπÅË∏∞Ë∏øË∫ΩËº∂ËºÆËºµËº≤ËºπËº∑Ëº¥ÈÅ∂ÈÅπÈÅªÈÇÜÈÉ∫ÈÑ≥ÈÑµÈÑ∂ÈÜìÈÜêÈÜëÈÜçÈÜèÈåßÈåûÈåàÈåüÈåÜÈåèÈç∫Èå∏ÈåºÈåõÈå£ÈåíÈåÅÈçÜÈå≠ÈåéÈåçÈããÈåùÈã∫Èå•ÈåìÈãπÈã∑Èå¥ÈåÇÈå§ÈãøÈå©ÈåπÈåµÈå™ÈåîÈåå"],["ec40","ÈåãÈãæÈåâÈåÄÈãªÈåñÈñºÈóçÈñæÈñπÈñ∫Èñ∂ÈñøÈñµÈñΩÈö©ÈõîÈúãÈúíÈúêÈûôÈûóÈûîÈü∞Èü∏È†µÈ†ØÈ†≤È§§È§üÈ§ßÈ§©È¶ûÈßÆÈß¨Èß•Èß§Èß∞Èß£Èß™Èß©ÈßßÈ™πÈ™øÈ™¥È™ªÈ´∂È´∫È´πÈ´∑È¨≥ÈÆÄÈÆÖÈÆáÈ≠ºÈ≠æÈ≠ªÈÆÇÈÆìÈÆíÈÆêÈ≠∫ÈÆï"],["eca1","È≠ΩÈÆàÈ¥•È¥óÈ¥†È¥ûÈ¥îÈ¥©È¥ùÈ¥òÈ¥¢È¥êÈ¥ôÈ¥üÈ∫àÈ∫ÜÈ∫áÈ∫ÆÈ∫≠ÈªïÈªñÈª∫ÈºíÈºΩÂÑ¶ÂÑ•ÂÑ¢ÂÑ§ÂÑ†ÂÑ©Âã¥ÂöìÂöåÂöçÂöÜÂöÑÂöÉÂôæÂöÇÂôøÂöÅÂ£ñÂ£îÂ£èÂ£íÂ¨≠Â¨•Â¨≤Â¨£Â¨¨Â¨ßÂ¨¶Â¨ØÂ¨ÆÂ≠ªÂØ±ÂØ≤Â∂∑Âπ¨Âπ™ÂææÂæªÊáÉÊÜµÊÜºÊáßÊá†Êá•Êá§Êá®ÊáûÊìØÊì©Êì£Êì´Êì§Êì®ÊñÅÊñÄÊñ∂ÊóöÊõíÊ™çÊ™ñÊ™ÅÊ™•Ê™âÊ™üÊ™õÊ™°Ê™ûÊ™áÊ™ìÊ™é"],["ed40","Ê™ïÊ™ÉÊ™®Ê™§Ê™ëÊ©øÊ™¶Ê™öÊ™ÖÊ™åÊ™íÊ≠õÊÆ≠Ê∞âÊøåÊæ©Êø¥ÊøîÊø£ÊøúÊø≠ÊøßÊø¶ÊøûÊø≤ÊøùÊø¢Êø®Áá°Áá±Áá®Áá≤Áá§Áá∞Áá¢Áç≥ÁçÆÁçØÁíóÁí≤Áí´ÁíêÁí™Áí≠Áí±Áí•ÁíØÁîêÁîëÁîíÁîèÁñÑÁôÉÁôàÁôâÁôáÁö§Áõ©ÁûµÁû´Áû≤Áû∑Áû∂"],["eda1","Áû¥Áû±Áû®Áü∞Á£≥Á£ΩÁ§ÇÁ£ªÁ£ºÁ£≤Á§ÖÁ£πÁ£æÁ§ÑÁ¶´Á¶®Á©úÁ©õÁ©ñÁ©òÁ©îÁ©öÁ™æÁ´ÄÁ´ÅÁ∞ÖÁ∞èÁØ≤Á∞ÄÁØøÁØªÁ∞éÁØ¥Á∞ãÁØ≥Á∞ÇÁ∞âÁ∞ÉÁ∞ÅÁØ∏ÁØΩÁ∞ÜÁØ∞ÁØ±Á∞êÁ∞äÁ≥®Á∏≠Á∏ºÁπÇÁ∏≥È°àÁ∏∏Á∏™ÁπâÁπÄÁπáÁ∏©ÁπåÁ∏∞Á∏ªÁ∏∂ÁπÑÁ∏∫ÁΩÖÁΩøÁΩæÁΩΩÁø¥Áø≤ËÄ¨ËÜªËáÑËáåËáäËáÖËááËÜºËá©ËâõËâöËâúËñÉËñÄËñèËñßËñïËñ†ËñãËñ£ËïªËñ§ËñöËñû"],["ee40","Ëï∑ËïºËñâËñ°Ëï∫Ëï∏ËïóËñéËññËñÜËñçËñôËñùËñÅËñ¢ËñÇËñàËñÖËïπËï∂ËñòËñêËñüËô®ËûæËû™Ëû≠ËüÖËû∞Ëû¨ËûπËûµËûºËûÆËüâËüÉËüÇËüåËû∑ËûØËüÑËüäËû¥Ëû∂ËûøËû∏ËûΩËüûËû≤Ë§µË§≥Ë§ºË§æË•ÅË•íË§∑Ë•ÇË¶≠Ë¶ØË¶ÆËß≤Ëß≥Ë¨û"],["eea1","Ë¨òË¨ñË¨ëË¨ÖË¨ãË¨¢Ë¨èË¨íË¨ïË¨áË¨çË¨àË¨ÜË¨úË¨ìË¨öË±èË±∞Ë±≤Ë±±Ë±ØË≤ïË≤îË≥πËµØËπéËπçËπìËπêËπåËπáËΩÉËΩÄÈÇÖÈÅæÈÑ∏ÈÜöÈÜ¢ÈÜõÈÜôÈÜüÈÜ°ÈÜùÈÜ†Èé°ÈéÉÈéØÈç§ÈçñÈçáÈçºÈçòÈçúÈç∂ÈçâÈçêÈçëÈç†Èç≠ÈéèÈçåÈç™ÈçπÈçóÈçïÈçíÈçèÈç±Èç∑ÈçªÈç°ÈçûÈç£ÈçßÈéÄÈçéÈçôÈóáÈóÄÈóâÈóÉÈóÖÈñ∑ÈöÆÈö∞Èö¨Èú†ÈúüÈúòÈúùÈúôÈûöÈû°Èûú"],["ef40","ÈûûÈûùÈüïÈüîÈü±È°ÅÈ°ÑÈ°äÈ°âÈ°ÖÈ°ÉÈ§•È§´È§¨È§™È§≥È§≤È§ØÈ§≠È§±È§∞È¶òÈ¶£È¶°È®ÇÈß∫Èß¥Èß∑ÈßπÈß∏Èß∂ÈßªÈßΩÈßæÈßºÈ®ÉÈ™æÈ´æÈ´ΩÈ¨ÅÈ´ºÈ≠àÈÆöÈÆ®ÈÆûÈÆõÈÆ¶ÈÆ°ÈÆ•ÈÆ§ÈÆÜÈÆ¢ÈÆ†ÈÆØÈ¥≥ÈµÅÈµßÈ¥∂È¥ÆÈ¥ØÈ¥±È¥∏È¥∞"],["efa1","ÈµÖÈµÇÈµÉÈ¥æÈ¥∑ÈµÄÈ¥ΩÁøµÈ¥≠È∫äÈ∫âÈ∫çÈ∫∞ÈªàÈªöÈªªÈªøÈº§Èº£Èº¢ÈΩîÈæ†ÂÑ±ÂÑ≠ÂÑÆÂöòÂöúÂöóÂööÂöùÂöôÂ•∞Â¨ºÂ±©Â±™Â∑ÄÂπ≠ÂπÆÊáòÊáüÊá≠ÊáÆÊá±Êá™Êá∞Êá´ÊáñÊá©ÊìøÊîÑÊìΩÊì∏ÊîÅÊîÉÊìºÊñîÊóõÊõöÊõõÊõòÊ´ÖÊ™πÊ™ΩÊ´°Ê´ÜÊ™∫Ê™∂Ê™∑Ê´áÊ™¥Ê™≠Ê≠ûÊØâÊ∞ãÁÄáÁÄåÁÄçÁÄÅÁÄÖÁÄîÁÄéÊøøÁÄÄÊøªÁÄ¶ÊøºÊø∑ÁÄäÁàÅÁáøÁáπÁàÉÁáΩÁç∂"],["f040","Áí∏ÁìÄÁíµÁìÅÁíæÁí∂ÁíªÁìÇÁîîÁîìÁôúÁô§ÁôôÁôêÁôìÁôóÁôöÁö¶ÁöΩÁõ¨ÁüÇÁû∫Á£øÁ§åÁ§ìÁ§îÁ§âÁ§êÁ§íÁ§ëÁ¶≠Á¶¨Á©üÁ∞úÁ∞©Á∞ôÁ∞†Á∞üÁ∞≠Á∞ùÁ∞¶Á∞®Á∞¢Á∞•Á∞∞ÁπúÁπêÁπñÁπ£ÁπòÁπ¢ÁπüÁπëÁπ†ÁπóÁπìÁæµÁæ≥Áø∑Áø∏ËÅµËáëËáí"],["f0a1","ËáêËâüËâûËñ¥ËóÜËóÄËóÉËóÇËñ≥ËñµËñΩËóáËóÑËñøËóãËóéËóàËóÖËñ±Ëñ∂ËóíËò§Ëñ∏Ëñ∑ËñæËô©ËüßËü¶Ëü¢ËüõËü´Ëü™Ëü•ËüüËü≥Ëü§ËüîËüúËüìËü≠ËüòËü£Ëû§ËüóËüôË†ÅËü¥Ëü®ËüùË•ìË•ãË•èË•åË•ÜË•êË•ëË•âË¨™Ë¨ßË¨£Ë¨≥Ë¨∞Ë¨µË≠áË¨ØË¨ºË¨æË¨±Ë¨•Ë¨∑Ë¨¶Ë¨∂Ë¨ÆË¨§Ë¨ªË¨ΩË¨∫Ë±ÇË±µË≤ôË≤òË≤óË≥æË¥ÑË¥ÇË¥ÄËπúËπ¢Ëπ†ËπóËπñËπûËπ•Ëπß"],["f140","ËπõËπöËπ°ËπùËπ©ËπîËΩÜËΩáËΩàËΩãÈÑ®ÈÑ∫ÈÑªÈÑæÈÜ®ÈÜ•ÈÜßÈÜØÈÜ™ÈéµÈéåÈéíÈé∑ÈéõÈéùÈéâÈéßÈééÈé™ÈéûÈé¶ÈéïÈéàÈéôÈéüÈéçÈé±ÈéëÈé≤Èé§Èé®Èé¥Èé£Èé•ÈóíÈóìÈóëÈö≥ÈõóÈõöÂ∑ÇÈõüÈõòÈõùÈú£Èú¢Èú•Èû¨ÈûÆÈû®Èû´Èû§Èû™"],["f1a1","Èû¢Èû•ÈüóÈüôÈüñÈüòÈü∫È°êÈ°ëÈ°íÈ¢∏È•ÅÈ§ºÈ§∫È®èÈ®ãÈ®âÈ®çÈ®ÑÈ®ëÈ®äÈ®ÖÈ®áÈ®ÜÈ´ÄÈ´úÈ¨àÈ¨ÑÈ¨ÖÈ¨©È¨µÈ≠äÈ≠åÈ≠ãÈØáÈØÜÈØÉÈÆøÈØÅÈÆµÈÆ∏ÈØìÈÆ∂ÈØÑÈÆπÈÆΩÈµúÈµìÈµèÈµäÈµõÈµãÈµôÈµñÈµåÈµóÈµíÈµîÈµüÈµòÈµöÈ∫éÈ∫åÈªüÈºÅÈºÄÈºñÈº•Èº´Èº™Èº©Èº®ÈΩåÈΩïÂÑ¥ÂÑµÂäñÂã∑Âé¥Âö´Âö≠Âö¶ÂößÂö™Âö¨Â£öÂ£ùÂ£õÂ§íÂ¨ΩÂ¨æÂ¨øÂ∑ÉÂπ∞"],["f240","ÂæøÊáªÊîáÊîêÊîçÊîâÊîåÊîéÊñÑÊóûÊóùÊõûÊ´ßÊ´†Ê´åÊ´ëÊ´ôÊ´ãÊ´üÊ´úÊ´êÊ´´Ê´èÊ´çÊ´ûÊ≠†ÊÆ∞Ê∞åÁÄôÁÄßÁÄ†ÁÄñÁÄ´ÁÄ°ÁÄ¢ÁÄ£ÁÄ©ÁÄóÁÄ§ÁÄúÁÄ™ÁàåÁàäÁàáÁàÇÁàÖÁä•Áä¶Áä§Áä£Áä°ÁìãÁìÖÁí∑ÁìÉÁîñÁô†ÁüâÁüäÁüÑÁü±Á§ùÁ§õ"],["f2a1","Á§°Á§úÁ§óÁ§ûÁ¶∞Á©ßÁ©®Á∞≥Á∞ºÁ∞πÁ∞¨Á∞ªÁ≥¨Á≥™Áπ∂ÁπµÁπ∏Áπ∞Áπ∑ÁπØÁπ∫Áπ≤Áπ¥Áπ®ÁΩãÁΩäÁæÉÁæÜÁæ∑ÁøΩÁøæËÅ∏ËáóËáïËâ§Ëâ°Ëâ£Ëó´Ëó±Ëó≠ËóôËó°Ëó®ËóöËóóËó¨Ëó≤Ëó∏ËóòËóüËó£ËóúËóëËó∞Ëó¶ËóØËóûËó¢Ë†ÄËü∫Ë†ÉËü∂Ëü∑Ë†âË†åË†ãË†ÜËüºË†àËüøË†äË†ÇË•¢Ë•öË•õË•óË•°Ë•úË•òË•ùË•ôË¶àË¶∑Ë¶∂Ëß∂Ë≠êË≠àË≠äË≠ÄË≠ìË≠ñË≠îË≠ãË≠ï"],["f340","Ë≠ëË≠ÇË≠íË≠óË±ÉË±∑Ë±∂Ë≤öË¥ÜË¥áË¥âË∂¨Ë∂™Ë∂≠Ë∂´Ëπ≠Ëπ∏Ëπ≥Ëπ™ËπØËπªËªÇËΩíËΩëËΩèËΩêËΩìËæ¥ÈÖÄÈÑøÈÜ∞ÈÜ≠ÈèûÈèáÈèèÈèÇÈèöÈèêÈèπÈè¨ÈèåÈèôÈé©Èè¶ÈèäÈèîÈèÆÈè£ÈèïÈèÑÈèéÈèÄÈèíÈèßÈïΩÈóöÈóõÈõ°Èú©Èú´Èú¨Èú®Èú¶"],["f3a1","Èû≥Èû∑Èû∂ÈüùÈüûÈüüÈ°úÈ°ôÈ°ùÈ°óÈ¢øÈ¢ΩÈ¢ªÈ¢æÈ•àÈ•áÈ•ÉÈ¶¶È¶ßÈ®öÈ®ïÈ®•È®ùÈ®§È®õÈ®¢È®†È®ßÈ®£È®ûÈ®úÈ®îÈ´ÇÈ¨ãÈ¨äÈ¨éÈ¨åÈ¨∑ÈØ™ÈØ´ÈØ†ÈØûÈØ§ÈØ¶ÈØ¢ÈØ∞ÈØîÈØóÈØ¨ÈØúÈØôÈØ•ÈØïÈØ°ÈØöÈµ∑È∂ÅÈ∂äÈ∂ÑÈ∂àÈµ±È∂ÄÈµ∏È∂ÜÈ∂ãÈ∂åÈµΩÈµ´Èµ¥ÈµµÈµ∞Èµ©È∂ÖÈµ≥ÈµªÈ∂ÇÈµØÈµπÈµøÈ∂áÈµ®È∫îÈ∫ëÈªÄÈªºÈº≠ÈΩÄÈΩÅÈΩçÈΩñÈΩóÈΩòÂå∑Âö≤"],["f440","ÂöµÂö≥Â££Â≠ÖÂ∑ÜÂ∑áÂªÆÂªØÂøÄÂøÅÊáπÊîóÊîñÊîïÊîìÊóüÊõ®Êõ£Êõ§Ê´≥Ê´∞Ê´™Ê´®Ê´πÊ´±Ê´ÆÊ´ØÁÄºÁÄµÁÄØÁÄ∑ÁÄ¥ÁÄ±ÁÅÇÁÄ∏ÁÄøÁÄ∫ÁÄπÁÅÄÁÄªÁÄ≥ÁÅÅÁàìÁàîÁä®ÁçΩÁçºÁí∫Áö´Áö™ÁöæÁõ≠ÁüåÁüéÁüèÁüçÁü≤Á§•Á§£Á§ßÁ§®Á§§Á§©"],["f4a1","Á¶≤Á©ÆÁ©¨Á©≠Á´∑Á±âÁ±àÁ±äÁ±áÁ±ÖÁ≥ÆÁπªÁπæÁ∫ÅÁ∫ÄÁæ∫ÁøøËÅπËáõËáôËàãËâ®Ëâ©Ëò¢ËóøËòÅËóæËòõËòÄËó∂ËòÑËòâËòÖËòåËóΩË†ôË†êË†ëË†óË†ìË†ñË•£Ë•¶Ë¶πËß∑Ë≠†Ë≠™Ë≠ùË≠®Ë≠£Ë≠•Ë≠ßË≠≠Ë∂ÆË∫ÜË∫àË∫ÑËΩôËΩñËΩóËΩïËΩòËΩöÈÇçÈÖÉÈÖÅÈÜ∑ÈÜµÈÜ≤ÈÜ≥ÈêãÈêìÈèªÈê†ÈêèÈêîÈèæÈêïÈêêÈê®ÈêôÈêçÈèµÈêÄÈè∑ÈêáÈêéÈêñÈêíÈè∫ÈêâÈè∏ÈêäÈèø"],["f540","ÈèºÈêåÈè∂ÈêëÈêÜÈóûÈó†ÈóüÈúÆÈúØÈûπÈûªÈüΩÈüæÈ°†È°¢È°£È°üÈ£ÅÈ£ÇÈ•êÈ•éÈ•ôÈ•åÈ•ãÈ•ìÈ®≤È®¥È®±È®¨È®™È®∂È®©È®ÆÈ®∏È®≠È´áÈ´äÈ´ÜÈ¨êÈ¨íÈ¨ëÈ∞ãÈ∞àÈØ∑È∞ÖÈ∞íÈØ∏È±ÄÈ∞áÈ∞éÈ∞ÜÈ∞óÈ∞îÈ∞âÈ∂üÈ∂ôÈ∂§È∂ùÈ∂íÈ∂òÈ∂êÈ∂õ"],["f5a1","È∂†È∂îÈ∂úÈ∂™È∂óÈ∂°È∂öÈ∂¢È∂®È∂ûÈ∂£È∂øÈ∂©È∂ñÈ∂¶È∂ßÈ∫ôÈ∫õÈ∫öÈª•Èª§ÈªßÈª¶Èº∞ÈºÆÈΩõÈΩ†ÈΩûÈΩùÈΩôÈæëÂÑ∫ÂÑπÂäòÂäóÂõÉÂöΩÂöæÂ≠àÂ≠áÂ∑ãÂ∑èÂª±ÊáΩÊîõÊ¨ÇÊ´ºÊ¨ÉÊ´∏Ê¨ÄÁÅÉÁÅÑÁÅäÁÅàÁÅâÁÅÖÁÅÜÁàùÁàöÁàôÁçæÁîóÁô™ÁüêÁ§≠Á§±Á§ØÁ±îÁ±ìÁ≥≤Á∫äÁ∫áÁ∫àÁ∫ãÁ∫ÜÁ∫çÁΩçÁæªËÄ∞ËáùËòòËò™Ëò¶ËòüËò£ËòúËòôËòßËòÆËò°Ëò†Ëò©ËòûËò•"],["f640","Ë†©Ë†ùË†õË††Ë†§Ë†úË†´Ë°äË•≠Ë•©Ë•ÆË•´Ëß∫Ë≠πË≠∏Ë≠ÖË≠∫Ë≠ªË¥êË¥îË∂ØË∫éË∫åËΩûËΩõËΩùÈÖÜÈÖÑÈÖÖÈÜπÈêøÈêªÈê∂Èê©ÈêΩÈêºÈê∞ÈêπÈê™Èê∑Èê¨ÈëÄÈê±Èó•Èó§Èó£ÈúµÈú∫ÈûøÈü°È°§È£âÈ£ÜÈ£ÄÈ•òÈ•ñÈ®πÈ®ΩÈ©ÜÈ©ÑÈ©ÇÈ©ÅÈ®∫"],["f6a1","È®øÈ´çÈ¨ïÈ¨óÈ¨òÈ¨ñÈ¨∫È≠íÈ∞´È∞ùÈ∞úÈ∞¨È∞£È∞®È∞©È∞§È∞°È∂∑È∂∂È∂ºÈ∑ÅÈ∑áÈ∑äÈ∑èÈ∂æÈ∑ÖÈ∑ÉÈ∂ªÈ∂µÈ∑éÈ∂πÈ∂∫È∂¨È∑àÈ∂±È∂≠È∑åÈ∂≥È∑çÈ∂≤Èπ∫È∫úÈª´ÈªÆÈª≠ÈºõÈºòÈºöÈº±ÈΩéÈΩ•ÈΩ§Èæí‰∫πÂõÜÂõÖÂõãÂ•±Â≠ãÂ≠åÂ∑ïÂ∑ëÂª≤Êî°Êî†Êî¶Êî¢Ê¨ãÊ¨àÊ¨âÊ∞çÁÅïÁÅñÁÅóÁÅíÁàûÁàüÁä©ÁçøÁìòÁìïÁìôÁìóÁô≠Áö≠Á§µÁ¶¥Á©∞Á©±Á±óÁ±úÁ±ôÁ±õÁ±ö"],["f740","Á≥¥Á≥±Á∫ëÁΩèÁæáËáûËâ´Ëò¥ËòµËò≥Ëò¨Ëò≤Ëò∂Ë†¨Ë†®Ë†¶Ë†™Ë†•Ë•±Ë¶øË¶æËßªË≠æËÆÑËÆÇËÆÜËÆÖË≠øË¥ïË∫ïË∫îË∫öË∫íË∫êË∫ñË∫óËΩ†ËΩ¢ÈÖáÈëåÈëêÈëäÈëãÈëèÈëáÈëÖÈëàÈëâÈëÜÈúøÈü£È°™È°©È£ãÈ•îÈ•õÈ©éÈ©ìÈ©îÈ©åÈ©èÈ©àÈ©ä"],["f7a1","È©âÈ©íÈ©êÈ´êÈ¨ôÈ¨´È¨ªÈ≠ñÈ≠ïÈ±ÜÈ±àÈ∞øÈ±ÑÈ∞πÈ∞≥È±ÅÈ∞ºÈ∞∑È∞¥È∞≤È∞ΩÈ∞∂È∑õÈ∑íÈ∑ûÈ∑öÈ∑ãÈ∑êÈ∑úÈ∑ëÈ∑üÈ∑©È∑ôÈ∑òÈ∑ñÈ∑µÈ∑ïÈ∑ùÈ∫∂Èª∞ÈºµÈº≥Èº≤ÈΩÇÈΩ´ÈæïÈæ¢ÂÑΩÂäôÂ£®Â£ßÂ•≤Â≠çÂ∑òË†ØÂΩèÊàÅÊàÉÊàÑÊî©Êî•ÊññÊõ´Ê¨ëÊ¨íÊ¨èÊØäÁÅõÁÅöÁà¢ÁéÇÁéÅÁéÉÁô∞ÁüîÁ±ßÁ±¶Á∫ïËâ¨Ëò∫ËôÄËòπËòºËò±ËòªËòæË†∞Ë†≤Ë†ÆË†≥Ë•∂Ë•¥Ë•≥Ëßæ"],["f840","ËÆåËÆéËÆãËÆàË±ÖË¥ôË∫òËΩ§ËΩ£ÈÜºÈë¢ÈëïÈëùÈëóÈëûÈüÑÈüÖÈ†ÄÈ©ñÈ©ôÈ¨ûÈ¨üÈ¨†È±íÈ±òÈ±êÈ±äÈ±çÈ±ãÈ±ïÈ±ôÈ±åÈ±éÈ∑ªÈ∑∑È∑ØÈ∑£È∑´È∑∏È∑§È∑∂È∑°È∑ÆÈ∑¶È∑≤È∑∞È∑¢È∑¨È∑¥È∑≥È∑®È∑≠ÈªÇÈªêÈª≤Èª≥ÈºÜÈºúÈº∏Èº∑Èº∂ÈΩÉÈΩè"],["f8a1","ÈΩ±ÈΩ∞ÈΩÆÈΩØÂõìÂõçÂ≠éÂ±≠Êî≠Êõ≠ÊõÆÊ¨ìÁÅüÁÅ°ÁÅùÁÅ†Áà£ÁìõÁì•ÁüïÁ§∏Á¶∑Á¶∂Á±™Á∫óÁæâËâ≠ËôÉË†∏Ë†∑Ë†µË°ãËÆîËÆïË∫ûË∫üË∫†Ë∫ùÈÜæÈÜΩÈáÇÈë´Èë®Èë©Èõ•ÈùÜÈùÉÈùáÈüáÈü•È©ûÈ´ïÈ≠ôÈ±£È±ßÈ±¶È±¢È±ûÈ±†È∏ÇÈ∑æÈ∏áÈ∏ÉÈ∏ÜÈ∏ÖÈ∏ÄÈ∏ÅÈ∏âÈ∑øÈ∑ΩÈ∏ÑÈ∫†ÈºûÈΩÜÈΩ¥ÈΩµÈΩ∂ÂõîÊîÆÊñ∏Ê¨òÊ¨ôÊ¨óÊ¨öÁÅ¢Áà¶Áä™ÁüòÁüôÁ§πÁ±©Á±´Á≥∂Á∫ö"],["f940","Á∫òÁ∫õÁ∫ôËá†Ëá°ËôÜËôáËôàË•πË•∫Ë•ºË•ªËßøËÆòËÆôË∫•Ë∫§Ë∫£ÈëÆÈë≠ÈëØÈë±Èë≥ÈùâÈ°≤È•üÈ±®È±ÆÈ±≠È∏ãÈ∏çÈ∏êÈ∏èÈ∏íÈ∏ëÈ∫°ÈªµÈºâÈΩáÈΩ∏ÈΩªÈΩ∫ÈΩπÂúûÁÅ¶Á±ØË†ºË∂≤Ë∫¶ÈáÉÈë¥Èë∏Èë∂ÈëµÈ©†È±¥È±≥È±±È±µÈ∏îÈ∏ìÈª∂Èºä"],["f9a1","Èæ§ÁÅ®ÁÅ•Á≥∑Ëô™Ë†æË†ΩË†øËÆûË≤úË∫©ËªâÈùãÈ°≥È°¥È£åÈ•°È¶´È©§È©¶È©ßÈ¨§È∏ïÈ∏óÈΩàÊàáÊ¨ûÁàßËôåË∫®ÈíÇÈíÄÈíÅÈ©©È©®È¨ÆÈ∏ôÁà©ËôãËÆüÈíÉÈ±πÈ∫∑ÁôµÈ©´È±∫È∏ùÁÅ©ÁÅ™È∫§ÈΩæÈΩâÈæòÁ¢ÅÈäπË£èÂ¢ªÊÅíÁ≤ßÂ´∫‚ïî‚ï¶‚ïó‚ï†‚ï¨‚ï£‚ïö‚ï©‚ïù‚ïí‚ï§‚ïï‚ïû‚ï™‚ï°‚ïò‚ïß‚ïõ‚ïì‚ï•‚ïñ‚ïü‚ï´‚ï¢‚ïô‚ï®‚ïú‚ïë‚ïê‚ï≠‚ïÆ‚ï∞‚ïØ‚ñì"]]');

/***/ }),

/***/ 3030:
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('[["0","\\u0000",127],["8ea1","ÔΩ°",62],["a1a1","„ÄÄ„ÄÅ„ÄÇÔºåÔºé„ÉªÔºöÔºõÔºüÔºÅ„Çõ„Çú¬¥ÔΩÄ¬®ÔºæÔø£Ôºø„ÉΩ„Éæ„Çù„Çû„ÄÉ‰ªù„ÄÖ„ÄÜ„Äá„Éº‚Äï‚ÄêÔºèÔººÔΩû‚à•ÔΩú‚Ä¶‚Ä•‚Äò‚Äô‚Äú‚ÄùÔºàÔºâ„Äî„ÄïÔºªÔºΩÔΩõÔΩù„Äà",9,"ÔºãÔºç¬±√ó√∑Ôºù‚â†ÔºúÔºû‚â¶‚âß‚àû‚à¥‚ôÇ‚ôÄ¬∞‚Ä≤‚Ä≥‚ÑÉÔø•ÔºÑÔø†Ôø°ÔºÖÔºÉÔºÜÔºäÔº†¬ß‚òÜ‚òÖ‚óã‚óè‚óé‚óá"],["a2a1","‚óÜ‚ñ°‚ñ†‚ñ≥‚ñ≤‚ñΩ‚ñº‚Äª„Äí‚Üí‚Üê‚Üë‚Üì„Äì"],["a2ba","‚àà‚àã‚äÜ‚äá‚äÇ‚äÉ‚à™‚à©"],["a2ca","‚àß‚à®Ôø¢‚áí‚áî‚àÄ‚àÉ"],["a2dc","‚à†‚ä•‚åí‚àÇ‚àá‚â°‚âí‚â™‚â´‚àö‚àΩ‚àù‚àµ‚à´‚à¨"],["a2f2","‚Ñ´‚Ä∞‚ôØ‚ô≠‚ô™‚Ä†‚Ä°¬∂"],["a2fe","‚óØ"],["a3b0","Ôºê",9],["a3c1","Ôº°",25],["a3e1","ÔΩÅ",25],["a4a1","„ÅÅ",82],["a5a1","„Ç°",85],["a6a1","Œë",16,"Œ£",6],["a6c1","Œ±",16,"œÉ",6],["a7a1","–ê",5,"–Å–ñ",25],["a7d1","–∞",5,"—ë–∂",25],["a8a1","‚îÄ‚îÇ‚îå‚îê‚îò‚îî‚îú‚î¨‚î§‚î¥‚îº‚îÅ‚îÉ‚îè‚îì‚îõ‚îó‚î£‚î≥‚î´‚îª‚ïã‚î†‚îØ‚î®‚î∑‚îø‚îù‚î∞‚î•‚î∏‚ïÇ"],["ada1","‚ë†",19,"‚Ö†",9],["adc0","„çâ„åî„å¢„çç„åò„åß„åÉ„å∂„çë„çó„åç„å¶„å£„å´„çä„åª„éú„éù„éû„éé„éè„èÑ„é°"],["addf","„çª„Äù„Äü‚Ññ„èç‚Ñ°„ä§",4,"„à±„à≤„àπ„çæ„çΩ„çº‚âí‚â°‚à´‚àÆ‚àë‚àö‚ä•‚à†‚àü‚äø‚àµ‚à©‚à™"],["b0a1","‰∫úÂîñÂ®ÉÈòøÂìÄÊÑõÊå®Âß∂ÈÄ¢ËëµËåúÁ©êÊÇ™Êè°Ê∏•Êó≠Ëë¶Ëä¶ÈØµÊ¢ìÂúßÊñ°Êâ±ÂÆõÂßêËôªÈ£¥Áµ¢Á∂æÈÆéÊàñÁ≤üË¢∑ÂÆâÂ∫µÊåâÊöóÊ°àÈóáÈûçÊùè‰ª•‰ºä‰Ωç‰æùÂÅâÂõ≤Â§∑ÂßîÂ®ÅÂ∞âÊÉüÊÑèÊÖ∞ÊòìÊ§ÖÁÇ∫ÁïèÁï∞ÁßªÁ∂≠Á∑ØËÉÉËêéË°£Ë¨ÇÈÅïÈÅ∫Âåª‰∫ï‰∫•ÂüüËÇ≤ÈÉÅÁ£Ø‰∏ÄÂ£±Ê∫¢ÈÄ∏Á®≤Ëå®ËäãÈ∞ØÂÖÅÂç∞ÂíΩÂì°Âõ†ÂßªÂºïÈ£≤Ê∑´ËÉ§Ëî≠"],["b1a1","Èô¢Èô∞Èö†ÈüªÂêãÂè≥ÂÆáÁÉèÁæΩËøÇÈõ®ÂçØÈµúÁ™∫‰∏ëÁ¢ìËáºÊ∏¶ÂòòÂîÑÊ¨ùËîöÈ∞ªÂß•Âé©Êµ¶ÁìúÈñèÂôÇ‰∫ëÈÅãÈõ≤ËçèÈ§åÂè°Âñ∂Â¨∞ÂΩ±Êò†Êõ≥Ê†ÑÊ∞∏Ê≥≥Ê¥©ÁëõÁõàÁ©éÈ†¥Ëã±Ë°õË©†Èã≠Ê∂≤Áñ´ÁõäÈßÖÊÇ¶Ë¨ÅË∂äÈñ≤Ê¶éÂé≠ÂÜÜÂúíÂ†∞Â•ÑÂÆ¥Âª∂ÊÄ®Êé©Êè¥Ê≤øÊºîÁÇéÁÑîÁÖôÁáïÁåøÁ∏ÅËâ∂ËãëËñóÈÅ†ÈâõÈ¥õÂ°©ÊñºÊ±öÁî•ÂáπÂ§ÆÂ••ÂæÄÂøú"],["b2a1","ÊäºÊó∫Ê®™Ê¨ßÊÆ¥ÁéãÁøÅË•ñÈ¥¨È¥éÈªÑÂ≤°Ê≤ñËçªÂÑÑÂ±ãÊÜ∂ËáÜÊ°∂Áâ°‰πô‰ø∫Âç∏ÊÅ©Ê∏©Á©èÈü≥‰∏ãÂåñ‰ªÆ‰Ωï‰ºΩ‰æ°‰Ω≥Âä†ÂèØÂòâÂ§èÂ´ÅÂÆ∂ÂØ°ÁßëÊöáÊûúÊû∂Ê≠åÊ≤≥ÁÅ´ÁèÇÁ¶çÁ¶æÁ®ºÁÆáËä±ËãõËåÑËç∑ËèØËèìËù¶Ë™≤Âò©Ë≤®Ëø¶ÈÅéÈúûËöä‰øÑÂ≥®ÊàëÁâôÁîªËá•ËäΩËõæË≥ÄÈõÖÈ§ìÈßï‰ªã‰ºöËß£ÂõûÂ°äÂ£äÂªªÂø´ÊÄ™ÊÇîÊÅ¢ÊáêÊàíÊãêÊîπ"],["b3a1","È≠ÅÊô¶Ê¢∞Êµ∑ÁÅ∞ÁïåÁöÜÁµµËä•ËüπÈñãÈöéË≤ùÂá±ÂäæÂ§ñÂí≥ÂÆ≥Â¥ñÊÖ®Ê¶ÇÊ∂ØÁ¢çËìãË°óË©≤ÈéßÈ™∏Êµ¨È¶®ËõôÂû£ÊüøËõéÈàéÂäÉÂöáÂêÑÂªìÊã°ÊíπÊ†ºÊ†∏ÊÆªÁç≤Á¢∫Á©´Ë¶öËßíËµ´ËºÉÈÉ≠Èñ£ÈöîÈù©Â≠¶Â≤≥Ê•ΩÈ°çÈ°éÊéõÁ¨†Ê®´Ê©øÊ¢∂È∞çÊΩüÂâ≤ÂñùÊÅ∞Êã¨Ê¥ªÊ∏áÊªëËëõË§êËΩÑ‰∏îÈ∞πÂè∂Ê§õÊ®∫ÈûÑÊ†™ÂÖúÁ´ÉËí≤ÈáúÈéåÂôõÈ¥®Ê†¢ËåÖËê±"],["b4a1","Á≤•ÂààËãÖÁì¶‰πæ‰æÉÂÜ†ÂØíÂàäÂãòÂãßÂ∑ªÂñöÂ†™Âß¶ÂÆåÂÆòÂØõÂπ≤ÂππÊÇ£ÊÑüÊÖ£ÊÜæÊèõÊï¢ÊüëÊ°ìÊ£∫Ê¨æÊ≠ìÊ±óÊº¢ÊæóÊΩÖÁí∞ÁîòÁõ£ÁúãÁ´øÁÆ°Á∞°Á∑©Áº∂Áø∞ËÇùËâ¶ËéûË¶≥Ë´åË≤´ÈÇÑÈëëÈñìÈñëÈñ¢Èô•ÈüìÈ§®Ëàò‰∏∏Âê´Â≤∏Â∑åÁé©ÁôåÁúºÂ≤©Áø´Ë¥ãÈõÅÈ†ëÈ°îÈ°ò‰ºÅ‰ºéÂç±ÂñúÂô®Âü∫Â•áÂ¨âÂØÑÂ≤êÂ∏åÂπæÂøåÊèÆÊú∫ÊóóÊó¢ÊúüÊ£ãÊ£Ñ"],["b5a1","Ê©üÂ∏∞ÊØÖÊ∞óÊ±ΩÁïøÁ•àÂ≠£Á®ÄÁ¥ÄÂæΩË¶èË®òË≤¥Ëµ∑ËªåËºùÈ£¢È®éÈ¨º‰∫ÄÂÅΩÂÑÄÂ¶ìÂÆúÊàØÊäÄÊì¨Ê¨∫Áä†ÁñëÁ•áÁæ©ËüªË™ºË≠∞Êé¨ËèäÈû†ÂêâÂêÉÂñ´Ê°îÊ©òË©∞Á†ßÊùµÈªçÂç¥ÂÆ¢ËÑöËôêÈÄÜ‰∏ò‰πÖ‰ªá‰ºëÂèäÂê∏ÂÆÆÂºìÊÄ•ÊïëÊúΩÊ±ÇÊ±≤Ê≥£ÁÅ∏ÁêÉÁ©∂Á™ÆÁ¨àÁ¥öÁ≥æÁµ¶ÊóßÁâõÂéªÂ±ÖÂ∑®ÊãíÊã†ÊåôÊ∏†ËôöË®±Ë∑ùÈã∏ÊºÅÁ¶¶È≠ö‰∫®‰∫´‰∫¨"],["b6a1","‰æõ‰æ†ÂÉëÂÖáÁ´∂ÂÖ±Âá∂ÂçîÂå°ÂçøÂè´Âñ¨Â¢ÉÂ≥°Âº∑ÂΩäÊÄØÊÅêÊÅ≠ÊåüÊïôÊ©ãÊ≥ÅÁãÇÁã≠ÁüØËÉ∏ËÑÖËààËïéÈÉ∑Èè°ÈüøÈ•óÈ©ö‰ª∞ÂáùÂ∞≠ÊöÅÊ•≠Â±ÄÊõ≤Ê•µÁéâÊ°êÁ≤ÅÂÉÖÂã§ÂùáÂ∑æÈå¶Êñ§Ê¨£Ê¨ΩÁê¥Á¶ÅÁ¶ΩÁ≠ãÁ∑äËäπËèåË°øË•üË¨πËøëÈáëÂêüÈäÄ‰πùÂÄ∂Âè•Âå∫ÁãóÁéñÁü©Ëã¶Ë∫ØÈßÜÈßàÈßíÂÖ∑ÊÑöËôûÂñ∞Á©∫ÂÅ∂ÂØìÈÅáÈöÖ‰∏≤Ê´õÈáßÂ±ëÂ±à"],["b7a1","ÊéòÁ™üÊ≤ìÈù¥ËΩ°Á™™ÁÜäÈöàÁ≤ÇÊ†óÁπ∞Ê°ëÈç¨Âã≤ÂêõËñ´Ë®ìÁæ§ËªçÈÉ°Âç¶Ë¢àÁ•Å‰øÇÂÇæÂàëÂÖÑÂïìÂú≠Áè™ÂûãÂ•ëÂΩ¢ÂæÑÊÅµÊÖ∂ÊÖßÊÜ©Êé≤Êê∫Êï¨ÊôØÊ°ÇÊ∏ìÁï¶Á®ΩÁ≥ªÁµåÁ∂ôÁπãÁΩ´ËåéËçäËõçË®àË©£Ë≠¶ËªΩÈ†öÈ∂èËä∏ËøéÈØ®ÂäáÊàüÊíÉÊøÄÈöôÊ°ÅÂÇëÊ¨†Ê±∫ÊΩîÁ©¥ÁµêË°ÄË®£Êúà‰ª∂ÂÄπÂÄ¶ÂÅ•ÂÖºÂà∏Ââ£ÂñßÂúèÂ†ÖÂ´åÂª∫ÊÜ≤Êá∏Êã≥Êç≤"],["b8a1","Ê§úÊ®©ÁâΩÁä¨ÁåÆÁ†îÁ°ØÁµπÁúåËÇ©Ë¶ãË¨ôË≥¢ËªíÈÅ£ÈçµÈô∫È°ïÈ®ìÈπ∏ÂÖÉÂéüÂé≥ÂπªÂº¶Ê∏õÊ∫êÁéÑÁèæÁµÉËà∑Ë®ÄË´∫Èôê‰πéÂÄãÂè§ÂëºÂõ∫ÂßëÂ≠§Â∑±Â∫´ÂºßÊà∏ÊïÖÊûØÊπñÁãêÁ≥äË¢¥ËÇ°ËÉ°Ëè∞ËôéË™áË∑®Èà∑ÈõáÈ°ßÈºì‰∫î‰∫í‰ºçÂçàÂëâÂêæÂ®ØÂæåÂæ°ÊÇüÊ¢ßÊ™éÁëöÁ¢ÅË™ûË™§Ë≠∑ÈÜê‰πûÈØâ‰∫§‰Ωº‰æØÂÄôÂÄñÂÖâÂÖ¨ÂäüÂäπÂãæÂéöÂè£Âêë"],["b9a1","ÂêéÂñâÂùëÂû¢Â•ΩÂ≠îÂ≠ùÂÆèÂ∑•Â∑ßÂ∑∑Âπ∏Â∫ÉÂ∫öÂ∫∑ÂºòÊÅíÊÖåÊäóÊãòÊéßÊîªÊòÇÊôÉÊõ¥Êù≠Ê†°Ê¢óÊßãÊ±üÊ¥™Êµ©Ê∏ØÊ∫ùÁî≤ÁöáÁ°¨Á®øÁ≥†Á¥ÖÁ¥òÁµûÁ∂±ËÄïËÄÉËÇØËÇ±ËÖîËÜèËà™ËçíË°åË°°Ë¨õË≤¢Ë≥ºÈÉäÈÖµÈâ±Á†øÈãºÈñ§ÈôçÈ†ÖÈ¶ôÈ´òÈ¥ªÂâõÂä´Âè∑ÂêàÂ£ïÊã∑Êø†Ë±™ËΩüÈ∫πÂÖãÂàªÂëäÂõΩÁ©ÄÈÖ∑Èµ†ÈªíÁçÑÊºâËÖ∞ÁîëÂøΩÊÉöÈ™®ÁãõËæº"],["baa1","Ê≠§È†É‰ªäÂõ∞Âù§Â¢æÂ©öÊÅ®ÊááÊòèÊòÜÊ†πÊ¢±Ê∑∑ÁóïÁ¥∫ËâÆÈ≠Ç‰∫õ‰ΩêÂèâÂîÜÂµØÂ∑¶Â∑ÆÊüªÊ≤ôÁë≥Á†ÇË©êÈéñË£üÂùêÂ∫ßÊå´ÂÇµÂÇ¨ÂÜçÊúÄÂìâÂ°ûÂ¶ªÂÆ∞ÂΩ©ÊâçÊé°Ê†ΩÊ≠≥Ê∏àÁÅΩÈááÁäÄÁ†ïÁ†¶Á•≠ÊñéÁ¥∞ËèúË£ÅËºâÈöõÂâ§Âú®ÊùêÁΩ™Ë≤°ÂÜ¥ÂùÇÈò™Â†∫Ê¶äËÇ¥Âí≤Â¥éÂüºÁ¢ïÈ∑∫‰ΩúÂâäÂíãÊêæÊò®ÊúîÊüµÁ™ÑÁ≠ñÁ¥¢ÈåØÊ°úÈÆ≠Á¨πÂåôÂÜäÂà∑"],["bba1","ÂØüÊã∂ÊíÆÊì¶Êú≠ÊÆ∫Ëñ©ÈõëÁöêÈØñÊçåÈåÜÈÆ´ÁöøÊôí‰∏âÂÇòÂèÇÂ±±ÊÉ®ÊííÊï£Ê°üÁá¶ÁèäÁî£ÁÆóÁ∫ÇËöïËÆÉË≥õÈÖ∏È§êÊñ¨Êö´ÊÆã‰ªï‰ªî‰º∫‰ΩøÂà∫Âè∏Âè≤Âó£ÂõõÂ£´ÂßãÂßâÂßøÂ≠êÂ±çÂ∏ÇÂ∏´ÂøóÊÄùÊåáÊîØÂ≠úÊñØÊñΩÊó®ÊûùÊ≠¢Ê≠ªÊ∞èÁçÖÁ•âÁßÅÁ≥∏Á¥ôÁ¥´ËÇ¢ËÑÇËá≥Ë¶ñË©ûË©©Ë©¶Ë™åË´ÆË≥áË≥úÈõåÈ£ºÊ≠Ø‰∫ã‰ºº‰æçÂÖêÂ≠óÂØ∫ÊÖàÊåÅÊôÇ"],["bca1","Ê¨°ÊªãÊ≤ªÁàæÁíΩÁóîÁ£ÅÁ§∫ËÄåËÄ≥Ëá™ËíîËæûÊ±êÈπøÂºèË≠òÈ¥´Á´∫Ëª∏ÂÆçÈõ´‰∏ÉÂè±Âü∑Â§±Â´âÂÆ§ÊÇâÊπøÊºÜÁñæË≥™ÂÆüËîÄÁØ†ÂÅ≤Êü¥ËäùÂ±°ËïäÁ∏ûËàéÂÜôÂ∞ÑÊç®Ëµ¶ÊñúÁÖÆÁ§æÁ¥óËÄÖË¨ùËªäÈÅÆËõáÈÇ™ÂÄüÂã∫Â∞∫ÊùìÁÅºÁàµÈÖåÈáàÈå´Ëã•ÂØÇÂº±ÊÉπ‰∏ªÂèñÂÆàÊâãÊú±ÊÆäÁã©Áè†Á®ÆËÖ´Ë∂£ÈÖíÈ¶ñÂÑíÂèóÂë™ÂØøÊéàÊ®πÁ∂¨ÈúÄÂõöÂèéÂë®"],["bda1","ÂÆóÂ∞±Â∑û‰øÆÊÑÅÊãæÊ¥≤ÁßÄÁßãÁµÇÁπçÁøíËá≠ËàüËíêË°ÜË•≤ËÆêËπ¥ËºØÈÄ±ÈÖãÈÖ¨ÈõÜÈÜú‰ªÄ‰ΩèÂÖÖÂçÅÂæìÊàéÊüîÊ±ÅÊ∏ãÁç£Á∏¶ÈáçÈäÉÂèîÂ§ôÂÆøÊ∑ëÁ•ùÁ∏ÆÁ≤õÂ°æÁÜüÂá∫Ë°ìËø∞‰øäÂ≥ªÊò•Áû¨Á´£ËàúÈßøÂáÜÂæ™Êó¨Ê•ØÊÆâÊ∑≥Ê∫ñÊΩ§ÁõæÁ¥îÂ∑°ÈÅµÈÜáÈ†ÜÂá¶ÂàùÊâÄÊöëÊõôÊ∏öÂ∫∂Á∑íÁΩ≤Êõ∏ËñØËó∑Ë´∏Âä©ÂèôÂ•≥Â∫èÂæêÊÅïÈã§Èô§ÂÇ∑ÂÑü"],["bea1","ÂãùÂå†ÂçáÂè¨Âì®ÂïÜÂî±ÂòóÂ•®Â¶æÂ®ºÂÆµÂ∞ÜÂ∞èÂ∞ëÂ∞öÂ∫ÑÂ∫äÂª†ÂΩ∞ÊâøÊäÑÊãõÊéåÊç∑ÊòáÊòåÊò≠Êô∂ÊùæÊ¢¢Ê®üÊ®µÊ≤ºÊ∂àÊ∏âÊπòÁÑºÁÑ¶ÁÖßÁóáÁúÅÁ°ùÁ§ÅÁ••Áß∞Á´†Á¨ëÁ≤ßÁ¥πËÇñËèñËíãËïâË°ùË£≥Ë®üË®ºË©îË©≥Ë±°Ë≥ûÈÜ§Èâ¶ÈçæÈêòÈöúÈûò‰∏ä‰∏à‰∏û‰πóÂÜóÂâ∞ÂüéÂ†¥Â£åÂ¨¢Â∏∏ÊÉÖÊìæÊù°ÊùñÊµÑÁä∂Áï≥Á©£Ëí∏Ë≠≤ÈÜ∏Èå†Âò±Âü¥È£æ"],["bfa1","Êã≠Ê§çÊÆñÁá≠ÁπîËÅ∑Ëâ≤Ëß¶È£üËùïËæ±Â∞ª‰º∏‰ø°‰æµÂîáÂ®†ÂØùÂØ©ÂøÉÊÖéÊåØÊñ∞ÊôãÊ£ÆÊ¶õÊµ∏Ê∑±Áî≥ÁñπÁúüÁ•ûÁß¶Á¥≥Ëá£ËäØËñ™Ë¶™Ë®∫Ë∫´ËæõÈÄ≤ÈáùÈúá‰∫∫‰ªÅÂàÉÂ°µÂ£¨Â∞ãÁîöÂ∞ΩËÖéË®äËøÖÈô£Èù≠Á¨•Ë´èÈ†àÈÖ¢Âõ≥Âé®ÈÄóÂêπÂûÇÂ∏•Êé®Ê∞¥ÁÇäÁù°Á≤ãÁø†Ë°∞ÈÅÇÈÖîÈåêÈåòÈöèÁëûÈ´ÑÂ¥áÂµ©Êï∞Êû¢Ë∂®ÈõõÊçÆÊùâÊ§ôËèÖÈ†óÈõÄË£æ"],["c0a1","ÊæÑÊë∫ÂØ∏‰∏ñÁÄ¨ÁïùÊòØÂáÑÂà∂Âã¢ÂßìÂæÅÊÄßÊàêÊîøÊï¥ÊòüÊô¥Ê£≤Ê†ñÊ≠£Ê∏ÖÁâ≤ÁîüÁõõÁ≤æËÅñÂ£∞Ë£ΩË•øË™†Ë™ìË´ãÈÄùÈÜíÈùíÈùôÊñâÁ®éËÑÜÈöªÂ∏≠ÊÉúÊàöÊñ•ÊòîÊûêÁü≥Á©çÁ±çÁ∏æËÑäË≤¨Ëµ§Ë∑°ËπüÁ¢©ÂàáÊãôÊé•ÊëÇÊäòË®≠Á™ÉÁØÄË™¨Èõ™Áµ∂ËàåËùâ‰ªôÂÖàÂçÉÂç†ÂÆ£Â∞ÇÂ∞ñÂ∑ùÊà¶ÊâáÊí∞Ê†ìÊ†¥Ê≥âÊµÖÊ¥óÊüìÊΩúÁÖéÁÖΩÊóãÁ©øÁÆ≠Á∑ö"],["c1a1","ÁπäÁæ®ËÖ∫ËàõËàπËñ¶Ë©ÆË≥éË∑µÈÅ∏ÈÅ∑Èä≠ÈäëÈñÉÈÆÆÂâçÂñÑÊº∏ÁÑ∂ÂÖ®Á¶ÖÁπïËÜ≥Á≥éÂôåÂ°ëÂ≤®Êé™ÊõæÊõΩÊ•öÁãôÁñèÁñéÁ§éÁ•ñÁßüÁ≤óÁ¥†ÁµÑËòáË®¥ÈòªÈÅ°Èº†ÂÉßÂâµÂèåÂè¢ÂÄâÂñ™Â£ÆÂ•èÁàΩÂÆãÂ±§ÂåùÊÉ£ÊÉ≥ÊçúÊéÉÊåøÊéªÊìçÊó©ÊõπÂ∑£ÊßçÊßΩÊºïÁá•‰∫âÁó©Áõ∏Á™ìÁ≥üÁ∑èÁ∂úËÅ°ËçâËçòËë¨ËíºËóªË£ÖËµ∞ÈÄÅÈÅ≠ÈéóÈúúÈ®íÂÉèÂ¢óÊÜé"],["c2a1","ËáìËîµË¥àÈÄ†‰øÉÂÅ¥ÂâáÂç≥ÊÅØÊçâÊùüÊ∏¨Ë∂≥ÈÄü‰øóÂ±ûË≥äÊóèÁ∂öÂçíË¢ñÂÖ∂ÊèÉÂ≠òÂ≠´Â∞äÊêçÊùëÈÅú‰ªñÂ§öÂ§™Ê±∞Ë©ëÂîæÂ†ïÂ¶•ÊÉ∞ÊâìÊüÅËàµÊ•ïÈôÄÈßÑÈ®®‰ΩìÂ†ÜÂØæËÄêÂ≤±Â∏ØÂæÖÊÄ†ÊÖãÊà¥ÊõøÊ≥∞ÊªûËÉéËÖøËãîË¢ãË≤∏ÈÄÄÈÄÆÈöäÈªõÈØõ‰ª£Âè∞Â§ßÁ¨¨ÈÜçÈ°åÈ∑πÊªùÁÄßÂçìÂïÑÂÆÖÊâòÊäûÊãìÊ≤¢ÊøØÁê¢Ë®óÈê∏ÊøÅË´æËå∏ÂáßËõ∏Âè™"],["c3a1","Âè©‰ΩÜÈÅîËæ∞Â•™ËÑ±Â∑ΩÁ´™ËæøÊ£öË∞∑Áã∏È±àÊ®ΩË™∞‰∏πÂçòÂòÜÂù¶ÊãÖÊé¢Êó¶Ê≠éÊ∑°ÊπõÁÇ≠Áü≠Á´ØÁÆ™Á∂ªËÄΩËÉÜËõãË™ïÈçõÂõ£Â£áÂºæÊñ≠ÊöñÊ™ÄÊÆµÁî∑Ë´áÂÄ§Áü•Âú∞ÂºõÊÅ•Êô∫Ê±†Áó¥Á®öÁΩÆËá¥ËúòÈÅÖÈ¶≥ÁØâÁïúÁ´πÁ≠ëËìÑÈÄêÁß©Á™íËå∂Â´°ÁùÄ‰∏≠‰ª≤ÂÆôÂø†ÊäΩÊòºÊü±Ê≥®Ëô´Ë°∑Ë®ªÈÖéÈã≥ÈßêÊ®óÁÄ¶Áå™ËãßËëóË≤Ø‰∏ÅÂÖÜÂáãÂñãÂØµ"],["c4a1","Â∏ñÂ∏≥Â∫ÅÂºîÂºµÂΩ´Âæ¥Êá≤ÊåëÊö¢ÊúùÊΩÆÁâíÁî∫Áú∫ËÅ¥ËÑπËÖ∏Ëù∂Ë™øË´úË∂ÖË∑≥ÈäöÈï∑È†ÇÈ≥•ÂãÖÊçóÁõ¥ÊúïÊ≤àÁèçË≥ÉÈéÆÈô≥Ê¥•Â¢úÊ§éÊßåËøΩÈéöÁóõÈÄöÂ°öÊ†ÇÊé¥Êßª‰ΩÉÊº¨ÊüòËæªËî¶Á∂¥ÈçîÊ§øÊΩ∞Âù™Â£∑Â¨¨Á¥¨Áà™ÂêäÈá£È∂¥‰∫≠‰ΩéÂÅúÂÅµÂâÉË≤ûÂëàÂ†§ÂÆöÂ∏ùÂ∫ïÂ∫≠Âª∑ÂºüÊÇåÊäµÊå∫ÊèêÊ¢ØÊ±ÄÁ¢áÁ¶éÁ®ãÁ∑†ËâáË®ÇË´¶ËπÑÈÄì"],["c5a1","ÈÇ∏ÈÑ≠ÈáòÈºéÊ≥•ÊëòÊì¢ÊïµÊª¥ÁöÑÁ¨õÈÅ©ÈèëÊ∫∫Âì≤ÂæπÊí§ËΩçËø≠ÈâÑÂÖ∏Â°´Â§©Â±ïÂ∫óÊ∑ªÁ∫èÁîúË≤ºËª¢È°õÁÇπ‰ºùÊÆøÊæ±Áî∞ÈõªÂÖéÂêêÂ†µÂ°óÂ¶¨Â±†ÂæíÊñóÊùúÊ∏°ÁôªËèüË≥≠ÈÄîÈÉΩÈççÁ†•Á†∫Âä™Â∫¶ÂúüÂ•¥ÊÄíÂÄíÂÖöÂÜ¨ÂáçÂàÄÂîêÂ°îÂ°òÂ•óÂÆïÂ≥∂Â∂ãÊÇºÊäïÊê≠Êù±Ê°ÉÊ¢ºÊ£üÁõóÊ∑òÊπØÊ∂õÁÅØÁáàÂΩìÁóòÁ•∑Á≠âÁ≠îÁ≠íÁ≥ñÁµ±Âà∞"],["c6a1","Ëë£Ëï©Ëó§Ë®éË¨ÑË±ÜË∏èÈÄÉÈÄèÈêôÈô∂È†≠È®∞ÈóòÂÉçÂãïÂêåÂ†ÇÂ∞éÊÜßÊíûÊ¥ûÁû≥Á´•ËÉ¥ËêÑÈÅìÈäÖÂ≥†È¥áÂåøÂæóÂæ≥Ê∂úÁâπÁù£Á¶øÁØ§ÊØíÁã¨Ë™≠Ê†ÉÊ©°Âá∏Á™ÅÊ§¥Â±äÈ≥∂Ëã´ÂØÖÈÖâÁÄûÂô∏Â±ØÊÉáÊï¶Ê≤åË±öÈÅÅÈ†ìÂëëÊõáÈàçÂ•àÈÇ£ÂÜÖ‰πçÂá™ËñôË¨éÁÅòÊç∫ÈçãÊ•¢È¶¥Á∏ÑÁï∑ÂçóÊ•†ËªüÈõ£Ê±ù‰∫åÂ∞ºÂºêËø©ÂåÇË≥ëËÇâËôπÂªøÊó•‰π≥ÂÖ•"],["c7a1","Â¶ÇÂ∞øÈüÆ‰ªªÂ¶äÂøçË™çÊø°Á¶∞Á•¢ÂØßËë±Áå´ÁÜ±Âπ¥ÂøµÊçªÊíöÁáÉÁ≤ò‰πÉÂªº‰πãÂüúÂö¢ÊÇ©ÊøÉÁ¥çËÉΩËÑ≥ËÜøËæ≤Ë¶óËö§Â∑¥ÊääÊí≠Ë¶áÊù∑Ê≥¢Ê¥æÁê∂Á†¥Â©ÜÁΩµËä≠È¶¨‰ø≥ÂªÉÊãùÊéíÊïóÊùØÁõÉÁâåËÉåËÇ∫Ëº©ÈÖçÂÄçÂüπÂ™íÊ¢ÖÊ•≥ÁÖ§ÁãΩË≤∑Â£≤Ë≥†Èô™ÈÄôËùøÁß§ÁüßËê©‰ºØÂâ•ÂçöÊãçÊüèÊ≥äÁôΩÁÆîÁ≤ïËà∂ËñÑËø´ÊõùÊº†ÁàÜÁ∏õËé´ÈßÅÈ∫¶"],["c8a1","ÂáΩÁÆ±Á°≤ÁÆ∏ËÇáÁ≠àÊ´®Âπ°ËÇåÁïëÁï†ÂÖ´Èâ¢Ê∫åÁô∫ÈÜóÈ´™‰ºêÁΩ∞ÊäúÁ≠èÈñ•È≥©Âô∫Â°ôËõ§Èöº‰º¥Âà§ÂçäÂèçÂèõÂ∏ÜÊê¨ÊñëÊùøÊ∞æÊ±éÁâàÁäØÁè≠ÁïîÁπÅËà¨Ëó©Ë≤©ÁØÑÈáÜÁÖ©È†íÈ£ØÊåΩÊô©Áï™Áõ§Á£êËïÉËõÆÂå™ÂçëÂê¶Â¶ÉÂ∫áÂΩºÊÇ≤ÊââÊâπÊä´ÊñêÊØîÊ≥åÁñ≤ÁöÆÁ¢ëÁßòÁ∑ãÁΩ∑ËÇ•Ë¢´Ë™πË≤ªÈÅøÈùûÈ£õÊ®ãÁ∞∏ÂÇôÂ∞æÂæÆÊûáÊØòÁêµÁúâÁæé"],["c9a1","ÈºªÊüäÁ®óÂåπÁñãÈ´≠ÂΩ¶ËÜùËè±ËÇòÂººÂøÖÁï¢Á≠ÜÈÄºÊ°ßÂß´Â™õÁ¥êÁôæË¨¨‰øµÂΩ™Ê®ôÊ∞∑ÊºÇÁì¢Á•®Ë°®Ë©ïË±πÂªüÊèèÁóÖÁßíËãóÈå®Èã≤ËíúËõ≠È∞≠ÂìÅÂΩ¨ÊñåÊµúÁÄïË≤ßË≥ìÈ†ªÊïèÁì∂‰∏ç‰ªòÂü†Â§´Â©¶ÂØåÂÜ®Â∏ÉÂ∫úÊÄñÊâ∂Êï∑ÊñßÊôÆÊµÆÁà∂Á¨¶ËÖêËÜöËäôË≠úË≤†Ë≥¶Ëµ¥ÈòúÈôÑ‰æÆÊí´Ê≠¶ËàûËë°Ëï™ÈÉ®Â∞ÅÊ•ìÈ¢®Ëë∫Ëïó‰ºèÂâØÂæ©ÂπÖÊúç"],["caa1","Á¶èËÖπË§áË¶ÜÊ∑µÂºóÊâïÊ≤∏‰ªèÁâ©ÈÆíÂàÜÂêªÂô¥Â¢≥ÊÜ§ÊâÆÁÑöÂ•ÆÁ≤âÁ≥ûÁ¥õÈõ∞ÊñáËÅû‰∏ô‰ΩµÂÖµÂ°ÄÂπ£Âπ≥ÂºäÊüÑ‰∏¶ËîΩÈñâÈôõÁ±≥È†ÅÂÉªÂ£ÅÁôñÁ¢ßÂà•Áû•ËîëÁÆÜÂÅèÂ§âÁâáÁØáÁ∑®Ëæ∫ËøîÈÅç‰æøÂãâÂ®©ÂºÅÈû≠‰øùËàóÈã™ÂúÉÊçïÊ≠©Áî´Ë£úËºîÁ©ÇÂãüÂ¢ìÊÖïÊàäÊöÆÊØçÁ∞øËè©ÂÄ£‰ø∏ÂåÖÂëÜÂ†±Â•âÂÆùÂ≥∞Â≥ØÂ¥©Â∫ñÊä±ÊçßÊîæÊñπÊúã"],["cba1","Ê≥ïÊ≥°ÁÉπÁ†≤Á∏´ËÉûËä≥ËêåËì¨ËúÇË§íË®™Ë±äÈÇ¶ÈãíÈ£ΩÈ≥≥Èµ¨‰πè‰∫°ÂÇçÂâñÂùäÂ¶®Â∏ΩÂøòÂøôÊàøÊö¥ÊúõÊüêÊ£íÂÜíÁ¥°ËÇ™ËÜ®Ë¨ÄË≤åË≤øÈâæÈò≤Âê†È†¨ÂåóÂÉïÂçúÂ¢®Êí≤Êú¥ÁâßÁù¶Á©ÜÈá¶ÂãÉÊ≤°ÊÆÜÂ†ÄÂπåÂ•îÊú¨ÁøªÂá°ÁõÜÊë©Á£®È≠îÈ∫ªÂüãÂ¶πÊòßÊûöÊØéÂì©ÊßôÂπïËÜúÊûïÈÆ™ÊüæÈ±íÊ°ù‰∫¶‰ø£ÂèàÊäπÊú´Ê≤´ËøÑ‰æ≠Áπ≠È∫ø‰∏áÊÖ¢Ê∫Ä"],["cca1","Êº´ËîìÂë≥Êú™È≠ÖÂ∑≥ÁÆïÂ≤¨ÂØÜËúúÊπäËìëÁ®îËÑàÂ¶ôÁ≤çÊ∞ëÁú†ÂãôÂ§¢ÁÑ°ÁâüÁüõÈúßÈµ°Ê§ãÂ©øÂ®òÂÜ•ÂêçÂëΩÊòéÁõüËø∑ÈäòÈ≥¥Âß™ÁâùÊªÖÂÖçÊ£âÁ∂øÁ∑¨Èù¢È∫∫Êë∏Ê®°ËåÇÂ¶ÑÂ≠üÊØõÁåõÁõ≤Á∂≤ËÄóËíôÂÑ≤Êú®ÈªôÁõÆÊù¢ÂãøÈ§ÖÂ∞§ÊàªÁ±æË≤∞ÂïèÊÇ∂Á¥ãÈñÄÂåÅ‰πüÂÜ∂Â§úÁà∫ËÄ∂ÈáéÂº•Áü¢ÂéÑÂΩπÁ¥ÑËñ¨Ë®≥Ë∫çÈùñÊü≥ËñÆÈëìÊÑâÊÑàÊ≤πÁôí"],["cda1","Ë´≠Ëº∏ÂîØ‰ΩëÂÑ™ÂãáÂèãÂÆ•ÂπΩÊÇ†ÊÜÇÊèñÊúâÊüöÊπßÊ∂åÁå∂Áå∑Áî±Á•êË£ïË™òÈÅäÈÇëÈÉµÈõÑËûçÂ§ï‰∫à‰Ωô‰∏éË™âËºøÈ†êÂÇ≠ÂπºÂ¶ñÂÆπÂ∫∏ÊèöÊè∫ÊìÅÊõúÊ•äÊßòÊ¥ãÊ∫∂ÁÜîÁî®Á™ØÁæäËÄÄËëâËìâË¶ÅË¨°Ë∏äÈÅ•ÈôΩÈ§äÊÖæÊäëÊ¨≤Ê≤ÉÊµ¥ÁøåÁøºÊ∑ÄÁæÖËû∫Ë£∏Êù•Ëé±È†ºÈõ∑Ê¥õÁµ°ËêΩÈÖ™‰π±ÂçµÂµêÊ¨ÑÊø´ËóçËò≠Ë¶ßÂà©ÂêèÂ±•ÊùéÊ¢®ÁêÜÁíÉ"],["cea1","Áó¢Ë£èË£°ÈáåÈõ¢Èô∏ÂæãÁéáÁ´ãËëéÊé†Áï•ÂäâÊµÅÊ∫úÁêâÁïôÁ°´Á≤íÈöÜÁ´úÈæç‰æ∂ÊÖÆÊóÖËôú‰∫Ü‰∫ÆÂÉö‰∏°ÂáåÂØÆÊñôÊ¢ÅÊ∂ºÁåüÁôÇÁû≠Á®úÁ≥ßËâØË´íÈÅºÈáèÈôµÈ†òÂäõÁ∑ëÂÄ´ÂéòÊûóÊ∑ãÁáêÁê≥Ëá®Ëº™Èö£È±óÈ∫üÁë†Â°ÅÊ∂ôÁ¥ØÈ°û‰ª§‰º∂‰æãÂÜ∑Âä±Â∂∫ÊÄúÁé≤Á§ºËãìÈà¥Èö∑Èõ∂ÈúäÈ∫óÈΩ¢Êö¶Ê≠¥ÂàóÂä£ÁÉàË£ÇÂªâÊÅãÊÜêÊº£ÁÖâÁ∞æÁ∑¥ËÅØ"],["cfa1","ËìÆÈÄ£Èå¨ÂëÇÈ≠ØÊ´ìÁÇâË≥ÇË∑ØÈú≤Âä¥Â©ÅÂªäÂºÑÊúóÊ•ºÊ¶îÊµ™ÊºèÁâ¢ÁãºÁØ≠ËÄÅËÅæËùãÈÉéÂÖ≠È∫ìÁ¶ÑËÇãÈå≤Ë´ñÂÄ≠ÂíåË©±Ê≠™Ë≥ÑËÑáÊÉëÊû†È∑≤‰∫ô‰∫òÈ∞êË©´ËóÅËï®Ê§ÄÊπæÁ¢óËÖï"],["d0a1","Âºå‰∏ê‰∏ï‰∏™‰∏±‰∏∂‰∏º‰∏ø‰πÇ‰πñ‰πò‰∫Ç‰∫ÖË±´‰∫äËàíÂºç‰∫é‰∫û‰∫ü‰∫†‰∫¢‰∫∞‰∫≥‰∫∂‰ªé‰ªç‰ªÑ‰ªÜ‰ªÇ‰ªó‰ªû‰ª≠‰ªü‰ª∑‰ºâ‰Ωö‰º∞‰Ωõ‰Ωù‰Ωó‰Ωá‰Ω∂‰æà‰æè‰æò‰Ωª‰Ω©‰Ω∞‰æë‰ΩØ‰æÜ‰æñÂÑò‰øî‰øü‰øé‰øò‰øõ‰øë‰øö‰øê‰ø§‰ø•ÂÄöÂÄ®ÂÄîÂÄ™ÂÄ•ÂÄÖ‰ºú‰ø∂ÂÄ°ÂÄ©ÂÄ¨‰øæ‰øØÂÄëÂÄÜÂÅÉÂÅáÊúÉÂÅïÂÅêÂÅàÂÅöÂÅñÂÅ¨ÂÅ∏ÂÇÄÂÇöÂÇÖÂÇ¥ÂÇ≤"],["d1a1","ÂÉâÂÉäÂÇ≥ÂÉÇÂÉñÂÉûÂÉ•ÂÉ≠ÂÉ£ÂÉÆÂÉπÂÉµÂÑâÂÑÅÂÑÇÂÑñÂÑïÂÑîÂÑöÂÑ°ÂÑ∫ÂÑ∑ÂÑºÂÑªÂÑøÂÖÄÂÖíÂÖåÂÖîÂÖ¢Á´∏ÂÖ©ÂÖ™ÂÖÆÂÜÄÂÜÇÂõòÂÜåÂÜâÂÜèÂÜëÂÜìÂÜïÂÜñÂÜ§ÂÜ¶ÂÜ¢ÂÜ©ÂÜ™ÂÜ´ÂÜ≥ÂÜ±ÂÜ≤ÂÜ∞ÂÜµÂÜΩÂáÖÂáâÂáõÂá†ËôïÂá©Âá≠Âá∞ÂáµÂáæÂàÑÂàãÂàîÂàéÂàßÂà™ÂàÆÂà≥ÂàπÂâèÂâÑÂâãÂâåÂâûÂâîÂâ™Ââ¥Ââ©Ââ≥ÂâøÂâΩÂäçÂäîÂäíÂâ±ÂäàÂäëËæ®"],["d2a1","ËæßÂä¨Âä≠ÂäºÂäµÂãÅÂãçÂãóÂãûÂã£Âã¶È£≠Âã†Âã≥ÂãµÂã∏ÂãπÂåÜÂåàÁî∏ÂåçÂåêÂåèÂåïÂåöÂå£ÂåØÂå±Âå≥Âå∏ÂçÄÂçÜÂçÖ‰∏óÂçâÂççÂáñÂçûÂç©ÂçÆÂ§òÂçªÂç∑ÂéÇÂéñÂé†Âé¶Âé•ÂéÆÂé∞Âé∂ÂèÉÁ∞íÈõôÂèüÊõºÁáÆÂèÆÂè®Âè≠Âè∫ÂêÅÂêΩÂëÄÂê¨Âê≠ÂêºÂêÆÂê∂Âê©ÂêùÂëéÂíèÂëµÂíéÂëüÂë±Âë∑Âë∞ÂííÂëªÂíÄÂë∂ÂíÑÂíêÂíÜÂìáÂí¢Âí∏Âí•Âí¨ÂìÑÂìàÂí®"],["d3a1","Âí´ÂìÇÂí§ÂíæÂíºÂìòÂì•Âì¶ÂîèÂîîÂìΩÂìÆÂì≠Âì∫Âì¢ÂîπÂïÄÂï£ÂïåÂîÆÂïúÂïÖÂïñÂïóÂî∏Âî≥ÂïùÂñôÂñÄÂíØÂñäÂñüÂïªÂïæÂñòÂñûÂñÆÂïºÂñÉÂñ©ÂñáÂñ®ÂóöÂóÖÂóüÂóÑÂóúÂó§ÂóîÂòîÂó∑ÂòñÂóæÂóΩÂòõÂóπÂôéÂôêÁáüÂò¥Âò∂Âò≤Âò∏Âô´Âô§ÂòØÂô¨Âô™ÂöÜÂöÄÂöäÂö†ÂöîÂöèÂö•ÂöÆÂö∂Âö¥ÂõÇÂöºÂõÅÂõÉÂõÄÂõàÂõéÂõëÂõìÂõóÂõÆÂõπÂúÄÂõøÂúÑÂúâ"],["d4a1","ÂúàÂúãÂúçÂúìÂúòÂúñÂóáÂúúÂú¶Âú∑Âú∏ÂùéÂúªÂùÄÂùèÂù©ÂüÄÂûàÂù°ÂùøÂûâÂûìÂû†Âû≥Âû§Âû™Âû∞ÂüÉÂüÜÂüîÂüíÂüìÂ†äÂüñÂü£Â†ãÂ†ôÂ†ùÂ°≤Â†°Â°¢Â°ãÂ°∞ÊØÄÂ°íÂ†ΩÂ°πÂ¢ÖÂ¢πÂ¢üÂ¢´Â¢∫Â£ûÂ¢ªÂ¢∏Â¢ÆÂ£ÖÂ£ìÂ£ëÂ£óÂ£ôÂ£òÂ£•Â£úÂ£§Â£üÂ£ØÂ£∫Â£πÂ£ªÂ£ºÂ£ΩÂ§ÇÂ§äÂ§êÂ§õÊ¢¶Â§•Â§¨Â§≠Â§≤Â§∏Â§æÁ´íÂ•ïÂ•êÂ•éÂ•öÂ•òÂ•¢Â•†Â•ßÂ•¨Â•©"],["d5a1","Â•∏Â¶ÅÂ¶ù‰Ωû‰æ´Â¶£Â¶≤ÂßÜÂß®ÂßúÂ¶çÂßôÂßöÂ®•Â®üÂ®ëÂ®úÂ®âÂ®öÂ©ÄÂ©¨Â©âÂ®µÂ®∂Â©¢Â©™Â™öÂ™ºÂ™æÂ´ãÂ´ÇÂ™ΩÂ´£Â´óÂ´¶Â´©Â´ñÂ´∫Â´ªÂ¨åÂ¨ãÂ¨ñÂ¨≤Â´êÂ¨™Â¨∂Â¨æÂ≠ÉÂ≠ÖÂ≠ÄÂ≠ëÂ≠ïÂ≠öÂ≠õÂ≠•Â≠©Â≠∞Â≠≥Â≠µÂ≠∏ÊñàÂ≠∫ÂÆÄÂÆÉÂÆ¶ÂÆ∏ÂØÉÂØáÂØâÂØîÂØêÂØ§ÂØ¶ÂØ¢ÂØûÂØ•ÂØ´ÂØ∞ÂØ∂ÂØ≥Â∞ÖÂ∞áÂ∞àÂ∞çÂ∞ìÂ∞†Â∞¢Â∞®Â∞∏Â∞πÂ±ÅÂ±ÜÂ±éÂ±ì"],["d6a1","Â±êÂ±èÂ≠±Â±¨Â±Æ‰π¢Â±∂Â±πÂ≤åÂ≤ëÂ≤îÂ¶õÂ≤´Â≤ªÂ≤∂Â≤ºÂ≤∑Â≥ÖÂ≤æÂ≥áÂ≥ôÂ≥©Â≥ΩÂ≥∫Â≥≠Â∂åÂ≥™Â¥ãÂ¥ïÂ¥óÂµúÂ¥üÂ¥õÂ¥ëÂ¥îÂ¥¢Â¥öÂ¥ôÂ¥òÂµåÂµíÂµéÂµãÂµ¨Âµ≥Âµ∂Â∂áÂ∂ÑÂ∂ÇÂ∂¢Â∂ùÂ∂¨Â∂ÆÂ∂ΩÂ∂êÂ∂∑Â∂ºÂ∑âÂ∑çÂ∑ìÂ∑íÂ∑ñÂ∑õÂ∑´Â∑≤Â∑µÂ∏ãÂ∏öÂ∏ôÂ∏ëÂ∏õÂ∏∂Â∏∑ÂπÑÂπÉÂπÄÂπéÂπóÂπîÂπüÂπ¢Âπ§ÂπáÂπµÂπ∂Âπ∫È∫ºÂπøÂ∫†ÂªÅÂªÇÂªàÂªêÂªè"],["d7a1","ÂªñÂª£ÂªùÂªöÂªõÂª¢Âª°Âª®Âª©Âª¨Âª±Âª≥Âª∞Âª¥Âª∏ÂªæÂºÉÂºâÂΩùÂΩúÂºãÂºëÂºñÂº©Âº≠Âº∏ÂΩÅÂΩàÂΩåÂΩéÂºØÂΩëÂΩñÂΩóÂΩôÂΩ°ÂΩ≠ÂΩ≥ÂΩ∑ÂæÉÂæÇÂΩøÂæäÂæàÂæëÂæáÂæûÂæôÂæòÂæ†Âæ®Âæ≠ÂæºÂøñÂøªÂø§Âø∏Âø±ÂøùÊÇ≥ÂøøÊÄ°ÊÅ†ÊÄôÊÄêÊÄ©ÊÄéÊÄ±ÊÄõÊÄïÊÄ´ÊÄ¶ÊÄèÊÄ∫ÊÅöÊÅÅÊÅ™ÊÅ∑ÊÅüÊÅäÊÅÜÊÅçÊÅ£ÊÅÉÊÅ§ÊÅÇÊÅ¨ÊÅ´ÊÅôÊÇÅÊÇçÊÉßÊÇÉÊÇö"],["d8a1","ÊÇÑÊÇõÊÇñÊÇóÊÇíÊÇßÊÇãÊÉ°ÊÇ∏ÊÉ†ÊÉìÊÇ¥Âø∞ÊÇΩÊÉÜÊÇµÊÉòÊÖçÊÑïÊÑÜÊÉ∂ÊÉ∑ÊÑÄÊÉ¥ÊÉ∫ÊÑÉÊÑ°ÊÉªÊÉ±ÊÑçÊÑéÊÖáÊÑæÊÑ®ÊÑßÊÖäÊÑøÊÑºÊÑ¨ÊÑ¥ÊÑΩÊÖÇÊÖÑÊÖ≥ÊÖ∑ÊÖòÊÖôÊÖöÊÖ´ÊÖ¥ÊÖØÊÖ•ÊÖ±ÊÖüÊÖùÊÖìÊÖµÊÜôÊÜñÊÜáÊÜ¨ÊÜîÊÜöÊÜäÊÜëÊÜ´ÊÜÆÊáåÊáäÊáâÊá∑ÊáàÊáÉÊáÜÊÜ∫ÊáãÁΩπÊáçÊá¶Êá£Êá∂Êá∫Êá¥ÊáøÊáΩÊáºÊáæÊàÄÊààÊàâÊàçÊàåÊàîÊàõ"],["d9a1","ÊàûÊà°Êà™ÊàÆÊà∞Êà≤Êà≥ÊâÅÊâéÊâûÊâ£ÊâõÊâ†Êâ®ÊâºÊäÇÊäâÊâæÊäíÊäìÊäñÊãîÊäÉÊäîÊãóÊãëÊäªÊãèÊãøÊãÜÊìîÊãàÊãúÊãåÊãäÊãÇÊãáÊäõÊãâÊååÊãÆÊã±ÊåßÊåÇÊåàÊãØÊãµÊçêÊåæÊççÊêúÊçèÊéñÊééÊéÄÊé´Êç∂Êé£ÊéèÊéâÊéüÊéµÊç´Êç©ÊéæÊè©ÊèÄÊèÜÊè£ÊèâÊèíÊè∂ÊèÑÊêñÊê¥ÊêÜÊêìÊê¶Êê∂ÊîùÊêóÊê®ÊêèÊëßÊëØÊë∂ÊëéÊî™ÊíïÊíìÊí•Êí©ÊíàÊíº"],["daa1","ÊìöÊìíÊìÖÊìáÊíªÊìòÊìÇÊì±ÊìßËàâÊì†Êì°Êä¨Êì£ÊìØÊî¨Êì∂Êì¥Êì≤Êì∫ÊîÄÊìΩÊîòÊîúÊîÖÊî§Êî£Êî´Êî¥ÊîµÊî∑Êî∂Êî∏ÁïãÊïàÊïñÊïïÊïçÊïòÊïûÊïùÊï≤Êï∏ÊñÇÊñÉËÆäÊñõÊñüÊñ´Êñ∑ÊóÉÊóÜÊóÅÊóÑÊóåÊóíÊóõÊóôÊó†Êó°Êó±Êù≤ÊòäÊòÉÊóªÊù≥ÊòµÊò∂Êò¥ÊòúÊôèÊôÑÊôâÊôÅÊôûÊôùÊô§ÊôßÊô®ÊôüÊô¢Êô∞ÊöÉÊöàÊöéÊöâÊöÑÊöòÊöùÊõÅÊöπÊõâÊöæÊöº"],["dba1","ÊõÑÊö∏ÊõñÊõöÊõ†ÊòøÊõ¶Êõ©Êõ∞ÊõµÊõ∑ÊúèÊúñÊúûÊú¶ÊúßÈú∏ÊúÆÊúøÊú∂ÊùÅÊú∏Êú∑ÊùÜÊùûÊù†ÊùôÊù£Êù§ÊûâÊù∞Êû©ÊùºÊù™ÊûåÊûãÊû¶Êû°ÊûÖÊû∑ÊüØÊû¥Êü¨Êû≥Êü©Êû∏Êü§ÊüûÊüùÊü¢ÊüÆÊûπÊüéÊüÜÊüßÊ™úÊ†ûÊ°ÜÊ†©Ê°ÄÊ°çÊ†≤Ê°éÊ¢≥Ê†´Ê°ôÊ°£Ê°∑Ê°øÊ¢üÊ¢èÊ¢≠Ê¢îÊ¢ùÊ¢õÊ¢ÉÊ™ÆÊ¢πÊ°¥Ê¢µÊ¢†Ê¢∫Ê§èÊ¢çÊ°æÊ§ÅÊ£äÊ§àÊ£òÊ§¢Ê§¶Ê£°Ê§åÊ£ç"],["dca1","Ê£îÊ£ßÊ£ïÊ§∂Ê§íÊ§ÑÊ£óÊ££Ê§•Ê£πÊ£†Ê£ØÊ§®Ê§™Ê§öÊ§£Ê§°Ê£ÜÊ•πÊ•∑Ê•úÊ•∏Ê•´Ê•îÊ•æÊ•ÆÊ§πÊ•¥Ê§ΩÊ•ôÊ§∞Ê•°Ê•ûÊ•ùÊ¶ÅÊ•™Ê¶≤Ê¶ÆÊßêÊ¶øÊßÅÊßìÊ¶æÊßéÂØ®ÊßäÊßùÊ¶ªÊßÉÊ¶ßÊ®ÆÊ¶ëÊ¶†Ê¶úÊ¶ïÊ¶¥ÊßûÊß®Ê®ÇÊ®õÊßøÊ¨äÊßπÊß≤ÊßßÊ®ÖÊ¶±Ê®ûÊß≠Ê®îÊß´Ê®äÊ®íÊ´ÅÊ®£Ê®ìÊ©ÑÊ®åÊ©≤Ê®∂Ê©∏Ê©áÊ©¢Ê©ôÊ©¶Ê©àÊ®∏Ê®¢Ê™êÊ™çÊ™†Ê™ÑÊ™¢Ê™£"],["dda1","Ê™óËòóÊ™ªÊ´ÉÊ´ÇÊ™∏Ê™≥Ê™¨Ê´ûÊ´ëÊ´üÊ™™Ê´öÊ´™Ê´ªÊ¨ÖËòñÊ´∫Ê¨íÊ¨ñÈ¨±Ê¨üÊ¨∏Ê¨∑ÁõúÊ¨πÈ£ÆÊ≠áÊ≠ÉÊ≠âÊ≠êÊ≠ôÊ≠îÊ≠õÊ≠üÊ≠°Ê≠∏Ê≠πÊ≠øÊÆÄÊÆÑÊÆÉÊÆçÊÆòÊÆïÊÆûÊÆ§ÊÆ™ÊÆ´ÊÆØÊÆ≤ÊÆ±ÊÆ≥ÊÆ∑ÊÆºÊØÜÊØãÊØìÊØüÊØ¨ÊØ´ÊØ≥ÊØØÈ∫æÊ∞àÊ∞ìÊ∞îÊ∞õÊ∞§Ê∞£Ê±ûÊ±ïÊ±¢Ê±™Ê≤ÇÊ≤çÊ≤öÊ≤ÅÊ≤õÊ±æÊ±®Ê±≥Ê≤íÊ≤êÊ≥ÑÊ≥±Ê≥ìÊ≤ΩÊ≥óÊ≥ÖÊ≥ùÊ≤ÆÊ≤±Ê≤æ"],["dea1","Ê≤∫Ê≥õÊ≥ØÊ≥ôÊ≥™Ê¥üË°çÊ¥∂Ê¥´Ê¥ΩÊ¥∏Ê¥ôÊ¥µÊ¥≥Ê¥íÊ¥åÊµ£Ê∂ìÊµ§ÊµöÊµπÊµôÊ∂éÊ∂ïÊø§Ê∂ÖÊ∑πÊ∏ïÊ∏äÊ∂µÊ∑áÊ∑¶Ê∂∏Ê∑ÜÊ∑¨Ê∑ûÊ∑åÊ∑®Ê∑íÊ∑ÖÊ∑∫Ê∑ôÊ∑§Ê∑ïÊ∑™Ê∑ÆÊ∏≠ÊπÆÊ∏ÆÊ∏ôÊπ≤ÊπüÊ∏æÊ∏£Êπ´Ê∏´Êπ∂ÊπçÊ∏üÊπÉÊ∏∫ÊπéÊ∏§ÊªøÊ∏ùÊ∏∏Ê∫ÇÊ∫™Ê∫òÊªâÊ∫∑ÊªìÊ∫ΩÊ∫ØÊªÑÊ∫≤ÊªîÊªïÊ∫èÊ∫•ÊªÇÊ∫üÊΩÅÊºëÁÅåÊª¨Êª∏ÊªæÊºøÊª≤Êº±ÊªØÊº≤Êªå"],["dfa1","ÊºæÊºìÊª∑ÊæÜÊΩ∫ÊΩ∏ÊæÅÊæÄÊΩØÊΩõÊø≥ÊΩ≠ÊæÇÊΩºÊΩòÊæéÊæëÊøÇÊΩ¶Êæ≥Êæ£Êæ°Êæ§ÊæπÊøÜÊæ™ÊøüÊøïÊø¨ÊøîÊøòÊø±ÊøÆÊøõÁÄâÁÄãÊø∫ÁÄëÁÄÅÁÄèÊøæÁÄõÁÄöÊΩ¥ÁÄùÁÄòÁÄüÁÄ∞ÁÄæÁÄ≤ÁÅëÁÅ£ÁÇôÁÇíÁÇØÁÉ±ÁÇ¨ÁÇ∏ÁÇ≥ÁÇÆÁÉüÁÉãÁÉùÁÉôÁÑâÁÉΩÁÑúÁÑôÁÖ•ÁÖïÁÜàÁÖ¶ÁÖ¢ÁÖåÁÖñÁÖ¨ÁÜèÁáªÁÜÑÁÜïÁÜ®ÁÜ¨ÁáóÁÜπÁÜæÁáíÁáâÁáîÁáéÁá†Áá¨ÁáßÁáµÁáº"],["e0a1","ÁáπÁáøÁàçÁàêÁàõÁà®Áà≠Áà¨Áà∞Áà≤ÁàªÁàºÁàøÁâÄÁâÜÁâãÁâòÁâ¥ÁâæÁäÇÁäÅÁäáÁäíÁäñÁä¢ÁäßÁäπÁä≤ÁãÉÁãÜÁãÑÁãéÁãíÁã¢Áã†Áã°ÁãπÁã∑ÂÄèÁåóÁåäÁåúÁåñÁåùÁå¥ÁåØÁå©Áå•ÁåæÁçéÁçèÈªòÁçóÁç™Áç®Áç∞Áç∏ÁçµÁçªÁç∫ÁèàÁé≥ÁèéÁéªÁèÄÁè•ÁèÆÁèûÁí¢ÁêÖÁëØÁê•Áè∏Áê≤Áê∫ÁëïÁêøÁëüÁëôÁëÅÁëúÁë©Áë∞Áë£Áë™Áë∂ÁëæÁíãÁíûÁíßÁìäÁìèÁìîÁè±"],["e1a1","Áì†Áì£ÁìßÁì©ÁìÆÁì≤Áì∞Áì±Áì∏Áì∑ÁîÑÁîÉÁîÖÁîåÁîéÁîçÁîïÁîìÁîûÁî¶Áî¨ÁîºÁïÑÁïçÁïäÁïâÁïõÁïÜÁïöÁï©Áï§ÁïßÁï´Áï≠Áï∏Áï∂ÁñÜÁñáÁï¥ÁñäÁñâÁñÇÁñîÁñöÁñùÁñ•Áñ£ÁóÇÁñ≥ÁóÉÁñµÁñΩÁñ∏ÁñºÁñ±ÁóçÁóäÁóíÁóôÁó£ÁóûÁóæÁóøÁóºÁòÅÁó∞Áó∫Áó≤Áó≥ÁòãÁòçÁòâÁòüÁòßÁò†Áò°Áò¢Áò§Áò¥Áò∞ÁòªÁôáÁôàÁôÜÁôúÁôòÁô°Áô¢Áô®Áô©Áô™ÁôßÁô¨Áô∞"],["e2a1","Áô≤Áô∂Áô∏ÁôºÁöÄÁöÉÁöàÁöãÁöéÁöñÁöìÁöôÁööÁö∞Áö¥Áö∏ÁöπÁö∫ÁõÇÁõçÁõñÁõíÁõûÁõ°Áõ•ÁõßÁõ™ËòØÁõªÁúàÁúáÁúÑÁú©Áú§ÁúûÁú•Áú¶ÁúõÁú∑Áú∏ÁùáÁùöÁù®Áù´ÁùõÁù•ÁùøÁùæÁùπÁûéÁûãÁûëÁû†ÁûûÁû∞Áû∂ÁûπÁûøÁûºÁûΩÁûªÁüáÁüçÁüóÁüöÁüúÁü£ÁüÆÁüºÁ†åÁ†íÁ§¶Á††Á§™Á°ÖÁ¢éÁ°¥Á¢ÜÁ°ºÁ¢öÁ¢åÁ¢£Á¢µÁ¢™Á¢ØÁ£ëÁ£ÜÁ£ãÁ£îÁ¢æÁ¢ºÁ£ÖÁ£äÁ£¨"],["e3a1","Á£ßÁ£öÁ£ΩÁ£¥Á§áÁ§íÁ§ëÁ§ôÁ§¨Á§´Á•ÄÁ•†Á•óÁ•üÁ•öÁ•ïÁ•ìÁ•∫Á•øÁ¶äÁ¶ùÁ¶ßÈΩãÁ¶™Á¶ÆÁ¶≥Á¶πÁ¶∫ÁßâÁßïÁßßÁß¨Áß°Áß£Á®àÁ®çÁ®òÁ®ôÁ®†Á®üÁ¶ÄÁ®±Á®ªÁ®æÁ®∑Á©ÉÁ©óÁ©âÁ©°Á©¢Á©©ÈæùÁ©∞Á©πÁ©ΩÁ™àÁ™óÁ™ïÁ™òÁ™ñÁ™©Á´àÁ™∞Á™∂Á´ÖÁ´ÑÁ™øÈÇÉÁ´áÁ´äÁ´çÁ´èÁ´ïÁ´ìÁ´ôÁ´öÁ´ùÁ´°Á´¢Á´¶Á´≠Á´∞Á¨ÇÁ¨èÁ¨äÁ¨ÜÁ¨≥Á¨òÁ¨ôÁ¨ûÁ¨µÁ¨®Á¨∂Á≠ê"],["e4a1","Á≠∫Á¨ÑÁ≠çÁ¨ãÁ≠åÁ≠ÖÁ≠µÁ≠•Á≠¥Á≠ßÁ≠∞Á≠±Á≠¨Á≠ÆÁÆùÁÆòÁÆüÁÆçÁÆúÁÆöÁÆãÁÆíÁÆèÁ≠ùÁÆôÁØãÁØÅÁØåÁØèÁÆ¥ÁØÜÁØùÁØ©Á∞ëÁ∞îÁØ¶ÁØ•Á±†Á∞ÄÁ∞áÁ∞ìÁØ≥ÁØ∑Á∞óÁ∞çÁØ∂Á∞£Á∞ßÁ∞™Á∞üÁ∞∑Á∞´Á∞ΩÁ±åÁ±ÉÁ±îÁ±èÁ±ÄÁ±êÁ±òÁ±üÁ±§Á±ñÁ±•Á±¨Á±µÁ≤ÉÁ≤êÁ≤§Á≤≠Á≤¢Á≤´Á≤°Á≤®Á≤≥Á≤≤Á≤±Á≤ÆÁ≤πÁ≤ΩÁ≥ÄÁ≥ÖÁ≥ÇÁ≥òÁ≥íÁ≥úÁ≥¢È¨ªÁ≥ØÁ≥≤Á≥¥Á≥∂Á≥∫Á¥Ü"],["e5a1","Á¥ÇÁ¥úÁ¥ïÁ¥äÁµÖÁµãÁ¥ÆÁ¥≤Á¥øÁ¥µÁµÜÁµ≥ÁµñÁµéÁµ≤Áµ®ÁµÆÁµèÁµ£Á∂ìÁ∂âÁµõÁ∂èÁµΩÁ∂õÁ∂∫Á∂ÆÁ∂£Á∂µÁ∑áÁ∂ΩÁ∂´Á∏ΩÁ∂¢Á∂ØÁ∑úÁ∂∏Á∂üÁ∂∞Á∑òÁ∑ùÁ∑§Á∑ûÁ∑ªÁ∑≤Á∑°Á∏ÖÁ∏äÁ∏£Á∏°Á∏íÁ∏±Á∏üÁ∏âÁ∏ãÁ∏¢ÁπÜÁπ¶Á∏ªÁ∏µÁ∏πÁπÉÁ∏∑Á∏≤Á∏∫ÁπßÁπùÁπñÁπûÁπôÁπöÁππÁπ™Áπ©ÁπºÁπªÁ∫ÉÁ∑ïÁπΩËæÆÁπøÁ∫àÁ∫âÁ∫åÁ∫íÁ∫êÁ∫ìÁ∫îÁ∫ñÁ∫éÁ∫õÁ∫úÁº∏Áº∫"],["e6a1","ÁΩÖÁΩåÁΩçÁΩéÁΩêÁΩëÁΩïÁΩîÁΩòÁΩüÁΩ†ÁΩ®ÁΩ©ÁΩßÁΩ∏ÁæÇÁæÜÁæÉÁæàÁæáÁæåÁæîÁæûÁæùÁæöÁæ£ÁæØÁæ≤ÁæπÁæÆÁæ∂Áæ∏Ë≠±ÁøÖÁøÜÁøäÁøïÁøîÁø°Áø¶Áø©Áø≥ÁøπÈ£úËÄÜËÄÑËÄãËÄíËÄòËÄôËÄúËÄ°ËÄ®ËÄøËÄªËÅäËÅÜËÅíËÅòËÅöËÅüËÅ¢ËÅ®ËÅ≥ËÅ≤ËÅ∞ËÅ∂ËÅπËÅΩËÅøËÇÑËÇÜËÇÖËÇõËÇìËÇöËÇ≠ÂÜêËÇ¨ËÉõËÉ•ËÉôËÉùËÉÑËÉöËÉñËÑâËÉØËÉ±ËÑõËÑ©ËÑ£ËÑØËÖã"],["e7a1","ÈöãËÖÜËÑæËÖìËÖëËÉºËÖ±ËÖÆËÖ•ËÖ¶ËÖ¥ËÜÉËÜàËÜäËÜÄËÜÇËÜ†ËÜïËÜ§ËÜ£ËÖüËÜìËÜ©ËÜ∞ËÜµËÜæËÜ∏ËÜΩËáÄËáÇËÜ∫ËáâËáçËáëËáôËáòËáàËáöËáüËá†ËáßËá∫ËáªËáæËàÅËàÇËàÖËàáËàäËàçËàêËàñËà©Ëà´Ëà∏Ëà≥ËâÄËâôËâòËâùËâöËâüËâ§Ëâ¢Ëâ®Ëâ™Ëâ´ËàÆËâ±Ëâ∑Ëâ∏ËâæËäçËäíËä´ËäüËäªËä¨Ëã°Ëã£ËãüËãíËã¥Ëã≥Ëã∫ËéìËåÉËãªËãπËãûËåÜËãúËåâËãô"],["e8a1","ËåµËå¥ËåñËå≤Ëå±ËçÄËåπËçêËçÖËåØËå´ËåóËåòËéÖËéöËé™ËéüËé¢ËéñËå£ËééËéáËéäËçºËéµËç≥ËçµËé†ËéâËé®Ëè¥ËêìËè´ËèéËèΩËêÉËèòËêãËèÅËè∑ËêáËè†Ëè≤ËêçËê¢Ëê†ËéΩËê∏ËîÜËèªËë≠Ëê™ËêºËïöËíÑËë∑Ëë´Ëí≠ËëÆËíÇËë©ËëÜËê¨ËëØËëπËêµËìäËë¢ËíπËíøËíüËìôËìçËíªËìöËìêËìÅËìÜËìñËí°Ëî°ËìøËì¥ËîóËîòËî¨ËîüËîïËîîËìºËïÄËï£ËïòËïà"],["e9a1","ËïÅËòÇËïãËïïËñÄËñ§ËñàËñëËñäËñ®Ëï≠ËñîËñõËó™ËñáËñúËï∑ËïæËñêËóâËñ∫ËóèËñπËóêËóïËóùËó•ËóúËóπËòäËòìËòãËóæËó∫ËòÜËò¢ËòöËò∞ËòøËôç‰πïËôîËôüËôßËô±ËöìËö£Ëö©Ëö™ËöãËöåËö∂ËöØËõÑËõÜËö∞ËõâË†£Ëö´ËõîËõûËõ©Ëõ¨ËõüËõõËõØËúíËúÜËúàËúÄËúÉËõªËúëËúâËúçËõπËúäËú¥ËúøËú∑ËúªËú•Ëú©ËúöËù†ËùüËù∏ËùåËùéËù¥ËùóËù®ËùÆËùô"],["eaa1","ËùìËù£Ëù™Ë†ÖËû¢ËûüËûÇËûØËüãËûΩËüÄËüêÈõñËû´ËüÑËû≥ËüáËüÜËûªËüØËü≤Ëü†Ë†èË†çËüæËü∂Ëü∑Ë†éËüíË†ëË†ñË†ïË†¢Ë†°Ë†±Ë†∂Ë†πË†ßË†ªË°ÑË°ÇË°íË°ôË°ûË°¢Ë°´Ë¢ÅË°æË¢ûË°µË°ΩË¢µË°≤Ë¢ÇË¢óË¢íË¢ÆË¢ôË¢¢Ë¢çË¢§Ë¢∞Ë¢øË¢±Ë£ÉË£ÑË£îË£òË£ôË£ùË£πË§ÇË£ºË£¥Ë£®Ë£≤Ë§ÑË§åË§äË§ìË•ÉË§ûË§•Ë§™Ë§´Ë•ÅË•ÑË§ªË§∂Ë§∏Ë•åË§ùË•†Ë•û"],["eba1","Ë•¶Ë•§Ë•≠Ë•™Ë•ØË•¥Ë•∑Ë•æË¶ÉË¶àË¶äË¶ìË¶òË¶°Ë¶©Ë¶¶Ë¶¨Ë¶ØË¶≤Ë¶∫Ë¶ΩË¶øËßÄËßöËßúËßùËßßËß¥Ëß∏Ë®ÉË®ñË®êË®åË®õË®ùË®•Ë®∂Ë©ÅË©õË©íË©ÜË©àË©ºË©≠Ë©¨Ë©¢Ë™ÖË™ÇË™ÑË™®Ë™°Ë™ëË™•Ë™¶Ë™öË™£Ë´ÑË´çË´ÇË´öË´´Ë´≥Ë´ßË´§Ë´±Ë¨îË´†Ë´¢Ë´∑Ë´ûË´õË¨åË¨áË¨öË´°Ë¨ñË¨êË¨óË¨†Ë¨≥Èû´Ë¨¶Ë¨´Ë¨æË¨®Ë≠ÅË≠åË≠èË≠éË≠âË≠ñË≠õË≠öË≠´"],["eca1","Ë≠üË≠¨Ë≠ØË≠¥Ë≠ΩËÆÄËÆåËÆéËÆíËÆìËÆñËÆôËÆöË∞∫Ë±ÅË∞øË±àË±åË±éË±êË±ïË±¢Ë±¨Ë±∏Ë±∫Ë≤ÇË≤âË≤ÖË≤äË≤çË≤éË≤îË±ºË≤òÊàùË≤≠Ë≤™Ë≤ΩË≤≤Ë≤≥Ë≤ÆË≤∂Ë≥àË≥ÅË≥§Ë≥£Ë≥öË≥ΩË≥∫Ë≥ªË¥ÑË¥ÖË¥äË¥áË¥èË¥çË¥êÈΩéË¥ìË≥çË¥îË¥ñËµßËµ≠Ëµ±Ëµ≥Ë∂ÅË∂ôË∑ÇË∂æË∂∫Ë∑èË∑öË∑ñË∑åË∑õË∑ãË∑™Ë∑´Ë∑üË∑£Ë∑ºË∏àË∏âË∑øË∏ùË∏ûË∏êË∏üËπÇË∏µË∏∞Ë∏¥Ëπä"],["eda1","ËπáËπâËπåËπêËπàËπôËπ§Ëπ†Ë∏™Ëπ£ËπïËπ∂Ëπ≤ËπºË∫ÅË∫áË∫ÖË∫ÑË∫ãË∫äË∫ìË∫ëË∫îË∫ôË∫™Ë∫°Ë∫¨Ë∫∞ËªÜË∫±Ë∫æËªÖËªàËªãËªõËª£ËªºËªªËª´ËªæËºäËºÖËºïËºíËºôËºìËºúËºüËºõËºåËº¶Ëº≥ËºªËºπËΩÖËΩÇËºæËΩåËΩâËΩÜËΩéËΩóËΩúËΩ¢ËΩ£ËΩ§ËæúËæüËæ£Ëæ≠ËæØËæ∑ËøöËø•Ëø¢Ëø™ËøØÈÇáËø¥ÈÄÖËøπËø∫ÈÄëÈÄïÈÄ°ÈÄçÈÄûÈÄñÈÄãÈÄßÈÄ∂ÈÄµÈÄπËø∏"],["eea1","ÈÅèÈÅêÈÅëÈÅíÈÄéÈÅâÈÄæÈÅñÈÅòÈÅûÈÅ®ÈÅØÈÅ∂Èö®ÈÅ≤ÈÇÇÈÅΩÈÇÅÈÇÄÈÇäÈÇâÈÇèÈÇ®ÈÇØÈÇ±ÈÇµÈÉ¢ÈÉ§ÊâàÈÉõÈÑÇÈÑíÈÑôÈÑ≤ÈÑ∞ÈÖäÈÖñÈÖòÈÖ£ÈÖ•ÈÖ©ÈÖ≥ÈÖ≤ÈÜãÈÜâÈÜÇÈÜ¢ÈÜ´ÈÜØÈÜ™ÈÜµÈÜ¥ÈÜ∫ÈáÄÈáÅÈáâÈáãÈáêÈáñÈáüÈá°ÈáõÈáºÈáµÈá∂ÈàûÈáøÈàîÈà¨ÈàïÈàëÈâûÈâóÈâÖÈââÈâ§ÈâàÈäïÈàøÈâãÈâêÈäúÈäñÈäìÈäõÈâöÈãèÈäπÈä∑Èã©ÈåèÈã∫ÈçÑÈåÆ"],["efa1","ÈåôÈå¢ÈåöÈå£Èå∫ÈåµÈåªÈçúÈç†ÈçºÈçÆÈçñÈé∞Èé¨Èé≠ÈéîÈéπÈèñÈèóÈè®Èè•ÈèòÈèÉÈèùÈèêÈèàÈè§ÈêöÈêîÈêìÈêÉÈêáÈêêÈê∂Èê´ÈêµÈê°Èê∫ÈëÅÈëíÈëÑÈëõÈë†Èë¢ÈëûÈë™Èà©Èë∞ÈëµÈë∑ÈëΩÈëöÈëºÈëæÈíÅÈëøÈñÇÈñáÈñäÈñîÈññÈñòÈñôÈñ†Èñ®ÈñßÈñ≠ÈñºÈñªÈñπÈñæÈóäÊø∂ÈóÉÈóçÈóåÈóïÈóîÈóñÈóúÈó°Èó•Èó¢Èò°Èò®ÈòÆÈòØÈôÇÈôåÈôèÈôãÈô∑ÈôúÈôû"],["f0a1","ÈôùÈôüÈô¶Èô≤Èô¨ÈöçÈöòÈöïÈöóÈö™ÈößÈö±Èö≤Èö∞Èö¥Èö∂Èö∏ÈöπÈõéÈõãÈõâÈõçË•çÈõúÈúçÈõïÈõπÈúÑÈúÜÈúàÈúìÈúéÈúëÈúèÈúñÈúôÈú§Èú™Èú∞ÈúπÈúΩÈúæÈùÑÈùÜÈùàÈùÇÈùâÈùúÈù†Èù§Èù¶Èù®ÂãíÈù´Èù±ÈùπÈûÖÈùºÈûÅÈù∫ÈûÜÈûãÈûèÈûêÈûúÈû®Èû¶Èû£Èû≥Èû¥ÈüÉÈüÜÈüàÈüãÈüúÈü≠ÈΩèÈü≤Á´üÈü∂ÈüµÈ†èÈ†åÈ†∏È†§È†°È†∑È†ΩÈ°ÜÈ°èÈ°ãÈ°´È°ØÈ°∞"],["f1a1","È°±È°¥È°≥È¢™È¢ØÈ¢±È¢∂È£ÑÈ£ÉÈ£ÜÈ£©È£´È§ÉÈ§âÈ§íÈ§îÈ§òÈ§°È§ùÈ§ûÈ§§È§†È§¨È§ÆÈ§ΩÈ§æÈ•ÇÈ•âÈ•ÖÈ•êÈ•ãÈ•ëÈ•íÈ•åÈ•ïÈ¶óÈ¶òÈ¶•È¶≠È¶ÆÈ¶ºÈßüÈßõÈßùÈßòÈßëÈß≠ÈßÆÈß±Èß≤ÈßªÈß∏È®ÅÈ®èÈ®ÖÈß¢È®ôÈ®´È®∑È©ÖÈ©ÇÈ©ÄÈ©ÉÈ®æÈ©ïÈ©çÈ©õÈ©óÈ©üÈ©¢È©•È©§È©©È©´È©™È™≠È™∞È™ºÈ´ÄÈ´èÈ´ëÈ´ìÈ´îÈ´ûÈ´üÈ´¢È´£È´¶È´ØÈ´´È´ÆÈ´¥È´±È´∑"],["f2a1","È´ªÈ¨ÜÈ¨òÈ¨öÈ¨üÈ¨¢È¨£È¨•È¨ßÈ¨®È¨©È¨™È¨ÆÈ¨ØÈ¨≤È≠ÑÈ≠ÉÈ≠èÈ≠çÈ≠éÈ≠ëÈ≠òÈ≠¥ÈÆìÈÆÉÈÆëÈÆñÈÆóÈÆüÈÆ†ÈÆ®ÈÆ¥ÈØÄÈØäÈÆπÈØÜÈØèÈØëÈØíÈØ£ÈØ¢ÈØ§ÈØîÈØ°È∞∫ÈØ≤ÈØ±ÈØ∞È∞ïÈ∞îÈ∞âÈ∞ìÈ∞åÈ∞ÜÈ∞àÈ∞íÈ∞äÈ∞ÑÈ∞ÆÈ∞õÈ∞•È∞§È∞°È∞∞È±áÈ∞≤È±ÜÈ∞æÈ±öÈ±†È±ßÈ±∂È±∏È≥ßÈ≥¨È≥∞È¥âÈ¥àÈ≥´È¥ÉÈ¥ÜÈ¥™È¥¶È∂ØÈ¥£È¥üÈµÑÈ¥ïÈ¥íÈµÅÈ¥øÈ¥æÈµÜÈµà"],["f3a1","ÈµùÈµûÈµ§ÈµëÈµêÈµôÈµ≤È∂âÈ∂áÈ∂´ÈµØÈµ∫È∂öÈ∂§È∂©È∂≤È∑ÑÈ∑ÅÈ∂ªÈ∂∏È∂∫È∑ÜÈ∑èÈ∑ÇÈ∑ôÈ∑ìÈ∑∏È∑¶È∑≠È∑ØÈ∑ΩÈ∏öÈ∏õÈ∏ûÈπµÈππÈπΩÈ∫ÅÈ∫àÈ∫ãÈ∫åÈ∫íÈ∫ïÈ∫ëÈ∫ùÈ∫•È∫©È∫∏È∫™È∫≠Èù°ÈªåÈªéÈªèÈªêÈªîÈªúÈªûÈªùÈª†Èª•Èª®ÈªØÈª¥Èª∂Èª∑ÈªπÈªªÈªºÈªΩÈºáÈºàÁö∑ÈºïÈº°Èº¨ÈºæÈΩäÈΩíÈΩîÈΩ£ÈΩüÈΩ†ÈΩ°ÈΩ¶ÈΩßÈΩ¨ÈΩ™ÈΩ∑ÈΩ≤ÈΩ∂ÈæïÈæúÈæ†"],["f4a1","Â†ØÊßáÈÅôÁë§ÂáúÁÜô"],["f9a1","Á∫äË§úÈçàÈäàËìú‰øâÁÇªÊò±Ê£àÈãπÊõªÂΩÖ‰∏®‰ª°‰ªº‰ºÄ‰ºÉ‰ºπ‰Ωñ‰æí‰æä‰æö‰æî‰øçÂÅÄÂÄ¢‰øøÂÄûÂÅÜÂÅ∞ÂÅÇÂÇîÂÉ¥ÂÉòÂÖäÂÖ§ÂÜùÂÜæÂá¨ÂàïÂäúÂä¶ÂãÄÂãõÂåÄÂåáÂå§Âç≤ÂéìÂé≤ÂèùÔ®éÂíúÂíäÂí©ÂìøÂñÜÂùôÂù•Âû¨ÂüàÂüáÔ®èÔ®êÂ¢ûÂ¢≤Â§ãÂ•ìÂ•õÂ•ùÂ•£Â¶§Â¶∫Â≠ñÂØÄÁîØÂØòÂØ¨Â∞ûÂ≤¶Â≤∫Â≥µÂ¥ßÂµìÔ®ëÂµÇÂµ≠Â∂∏Â∂πÂ∑êÂº°Âº¥ÂΩßÂæ∑"],["faa1","ÂøûÊÅùÊÇÖÊÇäÊÉûÊÉïÊÑ†ÊÉ≤ÊÑëÊÑ∑ÊÑ∞ÊÜòÊàìÊä¶ÊèµÊë†ÊíùÊìéÊïéÊòÄÊòïÊòªÊòâÊòÆÊòûÊò§Êô•ÊôóÊôôÔ®íÊô≥ÊöôÊö†Êö≤ÊöøÊõ∫ÊúéÔ§©Êù¶ÊûªÊ°íÊüÄÊ†ÅÊ°ÑÊ£èÔ®ìÊ•®Ô®îÊ¶òÊß¢Ê®∞Ê©´Ê©ÜÊ©≥Ê©æÊ´¢Ê´§ÊØñÊ∞øÊ±úÊ≤ÜÊ±ØÊ≥öÊ¥ÑÊ∂áÊµØÊ∂ñÊ∂¨Ê∑èÊ∑∏Ê∑≤Ê∑ºÊ∏πÊπúÊ∏ßÊ∏ºÊ∫øÊæàÊæµÊøµÁÄÖÁÄáÁÄ®ÁÇÖÁÇ´ÁÑèÁÑÑÁÖúÁÖÜÁÖáÔ®ïÁáÅÁáæÁä±"],["fba1","ÁäæÁå§Ô®ñÁç∑ÁéΩÁèâÁèñÁè£ÁèíÁêáÁèµÁê¶Áê™Áê©ÁêÆÁë¢ÁíâÁíüÁîÅÁïØÁöÇÁöúÁöûÁöõÁö¶Ô®óÁùÜÂäØÁ†°Á°éÁ°§Á°∫Á§∞Ô®òÔ®ôÔ®öÁ¶îÔ®õÁ¶õÁ´ëÁ´ßÔ®úÁ´´ÁÆûÔ®ùÁµàÁµúÁ∂∑Á∂†Á∑ñÁπíÁΩáÁæ°Ô®ûËåÅËç¢ËçøËèáËè∂ËëàËí¥ËïìËïôËï´Ô®üËñ∞Ô®†Ô®°Ë†áË£µË®íË®∑Ë©πË™ßË™æË´üÔ®¢Ë´∂Ë≠ìË≠øË≥∞Ë≥¥Ë¥íËµ∂Ô®£ËªèÔ®§Ô®•ÈÅßÈÉûÔ®¶ÈÑïÈÑßÈáö"],["fca1","ÈáóÈáûÈá≠ÈáÆÈá§Èá•ÈàÜÈàêÈàäÈà∫ÈâÄÈàºÈâéÈâôÈâëÈàπÈâßÈäßÈâ∑Èâ∏ÈãßÈãóÈãôÈãêÔ®ßÈãïÈã†ÈãìÈå•Èå°ÈãªÔ®®ÈåûÈãøÈåùÈåÇÈç∞ÈçóÈé§ÈèÜÈèûÈè∏Èê±ÈëÖÈëàÈñíÔßúÔ®©ÈöùÈöØÈú≥ÈúªÈùÉÈùçÈùèÈùëÈùïÈ°óÈ°•Ô®™Ô®´È§ßÔ®¨È¶ûÈ©éÈ´ôÈ´úÈ≠µÈ≠≤ÈÆèÈÆ±ÈÆªÈ∞ÄÈµ∞Èµ´Ô®≠È∏ôÈªë"],["fcf1","‚Ö∞",9,"Ôø¢Ôø§ÔºáÔºÇ"],["8fa2af","ÀòÀá¬∏ÀôÀù¬ØÀõÀöÔΩûŒÑŒÖ"],["8fa2c2","¬°¬¶¬ø"],["8fa2eb","¬∫¬™¬©¬Æ‚Ñ¢¬§‚Ññ"],["8fa6e1","ŒÜŒàŒâŒäŒ™"],["8fa6e7","Œå"],["8fa6e9","ŒéŒ´"],["8fa6ec","Œè"],["8fa6f1","Œ¨Œ≠ŒÆŒØœäŒêœåœÇœçœãŒ∞œé"],["8fa7c2","–Ç",10,"–é–è"],["8fa7f2","—í",10,"—û—ü"],["8fa9a1","√Üƒê"],["8fa9a4","ƒ¶"],["8fa9a6","ƒ≤"],["8fa9a8","≈Åƒø"],["8fa9ab","≈ä√ò≈í"],["8fa9af","≈¶√û"],["8fa9c1","√¶ƒë√∞ƒßƒ±ƒ≥ƒ∏≈Ç≈Ä≈â≈ã√∏≈ì√ü≈ß√æ"],["8faaa1","√Å√Ä√Ñ√ÇƒÇ«çƒÄƒÑ√Ö√ÉƒÜƒàƒå√áƒäƒé√â√à√ã√äƒöƒñƒíƒò"],["8faaba","ƒúƒûƒ¢ƒ†ƒ§√ç√å√è√é«èƒ∞ƒ™ƒÆƒ®ƒ¥ƒ∂ƒπƒΩƒª≈É≈á≈Ö√ë√ì√í√ñ√î«ë≈ê≈å√ï≈î≈ò≈ñ≈ö≈ú≈†≈û≈§≈¢√ö√ô√ú√õ≈¨«ì≈∞≈™≈≤≈Æ≈®«ó«õ«ô«ï≈¥√ù≈∏≈∂≈π≈Ω≈ª"],["8faba1","√°√†√§√¢ƒÉ«éƒÅƒÖ√•√£ƒáƒâƒç√ßƒãƒè√©√®√´√™ƒõƒóƒìƒô«µƒùƒü"],["8fabbd","ƒ°ƒ•√≠√¨√Ø√Æ«ê"],["8fabc5","ƒ´ƒØƒ©ƒµƒ∑ƒ∫ƒæƒº≈Ñ≈à≈Ü√±√≥√≤√∂√¥«í≈ë≈ç√µ≈ï≈ô≈ó≈õ≈ù≈°≈ü≈•≈£√∫√π√º√ª≈≠«î≈±≈´≈≥≈Ø≈©«ò«ú«ö«ñ≈µ√Ω√ø≈∑≈∫≈æ≈º"],["8fb0a1","‰∏Ç‰∏Ñ‰∏Ö‰∏å‰∏í‰∏ü‰∏£‰∏§‰∏®‰∏´‰∏Æ‰∏Ø‰∏∞‰∏µ‰πÄ‰πÅ‰πÑ‰πá‰πë‰πö‰πú‰π£‰π®‰π©‰π¥‰πµ‰ππ‰πø‰∫ç‰∫ñ‰∫ó‰∫ù‰∫Ø‰∫π‰ªÉ‰ªê‰ªö‰ªõ‰ª†‰ª°‰ª¢‰ª®‰ªØ‰ª±‰ª≥‰ªµ‰ªΩ‰ªæ‰ªø‰ºÄ‰ºÇ‰ºÉ‰ºà‰ºã‰ºå‰ºí‰ºï‰ºñ‰ºó‰ºô‰ºÆ‰º±‰Ω†‰º≥‰ºµ‰º∑‰ºπ‰ºª‰ºæ‰ΩÄ‰ΩÇ‰Ωà‰Ωâ‰Ωã‰Ωå‰Ωí‰Ωî‰Ωñ‰Ωò‰Ωü‰Ω£‰Ω™‰Ω¨‰ΩÆ‰Ω±‰Ω∑‰Ω∏‰Ωπ‰Ω∫‰ΩΩ‰Ωæ‰æÅ‰æÇ‰æÑ"],["8fb1a1","‰æÖ‰æâ‰æä‰æå‰æé‰æê‰æí‰æì‰æî‰æó‰æô‰æö‰æû‰æü‰æ≤‰æ∑‰æπ‰æª‰æº‰æΩ‰ææ‰øÄ‰øÅ‰øÖ‰øÜ‰øà‰øâ‰øã‰øå‰øç‰øè‰øí‰øú‰ø†‰ø¢‰ø∞‰ø≤‰øº‰øΩ‰øøÂÄÄÂÄÅÂÄÑÂÄáÂÄäÂÄåÂÄéÂÄêÂÄìÂÄóÂÄòÂÄõÂÄúÂÄùÂÄûÂÄ¢ÂÄßÂÄÆÂÄ∞ÂÄ≤ÂÄ≥ÂÄµÂÅÄÂÅÅÂÅÇÂÅÖÂÅÜÂÅäÂÅåÂÅéÂÅëÂÅíÂÅìÂÅóÂÅôÂÅüÂÅ†ÂÅ¢ÂÅ£ÂÅ¶ÂÅßÂÅ™ÂÅ≠ÂÅ∞ÂÅ±ÂÄªÂÇÅÂÇÉÂÇÑÂÇÜÂÇäÂÇéÂÇèÂÇê"],["8fb2a1","ÂÇíÂÇìÂÇîÂÇñÂÇõÂÇúÂÇû",4,"ÂÇ™ÂÇØÂÇ∞ÂÇπÂÇ∫ÂÇΩÂÉÄÂÉÉÂÉÑÂÉáÂÉåÂÉéÂÉêÂÉìÂÉîÂÉòÂÉúÂÉùÂÉüÂÉ¢ÂÉ§ÂÉ¶ÂÉ®ÂÉ©ÂÉØÂÉ±ÂÉ∂ÂÉ∫ÂÉæÂÑÉÂÑÜÂÑáÂÑàÂÑãÂÑåÂÑçÂÑéÂÉ≤ÂÑêÂÑóÂÑôÂÑõÂÑúÂÑùÂÑûÂÑ£ÂÑßÂÑ®ÂÑ¨ÂÑ≠ÂÑØÂÑ±ÂÑ≥ÂÑ¥ÂÑµÂÑ∏ÂÑπÂÖÇÂÖäÂÖèÂÖìÂÖïÂÖóÂÖòÂÖüÂÖ§ÂÖ¶ÂÖæÂÜÉÂÜÑÂÜãÂÜéÂÜòÂÜùÂÜ°ÂÜ£ÂÜ≠ÂÜ∏ÂÜ∫ÂÜºÂÜæÂÜøÂáÇ"],["8fb3a1","ÂáàÂáèÂáëÂáíÂáìÂáïÂáòÂáûÂá¢Âá•ÂáÆÂá≤Âá≥Âá¥Âá∑ÂàÅÂàÇÂàÖÂàíÂàìÂàïÂàñÂàòÂà¢Âà®Âà±Âà≤ÂàµÂàºÂâÖÂââÂâïÂâóÂâòÂâöÂâúÂâüÂâ†Ââ°Ââ¶ÂâÆÂâ∑Ââ∏ÂâπÂäÄÂäÇÂäÖÂääÂäåÂäìÂäïÂäñÂäóÂäòÂäöÂäúÂä§Âä•Âä¶ÂäßÂäØÂä∞Âä∂Âä∑Âä∏Âä∫ÂäªÂäΩÂãÄÂãÑÂãÜÂãàÂãåÂãèÂãëÂãîÂãñÂãõÂãúÂã°Âã•Âã®Âã©Âã™Âã¨Âã∞Âã±Âã¥Âã∂Âã∑ÂåÄÂåÉÂåäÂåã"],["8fb4a1","ÂååÂåëÂåìÂåòÂåõÂåúÂåûÂåüÂå•ÂåßÂå®Âå©Âå´Âå¨Âå≠Âå∞Âå≤ÂåµÂåºÂåΩÂåæÂçÇÂçåÂçãÂçôÂçõÂç°Âç£Âç•Âç¨Âç≠Âç≤ÂçπÂçæÂéÉÂéáÂéàÂééÂéìÂéîÂéôÂéùÂé°Âé§Âé™Âé´ÂéØÂé≤Âé¥ÂéµÂé∑Âé∏Âé∫ÂéΩÂèÄÂèÖÂèèÂèíÂèìÂèïÂèöÂèùÂèûÂè†Âè¶ÂèßÂèµÂêÇÂêìÂêöÂê°ÂêßÂê®Âê™ÂêØÂê±Âê¥ÂêµÂëÉÂëÑÂëáÂëçÂëèÂëûÂë¢Âë§Âë¶ÂëßÂë©Âë´Âë≠ÂëÆÂë¥Âëø"],["8fb5a1","ÂíÅÂíÉÂíÖÂíàÂíâÂíçÂíëÂíïÂíñÂíúÂíüÂí°Âí¶ÂíßÂí©Âí™Âí≠ÂíÆÂí±Âí∑ÂíπÂí∫ÂíªÂíøÂìÜÂìäÂìçÂìéÂì†Âì™Âì¨ÂìØÂì∂ÂìºÂìæÂìøÂîÄÂîÅÂîÖÂîàÂîâÂîåÂîçÂîéÂîïÂî™Âî´Âî≤ÂîµÂî∂ÂîªÂîºÂîΩÂïÅÂïáÂïâÂïäÂïçÂïêÂïëÂïòÂïöÂïõÂïûÂï†Âï°Âï§Âï¶ÂïøÂñÅÂñÇÂñÜÂñàÂñéÂñèÂñëÂñíÂñìÂñîÂñóÂñ£Âñ§Âñ≠Âñ≤ÂñøÂóÅÂóÉÂóÜÂóâÂóãÂóåÂóéÂóëÂóí"],["8fb6a1","ÂóìÂóóÂóòÂóõÂóûÂó¢Âó©Âó∂ÂóøÂòÖÂòàÂòäÂòç",5,"ÂòôÂò¨Âò∞Âò≥ÂòµÂò∑ÂòπÂòªÂòºÂòΩÂòøÂôÄÂôÅÂôÉÂôÑÂôÜÂôâÂôãÂôçÂôèÂôîÂôûÂô†Âô°Âô¢Âô£Âô¶Âô©Âô≠ÂôØÂô±Âô≤ÂôµÂöÑÂöÖÂöàÂöãÂöåÂöïÂöôÂööÂöùÂöûÂöüÂö¶ÂößÂö®Âö©Âö´Âö¨Âö≠Âö±Âö≥Âö∑ÂöæÂõÖÂõâÂõäÂõãÂõèÂõêÂõåÂõçÂõôÂõúÂõùÂõüÂõ°Âõ§",4,"Âõ±Âõ´Âõ≠"],["8fb7a1","Âõ∂Âõ∑ÂúÅÂúÇÂúáÂúäÂúåÂúëÂúïÂúöÂúõÂúùÂú†Âú¢Âú£Âú§Âú•Âú©Âú™Âú¨ÂúÆÂúØÂú≥Âú¥ÂúΩÂúæÂúøÂùÖÂùÜÂùåÂùçÂùíÂù¢Âù•ÂùßÂù®Âù´Âù≠",4,"Âù≥Âù¥ÂùµÂù∑ÂùπÂù∫ÂùªÂùºÂùæÂûÅÂûÉÂûåÂûîÂûóÂûôÂûöÂûúÂûùÂûûÂûüÂû°ÂûïÂûßÂû®Âû©Âû¨Âû∏ÂûΩÂüáÂüàÂüåÂüèÂüïÂüùÂüûÂü§Âü¶ÂüßÂü©Âü≠Âü∞ÂüµÂü∂Âü∏ÂüΩÂüæÂüøÂ†ÉÂ†ÑÂ†àÂ†âÂü°"],["8fb8a1","Â†åÂ†çÂ†õÂ†ûÂ†üÂ††Â†¶Â†ßÂ†≠Â†≤Â†πÂ†øÂ°âÂ°åÂ°çÂ°èÂ°êÂ°ïÂ°üÂ°°Â°§Â°ßÂ°®Â°∏Â°ºÂ°øÂ¢ÄÂ¢ÅÂ¢áÂ¢àÂ¢âÂ¢äÂ¢åÂ¢çÂ¢èÂ¢êÂ¢îÂ¢ñÂ¢ùÂ¢†Â¢°Â¢¢Â¢¶Â¢©Â¢±Â¢≤Â£ÑÂ¢ºÂ£ÇÂ£àÂ£çÂ£éÂ£êÂ£íÂ£îÂ£ñÂ£öÂ£ùÂ£°Â£¢Â£©Â£≥Â§ÖÂ§ÜÂ§ãÂ§åÂ§íÂ§ìÂ§îËôÅÂ§ùÂ§°Â§£Â§§Â§®Â§ØÂ§∞Â§≥Â§µÂ§∂Â§øÂ•ÉÂ•ÜÂ•íÂ•ìÂ•ôÂ•õÂ•ùÂ•ûÂ•üÂ•°Â•£Â•´Â•≠"],["8fb9a1","Â•ØÂ•≤Â•µÂ•∂Â•πÂ•ªÂ•ºÂ¶ãÂ¶åÂ¶éÂ¶íÂ¶ïÂ¶óÂ¶üÂ¶§Â¶ßÂ¶≠Â¶ÆÂ¶ØÂ¶∞Â¶≥Â¶∑Â¶∫Â¶ºÂßÅÂßÉÂßÑÂßàÂßäÂßçÂßíÂßùÂßûÂßüÂß£Âß§ÂßßÂßÆÂßØÂß±Âß≤Âß¥Âß∑Â®ÄÂ®ÑÂ®åÂ®çÂ®éÂ®íÂ®ìÂ®ûÂ®£Â®§Â®ßÂ®®Â®™Â®≠Â®∞Â©ÑÂ©ÖÂ©áÂ©àÂ©åÂ©êÂ©ïÂ©ûÂ©£Â©•Â©ßÂ©≠Â©∑Â©∫Â©ªÂ©æÂ™ãÂ™êÂ™ìÂ™ñÂ™ôÂ™úÂ™ûÂ™üÂ™†Â™¢Â™ßÂ™¨Â™±Â™≤Â™≥Â™µÂ™∏Â™∫Â™ªÂ™ø"],["8fbaa1","Â´ÑÂ´ÜÂ´àÂ´èÂ´öÂ´úÂ´†Â´•Â´™Â´ÆÂ´µÂ´∂Â´ΩÂ¨ÄÂ¨ÅÂ¨àÂ¨óÂ¨¥Â¨ôÂ¨õÂ¨ùÂ¨°Â¨•Â¨≠Â¨∏Â≠ÅÂ≠ãÂ≠åÂ≠íÂ≠ñÂ≠ûÂ≠®Â≠ÆÂ≠ØÂ≠ºÂ≠ΩÂ≠æÂ≠øÂÆÅÂÆÑÂÆÜÂÆäÂÆéÂÆêÂÆëÂÆìÂÆîÂÆñÂÆ®ÂÆ©ÂÆ¨ÂÆ≠ÂÆØÂÆ±ÂÆ≤ÂÆ∑ÂÆ∫ÂÆºÂØÄÂØÅÂØçÂØèÂØñ",4,"ÂØ†ÂØØÂØ±ÂØ¥ÂØΩÂ∞åÂ∞óÂ∞ûÂ∞üÂ∞£Â∞¶Â∞©Â∞´Â∞¨Â∞ÆÂ∞∞Â∞≤Â∞µÂ∞∂Â±ôÂ±öÂ±úÂ±¢Â±£Â±ßÂ±®Â±©"],["8fbba1","Â±≠Â±∞Â±¥Â±µÂ±∫Â±ªÂ±ºÂ±ΩÂ≤áÂ≤àÂ≤äÂ≤èÂ≤íÂ≤ùÂ≤üÂ≤†Â≤¢Â≤£Â≤¶Â≤™Â≤≤Â≤¥Â≤µÂ≤∫Â≥âÂ≥ãÂ≥íÂ≥ùÂ≥óÂ≥ÆÂ≥±Â≥≤Â≥¥Â¥ÅÂ¥ÜÂ¥çÂ¥íÂ¥´Â¥£Â¥§Â¥¶Â¥ßÂ¥±Â¥¥Â¥πÂ¥ΩÂ¥øÂµÇÂµÉÂµÜÂµàÂµïÂµëÂµôÂµäÂµüÂµ†Âµ°Âµ¢Âµ§Âµ™Âµ≠Âµ∞ÂµπÂµ∫ÂµæÂµøÂ∂ÅÂ∂ÉÂ∂àÂ∂äÂ∂íÂ∂ìÂ∂îÂ∂ïÂ∂ôÂ∂õÂ∂üÂ∂†Â∂ßÂ∂´Â∂∞Â∂¥Â∂∏Â∂πÂ∑ÉÂ∑áÂ∑ãÂ∑êÂ∑éÂ∑òÂ∑ôÂ∑†Â∑§"],["8fbca1","Â∑©Â∑∏Â∑πÂ∏ÄÂ∏áÂ∏çÂ∏íÂ∏îÂ∏ïÂ∏òÂ∏üÂ∏†Â∏ÆÂ∏®Â∏≤Â∏µÂ∏æÂπãÂπêÂπâÂπëÂπñÂπòÂπõÂπúÂπûÂπ®Âπ™",4,"Âπ∞Â∫ÄÂ∫ãÂ∫éÂ∫¢Â∫§Â∫•Â∫®Â∫™Â∫¨Â∫±Â∫≥Â∫ΩÂ∫æÂ∫øÂªÜÂªåÂªãÂªéÂªëÂªíÂªîÂªïÂªúÂªûÂª•Âª´ÂºÇÂºÜÂºáÂºàÂºéÂºôÂºúÂºùÂº°Âº¢Âº£Âº§Âº®Âº´Âº¨ÂºÆÂº∞Âº¥Âº∂ÂºªÂºΩÂºøÂΩÄÂΩÑÂΩÖÂΩáÂΩçÂΩêÂΩîÂΩòÂΩõÂΩ†ÂΩ£ÂΩ§ÂΩß"],["8fbda1","ÂΩØÂΩ≤ÂΩ¥ÂΩµÂΩ∏ÂΩ∫ÂΩΩÂΩæÂæâÂæçÂæèÂæñÂæúÂæùÂæ¢ÂæßÂæ´Âæ§Âæ¨ÂæØÂæ∞Âæ±Âæ∏ÂøÑÂøáÂøàÂøâÂøãÂøê",4,"ÂøûÂø°Âø¢Âø®Âø©Âø™Âø¨Âø≠ÂøÆÂøØÂø≤Âø≥Âø∂Âø∫ÂøºÊÄáÊÄäÊÄçÊÄìÊÄîÊÄóÊÄòÊÄöÊÄüÊÄ§ÊÄ≠ÊÄ≥ÊÄµÊÅÄÊÅáÊÅàÊÅâÊÅåÊÅëÊÅîÊÅñÊÅóÊÅùÊÅ°ÊÅßÊÅ±ÊÅæÊÅøÊÇÇÊÇÜÊÇàÊÇäÊÇéÊÇëÊÇìÊÇïÊÇòÊÇùÊÇûÊÇ¢ÊÇ§ÊÇ•ÊÇ®ÊÇ∞ÊÇ±ÊÇ∑"],["8fbea1","ÊÇªÊÇæÊÉÇÊÉÑÊÉàÊÉâÊÉäÊÉãÊÉéÊÉèÊÉîÊÉïÊÉôÊÉõÊÉùÊÉûÊÉ¢ÊÉ•ÊÉ≤ÊÉµÊÉ∏ÊÉºÊÉΩÊÑÇÊÑáÊÑäÊÑåÊÑê",4,"ÊÑñÊÑóÊÑôÊÑúÊÑûÊÑ¢ÊÑ™ÊÑ´ÊÑ∞ÊÑ±ÊÑµÊÑ∂ÊÑ∑ÊÑπÊÖÅÊÖÖÊÖÜÊÖâÊÖûÊÖ†ÊÖ¨ÊÖ≤ÊÖ∏ÊÖªÊÖºÊÖøÊÜÄÊÜÅÊÜÉÊÜÑÊÜãÊÜçÊÜíÊÜìÊÜóÊÜòÊÜúÊÜùÊÜüÊÜ†ÊÜ•ÊÜ®ÊÜ™ÊÜ≠ÊÜ∏ÊÜπÊÜºÊáÄÊáÅÊáÇÊáéÊáèÊáïÊáúÊáùÊáûÊáüÊá°Êá¢ÊáßÊá©Êá•"],["8fbfa1","Êá¨Êá≠ÊáØÊàÅÊàÉÊàÑÊàáÊàìÊàïÊàúÊà†Êà¢Êà£ÊàßÊà©Êà´ÊàπÊàΩÊâÇÊâÉÊâÑÊâÜÊâåÊâêÊâëÊâíÊâîÊâñÊâöÊâúÊâ§Êâ≠ÊâØÊâ≥Êâ∫ÊâΩÊäçÊäéÊäèÊäêÊä¶Êä®Êä≥Êä∂Êä∑Êä∫ÊäæÊäøÊãÑÊãéÊãïÊãñÊãöÊã™Êã≤Êã¥ÊãºÊãΩÊåÉÊåÑÊåäÊåãÊåçÊåêÊåìÊåñÊåòÊå©Êå™Êå≠ÊåµÊå∂ÊåπÊåºÊçÅÊçÇÊçÉÊçÑÊçÜÊçäÊçãÊçéÊçíÊçìÊçîÊçòÊçõÊç•Êç¶Êç¨Êç≠Êç±Êç¥Êçµ"],["8fc0a1","Êç∏ÊçºÊçΩÊçøÊéÇÊéÑÊéáÊéäÊéêÊéîÊéïÊéôÊéöÊéûÊé§Êé¶Êé≠ÊéÆÊéØÊéΩÊèÅÊèÖÊèàÊèéÊèëÊèìÊèîÊèïÊèúÊè†Êè•Êè™Êè¨Êè≤Êè≥ÊèµÊè∏ÊèπÊêâÊêäÊêêÊêíÊêîÊêòÊêûÊê†Êê¢Êê§Êê•Êê©Êê™ÊêØÊê∞ÊêµÊêΩÊêøÊëãÊëèÊëëÊëíÊëìÊëîÊëöÊëõÊëúÊëùÊëüÊë†Êë°Êë£Êë≠Êë≥Êë¥ÊëªÊëΩÊíÖÊíáÊíèÊíêÊíëÊíòÊíôÊíõÊíùÊíüÊí°Êí£Êí¶Êí®Êí¨Êí≥ÊíΩÊíæÊíø"],["8fc1a1","ÊìÑÊìâÊìäÊìãÊìåÊìéÊìêÊìëÊìïÊìóÊì§Êì•Êì©Êì™Êì≠Êì∞ÊìµÊì∑ÊìªÊìøÊîÅÊîÑÊîàÊîâÊîäÊîèÊîìÊîîÊîñÊîôÊîõÊîûÊîüÊî¢Êî¶Êî©ÊîÆÊî±Êî∫ÊîºÊîΩÊïÉÊïáÊïâÊïêÊïíÊïîÊïüÊï†ÊïßÊï´Êï∫ÊïΩÊñÅÊñÖÊñäÊñíÊñïÊñòÊñùÊñ†Êñ£Êñ¶ÊñÆÊñ≤Êñ≥Êñ¥ÊñøÊóÇÊóàÊóâÊóéÊóêÊóîÊóñÊóòÊóüÊó∞Êó≤Êó¥ÊóµÊóπÊóæÊóøÊòÄÊòÑÊòàÊòâÊòçÊòëÊòíÊòïÊòñÊòù"],["8fc2a1","ÊòûÊò°Êò¢Êò£Êò§Êò¶Êò©Êò™Êò´Êò¨ÊòÆÊò∞Êò±Êò≥ÊòπÊò∑ÊôÄÊôÖÊôÜÊôäÊôåÊôëÊôéÊôóÊôòÊôôÊôõÊôúÊô†Êô°ÊõªÊô™Êô´Êô¨ÊôæÊô≥ÊôµÊôøÊô∑Êô∏ÊôπÊôªÊöÄÊôºÊöãÊöåÊöçÊöêÊöíÊöôÊööÊöõÊöúÊöüÊö†Êö§Êö≠Êö±Êö≤ÊöµÊöªÊöøÊõÄÊõÇÊõÉÊõàÊõåÊõéÊõèÊõîÊõõÊõüÊõ®Êõ´Êõ¨ÊõÆÊõ∫ÊúÖÊúáÊúéÊúìÊúôÊúúÊú†Êú¢Êú≥ÊúæÊùÖÊùáÊùàÊùåÊùîÊùïÊùù"],["8fc3a1","Êù¶Êù¨ÊùÆÊù¥Êù∂ÊùªÊûÅÊûÑÊûéÊûèÊûëÊûìÊûñÊûòÊûôÊûõÊû∞Êû±Êû≤ÊûµÊûªÊûºÊûΩÊüπÊüÄÊüÇÊüÉÊüÖÊüàÊüâÊüíÊüóÊüôÊüúÊü°Êü¶Êü∞Êü≤Êü∂Êü∑Ê°íÊ†îÊ†ôÊ†ùÊ†üÊ†®Ê†ßÊ†¨Ê†≠Ê†ØÊ†∞Ê†±Ê†≥Ê†ªÊ†øÊ°ÑÊ°ÖÊ°äÊ°åÊ°ïÊ°óÊ°òÊ°õÊ°´Ê°Æ",4,"Ê°µÊ°πÊ°∫Ê°ªÊ°ºÊ¢ÇÊ¢ÑÊ¢ÜÊ¢àÊ¢ñÊ¢òÊ¢öÊ¢úÊ¢°Ê¢£Ê¢•Ê¢©Ê¢™Ê¢ÆÊ¢≤Ê¢ªÊ£ÖÊ£àÊ£åÊ£è"],["8fc4a1","Ê£êÊ£ëÊ£ìÊ£ñÊ£ôÊ£úÊ£ùÊ£•Ê£®Ê£™Ê£´Ê£¨Ê£≠Ê£∞Ê£±Ê£µÊ£∂Ê£ªÊ£ºÊ£ΩÊ§ÜÊ§âÊ§äÊ§êÊ§ëÊ§ìÊ§ñÊ§óÊ§±Ê§≥Ê§µÊ§∏Ê§ªÊ•ÇÊ•ÖÊ•âÊ•éÊ•óÊ•õÊ•£Ê•§Ê••Ê•¶Ê•®Ê•©Ê•¨Ê•∞Ê•±Ê•≤Ê•∫Ê•ªÊ•øÊ¶ÄÊ¶çÊ¶íÊ¶ñÊ¶òÊ¶°Ê¶•Ê¶¶Ê¶®Ê¶´Ê¶≠Ê¶ØÊ¶∑Ê¶∏Ê¶∫Ê¶ºÊßÖÊßàÊßëÊßñÊßóÊß¢Êß•ÊßÆÊßØÊß±Êß≥ÊßµÊßæÊ®ÄÊ®ÅÊ®ÉÊ®èÊ®ëÊ®ïÊ®öÊ®ùÊ®†Ê®§Ê®®Ê®∞Ê®≤"],["8fc5a1","Ê®¥Ê®∑Ê®ªÊ®æÊ®øÊ©ÖÊ©ÜÊ©âÊ©äÊ©éÊ©êÊ©ëÊ©íÊ©ïÊ©ñÊ©õÊ©§Ê©ßÊ©™Ê©±Ê©≥Ê©æÊ™ÅÊ™ÉÊ™ÜÊ™áÊ™âÊ™ãÊ™ëÊ™õÊ™ùÊ™ûÊ™üÊ™•Ê™´Ê™ØÊ™∞Ê™±Ê™¥Ê™ΩÊ™æÊ™øÊ´ÜÊ´âÊ´àÊ´åÊ´êÊ´îÊ´ïÊ´ñÊ´úÊ´ùÊ´§Ê´ßÊ´¨Ê´∞Ê´±Ê´≤Ê´ºÊ´ΩÊ¨ÇÊ¨ÉÊ¨ÜÊ¨áÊ¨âÊ¨èÊ¨êÊ¨ëÊ¨óÊ¨õÊ¨ûÊ¨§Ê¨®Ê¨´Ê¨¨Ê¨ØÊ¨µÊ¨∂Ê¨ªÊ¨øÊ≠ÜÊ≠äÊ≠çÊ≠íÊ≠ñÊ≠òÊ≠ùÊ≠†Ê≠ßÊ≠´Ê≠ÆÊ≠∞Ê≠µÊ≠Ω"],["8fc6a1","Ê≠æÊÆÇÊÆÖÊÆóÊÆõÊÆüÊÆ†ÊÆ¢ÊÆ£ÊÆ®ÊÆ©ÊÆ¨ÊÆ≠ÊÆÆÊÆ∞ÊÆ∏ÊÆπÊÆΩÊÆæÊØÉÊØÑÊØâÊØåÊØñÊØöÊØ°ÊØ£ÊØ¶ÊØßÊØÆÊØ±ÊØ∑ÊØπÊØøÊ∞ÇÊ∞ÑÊ∞ÖÊ∞âÊ∞çÊ∞éÊ∞êÊ∞íÊ∞ôÊ∞üÊ∞¶Ê∞ßÊ∞®Ê∞¨Ê∞ÆÊ∞≥Ê∞µÊ∞∂Ê∞∫Ê∞ªÊ∞øÊ±äÊ±ãÊ±çÊ±èÊ±íÊ±îÊ±ôÊ±õÊ±úÊ±´Ê±≠Ê±ØÊ±¥Ê±∂Ê±∏Ê±πÊ±ªÊ≤ÖÊ≤ÜÊ≤áÊ≤âÊ≤îÊ≤ïÊ≤óÊ≤òÊ≤úÊ≤üÊ≤∞Ê≤≤Ê≤¥Ê≥ÇÊ≥ÜÊ≥çÊ≥èÊ≥êÊ≥ëÊ≥íÊ≥îÊ≥ñ"],["8fc7a1","Ê≥öÊ≥úÊ≥†Ê≥ßÊ≥©Ê≥´Ê≥¨Ê≥ÆÊ≥≤Ê≥¥Ê¥ÑÊ¥áÊ¥äÊ¥éÊ¥èÊ¥ëÊ¥ìÊ¥öÊ¥¶Ê¥ßÊ¥®Ê±ßÊ¥ÆÊ¥ØÊ¥±Ê¥πÊ¥ºÊ¥øÊµóÊµûÊµüÊµ°Êµ•ÊµßÊµØÊµ∞ÊµºÊ∂ÇÊ∂áÊ∂ëÊ∂íÊ∂îÊ∂ñÊ∂óÊ∂òÊ∂™Ê∂¨Ê∂¥Ê∂∑Ê∂πÊ∂ΩÊ∂øÊ∑ÑÊ∑àÊ∑äÊ∑éÊ∑èÊ∑ñÊ∑õÊ∑ùÊ∑üÊ∑†Ê∑¢Ê∑•Ê∑©Ê∑ØÊ∑∞Ê∑¥Ê∑∂Ê∑ºÊ∏ÄÊ∏ÑÊ∏ûÊ∏¢Ê∏ßÊ∏≤Ê∏∂Ê∏πÊ∏ªÊ∏ºÊπÑÊπÖÊπàÊπâÊπãÊπèÊπëÊπíÊπìÊπîÊπóÊπúÊπùÊπû"],["8fc8a1","Êπ¢Êπ£Êπ®Êπ≥ÊπªÊπΩÊ∫çÊ∫ìÊ∫ôÊ∫†Ê∫ßÊ∫≠Ê∫ÆÊ∫±Ê∫≥Ê∫ªÊ∫øÊªÄÊªÅÊªÉÊªáÊªàÊªäÊªçÊªéÊªèÊª´Êª≠ÊªÆÊªπÊªªÊªΩÊºÑÊºàÊºäÊºåÊºçÊºñÊºòÊºöÊºõÊº¶Êº©Êº™ÊºØÊº∞Êº≥Êº∂ÊºªÊººÊº≠ÊΩèÊΩëÊΩíÊΩìÊΩóÊΩôÊΩöÊΩùÊΩûÊΩ°ÊΩ¢ÊΩ®ÊΩ¨ÊΩΩÊΩæÊæÉÊæáÊæàÊæãÊæåÊæçÊæêÊæíÊæìÊæîÊæñÊæöÊæüÊæ†Êæ•Êæ¶ÊæßÊæ®ÊæÆÊæØÊæ∞ÊæµÊæ∂ÊæºÊøÖÊøáÊøàÊøä"],["8fc9a1","ÊøöÊøûÊø®Êø©Êø∞ÊøµÊøπÊøºÊøΩÁÄÄÁÄÖÁÄÜÁÄáÁÄçÁÄóÁÄ†ÁÄ£ÁÄØÁÄ¥ÁÄ∑ÁÄπÁÄºÁÅÉÁÅÑÁÅàÁÅâÁÅäÁÅãÁÅîÁÅïÁÅùÁÅûÁÅéÁÅ§ÁÅ•ÁÅ¨ÁÅÆÁÅµÁÅ∂ÁÅæÁÇÅÁÇÖÁÇÜÁÇî",4,"ÁÇõÁÇ§ÁÇ´ÁÇ∞ÁÇ±ÁÇ¥ÁÇ∑ÁÉäÁÉëÁÉìÁÉîÁÉïÁÉñÁÉòÁÉúÁÉ§ÁÉ∫ÁÑÉ",4,"ÁÑãÁÑåÁÑèÁÑûÁÑ†ÁÑ´ÁÑ≠ÁÑØÁÑ∞ÁÑ±ÁÑ∏ÁÖÅÁÖÖÁÖÜÁÖáÁÖäÁÖãÁÖêÁÖíÁÖóÁÖöÁÖúÁÖûÁÖ†"],["8fcaa1","ÁÖ®ÁÖπÁÜÄÁÜÖÁÜáÁÜåÁÜíÁÜöÁÜõÁÜ†ÁÜ¢ÁÜØÁÜ∞ÁÜ≤ÁÜ≥ÁÜ∫ÁÜøÁáÄÁáÅÁáÑÁáãÁáåÁáìÁáñÁáôÁáöÁáúÁá∏ÁáæÁàÄÁàáÁààÁàâÁàìÁàóÁàöÁàùÁàüÁà§Áà´ÁàØÁà¥Áà∏ÁàπÁâÅÁâÇÁâÉÁâÖÁâéÁâèÁâêÁâìÁâïÁâñÁâöÁâúÁâûÁâ†Áâ£Áâ®Áâ´ÁâÆÁâØÁâ±Áâ∑Áâ∏ÁâªÁâºÁâøÁäÑÁäâÁäçÁäéÁäìÁäõÁä®Áä≠ÁäÆÁä±Áä¥ÁäæÁãÅÁãáÁãâÁãåÁãïÁãñÁãòÁãüÁã•Áã≥Áã¥Áã∫Áãª"],["8fcba1","ÁãæÁåÇÁåÑÁåÖÁåáÁåãÁåçÁåíÁåìÁåòÁåôÁåûÁå¢Áå§ÁåßÁå®Áå¨Áå±Áå≤ÁåµÁå∫ÁåªÁåΩÁçÉÁççÁçêÁçíÁçñÁçòÁçùÁçûÁçüÁç†Áç¶ÁçßÁç©Áç´Áç¨ÁçÆÁçØÁç±Áç∑ÁçπÁçºÁéÄÁéÅÁéÉÁéÖÁéÜÁééÁéêÁéìÁéïÁéóÁéòÁéúÁéûÁéüÁé†Áé¢Áé•Áé¶Áé™Áé´Áé≠ÁéµÁé∑ÁéπÁéºÁéΩÁéøÁèÖÁèÜÁèâÁèãÁèåÁèèÁèíÁèìÁèñÁèôÁèùÁè°Áè£Áè¶ÁèßÁè©Áè¥ÁèµÁè∑ÁèπÁè∫ÁèªÁèΩ"],["8fcca1","ÁèøÁêÄÁêÅÁêÑÁêáÁêäÁêëÁêöÁêõÁê§Áê¶Áê®",9,"ÁêπÁëÄÁëÉÁëÑÁëÜÁëáÁëãÁëçÁëëÁëíÁëóÁëùÁë¢Áë¶ÁëßÁë®Áë´Áë≠ÁëÆÁë±Áë≤ÁíÄÁíÅÁíÖÁíÜÁíáÁíâÁíèÁíêÁíëÁííÁíòÁíôÁíöÁíúÁíüÁí†Áí°Áí£Áí¶Áí®Áí©Áí™Áí´ÁíÆÁíØÁí±Áí≤ÁíµÁíπÁíªÁíøÁìàÁìâÁìåÁìêÁììÁìòÁìöÁìõÁìûÁìüÁì§Áì®Áì™Áì´ÁìØÁì¥Áì∫ÁìªÁìºÁìøÁîÜ"],["8fcda1","ÁîíÁîñÁîóÁî†Áî°Áî§ÁîßÁî©Áî™ÁîØÁî∂ÁîπÁîΩÁîæÁîøÁïÄÁïÉÁïáÁïàÁïéÁïêÁïíÁïóÁïûÁïüÁï°ÁïØÁï±Áïπ",5,"ÁñÅÁñÖÁñêÁñíÁñìÁñïÁñôÁñúÁñ¢Áñ§Áñ¥Áñ∫ÁñøÁóÄÁóÅÁóÑÁóÜÁóåÁóéÁóèÁóóÁóúÁóüÁó†Áó°Áó§ÁóßÁó¨ÁóÆÁóØÁó±ÁóπÁòÄÁòÇÁòÉÁòÑÁòáÁòàÁòäÁòåÁòèÁòíÁòìÁòïÁòñÁòôÁòõÁòúÁòùÁòûÁò£Áò•Áò¶Áò©Áò≠Áò≤Áò≥ÁòµÁò∏Áòπ"],["8fcea1","Áò∫ÁòºÁôäÁôÄÁôÅÁôÉÁôÑÁôÖÁôâÁôãÁôïÁôôÁôüÁô§Áô•Áô≠ÁôÆÁôØÁô±Áô¥ÁöÅÁöÖÁöåÁöçÁöïÁöõÁöúÁöùÁöüÁö†Áö¢",6,"Áö™Áö≠ÁöΩÁõÅÁõÖÁõâÁõãÁõåÁõéÁõîÁõôÁõ†Áõ¶Áõ®Áõ¨Áõ∞Áõ±Áõ∂ÁõπÁõºÁúÄÁúÜÁúäÁúéÁúíÁúîÁúïÁúóÁúôÁúöÁúúÁú¢Áú®Áú≠ÁúÆÁúØÁú¥ÁúµÁú∂ÁúπÁúΩÁúæÁùÇÁùÖÁùÜÁùäÁùçÁùéÁùèÁùíÁùñÁùóÁùúÁùûÁùüÁù†Áù¢"],["8fcfa1","Áù§ÁùßÁù™Áù¨Áù∞Áù≤Áù≥Áù¥Áù∫ÁùΩÁûÄÁûÑÁûåÁûçÁûîÁûïÁûñÁûöÁûüÁû¢ÁûßÁû™ÁûÆÁûØÁû±ÁûµÁûæÁüÉÁüâÁüëÁüíÁüïÁüôÁüûÁüüÁü†Áü§Áü¶Áü™Áü¨Áü∞Áü±Áü¥Áü∏ÁüªÁ†ÖÁ†ÜÁ†âÁ†çÁ†éÁ†ëÁ†ùÁ†°Á†¢Á†£Á†≠Á†ÆÁ†∞Á†µÁ†∑Á°ÉÁ°ÑÁ°áÁ°àÁ°åÁ°éÁ°íÁ°úÁ°ûÁ°†Á°°Á°£Á°§Á°®Á°™Á°ÆÁ°∫Á°æÁ¢äÁ¢èÁ¢îÁ¢òÁ¢°Á¢ùÁ¢ûÁ¢üÁ¢§Á¢®Á¢¨Á¢≠Á¢∞Á¢±Á¢≤Á¢≥"],["8fd0a1","Á¢ªÁ¢ΩÁ¢øÁ£áÁ£àÁ£âÁ£åÁ£éÁ£íÁ£ìÁ£ïÁ£ñÁ£§Á£õÁ£üÁ£†Á£°Á£¶Á£™Á£≤Á£≥Á§ÄÁ£∂Á£∑Á£∫Á£ªÁ£øÁ§ÜÁ§åÁ§êÁ§öÁ§úÁ§ûÁ§üÁ§†Á§•Á§ßÁ§©Á§≠Á§±Á§¥Á§µÁ§ªÁ§ΩÁ§øÁ•ÑÁ•ÖÁ•ÜÁ•äÁ•ãÁ•èÁ•ëÁ•îÁ•òÁ•õÁ•úÁ•ßÁ•©Á•´Á•≤Á•πÁ•ªÁ•ºÁ•æÁ¶ãÁ¶åÁ¶ëÁ¶ìÁ¶îÁ¶ïÁ¶ñÁ¶òÁ¶õÁ¶úÁ¶°Á¶®Á¶©Á¶´Á¶ØÁ¶±Á¶¥Á¶∏Á¶ªÁßÇÁßÑÁßáÁßàÁßäÁßèÁßîÁßñÁßöÁßùÁßû"],["8fd1a1","Áß†Áß¢Áß•Áß™Áß´Áß≠Áß±Áß∏ÁßºÁ®ÇÁ®ÉÁ®áÁ®âÁ®äÁ®åÁ®ëÁ®ïÁ®õÁ®ûÁ®°Á®ßÁ®´Á®≠Á®ØÁ®∞Á®¥Á®µÁ®∏Á®πÁ®∫Á©ÑÁ©ÖÁ©áÁ©àÁ©åÁ©ïÁ©ñÁ©ôÁ©úÁ©ùÁ©üÁ©†Á©•Á©ßÁ©™Á©≠Á©µÁ©∏Á©æÁ™ÄÁ™ÇÁ™ÖÁ™ÜÁ™äÁ™ãÁ™êÁ™ëÁ™îÁ™ûÁ™†Á™£Á™¨Á™≥Á™µÁ™πÁ™ªÁ™ºÁ´ÜÁ´âÁ´åÁ´éÁ´ëÁ´õÁ´®Á´©Á´´Á´¨Á´±Á´¥Á´ªÁ´ΩÁ´æÁ¨áÁ¨îÁ¨üÁ¨£Á¨ßÁ¨©Á¨™Á¨´Á¨≠Á¨ÆÁ¨ØÁ¨∞"],["8fd2a1","Á¨±Á¨¥Á¨ΩÁ¨øÁ≠ÄÁ≠ÅÁ≠áÁ≠éÁ≠ïÁ≠†Á≠§Á≠¶Á≠©Á≠™Á≠≠Á≠ØÁ≠≤Á≠≥Á≠∑ÁÆÑÁÆâÁÆéÁÆêÁÆëÁÆñÁÆõÁÆûÁÆ†ÁÆ•ÁÆ¨ÁÆØÁÆ∞ÁÆ≤ÁÆµÁÆ∂ÁÆ∫ÁÆªÁÆºÁÆΩÁØÇÁØÖÁØàÁØäÁØîÁØñÁØóÁØôÁØöÁØõÁØ®ÁØ™ÁØ≤ÁØ¥ÁØµÁØ∏ÁØπÁØ∫ÁØºÁØæÁ∞ÅÁ∞ÇÁ∞ÉÁ∞ÑÁ∞ÜÁ∞âÁ∞ãÁ∞åÁ∞éÁ∞èÁ∞ôÁ∞õÁ∞†Á∞•Á∞¶Á∞®Á∞¨Á∞±Á∞≥Á∞¥Á∞∂Á∞πÁ∞∫Á±ÜÁ±äÁ±ïÁ±ëÁ±íÁ±ìÁ±ô",5],["8fd3a1","Á±°Á±£Á±ßÁ±©Á±≠Á±ÆÁ±∞Á±≤Á±πÁ±ºÁ±ΩÁ≤ÜÁ≤áÁ≤èÁ≤îÁ≤ûÁ≤†Á≤¶Á≤∞Á≤∂Á≤∑Á≤∫Á≤ªÁ≤ºÁ≤øÁ≥ÑÁ≥áÁ≥àÁ≥âÁ≥çÁ≥èÁ≥ìÁ≥îÁ≥ïÁ≥óÁ≥ôÁ≥öÁ≥ùÁ≥¶Á≥©Á≥´Á≥µÁ¥ÉÁ¥áÁ¥àÁ¥âÁ¥èÁ¥ëÁ¥íÁ¥ìÁ¥ñÁ¥ùÁ¥ûÁ¥£Á¥¶Á¥™Á¥≠Á¥±Á¥ºÁ¥ΩÁ¥æÁµÄÁµÅÁµáÁµàÁµçÁµëÁµìÁµóÁµôÁµöÁµúÁµùÁµ•ÁµßÁµ™Áµ∞Áµ∏Áµ∫ÁµªÁµøÁ∂ÅÁ∂ÇÁ∂ÉÁ∂ÖÁ∂ÜÁ∂àÁ∂ãÁ∂åÁ∂çÁ∂ëÁ∂ñÁ∂óÁ∂ù"],["8fd4a1","Á∂ûÁ∂¶Á∂ßÁ∂™Á∂≥Á∂∂Á∂∑Á∂πÁ∑Ç",4,"Á∑åÁ∑çÁ∑éÁ∑óÁ∑ôÁ∏ÄÁ∑¢Á∑•Á∑¶Á∑™Á∑´Á∑≠Á∑±Á∑µÁ∑∂Á∑πÁ∑∫Á∏àÁ∏êÁ∏ëÁ∏ïÁ∏óÁ∏úÁ∏ùÁ∏†Á∏ßÁ∏®Á∏¨Á∏≠Á∏ØÁ∏≥Á∏∂Á∏øÁπÑÁπÖÁπáÁπéÁπêÁπíÁπòÁπüÁπ°Áπ¢Áπ•Áπ´ÁπÆÁπØÁπ≥Áπ∏ÁπæÁ∫ÅÁ∫ÜÁ∫áÁ∫äÁ∫çÁ∫ëÁ∫ïÁ∫òÁ∫öÁ∫ùÁ∫ûÁººÁºªÁºΩÁºæÁºøÁΩÉÁΩÑÁΩáÁΩèÁΩíÁΩìÁΩõÁΩúÁΩùÁΩ°ÁΩ£ÁΩ§ÁΩ•ÁΩ¶ÁΩ≠"],["8fd5a1","ÁΩ±ÁΩΩÁΩæÁΩøÁæÄÁæãÁæçÁæèÁæêÁæëÁæñÁæóÁæúÁæ°Áæ¢Áæ¶Áæ™Áæ≠Áæ¥ÁæºÁæøÁøÄÁøÉÁøàÁøéÁøèÁøõÁøüÁø£Áø•Áø®Áø¨ÁøÆÁøØÁø≤Áø∫ÁøΩÁøæÁøøËÄáËÄàËÄäËÄçËÄéËÄèËÄëËÄìËÄîËÄñËÄùËÄûËÄüËÄ†ËÄ§ËÄ¶ËÄ¨ËÄÆËÄ∞ËÄ¥ËÄµËÄ∑ËÄπËÄ∫ËÄºËÄæËÅÄËÅÑËÅ†ËÅ§ËÅ¶ËÅ≠ËÅ±ËÅµËÇÅËÇàËÇéËÇúËÇûËÇ¶ËÇßËÇ´ËÇ∏ËÇπËÉàËÉçËÉèËÉíËÉîËÉïËÉóËÉòËÉ†ËÉ≠ËÉÆ"],["8fd6a1","ËÉ∞ËÉ≤ËÉ≥ËÉ∂ËÉπËÉ∫ËÉæËÑÉËÑãËÑñËÑóËÑòËÑúËÑûËÑ†ËÑ§ËÑßËÑ¨ËÑ∞ËÑµËÑ∫ËÑºËÖÖËÖáËÖäËÖåËÖíËÖóËÖ†ËÖ°ËÖßËÖ®ËÖ©ËÖ≠ËÖØËÖ∑ËÜÅËÜêËÜÑËÜÖËÜÜËÜãËÜéËÜñËÜòËÜõËÜûËÜ¢ËÜÆËÜ≤ËÜ¥ËÜªËáãËáÉËáÖËáäËáéËáèËáïËáóËáõËáùËáûËá°Ëá§Ëá´Ëá¨Ëá∞Ëá±Ëá≤ËáµËá∂Ëá∏ËáπËáΩËáøËàÄËàÉËàèËàìËàîËàôËàöËàùËà°Ëà¢Ëà®Ëà≤Ëà¥Ëà∫ËâÉËâÑËâÖËâÜ"],["8fd7a1","ËâãËâéËâèËâëËâñËâúËâ†Ëâ£ËâßËâ≠Ëâ¥ËâªËâΩËâøËäÄËäÅËäÉËäÑËäáËäâËääËäéËäëËäîËäñËäòËäöËäõËä†Ëä°Ëä£Ëä§ËäßËä®Ëä©Ëä™ËäÆËä∞Ëä≤Ëä¥Ëä∑Ëä∫ËäºËäæËäøËãÜËãêËãïËãöËã†Ëã¢Ëã§Ëã®Ëã™Ëã≠ËãØËã∂Ëã∑ËãΩËãæËåÄËåÅËåáËåàËåäËåãËçîËåõËåùËåûËåüËå°Ëå¢Ëå¨Ëå≠ËåÆËå∞Ëå≥Ëå∑Ëå∫ËåºËåΩËçÇËçÉËçÑËçáËççËçéËçëËçïËçñËçóËç∞Ëç∏"],["8fd8a1","ËçΩËçøËéÄËéÇËéÑËéÜËéçËéíËéîËéïËéòËéôËéõËéúËéùËé¶ËéßËé©Ëé¨ËéæËéøËèÄËèáËèâËèèËèêËèëËèîËèùËçìËè®Ëè™Ëè∂Ëè∏ËèπËèºËêÅËêÜËêäËêèËêëËêïËêôËé≠ËêØËêπËëÖËëáËëàËëäËëçËëèËëëËëíËëñËëòËëôËëöËëúËë†Ëë§Ëë•ËëßËë™Ëë∞Ëë≥Ëë¥Ëë∂Ëë∏ËëºËëΩËíÅËíÖËííËíìËíïËíûËí¶Ëí®Ëí©Ëí™ËíØËí±Ëí¥Ëí∫ËíΩËíæËìÄËìÇËìáËìàËìåËìèËìì"],["8fd9a1","ËìúËìßËì™ËìØËì∞Ëì±Ëì≤Ëì∑Ëî≤Ëì∫ËìªËìΩËîÇËîÉËîáËîåËîéËîêËîúËîûËî¢Ëî£Ëî§Ëî•ËîßËî™Ëî´ËîØËî≥Ëî¥Ëî∂ËîøËïÜËïè",4,"ËïñËïôËïú",6,"Ëï§Ëï´ËïØËïπËï∫ËïªËïΩËïøËñÅËñÖËñÜËñâËñãËñåËñèËñìËñòËñùËñüËñ†Ëñ¢Ëñ•ËñßËñ¥Ëñ∂Ëñ∑Ëñ∏ËñºËñΩËñæËñøËóÇËóáËóäËóãËóéËñ≠ËóòËóöËóüËó†Ëó¶Ëó®Ëó≠Ëó≥Ëó∂Ëóº"],["8fdaa1","ËóøËòÄËòÑËòÖËòçËòéËòêËòëËòíËòòËòôËòõËòûËò°ËòßËò©Ëò∂Ëò∏Ëò∫ËòºËòΩËôÄËôÇËôÜËôíËôìËôñËôóËôòËôôËôùËô†",4,"Ëô©Ëô¨ËôØËôµËô∂Ëô∑Ëô∫ËöçËöëËöñËöòËööËöúËö°Ëö¶ËößËö®Ëö≠Ëö±Ëö≥Ëö¥ËöµËö∑Ëö∏ËöπËöøËõÄËõÅËõÉËõÖËõëËõíËõïËõóËõöËõúËõ†Ëõ£Ëõ•ËõßËöàËõ∫ËõºËõΩËúÑËúÖËúáËúãËúéËúèËúêËúìËúîËúôËúûËúüËú°Ëú£"],["8fdba1","Ëú®ËúÆËúØËú±Ëú≤ËúπËú∫ËúºËúΩËúæËùÄËùÉËùÖËùçËùòËùùËù°Ëù§Ëù•ËùØËù±Ëù≤ËùªËûÉ",6,"ËûãËûåËûêËûìËûïËûóËûòËûôËûûËû†Ëû£ËûßËû¨Ëû≠ËûÆËû±ËûµËûæËûøËüÅËüàËüâËüäËüéËüïËüñËüôËüöËüúËüüËü¢Ëü£Ëü§Ëü™Ëü´Ëü≠Ëü±Ëü≥Ëü∏Ëü∫ËüøË†ÅË†ÉË†ÜË†âË†äË†ãË†êË†ôË†íË†ìË†îË†òË†öË†õË†úË†ûË†üË†®Ë†≠Ë†ÆË†∞Ë†≤Ë†µ"],["8fdca1","Ë†∫Ë†ºË°ÅË°ÉË°ÖË°àË°âË°äË°ãË°éË°ëË°ïË°ñË°òË°öË°úË°üË°†Ë°§Ë°©Ë°±Ë°πË°ªË¢ÄË¢òË¢öË¢õË¢úË¢üË¢†Ë¢®Ë¢™Ë¢∫Ë¢ΩË¢æË£ÄË£ä",4,"Ë£ëË£íË£ìË£õË£ûË£ßË£ØË£∞Ë£±Ë£µË£∑Ë§ÅË§ÜË§çË§éË§èË§ïË§ñË§òË§ôË§öË§úË§†Ë§¶Ë§ßË§®Ë§∞Ë§±Ë§≤Ë§µË§πË§∫Ë§æË•ÄË•ÇË•ÖË•ÜË•âË•èË•íË•óË•öË•õË•úË•°Ë•¢Ë•£Ë•´Ë•ÆË•∞Ë•≥Ë•µË•∫"],["8fdda1","Ë•ªË•ºË•ΩË¶âË¶çË¶êË¶îË¶ïË¶õË¶úË¶üË¶†Ë¶•Ë¶∞Ë¶¥Ë¶µË¶∂Ë¶∑Ë¶ºËßî",4,"Ëß•Ëß©Ëß´Ëß≠Ëß±Ëß≥Ëß∂ËßπËßΩËßøË®ÑË®ÖË®áË®èË®ëË®íË®îË®ïË®ûË®†Ë®¢Ë®§Ë®¶Ë®´Ë®¨Ë®ØË®µË®∑Ë®ΩË®æË©ÄË©ÉË©ÖË©áË©âË©çË©éË©ìË©ñË©óË©òË©úË©ùË©°Ë©•Ë©ßË©µË©∂Ë©∑Ë©πË©∫Ë©ªË©æË©øË™ÄË™ÉË™ÜË™ãË™èË™êË™íË™ñË™óË™ôË™üË™ßË™©Ë™ÆË™ØË™≥"],["8fdea1","Ë™∂Ë™∑Ë™ªË™æË´ÉË´ÜË´àË´âË´äË´ëË´ìË´îË´ïË´óË´ùË´üË´¨Ë´∞Ë´¥Ë´µË´∂Ë´ºË´øË¨ÖË¨ÜË¨ãË¨ëË¨úË¨ûË¨üË¨äË¨≠Ë¨∞Ë¨∑Ë¨ºË≠Ç",4,"Ë≠àË≠íË≠ìË≠îË≠ôË≠çË≠ûË≠£Ë≠≠Ë≠∂Ë≠∏Ë≠πË≠ºË≠æËÆÅËÆÑËÆÖËÆãËÆçËÆèËÆîËÆïËÆúËÆûËÆüË∞∏Ë∞πË∞ΩË∞æË±ÖË±áË±âË±ãË±èË±ëË±ìË±îË±óË±òË±õË±ùË±ôË±£Ë±§Ë±¶Ë±®Ë±©Ë±≠Ë±≥Ë±µË±∂Ë±ªË±æË≤Ü"],["8fdfa1","Ë≤áË≤ãË≤êË≤íË≤ìË≤ôË≤õË≤úË≤§Ë≤πË≤∫Ë≥ÖË≥ÜË≥âË≥ãË≥èË≥ñË≥ïË≥ôË≥ùË≥°Ë≥®Ë≥¨Ë≥ØË≥∞Ë≥≤Ë≥µË≥∑Ë≥∏Ë≥æË≥øË¥ÅË¥ÉË¥âË¥íË¥óË¥õËµ•Ëµ©Ëµ¨ËµÆËµøË∂ÇË∂ÑË∂àË∂çË∂êË∂ëË∂ïË∂ûË∂üË∂†Ë∂¶Ë∂´Ë∂¨Ë∂ØË∂≤Ë∂µË∂∑Ë∂πË∂ªË∑ÄË∑ÖË∑ÜË∑áË∑àË∑äË∑éË∑ëË∑îË∑ïË∑óË∑ôË∑§Ë∑•Ë∑ßË∑¨Ë∑∞Ë∂ºË∑±Ë∑≤Ë∑¥Ë∑ΩË∏ÅË∏ÑË∏ÖË∏ÜË∏ãË∏ëË∏îË∏ñË∏†Ë∏°Ë∏¢"],["8fe0a1","Ë∏£Ë∏¶Ë∏ßË∏±Ë∏≥Ë∏∂Ë∏∑Ë∏∏Ë∏πË∏ΩËπÄËπÅËπãËπçËπéËπèËπîËπõËπúËπùËπûËπ°Ëπ¢Ëπ©Ëπ¨Ëπ≠ËπØËπ∞Ëπ±ËππËπ∫ËπªË∫ÇË∫ÉË∫âË∫êË∫íË∫ïË∫öË∫õË∫ùË∫ûË∫¢Ë∫ßË∫©Ë∫≠Ë∫ÆË∫≥Ë∫µË∫∫Ë∫ªËªÄËªÅËªÉËªÑËªáËªèËªëËªîËªúËª®ËªÆËª∞Ëª±Ëª∑ËªπËª∫Ëª≠ËºÄËºÇËºáËºàËºèËºêËºñËºóËºòËºûËº†Ëº°Ëº£Ëº•ËºßËº®Ëº¨Ëº≠ËºÆËº¥ËºµËº∂Ëº∑Ëº∫ËΩÄËΩÅ"],["8fe1a1","ËΩÉËΩáËΩèËΩë",4,"ËΩòËΩùËΩûËΩ•ËæùËæ†Ëæ°Ëæ§Ëæ•Ëæ¶ËæµËæ∂Ëæ∏ËææËøÄËøÅËøÜËøäËøãËøçËøêËøíËøìËøïËø†Ëø£Ëø§Ëø®ËøÆËø±ËøµËø∂ËøªËøæÈÄÇÈÄÑÈÄàÈÄåÈÄòÈÄõÈÄ®ÈÄ©ÈÄØÈÄ™ÈÄ¨ÈÄ≠ÈÄ≥ÈÄ¥ÈÄ∑ÈÄøÈÅÉÈÅÑÈÅåÈÅõÈÅùÈÅ¢ÈÅ¶ÈÅßÈÅ¨ÈÅ∞ÈÅ¥ÈÅπÈÇÖÈÇàÈÇãÈÇåÈÇéÈÇêÈÇïÈÇóÈÇòÈÇôÈÇõÈÇ†ÈÇ°ÈÇ¢ÈÇ•ÈÇ∞ÈÇ≤ÈÇ≥ÈÇ¥ÈÇ∂ÈÇΩÈÉåÈÇæÈÉÉ"],["8fe2a1","ÈÉÑÈÉÖÈÉáÈÉàÈÉïÈÉóÈÉòÈÉôÈÉúÈÉùÈÉüÈÉ•ÈÉíÈÉ∂ÈÉ´ÈÉØÈÉ∞ÈÉ¥ÈÉæÈÉøÈÑÄÈÑÑÈÑÖÈÑÜÈÑàÈÑçÈÑêÈÑîÈÑñÈÑóÈÑòÈÑöÈÑúÈÑûÈÑ†ÈÑ•ÈÑ¢ÈÑ£ÈÑßÈÑ©ÈÑÆÈÑØÈÑ±ÈÑ¥ÈÑ∂ÈÑ∑ÈÑπÈÑ∫ÈÑºÈÑΩÈÖÉÈÖáÈÖàÈÖèÈÖìÈÖóÈÖôÈÖöÈÖõÈÖ°ÈÖ§ÈÖßÈÖ≠ÈÖ¥ÈÖπÈÖ∫ÈÖªÈÜÅÈÜÉÈÜÖÈÜÜÈÜäÈÜéÈÜëÈÜìÈÜîÈÜïÈÜòÈÜûÈÜ°ÈÜ¶ÈÜ®ÈÜ¨ÈÜ≠ÈÜÆÈÜ∞ÈÜ±ÈÜ≤ÈÜ≥ÈÜ∂ÈÜªÈÜºÈÜΩÈÜø"],["8fe3a1","ÈáÇÈáÉÈáÖÈáìÈáîÈáóÈáôÈáöÈáûÈá§Èá•Èá©Èá™Èá¨",5,"Èá∑ÈáπÈáªÈáΩÈàÄÈàÅÈàÑÈàÖÈàÜÈàáÈàâÈàäÈàåÈàêÈàíÈàìÈàñÈàòÈàúÈàùÈà£Èà§Èà•Èà¶Èà®ÈàÆÈàØÈà∞Èà≥ÈàµÈà∂Èà∏ÈàπÈà∫ÈàºÈàæÈâÄÈâÇÈâÉÈâÜÈâáÈâäÈâçÈâéÈâèÈâëÈâòÈâôÈâúÈâùÈâ†Èâ°Èâ•ÈâßÈâ®Èâ©ÈâÆÈâØÈâ∞Èâµ",4,"ÈâªÈâºÈâΩÈâøÈäàÈäâÈääÈäçÈäéÈäíÈäó"],["8fe4a1","ÈäôÈäüÈä†Èä§Èä•ÈäßÈä®Èä´ÈäØÈä≤Èä∂Èä∏Èä∫ÈäªÈäºÈäΩÈäø",4,"ÈãÖÈãÜÈãáÈãàÈããÈãåÈãçÈãéÈãêÈãìÈãïÈãóÈãòÈãôÈãúÈãùÈãüÈã†Èã°Èã£Èã•ÈãßÈã®Èã¨ÈãÆÈã∞ÈãπÈãªÈãøÈåÄÈåÇÈåàÈåçÈåëÈåîÈåïÈåúÈåùÈåûÈåüÈå°Èå§Èå•ÈåßÈå©Èå™Èå≥Èå¥Èå∂Èå∑ÈçáÈçàÈçâÈçêÈçëÈçíÈçïÈçóÈçòÈçöÈçûÈç§Èç•ÈçßÈç©Èç™Èç≠ÈçØÈç∞Èç±Èç≥Èç¥Èç∂"],["8fe5a1","Èç∫ÈçΩÈçøÈéÄÈéÅÈéÇÈéàÈéäÈéãÈéçÈéèÈéíÈéïÈéòÈéõÈéûÈé°Èé£Èé§Èé¶Èé®Èé´Èé¥ÈéµÈé∂Èé∫Èé©ÈèÅÈèÑÈèÖÈèÜÈèáÈèâ",4,"ÈèìÈèôÈèúÈèûÈèüÈè¢Èè¶ÈèßÈèπÈè∑Èè∏Èè∫ÈèªÈèΩÈêÅÈêÇÈêÑÈêàÈêâÈêçÈêéÈêèÈêïÈêñÈêóÈêüÈêÆÈêØÈê±Èê≤Èê≥Èê¥ÈêªÈêøÈêΩÈëÉÈëÖÈëàÈëäÈëåÈëïÈëôÈëúÈëüÈë°Èë£Èë®Èë´Èë≠ÈëÆÈëØÈë±Èë≤ÈíÑÈíÉÈï∏Èïπ"],["8fe6a1","ÈïæÈñÑÈñàÈñåÈñçÈñéÈñùÈñûÈñüÈñ°Èñ¶Èñ©Èñ´Èñ¨Èñ¥Èñ∂Èñ∫ÈñΩÈñøÈóÜÈóàÈóâÈóãÈóêÈóëÈóíÈóìÈóôÈóöÈóùÈóûÈóüÈó†Èó§Èó¶ÈòùÈòûÈò¢Èò§Èò•Èò¶Èò¨Èò±Èò≥Èò∑Èò∏ÈòπÈò∫ÈòºÈòΩÈôÅÈôíÈôîÈôñÈôóÈôòÈô°ÈôÆÈô¥ÈôªÈôºÈôæÈôøÈöÅÈöÇÈöÉÈöÑÈöâÈöëÈöñÈööÈöùÈöüÈö§Èö•Èö¶Èö©ÈöÆÈöØÈö≥Èö∫ÈõäÈõíÂ∂≤ÈõòÈõöÈõùÈõûÈõüÈõ©ÈõØÈõ±Èõ∫ÈúÇ"],["8fe7a1","ÈúÉÈúÖÈúâÈúöÈúõÈúùÈú°Èú¢Èú£Èú®Èú±Èú≥ÈùÅÈùÉÈùäÈùéÈùèÈùïÈùóÈùòÈùöÈùõÈù£ÈùßÈù™ÈùÆÈù≥Èù∂Èù∑Èù∏ÈùªÈùΩÈùøÈûÄÈûâÈûïÈûñÈûóÈûôÈûöÈûûÈûüÈû¢Èû¨ÈûÆÈû±Èû≤ÈûµÈû∂Èû∏ÈûπÈû∫ÈûºÈûæÈûøÈüÅÈüÑÈüÖÈüáÈüâÈüäÈüåÈüçÈüéÈüêÈüëÈüîÈüóÈüòÈüôÈüùÈüûÈü†ÈüõÈü°Èü§ÈüØÈü±Èü¥Èü∑Èü∏Èü∫È†áÈ†äÈ†ôÈ†çÈ†éÈ†îÈ†ñÈ†úÈ†ûÈ††È†£È†¶"],["8fe8a1","È†´È†ÆÈ†ØÈ†∞È†≤È†≥È†µÈ†•È†æÈ°ÑÈ°áÈ°äÈ°ëÈ°íÈ°ìÈ°ñÈ°óÈ°ôÈ°öÈ°¢È°£È°•È°¶È°™È°¨È¢´È¢≠È¢ÆÈ¢∞È¢¥È¢∑È¢∏È¢∫È¢ªÈ¢øÈ£ÇÈ£ÖÈ£àÈ£åÈ£°È££È£•È£¶È£ßÈ£™È£≥È£∂È§ÇÈ§áÈ§àÈ§ëÈ§ïÈ§ñÈ§óÈ§öÈ§õÈ§úÈ§üÈ§¢È§¶È§ßÈ§´È§±",4,"È§πÈ§∫È§ªÈ§ºÈ•ÄÈ•ÅÈ•ÜÈ•áÈ•àÈ•çÈ•éÈ•îÈ•òÈ•ôÈ•õÈ•úÈ•ûÈ•üÈ•†È¶õÈ¶ùÈ¶üÈ¶¶È¶∞È¶±È¶≤È¶µ"],["8fe9a1","È¶πÈ¶∫È¶ΩÈ¶øÈßÉÈßâÈßìÈßîÈßôÈßöÈßúÈßûÈßßÈß™Èß´Èß¨Èß∞Èß¥ÈßµÈßπÈßΩÈßæÈ®ÇÈ®ÉÈ®ÑÈ®ãÈ®åÈ®êÈ®ëÈ®ñÈ®ûÈ®†È®¢È®£È®§È®ßÈ®≠È®ÆÈ®≥È®µÈ®∂È®∏È©áÈ©ÅÈ©ÑÈ©äÈ©ãÈ©åÈ©éÈ©ëÈ©îÈ©ñÈ©ùÈ™™È™¨È™ÆÈ™ØÈ™≤È™¥È™µÈ™∂È™πÈ™ªÈ™æÈ™øÈ´ÅÈ´ÉÈ´ÜÈ´àÈ´éÈ´êÈ´íÈ´ïÈ´ñÈ´óÈ´õÈ´úÈ´†È´§È´•È´ßÈ´©È´¨È´≤È´≥È´µÈ´πÈ´∫È´ΩÈ´ø",4],["8feaa1","È¨ÑÈ¨ÖÈ¨àÈ¨âÈ¨ãÈ¨åÈ¨çÈ¨éÈ¨êÈ¨íÈ¨ñÈ¨ôÈ¨õÈ¨úÈ¨†È¨¶È¨´È¨≠È¨≥È¨¥È¨µÈ¨∑È¨πÈ¨∫È¨ΩÈ≠àÈ≠ãÈ≠åÈ≠ïÈ≠ñÈ≠óÈ≠õÈ≠ûÈ≠°È≠£È≠•È≠¶È≠®È≠™",4,"È≠≥È≠µÈ≠∑È≠∏È≠πÈ≠øÈÆÄÈÆÑÈÆÖÈÆÜÈÆáÈÆâÈÆäÈÆãÈÆçÈÆèÈÆêÈÆîÈÆöÈÆùÈÆûÈÆ¶ÈÆßÈÆ©ÈÆ¨ÈÆ∞ÈÆ±ÈÆ≤ÈÆ∑ÈÆ∏ÈÆªÈÆºÈÆæÈÆøÈØÅÈØáÈØàÈØéÈØêÈØóÈØòÈØùÈØüÈØ•ÈØßÈØ™ÈØ´ÈØØÈØ≥ÈØ∑ÈØ∏"],["8feba1","ÈØπÈØ∫ÈØΩÈØøÈ∞ÄÈ∞ÇÈ∞ãÈ∞èÈ∞ëÈ∞ñÈ∞òÈ∞ôÈ∞öÈ∞úÈ∞ûÈ∞¢È∞£È∞¶",4,"È∞±È∞µÈ∞∂È∞∑È∞ΩÈ±ÅÈ±ÉÈ±ÑÈ±ÖÈ±âÈ±äÈ±éÈ±èÈ±êÈ±ìÈ±îÈ±ñÈ±òÈ±õÈ±ùÈ±ûÈ±üÈ±£È±©È±™È±úÈ±´È±®È±ÆÈ±∞È±≤È±µÈ±∑È±ªÈ≥¶È≥≤È≥∑È≥πÈ¥ãÈ¥ÇÈ¥ëÈ¥óÈ¥òÈ¥úÈ¥ùÈ¥ûÈ¥ØÈ¥∞È¥≤È¥≥È¥¥È¥∫È¥ºÈµÖÈ¥ΩÈµÇÈµÉÈµáÈµäÈµìÈµîÈµüÈµ£Èµ¢Èµ•Èµ©Èµ™Èµ´Èµ∞Èµ∂Èµ∑Èµª"],["8feca1","ÈµºÈµæÈ∂ÉÈ∂ÑÈ∂ÜÈ∂äÈ∂çÈ∂éÈ∂íÈ∂ìÈ∂ïÈ∂ñÈ∂óÈ∂òÈ∂°È∂™È∂¨È∂ÆÈ∂±È∂µÈ∂πÈ∂ºÈ∂øÈ∑ÉÈ∑áÈ∑âÈ∑äÈ∑îÈ∑ïÈ∑ñÈ∑óÈ∑öÈ∑ûÈ∑üÈ∑†È∑•È∑ßÈ∑©È∑´È∑ÆÈ∑∞È∑≥È∑¥È∑æÈ∏äÈ∏ÇÈ∏áÈ∏éÈ∏êÈ∏ëÈ∏íÈ∏ïÈ∏ñÈ∏ôÈ∏úÈ∏ùÈπ∫ÈπªÈπºÈ∫ÄÈ∫ÇÈ∫ÉÈ∫ÑÈ∫ÖÈ∫áÈ∫éÈ∫èÈ∫ñÈ∫òÈ∫õÈ∫ûÈ∫§È∫®È∫¨È∫ÆÈ∫ØÈ∫∞È∫≥È∫¥È∫µÈªÜÈªàÈªãÈªïÈªüÈª§ÈªßÈª¨Èª≠ÈªÆÈª∞Èª±Èª≤Èªµ"],["8feda1","Èª∏ÈªøÈºÇÈºÉÈºâÈºèÈºêÈºëÈºíÈºîÈºñÈºóÈºôÈºöÈºõÈºüÈº¢Èº¶Èº™Èº´ÈºØÈº±Èº≤Èº¥Èº∑ÈºπÈº∫ÈººÈºΩÈºøÈΩÅÈΩÉ",4,"ÈΩìÈΩïÈΩñÈΩóÈΩòÈΩöÈΩùÈΩûÈΩ®ÈΩ©ÈΩ≠",4,"ÈΩ≥ÈΩµÈΩ∫ÈΩΩÈæèÈæêÈæëÈæíÈæîÈæñÈæóÈæûÈæ°Èæ¢Èæ£Èæ•"]]');

/***/ }),

/***/ 96953:
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('{"uChars":[128,165,169,178,184,216,226,235,238,244,248,251,253,258,276,284,300,325,329,334,364,463,465,467,469,471,473,475,477,506,594,610,712,716,730,930,938,962,970,1026,1104,1106,8209,8215,8218,8222,8231,8241,8244,8246,8252,8365,8452,8454,8458,8471,8482,8556,8570,8596,8602,8713,8720,8722,8726,8731,8737,8740,8742,8748,8751,8760,8766,8777,8781,8787,8802,8808,8816,8854,8858,8870,8896,8979,9322,9372,9548,9588,9616,9622,9634,9652,9662,9672,9676,9680,9702,9735,9738,9793,9795,11906,11909,11913,11917,11928,11944,11947,11951,11956,11960,11964,11979,12284,12292,12312,12319,12330,12351,12436,12447,12535,12543,12586,12842,12850,12964,13200,13215,13218,13253,13263,13267,13270,13384,13428,13727,13839,13851,14617,14703,14801,14816,14964,15183,15471,15585,16471,16736,17208,17325,17330,17374,17623,17997,18018,18212,18218,18301,18318,18760,18811,18814,18820,18823,18844,18848,18872,19576,19620,19738,19887,40870,59244,59336,59367,59413,59417,59423,59431,59437,59443,59452,59460,59478,59493,63789,63866,63894,63976,63986,64016,64018,64021,64025,64034,64037,64042,65074,65093,65107,65112,65127,65132,65375,65510,65536],"gbChars":[0,36,38,45,50,81,89,95,96,100,103,104,105,109,126,133,148,172,175,179,208,306,307,308,309,310,311,312,313,341,428,443,544,545,558,741,742,749,750,805,819,820,7922,7924,7925,7927,7934,7943,7944,7945,7950,8062,8148,8149,8152,8164,8174,8236,8240,8262,8264,8374,8380,8381,8384,8388,8390,8392,8393,8394,8396,8401,8406,8416,8419,8424,8437,8439,8445,8482,8485,8496,8521,8603,8936,8946,9046,9050,9063,9066,9076,9092,9100,9108,9111,9113,9131,9162,9164,9218,9219,11329,11331,11334,11336,11346,11361,11363,11366,11370,11372,11375,11389,11682,11686,11687,11692,11694,11714,11716,11723,11725,11730,11736,11982,11989,12102,12336,12348,12350,12384,12393,12395,12397,12510,12553,12851,12962,12973,13738,13823,13919,13933,14080,14298,14585,14698,15583,15847,16318,16434,16438,16481,16729,17102,17122,17315,17320,17402,17418,17859,17909,17911,17915,17916,17936,17939,17961,18664,18703,18814,18962,19043,33469,33470,33471,33484,33485,33490,33497,33501,33505,33513,33520,33536,33550,37845,37921,37948,38029,38038,38064,38065,38066,38069,38075,38076,38078,39108,39109,39113,39114,39115,39116,39265,39394,189000]}');

/***/ }),

/***/ 7626:
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('[["a140","ÓìÜ",62],["a180","ÓîÖ",32],["a240","Óî¶",62],["a280","Óï•",32],["a2ab","Óù¶",5],["a2e3","‚Ç¨Óù≠"],["a2ef","ÓùÆÓùØ"],["a2fd","Óù∞Óù±"],["a340","ÓñÜ",62],["a380","ÓóÖ",31,"„ÄÄ"],["a440","Óó¶",62],["a480","Óò•",32],["a4f4","Óù≤",10],["a540","ÓôÜ",62],["a580","ÓöÖ",32],["a5f7","ÓùΩ",7],["a640","Óö¶",62],["a680","Óõ•",32],["a6b9","ÓûÖ",7],["a6d9","Óûç",6],["a6ec","ÓûîÓûï"],["a6f3","Óûñ"],["a6f6","Óûó",8],["a740","ÓúÜ",62],["a780","ÓùÖ",32],["a7c2","Óû†",14],["a7f2","ÓûØ",12],["a896","Óûº",10],["a8bc","·∏ø"],["a8bf","«π"],["a8c1","ÓüâÓüäÓüãÓüå"],["a8ea","Óüç",20],["a958","Óü¢"],["a95b","Óü£"],["a95d","Óü§Óü•Óü¶"],["a989","„Äæ‚ø∞",11],["a997","Óü¥",12],["a9f0","Ó†Å",14],["aaa1","ÓÄÄ",93],["aba1","ÓÅû",93],["aca1","ÓÇº",93],["ada1","ÓÑö",93],["aea1","ÓÖ∏",93],["afa1","Óáñ",93],["d7fa","Ó†ê",4],["f8a1","Óà¥",93],["f9a1","Óäí",93],["faa1","Óã∞",93],["fba1","Óçé",93],["fca1","Óé¨",93],["fda1","Óêä",93],["fe50","‚∫ÅÓ†ñÓ†óÓ†ò‚∫Ñ„ë≥„ëá‚∫à‚∫ãÓ†û„ñû„òö„òé‚∫å‚∫ó„•Æ„§òÓ†¶„ßè„ßü„©≥„ßêÓ†´Ó†¨„≠é„±Æ„≥†‚∫ßÓ†±Ó†≤‚∫™‰Åñ‰Öü‚∫Æ‰å∑‚∫≥‚∫∂‚∫∑Ó†ª‰é±‰é¨‚∫ª‰èù‰ìñ‰ô°‰ôåÓ°É"],["fe80","‰ú£‰ú©‰ùº‰ûç‚ªä‰•á‰•∫‰•Ω‰¶Ç‰¶É‰¶Ö‰¶Ü‰¶ü‰¶õ‰¶∑‰¶∂Ó°îÓ°ï‰≤£‰≤ü‰≤†‰≤°‰±∑‰≤¢‰¥ì",6,"‰∂ÆÓ°§Óë®",93],["8135f437","Óüá"]]');

/***/ }),

/***/ 49991:
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('[["0","\\u0000",128],["a1","ÔΩ°",62],["8140","„ÄÄ„ÄÅ„ÄÇÔºåÔºé„ÉªÔºöÔºõÔºüÔºÅ„Çõ„Çú¬¥ÔΩÄ¬®ÔºæÔø£Ôºø„ÉΩ„Éæ„Çù„Çû„ÄÉ‰ªù„ÄÖ„ÄÜ„Äá„Éº‚Äï‚ÄêÔºèÔººÔΩû‚à•ÔΩú‚Ä¶‚Ä•‚Äò‚Äô‚Äú‚ÄùÔºàÔºâ„Äî„ÄïÔºªÔºΩÔΩõÔΩù„Äà",9,"ÔºãÔºç¬±√ó"],["8180","√∑Ôºù‚â†ÔºúÔºû‚â¶‚âß‚àû‚à¥‚ôÇ‚ôÄ¬∞‚Ä≤‚Ä≥‚ÑÉÔø•ÔºÑÔø†Ôø°ÔºÖÔºÉÔºÜÔºäÔº†¬ß‚òÜ‚òÖ‚óã‚óè‚óé‚óá‚óÜ‚ñ°‚ñ†‚ñ≥‚ñ≤‚ñΩ‚ñº‚Äª„Äí‚Üí‚Üê‚Üë‚Üì„Äì"],["81b8","‚àà‚àã‚äÜ‚äá‚äÇ‚äÉ‚à™‚à©"],["81c8","‚àß‚à®Ôø¢‚áí‚áî‚àÄ‚àÉ"],["81da","‚à†‚ä•‚åí‚àÇ‚àá‚â°‚âí‚â™‚â´‚àö‚àΩ‚àù‚àµ‚à´‚à¨"],["81f0","‚Ñ´‚Ä∞‚ôØ‚ô≠‚ô™‚Ä†‚Ä°¬∂"],["81fc","‚óØ"],["824f","Ôºê",9],["8260","Ôº°",25],["8281","ÔΩÅ",25],["829f","„ÅÅ",82],["8340","„Ç°",62],["8380","„É†",22],["839f","Œë",16,"Œ£",6],["83bf","Œ±",16,"œÉ",6],["8440","–ê",5,"–Å–ñ",25],["8470","–∞",5,"—ë–∂",7],["8480","–æ",17],["849f","‚îÄ‚îÇ‚îå‚îê‚îò‚îî‚îú‚î¨‚î§‚î¥‚îº‚îÅ‚îÉ‚îè‚îì‚îõ‚îó‚î£‚î≥‚î´‚îª‚ïã‚î†‚îØ‚î®‚î∑‚îø‚îù‚î∞‚î•‚î∏‚ïÇ"],["8740","‚ë†",19,"‚Ö†",9],["875f","„çâ„åî„å¢„çç„åò„åß„åÉ„å∂„çë„çó„åç„å¶„å£„å´„çä„åª„éú„éù„éû„éé„éè„èÑ„é°"],["877e","„çª"],["8780","„Äù„Äü‚Ññ„èç‚Ñ°„ä§",4,"„à±„à≤„àπ„çæ„çΩ„çº‚âí‚â°‚à´‚àÆ‚àë‚àö‚ä•‚à†‚àü‚äø‚àµ‚à©‚à™"],["889f","‰∫úÂîñÂ®ÉÈòøÂìÄÊÑõÊå®Âß∂ÈÄ¢ËëµËåúÁ©êÊÇ™Êè°Ê∏•Êó≠Ëë¶Ëä¶ÈØµÊ¢ìÂúßÊñ°Êâ±ÂÆõÂßêËôªÈ£¥Áµ¢Á∂æÈÆéÊàñÁ≤üË¢∑ÂÆâÂ∫µÊåâÊöóÊ°àÈóáÈûçÊùè‰ª•‰ºä‰Ωç‰æùÂÅâÂõ≤Â§∑ÂßîÂ®ÅÂ∞âÊÉüÊÑèÊÖ∞ÊòìÊ§ÖÁÇ∫ÁïèÁï∞ÁßªÁ∂≠Á∑ØËÉÉËêéË°£Ë¨ÇÈÅïÈÅ∫Âåª‰∫ï‰∫•ÂüüËÇ≤ÈÉÅÁ£Ø‰∏ÄÂ£±Ê∫¢ÈÄ∏Á®≤Ëå®ËäãÈ∞ØÂÖÅÂç∞ÂíΩÂì°Âõ†ÂßªÂºïÈ£≤Ê∑´ËÉ§Ëî≠"],["8940","Èô¢Èô∞Èö†ÈüªÂêãÂè≥ÂÆáÁÉèÁæΩËøÇÈõ®ÂçØÈµúÁ™∫‰∏ëÁ¢ìËáºÊ∏¶ÂòòÂîÑÊ¨ùËîöÈ∞ªÂß•Âé©Êµ¶ÁìúÈñèÂôÇ‰∫ëÈÅãÈõ≤ËçèÈ§åÂè°Âñ∂Â¨∞ÂΩ±Êò†Êõ≥Ê†ÑÊ∞∏Ê≥≥Ê¥©ÁëõÁõàÁ©éÈ†¥Ëã±Ë°õË©†Èã≠Ê∂≤Áñ´ÁõäÈßÖÊÇ¶Ë¨ÅË∂äÈñ≤Ê¶éÂé≠ÂÜÜ"],["8980","ÂúíÂ†∞Â•ÑÂÆ¥Âª∂ÊÄ®Êé©Êè¥Ê≤øÊºîÁÇéÁÑîÁÖôÁáïÁåøÁ∏ÅËâ∂ËãëËñóÈÅ†ÈâõÈ¥õÂ°©ÊñºÊ±öÁî•ÂáπÂ§ÆÂ••ÂæÄÂøúÊäºÊó∫Ê®™Ê¨ßÊÆ¥ÁéãÁøÅË•ñÈ¥¨È¥éÈªÑÂ≤°Ê≤ñËçªÂÑÑÂ±ãÊÜ∂ËáÜÊ°∂Áâ°‰πô‰ø∫Âç∏ÊÅ©Ê∏©Á©èÈü≥‰∏ãÂåñ‰ªÆ‰Ωï‰ºΩ‰æ°‰Ω≥Âä†ÂèØÂòâÂ§èÂ´ÅÂÆ∂ÂØ°ÁßëÊöáÊûúÊû∂Ê≠åÊ≤≥ÁÅ´ÁèÇÁ¶çÁ¶æÁ®ºÁÆáËä±ËãõËåÑËç∑ËèØËèìËù¶Ë™≤Âò©Ë≤®Ëø¶ÈÅéÈúûËöä‰øÑÂ≥®ÊàëÁâôÁîªËá•ËäΩËõæË≥ÄÈõÖÈ§ìÈßï‰ªã‰ºöËß£ÂõûÂ°äÂ£äÂªªÂø´ÊÄ™ÊÇîÊÅ¢ÊáêÊàíÊãêÊîπ"],["8a40","È≠ÅÊô¶Ê¢∞Êµ∑ÁÅ∞ÁïåÁöÜÁµµËä•ËüπÈñãÈöéË≤ùÂá±ÂäæÂ§ñÂí≥ÂÆ≥Â¥ñÊÖ®Ê¶ÇÊ∂ØÁ¢çËìãË°óË©≤ÈéßÈ™∏Êµ¨È¶®ËõôÂû£ÊüøËõéÈàéÂäÉÂöáÂêÑÂªìÊã°ÊíπÊ†ºÊ†∏ÊÆªÁç≤Á¢∫Á©´Ë¶öËßíËµ´ËºÉÈÉ≠Èñ£ÈöîÈù©Â≠¶Â≤≥Ê•ΩÈ°çÈ°éÊéõÁ¨†Ê®´"],["8a80","Ê©øÊ¢∂È∞çÊΩüÂâ≤ÂñùÊÅ∞Êã¨Ê¥ªÊ∏áÊªëËëõË§êËΩÑ‰∏îÈ∞πÂè∂Ê§õÊ®∫ÈûÑÊ†™ÂÖúÁ´ÉËí≤ÈáúÈéåÂôõÈ¥®Ê†¢ËåÖËê±Á≤•ÂààËãÖÁì¶‰πæ‰æÉÂÜ†ÂØíÂàäÂãòÂãßÂ∑ªÂñöÂ†™Âß¶ÂÆåÂÆòÂØõÂπ≤ÂππÊÇ£ÊÑüÊÖ£ÊÜæÊèõÊï¢ÊüëÊ°ìÊ£∫Ê¨æÊ≠ìÊ±óÊº¢ÊæóÊΩÖÁí∞ÁîòÁõ£ÁúãÁ´øÁÆ°Á∞°Á∑©Áº∂Áø∞ËÇùËâ¶ËéûË¶≥Ë´åË≤´ÈÇÑÈëëÈñìÈñëÈñ¢Èô•ÈüìÈ§®Ëàò‰∏∏Âê´Â≤∏Â∑åÁé©ÁôåÁúºÂ≤©Áø´Ë¥ãÈõÅÈ†ëÈ°îÈ°ò‰ºÅ‰ºéÂç±ÂñúÂô®Âü∫Â•áÂ¨âÂØÑÂ≤êÂ∏åÂπæÂøåÊèÆÊú∫ÊóóÊó¢ÊúüÊ£ãÊ£Ñ"],["8b40","Ê©üÂ∏∞ÊØÖÊ∞óÊ±ΩÁïøÁ•àÂ≠£Á®ÄÁ¥ÄÂæΩË¶èË®òË≤¥Ëµ∑ËªåËºùÈ£¢È®éÈ¨º‰∫ÄÂÅΩÂÑÄÂ¶ìÂÆúÊàØÊäÄÊì¨Ê¨∫Áä†ÁñëÁ•áÁæ©ËüªË™ºË≠∞Êé¨ËèäÈû†ÂêâÂêÉÂñ´Ê°îÊ©òË©∞Á†ßÊùµÈªçÂç¥ÂÆ¢ËÑöËôêÈÄÜ‰∏ò‰πÖ‰ªá‰ºëÂèäÂê∏ÂÆÆÂºìÊÄ•Êïë"],["8b80","ÊúΩÊ±ÇÊ±≤Ê≥£ÁÅ∏ÁêÉÁ©∂Á™ÆÁ¨àÁ¥öÁ≥æÁµ¶ÊóßÁâõÂéªÂ±ÖÂ∑®ÊãíÊã†ÊåôÊ∏†ËôöË®±Ë∑ùÈã∏ÊºÅÁ¶¶È≠ö‰∫®‰∫´‰∫¨‰æõ‰æ†ÂÉëÂÖáÁ´∂ÂÖ±Âá∂ÂçîÂå°ÂçøÂè´Âñ¨Â¢ÉÂ≥°Âº∑ÂΩäÊÄØÊÅêÊÅ≠ÊåüÊïôÊ©ãÊ≥ÅÁãÇÁã≠ÁüØËÉ∏ËÑÖËààËïéÈÉ∑Èè°ÈüøÈ•óÈ©ö‰ª∞ÂáùÂ∞≠ÊöÅÊ•≠Â±ÄÊõ≤Ê•µÁéâÊ°êÁ≤ÅÂÉÖÂã§ÂùáÂ∑æÈå¶Êñ§Ê¨£Ê¨ΩÁê¥Á¶ÅÁ¶ΩÁ≠ãÁ∑äËäπËèåË°øË•üË¨πËøëÈáëÂêüÈäÄ‰πùÂÄ∂Âè•Âå∫ÁãóÁéñÁü©Ëã¶Ë∫ØÈßÜÈßàÈßíÂÖ∑ÊÑöËôûÂñ∞Á©∫ÂÅ∂ÂØìÈÅáÈöÖ‰∏≤Ê´õÈáßÂ±ëÂ±à"],["8c40","ÊéòÁ™üÊ≤ìÈù¥ËΩ°Á™™ÁÜäÈöàÁ≤ÇÊ†óÁπ∞Ê°ëÈç¨Âã≤ÂêõËñ´Ë®ìÁæ§ËªçÈÉ°Âç¶Ë¢àÁ•Å‰øÇÂÇæÂàëÂÖÑÂïìÂú≠Áè™ÂûãÂ•ëÂΩ¢ÂæÑÊÅµÊÖ∂ÊÖßÊÜ©Êé≤Êê∫Êï¨ÊôØÊ°ÇÊ∏ìÁï¶Á®ΩÁ≥ªÁµåÁ∂ôÁπãÁΩ´ËåéËçäËõçË®àË©£Ë≠¶ËªΩÈ†öÈ∂èËä∏ËøéÈØ®"],["8c80","ÂäáÊàüÊíÉÊøÄÈöôÊ°ÅÂÇëÊ¨†Ê±∫ÊΩîÁ©¥ÁµêË°ÄË®£Êúà‰ª∂ÂÄπÂÄ¶ÂÅ•ÂÖºÂà∏Ââ£ÂñßÂúèÂ†ÖÂ´åÂª∫ÊÜ≤Êá∏Êã≥Êç≤Ê§úÊ®©ÁâΩÁä¨ÁåÆÁ†îÁ°ØÁµπÁúåËÇ©Ë¶ãË¨ôË≥¢ËªíÈÅ£ÈçµÈô∫È°ïÈ®ìÈπ∏ÂÖÉÂéüÂé≥ÂπªÂº¶Ê∏õÊ∫êÁéÑÁèæÁµÉËà∑Ë®ÄË´∫Èôê‰πéÂÄãÂè§ÂëºÂõ∫ÂßëÂ≠§Â∑±Â∫´ÂºßÊà∏ÊïÖÊûØÊπñÁãêÁ≥äË¢¥ËÇ°ËÉ°Ëè∞ËôéË™áË∑®Èà∑ÈõáÈ°ßÈºì‰∫î‰∫í‰ºçÂçàÂëâÂêæÂ®ØÂæåÂæ°ÊÇüÊ¢ßÊ™éÁëöÁ¢ÅË™ûË™§Ë≠∑ÈÜê‰πûÈØâ‰∫§‰Ωº‰æØÂÄôÂÄñÂÖâÂÖ¨ÂäüÂäπÂãæÂéöÂè£Âêë"],["8d40","ÂêéÂñâÂùëÂû¢Â•ΩÂ≠îÂ≠ùÂÆèÂ∑•Â∑ßÂ∑∑Âπ∏Â∫ÉÂ∫öÂ∫∑ÂºòÊÅíÊÖåÊäóÊãòÊéßÊîªÊòÇÊôÉÊõ¥Êù≠Ê†°Ê¢óÊßãÊ±üÊ¥™Êµ©Ê∏ØÊ∫ùÁî≤ÁöáÁ°¨Á®øÁ≥†Á¥ÖÁ¥òÁµûÁ∂±ËÄïËÄÉËÇØËÇ±ËÖîËÜèËà™ËçíË°åË°°Ë¨õË≤¢Ë≥ºÈÉäÈÖµÈâ±Á†øÈãºÈñ§Èôç"],["8d80","È†ÖÈ¶ôÈ´òÈ¥ªÂâõÂä´Âè∑ÂêàÂ£ïÊã∑Êø†Ë±™ËΩüÈ∫πÂÖãÂàªÂëäÂõΩÁ©ÄÈÖ∑Èµ†ÈªíÁçÑÊºâËÖ∞ÁîëÂøΩÊÉöÈ™®ÁãõËæºÊ≠§È†É‰ªäÂõ∞Âù§Â¢æÂ©öÊÅ®ÊááÊòèÊòÜÊ†πÊ¢±Ê∑∑ÁóïÁ¥∫ËâÆÈ≠Ç‰∫õ‰ΩêÂèâÂîÜÂµØÂ∑¶Â∑ÆÊüªÊ≤ôÁë≥Á†ÇË©êÈéñË£üÂùêÂ∫ßÊå´ÂÇµÂÇ¨ÂÜçÊúÄÂìâÂ°ûÂ¶ªÂÆ∞ÂΩ©ÊâçÊé°Ê†ΩÊ≠≥Ê∏àÁÅΩÈááÁäÄÁ†ïÁ†¶Á•≠ÊñéÁ¥∞ËèúË£ÅËºâÈöõÂâ§Âú®ÊùêÁΩ™Ë≤°ÂÜ¥ÂùÇÈò™Â†∫Ê¶äËÇ¥Âí≤Â¥éÂüºÁ¢ïÈ∑∫‰ΩúÂâäÂíãÊêæÊò®ÊúîÊüµÁ™ÑÁ≠ñÁ¥¢ÈåØÊ°úÈÆ≠Á¨πÂåôÂÜäÂà∑"],["8e40","ÂØüÊã∂ÊíÆÊì¶Êú≠ÊÆ∫Ëñ©ÈõëÁöêÈØñÊçåÈåÜÈÆ´ÁöøÊôí‰∏âÂÇòÂèÇÂ±±ÊÉ®ÊííÊï£Ê°üÁá¶ÁèäÁî£ÁÆóÁ∫ÇËöïËÆÉË≥õÈÖ∏È§êÊñ¨Êö´ÊÆã‰ªï‰ªî‰º∫‰ΩøÂà∫Âè∏Âè≤Âó£ÂõõÂ£´ÂßãÂßâÂßøÂ≠êÂ±çÂ∏ÇÂ∏´ÂøóÊÄùÊåáÊîØÂ≠úÊñØÊñΩÊó®ÊûùÊ≠¢"],["8e80","Ê≠ªÊ∞èÁçÖÁ•âÁßÅÁ≥∏Á¥ôÁ¥´ËÇ¢ËÑÇËá≥Ë¶ñË©ûË©©Ë©¶Ë™åË´ÆË≥áË≥úÈõåÈ£ºÊ≠Ø‰∫ã‰ºº‰æçÂÖêÂ≠óÂØ∫ÊÖàÊåÅÊôÇÊ¨°ÊªãÊ≤ªÁàæÁíΩÁóîÁ£ÅÁ§∫ËÄåËÄ≥Ëá™ËíîËæûÊ±êÈπøÂºèË≠òÈ¥´Á´∫Ëª∏ÂÆçÈõ´‰∏ÉÂè±Âü∑Â§±Â´âÂÆ§ÊÇâÊπøÊºÜÁñæË≥™ÂÆüËîÄÁØ†ÂÅ≤Êü¥ËäùÂ±°ËïäÁ∏ûËàéÂÜôÂ∞ÑÊç®Ëµ¶ÊñúÁÖÆÁ§æÁ¥óËÄÖË¨ùËªäÈÅÆËõáÈÇ™ÂÄüÂã∫Â∞∫ÊùìÁÅºÁàµÈÖåÈáàÈå´Ëã•ÂØÇÂº±ÊÉπ‰∏ªÂèñÂÆàÊâãÊú±ÊÆäÁã©Áè†Á®ÆËÖ´Ë∂£ÈÖíÈ¶ñÂÑíÂèóÂë™ÂØøÊéàÊ®πÁ∂¨ÈúÄÂõöÂèéÂë®"],["8f40","ÂÆóÂ∞±Â∑û‰øÆÊÑÅÊãæÊ¥≤ÁßÄÁßãÁµÇÁπçÁøíËá≠ËàüËíêË°ÜË•≤ËÆêËπ¥ËºØÈÄ±ÈÖãÈÖ¨ÈõÜÈÜú‰ªÄ‰ΩèÂÖÖÂçÅÂæìÊàéÊüîÊ±ÅÊ∏ãÁç£Á∏¶ÈáçÈäÉÂèîÂ§ôÂÆøÊ∑ëÁ•ùÁ∏ÆÁ≤õÂ°æÁÜüÂá∫Ë°ìËø∞‰øäÂ≥ªÊò•Áû¨Á´£ËàúÈßøÂáÜÂæ™Êó¨Ê•ØÊÆâÊ∑≥"],["8f80","Ê∫ñÊΩ§ÁõæÁ¥îÂ∑°ÈÅµÈÜáÈ†ÜÂá¶ÂàùÊâÄÊöëÊõôÊ∏öÂ∫∂Á∑íÁΩ≤Êõ∏ËñØËó∑Ë´∏Âä©ÂèôÂ•≥Â∫èÂæêÊÅïÈã§Èô§ÂÇ∑ÂÑüÂãùÂå†ÂçáÂè¨Âì®ÂïÜÂî±ÂòóÂ•®Â¶æÂ®ºÂÆµÂ∞ÜÂ∞èÂ∞ëÂ∞öÂ∫ÑÂ∫äÂª†ÂΩ∞ÊâøÊäÑÊãõÊéåÊç∑ÊòáÊòåÊò≠Êô∂ÊùæÊ¢¢Ê®üÊ®µÊ≤ºÊ∂àÊ∏âÊπòÁÑºÁÑ¶ÁÖßÁóáÁúÅÁ°ùÁ§ÅÁ••Áß∞Á´†Á¨ëÁ≤ßÁ¥πËÇñËèñËíãËïâË°ùË£≥Ë®üË®ºË©îË©≥Ë±°Ë≥ûÈÜ§Èâ¶ÈçæÈêòÈöúÈûò‰∏ä‰∏à‰∏û‰πóÂÜóÂâ∞ÂüéÂ†¥Â£åÂ¨¢Â∏∏ÊÉÖÊìæÊù°ÊùñÊµÑÁä∂Áï≥Á©£Ëí∏Ë≠≤ÈÜ∏Èå†Âò±Âü¥È£æ"],["9040","Êã≠Ê§çÊÆñÁá≠ÁπîËÅ∑Ëâ≤Ëß¶È£üËùïËæ±Â∞ª‰º∏‰ø°‰æµÂîáÂ®†ÂØùÂØ©ÂøÉÊÖéÊåØÊñ∞ÊôãÊ£ÆÊ¶õÊµ∏Ê∑±Áî≥ÁñπÁúüÁ•ûÁß¶Á¥≥Ëá£ËäØËñ™Ë¶™Ë®∫Ë∫´ËæõÈÄ≤ÈáùÈúá‰∫∫‰ªÅÂàÉÂ°µÂ£¨Â∞ãÁîöÂ∞ΩËÖéË®äËøÖÈô£Èù≠Á¨•Ë´èÈ†àÈÖ¢Âõ≥Âé®"],["9080","ÈÄóÂêπÂûÇÂ∏•Êé®Ê∞¥ÁÇäÁù°Á≤ãÁø†Ë°∞ÈÅÇÈÖîÈåêÈåòÈöèÁëûÈ´ÑÂ¥áÂµ©Êï∞Êû¢Ë∂®ÈõõÊçÆÊùâÊ§ôËèÖÈ†óÈõÄË£æÊæÑÊë∫ÂØ∏‰∏ñÁÄ¨ÁïùÊòØÂáÑÂà∂Âã¢ÂßìÂæÅÊÄßÊàêÊîøÊï¥ÊòüÊô¥Ê£≤Ê†ñÊ≠£Ê∏ÖÁâ≤ÁîüÁõõÁ≤æËÅñÂ£∞Ë£ΩË•øË™†Ë™ìË´ãÈÄùÈÜíÈùíÈùôÊñâÁ®éËÑÜÈöªÂ∏≠ÊÉúÊàöÊñ•ÊòîÊûêÁü≥Á©çÁ±çÁ∏æËÑäË≤¨Ëµ§Ë∑°ËπüÁ¢©ÂàáÊãôÊé•ÊëÇÊäòË®≠Á™ÉÁØÄË™¨Èõ™Áµ∂ËàåËùâ‰ªôÂÖàÂçÉÂç†ÂÆ£Â∞ÇÂ∞ñÂ∑ùÊà¶ÊâáÊí∞Ê†ìÊ†¥Ê≥âÊµÖÊ¥óÊüìÊΩúÁÖéÁÖΩÊóãÁ©øÁÆ≠Á∑ö"],["9140","ÁπäÁæ®ËÖ∫ËàõËàπËñ¶Ë©ÆË≥éË∑µÈÅ∏ÈÅ∑Èä≠ÈäëÈñÉÈÆÆÂâçÂñÑÊº∏ÁÑ∂ÂÖ®Á¶ÖÁπïËÜ≥Á≥éÂôåÂ°ëÂ≤®Êé™ÊõæÊõΩÊ•öÁãôÁñèÁñéÁ§éÁ•ñÁßüÁ≤óÁ¥†ÁµÑËòáË®¥ÈòªÈÅ°Èº†ÂÉßÂâµÂèåÂè¢ÂÄâÂñ™Â£ÆÂ•èÁàΩÂÆãÂ±§ÂåùÊÉ£ÊÉ≥ÊçúÊéÉÊåøÊéª"],["9180","ÊìçÊó©ÊõπÂ∑£ÊßçÊßΩÊºïÁá•‰∫âÁó©Áõ∏Á™ìÁ≥üÁ∑èÁ∂úËÅ°ËçâËçòËë¨ËíºËóªË£ÖËµ∞ÈÄÅÈÅ≠ÈéóÈúúÈ®íÂÉèÂ¢óÊÜéËáìËîµË¥àÈÄ†‰øÉÂÅ¥ÂâáÂç≥ÊÅØÊçâÊùüÊ∏¨Ë∂≥ÈÄü‰øóÂ±ûË≥äÊóèÁ∂öÂçíË¢ñÂÖ∂ÊèÉÂ≠òÂ≠´Â∞äÊêçÊùëÈÅú‰ªñÂ§öÂ§™Ê±∞Ë©ëÂîæÂ†ïÂ¶•ÊÉ∞ÊâìÊüÅËàµÊ•ïÈôÄÈßÑÈ®®‰ΩìÂ†ÜÂØæËÄêÂ≤±Â∏ØÂæÖÊÄ†ÊÖãÊà¥ÊõøÊ≥∞ÊªûËÉéËÖøËãîË¢ãË≤∏ÈÄÄÈÄÆÈöäÈªõÈØõ‰ª£Âè∞Â§ßÁ¨¨ÈÜçÈ°åÈ∑πÊªùÁÄßÂçìÂïÑÂÆÖÊâòÊäûÊãìÊ≤¢ÊøØÁê¢Ë®óÈê∏ÊøÅË´æËå∏ÂáßËõ∏Âè™"],["9240","Âè©‰ΩÜÈÅîËæ∞Â•™ËÑ±Â∑ΩÁ´™ËæøÊ£öË∞∑Áã∏È±àÊ®ΩË™∞‰∏πÂçòÂòÜÂù¶ÊãÖÊé¢Êó¶Ê≠éÊ∑°ÊπõÁÇ≠Áü≠Á´ØÁÆ™Á∂ªËÄΩËÉÜËõãË™ïÈçõÂõ£Â£áÂºæÊñ≠ÊöñÊ™ÄÊÆµÁî∑Ë´áÂÄ§Áü•Âú∞ÂºõÊÅ•Êô∫Ê±†Áó¥Á®öÁΩÆËá¥ËúòÈÅÖÈ¶≥ÁØâÁïúÁ´πÁ≠ëËìÑ"],["9280","ÈÄêÁß©Á™íËå∂Â´°ÁùÄ‰∏≠‰ª≤ÂÆôÂø†ÊäΩÊòºÊü±Ê≥®Ëô´Ë°∑Ë®ªÈÖéÈã≥ÈßêÊ®óÁÄ¶Áå™ËãßËëóË≤Ø‰∏ÅÂÖÜÂáãÂñãÂØµÂ∏ñÂ∏≥Â∫ÅÂºîÂºµÂΩ´Âæ¥Êá≤ÊåëÊö¢ÊúùÊΩÆÁâíÁî∫Áú∫ËÅ¥ËÑπËÖ∏Ëù∂Ë™øË´úË∂ÖË∑≥ÈäöÈï∑È†ÇÈ≥•ÂãÖÊçóÁõ¥ÊúïÊ≤àÁèçË≥ÉÈéÆÈô≥Ê¥•Â¢úÊ§éÊßåËøΩÈéöÁóõÈÄöÂ°öÊ†ÇÊé¥Êßª‰ΩÉÊº¨ÊüòËæªËî¶Á∂¥ÈçîÊ§øÊΩ∞Âù™Â£∑Â¨¨Á¥¨Áà™ÂêäÈá£È∂¥‰∫≠‰ΩéÂÅúÂÅµÂâÉË≤ûÂëàÂ†§ÂÆöÂ∏ùÂ∫ïÂ∫≠Âª∑ÂºüÊÇåÊäµÊå∫ÊèêÊ¢ØÊ±ÄÁ¢áÁ¶éÁ®ãÁ∑†ËâáË®ÇË´¶ËπÑÈÄì"],["9340","ÈÇ∏ÈÑ≠ÈáòÈºéÊ≥•ÊëòÊì¢ÊïµÊª¥ÁöÑÁ¨õÈÅ©ÈèëÊ∫∫Âì≤ÂæπÊí§ËΩçËø≠ÈâÑÂÖ∏Â°´Â§©Â±ïÂ∫óÊ∑ªÁ∫èÁîúË≤ºËª¢È°õÁÇπ‰ºùÊÆøÊæ±Áî∞ÈõªÂÖéÂêêÂ†µÂ°óÂ¶¨Â±†ÂæíÊñóÊùúÊ∏°ÁôªËèüË≥≠ÈÄîÈÉΩÈççÁ†•Á†∫Âä™Â∫¶ÂúüÂ•¥ÊÄíÂÄíÂÖöÂÜ¨"],["9380","ÂáçÂàÄÂîêÂ°îÂ°òÂ•óÂÆïÂ≥∂Â∂ãÊÇºÊäïÊê≠Êù±Ê°ÉÊ¢ºÊ£üÁõóÊ∑òÊπØÊ∂õÁÅØÁáàÂΩìÁóòÁ•∑Á≠âÁ≠îÁ≠íÁ≥ñÁµ±Âà∞Ëë£Ëï©Ëó§Ë®éË¨ÑË±ÜË∏èÈÄÉÈÄèÈêôÈô∂È†≠È®∞ÈóòÂÉçÂãïÂêåÂ†ÇÂ∞éÊÜßÊíûÊ¥ûÁû≥Á´•ËÉ¥ËêÑÈÅìÈäÖÂ≥†È¥áÂåøÂæóÂæ≥Ê∂úÁâπÁù£Á¶øÁØ§ÊØíÁã¨Ë™≠Ê†ÉÊ©°Âá∏Á™ÅÊ§¥Â±äÈ≥∂Ëã´ÂØÖÈÖâÁÄûÂô∏Â±ØÊÉáÊï¶Ê≤åË±öÈÅÅÈ†ìÂëëÊõáÈàçÂ•àÈÇ£ÂÜÖ‰πçÂá™ËñôË¨éÁÅòÊç∫ÈçãÊ•¢È¶¥Á∏ÑÁï∑ÂçóÊ•†ËªüÈõ£Ê±ù‰∫åÂ∞ºÂºêËø©ÂåÇË≥ëËÇâËôπÂªøÊó•‰π≥ÂÖ•"],["9440","Â¶ÇÂ∞øÈüÆ‰ªªÂ¶äÂøçË™çÊø°Á¶∞Á•¢ÂØßËë±Áå´ÁÜ±Âπ¥ÂøµÊçªÊíöÁáÉÁ≤ò‰πÉÂªº‰πãÂüúÂö¢ÊÇ©ÊøÉÁ¥çËÉΩËÑ≥ËÜøËæ≤Ë¶óËö§Â∑¥ÊääÊí≠Ë¶áÊù∑Ê≥¢Ê¥æÁê∂Á†¥Â©ÜÁΩµËä≠È¶¨‰ø≥ÂªÉÊãùÊéíÊïóÊùØÁõÉÁâåËÉåËÇ∫Ëº©ÈÖçÂÄçÂüπÂ™íÊ¢Ö"],["9480","Ê•≥ÁÖ§ÁãΩË≤∑Â£≤Ë≥†Èô™ÈÄôËùøÁß§ÁüßËê©‰ºØÂâ•ÂçöÊãçÊüèÊ≥äÁôΩÁÆîÁ≤ïËà∂ËñÑËø´ÊõùÊº†ÁàÜÁ∏õËé´ÈßÅÈ∫¶ÂáΩÁÆ±Á°≤ÁÆ∏ËÇáÁ≠àÊ´®Âπ°ËÇåÁïëÁï†ÂÖ´Èâ¢Ê∫åÁô∫ÈÜóÈ´™‰ºêÁΩ∞ÊäúÁ≠èÈñ•È≥©Âô∫Â°ôËõ§Èöº‰º¥Âà§ÂçäÂèçÂèõÂ∏ÜÊê¨ÊñëÊùøÊ∞æÊ±éÁâàÁäØÁè≠ÁïîÁπÅËà¨Ëó©Ë≤©ÁØÑÈáÜÁÖ©È†íÈ£ØÊåΩÊô©Áï™Áõ§Á£êËïÉËõÆÂå™ÂçëÂê¶Â¶ÉÂ∫áÂΩºÊÇ≤ÊââÊâπÊä´ÊñêÊØîÊ≥åÁñ≤ÁöÆÁ¢ëÁßòÁ∑ãÁΩ∑ËÇ•Ë¢´Ë™πË≤ªÈÅøÈùûÈ£õÊ®ãÁ∞∏ÂÇôÂ∞æÂæÆÊûáÊØòÁêµÁúâÁæé"],["9540","ÈºªÊüäÁ®óÂåπÁñãÈ´≠ÂΩ¶ËÜùËè±ËÇòÂººÂøÖÁï¢Á≠ÜÈÄºÊ°ßÂß´Â™õÁ¥êÁôæË¨¨‰øµÂΩ™Ê®ôÊ∞∑ÊºÇÁì¢Á•®Ë°®Ë©ïË±πÂªüÊèèÁóÖÁßíËãóÈå®Èã≤ËíúËõ≠È∞≠ÂìÅÂΩ¨ÊñåÊµúÁÄïË≤ßË≥ìÈ†ªÊïèÁì∂‰∏ç‰ªòÂü†Â§´Â©¶ÂØåÂÜ®Â∏ÉÂ∫úÊÄñÊâ∂Êï∑"],["9580","ÊñßÊôÆÊµÆÁà∂Á¨¶ËÖêËÜöËäôË≠úË≤†Ë≥¶Ëµ¥ÈòúÈôÑ‰æÆÊí´Ê≠¶ËàûËë°Ëï™ÈÉ®Â∞ÅÊ•ìÈ¢®Ëë∫Ëïó‰ºèÂâØÂæ©ÂπÖÊúçÁ¶èËÖπË§áË¶ÜÊ∑µÂºóÊâïÊ≤∏‰ªèÁâ©ÈÆíÂàÜÂêªÂô¥Â¢≥ÊÜ§ÊâÆÁÑöÂ•ÆÁ≤âÁ≥ûÁ¥õÈõ∞ÊñáËÅû‰∏ô‰ΩµÂÖµÂ°ÄÂπ£Âπ≥ÂºäÊüÑ‰∏¶ËîΩÈñâÈôõÁ±≥È†ÅÂÉªÂ£ÅÁôñÁ¢ßÂà•Áû•ËîëÁÆÜÂÅèÂ§âÁâáÁØáÁ∑®Ëæ∫ËøîÈÅç‰æøÂãâÂ®©ÂºÅÈû≠‰øùËàóÈã™ÂúÉÊçïÊ≠©Áî´Ë£úËºîÁ©ÇÂãüÂ¢ìÊÖïÊàäÊöÆÊØçÁ∞øËè©ÂÄ£‰ø∏ÂåÖÂëÜÂ†±Â•âÂÆùÂ≥∞Â≥ØÂ¥©Â∫ñÊä±ÊçßÊîæÊñπÊúã"],["9640","Ê≥ïÊ≥°ÁÉπÁ†≤Á∏´ËÉûËä≥ËêåËì¨ËúÇË§íË®™Ë±äÈÇ¶ÈãíÈ£ΩÈ≥≥Èµ¨‰πè‰∫°ÂÇçÂâñÂùäÂ¶®Â∏ΩÂøòÂøôÊàøÊö¥ÊúõÊüêÊ£íÂÜíÁ¥°ËÇ™ËÜ®Ë¨ÄË≤åË≤øÈâæÈò≤Âê†È†¨ÂåóÂÉïÂçúÂ¢®Êí≤Êú¥ÁâßÁù¶Á©ÜÈá¶ÂãÉÊ≤°ÊÆÜÂ†ÄÂπåÂ•îÊú¨ÁøªÂá°ÁõÜ"],["9680","Êë©Á£®È≠îÈ∫ªÂüãÂ¶πÊòßÊûöÊØéÂì©ÊßôÂπïËÜúÊûïÈÆ™ÊüæÈ±íÊ°ù‰∫¶‰ø£ÂèàÊäπÊú´Ê≤´ËøÑ‰æ≠Áπ≠È∫ø‰∏áÊÖ¢Ê∫ÄÊº´ËîìÂë≥Êú™È≠ÖÂ∑≥ÁÆïÂ≤¨ÂØÜËúúÊπäËìëÁ®îËÑàÂ¶ôÁ≤çÊ∞ëÁú†ÂãôÂ§¢ÁÑ°ÁâüÁüõÈúßÈµ°Ê§ãÂ©øÂ®òÂÜ•ÂêçÂëΩÊòéÁõüËø∑ÈäòÈ≥¥Âß™ÁâùÊªÖÂÖçÊ£âÁ∂øÁ∑¨Èù¢È∫∫Êë∏Ê®°ËåÇÂ¶ÑÂ≠üÊØõÁåõÁõ≤Á∂≤ËÄóËíôÂÑ≤Êú®ÈªôÁõÆÊù¢ÂãøÈ§ÖÂ∞§ÊàªÁ±æË≤∞ÂïèÊÇ∂Á¥ãÈñÄÂåÅ‰πüÂÜ∂Â§úÁà∫ËÄ∂ÈáéÂº•Áü¢ÂéÑÂΩπÁ¥ÑËñ¨Ë®≥Ë∫çÈùñÊü≥ËñÆÈëìÊÑâÊÑàÊ≤πÁôí"],["9740","Ë´≠Ëº∏ÂîØ‰ΩëÂÑ™ÂãáÂèãÂÆ•ÂπΩÊÇ†ÊÜÇÊèñÊúâÊüöÊπßÊ∂åÁå∂Áå∑Áî±Á•êË£ïË™òÈÅäÈÇëÈÉµÈõÑËûçÂ§ï‰∫à‰Ωô‰∏éË™âËºøÈ†êÂÇ≠ÂπºÂ¶ñÂÆπÂ∫∏ÊèöÊè∫ÊìÅÊõúÊ•äÊßòÊ¥ãÊ∫∂ÁÜîÁî®Á™ØÁæäËÄÄËëâËìâË¶ÅË¨°Ë∏äÈÅ•ÈôΩÈ§äÊÖæÊäëÊ¨≤"],["9780","Ê≤ÉÊµ¥ÁøåÁøºÊ∑ÄÁæÖËû∫Ë£∏Êù•Ëé±È†ºÈõ∑Ê¥õÁµ°ËêΩÈÖ™‰π±ÂçµÂµêÊ¨ÑÊø´ËóçËò≠Ë¶ßÂà©ÂêèÂ±•ÊùéÊ¢®ÁêÜÁíÉÁó¢Ë£èË£°ÈáåÈõ¢Èô∏ÂæãÁéáÁ´ãËëéÊé†Áï•ÂäâÊµÅÊ∫úÁêâÁïôÁ°´Á≤íÈöÜÁ´úÈæç‰æ∂ÊÖÆÊóÖËôú‰∫Ü‰∫ÆÂÉö‰∏°ÂáåÂØÆÊñôÊ¢ÅÊ∂ºÁåüÁôÇÁû≠Á®úÁ≥ßËâØË´íÈÅºÈáèÈôµÈ†òÂäõÁ∑ëÂÄ´ÂéòÊûóÊ∑ãÁáêÁê≥Ëá®Ëº™Èö£È±óÈ∫üÁë†Â°ÅÊ∂ôÁ¥ØÈ°û‰ª§‰º∂‰æãÂÜ∑Âä±Â∂∫ÊÄúÁé≤Á§ºËãìÈà¥Èö∑Èõ∂ÈúäÈ∫óÈΩ¢Êö¶Ê≠¥ÂàóÂä£ÁÉàË£ÇÂªâÊÅãÊÜêÊº£ÁÖâÁ∞æÁ∑¥ËÅØ"],["9840","ËìÆÈÄ£Èå¨ÂëÇÈ≠ØÊ´ìÁÇâË≥ÇË∑ØÈú≤Âä¥Â©ÅÂªäÂºÑÊúóÊ•ºÊ¶îÊµ™ÊºèÁâ¢ÁãºÁØ≠ËÄÅËÅæËùãÈÉéÂÖ≠È∫ìÁ¶ÑËÇãÈå≤Ë´ñÂÄ≠ÂíåË©±Ê≠™Ë≥ÑËÑáÊÉëÊû†È∑≤‰∫ô‰∫òÈ∞êË©´ËóÅËï®Ê§ÄÊπæÁ¢óËÖï"],["989f","Âºå‰∏ê‰∏ï‰∏™‰∏±‰∏∂‰∏º‰∏ø‰πÇ‰πñ‰πò‰∫Ç‰∫ÖË±´‰∫äËàíÂºç‰∫é‰∫û‰∫ü‰∫†‰∫¢‰∫∞‰∫≥‰∫∂‰ªé‰ªç‰ªÑ‰ªÜ‰ªÇ‰ªó‰ªû‰ª≠‰ªü‰ª∑‰ºâ‰Ωö‰º∞‰Ωõ‰Ωù‰Ωó‰Ωá‰Ω∂‰æà‰æè‰æò‰Ωª‰Ω©‰Ω∞‰æë‰ΩØ‰æÜ‰æñÂÑò‰øî‰øü‰øé‰øò‰øõ‰øë‰øö‰øê‰ø§‰ø•ÂÄöÂÄ®ÂÄîÂÄ™ÂÄ•ÂÄÖ‰ºú‰ø∂ÂÄ°ÂÄ©ÂÄ¨‰øæ‰øØÂÄëÂÄÜÂÅÉÂÅáÊúÉÂÅïÂÅêÂÅàÂÅöÂÅñÂÅ¨ÂÅ∏ÂÇÄÂÇöÂÇÖÂÇ¥ÂÇ≤"],["9940","ÂÉâÂÉäÂÇ≥ÂÉÇÂÉñÂÉûÂÉ•ÂÉ≠ÂÉ£ÂÉÆÂÉπÂÉµÂÑâÂÑÅÂÑÇÂÑñÂÑïÂÑîÂÑöÂÑ°ÂÑ∫ÂÑ∑ÂÑºÂÑªÂÑøÂÖÄÂÖíÂÖåÂÖîÂÖ¢Á´∏ÂÖ©ÂÖ™ÂÖÆÂÜÄÂÜÇÂõòÂÜåÂÜâÂÜèÂÜëÂÜìÂÜïÂÜñÂÜ§ÂÜ¶ÂÜ¢ÂÜ©ÂÜ™ÂÜ´ÂÜ≥ÂÜ±ÂÜ≤ÂÜ∞ÂÜµÂÜΩÂáÖÂáâÂáõÂá†ËôïÂá©Âá≠"],["9980","Âá∞ÂáµÂáæÂàÑÂàãÂàîÂàéÂàßÂà™ÂàÆÂà≥ÂàπÂâèÂâÑÂâãÂâåÂâûÂâîÂâ™Ââ¥Ââ©Ââ≥ÂâøÂâΩÂäçÂäîÂäíÂâ±ÂäàÂäëËæ®ËæßÂä¨Âä≠ÂäºÂäµÂãÅÂãçÂãóÂãûÂã£Âã¶È£≠Âã†Âã≥ÂãµÂã∏ÂãπÂåÜÂåàÁî∏ÂåçÂåêÂåèÂåïÂåöÂå£ÂåØÂå±Âå≥Âå∏ÂçÄÂçÜÂçÖ‰∏óÂçâÂççÂáñÂçûÂç©ÂçÆÂ§òÂçªÂç∑ÂéÇÂéñÂé†Âé¶Âé•ÂéÆÂé∞Âé∂ÂèÉÁ∞íÈõôÂèüÊõºÁáÆÂèÆÂè®Âè≠Âè∫ÂêÅÂêΩÂëÄÂê¨Âê≠ÂêºÂêÆÂê∂Âê©ÂêùÂëéÂíèÂëµÂíéÂëüÂë±Âë∑Âë∞ÂííÂëªÂíÄÂë∂ÂíÑÂíêÂíÜÂìáÂí¢Âí∏Âí•Âí¨ÂìÑÂìàÂí®"],["9a40","Âí´ÂìÇÂí§ÂíæÂíºÂìòÂì•Âì¶ÂîèÂîîÂìΩÂìÆÂì≠Âì∫Âì¢ÂîπÂïÄÂï£ÂïåÂîÆÂïúÂïÖÂïñÂïóÂî∏Âî≥ÂïùÂñôÂñÄÂíØÂñäÂñüÂïªÂïæÂñòÂñûÂñÆÂïºÂñÉÂñ©ÂñáÂñ®ÂóöÂóÖÂóüÂóÑÂóúÂó§ÂóîÂòîÂó∑ÂòñÂóæÂóΩÂòõÂóπÂôéÂôêÁáüÂò¥Âò∂Âò≤Âò∏"],["9a80","Âô´Âô§ÂòØÂô¨Âô™ÂöÜÂöÄÂöäÂö†ÂöîÂöèÂö•ÂöÆÂö∂Âö¥ÂõÇÂöºÂõÅÂõÉÂõÄÂõàÂõéÂõëÂõìÂõóÂõÆÂõπÂúÄÂõøÂúÑÂúâÂúàÂúãÂúçÂúìÂúòÂúñÂóáÂúúÂú¶Âú∑Âú∏ÂùéÂúªÂùÄÂùèÂù©ÂüÄÂûàÂù°ÂùøÂûâÂûìÂû†Âû≥Âû§Âû™Âû∞ÂüÉÂüÜÂüîÂüíÂüìÂ†äÂüñÂü£Â†ãÂ†ôÂ†ùÂ°≤Â†°Â°¢Â°ãÂ°∞ÊØÄÂ°íÂ†ΩÂ°πÂ¢ÖÂ¢πÂ¢üÂ¢´Â¢∫Â£ûÂ¢ªÂ¢∏Â¢ÆÂ£ÖÂ£ìÂ£ëÂ£óÂ£ôÂ£òÂ£•Â£úÂ£§Â£üÂ£ØÂ£∫Â£πÂ£ªÂ£ºÂ£ΩÂ§ÇÂ§äÂ§êÂ§õÊ¢¶Â§•Â§¨Â§≠Â§≤Â§∏Â§æÁ´íÂ•ïÂ•êÂ•éÂ•öÂ•òÂ•¢Â•†Â•ßÂ•¨Â•©"],["9b40","Â•∏Â¶ÅÂ¶ù‰Ωû‰æ´Â¶£Â¶≤ÂßÜÂß®ÂßúÂ¶çÂßôÂßöÂ®•Â®üÂ®ëÂ®úÂ®âÂ®öÂ©ÄÂ©¨Â©âÂ®µÂ®∂Â©¢Â©™Â™öÂ™ºÂ™æÂ´ãÂ´ÇÂ™ΩÂ´£Â´óÂ´¶Â´©Â´ñÂ´∫Â´ªÂ¨åÂ¨ãÂ¨ñÂ¨≤Â´êÂ¨™Â¨∂Â¨æÂ≠ÉÂ≠ÖÂ≠ÄÂ≠ëÂ≠ïÂ≠öÂ≠õÂ≠•Â≠©Â≠∞Â≠≥Â≠µÂ≠∏ÊñàÂ≠∫ÂÆÄ"],["9b80","ÂÆÉÂÆ¶ÂÆ∏ÂØÉÂØáÂØâÂØîÂØêÂØ§ÂØ¶ÂØ¢ÂØûÂØ•ÂØ´ÂØ∞ÂØ∂ÂØ≥Â∞ÖÂ∞áÂ∞àÂ∞çÂ∞ìÂ∞†Â∞¢Â∞®Â∞∏Â∞πÂ±ÅÂ±ÜÂ±éÂ±ìÂ±êÂ±èÂ≠±Â±¨Â±Æ‰π¢Â±∂Â±πÂ≤åÂ≤ëÂ≤îÂ¶õÂ≤´Â≤ªÂ≤∂Â≤ºÂ≤∑Â≥ÖÂ≤æÂ≥áÂ≥ôÂ≥©Â≥ΩÂ≥∫Â≥≠Â∂åÂ≥™Â¥ãÂ¥ïÂ¥óÂµúÂ¥üÂ¥õÂ¥ëÂ¥îÂ¥¢Â¥öÂ¥ôÂ¥òÂµåÂµíÂµéÂµãÂµ¨Âµ≥Âµ∂Â∂áÂ∂ÑÂ∂ÇÂ∂¢Â∂ùÂ∂¨Â∂ÆÂ∂ΩÂ∂êÂ∂∑Â∂ºÂ∑âÂ∑çÂ∑ìÂ∑íÂ∑ñÂ∑õÂ∑´Â∑≤Â∑µÂ∏ãÂ∏öÂ∏ôÂ∏ëÂ∏õÂ∏∂Â∏∑ÂπÑÂπÉÂπÄÂπéÂπóÂπîÂπüÂπ¢Âπ§ÂπáÂπµÂπ∂Âπ∫È∫ºÂπøÂ∫†ÂªÅÂªÇÂªàÂªêÂªè"],["9c40","ÂªñÂª£ÂªùÂªöÂªõÂª¢Âª°Âª®Âª©Âª¨Âª±Âª≥Âª∞Âª¥Âª∏ÂªæÂºÉÂºâÂΩùÂΩúÂºãÂºëÂºñÂº©Âº≠Âº∏ÂΩÅÂΩàÂΩåÂΩéÂºØÂΩëÂΩñÂΩóÂΩôÂΩ°ÂΩ≠ÂΩ≥ÂΩ∑ÂæÉÂæÇÂΩøÂæäÂæàÂæëÂæáÂæûÂæôÂæòÂæ†Âæ®Âæ≠ÂæºÂøñÂøªÂø§Âø∏Âø±ÂøùÊÇ≥ÂøøÊÄ°ÊÅ†"],["9c80","ÊÄôÊÄêÊÄ©ÊÄéÊÄ±ÊÄõÊÄïÊÄ´ÊÄ¶ÊÄèÊÄ∫ÊÅöÊÅÅÊÅ™ÊÅ∑ÊÅüÊÅäÊÅÜÊÅçÊÅ£ÊÅÉÊÅ§ÊÅÇÊÅ¨ÊÅ´ÊÅôÊÇÅÊÇçÊÉßÊÇÉÊÇöÊÇÑÊÇõÊÇñÊÇóÊÇíÊÇßÊÇãÊÉ°ÊÇ∏ÊÉ†ÊÉìÊÇ¥Âø∞ÊÇΩÊÉÜÊÇµÊÉòÊÖçÊÑïÊÑÜÊÉ∂ÊÉ∑ÊÑÄÊÉ¥ÊÉ∫ÊÑÉÊÑ°ÊÉªÊÉ±ÊÑçÊÑéÊÖáÊÑæÊÑ®ÊÑßÊÖäÊÑøÊÑºÊÑ¨ÊÑ¥ÊÑΩÊÖÇÊÖÑÊÖ≥ÊÖ∑ÊÖòÊÖôÊÖöÊÖ´ÊÖ¥ÊÖØÊÖ•ÊÖ±ÊÖüÊÖùÊÖìÊÖµÊÜôÊÜñÊÜáÊÜ¨ÊÜîÊÜöÊÜäÊÜëÊÜ´ÊÜÆÊáåÊáäÊáâÊá∑ÊáàÊáÉÊáÜÊÜ∫ÊáãÁΩπÊáçÊá¶Êá£Êá∂Êá∫Êá¥ÊáøÊáΩÊáºÊáæÊàÄÊààÊàâÊàçÊàåÊàîÊàõ"],["9d40","ÊàûÊà°Êà™ÊàÆÊà∞Êà≤Êà≥ÊâÅÊâéÊâûÊâ£ÊâõÊâ†Êâ®ÊâºÊäÇÊäâÊâæÊäíÊäìÊäñÊãîÊäÉÊäîÊãóÊãëÊäªÊãèÊãøÊãÜÊìîÊãàÊãúÊãåÊãäÊãÇÊãáÊäõÊãâÊååÊãÆÊã±ÊåßÊåÇÊåàÊãØÊãµÊçêÊåæÊççÊêúÊçèÊéñÊééÊéÄÊé´Êç∂Êé£ÊéèÊéâÊéüÊéµÊç´"],["9d80","Êç©ÊéæÊè©ÊèÄÊèÜÊè£ÊèâÊèíÊè∂ÊèÑÊêñÊê¥ÊêÜÊêìÊê¶Êê∂ÊîùÊêóÊê®ÊêèÊëßÊëØÊë∂ÊëéÊî™ÊíïÊíìÊí•Êí©ÊíàÊíºÊìöÊìíÊìÖÊìáÊíªÊìòÊìÇÊì±ÊìßËàâÊì†Êì°Êä¨Êì£ÊìØÊî¨Êì∂Êì¥Êì≤Êì∫ÊîÄÊìΩÊîòÊîúÊîÖÊî§Êî£Êî´Êî¥ÊîµÊî∑Êî∂Êî∏ÁïãÊïàÊïñÊïïÊïçÊïòÊïûÊïùÊï≤Êï∏ÊñÇÊñÉËÆäÊñõÊñüÊñ´Êñ∑ÊóÉÊóÜÊóÅÊóÑÊóåÊóíÊóõÊóôÊó†Êó°Êó±Êù≤ÊòäÊòÉÊóªÊù≥ÊòµÊò∂Êò¥ÊòúÊôèÊôÑÊôâÊôÅÊôûÊôùÊô§ÊôßÊô®ÊôüÊô¢Êô∞ÊöÉÊöàÊöéÊöâÊöÑÊöòÊöùÊõÅÊöπÊõâÊöæÊöº"],["9e40","ÊõÑÊö∏ÊõñÊõöÊõ†ÊòøÊõ¶Êõ©Êõ∞ÊõµÊõ∑ÊúèÊúñÊúûÊú¶ÊúßÈú∏ÊúÆÊúøÊú∂ÊùÅÊú∏Êú∑ÊùÜÊùûÊù†ÊùôÊù£Êù§ÊûâÊù∞Êû©ÊùºÊù™ÊûåÊûãÊû¶Êû°ÊûÖÊû∑ÊüØÊû¥Êü¨Êû≥Êü©Êû∏Êü§ÊüûÊüùÊü¢ÊüÆÊûπÊüéÊüÜÊüßÊ™úÊ†ûÊ°ÜÊ†©Ê°ÄÊ°çÊ†≤Ê°é"],["9e80","Ê¢≥Ê†´Ê°ôÊ°£Ê°∑Ê°øÊ¢üÊ¢èÊ¢≠Ê¢îÊ¢ùÊ¢õÊ¢ÉÊ™ÆÊ¢πÊ°¥Ê¢µÊ¢†Ê¢∫Ê§èÊ¢çÊ°æÊ§ÅÊ£äÊ§àÊ£òÊ§¢Ê§¶Ê£°Ê§åÊ£çÊ£îÊ£ßÊ£ïÊ§∂Ê§íÊ§ÑÊ£óÊ££Ê§•Ê£πÊ£†Ê£ØÊ§®Ê§™Ê§öÊ§£Ê§°Ê£ÜÊ•πÊ•∑Ê•úÊ•∏Ê•´Ê•îÊ•æÊ•ÆÊ§πÊ•¥Ê§ΩÊ•ôÊ§∞Ê•°Ê•ûÊ•ùÊ¶ÅÊ•™Ê¶≤Ê¶ÆÊßêÊ¶øÊßÅÊßìÊ¶æÊßéÂØ®ÊßäÊßùÊ¶ªÊßÉÊ¶ßÊ®ÆÊ¶ëÊ¶†Ê¶úÊ¶ïÊ¶¥ÊßûÊß®Ê®ÇÊ®õÊßøÊ¨äÊßπÊß≤ÊßßÊ®ÖÊ¶±Ê®ûÊß≠Ê®îÊß´Ê®äÊ®íÊ´ÅÊ®£Ê®ìÊ©ÑÊ®åÊ©≤Ê®∂Ê©∏Ê©áÊ©¢Ê©ôÊ©¶Ê©àÊ®∏Ê®¢Ê™êÊ™çÊ™†Ê™ÑÊ™¢Ê™£"],["9f40","Ê™óËòóÊ™ªÊ´ÉÊ´ÇÊ™∏Ê™≥Ê™¨Ê´ûÊ´ëÊ´üÊ™™Ê´öÊ´™Ê´ªÊ¨ÖËòñÊ´∫Ê¨íÊ¨ñÈ¨±Ê¨üÊ¨∏Ê¨∑ÁõúÊ¨πÈ£ÆÊ≠áÊ≠ÉÊ≠âÊ≠êÊ≠ôÊ≠îÊ≠õÊ≠üÊ≠°Ê≠∏Ê≠πÊ≠øÊÆÄÊÆÑÊÆÉÊÆçÊÆòÊÆïÊÆûÊÆ§ÊÆ™ÊÆ´ÊÆØÊÆ≤ÊÆ±ÊÆ≥ÊÆ∑ÊÆºÊØÜÊØãÊØìÊØüÊØ¨ÊØ´ÊØ≥ÊØØ"],["9f80","È∫æÊ∞àÊ∞ìÊ∞îÊ∞õÊ∞§Ê∞£Ê±ûÊ±ïÊ±¢Ê±™Ê≤ÇÊ≤çÊ≤öÊ≤ÅÊ≤õÊ±æÊ±®Ê±≥Ê≤íÊ≤êÊ≥ÑÊ≥±Ê≥ìÊ≤ΩÊ≥óÊ≥ÖÊ≥ùÊ≤ÆÊ≤±Ê≤æÊ≤∫Ê≥õÊ≥ØÊ≥ôÊ≥™Ê¥üË°çÊ¥∂Ê¥´Ê¥ΩÊ¥∏Ê¥ôÊ¥µÊ¥≥Ê¥íÊ¥åÊµ£Ê∂ìÊµ§ÊµöÊµπÊµôÊ∂éÊ∂ïÊø§Ê∂ÖÊ∑πÊ∏ïÊ∏äÊ∂µÊ∑áÊ∑¶Ê∂∏Ê∑ÜÊ∑¨Ê∑ûÊ∑åÊ∑®Ê∑íÊ∑ÖÊ∑∫Ê∑ôÊ∑§Ê∑ïÊ∑™Ê∑ÆÊ∏≠ÊπÆÊ∏ÆÊ∏ôÊπ≤ÊπüÊ∏æÊ∏£Êπ´Ê∏´Êπ∂ÊπçÊ∏üÊπÉÊ∏∫ÊπéÊ∏§ÊªøÊ∏ùÊ∏∏Ê∫ÇÊ∫™Ê∫òÊªâÊ∫∑ÊªìÊ∫ΩÊ∫ØÊªÑÊ∫≤ÊªîÊªïÊ∫èÊ∫•ÊªÇÊ∫üÊΩÅÊºëÁÅåÊª¨Êª∏ÊªæÊºøÊª≤Êº±ÊªØÊº≤Êªå"],["e040","ÊºæÊºìÊª∑ÊæÜÊΩ∫ÊΩ∏ÊæÅÊæÄÊΩØÊΩõÊø≥ÊΩ≠ÊæÇÊΩºÊΩòÊæéÊæëÊøÇÊΩ¶Êæ≥Êæ£Êæ°Êæ§ÊæπÊøÜÊæ™ÊøüÊøïÊø¨ÊøîÊøòÊø±ÊøÆÊøõÁÄâÁÄãÊø∫ÁÄëÁÄÅÁÄèÊøæÁÄõÁÄöÊΩ¥ÁÄùÁÄòÁÄüÁÄ∞ÁÄæÁÄ≤ÁÅëÁÅ£ÁÇôÁÇíÁÇØÁÉ±ÁÇ¨ÁÇ∏ÁÇ≥ÁÇÆÁÉüÁÉãÁÉù"],["e080","ÁÉôÁÑâÁÉΩÁÑúÁÑôÁÖ•ÁÖïÁÜàÁÖ¶ÁÖ¢ÁÖåÁÖñÁÖ¨ÁÜèÁáªÁÜÑÁÜïÁÜ®ÁÜ¨ÁáóÁÜπÁÜæÁáíÁáâÁáîÁáéÁá†Áá¨ÁáßÁáµÁáºÁáπÁáøÁàçÁàêÁàõÁà®Áà≠Áà¨Áà∞Áà≤ÁàªÁàºÁàøÁâÄÁâÜÁâãÁâòÁâ¥ÁâæÁäÇÁäÅÁäáÁäíÁäñÁä¢ÁäßÁäπÁä≤ÁãÉÁãÜÁãÑÁãéÁãíÁã¢Áã†Áã°ÁãπÁã∑ÂÄèÁåóÁåäÁåúÁåñÁåùÁå¥ÁåØÁå©Áå•ÁåæÁçéÁçèÈªòÁçóÁç™Áç®Áç∞Áç∏ÁçµÁçªÁç∫ÁèàÁé≥ÁèéÁéªÁèÄÁè•ÁèÆÁèûÁí¢ÁêÖÁëØÁê•Áè∏Áê≤Áê∫ÁëïÁêøÁëüÁëôÁëÅÁëúÁë©Áë∞Áë£Áë™Áë∂ÁëæÁíãÁíûÁíßÁìäÁìèÁìîÁè±"],["e140","Áì†Áì£ÁìßÁì©ÁìÆÁì≤Áì∞Áì±Áì∏Áì∑ÁîÑÁîÉÁîÖÁîåÁîéÁîçÁîïÁîìÁîûÁî¶Áî¨ÁîºÁïÑÁïçÁïäÁïâÁïõÁïÜÁïöÁï©Áï§ÁïßÁï´Áï≠Áï∏Áï∂ÁñÜÁñáÁï¥ÁñäÁñâÁñÇÁñîÁñöÁñùÁñ•Áñ£ÁóÇÁñ≥ÁóÉÁñµÁñΩÁñ∏ÁñºÁñ±ÁóçÁóäÁóíÁóôÁó£ÁóûÁóæÁóø"],["e180","ÁóºÁòÅÁó∞Áó∫Áó≤Áó≥ÁòãÁòçÁòâÁòüÁòßÁò†Áò°Áò¢Áò§Áò¥Áò∞ÁòªÁôáÁôàÁôÜÁôúÁôòÁô°Áô¢Áô®Áô©Áô™ÁôßÁô¨Áô∞Áô≤Áô∂Áô∏ÁôºÁöÄÁöÉÁöàÁöãÁöéÁöñÁöìÁöôÁööÁö∞Áö¥Áö∏ÁöπÁö∫ÁõÇÁõçÁõñÁõíÁõûÁõ°Áõ•ÁõßÁõ™ËòØÁõªÁúàÁúáÁúÑÁú©Áú§ÁúûÁú•Áú¶ÁúõÁú∑Áú∏ÁùáÁùöÁù®Áù´ÁùõÁù•ÁùøÁùæÁùπÁûéÁûãÁûëÁû†ÁûûÁû∞Áû∂ÁûπÁûøÁûºÁûΩÁûªÁüáÁüçÁüóÁüöÁüúÁü£ÁüÆÁüºÁ†åÁ†íÁ§¶Á††Á§™Á°ÖÁ¢éÁ°¥Á¢ÜÁ°ºÁ¢öÁ¢åÁ¢£Á¢µÁ¢™Á¢ØÁ£ëÁ£ÜÁ£ãÁ£îÁ¢æÁ¢ºÁ£ÖÁ£äÁ£¨"],["e240","Á£ßÁ£öÁ£ΩÁ£¥Á§áÁ§íÁ§ëÁ§ôÁ§¨Á§´Á•ÄÁ•†Á•óÁ•üÁ•öÁ•ïÁ•ìÁ•∫Á•øÁ¶äÁ¶ùÁ¶ßÈΩãÁ¶™Á¶ÆÁ¶≥Á¶πÁ¶∫ÁßâÁßïÁßßÁß¨Áß°Áß£Á®àÁ®çÁ®òÁ®ôÁ®†Á®üÁ¶ÄÁ®±Á®ªÁ®æÁ®∑Á©ÉÁ©óÁ©âÁ©°Á©¢Á©©ÈæùÁ©∞Á©πÁ©ΩÁ™àÁ™óÁ™ïÁ™òÁ™ñÁ™©Á´àÁ™∞"],["e280","Á™∂Á´ÖÁ´ÑÁ™øÈÇÉÁ´áÁ´äÁ´çÁ´èÁ´ïÁ´ìÁ´ôÁ´öÁ´ùÁ´°Á´¢Á´¶Á´≠Á´∞Á¨ÇÁ¨èÁ¨äÁ¨ÜÁ¨≥Á¨òÁ¨ôÁ¨ûÁ¨µÁ¨®Á¨∂Á≠êÁ≠∫Á¨ÑÁ≠çÁ¨ãÁ≠åÁ≠ÖÁ≠µÁ≠•Á≠¥Á≠ßÁ≠∞Á≠±Á≠¨Á≠ÆÁÆùÁÆòÁÆüÁÆçÁÆúÁÆöÁÆãÁÆíÁÆèÁ≠ùÁÆôÁØãÁØÅÁØåÁØèÁÆ¥ÁØÜÁØùÁØ©Á∞ëÁ∞îÁØ¶ÁØ•Á±†Á∞ÄÁ∞áÁ∞ìÁØ≥ÁØ∑Á∞óÁ∞çÁØ∂Á∞£Á∞ßÁ∞™Á∞üÁ∞∑Á∞´Á∞ΩÁ±åÁ±ÉÁ±îÁ±èÁ±ÄÁ±êÁ±òÁ±üÁ±§Á±ñÁ±•Á±¨Á±µÁ≤ÉÁ≤êÁ≤§Á≤≠Á≤¢Á≤´Á≤°Á≤®Á≤≥Á≤≤Á≤±Á≤ÆÁ≤πÁ≤ΩÁ≥ÄÁ≥ÖÁ≥ÇÁ≥òÁ≥íÁ≥úÁ≥¢È¨ªÁ≥ØÁ≥≤Á≥¥Á≥∂Á≥∫Á¥Ü"],["e340","Á¥ÇÁ¥úÁ¥ïÁ¥äÁµÖÁµãÁ¥ÆÁ¥≤Á¥øÁ¥µÁµÜÁµ≥ÁµñÁµéÁµ≤Áµ®ÁµÆÁµèÁµ£Á∂ìÁ∂âÁµõÁ∂èÁµΩÁ∂õÁ∂∫Á∂ÆÁ∂£Á∂µÁ∑áÁ∂ΩÁ∂´Á∏ΩÁ∂¢Á∂ØÁ∑úÁ∂∏Á∂üÁ∂∞Á∑òÁ∑ùÁ∑§Á∑ûÁ∑ªÁ∑≤Á∑°Á∏ÖÁ∏äÁ∏£Á∏°Á∏íÁ∏±Á∏üÁ∏âÁ∏ãÁ∏¢ÁπÜÁπ¶Á∏ªÁ∏µÁ∏πÁπÉÁ∏∑"],["e380","Á∏≤Á∏∫ÁπßÁπùÁπñÁπûÁπôÁπöÁππÁπ™Áπ©ÁπºÁπªÁ∫ÉÁ∑ïÁπΩËæÆÁπøÁ∫àÁ∫âÁ∫åÁ∫íÁ∫êÁ∫ìÁ∫îÁ∫ñÁ∫éÁ∫õÁ∫úÁº∏Áº∫ÁΩÖÁΩåÁΩçÁΩéÁΩêÁΩëÁΩïÁΩîÁΩòÁΩüÁΩ†ÁΩ®ÁΩ©ÁΩßÁΩ∏ÁæÇÁæÜÁæÉÁæàÁæáÁæåÁæîÁæûÁæùÁæöÁæ£ÁæØÁæ≤ÁæπÁæÆÁæ∂Áæ∏Ë≠±ÁøÖÁøÜÁøäÁøïÁøîÁø°Áø¶Áø©Áø≥ÁøπÈ£úËÄÜËÄÑËÄãËÄíËÄòËÄôËÄúËÄ°ËÄ®ËÄøËÄªËÅäËÅÜËÅíËÅòËÅöËÅüËÅ¢ËÅ®ËÅ≥ËÅ≤ËÅ∞ËÅ∂ËÅπËÅΩËÅøËÇÑËÇÜËÇÖËÇõËÇìËÇöËÇ≠ÂÜêËÇ¨ËÉõËÉ•ËÉôËÉùËÉÑËÉöËÉñËÑâËÉØËÉ±ËÑõËÑ©ËÑ£ËÑØËÖã"],["e440","ÈöãËÖÜËÑæËÖìËÖëËÉºËÖ±ËÖÆËÖ•ËÖ¶ËÖ¥ËÜÉËÜàËÜäËÜÄËÜÇËÜ†ËÜïËÜ§ËÜ£ËÖüËÜìËÜ©ËÜ∞ËÜµËÜæËÜ∏ËÜΩËáÄËáÇËÜ∫ËáâËáçËáëËáôËáòËáàËáöËáüËá†ËáßËá∫ËáªËáæËàÅËàÇËàÖËàáËàäËàçËàêËàñËà©Ëà´Ëà∏Ëà≥ËâÄËâôËâòËâùËâöËâüËâ§"],["e480","Ëâ¢Ëâ®Ëâ™Ëâ´ËàÆËâ±Ëâ∑Ëâ∏ËâæËäçËäíËä´ËäüËäªËä¨Ëã°Ëã£ËãüËãíËã¥Ëã≥Ëã∫ËéìËåÉËãªËãπËãûËåÜËãúËåâËãôËåµËå¥ËåñËå≤Ëå±ËçÄËåπËçêËçÖËåØËå´ËåóËåòËéÖËéöËé™ËéüËé¢ËéñËå£ËééËéáËéäËçºËéµËç≥ËçµËé†ËéâËé®Ëè¥ËêìËè´ËèéËèΩËêÉËèòËêãËèÅËè∑ËêáËè†Ëè≤ËêçËê¢Ëê†ËéΩËê∏ËîÜËèªËë≠Ëê™ËêºËïöËíÑËë∑Ëë´Ëí≠ËëÆËíÇËë©ËëÜËê¨ËëØËëπËêµËìäËë¢ËíπËíøËíüËìôËìçËíªËìöËìêËìÅËìÜËìñËí°Ëî°ËìøËì¥ËîóËîòËî¨ËîüËîïËîîËìºËïÄËï£ËïòËïà"],["e540","ËïÅËòÇËïãËïïËñÄËñ§ËñàËñëËñäËñ®Ëï≠ËñîËñõËó™ËñáËñúËï∑ËïæËñêËóâËñ∫ËóèËñπËóêËóïËóùËó•ËóúËóπËòäËòìËòãËóæËó∫ËòÜËò¢ËòöËò∞ËòøËôç‰πïËôîËôüËôßËô±ËöìËö£Ëö©Ëö™ËöãËöåËö∂ËöØËõÑËõÜËö∞ËõâË†£Ëö´ËõîËõûËõ©Ëõ¨"],["e580","ËõüËõõËõØËúíËúÜËúàËúÄËúÉËõªËúëËúâËúçËõπËúäËú¥ËúøËú∑ËúªËú•Ëú©ËúöËù†ËùüËù∏ËùåËùéËù¥ËùóËù®ËùÆËùôËùìËù£Ëù™Ë†ÖËû¢ËûüËûÇËûØËüãËûΩËüÄËüêÈõñËû´ËüÑËû≥ËüáËüÜËûªËüØËü≤Ëü†Ë†èË†çËüæËü∂Ëü∑Ë†éËüíË†ëË†ñË†ïË†¢Ë†°Ë†±Ë†∂Ë†πË†ßË†ªË°ÑË°ÇË°íË°ôË°ûË°¢Ë°´Ë¢ÅË°æË¢ûË°µË°ΩË¢µË°≤Ë¢ÇË¢óË¢íË¢ÆË¢ôË¢¢Ë¢çË¢§Ë¢∞Ë¢øË¢±Ë£ÉË£ÑË£îË£òË£ôË£ùË£πË§ÇË£ºË£¥Ë£®Ë£≤Ë§ÑË§åË§äË§ìË•ÉË§ûË§•Ë§™Ë§´Ë•ÅË•ÑË§ªË§∂Ë§∏Ë•åË§ùË•†Ë•û"],["e640","Ë•¶Ë•§Ë•≠Ë•™Ë•ØË•¥Ë•∑Ë•æË¶ÉË¶àË¶äË¶ìË¶òË¶°Ë¶©Ë¶¶Ë¶¨Ë¶ØË¶≤Ë¶∫Ë¶ΩË¶øËßÄËßöËßúËßùËßßËß¥Ëß∏Ë®ÉË®ñË®êË®åË®õË®ùË®•Ë®∂Ë©ÅË©õË©íË©ÜË©àË©ºË©≠Ë©¨Ë©¢Ë™ÖË™ÇË™ÑË™®Ë™°Ë™ëË™•Ë™¶Ë™öË™£Ë´ÑË´çË´ÇË´öË´´Ë´≥Ë´ß"],["e680","Ë´§Ë´±Ë¨îË´†Ë´¢Ë´∑Ë´ûË´õË¨åË¨áË¨öË´°Ë¨ñË¨êË¨óË¨†Ë¨≥Èû´Ë¨¶Ë¨´Ë¨æË¨®Ë≠ÅË≠åË≠èË≠éË≠âË≠ñË≠õË≠öË≠´Ë≠üË≠¨Ë≠ØË≠¥Ë≠ΩËÆÄËÆåËÆéËÆíËÆìËÆñËÆôËÆöË∞∫Ë±ÅË∞øË±àË±åË±éË±êË±ïË±¢Ë±¨Ë±∏Ë±∫Ë≤ÇË≤âË≤ÖË≤äË≤çË≤éË≤îË±ºË≤òÊàùË≤≠Ë≤™Ë≤ΩË≤≤Ë≤≥Ë≤ÆË≤∂Ë≥àË≥ÅË≥§Ë≥£Ë≥öË≥ΩË≥∫Ë≥ªË¥ÑË¥ÖË¥äË¥áË¥èË¥çË¥êÈΩéË¥ìË≥çË¥îË¥ñËµßËµ≠Ëµ±Ëµ≥Ë∂ÅË∂ôË∑ÇË∂æË∂∫Ë∑èË∑öË∑ñË∑åË∑õË∑ãË∑™Ë∑´Ë∑üË∑£Ë∑ºË∏àË∏âË∑øË∏ùË∏ûË∏êË∏üËπÇË∏µË∏∞Ë∏¥Ëπä"],["e740","ËπáËπâËπåËπêËπàËπôËπ§Ëπ†Ë∏™Ëπ£ËπïËπ∂Ëπ≤ËπºË∫ÅË∫áË∫ÖË∫ÑË∫ãË∫äË∫ìË∫ëË∫îË∫ôË∫™Ë∫°Ë∫¨Ë∫∞ËªÜË∫±Ë∫æËªÖËªàËªãËªõËª£ËªºËªªËª´ËªæËºäËºÖËºïËºíËºôËºìËºúËºüËºõËºåËº¶Ëº≥ËºªËºπËΩÖËΩÇËºæËΩåËΩâËΩÜËΩéËΩóËΩú"],["e780","ËΩ¢ËΩ£ËΩ§ËæúËæüËæ£Ëæ≠ËæØËæ∑ËøöËø•Ëø¢Ëø™ËøØÈÇáËø¥ÈÄÖËøπËø∫ÈÄëÈÄïÈÄ°ÈÄçÈÄûÈÄñÈÄãÈÄßÈÄ∂ÈÄµÈÄπËø∏ÈÅèÈÅêÈÅëÈÅíÈÄéÈÅâÈÄæÈÅñÈÅòÈÅûÈÅ®ÈÅØÈÅ∂Èö®ÈÅ≤ÈÇÇÈÅΩÈÇÅÈÇÄÈÇäÈÇâÈÇèÈÇ®ÈÇØÈÇ±ÈÇµÈÉ¢ÈÉ§ÊâàÈÉõÈÑÇÈÑíÈÑôÈÑ≤ÈÑ∞ÈÖäÈÖñÈÖòÈÖ£ÈÖ•ÈÖ©ÈÖ≥ÈÖ≤ÈÜãÈÜâÈÜÇÈÜ¢ÈÜ´ÈÜØÈÜ™ÈÜµÈÜ¥ÈÜ∫ÈáÄÈáÅÈáâÈáãÈáêÈáñÈáüÈá°ÈáõÈáºÈáµÈá∂ÈàûÈáøÈàîÈà¨ÈàïÈàëÈâûÈâóÈâÖÈââÈâ§ÈâàÈäïÈàøÈâãÈâêÈäúÈäñÈäìÈäõÈâöÈãèÈäπÈä∑Èã©ÈåèÈã∫ÈçÑÈåÆ"],["e840","ÈåôÈå¢ÈåöÈå£Èå∫ÈåµÈåªÈçúÈç†ÈçºÈçÆÈçñÈé∞Èé¨Èé≠ÈéîÈéπÈèñÈèóÈè®Èè•ÈèòÈèÉÈèùÈèêÈèàÈè§ÈêöÈêîÈêìÈêÉÈêáÈêêÈê∂Èê´ÈêµÈê°Èê∫ÈëÅÈëíÈëÑÈëõÈë†Èë¢ÈëûÈë™Èà©Èë∞ÈëµÈë∑ÈëΩÈëöÈëºÈëæÈíÅÈëøÈñÇÈñáÈñäÈñîÈññÈñòÈñô"],["e880","Èñ†Èñ®ÈñßÈñ≠ÈñºÈñªÈñπÈñæÈóäÊø∂ÈóÉÈóçÈóåÈóïÈóîÈóñÈóúÈó°Èó•Èó¢Èò°Èò®ÈòÆÈòØÈôÇÈôåÈôèÈôãÈô∑ÈôúÈôûÈôùÈôüÈô¶Èô≤Èô¨ÈöçÈöòÈöïÈöóÈö™ÈößÈö±Èö≤Èö∞Èö¥Èö∂Èö∏ÈöπÈõéÈõãÈõâÈõçË•çÈõúÈúçÈõïÈõπÈúÑÈúÜÈúàÈúìÈúéÈúëÈúèÈúñÈúôÈú§Èú™Èú∞ÈúπÈúΩÈúæÈùÑÈùÜÈùàÈùÇÈùâÈùúÈù†Èù§Èù¶Èù®ÂãíÈù´Èù±ÈùπÈûÖÈùºÈûÅÈù∫ÈûÜÈûãÈûèÈûêÈûúÈû®Èû¶Èû£Èû≥Èû¥ÈüÉÈüÜÈüàÈüãÈüúÈü≠ÈΩèÈü≤Á´üÈü∂ÈüµÈ†èÈ†åÈ†∏È†§È†°È†∑È†ΩÈ°ÜÈ°èÈ°ãÈ°´È°ØÈ°∞"],["e940","È°±È°¥È°≥È¢™È¢ØÈ¢±È¢∂È£ÑÈ£ÉÈ£ÜÈ£©È£´È§ÉÈ§âÈ§íÈ§îÈ§òÈ§°È§ùÈ§ûÈ§§È§†È§¨È§ÆÈ§ΩÈ§æÈ•ÇÈ•âÈ•ÖÈ•êÈ•ãÈ•ëÈ•íÈ•åÈ•ïÈ¶óÈ¶òÈ¶•È¶≠È¶ÆÈ¶ºÈßüÈßõÈßùÈßòÈßëÈß≠ÈßÆÈß±Èß≤ÈßªÈß∏È®ÅÈ®èÈ®ÖÈß¢È®ôÈ®´È®∑È©ÖÈ©ÇÈ©ÄÈ©É"],["e980","È®æÈ©ïÈ©çÈ©õÈ©óÈ©üÈ©¢È©•È©§È©©È©´È©™È™≠È™∞È™ºÈ´ÄÈ´èÈ´ëÈ´ìÈ´îÈ´ûÈ´üÈ´¢È´£È´¶È´ØÈ´´È´ÆÈ´¥È´±È´∑È´ªÈ¨ÜÈ¨òÈ¨öÈ¨üÈ¨¢È¨£È¨•È¨ßÈ¨®È¨©È¨™È¨ÆÈ¨ØÈ¨≤È≠ÑÈ≠ÉÈ≠èÈ≠çÈ≠éÈ≠ëÈ≠òÈ≠¥ÈÆìÈÆÉÈÆëÈÆñÈÆóÈÆüÈÆ†ÈÆ®ÈÆ¥ÈØÄÈØäÈÆπÈØÜÈØèÈØëÈØíÈØ£ÈØ¢ÈØ§ÈØîÈØ°È∞∫ÈØ≤ÈØ±ÈØ∞È∞ïÈ∞îÈ∞âÈ∞ìÈ∞åÈ∞ÜÈ∞àÈ∞íÈ∞äÈ∞ÑÈ∞ÆÈ∞õÈ∞•È∞§È∞°È∞∞È±áÈ∞≤È±ÜÈ∞æÈ±öÈ±†È±ßÈ±∂È±∏È≥ßÈ≥¨È≥∞È¥âÈ¥àÈ≥´È¥ÉÈ¥ÜÈ¥™È¥¶È∂ØÈ¥£È¥üÈµÑÈ¥ïÈ¥íÈµÅÈ¥øÈ¥æÈµÜÈµà"],["ea40","ÈµùÈµûÈµ§ÈµëÈµêÈµôÈµ≤È∂âÈ∂áÈ∂´ÈµØÈµ∫È∂öÈ∂§È∂©È∂≤È∑ÑÈ∑ÅÈ∂ªÈ∂∏È∂∫È∑ÜÈ∑èÈ∑ÇÈ∑ôÈ∑ìÈ∑∏È∑¶È∑≠È∑ØÈ∑ΩÈ∏öÈ∏õÈ∏ûÈπµÈππÈπΩÈ∫ÅÈ∫àÈ∫ãÈ∫åÈ∫íÈ∫ïÈ∫ëÈ∫ùÈ∫•È∫©È∫∏È∫™È∫≠Èù°ÈªåÈªéÈªèÈªêÈªîÈªúÈªûÈªùÈª†Èª•Èª®ÈªØ"],["ea80","Èª¥Èª∂Èª∑ÈªπÈªªÈªºÈªΩÈºáÈºàÁö∑ÈºïÈº°Èº¨ÈºæÈΩäÈΩíÈΩîÈΩ£ÈΩüÈΩ†ÈΩ°ÈΩ¶ÈΩßÈΩ¨ÈΩ™ÈΩ∑ÈΩ≤ÈΩ∂ÈæïÈæúÈæ†Â†ØÊßáÈÅôÁë§ÂáúÁÜô"],["ed40","Á∫äË§úÈçàÈäàËìú‰øâÁÇªÊò±Ê£àÈãπÊõªÂΩÖ‰∏®‰ª°‰ªº‰ºÄ‰ºÉ‰ºπ‰Ωñ‰æí‰æä‰æö‰æî‰øçÂÅÄÂÄ¢‰øøÂÄûÂÅÜÂÅ∞ÂÅÇÂÇîÂÉ¥ÂÉòÂÖäÂÖ§ÂÜùÂÜæÂá¨ÂàïÂäúÂä¶ÂãÄÂãõÂåÄÂåáÂå§Âç≤ÂéìÂé≤ÂèùÔ®éÂíúÂíäÂí©ÂìøÂñÜÂùôÂù•Âû¨ÂüàÂüáÔ®è"],["ed80","Ô®êÂ¢ûÂ¢≤Â§ãÂ•ìÂ•õÂ•ùÂ•£Â¶§Â¶∫Â≠ñÂØÄÁîØÂØòÂØ¨Â∞ûÂ≤¶Â≤∫Â≥µÂ¥ßÂµìÔ®ëÂµÇÂµ≠Â∂∏Â∂πÂ∑êÂº°Âº¥ÂΩßÂæ∑ÂøûÊÅùÊÇÖÊÇäÊÉûÊÉïÊÑ†ÊÉ≤ÊÑëÊÑ∑ÊÑ∞ÊÜòÊàìÊä¶ÊèµÊë†ÊíùÊìéÊïéÊòÄÊòïÊòªÊòâÊòÆÊòûÊò§Êô•ÊôóÊôôÔ®íÊô≥ÊöôÊö†Êö≤ÊöøÊõ∫ÊúéÔ§©Êù¶ÊûªÊ°íÊüÄÊ†ÅÊ°ÑÊ£èÔ®ìÊ•®Ô®îÊ¶òÊß¢Ê®∞Ê©´Ê©ÜÊ©≥Ê©æÊ´¢Ê´§ÊØñÊ∞øÊ±úÊ≤ÜÊ±ØÊ≥öÊ¥ÑÊ∂áÊµØÊ∂ñÊ∂¨Ê∑èÊ∑∏Ê∑≤Ê∑ºÊ∏πÊπúÊ∏ßÊ∏ºÊ∫øÊæàÊæµÊøµÁÄÖÁÄáÁÄ®ÁÇÖÁÇ´ÁÑèÁÑÑÁÖúÁÖÜÁÖáÔ®ïÁáÅÁáæÁä±"],["ee40","ÁäæÁå§Ô®ñÁç∑ÁéΩÁèâÁèñÁè£ÁèíÁêáÁèµÁê¶Áê™Áê©ÁêÆÁë¢ÁíâÁíüÁîÅÁïØÁöÇÁöúÁöûÁöõÁö¶Ô®óÁùÜÂäØÁ†°Á°éÁ°§Á°∫Á§∞Ô®òÔ®ôÔ®öÁ¶îÔ®õÁ¶õÁ´ëÁ´ßÔ®úÁ´´ÁÆûÔ®ùÁµàÁµúÁ∂∑Á∂†Á∑ñÁπíÁΩáÁæ°Ô®ûËåÅËç¢ËçøËèáËè∂ËëàËí¥ËïìËïô"],["ee80","Ëï´Ô®üËñ∞Ô®†Ô®°Ë†áË£µË®íË®∑Ë©πË™ßË™æË´üÔ®¢Ë´∂Ë≠ìË≠øË≥∞Ë≥¥Ë¥íËµ∂Ô®£ËªèÔ®§Ô®•ÈÅßÈÉûÔ®¶ÈÑïÈÑßÈáöÈáóÈáûÈá≠ÈáÆÈá§Èá•ÈàÜÈàêÈàäÈà∫ÈâÄÈàºÈâéÈâôÈâëÈàπÈâßÈäßÈâ∑Èâ∏ÈãßÈãóÈãôÈãêÔ®ßÈãïÈã†ÈãìÈå•Èå°ÈãªÔ®®ÈåûÈãøÈåùÈåÇÈç∞ÈçóÈé§ÈèÜÈèûÈè∏Èê±ÈëÖÈëàÈñíÔßúÔ®©ÈöùÈöØÈú≥ÈúªÈùÉÈùçÈùèÈùëÈùïÈ°óÈ°•Ô®™Ô®´È§ßÔ®¨È¶ûÈ©éÈ´ôÈ´úÈ≠µÈ≠≤ÈÆèÈÆ±ÈÆªÈ∞ÄÈµ∞Èµ´Ô®≠È∏ôÈªë"],["eeef","‚Ö∞",9,"Ôø¢Ôø§ÔºáÔºÇ"],["f040","ÓÄÄ",62],["f080","ÓÄø",124],["f140","ÓÇº",62],["f180","ÓÉª",124],["f240","ÓÖ∏",62],["f280","ÓÜ∑",124],["f340","Óà¥",62],["f380","Óâ≥",124],["f440","Óã∞",62],["f480","ÓåØ",124],["f540","Óé¨",62],["f580","Óè´",124],["f640","Óë®",62],["f680","Óíß",124],["f740","Óî§",62],["f780","Óï£",124],["f840","Óó†",62],["f880","Óòü",124],["f940","Óöú"],["fa40","‚Ö∞",9,"‚Ö†",9,"Ôø¢Ôø§ÔºáÔºÇ„à±‚Ññ‚Ñ°‚àµÁ∫äË§úÈçàÈäàËìú‰øâÁÇªÊò±Ê£àÈãπÊõªÂΩÖ‰∏®‰ª°‰ªº‰ºÄ‰ºÉ‰ºπ‰Ωñ‰æí‰æä‰æö‰æî‰øçÂÅÄÂÄ¢‰øøÂÄûÂÅÜÂÅ∞ÂÅÇÂÇîÂÉ¥ÂÉòÂÖä"],["fa80","ÂÖ§ÂÜùÂÜæÂá¨ÂàïÂäúÂä¶ÂãÄÂãõÂåÄÂåáÂå§Âç≤ÂéìÂé≤ÂèùÔ®éÂíúÂíäÂí©ÂìøÂñÜÂùôÂù•Âû¨ÂüàÂüáÔ®èÔ®êÂ¢ûÂ¢≤Â§ãÂ•ìÂ•õÂ•ùÂ•£Â¶§Â¶∫Â≠ñÂØÄÁîØÂØòÂØ¨Â∞ûÂ≤¶Â≤∫Â≥µÂ¥ßÂµìÔ®ëÂµÇÂµ≠Â∂∏Â∂πÂ∑êÂº°Âº¥ÂΩßÂæ∑ÂøûÊÅùÊÇÖÊÇäÊÉûÊÉïÊÑ†ÊÉ≤ÊÑëÊÑ∑ÊÑ∞ÊÜòÊàìÊä¶ÊèµÊë†ÊíùÊìéÊïéÊòÄÊòïÊòªÊòâÊòÆÊòûÊò§Êô•ÊôóÊôôÔ®íÊô≥ÊöôÊö†Êö≤ÊöøÊõ∫ÊúéÔ§©Êù¶ÊûªÊ°íÊüÄÊ†ÅÊ°ÑÊ£èÔ®ìÊ•®Ô®îÊ¶òÊß¢Ê®∞Ê©´Ê©ÜÊ©≥Ê©æÊ´¢Ê´§ÊØñÊ∞øÊ±úÊ≤ÜÊ±ØÊ≥öÊ¥ÑÊ∂áÊµØ"],["fb40","Ê∂ñÊ∂¨Ê∑èÊ∑∏Ê∑≤Ê∑ºÊ∏πÊπúÊ∏ßÊ∏ºÊ∫øÊæàÊæµÊøµÁÄÖÁÄáÁÄ®ÁÇÖÁÇ´ÁÑèÁÑÑÁÖúÁÖÜÁÖáÔ®ïÁáÅÁáæÁä±ÁäæÁå§Ô®ñÁç∑ÁéΩÁèâÁèñÁè£ÁèíÁêáÁèµÁê¶Áê™Áê©ÁêÆÁë¢ÁíâÁíüÁîÅÁïØÁöÇÁöúÁöûÁöõÁö¶Ô®óÁùÜÂäØÁ†°Á°éÁ°§Á°∫Á§∞Ô®òÔ®ô"],["fb80","Ô®öÁ¶îÔ®õÁ¶õÁ´ëÁ´ßÔ®úÁ´´ÁÆûÔ®ùÁµàÁµúÁ∂∑Á∂†Á∑ñÁπíÁΩáÁæ°Ô®ûËåÅËç¢ËçøËèáËè∂ËëàËí¥ËïìËïôËï´Ô®üËñ∞Ô®†Ô®°Ë†áË£µË®íË®∑Ë©πË™ßË™æË´üÔ®¢Ë´∂Ë≠ìË≠øË≥∞Ë≥¥Ë¥íËµ∂Ô®£ËªèÔ®§Ô®•ÈÅßÈÉûÔ®¶ÈÑïÈÑßÈáöÈáóÈáûÈá≠ÈáÆÈá§Èá•ÈàÜÈàêÈàäÈà∫ÈâÄÈàºÈâéÈâôÈâëÈàπÈâßÈäßÈâ∑Èâ∏ÈãßÈãóÈãôÈãêÔ®ßÈãïÈã†ÈãìÈå•Èå°ÈãªÔ®®ÈåûÈãøÈåùÈåÇÈç∞ÈçóÈé§ÈèÜÈèûÈè∏Èê±ÈëÖÈëàÈñíÔßúÔ®©ÈöùÈöØÈú≥ÈúªÈùÉÈùçÈùèÈùëÈùïÈ°óÈ°•Ô®™Ô®´È§ßÔ®¨È¶ûÈ©éÈ´ô"],["fc40","È´úÈ≠µÈ≠≤ÈÆèÈÆ±ÈÆªÈ∞ÄÈµ∞Èµ´Ô®≠È∏ôÈªë"]]');

/***/ }),

/***/ 87466:
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('{"name":"mysql2","version":"3.15.1","description":"fast mysql driver. Implements core protocol, prepared statements, ssl and compression in native JS","main":"index.js","typings":"typings/mysql/index","type":"commonjs","scripts":{"lint":"eslint . && prettier --check .","lint:fix":"eslint . --fix && prettier --write .","test":"poku -d -r=verbose --sequential test/esm test/unit test/integration","test:bun":"bun poku -d --sequential test/esm test/unit test/integration","test:deno":"deno run --allow-read --allow-env --allow-run npm:poku -d --sequential --denoAllow=\\"read,env,net,sys\\" test/esm test/unit test/integration","test:tsc-build":"cd \\"test/tsc-build\\" && npx tsc -p \\"tsconfig.json\\"","coverage-test":"c8 npm run test","benchmark":"node ./benchmarks/benchmark.js","wait-port":"wait-on"},"repository":{"type":"git","url":"git+https://github.com/sidorares/node-mysql2.git"},"homepage":"https://sidorares.github.io/node-mysql2/docs","keywords":["mysql","client","server"],"files":["lib","typings/mysql","index.js","index.d.ts","promise.js","promise.d.ts"],"exports":{".":"./index.js","./package.json":"./package.json","./promise":"./promise.js","./promise.js":"./promise.js"},"engines":{"node":">= 8.0"},"author":"Andrey Sidorov <andrey.sidorov@gmail.com>","license":"MIT","dependencies":{"aws-ssl-profiles":"^1.1.1","denque":"^2.1.0","generate-function":"^2.3.1","iconv-lite":"^0.7.0","long":"^5.2.1","lru.min":"^1.0.0","named-placeholders":"^1.1.3","seq-queue":"^0.0.5","sqlstring":"^2.3.2"},"devDependencies":{"@eslint/eslintrc":"^3.3.0","@eslint/js":"^9.21.0","@eslint/markdown":"^7.0.0","@types/node":"^24.0.0","@typescript-eslint/eslint-plugin":"^8.26.0","@typescript-eslint/parser":"^8.26.0","assert-diff":"^3.0.2","benchmark":"^2.1.4","c8":"^10.1.1","error-stack-parser":"^2.0.3","eslint-config-prettier":"^10.0.2","eslint-plugin-async-await":"^0.0.0","eslint-plugin-markdown":"^5.1.0","eslint-plugin-prettier":"^5.2.3","globals":"^16.0.0","poku":"^3.0.0","portfinder":"^1.0.28","prettier":"^3.0.0","typescript":"^5.0.2"}}');

/***/ }),

/***/ 89338:
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('[["8740","‰è∞‰∞≤‰òÉ‰ñ¶‰ï∏ßâß‰µ∑‰ñ≥ß≤±‰≥¢ß≥Ö„Æï‰ú∂‰ùÑ‰±á‰±Ä§äø£òóßçí¶∫ãßÉí‰±ó™çë‰ùè‰óö‰≤Öß±¨‰¥á‰™§‰ö°¶¨£Áà••©î°©££∏Ü£Ω°ÊôçÂõª"],["8767","Á∂ïÂ§ù®Æπ„∑¥Èú¥ßØØÂØõ°µûÂ™§„ò•©∫∞Â´ëÂÆ∑Â≥ºÊùÆËñì©•ÖÁë°Áíù„°µ°µì£öû¶Ä°„ª¨"],["87a1","•£û„´µÁ´ºÈæó§Ö°®§ç£á™†™ä£âû‰åäËíÑÈæñÈêØ‰§∞ËòìÂ¢ñÈùäÈàòÁßêÁ®≤Êô†Ê®©Ë¢ùÁëåÁØÖÊûÇÁ®¨ÂâèÈÅÜ„ì¶ÁèÑ•∂πÁìÜÈøáÂû≥‰§ØÂëå‰Ñ±£öéÂ†òÁ©≤ß≠•ËÆè‰öÆ¶∫à‰ÜÅ•∂ôÁÆÆ¢íºÈøà¢ìÅ¢ìâ¢ìåÈøâËîÑ£ñª‰Ç¥Èøä‰ì°™∑øÊãÅÁÅÆÈøã"],["8840","„áÄ",4,"†Ñå„áÖ†Éë†Éç„áÜ„áá†Éã°ø®„áà†Éä„áâ„áä„áã„áå†Ñé„áç„áéƒÄ√Å«ç√Äƒí√âƒö√à≈å√ì«ë√í‡øø√äÃÑ·∫æ‡øø√äÃå·ªÄ√äƒÅ√°«é√†…ëƒì√©ƒõ√®ƒ´√≠«ê√¨≈ç√≥«í√≤≈´√∫«î√π«ñ«ò«ö"],["88a1","«ú√º‡øø√™ÃÑ·∫ø‡øø√™Ãå·ªÅ√™…°‚èö‚èõ"],["8940","™é©°ÖÖ"],["8943","Êîä"],["8946","‰∏ΩÊªùÈµéÈáü"],["894c","ßúµÊíë‰ºö‰º®‰æ®ÂÖñÂÖ¥ÂÜúÂá§Âä°Âä®ÂåªÂçéÂèëÂèòÂõ¢Â£∞Â§ÑÂ§áÂ§≤Â§¥Â≠¶ÂÆûÂÆüÂ≤öÂ∫ÜÊÄªÊñâÊüæÊ†ÑÊ°•ÊµéÁÇºÁîµÁ∫§Á∫¨Á∫∫ÁªáÁªèÁªüÁºÜÁº∑Ëâ∫ËãèËçØËßÜËÆæËØ¢ËΩ¶ËΩßËΩÆ"],["89a1","ÁêëÁ≥ºÁ∑çÊ•ÜÁ´âÂàß"],["89ab","ÈÜåÁ¢∏ÈÖûËÇº"],["89b0","Ë¥ãËÉ∂†ßß"],["89b5","ËÇüÈªá‰≥çÈ∑âÈ∏å‰∞æ©∑∂ßÄéÈ∏ä™Ñ≥„óÅ"],["89c1","Ê∫öËàæÁîô"],["89c5","‰§ëÈ©¨È™èÈæôÁ¶á®ë¨°∑ä†óê¢´¶‰∏§‰∫Å‰∫Ä‰∫á‰∫ø‰ª´‰º∑„ëå‰æΩ„πàÂÄÉÂÇà„ëΩ„íì„í•ÂÜÜÂ§ÖÂáõÂáºÂàÖ‰∫âÂâπÂäêÂåß„óáÂé©„ïëÂé∞„ïìÂèÇÂê£„ï≠„ï≤„öÅÂíìÂí£Âí¥ÂíπÂìêÂìØÂîòÂî£Âî®„ñòÂîø„ñ•„ñøÂóó„óÖ"],["8a40","ß∂ÑÂî•"],["8a43","†±Ç†¥ï•Ñ´Âñê¢≥Ü„ß¨†çÅËπÜ§∂∏©ì•‰Åì®ÇæÁù∫¢∞∏„®¥‰üï®Öù¶ß≤§∑™Êìù†µº†æ¥†≥ï°É¥ÊíçËπæ†∫ñ†∞ã†Ω§¢≤©®âñ§ìì"],["8a64","†µÜ©©ç®É©‰ü¥§∫ß¢≥ÇÈ™≤„©ß©ó¥„ø≠„îÜ•ãá©üîß£à¢µÑÈµÆÈ†ï"],["8a76","‰èô¶Ç•Êí¥Âì£¢µå¢Øä°Å∑„ßª°ÅØ"],["8aa1","¶õö¶úñß¶†Êì™•Åí†±ÉËπ®¢Ü°®≠å†ú±"],["8aac","‰†ã†Ü©„ø∫Â°≥¢∂ç"],["8ab2","§óà†ìº¶Çó†Ωå†∂ñÂïπ‰Çª‰é∫"],["8abb","‰™¥¢©¶°ÇùËÜ™È£µ†∂úÊçπ„ßæ¢ùµË∑ÄÂö°Êëº„πÉ"],["8ac9","™òÅ†∏â¢´è¢≥â"],["8ace","°Éà£ßÇ„¶í„®Ü®äõ„ï∏•πâ¢ÉáÂôí†º±¢≤≤©ú†„íºÊ∞Ω§∏ª"],["8adf","ßï¥¢∫ã¢àà™ôõ®≥ç†π∫†∞¥¶†úÁæì°Éè¢†É¢§π„óª•á£†∫å†æç†∫™„æì†º∞†µá°Öè†πå"],["8af6","†∫´†Æ©†µà°ÉÄ°ÑΩ„øπ¢öñÊê≤†æ≠"],["8b40","£è¥ßòπ¢Øé†µæ†µø¢±ë¢±ï„®ò†∫ò°Éá†ºÆ™ò≤¶≠ê®≥í®∂ô®≥äÈñ™ÂìåËãÑÂñπ"],["8b55","©ªÉÈ∞¶È™∂ßùû¢∑ÆÁÖÄËÖ≠ËÉ¨Â∞ú¶ï≤ËÑ¥„ûóÂçü®ÇΩÈÜ∂†ª∫†∏è†π∑†ªª„óù§∑´„òâ†≥ñÂöØ¢ûµ°Éâ†∏ê†π∏°Å∏°Öà®àá°ëï†ππ§πê¢∂§Â©î°Äù°Äû°Éµ°É∂Âûú†∏ë"],["8ba1","ßöî®ãç†æµ†πª•Öæ„úÉ†æ∂°ÜÄ•ãò™äΩ§ßö°†∫§Ö∑®âºÂ¢ôÂâ®„òö•úΩÁÆ≤Â≠®‰†Ä‰¨¨Èºß‰ßßÈ∞üÈÆç•≠¥£ÑΩÂóª„ó≤Âöâ‰∏®Â§Ç°ØÅØ°∏Èùë†ÇÜ‰πõ‰∫ª„îæÂ∞£ÂΩëÂøÑ„£∫ÊâåÊîµÊ≠∫Ê∞µÊ∞∫ÁÅ¨Áà´‰∏¨Áä≠§£©ÁΩíÁ§ªÁ≥πÁΩì¶â™„ìÅ"],["8bde","¶çãËÄÇËÇÄ¶òí¶•ëÂçùË°§ËßÅß¢≤ËÆ†Ë¥ùÈíÖÈï∏ÈïøÈó®®∏èÈü¶È°µÈ£éÈ£ûÈ•£©†êÈ±ºÈ∏üÈªÑÊ≠ØÔ§á‰∏∑†ÇáÈòùÊà∑Èí¢"],["8c40","ÂÄªÊ∑æ©±≥Èæ¶„∑âË¢è§ÖéÁÅ∑Â≥µ‰¨†•áç„ïô•¥∞ÊÑ¢®®≤ËæßÈá∂ÁÜëÊúôÁé∫£äÅ™Ñá„≤ã°¶Ä‰¨êÁ£§ÁêÇÂÜÆ®úè‰ÄâÊ©£™ä∫‰à£Ëòè†©ØÁ®™©•á®´™ÈùïÁÅçÂå§¢ÅæÈè¥Áõô®ß£ÈæßÁüù‰∫£‰ø∞ÂÇº‰∏Ø‰ºóÈæ®Âê¥Á∂ãÂ¢íÂ£ê°∂∂Â∫íÂ∫ôÂøÇ¢úíÊñã"],["8ca1","£èπÊ§ôÊ©É£±£Ê≥ø"],["8ca7","ÁàÄ§îÖÁéå„ªõ§®ìÂ¨ïÁíπËÆÉ•≤§•öïÁ™ìÁØ¨Á≥ÉÁπ¨Ëã∏ËñóÈæ©Ë¢êÈæ™Ë∫πÈæ´ËøèËïüÈß†Èà°Èæ¨®∂π°êø‰Å±‰ä¢Â®ö"],["8cc9","È°®Êù´‰â∂ÂúΩ"],["8cce","Ëóñ§•ªËäøßÑç‰≤Å¶µ¥Âµª¶¨ï¶ææÈæ≠ÈæÆÂÆñÈæØÊõßÁπõÊπóÁßä„∂à‰ìÉ£âñ¢ûñ‰éö‰î∂"],["8ce6","Â≥ï£¨öË´πÂ±∏„¥í£ïëÂµ∏Èæ≤ÁÖó‰ïò§É¨°∏£‰±∑„•∏„ëä†Ü§¶±ÅË´å‰æ¥†àπÂ¶øËÖ¨È°ñ©£∫Âºª"],["8d40","†Æü"],["8d42","¢áÅ®•≠‰ÑÇ‰öª©Åπ„ºáÈæ≥™Üµ‰É∏„üñ‰õ∑¶±Ü‰Öº®ö≤ßèø‰ï≠„£î•íö‰ï°‰îõ‰∂â‰±ª‰µ∂‰ó™„øà§¨è„ô°‰ìû‰íΩ‰á≠Â¥æÂµàÂµñ„∑º„†èÂ∂§Â∂π„††„†∏ÂπÇÂ∫ΩÂº•ÂæÉ„§à„§î„§ø„•çÊÉóÊÑΩÂ≥•„¶âÊÜ∑ÊÜπÊáè„¶∏Êà¨ÊäêÊã•Êåò„ß∏Âö±"],["8da1","„®ÉÊè¢ÊèªÊêáÊëö„©ãÊìÄÂ¥ïÂò°Èæü„™óÊñÜ„™ΩÊóøÊôì„´≤Êöí„¨¢Êúñ„≠ÇÊû§Ê†Ä„≠òÊ°äÊ¢Ñ„≠≤„≠±„≠ªÊ§âÊ•ÉÁâúÊ•§Ê¶üÊ¶Ö„ÆºÊßñ„ØùÊ©•Ê©¥Ê©±Ê™Ç„Ø¨Ê™ô„Ø≤Ê™´Ê™µÊ´îÊ´∂ÊÆÅÊØÅÊØ™Ê±µÊ≤™„≥ãÊ¥ÇÊ¥ÜÊ¥¶Ê∂Å„≥ØÊ∂§Ê∂±Ê∏ïÊ∏òÊ∏©Ê∫Ü®ßÄÊ∫ªÊª¢ÊªöÈΩøÊª®Êª©Êº§Êº¥„µÜ£ΩÅÊæÅÊææ„µ™„µµÁÜ∑Â≤ô„∂äÁÄ¨„∂ëÁÅêÁÅîÁÅØÁÅøÁÇâ†å•‰èÅ„ó±†ªò"],["8e40","£ªóÂûæ¶ªìÁÑæ•ü†„ôéÊ¶¢®Ø©Â≠¥Á©â•£°©ìôÁ©•Á©Ω•¶¨Á™ªÁ™∞Á´ÇÁ´ÉÁáë¶íç‰áäÁ´öÁ´ùÁ´™‰áØÂí≤•∞ÅÁ¨ãÁ≠ïÁ¨©•åé•≥æÁÆ¢Á≠ØËéú•Æ¥¶±øÁØêËê°ÁÆíÁÆ∏•¥†„∂≠•±•ËííÁØ∫Á∞ÜÁ∞µ•≥ÅÁ±ÑÁ≤É§¢ÇÁ≤¶ÊôΩ§ï∏Á≥âÁ≥áÁ≥¶Á±¥Á≥≥Á≥µÁ≥é"],["8ea1","Áπß‰îù¶πÑÁµù¶ªñÁíçÁ∂âÁ∂´ÁÑµÁ∂≥Á∑í§Åó¶Ä©Á∑§„¥ìÁ∑µ°üπÁ∑•®ç≠Á∏ù¶Ñ°¶ÖöÁπÆÁ∫í‰å´Èë¨Á∏ßÁΩÄÁΩÅÁΩáÁ§∂¶ãêÈß°Áæó¶çëÁæ£°ô°†Å®‰ïú£ù¶‰îÉ®å∫Áø∫¶íâËÄÖËÄàËÄùËÄ®ËÄØ™Çá¶≥ÉËÄªËÄºËÅ°¢úî‰¶â¶ò¶£∑£¶õ®Êú•ËÇß®©àËÑáËÑöÂ¢∞¢õ∂Ê±ø¶íò§æ∏Êìß°íäËàò°°ûÊ©ì§©•§™ï‰ë∫Ëà©†¨ç¶©í£µæ‰øπ°ìΩËì¢Ëç¢¶¨ä§¶ß£î∞°ù≥£∑∏Ëä™Ê§õØ¶î‰áõ"],["8f40","ËïãËãêËåö†∏ñ°û¥„õÅ£ÖΩ£ïöËâªËã¢Ëåò£∫ã¶∂£¶¨Ö¶Æó£óé„∂øËåùÂó¨ËéÖ‰îã¶∂•Ëé¨ËèÅËèì„ëæ¶ªîÊ©óËïö„íñ¶πÇ¢ªØËëò•Ø§Ëë±„∑ì‰ì§Ê™ßËëä£≤µÁ•òËí®¶Æñ¶π∑¶πÉËìûËêèËéë‰í†ËíìËì§•≤ë‰âÄ•≥Ä‰ïÉËî¥Â´≤¶∫ô‰îßËï≥‰îñÊûøËòñ"],["8fa1","®ò•®òªËóÅßÇàËòÇ°ñÇßÉçØ¶≤‰ï™Ëò®„ôà°¢¢Âè∑ßéöËôæËù±™É∏ËüÆ¢∞ßËû±ËüöË†èÂô°Ëô¨Ê°ñ‰òèË°ÖË°Üßó†£∂πßó§Ë°ûË¢ú‰ôõË¢¥Ë¢µÊèÅË£ÖÁù∑ßúèË¶áË¶äË¶¶Ë¶©Ë¶ßË¶º®®•Ëßßß§§ß™ΩË™úÁûìÈáæË™êß©ôÁ´©ß¨∫£æè‰úìß¨∏ÁÖºË¨åË¨ü•ê∞•ï•Ë¨øË≠åË≠çË™©§©∫ËÆêËÆõË™Ø°õü‰òïË°èË≤õßµîß∂èØßî„ú•ßµìË≥ñß∂òß∂ΩË¥íË¥É°§êË≥õÁÅúË¥ë§≥â„ªêËµ∑"],["9040","Ë∂©®ÄÇ°Äî§¶ä„≠º®ÜºßÑåÁ´ßË∫≠Ë∫∂ËªÉÈãîËºôËº≠®ç•®êíËæ•ÈåÉ™äü†©êËæ≥‰§™®ßû®îΩ£∂ªÂª∏£â¢Ëøπ™Äî®öº®îÅ¢å•„¶Ä¶ªóÈÄ∑®îºß™æÈÅ°®ï¨®òãÈÇ®®úìÈÉÑ®õ¶ÈÇÆÈÉΩÈÖß„´∞ÈÜ©ÈáÑÁ≤¨®§≥°∫âÈàéÊ≤üÈâÅÈâ¢•ñπÈäπ®´Ü£≤õ®¨å•óõ"],["90a1","†¥±Èå¨Èç´®´°®Ø´ÁÇèÂ´É®´¢®´•‰••ÈâÑ®Ø¨®∞π®ØøÈç≥ÈëõË∫ºÈñÖÈñ¶Èê¶Èñ†Êø∂‰äπ¢ô∫®õò°âº£∏Æ‰ßüÊ∞úÈôªÈöñ‰Ö¨Èö£¶ªïÊáöÈö∂Á£µ®´†ÈöΩÂèå‰¶°¶≤∏†â¥¶êê©ÇØ©É•§´ë°§ï£åäÈú±ËôÇÈú∂‰®è‰îΩ‰ñÖ§´©ÁÅµÂ≠ÅÈúõÈùú©áïÈùóÂ≠ä©á´ÈùüÈê•ÂÉê£Ç∑£ÇºÈûâÈûüÈû±ÈûæÈüÄÈüíÈü†•ë¨ÈüÆÁêú©ê≥ÈüøÈüµ©êùß•∫‰´ëÈ†¥È†≥È°ãÈ°¶„¨éßÖµ„µë†ò∞§Öú"],["9140","•úÜÈ£äÈ¢∑È£àÈ£á‰´ø¶¥ß°õìÂñ∞È£°È£¶È£¨Èç∏È§π§®©‰≠≤©°ó©§ÖÈßµÈ®åÈ®ªÈ®êÈ©ò•ú•„õÑ©Ç±©ØïÈ´†È´¢©¨ÖÈ´¥‰∞éÈ¨îÈ¨≠®òÄÂÄ¥È¨¥¶¶®„£É£ÅΩÈ≠êÈ≠Ä©¥æÂ©Ö°°£ÈÆé§âãÈ∞ÇÈØøÈ∞å©π®È∑î©æ∑™Üí™Ü´™É°™Ñ£™áüÈµæÈ∂É™Ñ¥È∏éÊ¢à"],["91a1","È∑Ñ¢Öõ™Üì™à†°§ª™à≥È¥π™Çπ™ä¥È∫êÈ∫ïÈ∫ûÈ∫¢‰¥¥È∫™È∫Ø§ç§ÈªÅ„≠†„ß•„¥ù‰º≤„ûæ®∞´ÈºÇÈºà‰ÆñÈê§¶∂¢ÈºóÈºñÈºπÂöüÂöäÈΩÖÈ¶∏©ÇãÈü≤ËëøÈΩ¢ÈΩ©Á´úÈæéÁàñ‰Ææ§•µ§¶ªÁÖ∑§ß∏§çà§©ëÁéû®Øö°£∫Á¶ü®•æ®∏∂Èç©Èè≥®©ÑÈã¨ÈéÅÈèã®•¨§íπÁàó„ª´Áù≤Á©ÉÁÉê§ë≥§è∏ÁÖæ°üØÁÇ£°¢æ£ñô„ªá°¢Ö•êØ°ü∏„ú¢°õª°†π„õ°°ù¥°£ë•Ωã„ú£°õÄÂùõ§®•°èæ°ä®"],["9240","°èÜ°í∂ËîÉ£ö¶ËîÉËëï§¶îßÖ•£∏±•ïú£ªªßÅí‰ì¥£õÆ©¶ù¶º¶Êüπ„ú≥„∞ï„∑ßÂ°¨°§¢Ê†ê‰Åó£úø§É°§Çã§Ñè¶∞°ÂìãÂöû¶ö±Âöí†øü†Æ®†∏çÈèÜ®¨ìÈéú‰ª∏ÂÑ´„†ô§ê∂‰∫º†ë•†çø‰Ωã‰æä•ôëÂ©®†Ü´†èã„¶ô†åä†êî„êµ‰º©†ãÄ®∫≥†âµË´ö†àå‰∫ò"],["92a1","ÂÉçÂÑç‰æ¢‰ºÉ§®é£∫ä‰ΩÇÂÄÆÂÅ¨ÂÇÅ‰øå‰ø•ÂÅòÂÉºÂÖôÂÖõÂÖùÂÖûÊπ∂£ñï£∏π£∫øÊµ≤°¢Ñ£∫âÂÜ®ÂáÉ†ó†‰ìù†í£†íí†íëËµ∫®™ú†úéÂâôÂä§†°≥Âã°ÈçÆ‰ô∫ÁÜå§éå†∞†§¶¨°É§Êßë†∏ùÁëπ„ªûÁíôÁêîÁëñÁéò‰Æé§™º§ÇçÂèê„ñÑÁàè§ÉâÂñ¥†çÖÂìç†ØÜÂúùÈâùÈõ¥Èç¶ÂüùÂûçÂùø„òæÂ£ãÂ™ô®©Ü°õ∫°ùØ°úêÂ®¨Â¶∏ÈäèÂ©æÂ´èÂ®í••Ü°ß≥°°°§äï„õµÊ¥ÖÁëÉÂ®°•∫É"],["9340","Â™Å®Øó†êìÈè†Áíå°åÉÁÑÖ‰•≤Èêà®ßªÈéΩ„û†Â∞ûÂ≤ûÂπûÂπà°¶ñ°•º£´ÆÂªçÂ≠è°§É°§Ñ„úÅ°¢†„õù°õæ„õìËÑ™®©á°∂∫£ë≤®¶®ÂºåÂºé°§ß°û´Â©´°úªÂ≠ÑËòîßóΩË°†ÊÅæ¢°†¢ò´Âøõ„∫∏¢ñØ¢ñæ©Çà¶Ω≥ÊáÄ†Äæ†ÅÜ¢òõÊÜôÊÜòÊÅµ¢≤õ¢¥á§õî©Öç"],["93a1","Êë±§ô•¢≠™„®©¢¨¢£ëê©£™¢π∏Êå∑™ëõÊí∂Êå±Êèë§ß£¢µßÊä§¢≤°ÊêªÊï´Ê•≤„Ø¥£Çé£ä≠§¶â£ä´Âîç£ã†°£ô©êøÊõé£äâ£Ü≥„´†‰Üê•ñÑ®¨¢•ñè°õº•ïõ•ê•Á£Æ£ÑÉ°†™£à¥„ë§£àè£ÜÇ§ãâÊöé¶¥§Êô´‰ÆìÊò∞ß°∞°∑´Êô££ãí£ã°Êòû•°≤„£ë£†∫£ûº„Æô£û¢£èæÁìê„ÆñÊûè§ò™Ê¢∂Ê†û„ØÑÊ™æ„°££üï§íáÊ®≥Ê©íÊ´âÊ¨Ö°§íÊîëÊ¢òÊ©å„ØóÊ©∫Ê≠ó£øÄ£≤öÈé†Èã≤®Ø™®´ã"],["9440","Èäâ®Äû®ßúÈëßÊ∂•Êºã§ß¨Êµß£Ωø„∂èÊ∏Ñ§ÄºÂ®ΩÊ∏äÂ°áÊ¥§Á°ÇÁÑª§åö§â∂ÁÉ±ÁâêÁäáÁäî§ûè§ú•ÂÖπ§™§†ó´Áë∫£ª∏£ôü§©ä§§ó•ø°„ºÜ„∫±§´ü®∞££ºµÊÇß„ª≥ÁìåÁêºÈéáÁê∑‰íü¶∑™‰ïëÁñÉ„Ω£§≥ô§¥Ü„ΩòÁïïÁô≥™óÜ„¨ôÁë®®´å§¶´§¶é„´ª"],["94a1","„∑ç§©é„ªø§ßÖ§£≥Èá∫Âú≤ÈçÇ®´£°°§ÂÉü•à°•áßÁù∏£à≤ÁúéÁúèÁùª§öó£ûÅ„©û§£∞Áê∏Áíõ„∫ø§™∫§´á‰Éà§™ñ¶ÜÆÈåá•ñÅÁ†ûÁ¢çÁ¢àÁ£íÁèêÁ•ôßùÅ•õ£‰ÑéÁ¶õËíñÁ¶•Ê®≠£ª∫Á®∫Áß¥‰ÖÆ°õ¶‰Ñ≤ÈàµÁß±†µå§¶å†äô£∂∫°ùÆ„ñóÂï´„ï∞„ö™†áî†∞çÁ´¢Â©ô¢õµ•™Ø•™úÂ®ç†âõÁ£∞Â®™•ØÜÁ´æ‰áπÁ±ùÁ±≠‰àë•Æ≥•∫º•∫¶Á≥ç§ßπ°û∞Á≤éÁ±ºÁ≤ÆÊ™≤Á∑úÁ∏áÁ∑ìÁΩé¶â°"],["9540","¶Öúß≠àÁ∂ó•∫Ç‰â™¶≠µ†§ñÊüñ†Åé£óèÂüÑ¶êí¶è∏§•¢ÁøùÁ¨ß††¨•´©•µÉÁ¨å•∏éÈß¶ËôÖÈ©£Ê®ú£êø„ß¢§ß∑¶ñ≠È®ü¶ñ†ËíÄßÑß¶≥ë‰ì™ËÑ∑‰êÇËÉÜËÑâËÖÇ¶û¥È£É¶©ÇËâ¢Ëâ•¶©ëËëì¶∂ßËòêßàõÂ™Ü‰Öø°°ÄÂ¨´°¢°Â´§°£òËö†Ø¶º£∂èË†≠ßê¢Â®Ç"],["95a1","Ë°Æ‰ΩÖË¢áË¢øË£¶Ë••Ë•ç•öÉË•îßûÖßûÑ®Øµ®Øô®Æú®ßπ„∫≠Ëí£‰õµ‰õè„ü≤Ë®ΩË®ú©ëàÂΩçÈà´§äÑÊóîÁÑ©ÁÉÑ°°ÖÈµ≠Ë≤üË≥©ß∑úÂ¶öÁüÉÂß∞‰çÆ„õîË∏™Ë∫ß§∞âËº∞ËΩä‰ã¥Ê±òÊæª¢å°‰¢õÊΩπÊ∫ã°üöÈØ©„öµ§§ØÈÇªÈÇóÂï±‰§ÜÈÜªÈêÑ®©ã‰Å¢®´ºÈêß®∞ù®∞ªËì•Ë®´ÈñôÈñßÈñóÈññ®¥¥ÁëÖ„ªÇ§£ø§©Ç§è™„ªß£à•Èöè®ªß®π¶®π•„ªå§ß≠§©∏£øÆÁêíÁë´„ªºÈùÅ©Ç∞"],["9640","Ê°á‰®ù©Çì•üüÈùùÈç®®¶â®∞¶®¨Ø¶éæÈä∫Â¨ëË≠©‰§ºÁèπ§àõÈûõÈù±È§∏†º¶Â∑Å®ØÖ§™≤È†ü©ìöÈã∂©óóÈá•‰ìÄ®≠ê§©ß®≠§È£ú®©Ö„ºÄÈà™‰§•ËêîÈ§ªÈ•çß¨Ü„∑ΩÈ¶õ‰≠ØÈ¶™È©ú®≠••£àÊ™èÈ®°Â´æÈ®Ø©£±‰Æê©•àÈ¶º‰ÆΩ‰ÆóÈçΩÂ°≤°åÇÂ†¢§¶∏"],["96a1","°ì®Á°Ñ¢úü£∂∏Ê£Ö„µΩÈëò„§ßÊÖê¢ûÅ¢•´ÊÑáÈ±èÈ±ìÈ±ªÈ∞µÈ∞êÈ≠øÈØè©∏≠ÈÆü™áµ™ÉæÈ¥°‰≤Æ§ÑÑÈ∏ò‰≤∞È¥å™Ü¥™É≠™É≥©§ØÈ∂•ËíΩ¶∏í¶øü¶ÆÇËóº‰î≥¶∂§¶∫Ñ¶∑∞Ëê†ËóÆ¶∏Ä£üó¶Å§Áß¢£ñú£ôÄ‰§≠§ßû„µ¢ÈèõÈäæÈçà†äøÁ¢πÈâ∑Èëç‰ø§„ëÄÈÅ§•ïùÁ†ΩÁ°îÁ¢∂Á°ã°ùó£áâ§•Å„öö‰Ω≤ÊøöÊøôÁÄûÁÄûÂêî§ÜµÂûªÂ£≥ÂûäÈ¥ñÂüóÁÑ¥„íØ§Ü¨Áá´¶±Ä§æóÂ¨®°ûµ®©â"],["9740","ÊÑåÂ´éÂ®ã‰äº§íà„ú¨‰≠ª®ßºÈéªÈé∏°£ñ†ºùËë≤¶≥Ä°êì§ã∫¢∞¶§èÅÂ¶î£∂∑¶ùÅÁ∂®¶Öõ¶Ç§§¶π§¶ã®ß∫Èã•Áè¢„ª©Áí¥®≠£°¢ü„ª°§™≥Ê´òÁè≥Áèª„ªñ§®æ§™î°üô§©¶†éß°ê§§ß•Áëà§§ñÁÇ•§•∂ÈäÑÁè¶Èçü†ìæÈå±®´é®®ñÈéÜ®Øß•óï‰§µ®™ÇÁÖ´"],["97a1","§•É†≥øÂö§†òö†Ø´†≤∏ÂîÇÁßÑ°ü∫Á∑æ°õÇ§©ê°°í‰îÆÈêÅ„úä®´Ä§¶≠Â¶∞°¢ø°¢ÉßíÑÂ™°„õ¢£µõ„ö∞ÈâüÂ©π®™Å°°¢Èç¥„≥ç†™¥‰™ñ„¶äÂÉ¥„µ©„µå°éúÁÖµ‰ãª®àòÊ∏è©É§‰ì´ÊµóßπèÁÅßÊ≤Ø„≥ñ£ø≠£∏≠Ê∏ÇÊºå„µØ†èµÁïë„öº„ìà‰öÄ„ªö‰°±ÂßÑÈâÆ‰§æËΩÅ®∞ú¶ØÄÂ†íÂüà„õñ°ëíÁÉæ§ç¢§©±¢ø£°ä∞¢éΩÊ¢πÊ•ß°éò£ì•ßØ¥£õü®™É£üñ£è∫§≤üÊ®ö£ö≠¶≤∑Ëêæ‰ìü‰ìé"],["9840","¶¥¶¶µë¶≤Ç¶øûÊºóßÑâËåΩ°ú∫Ëè≠¶≤ÄßÅì°üõÂ¶âÂ™Ç°û≥Â©°Â©±°§Ö§áº„ú≠ÂßØ°úº„õáÁÜéÈéêÊöö§ä•Â©ÆÂ®´§äìÊ®´£ªπßú∂§ëõ§ãäÁÑù§âô®ß°‰æ∞¶¥®Â≥Ç§ìéßπç§éΩÊ®å§âñ°åÑÁÇ¶ÁÑ≥§è©„∂•Ê≥üØ†•§©èÁπ•Âß´Â¥Ø„∑≥ÂΩú§©ù°üüÁ∂§Ëê¶"],["98a1","ÂíÖ£´∫£åÄ†àîÂùæ†£ï†òô„ø•°æû™ä∂ÁÄÉ©ÖõÂµ∞ÁéèÁ≥ì®©ô©ê†‰øàÁøßÁãçÁåêß´¥Áå∏Áåπ•õ∂ÁçÅÁçà„∫©ß¨òÈÅ¨Ááµ§£≤Áè°Ëá∂„ªäÁúå„ªëÊ≤¢ÂõΩÁêôÁêûÁêü„ª¢„ª∞„ª¥„ª∫Áìì„ºé„ΩìÁïÇÁï≠Áï≤Áñç„ΩºÁóàÁóú„øÄÁôç„øóÁô¥„øúÁô∫§ΩúÁÜàÂò£Ë¶ÄÂ°©‰ÄùÁùÉ‰ÄπÊù°‰ÅÖ„óõÁûò‰Å™‰ÅØÂ±ûÁûæÁüãÂ£≤Á†òÁÇπÁ†ú‰Ç®Á†πÁ°áÁ°ëÁ°¶Ëëà•îµÁ§≥Ê†ÉÁ§≤‰ÑÉ"],["9940","‰ÑâÁ¶ëÁ¶ôËæªÁ®ÜËæº‰ÖßÁ™ë‰Ü≤Á™ºËâπ‰áÑÁ´èÁ´õ‰áè‰∏°Á≠¢Á≠¨Á≠ªÁ∞íÁ∞õ‰â†‰â∫Á±ªÁ≤ú‰äåÁ≤∏‰äîÁ≥≠ËæìÁÉÄ†≥èÁ∑èÁ∑îÁ∑êÁ∑ΩÁæÆÁæ¥Áäü‰éóËÄ†ËÄ•Á¨πËÄÆËÄ±ËÅî„∑åÂû¥ÁÇ†ËÇ∑ËÉ©‰è≠ËÑåÁå™ËÑéËÑíÁï†ËÑî‰êÅ„¨πËÖñËÖôËÖö"],["99a1","‰êìÂ†∫ËÖºËÜÑ‰ê•ËÜì‰ê≠ËÜ•ÂüØËáÅËá§Ëâî‰íèËä¶Ëâ∂ËãäËãòËãø‰í∞ËçóÈô©Ê¶äËêÖÁÉµËë§ÊÉ£Ëíà‰îÑËíæËì°Ëì∏ËîêËî∏Ëïí‰îªËïØËï∞Ëó†‰ï∑Ëô≤ËöíËö≤ËõØÈôÖËûã‰òÜ‰òóË¢ÆË£øË§§Ë•áË¶ëß•ßË®©Ë®∏Ë™îË™¥Ë±ëË≥îË≥≤Ë¥ú‰ûòÂ°üË∑É‰ü≠‰ªÆË∏∫ÂóòÂùîËπ±ÂóµË∫∞‰†∑ËªéËª¢Ëª§Ëª≠Ëª≤Ëæ∑ËøÅËøäËøåÈÄ≥ÈßÑ‰¢≠È£†Èàì‰§ûÈà®ÈâòÈâ´Èä±ÈäÆÈäø"],["9a40","Èã£Èã´Èã≥Èã¥ÈãΩÈçÉÈéÑÈé≠‰•Ö‰•ëÈ∫øÈêóÂåÅÈêùÈê≠Èêæ‰•™ÈëîÈëπÈî≠Èñ¢‰¶ßÈó¥Èò≥‰ß•Êû†‰®§ÈùÄ‰®µÈû≤ÈüÇÂôî‰´§ÊÉ®È¢π‰¨ôÈ£±Â°ÑÈ§éÈ§ôÂÜ¥È§úÈ§∑È•ÇÈ•ùÈ•¢‰≠∞ÈßÖ‰ÆùÈ®ºÈ¨èÁ™ÉÈ≠©ÈÆÅÈØùÈØ±ÈØ¥‰±≠È∞†„ùØ°ØÇÈµâÈ∞∫"],["9aa1","ÈªæÂôêÈ∂ìÈ∂ΩÈ∑ÄÈ∑ºÈì∂Ëæ∂ÈπªÈ∫¨È∫±È∫ΩÈªÜÈìúÈª¢Èª±Èª∏Á´àÈΩÑ†Çî†ä∑†é†Ê§öÈìÉÂ¶¨†ìóÂ°ÄÈìÅ„ûπ†óï†òï†ô∂°ö∫ÂùóÁÖ≥†´Ç†´ç†ÆøÂë™Ø†ª†ØãÂíû†Øª†∞ª†±ì†±•†±ºÊÉß†≤çÂô∫†≤µ†≥ù†≥≠†µØ†∂≤†∑àÊ•ïÈ∞ØËû•†∏Ñ†∏é†ªó†æê†º≠†π≥Â∞††æºÂ∏ã°Åú°Åè°Å∂Êúû°Åª°Çà°Çñ„ôá°Çø°Éì°ÑØ°ÑªÂç§Ëí≠°ã£°çµ°å∂ËÆÅ°ï∑°òô°üÉ°üá‰π∏ÁÇª°†≠°•™"],["9b40","°®≠°©Ö°∞™°±∞°≤¨°ªàÊãÉ°ªï°ºïÁÜòÊ°ï¢ÅÖÊß©„õà¢âº¢èó¢è∫¢ú™¢°±¢•èËãΩ¢•ß¢¶ì¢´ïË¶•¢´®Ëæ†¢¨éÈû∏¢¨øÈ°áÈ™Ω¢±å"],["9b62","¢≤à¢≤∑•Ø®¢¥à¢¥í¢∂∑¢∂ï¢πÇ¢Ω¥¢øå£Ä≥£Å¶£åü£èûÂæ±ÊôàÊöøß©π£ïß£ó≥ÁàÅ§¶∫Áüó£òö£úñÁ∫á†çÜÂ¢µÊúé"],["9ba1","Ê§ò£™ßßôó•ø¢£∏ë£∫πßóæ¢Çö‰£ê‰™∏§Ñô®™ö§ãÆ§åç§Äª§å¥§éñ§©Ö†óäÂáí†òëÂ¶ü°∫®„Ææ£≥ø§êÑ§ìñÂûà§ô¥„¶õ§úØ®ó®©ßâ„ù¢¢áÉË≠û®≠éÈßñ§†í§£ª§®ïÁàâ§´Ä†±∏Â••§∫•§æÜ†ùπËªö•Ä¨ÂäèÂúøÁÖ±•äô•êô£Ωä§™ßÂñº•ëÜ•ëÆ¶≠íÈáî„ë≥•îøßò≤•ïû‰úò•ï¢•ï¶•üá§§ø•°ùÂÅ¶„ìª£èåÊÉû•§É‰ùº®•à•™Æ•Æâ•∞Ü°∂êÂû°ÁÖëÊæ∂¶ÑÇß∞íÈÅñ¶Ü≤§æöË≠¢¶êÇ¶ëä"],["9c40","Âµõ¶Ø∑Ëº∂¶íÑ°§úË´™§ß∂¶íà£øØ¶îí‰ØÄ¶ñø¶öµ¢úõÈë••ü°ÊÜïÂ®ßØ£ç‰æªÂöπ§î°¶õº‰π™§§¥ÈôñÊ∂è¶≤Ω„òòË•∑¶ûô¶°Æ¶êë¶°ûÁáü¶£áÁ≠Ç©ÉÄ†®ë¶§¶ÈÑÑ¶§πÁ©ÖÈ∑∞¶ß∫È®¶¶®≠„ôü¶ë©†Ä°Á¶É¶®¥¶≠õÂ¥¨£îôËèè¶Æù‰õê¶≤§ÁîªË°•¶∂ÆÂ¢∂"],["9ca1","„úú¢ñçßÅãßáç„±îßäÄßäÖÈäÅ¢Ö∫ßäãÈå∞ßã¶§ßêÊ∞πÈíüßëê†ª∏Ë†ßË£µ¢§¶®ë≥°û±Ê∫∏§®™°††„¶§„öπÂ∞êÁß£‰îøÊö∂©≤≠©¢§Ë•Éßüåß°òÂõñ‰Éü°òä„¶°£úØ®É®°èÖÁÜ≠Ëç¶ßßù©Ü®Â©ß‰≤∑ßÇØ®¶´ßßΩß®äß¨ãßµ¶§Ö∫Á≠ÉÁ•æ®ÄâÊæµ™ãüÊ®É®åòÂé¢¶∏áÈéøÊ†∂Èùù®ÖØ®Ä£¶¶µ°è≠£àØ®ÅàÂ∂Ö®∞∞®ÇÉÂúïÈ†£®•âÂ∂´§¶àÊñæÊßïÂèí§™•£æÅ„∞ëÊú∂®Çê®É¥®ÑÆ°æ°®Öè"],["9d40","®Üâ®ÜØ®àö®åÜ®åØ®éä„óä®ë®®ö™‰£∫Êè¶®•ñÁ†àÈâï®¶∏‰è≤®ßß‰èü®ß®®≠Ü®ØîÂß∏®∞âËºã®øÖ©É¨Á≠ë©Ñê©Ñº„∑∑©Öû§´äËøêÁäèÂöã©ìß©ó©©ñ∞©ñ∏©ú≤©£ë©•â©•™©ßÉ©®®©¨é©µö©∂õÁ∫ü©ª∏©º£‰≤§Èïá™äìÁÜ¢™ãø‰∂ëÈÄí™óã‰∂ú†≤úËææÂóÅ"],["9da1","Ëæ∫¢í∞Ëæπ§™ì‰îâÁπøÊΩñÊ™±‰ª™„ì§®¨¨ß¢ù„ú∫Ë∫Ä°üµ®Ä§®≠¨®Æôß®æ¶öØ„∑´ßôï£≤∑•òµ••ñ‰∫ö•∫Å¶âòÂöø†π≠Ë∏éÂ≠≠£∫à§≤ûÊèûÊãê°ü∂°°ªÊî∞Âò≠•±äÂêö•åë„∑Ü©∂ò‰±ΩÂò¢ÂòûÁΩâ•ªòÂ•µ£µÄËù∞‰∏ú†ø™†µâ£ö∫ËÑóÈµûË¥òÁòªÈ±ÖÁôéÁûπÈçÖÂê≤ËÖàËã∑Âò•ËÑ≤ËêòËÇΩÂó™Á•¢ÂôÉÂêñ†∫ù„óéÂòÖÂó±Êõ±®ã¢„ò≠Áî¥Âó∞Âñ∫ÂíóÂï≤†±Å†≤ñÂªê•Öà†π∂¢±¢"],["9e40","†∫¢È∫´ÁµöÂóû°ÅµÊäùÈù≠ÂíîË≥çÁá∂ÈÖ∂ÊèºÊéπÊèæÂï©¢≠ÉÈ±≤¢∫≥ÂÜö„ìü†∂ßÂÜßÂëçÂîûÂîìÁô¶Ë∏≠¶¢äÁñ±ËÇ∂Ë†ÑËûÜË£áËÜ∂Ëêú°ÉÅ‰ì¨ÁåÑ§úÜÂÆêËåã¶¢ìÂôª¢õ¥ß¥Ø§Ü£ßµ≥¶ªêßä∂ÈÖ∞°áôÈàà£≥º™ö©†∫¨†ªπÁâ¶°≤¢‰ùé§øÇßøπ†ø´‰É∫"],["9ea1","È±ùÊîü¢∂†‰£≥§ü†©µº†ø¨†∏äÊÅ¢ßñ£†ø≠"],["9ead","¶Åà°ÜáÁÜ£Á∫éÈµê‰∏ö‰∏Ñ„ï∑Â¨çÊ≤≤Âçß„ö¨„ßúÂçΩ„ö•§òòÂ¢ö§≠ÆËà≠ÂëãÂû™•™ï†•π"],["9ec5","„©í¢ë•Áç¥©∫¨‰¥âÈØ≠£≥æ©º∞‰±õ§æ©©ñû©øûËëú£∂∂ßä≤¶û≥£ú†ÊåÆÁ¥•£ª∑£∏¨„®™ÈÄàÂãå„π¥„ô∫‰ó©†íéÁôÄÂ´∞†∫∂Á°∫ßºÆÂ¢ß‰ÇøÂôºÈÆãÂµ¥Áôî™ê¥È∫Ö‰≥°Áóπ„üªÊÑô£Éö§è≤"],["9ef5","Âôù°ä©Âûß§•£©∏ÜÂà¥ßÇÆ„ñ≠Ê±äÈµº"],["9f40","Á±ñÈ¨πÂüû°ù¨Â±ìÊìì©ìê¶åµßÖ§Ëö≠†¥®¶¥¢§´¢†µ±"],["9f4f","Âáæ°ºèÂ∂éÈúÉ°∑ëÈ∫ÅÈÅåÁ¨üÈ¨ÇÂ≥ëÁÆ£Êâ®ÊåµÈ´øÁØèÈ¨™Á±æÈ¨ÆÁ±ÇÁ≤ÜÈ∞ïÁØºÈ¨âÈºóÈ∞õ§§æÈΩöÂï≥ÂØÉ‰øΩÈ∫ò‰ø≤Ââ†„∏ÜÂãëÂùßÂÅñÂ¶∑Â∏íÈüàÈ∂´ËΩúÂë©Èû¥È•ÄÈû∫Âå¨ÊÑ∞"],["9fa1","Ê§¨ÂèöÈ∞äÈ¥Ç‰∞ªÈôÅÊ¶ÄÂÇ¶ÁïÜ°ù≠ÈßöÂâ≥"],["9fae","ÈÖôÈöÅÈÖú"],["9fb2","ÈÖë®∫óÊçø¶¥£Ê´äÂòëÈÜéÁï∫ÊäÖ†èºÁçèÁ±∞•∞°£≥Ω"],["9fc1","§§ôÁõñÈÆù‰∏™†≥îËéæË°Ç"],["9fc9","Â±äÊßÄÂÉ≠Âù∫ÂàüÂ∑µ‰ªéÊ∞±†á≤‰ºπÂíúÂìöÂäöË∂Ç„óæÂºå„ó≥"],["9fdb","Ê≠íÈÖºÈæ•ÈÆóÈ†ÆÈ¢¥È™∫È∫®È∫ÑÁÖ∫Á¨î"],["9fe7","ÊØ∫Ë†òÁΩ∏"],["9feb","Âò†™ôäËπ∑ÈΩì"],["9ff0","Ë∑îËπèÈ∏úË∏ÅÊäÇ®çΩË∏®ËπµÁ´ì§©∑Á®æÁ£òÊ≥™Ë©ßÁòá"],["a040","®©öÈº¶Ê≥éËüñÁóÉ™ä≤Á°ìØ°ÄË¥åÁã¢Áç±Ë¨≠ÁåÇÁì±Ë≥´§™ªËòØÂæ∫Ë¢†‰í∑"],["a055","°†ª¶∏Ö"],["a058","Ë©æ¢îõ"],["a05b","ÊÉΩÁôßÈ´óÈµÑÈçÆÈÆèËüµ"],["a063","Ë†èË≥∑Áå¨Èú°ÈÆ∞„óñÁä≤‰∞áÁ±ëÈ•ä¶ÖôÊÖô‰∞ÑÈ∫ñÊÖΩ"],["a073","ÂùüÊÖØÊä¶ÊàπÊãé„©úÊá¢Âé™£èµÊç§Ê†Ç„óí"],["a0a1","Âµó®ØÇËøö®∏π"],["a0a6","ÂÉô°µÜÁ§ÜÂå≤Èò∏†ºª‰Å•"],["a0ae","Áüæ"],["a0b0","Á≥Ç•ºöÁ≥öÁ®≠ËÅ¶ËÅ£ÁµçÁîÖÁì≤Ë¶îËàöÊúåËÅ¢ßíÜËÅõÁì∞ËÑÉÁú§Ë¶â¶üåÁïì¶ªëËû©ËüéËáàËûåË©âË≤≠Ë≠ÉÁú´Áì∏Ëìö„òµÊ¶≤Ë∂¶"],["a0d4","Ë¶©Áë®Ê∂πËüÅ§ÄëÁìß„∑õÁÖ∂ÊÇ§ÊÜú„≥ëÁÖ¢ÊÅ∑"],["a0e2","ÁΩ±®¨≠ÁâêÊÉ©‰≠æÂà†„∞ò£≥á•ªóßôñ•î±°•Ñ°ãæ©§É¶∑úßÇ≠Â≥Å¶Ü≠®®è£ô∑†ÉÆ¶°Ü§ºé‰ï¢Â¨ü¶çåÈΩêÈ∫¶¶â´"],["a3c0","‚êÄ",31,"‚ê°"],["c6a1","‚ë†",9,"‚ë¥",9,"‚Ö∞",9,"‰∏∂‰∏ø‰∫Ö‰∫†ÂÜÇÂÜñÂÜ´ÂãπÂå∏Âç©Âé∂Â§äÂÆÄÂ∑õ‚º≥ÂπøÂª¥ÂΩêÂΩ°Êî¥Êó†ÁñíÁô∂ËæµÈö∂¬®ÀÜ„ÉΩ„Éæ„Çù„Çû„ÄÉ‰ªù„ÄÖ„ÄÜ„Äá„ÉºÔºªÔºΩ‚úΩ„ÅÅ",23],["c740","„Åô",58,"„Ç°„Ç¢„Ç£„Ç§"],["c7a1","„Ç•",81,"–ê",5,"–Å–ñ",4],["c840","–õ",26,"—ë–∂",25,"‚áß‚Ü∏‚Üπ„áè†Éå‰πö†ÇäÂàÇ‰íë"],["c8a1","Èæ∞ÂÜàÈæ±ßòá"],["c8cd","Ôø¢Ôø§ÔºáÔºÇ„à±‚Ññ‚Ñ°„Çõ„Çú‚∫Ä‚∫Ñ‚∫Ü‚∫á‚∫à‚∫ä‚∫å‚∫ç‚∫ï‚∫ú‚∫ù‚∫•‚∫ß‚∫™‚∫¨‚∫Æ‚∫∂‚∫º‚∫æ‚ªÜ‚ªä‚ªå‚ªç‚ªè‚ªñ‚ªó‚ªû‚ª£"],["c8f5"," É…ê…õ…î…µ≈ì√∏≈ã ä…™"],["f9fe","Ôø≠"],["fa40","†ïáÈãõ†óü£øÖËïå‰äµÁèØÂÜµ„ôâ§•Ç®ß§ÈçÑ°ßõËãÆ£≥àÁ†ºÊùÑÊãü§§≥®¶™†ä†¶Æ≥°åÖ‰æ´¢ì≠ÂÄà¶¥©ß™Ñ£òÄ§™±¢îìÂÄ©†çæÂæ§†éÄ†çáÊªõ†êüÂÅΩÂÑÅ„ë∫ÂÑéÈ°¨„ùÉËêñ§¶§†íáÂÖ†£é¥ÂÖ™†Øø¢Éº†ã•¢î∞†ñé£à≥°¶ÉÂÆÇËùΩ†ñ≥£≤ôÂÜ≤ÂÜ∏"],["faa1","È¥¥ÂáâÂáèÂáë„≥úÂáì§™¶ÂÜ≥Âá¢ÂçÇÂá≠ËèçÊ§æ£ú≠ÂΩªÂàãÂà¶ÂàºÂäµÂâóÂäîÂäπÂãÖÁ∞ïËïÇÂã†Ëòç¶¨ìÂåÖ®´ûÂïâÊªô£æÄ†•î£ø¨Âå≥ÂçÑ†Ø¢Ê≥ã°ú¶Ê†õÁèïÊÅä„∫™„£å°õ®Ááù‰í¢Âç≠Âç¥®ö´ÂçæÂçø°ññ°òìÁü¶Âéì®™õÂé†Âé´ÂéÆÁéß•ù≤„ΩôÁéúÂèÅÂèÖÊ±â‰πâÂüæÂèô„™´†ÆèÂè†£ø´¢∂£Âè∂†±∑ÂêìÁÅπÂî´ÊôóÊµõÂë≠¶≠ì†µ¥ÂïùÂíèÂí§‰û¶°úç†ªù„∂¥†µç"],["fb40","®¶º¢öòÂïá‰≥≠ÂêØÁêóÂñÜÂñ©ÂòÖ°£ó§Ä∫‰ïí§êµÊö≥°Ç¥Âò∑Êõç£ääÊö§Êö≠ÂôçÂôèÁ£±Âõ±ÈûáÂèæÂúÄÂõØÂõ≠®≠¶„ò£°âèÂùÜ§Ü•Ê±ÆÁÇãÂùÇ„ö±¶±æÂü¶°êñÂ†É°ëî§ç£Â†¶§ØµÂ°úÂ¢™„ï°Â£†Â£ú°àºÂ£ªÂØøÂùÉ™Öê§â∏Èèì„ñ°Â§üÊ¢¶„õÉÊπô"],["fba1","°òæÂ®§Âïì°öíËîÖÂßâ†µé¶≤Å¶¥™°üúÂßô°üª°û≤¶∂¶Êµ±°†®°õïÂßπ¶πÖÂ™´Â©£„õ¶§¶©Â©∑„úàÂ™ñÁë•Â´ì¶æ°¢ïî„∂Ö°§ë„ú≤°ö∏Â∫ÉÂãêÂ≠∂ÊñàÂ≠ºß®é‰ÄÑ‰°ù†àÑÂØïÊÖ†°®¥•ßå†ñ•ÂØ≥ÂÆù‰¥êÂ∞Ö°≠ÑÂ∞ìÁèéÂ∞î°≤•¶¨®Â±â‰£ùÂ≤ÖÂ≥©Â≥ØÂ∂ã°∑π°∏∑Â¥êÂ¥òÂµÜ°∫§Â≤∫Â∑óËãº„†≠§§Å¢Åâ¢Ö≥Ëäá„†∂„ØÇÂ∏ÆÊ™äÂπµÂπ∫§íº†≥ìÂé¶‰∫∑ÂªêÂé®°ù±Â∏âÂª¥®íÇ"],["fc40","ÂªπÂªª„¢†ÂªºÊ†æÈêõÂºç†áÅØ¢î„´û‰¢Æ°å∫Âº∫¶¢à¢èêÂΩò¢ë±ÂΩ£ÈûΩ¶πÆÂΩ≤ÈçÄ®®∂ÂæßÂ∂∂„µü•âê°Ω™ßÉ∏¢ô®Èáñ†äû®®©ÊÄ±ÊöÖ°°∑„•£„∑á„òπÂûê¢û¥Á•±„πÄÊÇûÊÇ§ÊÇ≥§¶Ç§¶èß©ìÁí§ÂÉ°Â™†ÊÖ§Ëê§ÊÖÇØ¢¶¶ªíÊÜÅÂá¥†ôñÊÜáÂÆ™£æ∑"],["fca1","¢°üÊáì®Æù©•ùÊáê„§≤¢¶Ä¢£ÅÊÄ£ÊÖúÊîûÊéã†ÑòÊãÖ°ù∞Êãï¢∏çÊç¨§ßü„®óÊê∏Êè∏°éé°üºÊíêÊæä¢∏∂È†î§Çå•úùÊì°Êì•Èëª„©¶Êê∫„©óÊïçÊºñ§®®§®£ÊñÖÊï≠Êïü£ÅæÊñµ§•Ä‰¨∑Êóë‰Éò°†©Êó†Êó£Âøü£êÄÊòò£á∑£á∏ÊôÑ£Ü§£Ü•Êôã†πµÊôß•á¶Êô≥Êô¥°∏Ω£à±®ó¥£áà•åìÁüÖ¢£∑È¶§ÊúÇ§éú§®°„¨´Êß∫£üÇÊùûÊùßÊù¢§áç©É≠Êüó‰ì©Ê†¢ÊπêÈàºÊ†Å£è¶¶∂†Ê°ù"],["fd40","£ëØÊß°Ê®ã®´üÊ•≥Ê£É£óçÊ§ÅÊ§Ä„¥≤„®Å£òº„ÆÄÊû¨Ê•°®©ä‰ãºÊ§∂Ê¶ò„Æ°†èâËç£ÂÇêÊßπ£ôô¢Ñ™Ê©Ö£úÉÊ™ù„Ø≥Êû±Ê´à©Üú„∞çÊ¨ù†§£ÊÉûÊ¨µÊ≠¥¢üçÊ∫µ£´õ†éµ°•ò„ùÄÂê°£≠öÊØ°£ªºÊØúÊ∞∑¢íã§£±¶≠ëÊ±öËà¶Ê±π£∂º‰ìÖ£∂Ω§Ü§§§å§§Ä"],["fda1","£≥â„õ•„≥´†¥≤ÈÆÉ£áπ¢íëÁæèÊ†∑¶¥•¶∂°¶∑´Ê∂ñÊµúÊπºÊºÑ§•ø§ÇÖ¶π≤Ëî≥¶Ω¥ÂááÊ≤úÊ∏ùËêÆ®¨°Ê∏Ø£∏ØÁëì£æÇÁßåÊπèÂ™ë£ÅãÊø∏„úçÊæù£∏∞Êª∫°íó§ÄΩ‰ïïÈè∞ÊΩÑÊΩú„µéÊΩ¥©Ö∞„¥ªÊæü§ÖÑÊøì§Çë§Öï§Äπ£ø∞£æ¥§ÑøÂáü§Öñ§Öó§ÖÄ¶áùÁÅãÁÅæÁÇßÁÇÅÁÉåÁÉïÁÉñÁÉü‰ÑÑ„∑®ÁÜ¥ÁÜñ§â∑ÁÑ´ÁÖÖÂ™àÁÖäÁÖÆÂ≤ú§ç•ÁÖèÈç¢§ãÅÁÑ¨§ëö§®ß§®¢ÁÜ∫®Ø®ÁÇΩÁàé"],["fe40","ÈëÇÁàïÂ§ëÈëÉÁà§ÈçÅ•òÖÁàÆÁâÄ§•¥Ê¢ΩÁâïÁâó„πï£ÅÑÊ†çÊºΩÁäÇÁå™Áå´§†£®†´‰£≠®†ÑÁå®ÁåÆÁèèÁé™†∞∫¶®ÆÁèâÁëâ§á¢°õß§®§Êò£„õÖ§¶∑§¶ç§ßªÁè∑ÁêïÊ§É§®¶Áêπ†óÉ„ªóÁëú¢¢≠Áë†®∫≤ÁëáÁè§Áë∂ËéπÁë¨„ú∞Áë¥Èè±Ê®¨ÁíÇ‰•ì§™å"],["fea1","§Öü§©π®ÆèÂ≠Ü®∞É°¢ûÁìà°¶àÁîéÁì©Áîû®ªô°©ãÂØó®∫¨ÈéÖÁïçÁïäÁïßÁïÆ§æÇ„ºÑ§¥ìÁñéÁëùÁñûÁñ¥ÁòÇÁò¨ÁôëÁôèÁôØÁô∂¶èµÁöêËáØ„ü∏¶§ë¶§éÁö°Áö•Áö∑Áõå¶æüËë¢•Çù•ÖΩ°∏úÁúûÁú¶ÁùÄÊíØ•à†Áùò£ä¨ÁûØ®•§®•®°õÅÁü¥Á†â°ç∂§®íÊ£äÁ¢ØÁ£áÁ£ìÈö•Á§Æ•ó†Á£óÁ§¥Á¢±ßòåËæ∏Ë¢Ñ®¨´¶ÇÉ¢òúÁ¶ÜË§ÄÊ§ÇÁ¶Ä•°óÁ¶ùß¨πÁ§ºÁ¶©Ê∏™ßÑ¶„∫®ÁßÜ©ÑçÁßî"]]');

/***/ }),

/***/ 22787:
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('[["0","\\u0000",127,"‚Ç¨"],["8140","‰∏Ç‰∏Ñ‰∏Ö‰∏Ü‰∏è‰∏í‰∏ó‰∏ü‰∏†‰∏°‰∏£‰∏¶‰∏©‰∏Æ‰∏Ø‰∏±‰∏≥‰∏µ‰∏∑‰∏º‰πÄ‰πÅ‰πÇ‰πÑ‰πÜ‰πä‰πë‰πï‰πó‰πö‰πõ‰π¢‰π£‰π§‰π•‰πß‰π®‰π™",5,"‰π≤‰π¥",9,"‰πø",6,"‰∫á‰∫ä"],["8180","‰∫ê‰∫ñ‰∫ó‰∫ô‰∫ú‰∫ù‰∫û‰∫£‰∫™‰∫Ø‰∫∞‰∫±‰∫¥‰∫∂‰∫∑‰∫∏‰∫π‰∫º‰∫Ω‰∫æ‰ªà‰ªå‰ªè‰ªê‰ªí‰ªö‰ªõ‰ªú‰ª†‰ª¢‰ª¶‰ªß‰ª©‰ª≠‰ªÆ‰ªØ‰ª±‰ª¥‰ª∏‰ªπ‰ª∫‰ªº‰ªæ‰ºÄ‰ºÇ",6,"‰ºã‰ºå‰ºí",4,"‰ºú‰ºù‰º°‰º£‰º®‰º©‰º¨‰º≠‰ºÆ‰º±‰º≥‰ºµ‰º∑‰ºπ‰ºª‰ºæ",4,"‰ΩÑ‰ΩÖ‰Ωá",5,"‰Ωí‰Ωî‰Ωñ‰Ω°‰Ω¢‰Ω¶‰Ω®‰Ω™‰Ω´‰Ω≠‰ΩÆ‰Ω±‰Ω≤‰Ωµ‰Ω∑‰Ω∏‰Ωπ‰Ω∫‰ΩΩ‰æÄ‰æÅ‰æÇ‰æÖ‰æÜ‰æá‰æä‰æå‰æé‰æê‰æí‰æì‰æï‰æñ‰æò‰æô‰æö‰æú‰æû‰æü‰æ°‰æ¢"],["8240","‰æ§‰æ´‰æ≠‰æ∞",4,"‰æ∂",8,"‰øÄ‰øÅ‰øÇ‰øÜ‰øá‰øà‰øâ‰øã‰øå‰øç‰øí",4,"‰øô‰øõ‰ø†‰ø¢‰ø§‰ø•‰øß‰ø´‰ø¨‰ø∞‰ø≤‰ø¥‰øµ‰ø∂‰ø∑‰øπ‰øª‰øº‰øΩ‰øø",11],["8280","ÂÄãÂÄéÂÄêÂÄëÂÄìÂÄïÂÄñÂÄóÂÄõÂÄùÂÄûÂÄ†ÂÄ¢ÂÄ£ÂÄ§ÂÄßÂÄ´ÂÄØ",10,"ÂÄªÂÄΩÂÄøÂÅÄÂÅÅÂÅÇÂÅÑÂÅÖÂÅÜÂÅâÂÅäÂÅãÂÅçÂÅê",4,"ÂÅñÂÅóÂÅòÂÅôÂÅõÂÅù",7,"ÂÅ¶",5,"ÂÅ≠",8,"ÂÅ∏ÂÅπÂÅ∫ÂÅºÂÅΩÂÇÅÂÇÇÂÇÉÂÇÑÂÇÜÂÇáÂÇâÂÇäÂÇãÂÇåÂÇé",20,"ÂÇ§ÂÇ¶ÂÇ™ÂÇ´ÂÇ≠",4,"ÂÇ≥",6,"ÂÇº"],["8340","ÂÇΩ",17,"ÂÉê",5,"ÂÉóÂÉòÂÉôÂÉõ",10,"ÂÉ®ÂÉ©ÂÉ™ÂÉ´ÂÉØÂÉ∞ÂÉ±ÂÉ≤ÂÉ¥ÂÉ∂",4,"ÂÉº",9,"ÂÑà"],["8380","ÂÑâÂÑäÂÑå",5,"ÂÑì",13,"ÂÑ¢",28,"ÂÖÇÂÖáÂÖäÂÖåÂÖéÂÖèÂÖêÂÖíÂÖìÂÖóÂÖòÂÖôÂÖõÂÖù",4,"ÂÖ£ÂÖ§ÂÖ¶ÂÖßÂÖ©ÂÖ™ÂÖØÂÖ≤ÂÖ∫ÂÖæÂÖøÂÜÉÂÜÑÂÜÜÂÜáÂÜäÂÜãÂÜéÂÜèÂÜêÂÜëÂÜìÂÜîÂÜòÂÜöÂÜùÂÜûÂÜüÂÜ°ÂÜ£ÂÜ¶",4,"ÂÜ≠ÂÜÆÂÜ¥ÂÜ∏ÂÜπÂÜ∫ÂÜæÂÜøÂáÅÂáÇÂáÉÂáÖÂáàÂáäÂáçÂáéÂáêÂáí",5],["8440","ÂáòÂáôÂáöÂáúÂáûÂáüÂá¢Âá£Âá•",5,"Âá¨ÂáÆÂá±Âá≤Âá¥Âá∑ÂáæÂàÑÂàÖÂàâÂàãÂàåÂàèÂàêÂàìÂàîÂàïÂàúÂàûÂàüÂà°Âà¢Âà£Âà•Âà¶ÂàßÂà™Âà¨ÂàØÂà±Âà≤Âà¥ÂàµÂàºÂàæÂâÑ",5,"ÂâãÂâéÂâèÂâíÂâìÂâïÂâóÂâò"],["8480","ÂâôÂâöÂâõÂâùÂâüÂâ†Ââ¢Ââ£Ââ§Ââ¶Ââ®Ââ´Ââ¨Ââ≠ÂâÆÂâ∞Ââ±Ââ≥",9,"ÂâæÂäÄÂäÉ",4,"Âäâ",6,"ÂäëÂäíÂäî",6,"ÂäúÂä§Âä•Âä¶ÂäßÂäÆÂäØÂä∞Âä¥",9,"ÂãÄÂãÅÂãÇÂãÑÂãÖÂãÜÂãàÂãäÂãåÂãçÂãéÂãèÂãëÂãìÂãîÂãïÂãóÂãô",5,"Âã†Âã°Âã¢Âã£Âã•",10,"Âã±",7,"ÂãªÂãºÂãΩÂåÅÂåÇÂåÉÂåÑÂåáÂåâÂåäÂåãÂååÂåé"],["8540","ÂåëÂåíÂåìÂåîÂåòÂåõÂåúÂåûÂåüÂå¢Âå§Âå•ÂåßÂå®Âå©Âå´Âå¨Âå≠ÂåØ",9,"ÂåºÂåΩÂçÄÂçÇÂçÑÂçÜÂçãÂçåÂççÂçêÂçîÂçòÂçôÂçõÂçùÂç•Âç®Âç™Âç¨Âç≠Âç≤Âç∂ÂçπÂçªÂçºÂçΩÂçæÂéÄÂéÅÂéÉÂéáÂéàÂéäÂééÂéè"],["8580","Âéê",4,"ÂéñÂéóÂéôÂéõÂéúÂéûÂé†Âé°Âé§ÂéßÂé™Âé´Âé¨Âé≠ÂéØ",6,"Âé∑Âé∏ÂéπÂé∫ÂéºÂéΩÂéæÂèÄÂèÉ",4,"ÂèéÂèèÂèêÂèíÂèìÂèïÂèöÂèúÂèùÂèûÂè°Âè¢ÂèßÂè¥Âè∫ÂèæÂèøÂêÄÂêÇÂêÖÂêáÂêãÂêîÂêòÂêôÂêöÂêúÂê¢Âê§Âê•Âê™Âê∞Âê≥Âê∂Âê∑Âê∫ÂêΩÂêøÂëÅÂëÇÂëÑÂëÖÂëáÂëâÂëåÂëçÂëéÂëèÂëëÂëöÂëù",4,"Âë£Âë•ÂëßÂë©",7,"Âë¥ÂëπÂë∫ÂëæÂëøÂíÅÂíÉÂíÖÂíáÂíàÂíâÂíäÂíçÂíëÂíìÂíóÂíòÂíúÂíûÂíüÂí†Âí°"],["8640","Âí¢Âí•ÂíÆÂí∞Âí≤ÂíµÂí∂Âí∑ÂíπÂí∫ÂíºÂíæÂìÉÂìÖÂìäÂìãÂìñÂìòÂìõÂì†",4,"Âì´Âì¨ÂìØÂì∞Âì±Âì¥",5,"ÂìªÂìæÂîÄÂîÇÂîÉÂîÑÂîÖÂîàÂîä",4,"ÂîíÂîìÂîï",5,"ÂîúÂîùÂîûÂîüÂî°Âî•Âî¶"],["8680","Âî®Âî©Âî´Âî≠Âî≤Âî¥ÂîµÂî∂Âî∏ÂîπÂî∫ÂîªÂîΩÂïÄÂïÇÂïÖÂïáÂïàÂïã",4,"ÂïëÂïíÂïìÂïîÂïó",4,"ÂïùÂïûÂïüÂï†Âï¢Âï£Âï®Âï©Âï´ÂïØ",5,"ÂïπÂï∫ÂïΩÂïøÂñÖÂñÜÂñåÂñçÂñéÂñêÂñíÂñìÂñïÂññÂñóÂñöÂñõÂñûÂñ†",6,"Âñ®",8,"Âñ≤Âñ¥Âñ∂Âñ∏Âñ∫ÂñºÂñø",4,"ÂóÜÂóáÂóàÂóäÂóãÂóéÂóèÂóêÂóïÂóó",4,"ÂóûÂó†Âó¢ÂóßÂó©Âó≠ÂóÆÂó∞Âó±Âó¥Âó∂Âó∏",4,"ÂóøÂòÇÂòÉÂòÑÂòÖ"],["8740","ÂòÜÂòáÂòäÂòãÂòçÂòê",7,"ÂòôÂòöÂòúÂòùÂò†Âò°Âò¢Âò•Âò¶Âò®Âò©Âò™Âò´ÂòÆÂòØÂò∞Âò≥ÂòµÂò∑Âò∏Âò∫ÂòºÂòΩÂòæÂôÄ",11,"Âôè",4,"ÂôïÂôñÂôöÂôõÂôù",4],["8780","Âô£Âô•Âô¶ÂôßÂô≠ÂôÆÂôØÂô∞Âô≤Âô≥Âô¥ÂôµÂô∑Âô∏ÂôπÂô∫ÂôΩ",7,"Âöá",6,"ÂöêÂöëÂöíÂöî",14,"Âö§",10,"Âö∞",6,"Âö∏ÂöπÂö∫ÂöªÂöΩ",12,"Âõã",8,"ÂõïÂõñÂõòÂõôÂõúÂõ£Âõ•",5,"Âõ¨ÂõÆÂõØÂõ≤Âõ≥Âõ∂Âõ∑Âõ∏ÂõªÂõºÂúÄÂúÅÂúÇÂúÖÂúáÂúã",6],["8840","Âúí",9,"ÂúùÂúûÂú†Âú°Âú¢Âú§Âú•Âú¶ÂúßÂú´Âú±Âú≤Âú¥",4,"ÂúºÂúΩÂúøÂùÅÂùÉÂùÑÂùÖÂùÜÂùàÂùâÂùãÂùí",4,"ÂùòÂùôÂù¢Âù£Âù•ÂùßÂù¨ÂùÆÂù∞Âù±Âù≤Âù¥ÂùµÂù∏ÂùπÂù∫ÂùΩÂùæÂùøÂûÄ"],["8880","ÂûÅÂûáÂûàÂûâÂûäÂûç",4,"Âûî",6,"ÂûúÂûùÂûûÂûüÂû•Âû®Âû™Âû¨ÂûØÂû∞Âû±Âû≥ÂûµÂû∂Âû∑Âûπ",8,"ÂüÑ",6,"ÂüåÂüçÂüêÂüëÂüìÂüñÂüóÂüõÂüúÂüûÂü°Âü¢Âü£Âü•",7,"ÂüÆÂü∞Âü±Âü≤Âü≥ÂüµÂü∂Âü∑ÂüªÂüºÂüæÂüøÂ†ÅÂ†ÉÂ†ÑÂ†ÖÂ†àÂ†âÂ†äÂ†åÂ†éÂ†èÂ†êÂ†íÂ†ìÂ†îÂ†ñÂ†óÂ†òÂ†öÂ†õÂ†úÂ†ùÂ†üÂ†¢Â†£Â†•",4,"Â†´",4,"Â†±Â†≤Â†≥Â†¥Â†∂",7],["8940","Â†æ",5,"Â°Ö",6,"Â°éÂ°èÂ°êÂ°íÂ°ìÂ°ïÂ°ñÂ°óÂ°ô",4,"Â°ü",5,"Â°¶",4,"Â°≠",16,"Â°øÂ¢ÇÂ¢ÑÂ¢ÜÂ¢áÂ¢àÂ¢äÂ¢ãÂ¢å"],["8980","Â¢ç",4,"Â¢î",4,"Â¢õÂ¢úÂ¢ùÂ¢†",7,"Â¢™",17,"Â¢ΩÂ¢æÂ¢øÂ£ÄÂ£ÇÂ£ÉÂ£ÑÂ£Ü",10,"Â£íÂ£ìÂ£îÂ£ñ",13,"Â£•",5,"Â£≠Â£ØÂ£±Â£≤Â£¥Â£µÂ£∑Â£∏Â£∫",7,"Â§ÉÂ§ÖÂ§ÜÂ§à",4,"Â§éÂ§êÂ§ëÂ§íÂ§ìÂ§óÂ§òÂ§õÂ§ùÂ§ûÂ§†Â§°Â§¢Â§£Â§¶Â§®Â§¨Â§∞Â§≤Â§≥Â§µÂ§∂Â§ª"],["8a40","Â§ΩÂ§æÂ§øÂ•ÄÂ•ÉÂ•ÖÂ•ÜÂ•äÂ•åÂ•çÂ•êÂ•íÂ•ìÂ•ôÂ•õ",4,"Â•°Â•£Â•§Â•¶",12,"Â•µÂ•∑Â•∫Â•ªÂ•ºÂ•æÂ•øÂ¶ÄÂ¶ÖÂ¶âÂ¶ãÂ¶åÂ¶éÂ¶èÂ¶êÂ¶ëÂ¶îÂ¶ïÂ¶òÂ¶öÂ¶õÂ¶úÂ¶ùÂ¶üÂ¶†Â¶°Â¶¢Â¶¶"],["8a80","Â¶ßÂ¶¨Â¶≠Â¶∞Â¶±Â¶≥",5,"Â¶∫Â¶ºÂ¶ΩÂ¶ø",6,"ÂßáÂßàÂßâÂßåÂßçÂßéÂßèÂßïÂßñÂßôÂßõÂßû",4,"Âß§Âß¶ÂßßÂß©Âß™Âß´Âß≠",11,"Âß∫ÂßºÂßΩÂßæÂ®ÄÂ®ÇÂ®äÂ®ãÂ®çÂ®éÂ®èÂ®êÂ®íÂ®îÂ®ïÂ®ñÂ®óÂ®ôÂ®öÂ®õÂ®ùÂ®ûÂ®°Â®¢Â®§Â®¶Â®ßÂ®®Â®™",6,"Â®≥Â®µÂ®∑",4,"Â®ΩÂ®æÂ®øÂ©Å",4,"Â©áÂ©àÂ©ã",9,"Â©ñÂ©óÂ©òÂ©ôÂ©õ",5],["8b40","Â©°Â©£Â©§Â©•Â©¶Â©®Â©©Â©´",8,"Â©∏Â©πÂ©ªÂ©ºÂ©ΩÂ©æÂ™Ä",17,"Â™ì",6,"Â™ú",13,"Â™´Â™¨"],["8b80","Â™≠",4,"Â™¥Â™∂Â™∑Â™π",4,"Â™øÂ´ÄÂ´É",5,"Â´äÂ´ãÂ´ç",4,"Â´ìÂ´ïÂ´óÂ´ôÂ´öÂ´õÂ´ùÂ´ûÂ´üÂ´¢Â´§Â´•Â´ßÂ´®Â´™Â´¨",4,"Â´≤",22,"Â¨ä",11,"Â¨ò",25,"Â¨≥Â¨µÂ¨∂Â¨∏",7,"Â≠Å",6],["8c40","Â≠à",7,"Â≠íÂ≠ñÂ≠ûÂ≠†Â≠°Â≠ßÂ≠®Â≠´Â≠≠Â≠ÆÂ≠ØÂ≠≤Â≠¥Â≠∂Â≠∑Â≠∏Â≠πÂ≠ªÂ≠ºÂ≠æÂ≠øÂÆÇÂÆÜÂÆäÂÆçÂÆéÂÆêÂÆëÂÆíÂÆîÂÆñÂÆüÂÆßÂÆ®ÂÆ©ÂÆ¨ÂÆ≠ÂÆÆÂÆØÂÆ±ÂÆ≤ÂÆ∑ÂÆ∫ÂÆªÂÆºÂØÄÂØÅÂØÉÂØàÂØâÂØäÂØãÂØçÂØéÂØè"],["8c80","ÂØëÂØî",8,"ÂØ†ÂØ¢ÂØ£ÂØ¶ÂØßÂØ©",4,"ÂØØÂØ±",6,"ÂØΩÂØæÂ∞ÄÂ∞ÇÂ∞ÉÂ∞ÖÂ∞áÂ∞àÂ∞ãÂ∞åÂ∞çÂ∞éÂ∞êÂ∞íÂ∞ìÂ∞óÂ∞ôÂ∞õÂ∞ûÂ∞üÂ∞†Â∞°Â∞£Â∞¶Â∞®Â∞©Â∞™Â∞´Â∞≠Â∞ÆÂ∞ØÂ∞∞Â∞≤Â∞≥Â∞µÂ∞∂Â∞∑Â±ÉÂ±ÑÂ±ÜÂ±áÂ±åÂ±çÂ±íÂ±ìÂ±îÂ±ñÂ±óÂ±òÂ±öÂ±õÂ±úÂ±ùÂ±üÂ±¢Â±§Â±ß",6,"Â±∞Â±≤",6,"Â±ªÂ±ºÂ±ΩÂ±æÂ≤ÄÂ≤É",4,"Â≤âÂ≤äÂ≤ãÂ≤éÂ≤èÂ≤íÂ≤ìÂ≤ïÂ≤ù",4,"Â≤§",4],["8d40","Â≤™Â≤ÆÂ≤ØÂ≤∞Â≤≤Â≤¥Â≤∂Â≤πÂ≤∫Â≤ªÂ≤ºÂ≤æÂ≥ÄÂ≥ÇÂ≥ÉÂ≥Ö",5,"Â≥å",5,"Â≥ì",5,"Â≥ö",6,"Â≥¢Â≥£Â≥ßÂ≥©Â≥´Â≥¨Â≥ÆÂ≥ØÂ≥±",9,"Â≥º",4],["8d80","Â¥ÅÂ¥ÑÂ¥ÖÂ¥à",5,"Â¥è",4,"Â¥ïÂ¥óÂ¥òÂ¥ôÂ¥öÂ¥úÂ¥ùÂ¥ü",4,"Â¥•Â¥®Â¥™Â¥´Â¥¨Â¥Ø",4,"Â¥µ",7,"Â¥ø",7,"ÂµàÂµâÂµç",10,"ÂµôÂµöÂµúÂµû",10,"Âµ™Âµ≠ÂµÆÂµ∞Âµ±Âµ≤Âµ≥Âµµ",12,"Â∂É",21,"Â∂öÂ∂õÂ∂úÂ∂ûÂ∂üÂ∂†"],["8e40","Â∂°",21,"Â∂∏",12,"Â∑Ü",6,"Â∑é",12,"Â∑úÂ∑üÂ∑†Â∑£Â∑§Â∑™Â∑¨Â∑≠"],["8e80","Â∑∞Â∑µÂ∑∂Â∑∏",4,"Â∑øÂ∏ÄÂ∏ÑÂ∏áÂ∏âÂ∏äÂ∏ãÂ∏çÂ∏éÂ∏íÂ∏ìÂ∏óÂ∏û",7,"Â∏®",4,"Â∏ØÂ∏∞Â∏≤",4,"Â∏πÂ∏∫Â∏æÂ∏øÂπÄÂπÅÂπÉÂπÜ",5,"Âπç",6,"Âπñ",4,"ÂπúÂπùÂπüÂπ†Âπ£",14,"ÂπµÂπ∑ÂππÂπæÂ∫ÅÂ∫ÇÂ∫ÉÂ∫ÖÂ∫àÂ∫âÂ∫åÂ∫çÂ∫éÂ∫íÂ∫òÂ∫õÂ∫ùÂ∫°Â∫¢Â∫£Â∫§Â∫®",4,"Â∫Æ",4,"Â∫¥Â∫∫Â∫ªÂ∫ºÂ∫ΩÂ∫ø",6],["8f40","ÂªÜÂªáÂªàÂªã",5,"ÂªîÂªïÂªóÂªòÂªôÂªöÂªú",11,"Âª©Âª´",8,"ÂªµÂª∏ÂªπÂªªÂªºÂªΩÂºÖÂºÜÂºáÂºâÂºåÂºçÂºéÂºêÂºíÂºîÂºñÂºôÂºöÂºúÂºùÂºûÂº°Âº¢Âº£Âº§"],["8f80","Âº®Âº´Âº¨ÂºÆÂº∞Âº≤",6,"ÂºªÂºΩÂºæÂºøÂΩÅ",14,"ÂΩëÂΩîÂΩôÂΩöÂΩõÂΩúÂΩûÂΩüÂΩ†ÂΩ£ÂΩ•ÂΩßÂΩ®ÂΩ´ÂΩÆÂΩØÂΩ≤ÂΩ¥ÂΩµÂΩ∂ÂΩ∏ÂΩ∫ÂΩΩÂΩæÂΩøÂæÉÂæÜÂæçÂæéÂæèÂæëÂæìÂæîÂæñÂæöÂæõÂæùÂæûÂæüÂæ†Âæ¢",5,"Âæ©Âæ´Âæ¨ÂæØ",5,"Âæ∂Âæ∏ÂæπÂæ∫ÂæªÂææ",4,"ÂøáÂøàÂøäÂøãÂøéÂøìÂøîÂøïÂøöÂøõÂøúÂøûÂøüÂø¢Âø£Âø•Âø¶Âø®Âø©Âø¨ÂøØÂø∞Âø≤Âø≥Âø¥Âø∂Âø∑ÂøπÂø∫ÂøºÊÄá"],["9040","ÊÄàÊÄâÊÄãÊÄåÊÄêÊÄëÊÄìÊÄóÊÄòÊÄöÊÄûÊÄüÊÄ¢ÊÄ£ÊÄ§ÊÄ¨ÊÄ≠ÊÄÆÊÄ∞",4,"ÊÄ∂",4,"ÊÄΩÊÄæÊÅÄÊÅÑ",6,"ÊÅåÊÅéÊÅèÊÅëÊÅìÊÅîÊÅñÊÅóÊÅòÊÅõÊÅúÊÅûÊÅüÊÅ†ÊÅ°ÊÅ•ÊÅ¶ÊÅÆÊÅ±ÊÅ≤ÊÅ¥ÊÅµÊÅ∑ÊÅæÊÇÄ"],["9080","ÊÇÅÊÇÇÊÇÖÊÇÜÊÇáÊÇàÊÇäÊÇãÊÇéÊÇèÊÇêÊÇëÊÇìÊÇïÊÇóÊÇòÊÇôÊÇúÊÇûÊÇ°ÊÇ¢ÊÇ§ÊÇ•ÊÇßÊÇ©ÊÇ™ÊÇÆÊÇ∞ÊÇ≥ÊÇµÊÇ∂ÊÇ∑ÊÇπÊÇ∫ÊÇΩ",7,"ÊÉáÊÉàÊÉâÊÉå",4,"ÊÉíÊÉìÊÉîÊÉñÊÉóÊÉôÊÉõÊÉûÊÉ°",4,"ÊÉ™ÊÉ±ÊÉ≤ÊÉµÊÉ∑ÊÉ∏ÊÉª",4,"ÊÑÇÊÑÉÊÑÑÊÑÖÊÑáÊÑäÊÑãÊÑåÊÑê",4,"ÊÑñÊÑóÊÑòÊÑôÊÑõÊÑúÊÑùÊÑûÊÑ°ÊÑ¢ÊÑ•ÊÑ®ÊÑ©ÊÑ™ÊÑ¨",18,"ÊÖÄ",6],["9140","ÊÖáÊÖâÊÖãÊÖçÊÖèÊÖêÊÖíÊÖìÊÖîÊÖñ",6,"ÊÖûÊÖüÊÖ†ÊÖ°ÊÖ£ÊÖ§ÊÖ•ÊÖ¶ÊÖ©",6,"ÊÖ±ÊÖ≤ÊÖ≥ÊÖ¥ÊÖ∂ÊÖ∏",18,"ÊÜåÊÜçÊÜè",4,"ÊÜï"],["9180","ÊÜñ",6,"ÊÜû",8,"ÊÜ™ÊÜ´ÊÜ≠",9,"ÊÜ∏",5,"ÊÜøÊáÄÊáÅÊáÉ",4,"ÊáâÊáå",4,"ÊáìÊáï",16,"Êáß",13,"Êá∂",8,"ÊàÄ",5,"ÊàáÊàâÊàìÊàîÊàôÊàúÊàùÊàûÊà†Êà£Êà¶ÊàßÊà®Êà©Êà´Êà≠ÊàØÊà∞Êà±Êà≤ÊàµÊà∂Êà∏",4,"ÊâÇÊâÑÊâÖÊâÜÊâä"],["9240","ÊâèÊâêÊâïÊâñÊâóÊâôÊâöÊâú",6,"Êâ§Êâ•Êâ®Êâ±Êâ≤Êâ¥ÊâµÊâ∑Êâ∏Êâ∫ÊâªÊâΩÊäÅÊäÇÊäÉÊäÖÊäÜÊäáÊäàÊäã",5,"ÊäîÊäôÊäúÊäùÊäûÊä£Êä¶ÊäßÊä©Êä™Êä≠ÊäÆÊäØÊä∞Êä≤Êä≥Êä¥Êä∂Êä∑Êä∏Êä∫ÊäæÊãÄÊãÅ"],["9280","ÊãÉÊããÊãèÊãëÊãïÊãùÊãûÊã†Êã°Êã§Êã™Êã´Êã∞Êã≤ÊãµÊã∏ÊãπÊã∫ÊãªÊåÄÊåÉÊåÑÊåÖÊåÜÊåäÊåãÊååÊåçÊåèÊåêÊåíÊåìÊåîÊåïÊåóÊåòÊåôÊåúÊå¶ÊåßÊå©Êå¨Êå≠ÊåÆÊå∞Êå±Êå≥",5,"ÊåªÊåºÊåæÊåøÊçÄÊçÅÊçÑÊçáÊçàÊçäÊçëÊçíÊçìÊçîÊçñ",7,"Êç†Êç§Êç•Êç¶Êç®Êç™Êç´Êç¨ÊçØÊç∞Êç≤Êç≥Êç¥ÊçµÊç∏ÊçπÊçºÊçΩÊçæÊçøÊéÅÊéÉÊéÑÊéÖÊéÜÊéãÊéçÊéëÊéìÊéîÊéïÊéóÊéô",6,"Êé°Êé§Êé¶Êé´ÊéØÊé±Êé≤ÊéµÊé∂ÊéπÊéªÊéΩÊéøÊèÄ"],["9340","ÊèÅÊèÇÊèÉÊèÖÊèáÊèàÊèäÊèãÊèåÊèëÊèìÊèîÊèïÊèó",6,"ÊèüÊè¢Êè§",4,"Êè´Êè¨ÊèÆÊèØÊè∞Êè±Êè≥ÊèµÊè∑ÊèπÊè∫ÊèªÊèºÊèæÊêÉÊêÑÊêÜ",4,"ÊêçÊêéÊêëÊêíÊêï",5,"ÊêùÊêüÊê¢Êê£Êê§"],["9380","Êê•ÊêßÊê®Êê©Êê´ÊêÆ",5,"Êêµ",4,"ÊêªÊêºÊêæÊëÄÊëÇÊëÉÊëâÊëã",6,"ÊëìÊëïÊëñÊëóÊëô",4,"Êëü",7,"Êë®Êë™Êë´Êë¨ÊëÆ",9,"Êëª",6,"ÊíÉÊíÜÊíà",8,"ÊíìÊíîÊíóÊíòÊíöÊíõÊíúÊíùÊíü",4,"Êí•Êí¶ÊíßÊí®Êí™Êí´ÊíØÊí±Êí≤Êí≥Êí¥Êí∂ÊíπÊíªÊíΩÊíæÊíøÊìÅÊìÉÊìÑÊìÜ",6,"ÊìèÊìëÊììÊìîÊìïÊìñÊìôÊìö"],["9440","ÊìõÊìúÊìùÊìüÊì†Êì°Êì£Êì•Êìß",24,"ÊîÅ",7,"Êîä",7,"Êîì",4,"Êîô",8],["9480","Êî¢Êî£Êî§Êî¶",4,"Êî¨Êî≠Êî∞Êî±Êî≤Êî≥Êî∑Êî∫ÊîºÊîΩÊïÄ",4,"ÊïÜÊïáÊïäÊïãÊïçÊïéÊïêÊïíÊïìÊïîÊïóÊïòÊïöÊïúÊïüÊï†Êï°Êï§Êï•ÊïßÊï®Êï©Êï™Êï≠ÊïÆÊïØÊï±Êï≥ÊïµÊï∂Êï∏",14,"ÊñàÊñâÊñäÊñçÊñéÊñèÊñíÊñîÊñïÊññÊñòÊñöÊñùÊñûÊñ†Êñ¢Êñ£Êñ¶Êñ®Êñ™Êñ¨ÊñÆÊñ±",7,"Êñ∫ÊñªÊñæÊñøÊóÄÊóÇÊóáÊóàÊóâÊóäÊóçÊóêÊóëÊóìÊóîÊóïÊóò",7,"Êó°Êó£Êó§Êó™Êó´"],["9540","Êó≤Êó≥Êó¥ÊóµÊó∏ÊóπÊóª",4,"ÊòÅÊòÑÊòÖÊòáÊòàÊòâÊòãÊòçÊòêÊòëÊòíÊòñÊòóÊòòÊòöÊòõÊòúÊòûÊò°Êò¢Êò£Êò§Êò¶Êò©Êò™Êò´Êò¨ÊòÆÊò∞Êò≤Êò≥Êò∑",4,"ÊòΩÊòøÊôÄÊôÇÊôÑ",6,"ÊôçÊôéÊôêÊôëÊôò"],["9580","ÊôôÊôõÊôúÊôùÊôûÊô†Êô¢Êô£Êô•ÊôßÊô©",4,"Êô±Êô≤Êô≥ÊôµÊô∏ÊôπÊôªÊôºÊôΩÊôøÊöÄÊöÅÊöÉÊöÖÊöÜÊöàÊöâÊöäÊöãÊöçÊöéÊöèÊöêÊöíÊöìÊöîÊöïÊöò",4,"Êöû",8,"Êö©",4,"ÊöØ",4,"ÊöµÊö∂Êö∑Êö∏Êö∫ÊöªÊöºÊöΩÊöø",25,"ÊõöÊõû",7,"ÊõßÊõ®Êõ™",5,"Êõ±ÊõµÊõ∂Êõ∏Êõ∫ÊõªÊõΩÊúÅÊúÇÊúÉ"],["9640","ÊúÑÊúÖÊúÜÊúáÊúåÊúéÊúèÊúëÊúíÊúìÊúñÊúòÊúôÊúöÊúúÊúûÊú†",5,"ÊúßÊú©ÊúÆÊú∞Êú≤Êú≥Êú∂Êú∑Êú∏ÊúπÊúªÊúºÊúæÊúøÊùÅÊùÑÊùÖÊùáÊùäÊùãÊùçÊùíÊùîÊùïÊùó",4,"ÊùùÊù¢Êù£Êù§Êù¶ÊùßÊù´Êù¨ÊùÆÊù±Êù¥Êù∂"],["9680","Êù∏ÊùπÊù∫ÊùªÊùΩÊûÄÊûÇÊûÉÊûÖÊûÜÊûàÊûäÊûåÊûçÊûéÊûèÊûëÊûíÊûìÊûîÊûñÊûôÊûõÊûüÊû†Êû°Êû§Êû¶Êû©Êû¨ÊûÆÊû±Êû≤Êû¥Êûπ",7,"ÊüÇÊüÖ",9,"ÊüïÊüñÊüóÊüõÊüüÊü°Êü£Êü§Êü¶ÊüßÊü®Êü™Êü´Êü≠ÊüÆÊü≤Êüµ",7,"ÊüæÊ†ÅÊ†ÇÊ†ÉÊ†ÑÊ†ÜÊ†çÊ†êÊ†íÊ†îÊ†ïÊ†ò",4,"Ê†ûÊ†üÊ††Ê†¢",6,"Ê†´",6,"Ê†¥Ê†µÊ†∂Ê†∫Ê†ªÊ†øÊ°áÊ°ãÊ°çÊ°èÊ°íÊ°ñ",5],["9740","Ê°úÊ°ùÊ°ûÊ°üÊ°™Ê°¨",7,"Ê°µÊ°∏",8,"Ê¢ÇÊ¢ÑÊ¢á",7,"Ê¢êÊ¢ëÊ¢íÊ¢îÊ¢ïÊ¢ñÊ¢ò",9,"Ê¢£Ê¢§Ê¢•Ê¢©Ê¢™Ê¢´Ê¢¨Ê¢ÆÊ¢±Ê¢≤Ê¢¥Ê¢∂Ê¢∑Ê¢∏"],["9780","Ê¢π",6,"Ê£ÅÊ£É",5,"Ê£äÊ£åÊ£éÊ£èÊ£êÊ£ëÊ£ìÊ£îÊ£ñÊ£óÊ£ôÊ£õ",4,"Ê£°Ê£¢Ê£§",9,"Ê£ØÊ£≤Ê£≥Ê£¥Ê£∂Ê£∑Ê£∏Ê£ªÊ£ΩÊ£æÊ£øÊ§ÄÊ§ÇÊ§ÉÊ§ÑÊ§Ü",4,"Ê§åÊ§èÊ§ëÊ§ì",11,"Ê§°Ê§¢Ê§£Ê§•",7,"Ê§ÆÊ§ØÊ§±Ê§≤Ê§≥Ê§µÊ§∂Ê§∑Ê§∏Ê§∫Ê§ªÊ§ºÊ§æÊ•ÄÊ•ÅÊ•É",16,"Ê•ïÊ•ñÊ•òÊ•ôÊ•õÊ•úÊ•ü"],["9840","Ê•°Ê•¢Ê•§Ê••Ê•ßÊ•®Ê•©Ê•™Ê•¨Ê•≠Ê•ØÊ•∞Ê•≤",4,"Ê•∫Ê•ªÊ•ΩÊ•æÊ•øÊ¶ÅÊ¶ÉÊ¶ÖÊ¶äÊ¶ãÊ¶åÊ¶é",5,"Ê¶ñÊ¶óÊ¶ôÊ¶öÊ¶ù",9,"Ê¶©Ê¶™Ê¶¨Ê¶ÆÊ¶ØÊ¶∞Ê¶≤Ê¶≥Ê¶µÊ¶∂Ê¶∏Ê¶πÊ¶∫Ê¶ºÊ¶Ω"],["9880","Ê¶æÊ¶øÊßÄÊßÇ",7,"ÊßãÊßçÊßèÊßëÊßíÊßìÊßï",5,"ÊßúÊßùÊßûÊß°",11,"ÊßÆÊßØÊß∞Êß±Êß≥",9,"ÊßæÊ®Ä",9,"Ê®ã",11,"Ê®ô",5,"Ê®†Ê®¢",5,"Ê®©Ê®´Ê®¨Ê®≠Ê®ÆÊ®∞Ê®≤Ê®≥Ê®¥Ê®∂",6,"Ê®ø",4,"Ê©ÖÊ©ÜÊ©à",7,"Ê©ë",6,"Ê©ö"],["9940","Ê©ú",4,"Ê©¢Ê©£Ê©§Ê©¶",10,"Ê©≤",6,"Ê©∫Ê©ªÊ©ΩÊ©æÊ©øÊ™ÅÊ™ÇÊ™ÉÊ™Ö",8,"Ê™èÊ™í",4,"Ê™ò",7,"Ê™°",5],["9980","Ê™ßÊ™®Ê™™Ê™≠",114,"Ê¨•Ê¨¶Ê¨®",6],["9a40","Ê¨ØÊ¨∞Ê¨±Ê¨≥Ê¨¥Ê¨µÊ¨∂Ê¨∏Ê¨ªÊ¨ºÊ¨ΩÊ¨øÊ≠ÄÊ≠ÅÊ≠ÇÊ≠ÑÊ≠ÖÊ≠àÊ≠äÊ≠ãÊ≠ç",11,"Ê≠ö",7,"Ê≠®Ê≠©Ê≠´",13,"Ê≠∫Ê≠ΩÊ≠æÊ≠øÊÆÄÊÆÖÊÆà"],["9a80","ÊÆåÊÆéÊÆèÊÆêÊÆëÊÆîÊÆïÊÆóÊÆòÊÆôÊÆú",4,"ÊÆ¢",7,"ÊÆ´",7,"ÊÆ∂ÊÆ∏",6,"ÊØÄÊØÉÊØÑÊØÜ",4,"ÊØåÊØéÊØêÊØëÊØòÊØöÊØú",4,"ÊØ¢",7,"ÊØ¨ÊØ≠ÊØÆÊØ∞ÊØ±ÊØ≤ÊØ¥ÊØ∂ÊØ∑ÊØ∏ÊØ∫ÊØªÊØºÊØæ",6,"Ê∞à",4,"Ê∞éÊ∞íÊ∞óÊ∞úÊ∞ùÊ∞ûÊ∞†Ê∞£Ê∞•Ê∞´Ê∞¨Ê∞≠Ê∞±Ê∞≥Ê∞∂Ê∞∑Ê∞πÊ∞∫Ê∞ªÊ∞ºÊ∞æÊ∞øÊ±ÉÊ±ÑÊ±ÖÊ±àÊ±ã",4,"Ê±ëÊ±íÊ±ìÊ±ñÊ±ò"],["9b40","Ê±ôÊ±öÊ±¢Ê±£Ê±•Ê±¶Ê±ßÊ±´",4,"Ê±±Ê±≥Ê±µÊ±∑Ê±∏Ê±∫Ê±ªÊ±ºÊ±øÊ≤ÄÊ≤ÑÊ≤áÊ≤äÊ≤ãÊ≤çÊ≤éÊ≤ëÊ≤íÊ≤ïÊ≤ñÊ≤óÊ≤òÊ≤öÊ≤úÊ≤ùÊ≤ûÊ≤†Ê≤¢Ê≤®Ê≤¨Ê≤ØÊ≤∞Ê≤¥Ê≤µÊ≤∂Ê≤∑Ê≤∫Ê≥ÄÊ≥ÅÊ≥ÇÊ≥ÉÊ≥ÜÊ≥áÊ≥àÊ≥ãÊ≥çÊ≥éÊ≥èÊ≥ëÊ≥íÊ≥ò"],["9b80","Ê≥ôÊ≥öÊ≥úÊ≥ùÊ≥üÊ≥§Ê≥¶Ê≥ßÊ≥©Ê≥¨Ê≥≠Ê≥≤Ê≥¥Ê≥πÊ≥øÊ¥ÄÊ¥ÇÊ¥ÉÊ¥ÖÊ¥ÜÊ¥àÊ¥âÊ¥äÊ¥çÊ¥èÊ¥êÊ¥ëÊ¥ìÊ¥îÊ¥ïÊ¥ñÊ¥òÊ¥úÊ¥ùÊ¥ü",5,"Ê¥¶Ê¥®Ê¥©Ê¥¨Ê¥≠Ê¥ØÊ¥∞Ê¥¥Ê¥∂Ê¥∑Ê¥∏Ê¥∫Ê¥øÊµÄÊµÇÊµÑÊµâÊµåÊµêÊµïÊµñÊµóÊµòÊµõÊµùÊµüÊµ°Êµ¢Êµ§Êµ•ÊµßÊµ®Êµ´Êµ¨Êµ≠Êµ∞Êµ±Êµ≤Êµ≥ÊµµÊµ∂ÊµπÊµ∫ÊµªÊµΩ",4,"Ê∂ÉÊ∂ÑÊ∂ÜÊ∂áÊ∂äÊ∂ãÊ∂çÊ∂èÊ∂êÊ∂íÊ∂ñ",4,"Ê∂úÊ∂¢Ê∂•Ê∂¨Ê∂≠Ê∂∞Ê∂±Ê∂≥Ê∂¥Ê∂∂Ê∂∑Ê∂π",5,"Ê∑ÅÊ∑ÇÊ∑ÉÊ∑àÊ∑âÊ∑ä"],["9c40","Ê∑çÊ∑éÊ∑èÊ∑êÊ∑íÊ∑ìÊ∑îÊ∑ïÊ∑óÊ∑öÊ∑õÊ∑úÊ∑üÊ∑¢Ê∑£Ê∑•Ê∑ßÊ∑®Ê∑©Ê∑™Ê∑≠Ê∑ØÊ∑∞Ê∑≤Ê∑¥Ê∑µÊ∑∂Ê∑∏Ê∑∫Ê∑Ω",7,"Ê∏ÜÊ∏áÊ∏àÊ∏âÊ∏ãÊ∏èÊ∏íÊ∏ìÊ∏ïÊ∏òÊ∏ôÊ∏õÊ∏úÊ∏ûÊ∏üÊ∏¢Ê∏¶Ê∏ßÊ∏®Ê∏™Ê∏¨Ê∏ÆÊ∏∞Ê∏±Ê∏≥Ê∏µ"],["9c80","Ê∏∂Ê∏∑Ê∏πÊ∏ª",7,"ÊπÖ",7,"ÊπèÊπêÊπëÊπíÊπïÊπóÊπôÊπöÊπúÊπùÊπûÊπ†",10,"Êπ¨Êπ≠ÊπØ",14,"Ê∫ÄÊ∫ÅÊ∫ÇÊ∫ÑÊ∫áÊ∫àÊ∫ä",4,"Ê∫ë",6,"Ê∫ôÊ∫öÊ∫õÊ∫ùÊ∫ûÊ∫†Ê∫°Ê∫£Ê∫§Ê∫¶Ê∫®Ê∫©Ê∫´Ê∫¨Ê∫≠Ê∫ÆÊ∫∞Ê∫≥Ê∫µÊ∫∏Ê∫πÊ∫ºÊ∫æÊ∫øÊªÄÊªÉÊªÑÊªÖÊªÜÊªàÊªâÊªäÊªåÊªçÊªéÊªêÊªíÊªñÊªòÊªôÊªõÊªúÊªùÊª£ÊªßÊª™",5],["9d40","Êª∞Êª±Êª≤Êª≥ÊªµÊª∂Êª∑Êª∏Êª∫",7,"ÊºÉÊºÑÊºÖÊºáÊºàÊºä",4,"ÊºêÊºëÊºíÊºñ",9,"Êº°Êº¢Êº£Êº•Êº¶ÊºßÊº®Êº¨ÊºÆÊº∞Êº≤Êº¥ÊºµÊº∑",6,"ÊºøÊΩÄÊΩÅÊΩÇ"],["9d80","ÊΩÉÊΩÑÊΩÖÊΩàÊΩâÊΩäÊΩåÊΩé",9,"ÊΩôÊΩöÊΩõÊΩùÊΩüÊΩ†ÊΩ°ÊΩ£ÊΩ§ÊΩ•ÊΩß",5,"ÊΩØÊΩ∞ÊΩ±ÊΩ≥ÊΩµÊΩ∂ÊΩ∑ÊΩπÊΩªÊΩΩ",6,"ÊæÖÊæÜÊæáÊæäÊæãÊæè",12,"ÊæùÊæûÊæüÊæ†Êæ¢",4,"Êæ®",10,"Êæ¥ÊæµÊæ∑Êæ∏Êæ∫",5,"ÊøÅÊøÉ",5,"Êøä",6,"Êøì",10,"ÊøüÊø¢Êø£Êø§Êø•"],["9e40","Êø¶",7,"Êø∞",32,"ÁÄí",7,"ÁÄú",6,"ÁÄ§",6],["9e80","ÁÄ´",9,"ÁÄ∂ÁÄ∑ÁÄ∏ÁÄ∫",17,"ÁÅçÁÅéÁÅê",13,"ÁÅü",11,"ÁÅÆÁÅ±ÁÅ≤ÁÅ≥ÁÅ¥ÁÅ∑ÁÅπÁÅ∫ÁÅªÁÅΩÁÇÅÁÇÇÁÇÉÁÇÑÁÇÜÁÇáÁÇàÁÇãÁÇåÁÇçÁÇèÁÇêÁÇëÁÇìÁÇóÁÇòÁÇöÁÇõÁÇû",12,"ÁÇ∞ÁÇ≤ÁÇ¥ÁÇµÁÇ∂ÁÇ∫ÁÇæÁÇøÁÉÑÁÉÖÁÉÜÁÉáÁÉâÁÉã",12,"ÁÉö"],["9f40","ÁÉúÁÉùÁÉûÁÉ†ÁÉ°ÁÉ¢ÁÉ£ÁÉ•ÁÉ™ÁÉÆÁÉ∞",6,"ÁÉ∏ÁÉ∫ÁÉªÁÉºÁÉæ",10,"ÁÑã",4,"ÁÑëÁÑíÁÑîÁÑóÁÑõ",10,"ÁÑß",7,"ÁÑ≤ÁÑ≥ÁÑ¥"],["9f80","ÁÑµÁÑ∑",13,"ÁÖÜÁÖáÁÖàÁÖâÁÖãÁÖçÁÖè",12,"ÁÖùÁÖü",4,"ÁÖ•ÁÖ©",4,"ÁÖØÁÖ∞ÁÖ±ÁÖ¥ÁÖµÁÖ∂ÁÖ∑ÁÖπÁÖªÁÖºÁÖæ",5,"ÁÜÖ",4,"ÁÜãÁÜåÁÜçÁÜéÁÜêÁÜëÁÜíÁÜìÁÜïÁÜñÁÜóÁÜö",4,"ÁÜ°",6,"ÁÜ©ÁÜ™ÁÜ´ÁÜ≠",5,"ÁÜ¥ÁÜ∂ÁÜ∑ÁÜ∏ÁÜ∫",8,"ÁáÑ",9,"Ááè",4],["a040","Ááñ",9,"Áá°Áá¢Áá£Áá§Áá¶Áá®",5,"ÁáØ",9,"Áá∫",11,"Áàá",19],["a080","ÁàõÁàúÁàû",9,"Áà©Áà´Áà≠ÁàÆÁàØÁà≤Áà≥Áà¥Áà∫ÁàºÁàæÁâÄ",6,"ÁââÁâäÁâãÁâéÁâèÁâêÁâëÁâìÁâîÁâïÁâóÁâòÁâöÁâúÁâûÁâ†Áâ£Áâ§Áâ•Áâ®Áâ™Áâ´Áâ¨Áâ≠Áâ∞Áâ±Áâ≥Áâ¥Áâ∂Áâ∑Áâ∏ÁâªÁâºÁâΩÁäÇÁäÉÁäÖ",4,"ÁäåÁäéÁäêÁäëÁäì",11,"Áä†",11,"ÁäÆÁä±Áä≤Áä≥ÁäµÁä∫",6,"ÁãÖÁãÜÁãáÁãâÁãäÁããÁãåÁãèÁãëÁãìÁãîÁãïÁãñÁãòÁãöÁãõ"],["a1a1","„ÄÄ„ÄÅ„ÄÇ¬∑ÀâÀá¬®„ÄÉ„ÄÖ‚ÄîÔΩû‚Äñ‚Ä¶‚Äò‚Äô‚Äú‚Äù„Äî„Äï„Äà",7,"„Äñ„Äó„Äê„Äë¬±√ó√∑‚à∂‚àß‚à®‚àë‚àè‚à™‚à©‚àà‚à∑‚àö‚ä•‚à•‚à†‚åí‚äô‚à´‚àÆ‚â°‚âå‚âà‚àΩ‚àù‚â†‚âÆ‚âØ‚â§‚â•‚àû‚àµ‚à¥‚ôÇ‚ôÄ¬∞‚Ä≤‚Ä≥‚ÑÉÔºÑ¬§Ôø†Ôø°‚Ä∞¬ß‚Ññ‚òÜ‚òÖ‚óã‚óè‚óé‚óá‚óÜ‚ñ°‚ñ†‚ñ≥‚ñ≤‚Äª‚Üí‚Üê‚Üë‚Üì„Äì"],["a2a1","‚Ö∞",9],["a2b1","‚íà",19,"‚ë¥",19,"‚ë†",9],["a2e5","„à†",9],["a2f1","‚Ö†",11],["a3a1","ÔºÅÔºÇÔºÉÔø•ÔºÖ",88,"Ôø£"],["a4a1","„ÅÅ",82],["a5a1","„Ç°",85],["a6a1","Œë",16,"Œ£",6],["a6c1","Œ±",16,"œÉ",6],["a6e0","Ô∏µÔ∏∂Ô∏πÔ∏∫Ô∏øÔπÄÔ∏ΩÔ∏æÔπÅÔπÇÔπÉÔπÑ"],["a6ee","Ô∏ªÔ∏ºÔ∏∑Ô∏∏Ô∏±"],["a6f4","Ô∏≥Ô∏¥"],["a7a1","–ê",5,"–Å–ñ",25],["a7d1","–∞",5,"—ë–∂",25],["a840","ÀäÀãÀô‚Äì‚Äï‚Ä•‚Äµ‚ÑÖ‚Ñâ‚Üñ‚Üó‚Üò‚Üô‚àï‚àü‚à£‚âí‚â¶‚âß‚äø‚ïê",35,"‚ñÅ",6],["a880","‚ñà",7,"‚ñì‚ñî‚ñï‚ñº‚ñΩ‚ó¢‚ó£‚ó§‚ó•‚òâ‚äï„Äí„Äù„Äû"],["a8a1","ƒÅ√°«é√†ƒì√©ƒõ√®ƒ´√≠«ê√¨≈ç√≥«í√≤≈´√∫«î√π«ñ«ò«ö«ú√º√™…ë"],["a8bd","≈Ñ≈à"],["a8c0","…°"],["a8c5","„ÑÖ",36],["a940","„Ä°",8,"„ä£„éé„éè„éú„éù„éû„é°„èÑ„èé„èë„èí„èïÔ∏∞Ôø¢Ôø§"],["a959","‚Ñ°„à±"],["a95c","‚Äê"],["a960","„Éº„Çõ„Çú„ÉΩ„Éæ„ÄÜ„Çù„ÇûÔπâ",9,"ÔπîÔπïÔπñÔπóÔπô",8],["a980","Ôπ¢",4,"Ôπ®Ôπ©Ôπ™Ôπ´"],["a996","„Äá"],["a9a4","‚îÄ",75],["aa40","ÁãúÁãùÁãüÁã¢",5,"Áã™Áã´ÁãµÁã∂ÁãπÁãΩÁãæÁãøÁåÄÁåÇÁåÑ",5,"ÁåãÁååÁåçÁåèÁåêÁåëÁåíÁåîÁåòÁåôÁåöÁåüÁå†Áå£Áå§Áå¶ÁåßÁå®Áå≠ÁåØÁå∞Áå≤Áå≥ÁåµÁå∂Áå∫ÁåªÁåºÁåΩÁçÄ",8],["aa80","ÁçâÁçäÁçãÁçåÁçéÁçèÁçëÁçìÁçîÁçïÁçñÁçò",7,"Áç°",10,"ÁçÆÁç∞Áç±"],["ab40","Áç≤",11,"Áçø",4,"ÁéÖÁéÜÁéàÁéäÁéåÁéçÁéèÁéêÁéíÁéìÁéîÁéïÁéóÁéòÁéôÁéöÁéúÁéùÁéûÁé†Áé°Áé£",5,"Áé™Áé¨Áé≠Áé±Áé¥ÁéµÁé∂Áé∏ÁéπÁéºÁéΩÁéæÁéøÁèÅÁèÉ",4],["ab80","ÁèãÁèåÁèéÁèí",6,"ÁèöÁèõÁèúÁèùÁèüÁè°Áè¢Áè£Áè§Áè¶Áè®Áè™Áè´Áè¨ÁèÆÁèØÁè∞Áè±Áè≥",4],["ac40","Áè∏",10,"ÁêÑÁêáÁêàÁêãÁêåÁêçÁêéÁêë",8,"Áêú",5,"Áê£Áê§ÁêßÁê©Áê´Áê≠ÁêØÁê±Áê≤Áê∑",4,"ÁêΩÁêæÁêøÁëÄÁëÇ",11],["ac80","Áëé",6,"ÁëñÁëòÁëùÁë†",12,"ÁëÆÁëØÁë±",4,"Áë∏ÁëπÁë∫"],["ad40","ÁëªÁëºÁëΩÁëøÁíÇÁíÑÁíÖÁíÜÁíàÁíâÁíäÁíåÁíçÁíèÁíë",10,"ÁíùÁíü",7,"Áí™",15,"Áíª",12],["ad80","Áìà",9,"Áìì",8,"ÁìùÁìüÁì°Áì•Áìß",6,"Áì∞Áì±Áì≤"],["ae40","Áì≥ÁìµÁì∏",6,"ÁîÄÁîÅÁîÇÁîÉÁîÖ",7,"ÁîéÁîêÁîíÁîîÁîïÁîñÁîóÁîõÁîùÁîûÁî†",4,"Áî¶ÁîßÁî™ÁîÆÁî¥Áî∂ÁîπÁîºÁîΩÁîøÁïÅÁïÇÁïÉÁïÑÁïÜÁïáÁïâÁïäÁïçÁïêÁïëÁïíÁïìÁïïÁïñÁïóÁïò"],["ae80","Áïù",7,"ÁïßÁï®Áï©Áï´",6,"Áï≥ÁïµÁï∂Áï∑Áï∫",4,"ÁñÄÁñÅÁñÇÁñÑÁñÖÁñá"],["af40","ÁñàÁñâÁñäÁñåÁñçÁñéÁñêÁñìÁñïÁñòÁñõÁñúÁñûÁñ¢Áñ¶",4,"Áñ≠Áñ∂Áñ∑Áñ∫ÁñªÁñøÁóÄÁóÅÁóÜÁóãÁóåÁóéÁóèÁóêÁóëÁóìÁóóÁóôÁóöÁóúÁóùÁóüÁó†Áó°Áó•Áó©Áó¨Áó≠ÁóÆÁóØÁó≤Áó≥ÁóµÁó∂Áó∑Áó∏Áó∫ÁóªÁóΩÁóæÁòÇÁòÑÁòÜÁòá"],["af80","ÁòàÁòâÁòãÁòçÁòéÁòèÁòëÁòíÁòìÁòîÁòñÁòöÁòúÁòùÁòûÁò°Áò£ÁòßÁò®Áò¨ÁòÆÁòØÁò±Áò≤Áò∂Áò∑ÁòπÁò∫ÁòªÁòΩÁôÅÁôÇÁôÑ"],["b040","ÁôÖ",6,"Áôé",5,"ÁôïÁôó",4,"ÁôùÁôüÁô†Áô°Áô¢Áô§",6,"Áô¨Áô≠ÁôÆÁô∞",7,"ÁôπÁô∫ÁôºÁôøÁöÄÁöÅÁöÉÁöÖÁöâÁöäÁöåÁöçÁöèÁöêÁöíÁöîÁöïÁöóÁöòÁööÁöõ"],["b080","Áöú",7,"Áö•",8,"ÁöØÁö∞Áö≥Áöµ",9,"ÁõÄÁõÅÁõÉÂïäÈòøÂüÉÊå®ÂìéÂîâÂìÄÁöëÁôåËîºÁüÆËâæÁ¢çÁà±ÈöòÈûçÊ∞®ÂÆâ‰ø∫ÊåâÊöóÂ≤∏ËÉ∫Ê°àËÇÆÊòÇÁõéÂáπÊïñÁÜ¨Áø±Ë¢ÑÂÇ≤Â••ÊáäÊæ≥Ëä≠ÊçåÊâíÂè≠ÂêßÁ¨ÜÂÖ´Áñ§Â∑¥ÊãîË∑ãÈù∂ÊääËÄôÂùùÈú∏ÁΩ¢Áà∏ÁôΩÊüèÁôæÊëÜ‰Ω∞Ë¥•ÊãúÁ®óÊñëÁè≠Êê¨Êâ≥Ëà¨È¢ÅÊùøÁâàÊâÆÊãå‰º¥Áì£ÂçäÂäûÁªäÈÇ¶Â∏ÆÊ¢ÜÊ¶úËÜÄÁªëÊ£íÁ£ÖËöåÈïëÂÇçË∞§ËãûËÉûÂåÖË§íÂâ•"],["b140","ÁõÑÁõáÁõâÁõãÁõåÁõìÁõïÁõôÁõöÁõúÁõùÁõûÁõ†",4,"Áõ¶",7,"Áõ∞Áõ≥ÁõµÁõ∂Áõ∑Áõ∫ÁõªÁõΩÁõøÁúÄÁúÇÁúÉÁúÖÁúÜÁúäÁúåÁúé",10,"ÁúõÁúúÁúùÁúûÁú°Áú£Áú§Áú•ÁúßÁú™Áú´"],["b180","Áú¨ÁúÆÁú∞",4,"ÁúπÁúªÁúΩÁúæÁúøÁùÇÁùÑÁùÖÁùÜÁùà",7,"Áùí",7,"ÁùúËñÑÈõπ‰øùÂ†°È•±ÂÆùÊä±Êä•Êö¥Ë±πÈ≤çÁàÜÊùØÁ¢ëÊÇ≤ÂçëÂåóËæàËÉåË¥ùÈí°ÂÄçÁãàÂ§áÊÉ´ÁÑôË¢´Â•îËãØÊú¨Á¨®Â¥©Áª∑Áî≠Ê≥µËπ¶Ëø∏ÈÄºÈºªÊØîÈÑôÁ¨îÂΩºÁ¢ßËìñËîΩÊØïÊØôÊØñÂ∏ÅÂ∫áÁóπÈó≠ÊïùÂºäÂøÖËæüÂ£ÅËáÇÈÅøÈôõÈû≠ËæπÁºñË¥¨ÊâÅ‰æøÂèòÂçûËæ®Ëæ©Ëæ´ÈÅçÊ†áÂΩ™ËÜòË°®È≥ñÊÜãÂà´Áò™ÂΩ¨ÊñåÊøíÊª®ÂÆæÊëàÂÖµÂÜ∞ÊüÑ‰∏ôÁßâÈ•ºÁÇ≥"],["b240","ÁùùÁùûÁùüÁù†Áù§ÁùßÁù©Áù™Áù≠",11,"Áù∫ÁùªÁùºÁûÅÁûÇÁûÉÁûÜ",5,"ÁûèÁûêÁûì",11,"Áû°Áû£Áû§Áû¶Áû®Áû´Áû≠ÁûÆÁûØÁû±Áû≤Áû¥Áû∂",4],["b280","ÁûºÁûæÁüÄ",12,"Áüé",8,"ÁüòÁüôÁüöÁüù",4,"Áü§ÁóÖÂπ∂ÁéªËè†Êí≠Êã®ÈíµÊ≥¢ÂçöÂãÉÊêèÈìÇÁÆî‰ºØÂ∏õËà∂ËÑñËÜäÊ∏§Ê≥äÈ©≥ÊçïÂçúÂì∫Ë°•Âü†‰∏çÂ∏ÉÊ≠•Á∞øÈÉ®ÊÄñÊì¶ÁåúË£ÅÊùêÊâçË¥¢Áù¨Ë∏©ÈááÂΩ©ËèúËî°È§êÂèÇËöïÊÆãÊÉ≠ÊÉ®ÁÅøËãçËà±‰ªìÊ≤ßËóèÊìçÁ≥ôÊßΩÊõπËçâÂéïÁ≠ñ‰æßÂÜåÊµãÂ±ÇËπ≠ÊèíÂèâËå¨Ëå∂Êü•Á¢¥ÊêΩÂØüÂ≤îÂ∑ÆËØßÊãÜÊü¥Ë±∫ÊêÄÊé∫ËùâÈ¶ãË∞óÁº†Èì≤‰∫ßÈòêÈ¢§ÊòåÁåñ"],["b340","Áü¶Áü®Áü™ÁüØÁü∞Áü±Áü≤Áü¥ÁüµÁü∑ÁüπÁü∫ÁüªÁüºÁ†É",5,"Á†äÁ†ãÁ†éÁ†èÁ†êÁ†ìÁ†ïÁ†ôÁ†õÁ†ûÁ††Á†°Á†¢Á†§Á†®Á†™Á†´Á†ÆÁ†ØÁ†±Á†≤Á†≥Á†µÁ†∂Á†ΩÁ†øÁ°ÅÁ°ÇÁ°ÉÁ°ÑÁ°ÜÁ°àÁ°âÁ°äÁ°ãÁ°çÁ°èÁ°ëÁ°ìÁ°îÁ°òÁ°ôÁ°ö"],["b380","Á°õÁ°úÁ°û",11,"Á°Ø",7,"Á°∏Á°πÁ°∫Á°ªÁ°Ω",6,"Âú∫Â∞ùÂ∏∏ÈïøÂÅøËÇ†ÂéÇÊïûÁïÖÂî±ÂÄ°Ë∂ÖÊäÑÈíûÊúùÂò≤ÊΩÆÂ∑¢ÂêµÁÇíËΩ¶ÊâØÊí§Êé£ÂΩªÊæàÈÉ¥Ëá£Ëæ∞Â∞òÊô®Âø±Ê≤âÈôàË∂ÅË°¨ÊíëÁß∞ÂüéÊ©ôÊàêÂëà‰πòÁ®ãÊÉ©ÊæÑËØöÊâøÈÄûÈ™ãÁß§ÂêÉÁó¥ÊåÅÂåôÊ±†ËøüÂºõÈ©∞ËÄªÈΩø‰æàÂ∞∫Ëµ§ÁøÖÊñ•ÁÇΩÂÖÖÂÜ≤Ëô´Â¥áÂÆ†ÊäΩÈÖ¨Áï¥Ë∏åÁ®†ÊÑÅÁ≠π‰ªáÁª∏ÁûÖ‰∏ëËá≠ÂàùÂá∫Ê©±Âé®Ë∫áÈîÑÈõèÊªÅÈô§Ê•ö"],["b440","Á¢ÑÁ¢ÖÁ¢ÜÁ¢àÁ¢äÁ¢ãÁ¢èÁ¢êÁ¢íÁ¢îÁ¢ïÁ¢ñÁ¢ôÁ¢ùÁ¢ûÁ¢†Á¢¢Á¢§Á¢¶Á¢®",7,"Á¢µÁ¢∂Á¢∑Á¢∏Á¢∫Á¢ªÁ¢ºÁ¢ΩÁ¢øÁ£ÄÁ£ÇÁ£ÉÁ£ÑÁ£ÜÁ£áÁ£àÁ£åÁ£çÁ£éÁ£èÁ£ëÁ£íÁ£ìÁ£ñÁ£óÁ£òÁ£ö",9],["b480","Á£§Á£•Á£¶Á£ßÁ£©Á£™Á£´Á£≠",4,"Á£≥Á£µÁ£∂Á£∏Á£πÁ£ª",5,"Á§ÇÁ§ÉÁ§ÑÁ§Ü",6,"Á°ÄÂÇ®ÁüóÊêêËß¶Â§ÑÊè£Â∑ùÁ©øÊ§Ω‰º†ËàπÂñò‰∏≤ÁñÆÁ™óÂπ¢Â∫äÈóØÂàõÂêπÁÇäÊç∂Èî§ÂûÇÊò•Ê§øÈÜáÂîáÊ∑≥Á∫ØË†¢Êà≥Áª∞ÁñµËå®Á£ÅÈõåËæûÊÖàÁì∑ËØçÊ≠§Âà∫ËµêÊ¨°ËÅ™Ëë±Âõ±ÂåÜ‰ªé‰∏õÂáëÁ≤óÈÜãÁ∞á‰øÉËπøÁØ°Á™úÊëßÂ¥îÂÇ¨ËÑÜÁòÅÁ≤πÊ∑¨Áø†ÊùëÂ≠òÂØ∏Á£ãÊíÆÊêìÊé™Êå´ÈîôÊê≠ËææÁ≠îÁò©ÊâìÂ§ßÂëÜÊ≠πÂÇ£Êà¥Â∏¶ÊÆÜ‰ª£Ë¥∑Ë¢ãÂæÖÈÄÆ"],["b540","Á§ç",5,"Á§î",9,"Á§ü",4,"Á§•",14,"Á§µ",4,"Á§ΩÁ§øÁ•ÇÁ•ÉÁ•ÑÁ•ÖÁ•áÁ•ä",8,"Á•îÁ•ïÁ•òÁ•ôÁ•°Á•£"],["b580","Á•§Á•¶Á•©Á•™Á•´Á•¨Á•ÆÁ•∞",6,"Á•πÁ•ª",4,"Á¶ÇÁ¶ÉÁ¶ÜÁ¶áÁ¶àÁ¶âÁ¶ãÁ¶åÁ¶çÁ¶éÁ¶êÁ¶ëÁ¶íÊÄ†ËÄΩÊãÖ‰∏πÂçïÈÉ∏Êé∏ËÉÜÊó¶Ê∞Æ‰ΩÜÊÉÆÊ∑°ËØûÂºπËõãÂΩìÊå°ÂÖöËç°Ê°£ÂàÄÊç£ËπàÂÄíÂ≤õÁ•∑ÂØºÂà∞Á®ªÊÇºÈÅìÁõóÂæ∑ÂæóÁöÑËπ¨ÁÅØÁôªÁ≠âÁû™Âá≥ÈÇìÂ†§‰ΩéÊª¥Ëø™ÊïåÁ¨õÁãÑÊ∂§ÁøüÂ´°ÊäµÂ∫ïÂú∞ËíÇÁ¨¨Â∏ùÂºüÈÄíÁºîÈ¢†ÊéÇÊªáÁ¢òÁÇπÂÖ∏ÈùõÂû´Áîµ‰ΩÉÁî∏Â∫óÊÉ¶Â•†Ê∑ÄÊÆøÁ¢âÂèºÈõïÂáãÂàÅÊéâÂêäÈíìË∞ÉË∑åÁàπÁ¢üËù∂Ëø≠Ë∞çÂè†"],["b640","Á¶ì",6,"Á¶õ",11,"Á¶®",10,"Á¶¥",4,"Á¶ºÁ¶øÁßÇÁßÑÁßÖÁßáÁßàÁßäÁßåÁßéÁßèÁßêÁßìÁßîÁßñÁßóÁßô",5,"Áß†Áß°Áß¢Áß•Áß®Áß™"],["b680","Áß¨ÁßÆÁß±",6,"ÁßπÁß∫ÁßºÁßæÁßøÁ®ÅÁ®ÑÁ®ÖÁ®áÁ®àÁ®âÁ®äÁ®åÁ®è",4,"Á®ïÁ®ñÁ®òÁ®ôÁ®õÁ®ú‰∏ÅÁõØÂèÆÈíâÈ°∂ÈºéÈî≠ÂÆöËÆ¢‰∏¢‰∏úÂÜ¨Ëë£ÊáÇÂä®Ê†ã‰æóÊÅ´ÂÜªÊ¥ûÂÖúÊäñÊñóÈô°Ë±ÜÈÄóÁóòÈÉΩÁù£ÊØíÁääÁã¨ËØªÂ†µÁùπËµåÊùúÈïÄËÇöÂ∫¶Ê∏°Â¶íÁ´ØÁü≠ÈîªÊÆµÊñ≠ÁºéÂ†ÜÂÖëÈòüÂØπÂ¢©Âê®Ëπ≤Êï¶È°øÂõ§ÈíùÁõæÈÅÅÊéáÂìÜÂ§öÂ§∫ÂûõË∫≤ÊúµË∑∫ËàµÂâÅÊÉ∞Â†ïËõæÂ≥®ÈπÖ‰øÑÈ¢ùËÆπÂ®•ÊÅ∂ÂéÑÊâºÈÅèÈÑÇÈ•øÊÅ©ËÄåÂÑøËÄ≥Â∞îÈ•µÊ¥±‰∫å"],["b740","Á®ùÁ®üÁ®°Á®¢Á®§",14,"Á®¥Á®µÁ®∂Á®∏Á®∫Á®æÁ©Ä",5,"Á©á",9,"Á©í",4,"Á©ò",16],["b780","Á©©",6,"Á©±Á©≤Á©≥Á©µÁ©ªÁ©ºÁ©ΩÁ©æÁ™ÇÁ™ÖÁ™áÁ™âÁ™äÁ™ãÁ™åÁ™éÁ™èÁ™êÁ™ìÁ™îÁ™ôÁ™öÁ™õÁ™ûÁ™°Á™¢Ë¥∞ÂèëÁΩöÁ≠è‰ºê‰πèÈòÄÊ≥ïÁèêËó©Â∏ÜÁï™ÁøªÊ®äÁüæÈííÁπÅÂá°ÁÉ¶ÂèçËøîËåÉË¥©ÁäØÈ•≠Ê≥õÂùäËä≥ÊñπËÇ™ÊàøÈò≤Â¶®‰ªøËÆøÁ∫∫ÊîæËè≤ÈùûÂï°È£ûËÇ•Âå™ËØΩÂê†ËÇ∫Â∫üÊ≤∏Ë¥πËä¨ÈÖöÂê©Ê∞õÂàÜÁ∫∑ÂùüÁÑöÊ±æÁ≤âÂ•ã‰ªΩÂøøÊÑ§Á≤™‰∏∞Â∞ÅÊû´ËúÇÂ≥∞ÈîãÈ£éÁñØÁÉΩÈÄ¢ÂÜØÁºùËÆΩÂ•âÂá§‰ΩõÂê¶Â§´Êï∑ËÇ§Â≠µÊâ∂ÊãÇËæêÂπÖÊ∞üÁ¨¶‰ºè‰øòÊúç"],["b840","Á™£Á™§Á™ßÁ™©Á™™Á™´Á™Æ",4,"Á™¥",10,"Á´Ä",10,"Á´å",9,"Á´óÁ´òÁ´öÁ´õÁ´úÁ´ùÁ´°Á´¢Á´§Á´ß",5,"Á´ÆÁ´∞Á´±Á´≤Á´≥"],["b880","Á´¥",4,"Á´ªÁ´ºÁ´æÁ¨ÄÁ¨ÅÁ¨ÇÁ¨ÖÁ¨áÁ¨âÁ¨åÁ¨çÁ¨éÁ¨êÁ¨íÁ¨ìÁ¨ñÁ¨óÁ¨òÁ¨öÁ¨úÁ¨ùÁ¨üÁ¨°Á¨¢Á¨£Á¨ßÁ¨©Á¨≠ÊµÆÊ∂™Á¶èË¢±ÂºóÁî´ÊäöËæÖ‰øØÈáúÊñßËÑØËÖëÂ∫úËÖêËµ¥ÂâØË¶ÜËµãÂ§çÂÇÖ‰ªòÈòúÁà∂ËÖπË¥üÂØåËÆ£ÈôÑÂ¶áÁºöÂíêÂô∂ÂòéËØ•ÊîπÊ¶ÇÈíôÁõñÊ∫âÂπ≤ÁîòÊùÜÊüëÁ´øËÇùËµ∂ÊÑüÁßÜÊï¢Ëµ£ÂÜàÂàöÈí¢Áº∏ËÇõÁ∫≤Â≤óÊ∏ØÊù†ÁØôÁöãÈ´òËÜèÁæîÁ≥ïÊêûÈïêÁ®øÂëäÂì•Ê≠åÊêÅÊààÈ∏ΩËÉ≥ÁñôÂâ≤Èù©ËëõÊ†ºËõ§ÈòÅÈöîÈì¨‰∏™ÂêÑÁªôÊ†πË∑üËÄïÊõ¥Â∫öÁæπ"],["b940","Á¨ØÁ¨∞Á¨≤Á¨¥Á¨µÁ¨∂Á¨∑Á¨πÁ¨ªÁ¨ΩÁ¨ø",5,"Á≠ÜÁ≠àÁ≠äÁ≠çÁ≠éÁ≠ìÁ≠ïÁ≠óÁ≠ôÁ≠úÁ≠ûÁ≠üÁ≠°Á≠£",10,"Á≠ØÁ≠∞Á≠≥Á≠¥Á≠∂Á≠∏Á≠∫Á≠ºÁ≠ΩÁ≠øÁÆÅÁÆÇÁÆÉÁÆÑÁÆÜ",6,"ÁÆéÁÆè"],["b980","ÁÆëÁÆíÁÆìÁÆñÁÆòÁÆôÁÆöÁÆõÁÆûÁÆüÁÆ†ÁÆ£ÁÆ§ÁÆ•ÁÆÆÁÆØÁÆ∞ÁÆ≤ÁÆ≥ÁÆµÁÆ∂ÁÆ∑ÁÆπ",7,"ÁØÇÁØÉÁØÑÂüÇËÄøÊ¢óÂ∑•ÊîªÂäüÊÅ≠Èæö‰æõË∫¨ÂÖ¨ÂÆ´ÂºìÂ∑©Ê±ûÊã±Ë¥°ÂÖ±Èí©ÂãæÊ≤üËãüÁãóÂû¢ÊûÑË¥≠Â§üËæúËèáÂíïÁÆç‰º∞Ê≤ΩÂ≠§ÂßëÈºìÂè§ËõäÈ™®Ë∞∑ËÇ°ÊïÖÈ°æÂõ∫ÈõáÂàÆÁìúÂâêÂØ°ÊåÇË§Ç‰πñÊãêÊÄ™Ê£∫ÂÖ≥ÂÆòÂÜ†ËßÇÁÆ°È¶ÜÁΩêÊÉØÁÅåË¥ØÂÖâÂπøÈÄõÁë∞ËßÑÂú≠Á°ÖÂΩíÈæüÈó∫ËΩ®È¨ºËØ°Áô∏Ê°ÇÊüúË∑™Ë¥µÂàΩËæäÊªöÊ£çÈîÖÈÉ≠ÂõΩÊûúË£πËøáÂìà"],["ba40","ÁØÖÁØàÁØâÁØäÁØãÁØçÁØéÁØèÁØêÁØíÁØî",4,"ÁØõÁØúÁØûÁØüÁØ†ÁØ¢ÁØ£ÁØ§ÁØßÁØ®ÁØ©ÁØ´ÁØ¨ÁØ≠ÁØØÁØ∞ÁØ≤",4,"ÁØ∏ÁØπÁØ∫ÁØªÁØΩÁØø",7,"Á∞àÁ∞âÁ∞äÁ∞çÁ∞éÁ∞ê",5,"Á∞óÁ∞òÁ∞ô"],["ba80","Á∞ö",4,"Á∞†",5,"Á∞®Á∞©Á∞´",12,"Á∞π",5,"Á±ÇÈ™∏Â≠©Êµ∑Ê∞¶‰∫•ÂÆ≥È™áÈÖ£ÊÜ®ÈÇØÈü©Âê´Ê∂µÂØíÂáΩÂñäÁΩïÁø∞ÊíºÊççÊó±ÊÜæÊÇçÁÑäÊ±óÊ±âÂ§ØÊù≠Ëà™Â£ïÂöéË±™ÊØ´ÈÉùÂ•ΩËÄóÂè∑Êµ©ÂëµÂñùËç∑ËèèÊ†∏Á¶æÂíå‰ΩïÂêàÁõíË≤âÈòÇÊ≤≥Ê∂∏Ëµ´Ë§êÈπ§Ë¥∫ÂòøÈªëÁóïÂæàÁã†ÊÅ®Âìº‰∫®Ê®™Ë°°ÊÅíËΩ∞ÂìÑÁÉòËôπÈ∏øÊ¥™ÂÆèÂºòÁ∫¢Âñâ‰æØÁå¥ÂêºÂéöÂÄôÂêéÂëº‰πéÂøΩÁëöÂ£∂Ëë´ËÉ°Ëù¥ÁãêÁ≥äÊπñ"],["bb40","Á±É",9,"Á±é",36,"Á±µ",5,"Á±æ",9],["bb80","Á≤àÁ≤ä",6,"Á≤ìÁ≤îÁ≤ñÁ≤ôÁ≤öÁ≤õÁ≤†Á≤°Á≤£Á≤¶Á≤ßÁ≤®Á≤©Á≤´Á≤¨Á≤≠Á≤ØÁ≤∞Á≤¥",4,"Á≤∫Á≤ªÂºßËôéÂî¨Êä§‰∫íÊ≤™Êà∑Ëä±ÂìóÂçéÁåæÊªëÁîªÂàíÂåñËØùÊßêÂæäÊÄÄÊ∑ÆÂùèÊ¨¢ÁéØÊ°ìËøòÁºìÊç¢ÊÇ£Âî§Áó™Ë±¢ÁÑïÊ∂£ÂÆ¶ÂπªËçíÊÖåÈªÑÁ£∫ËùóÁ∞ßÁöáÂá∞ÊÉ∂ÁÖåÊôÉÂπåÊÅçË∞éÁÅ∞Êå•ËæâÂæΩÊÅ¢ËõîÂõûÊØÅÊÇîÊÖßÂçâÊÉ†Êô¶Ë¥øÁßΩ‰ºöÁÉ©Ê±áËÆ≥ËØ≤ÁªòËç§ÊòèÂ©öÈ≠ÇÊµëÊ∑∑Ë±ÅÊ¥ª‰ºôÁÅ´Ëé∑ÊàñÊÉëÈúçË¥ßÁ•∏ÂáªÂúæÂü∫Êú∫Áï∏Á®ΩÁßØÁÆï"],["bc40","Á≤øÁ≥ÄÁ≥ÇÁ≥ÉÁ≥ÑÁ≥ÜÁ≥âÁ≥ãÁ≥é",6,"Á≥òÁ≥öÁ≥õÁ≥ùÁ≥ûÁ≥°",6,"Á≥©",5,"Á≥∞",7,"Á≥πÁ≥∫Á≥º",13,"Á¥ã",5],["bc80","Á¥ë",14,"Á¥°Á¥£Á¥§Á¥•Á¥¶Á¥®Á¥©Á¥™Á¥¨Á¥≠Á¥ÆÁ¥∞",6,"ËÇåÈ••ËøπÊøÄËÆ•È∏°Âß¨Áª©ÁºâÂêâÊûÅÊ£òËæëÁ±çÈõÜÂèäÊÄ•ÁñæÊ±≤Âç≥Â´âÁ∫ßÊå§Âá†ËÑäÂ∑±ËìüÊäÄÂÜÄÂ≠£‰ºéÁ•≠ÂâÇÊÇ∏ÊµéÂØÑÂØÇËÆ°ËÆ∞Êó¢ÂøåÈôÖÂ¶ìÁªßÁ∫™ÂòâÊû∑Â§π‰Ω≥ÂÆ∂Âä†ËçöÈ¢äË¥æÁî≤ÈíæÂÅáÁ®º‰ª∑Êû∂È©æÂ´ÅÊ≠ºÁõëÂùöÂ∞ñÁ¨∫Èó¥ÁÖéÂÖºËÇ©Ëâ∞Â•∏ÁºÑËåßÊ£ÄÊü¨Á¢±Á°∑Êã£Êç°ÁÆÄ‰ø≠Ââ™ÂáèËçêÊßõÈâ¥Ë∑µË¥±ËßÅÈîÆÁÆ≠‰ª∂"],["bd40","Á¥∑",54,"ÁµØ",7],["bd80","Áµ∏",32,"ÂÅ•Ëà∞ÂâëÈ•ØÊ∏êÊ∫ÖÊ∂ßÂª∫ÂÉµÂßúÂ∞ÜÊµÜÊ±üÁñÜËíãÊ°®Â•ñËÆ≤Âå†ÈÖ±ÈôçËïâÊ§íÁ§ÅÁÑ¶ËÉ∂‰∫§ÈÉäÊµáÈ™ÑÂ®áÂöºÊêÖÈì∞Áü´‰æ•ËÑöÁã°ËßíÈ•∫Áº¥ÁªûÂâøÊïôÈÖµËΩøËæÉÂè´Á™ñÊè≠Êé•ÁöÜÁß∏Ë°óÈò∂Êà™Âä´ËäÇÊ°îÊù∞Êç∑Áù´Á´≠Ê¥ÅÁªìËß£ÂßêÊàíËóâËä•ÁïåÂÄü‰ªãÁñ•ËØ´Â±äÂ∑æÁ≠ãÊñ§Èáë‰ªäÊ¥•Ë•üÁ¥ßÈî¶‰ªÖË∞®ËøõÈù≥ÊôãÁ¶ÅËøëÁÉ¨Êµ∏"],["be40","Á∂ô",12,"Á∂ß",6,"Á∂Ø",42],["be80","Á∑ö",32,"Â∞ΩÂä≤ËçÜÂÖ¢ËåéÁùõÊô∂È≤∏‰∫¨ÊÉäÁ≤æÁ≤≥Áªè‰∫ïË≠¶ÊôØÈ¢àÈùôÂ¢ÉÊï¨ÈïúÂæÑÁóâÈùñÁ´üÁ´ûÂáÄÁÇØÁ™òÊè™Á©∂Á∫†ÁéñÈü≠‰πÖÁÅ∏‰πùÈÖíÂé©ÊïëÊóßËáºËàÖÂíéÂ∞±ÁñöÈû†ÊãòÁãôÁñΩÂ±ÖÈ©πËèäÂ±ÄÂíÄÁü©‰∏æÊ≤ÆËÅöÊãíÊçÆÂ∑®ÂÖ∑Ë∑ùË∏ûÈîØ‰ø±Âè•ÊÉßÁÇ¨ÂâßÊçêÈπÉÂ®üÂÄ¶Áú∑Âç∑Áª¢ÊíÖÊî´ÊäâÊéòÂÄîÁàµËßâÂÜ≥ËØÄÁªùÂùáËèåÈíßÂÜõÂêõÂ≥ª"],["bf40","Á∑ª",62],["bf80","Á∏∫Á∏º",4,"ÁπÇ",4,"Áπà",21,"‰øäÁ´£ÊµöÈÉ°È™èÂñÄÂíñÂç°ÂíØÂºÄÊè©Ê•∑ÂáØÊÖ®ÂàäÂ†™ÂãòÂùéÁ†çÁúãÂ∫∑ÊÖ∑Á≥†ÊâõÊäó‰∫¢ÁÇïËÄÉÊã∑ÁÉ§Èù†Âù∑ËãõÊüØÊ£µÁ£ïÈ¢óÁßëÂ£≥Âí≥ÂèØÊ∏¥ÂÖãÂàªÂÆ¢ËØæËÇØÂïÉÂû¶ÊÅ≥ÂùëÂê≠Á©∫ÊÅêÂ≠îÊéßÊä†Âè£Êâ£ÂØáÊûØÂì≠Á™üËã¶ÈÖ∑Â∫ìË£§Â§∏ÂûÆÊåéË∑®ËÉØÂùóÁ≠∑‰æ©Âø´ÂÆΩÊ¨æÂå°Á≠êÁãÇÊ°ÜÁüøÁú∂Êó∑ÂÜµ‰∫èÁõîÂ≤øÁ™•ËëµÂ•éÈ≠ÅÂÇÄ"],["c040","Áπû",35,"Á∫É",23,"Á∫úÁ∫ùÁ∫û"],["c080","Á∫ÆÁ∫¥Á∫ªÁ∫ºÁªñÁª§Áª¨ÁªπÁºäÁºêÁºûÁº∑ÁºπÁºª",6,"ÁΩÉÁΩÜ",9,"ÁΩíÁΩìÈ¶àÊÑßÊ∫ÉÂù§ÊòÜÊçÜÂõ∞Êã¨Êâ©ÂªìÈòîÂûÉÊãâÂñáËú°ËÖäËæ£Âï¶Ëé±Êù•ËµñËìùÂ©™Ê†èÊã¶ÁØÆÈòëÂÖ∞ÊæúË∞∞ÊèΩËßàÊáíÁºÜÁÉÇÊª•ÁêÖÊ¶îÁãºÂªäÈÉéÊúóÊµ™ÊçûÂä≥Áâ¢ËÄÅ‰Ω¨Âß•ÈÖ™ÁÉôÊ∂ùÂãí‰πêÈõ∑Èï≠ËïæÁ£äÁ¥ØÂÑ°ÂûíÊìÇËÇãÁ±ªÊ≥™Ê£±Ê•ûÂÜ∑ÂéòÊ¢®ÁäÅÈªéÁØ±Áã∏Á¶ªÊºìÁêÜÊùéÈáåÈ≤§Á§ºËéâËçîÂêèÊ†ó‰∏ΩÂéâÂä±Á†æÂéÜÂà©ÂÇà‰æã‰øê"],["c140","ÁΩñÁΩôÁΩõÁΩúÁΩùÁΩûÁΩ†ÁΩ£",4,"ÁΩ´ÁΩ¨ÁΩ≠ÁΩØÁΩ∞ÁΩ≥ÁΩµÁΩ∂ÁΩ∑ÁΩ∏ÁΩ∫ÁΩªÁΩºÁΩΩÁΩøÁæÄÁæÇ",7,"ÁæãÁæçÁæè",4,"Áæï",4,"ÁæõÁæúÁæ†Áæ¢Áæ£Áæ•Áæ¶Áæ®",6,"Áæ±"],["c180","Áæ≥",4,"Áæ∫ÁæªÁææÁøÄÁøÇÁøÉÁøÑÁøÜÁøáÁøàÁøâÁøãÁøçÁøè",4,"ÁøñÁøóÁøô",5,"Áø¢Áø£Áó¢Á´ãÁ≤íÊ≤•Èö∂ÂäõÁíÉÂì©‰ø©ËÅîËé≤ËøûÈï∞ÂªâÊÄúÊ∂üÂ∏òÊïõËÑ∏ÈìæÊÅãÁÇºÁªÉÁ≤ÆÂáâÊ¢ÅÁ≤±ËâØ‰∏§ËæÜÈáèÊôæ‰∫ÆË∞ÖÊí©ËÅäÂÉöÁñóÁáéÂØ•ËæΩÊΩ¶‰∫ÜÊíÇÈï£ÂªñÊñôÂàóË£ÇÁÉàÂä£ÁåéÁê≥ÊûóÁ£∑Èúñ‰∏¥ÈÇªÈ≥ûÊ∑ãÂáõËµÅÂêùÊãéÁé≤Ëè±Èõ∂ÈæÑÈìÉ‰º∂ÁæöÂáåÁÅµÈôµÂ≤≠È¢ÜÂè¶‰ª§Ê∫úÁêâÊ¶¥Á°´È¶èÁïôÂàòÁò§ÊµÅÊü≥ÂÖ≠ÈæôËÅãÂíôÁ¨ºÁ™ø"],["c240","Áø§ÁøßÁø®Áø™Áø´Áø¨Áø≠ÁøØÁø≤Áø¥",6,"ÁøΩÁøæÁøøËÄÇËÄáËÄàËÄâËÄäËÄéËÄèËÄëËÄìËÄöËÄõËÄùËÄûËÄüËÄ°ËÄ£ËÄ§ËÄ´",5,"ËÄ≤ËÄ¥ËÄπËÄ∫ËÄºËÄæËÅÄËÅÅËÅÑËÅÖËÅáËÅàËÅâËÅéËÅèËÅêËÅëËÅìËÅïËÅñËÅó"],["c280","ËÅôËÅõ",13,"ËÅ´",5,"ËÅ≤",11,"ÈöÜÂûÑÊã¢ÈôáÊ•ºÂ®ÑÊêÇÁØìÊºèÈôãËä¶Âç¢È¢ÖÂ∫êÁÇâÊé≥Âç§ËôèÈ≤ÅÈ∫ìÁ¢åÈú≤Ë∑ØËµÇÈπøÊΩûÁ¶ÑÂΩïÈôÜÊàÆÈ©¥ÂêïÈìù‰æ£ÊóÖÂ±•Â±°ÁºïËôëÊ∞ØÂæãÁéáÊª§ÁªøÂ≥¶ÊåõÂ≠™Êª¶Âçµ‰π±Êé†Áï•Êä°ËΩÆ‰º¶‰ªëÊ≤¶Á∫∂ËÆ∫ËêùËû∫ÁΩóÈÄªÈî£ÁÆ©È™°Ë£∏ËêΩÊ¥õÈ™ÜÁªúÂ¶àÈ∫ªÁéõÁ†ÅËöÇÈ©¨È™ÇÂòõÂêóÂüã‰π∞È∫¶ÂçñËøàËÑâÁûíÈ¶íËõÆÊª°ËîìÊõºÊÖ¢Êº´"],["c340","ËÅæËÇÅËÇÇËÇÖËÇàËÇäËÇç",5,"ËÇîËÇïËÇóËÇôËÇûËÇ£ËÇ¶ËÇßËÇ®ËÇ¨ËÇ∞ËÇ≥ËÇµËÇ∂ËÇ∏ËÇπËÇªËÉÖËÉá",4,"ËÉè",6,"ËÉòËÉüËÉ†ËÉ¢ËÉ£ËÉ¶ËÉÆËÉµËÉ∑ËÉπËÉªËÉæËÉøËÑÄËÑÅËÑÉËÑÑËÑÖËÑáËÑàËÑã"],["c380","ËÑåËÑïËÑóËÑôËÑõËÑúËÑùËÑü",12,"ËÑ≠ËÑÆËÑ∞ËÑ≥ËÑ¥ËÑµËÑ∑ËÑπ",4,"ËÑøË∞©ËäíËå´Áõ≤Ê∞ìÂøôËéΩÁå´ËåÖÈîöÊØõÁüõÈìÜÂçØËåÇÂÜíÂ∏ΩË≤åË¥∏‰πàÁé´ÊûöÊ¢ÖÈÖ∂ÈúâÁÖ§Ê≤°ÁúâÂ™íÈïÅÊØèÁæéÊòßÂØêÂ¶πÂ™öÈó®Èó∑‰ª¨ËêåËíôÊ™¨ÁõüÈî∞ÁåõÊ¢¶Â≠üÁúØÈÜöÈù°Á≥úËø∑Ë∞úÂº•Á±≥ÁßòËßÖÊ≥åËúúÂØÜÂπÇÊ£âÁú†ÁªµÂÜïÂÖçÂãâÂ®©ÁºÖÈù¢ËãóÊèèÁûÑËóêÁßíÊ∏∫Â∫ôÂ¶ôËîëÁÅ≠Ê∞ëÊäøÁöøÊïèÊÇØÈóΩÊòéËûüÈ∏£Èì≠ÂêçÂëΩË∞¨Êë∏"],["c440","ËÖÄ",5,"ËÖáËÖâËÖçËÖéËÖèËÖíËÖñËÖóËÖòËÖõ",4,"ËÖ°ËÖ¢ËÖ£ËÖ§ËÖ¶ËÖ®ËÖ™ËÖ´ËÖ¨ËÖØËÖ≤ËÖ≥ËÖµËÖ∂ËÖ∑ËÖ∏ËÜÅËÜÉ",4,"ËÜâËÜãËÜåËÜçËÜéËÜêËÜí",5,"ËÜôËÜöËÜû",4,"ËÜ§ËÜ•"],["c480","ËÜßËÜ©ËÜ´",7,"ËÜ¥",5,"ËÜºËÜΩËÜæËÜøËáÑËáÖËááËáàËáâËáãËáç",6,"ÊëπËòëÊ®°ËÜúÁ£®Êë©È≠îÊäπÊú´Ëé´Â¢®ÈªòÊ≤´Êº†ÂØûÈôåË∞ãÁâüÊüêÊãáÁâ°‰∫©ÂßÜÊØçÂ¢ìÊöÆÂπïÂãüÊÖïÊú®ÁõÆÁù¶ÁâßÁ©ÜÊãøÂì™ÂëêÈí†ÈÇ£Â®úÁ∫≥Ê∞ñ‰πÉÂ•∂ËÄêÂ•àÂçóÁî∑ÈöæÂõäÊå†ËÑëÊÅºÈóπÊ∑ñÂë¢È¶ÅÂÜÖÂ´©ËÉΩÂ¶ÆÈúìÂÄ™Ê≥•Â∞ºÊãü‰Ω†ÂåøËÖªÈÄÜÊ∫∫Ëî´ÊãàÂπ¥Á¢æÊíµÊçªÂøµÂ®òÈÖøÈ∏üÂ∞øÊçèËÅÇÂ≠ΩÂïÆÈïäÈïçÊ∂ÖÊÇ®Êü†ÁãûÂáùÂÆÅ"],["c540","Ëáî",14,"Ëá§Ëá•Ëá¶Ëá®Ëá©Ëá´ËáÆ",4,"Ëáµ",5,"ËáΩËáøËàÉËàá",4,"ËàéËàèËàëËàìËàï",5,"ËàùËà†Ëà§Ëà•Ëà¶ËàßËà©ËàÆËà≤Ëà∫ËàºËàΩËàø"],["c580","ËâÄËâÅËâÇËâÉËâÖËâÜËâàËâäËâåËâçËâéËâê",7,"ËâôËâõËâúËâùËâûËâ†",7,"Ëâ©ÊãßÊ≥ûÁâõÊâ≠ÈíÆÁ∫ΩËÑìÊµìÂÜúÂºÑÂ•¥Âä™ÊÄíÂ•≥ÊöñËôêÁñüÊå™Êá¶Á≥ØËØ∫Âì¶Ê¨ßÈ∏•ÊÆ¥ËóïÂëïÂÅ∂Ê≤§Âï™Ë∂¥Áà¨Â∏ïÊÄïÁê∂ÊãçÊéíÁâåÂæòÊπÉÊ¥æÊîÄÊΩòÁõòÁ£êÁõºÁïîÂà§Âèõ‰πìÂ∫ûÊóÅËÄ™ËÉñÊäõÂíÜÂà®ÁÇÆË¢çË∑ëÊ≥°Âë∏ËÉöÂüπË£¥ËµîÈô™ÈÖç‰Ω©Ê≤õÂñ∑ÁõÜÁ†∞Êä®ÁÉπÊæéÂΩ≠Ëì¨Ê£öÁ°ºÁØ∑ËÜ®ÊúãÈπèÊçßÁ¢∞ÂùØÁ†íÈúπÊâπÊä´ÂäàÁêµÊØó"],["c640","Ëâ™Ëâ´Ëâ¨Ëâ≠Ëâ±ËâµËâ∂Ëâ∑Ëâ∏ËâªËâºËäÄËäÅËäÉËäÖËäÜËäáËäâËäåËäêËäìËäîËäïËäñËäöËäõËäûËä†Ëä¢Ëä£ËäßËä≤ËäµËä∂Ëä∫ËäªËäºËäøËãÄËãÇËãÉËãÖËãÜËãâËãêËãñËãôËãöËãùËã¢ËãßËã®Ëã©Ëã™Ëã¨Ëã≠ËãÆËã∞Ëã≤Ëã≥ËãµËã∂Ëã∏"],["c680","Ëã∫Ëãº",4,"ËåäËåãËåçËåêËåíËåìËåñËåòËåôËåù",9,"Ëå©Ëå™ËåÆËå∞Ëå≤Ëå∑ËåªËåΩÂï§ËÑæÁñ≤ÁöÆÂåπÁóûÂÉªÂ±ÅË≠¨ÁØáÂÅèÁâáÈ™óÈ£òÊºÇÁì¢Á•®ÊíáÁû•ÊãºÈ¢ëË¥´ÂìÅËÅò‰πíÂù™ËãπËêçÂπ≥Âá≠Áì∂ËØÑÂ±èÂù°Ê≥ºÈ¢áÂ©ÜÁ†¥È≠ÑËø´Á≤ïÂâñÊâëÈì∫‰ªÜËéÜËë°Ëè©Ëí≤ÂüîÊú¥ÂúÉÊôÆÊµ¶Ë∞±ÊõùÁÄëÊúüÊ¨∫Ê†ñÊàöÂ¶ª‰∏ÉÂáÑÊºÜÊüíÊ≤èÂÖ∂Ê£ãÂ•áÊ≠ßÁï¶Â¥éËÑêÈΩêÊóóÁ•àÁ•ÅÈ™ëËµ∑Â≤Ç‰πû‰ºÅÂêØÂ•ëÁ†åÂô®Ê∞îËøÑÂºÉÊ±ΩÊ≥£ËÆ´Êéê"],["c740","ËåæËåøËçÅËçÇËçÑËçÖËçàËçä",4,"ËçìËçï",4,"ËçùËç¢Ëç∞",6,"ËçπËç∫Ëçæ",6,"ËéáËéàËéäËéãËéåËéçËéèËéêËéëËéîËéïËéñËéóËéôËéöËéùËéüËé°",6,"Ëé¨Ëé≠ËéÆ"],["c780","ËéØËéµËéªËéæËéøËèÇËèÉËèÑËèÜËèàËèâËèãËèçËèéËèêËèëËèíËèìËèïËèóËèôËèöËèõËèûËè¢Ëè£Ëè§Ëè¶ËèßËè®Ëè´Ëè¨Ëè≠ÊÅ∞Ê¥ΩÁâµÊâ¶ÈíéÈìÖÂçÉËøÅÁ≠æ‰ªüË∞¶‰πæÈªîÈí±Èí≥ÂâçÊΩúÈÅ£ÊµÖË∞¥Â†ëÂµåÊ¨†Ê≠âÊû™ÂëõËÖîÁæåÂ¢ôËî∑Âº∫Êä¢Ê©áÈîπÊï≤ÊÇÑÊ°•Áûß‰πî‰æ®Â∑ßÈûòÊí¨ÁøòÂ≥≠‰øèÁ™çÂàáËåÑ‰∏îÊÄØÁ™ÉÈí¶‰æµ‰∫≤Áß¶Áê¥Âã§ËäπÊìíÁ¶ΩÂØùÊ≤ÅÈùíËΩªÊ∞¢ÂÄæÂçøÊ∏ÖÊìéÊô¥Ê∞∞ÊÉÖÈ°∑ËØ∑Â∫ÜÁêºÁ©∑Áßã‰∏òÈÇ±ÁêÉÊ±ÇÂõöÈÖãÊ≥ÖË∂ãÂå∫ËõÜÊõ≤Ë∫ØÂ±àÈ©±Ê∏†"],["c840","ËèÆËèØËè≥",4,"Ëè∫ËèªËèºËèæËèøËêÄËêÇËêÖËêáËêàËêâËêäËêêËêí",5,"ËêôËêöËêõËêû",5,"Ëê©",7,"Ëê≤",5,"ËêπËê∫ËêªËêæ",7,"ËëáËëàËëâ"],["c880","Ëëä",6,"Ëëí",4,"ËëòËëùËëûËëüËë†Ëë¢Ëë§",4,"Ëë™ËëÆËëØËë∞Ëë≤Ëë¥Ëë∑ËëπËëªËëºÂèñÂ®∂ÈæãË∂£ÂéªÂúàÈ¢ßÊùÉÈÜõÊ≥âÂÖ®ÁóäÊã≥Áä¨Âà∏ÂäùÁº∫ÁÇîÁò∏Âç¥ÈπäÊ¶∑Á°ÆÈõÄË£ôÁæ§ÁÑ∂ÁáÉÂÜâÊüìÁì§Â£§ÊîòÂö∑ËÆ©È•∂Êâ∞ÁªïÊÉπÁÉ≠Â£¨‰ªÅ‰∫∫ÂøçÈüß‰ªªËÆ§ÂàÉÂ¶äÁ∫´Êâî‰ªçÊó•ÊàéËå∏ËìâËç£ËûçÁÜîÊ∫∂ÂÆπÁªíÂÜóÊèâÊüîËÇâËåπË†ïÂÑíÂ≠∫Â¶ÇËæ±‰π≥Ê±ùÂÖ•Ë§•ËΩØÈòÆËïäÁëûÈîêÈó∞Ê∂¶Ëã•Âº±ÊííÊ¥íËê®ËÖÆÈ≥ÉÂ°ûËµõ‰∏âÂèÅ"],["c940","ËëΩ",4,"ËíÉËíÑËíÖËíÜËíäËíçËíè",7,"ËíòËíöËíõËíùËíûËíüËí†Ëí¢",12,"Ëí∞Ëí±Ëí≥ËíµËí∂Ëí∑ËíªËíºËíæËìÄËìÇËìÉËìÖËìÜËìáËìàËìãËìåËìéËìèËìíËìîËìïËìó"],["c980","Ëìò",4,"ËìûËì°Ëì¢Ëì§Ëìß",4,"Ëì≠ËìÆËìØËì±",10,"ËìΩËìæËîÄËîÅËîÇ‰ºûÊï£Ê°ëÂóì‰∏ßÊêîÈ™öÊâ´Â´ÇÁëüËâ≤Ê∂©Ê£ÆÂÉßËééÁ†ÇÊùÄÂàπÊ≤ôÁ∫±ÂÇªÂï•ÁÖûÁ≠õÊôíÁèäËã´ÊùâÂ±±Âà†ÁÖΩË°´Èó™ÈôïÊìÖËµ°ËÜ≥ÂñÑÊ±ïÊâáÁºÆÂ¢í‰º§ÂïÜËµèÊôå‰∏äÂ∞öË£≥Ê¢¢ÊçéÁ®çÁÉßËäçÂã∫Èü∂Â∞ëÂì®ÈÇµÁªçÂ•¢ËµäËõáËàåËàçËµ¶ÊëÑÂ∞ÑÊÖëÊ∂âÁ§æËÆæÁ†∑Áî≥Âëª‰º∏Ë∫´Ê∑±Â®†ÁªÖÁ•ûÊ≤àÂÆ°Â©∂ÁîöËÇæÊÖéÊ∏óÂ£∞ÁîüÁî•Áâ≤ÂçáÁª≥"],["ca40","ËîÉ",8,"ËîçËîéËîèËîêËîíËîîËîïËîñËîòËîôËîõËîúËîùËîûËî†Ëî¢",8,"Ëî≠",9,"Ëîæ",4,"ËïÑËïÖËïÜËïáËïã",10],["ca80","ËïóËïòËïöËïõËïúËïùËïü",4,"Ëï•Ëï¶ËïßËï©",8,"Ëï≥ËïµËï∂Ëï∑Ëï∏ËïºËïΩËïøËñÄËñÅÁúÅÁõõÂâ©ËÉúÂú£Â∏àÂ§±ÁãÆÊñΩÊπøËØóÂ∞∏Ëô±ÂçÅÁü≥ÊãæÊó∂‰ªÄÈ£üËöÄÂÆûËØÜÂè≤Áü¢‰ΩøÂ±éÈ©∂ÂßãÂºèÁ§∫Â£´‰∏ñÊüø‰∫ãÊã≠Ë™ìÈÄùÂäøÊòØÂóúÂô¨ÈÄÇ‰ªï‰æçÈáäÈ•∞Ê∞èÂ∏ÇÊÅÉÂÆ§ËßÜËØïÊî∂ÊâãÈ¶ñÂÆàÂØøÊéàÂîÆÂèóÁò¶ÂÖΩËî¨Êû¢Ê¢≥ÊÆäÊäíËæìÂèîËàíÊ∑ëÁñè‰π¶ËµéÂ≠∞ÁÜüËñØÊöëÊõôÁΩ≤ËúÄÈªçÈº†Â±ûÊúØËø∞Ê†ëÊùüÊàçÁ´ñÂ¢ÖÂ∫∂Êï∞Êº±"],["cb40","ËñÇËñÉËñÜËñà",6,"Ëñê",10,"Ëñù",6,"Ëñ•Ëñ¶ËñßËñ©Ëñ´Ëñ¨Ëñ≠Ëñ±",5,"Ëñ∏Ëñ∫",6,"ËóÇ",6,"Ëóä",4,"ËóëËóí"],["cb80","ËóîËóñ",5,"Ëóù",6,"Ëó•Ëó¶ËóßËó®Ëó™",14,"ÊÅïÂà∑ËÄçÊëîË°∞Áî©Â∏ÖÊ†ìÊã¥ÈúúÂèåÁàΩË∞ÅÊ∞¥Áù°Á®éÂêÆÁû¨È°∫ËàúËØ¥Á°ïÊúîÁÉÅÊñØÊíïÂò∂ÊÄùÁßÅÂè∏‰∏ùÊ≠ªËÇÜÂØ∫Âó£Âõõ‰º∫‰ººÈ•≤Â∑≥ÊùæËÄ∏ÊÄÇÈ¢ÇÈÄÅÂÆãËÆºËØµÊêúËâòÊìûÂóΩËãèÈÖ•‰øóÁ¥†ÈÄüÁ≤üÂÉ≥Â°ëÊ∫ØÂÆøËØâËÇÉÈÖ∏ËíúÁÆóËôΩÈöãÈöèÁª•È´ìÁ¢éÂ≤ÅÁ©óÈÅÇÈößÁ•üÂ≠ôÊçüÁ¨ãËìëÊ¢≠ÂîÜÁº©ÁêêÁ¥¢ÈîÅÊâÄÂ°å‰ªñÂÆÉÂ•πÂ°î"],["cc40","ËóπËó∫ËóºËóΩËóæËòÄ",4,"ËòÜ",10,"ËòíËòìËòîËòïËòó",15,"Ëò®Ëò™",13,"ËòπËò∫ËòªËòΩËòæËòøËôÄ"],["cc80","ËôÅ",11,"ËôíËôìËôï",4,"ËôõËôúËôùËôüËô†Ëô°Ëô£",7,"Áç≠ÊåûËπãË∏èËÉéËãîÊä¨Âè∞Ê≥∞ÈÖûÂ§™ÊÄÅÊ±∞ÂùçÊëäË¥™Áò´Êª©ÂùõÊ™ÄÁó∞ÊΩ≠Ë∞≠Ë∞àÂù¶ÊØØË¢íÁ¢≥Êé¢ÂèπÁÇ≠Ê±§Â°òÊê™Â†ÇÊ£†ËÜõÂîêÁ≥ñÂÄòË∫∫Ê∑åË∂üÁÉ´ÊéèÊ∂õÊªîÁª¶ËêÑÊ°ÉÈÄÉÊ∑òÈô∂ËÆ®Â•óÁâπËó§ËÖæÁñºË™äÊ¢ØÂâîË∏¢ÈîëÊèêÈ¢òËπÑÂïº‰ΩìÊõøÂöèÊÉïÊ∂ïÂâÉÂ±âÂ§©Ê∑ªÂ°´Áî∞ÁîúÊÅ¨ËàîËÖÜÊåëÊù°Ëø¢Áú∫Ë∑≥Ë¥¥ÈìÅÂ∏ñÂéÖÂê¨ÁÉÉ"],["cd40","Ëô≠ËôØËô∞Ëô≤",6,"ËöÉ",6,"Ëöé",4,"ËöîËöñ",5,"Ëöû",4,"Ëö•Ëö¶Ëö´Ëö≠ËöÆËö≤Ëö≥Ëö∑Ëö∏ËöπËöª",4,"ËõÅËõÇËõÉËõÖËõàËõåËõçËõíËõìËõïËõñËõóËõöËõú"],["cd80","ËõùËõ†Ëõ°Ëõ¢Ëõ£Ëõ•Ëõ¶ËõßËõ®Ëõ™Ëõ´Ëõ¨ËõØËõµËõ∂Ëõ∑Ëõ∫ËõªËõºËõΩËõøËúÅËúÑËúÖËúÜËúãËúåËúéËúèËúêËúëËúîËúñÊ±ÄÂª∑ÂÅú‰∫≠Â∫≠Êå∫ËâáÈÄöÊ°êÈÖÆÁû≥ÂêåÈìúÂΩ§Á´•Ê°∂ÊçÖÁ≠íÁªüÁóõÂÅ∑ÊäïÂ§¥ÈÄèÂá∏ÁßÉÁ™ÅÂõæÂæíÈÄîÊ∂ÇÂ±†ÂúüÂêêÂÖîÊπçÂõ¢Êé®È¢ìËÖøËúïË§™ÈÄÄÂêûÂ±ØËáÄÊãñÊâòËÑ±È∏µÈôÄÈ©ÆÈ©ºÊ§≠Â¶•ÊãìÂîæÊåñÂìáËõôÊ¥ºÂ®ÉÁì¶Ë¢úÊ≠™Â§ñË±åÂºØÊπæÁé©È°Ω‰∏∏ÁÉ∑ÂÆåÁ¢óÊåΩÊôöÁöñÊÉãÂÆõÂ©â‰∏áËÖïÊ±™Áéã‰∫°ÊûâÁΩëÂæÄÊó∫ÊúõÂøòÂ¶ÑÂ®Å"],["ce40","ËúôËúõËúùËúüËú†Ëú§Ëú¶ËúßËú®Ëú™Ëú´Ëú¨Ëú≠ËúØËú∞Ëú≤Ëú≥ËúµËú∂Ëú∏ËúπËú∫ËúºËúΩËùÄ",6,"ËùäËùãËùçËùèËùêËùëËùíËùîËùïËùñËùòËùö",5,"Ëù°Ëù¢Ëù¶",7,"ËùØËù±Ëù≤Ëù≥Ëùµ"],["ce80","Ëù∑Ëù∏ËùπËù∫ËùøËûÄËûÅËûÑËûÜËûáËûâËûäËûåËûé",4,"ËûîËûïËûñËûò",6,"Ëû†",4,"Â∑çÂæÆÂç±Èü¶ËøùÊ°ÖÂõ¥ÂîØÊÉü‰∏∫ÊΩçÁª¥ËãáËêéÂßî‰ºü‰º™Â∞æÁ∫¨Êú™ËîöÂë≥ÁïèËÉÉÂñÇÈ≠è‰ΩçÊ∏≠Ë∞ìÂ∞âÊÖ∞Âç´ÁòüÊ∏©ËöäÊñáÈóªÁ∫πÂêªÁ®≥Á¥äÈóÆÂó°ÁøÅÁìÆÊåùËúóÊ∂°Á™ùÊàëÊñ°ÂçßÊè°Ê≤ÉÂ∑´ÂëúÈí®‰πåÊ±°ËØ¨Â±ãÊó†ËäúÊ¢ßÂêæÂê¥ÊØãÊ≠¶‰∫îÊçÇÂçàËàû‰ºç‰æÆÂùûÊàäÈõæÊô§Áâ©ÂãøÂä°ÊÇüËØØÊòîÁÜôÊûêË•øÁ°íÁüΩÊô∞ÂòªÂê∏Èî°Áâ∫"],["cf40","Ëû•Ëû¶ËûßËû©Ëû™ËûÆËû∞Ëû±Ëû≤Ëû¥Ëû∂Ëû∑Ëû∏ËûπËûªËûºËûæËûøËüÅ",4,"ËüáËüàËüâËüå",4,"Ëüî",6,"ËüúËüùËüûËüüËü°Ëü¢Ëü£Ëü§Ëü¶ËüßËü®Ëü©Ëü´Ëü¨Ëü≠ËüØ",9],["cf80","Ëü∫ËüªËüºËüΩËüøË†ÄË†ÅË†ÇË†Ñ",5,"Ë†ã",7,"Ë†îË†óË†òË†ôË†öË†ú",4,"Ë†£Á®ÄÊÅØÂ∏åÊÇâËÜùÂ§ïÊÉúÁÜÑÁÉØÊ∫™Ê±êÁäÄÊ™ÑË¢≠Â∏≠‰π†Â™≥ÂñúÈì£Ê¥óÁ≥ªÈöôÊàèÁªÜÁûéËôæÂå£ÈúûËæñÊöáÂ≥°‰æ†Áã≠‰∏ãÂé¶Â§èÂêìÊéÄÈî®ÂÖà‰ªôÈ≤úÁ∫§Âí∏Ë¥§Ë°îËà∑Èó≤Ê∂éÂº¶Â´åÊòæÈô©Áé∞ÁåÆÂéøËÖ∫È¶ÖÁæ°ÂÆ™Èô∑ÈôêÁ∫øÁõ∏Âé¢Èï∂È¶ôÁÆ±Ë•ÑÊπò‰π°ÁøîÁ••ËØ¶ÊÉ≥Âìç‰∫´È°πÂ∑∑Ê©°ÂÉèÂêëË±°ËêßÁ°ùÈúÑÂâäÂìÆÂö£ÈîÄÊ∂àÂÆµÊ∑ÜÊôì"],["d040","Ë†§",13,"Ë†≥",5,"Ë†∫Ë†ªË†ΩË†æË†øË°ÅË°ÇË°ÉË°Ü",5,"Ë°é",5,"Ë°ïË°ñË°òË°ö",6,"Ë°¶Ë°ßË°™Ë°≠Ë°ØË°±Ë°≥Ë°¥Ë°µË°∂Ë°∏Ë°πË°∫"],["d080","Ë°ªË°ºË¢ÄË¢ÉË¢ÜË¢áË¢âË¢äË¢åË¢éË¢èË¢êË¢ëË¢ìË¢îË¢ïË¢ó",4,"Ë¢ù",4,"Ë¢£Ë¢•",5,"Â∞èÂ≠ùÊ†°ËÇñÂï∏Á¨ëÊïàÊ•î‰∫õÊ≠áËùéÈûãÂçèÊåüÊê∫ÈÇ™ÊñúËÉÅË∞êÂÜôÊ¢∞Âç∏ËüπÊáàÊ≥ÑÊ≥ªË∞¢Â±ëËñ™ËäØÈîåÊ¨£ËæõÊñ∞ÂøªÂøÉ‰ø°Ë°ÖÊòüËÖ•Áå©ÊÉ∫ÂÖ¥ÂàëÂûãÂΩ¢ÈÇ¢Ë°åÈÜíÂπ∏ÊùèÊÄßÂßìÂÖÑÂá∂ËÉ∏ÂåàÊ±πÈõÑÁÜä‰ºë‰øÆÁæûÊúΩÂóÖÈîàÁßÄË¢ñÁª£Â¢üÊàåÈúÄËôöÂòòÈ°ªÂæêËÆ∏ËìÑÈÖóÂèôÊó≠Â∫èÁïúÊÅ§ÁµÆÂ©øÁª™Áª≠ËΩ©ÂñßÂÆ£ÊÇ¨ÊóãÁéÑ"],["d140","Ë¢¨Ë¢ÆË¢ØË¢∞Ë¢≤",4,"Ë¢∏Ë¢πË¢∫Ë¢ªË¢ΩË¢æË¢øË£ÄË£ÉË£ÑË£áË£àË£äË£ãË£åË£çË£èË£êË£ëË£ìË£ñË£óË£ö",4,"Ë£†Ë£°Ë£¶Ë£ßË£©",6,"Ë£≤Ë£µË£∂Ë£∑Ë£∫Ë£ªË£ΩË£øË§ÄË§ÅË§É",5],["d180","Ë§âË§ã",4,"Ë§ëË§î",4,"Ë§ú",4,"Ë§¢Ë§£Ë§§Ë§¶Ë§ßË§®Ë§©Ë§¨Ë§≠Ë§ÆË§ØË§±Ë§≤Ë§≥Ë§µË§∑ÈÄâÁô£Áú©ÁªöÈù¥ËñõÂ≠¶Á©¥Èõ™Ë°ÄÂããÁÜèÂæ™Êó¨ËØ¢ÂØªÈ©ØÂ∑°ÊÆâÊ±õËÆ≠ËÆØÈÄäËøÖÂéãÊäºÈ∏¶È∏≠ÂëÄ‰∏´ËäΩÁâôËöúÂ¥ñË°ôÊ∂ØÈõÖÂìë‰∫öËÆ∂ÁÑâÂíΩÈòâÁÉüÊ∑πÁõê‰∏•Á†îËúíÂ≤©Âª∂Ë®ÄÈ¢úÈòéÁÇéÊ≤øÂ•ÑÊé©ÁúºË°çÊºîËâ≥Â†∞ÁáïÂéåÁ†öÈõÅÂîÅÂΩ¶ÁÑ∞ÂÆ¥Ë∞öÈ™åÊÆÉÂ§ÆÈ∏ØÁßßÊù®Êâ¨‰ΩØÁñ°ÁæäÊ¥ãÈò≥Ê∞ß‰ª∞ÁóíÂÖªÊ†∑ÊºæÈÇÄËÖ∞Â¶ñÁë∂"],["d240","Ë§∏",8,"Ë•ÇË•ÉË•Ö",24,"Ë•†",5,"Ë•ß",19,"Ë•º"],["d280","Ë•ΩË•æË¶ÄË¶ÇË¶ÑË¶ÖË¶á",26,"ÊëáÂ∞ßÈÅ•Á™ëË∞£ÂßöÂí¨ËàÄËçØË¶ÅËÄÄÊ§∞ÂôéËÄ∂Áà∑ÈáéÂÜ∂‰πüÈ°µÊéñ‰∏öÂè∂Êõ≥ËÖãÂ§úÊ∂≤‰∏ÄÂ£πÂåªÊèñÈì±‰æù‰ºäË°£È¢êÂ§∑ÈÅóÁßª‰ª™ËÉ∞ÁñëÊ≤ÇÂÆúÂß®ÂΩùÊ§ÖËöÅÂÄöÂ∑≤‰πôÁü£‰ª•Ëâ∫ÊäëÊòìÈÇëÂ±π‰∫øÂΩπËáÜÈÄ∏ËÇÑÁñ´‰∫¶Ë£îÊÑèÊØÖÂøÜ‰πâÁõäÊ∫¢ËØ£ËÆÆË∞äËØëÂºÇÁøºÁøåÁªéËåµËç´Âõ†ÊÆ∑Èü≥Èò¥ÂßªÂêüÈì∂Ê∑´ÂØÖÈ•ÆÂ∞πÂºïÈöê"],["d340","Ë¶¢",30,"ËßÉËßçËßìËßîËßïËßóËßòËßôËßõËßùËßüËß†Ëß°Ëß¢Ëß§ËßßËß®Ëß©Ëß™Ëß¨Ëß≠ËßÆËß∞Ëß±Ëß≤Ëß¥",6],["d380","Ëßª",4,"Ë®Å",5,"Ë®à",21,"Âç∞Ëã±Ê®±Â©¥Èπ∞Â∫îÁº®ËéπËê§Ëê•ËçßËùáËøéËµ¢ÁõàÂΩ±È¢ñÁ°¨Êò†ÂìüÊã•‰Ω£ËáÉÁóàÂ∫∏ÈõçË∏äËõπÂíèÊ≥≥Ê∂åÊ∞∏ÊÅøÂãáÁî®ÂπΩ‰ºòÊÇ†ÂøßÂ∞§Áî±ÈÇÆÈìÄÁäπÊ≤πÊ∏∏ÈÖâÊúâÂèãÂè≥‰ΩëÈáâËØ±ÂèàÂπºËøÇÊ∑§‰∫éÁõÇÊ¶ÜËôûÊÑöËàÜ‰Ωô‰øûÈÄæÈ±ºÊÑâÊ∏ùÊ∏îÈöÖ‰∫àÂ®±Èõ®‰∏éÂ±øÁ¶πÂÆáËØ≠ÁæΩÁéâÂüüËäãÈÉÅÂêÅÈÅáÂñªÂ≥™Âæ°ÊÑàÊ¨≤Áã±ËÇ≤Ë™â"],["d440","Ë®û",31,"Ë®ø",8,"Ë©â",21],["d480","Ë©ü",25,"Ë©∫",6,"Êµ¥ÂØìË£ïÈ¢ÑË±´È©≠È∏≥Ê∏äÂÜ§ÂÖÉÂû£Ë¢ÅÂéüÊè¥ËæïÂõ≠ÂëòÂúÜÁåøÊ∫êÁºòËøúËãëÊÑøÊÄ®Èô¢Êõ∞Á∫¶Ë∂äË∑ÉÈí•Â≤≥Á≤§ÊúàÊÇ¶ÈòÖËÄò‰∫ëÈÉßÂåÄÈô®ÂÖÅËøêËï¥ÈÖùÊôïÈüµÂ≠ïÂåùÁ†∏ÊùÇÊ†ΩÂìâÁÅæÂÆ∞ËΩΩÂÜçÂú®Âí±ÊîíÊöÇËµûËµÉËÑèËë¨ÈÅ≠Á≥üÂáøËóªÊû£Êó©Êæ°Ëö§Ë∫ÅÂô™ÈÄ†ÁöÇÁÅ∂Áá•Ë¥£Êã©ÂàôÊ≥ΩË¥ºÊÄéÂ¢ûÊÜéÊõæËµ†ÊâéÂñ≥Ê∏£Êú≠ËΩß"],["d540","Ë™Å",7,"Ë™ã",7,"Ë™î",46],["d580","Ë´É",32,"Èì°Èó∏Áú®Ê†ÖÊ¶®Âíã‰πçÁÇ∏ËØàÊëòÊñãÂÆÖÁ™ÑÂÄ∫ÂØ®ÁûªÊØ°Ë©πÁ≤òÊ≤æÁõèÊñ©ËæóÂ¥≠Â±ïËò∏Ê†àÂç†ÊàòÁ´ôÊπõÁªΩÊ®üÁ´†ÂΩ∞Êº≥Âº†ÊéåÊ∂®Êùñ‰∏àÂ∏êË¥¶‰ªóËÉÄÁò¥ÈöúÊãõÊò≠ÊâæÊ≤ºËµµÁÖßÁΩ©ÂÖÜËÇáÂè¨ÈÅÆÊäòÂì≤Ëõ∞ËæôËÄÖÈîóËîóËøôÊµôÁèçÊñüÁúüÁîÑÁ†ßËáªË¥ûÈíà‰æ¶ÊûïÁñπËØäÈúáÊåØÈïáÈòµËí∏Êå£ÁùÅÂæÅÁã∞‰∫âÊÄîÊï¥ÊãØÊ≠£Êîø"],["d640","Ë´§",34,"Ë¨à",27],["d680","Ë¨§Ë¨•Ë¨ß",30,"Â∏ßÁóáÈÉëËØÅËäùÊûùÊîØÂê±ËúòÁü•ËÇ¢ËÑÇÊ±Å‰πãÁªáËÅåÁõ¥Ê§çÊÆñÊâßÂÄº‰æÑÂùÄÊåáÊ≠¢Ë∂æÂè™Êó®Á∫∏ÂøóÊåöÊé∑Ëá≥Ëá¥ÁΩÆÂ∏úÂ≥ôÂà∂Êô∫Áß©Á®öË¥®ÁÇôÁóîÊªûÊ≤ªÁ™í‰∏≠ÁõÖÂø†ÈíüË°∑ÁªàÁßçËÇøÈáç‰ª≤‰ºóËàüÂë®Â∑ûÊ¥≤ËØåÁ≤•ËΩ¥ËÇòÂ∏öÂííÁö±ÂÆôÊòºÈ™§Áè†Ê†™ËõõÊú±Áå™ËØ∏ËØõÈÄêÁ´πÁÉõÁÖÆÊãÑÁû©Âò±‰∏ªËëóÊü±Âä©ËõÄË¥ÆÈì∏Á≠ë"],["d740","Ë≠Ü",31,"Ë≠ß",4,"Ë≠≠",25],["d780","ËÆá",24,"ËÆ¨ËÆ±ËÆªËØáËØêËØ™Ë∞âË∞û‰ΩèÊ≥®Á•ùÈ©ªÊäìÁà™ÊãΩ‰∏ìÁ†ñËΩ¨Êí∞ËµöÁØÜÊ°©Â∫ÑË£ÖÂ¶ÜÊíûÂ£ÆÁä∂Ê§éÈî•ËøΩËµòÂù†ÁºÄË∞ÜÂáÜÊçâÊãôÂçìÊ°åÁê¢ËåÅÈÖåÂïÑÁùÄÁÅºÊµäÂÖπÂí®ËµÑÂßøÊªãÊ∑ÑÂ≠úÁ¥´‰ªîÁ±ΩÊªìÂ≠êËá™Ê∏çÂ≠óÈ¨ÉÊ£ïË∏™ÂÆóÁªºÊÄªÁ∫µÈÇπËµ∞Â•èÊèçÁßüË∂≥ÂçíÊóèÁ•ñËØÖÈòªÁªÑÈíªÁ∫ÇÂò¥ÈÜâÊúÄÁΩ™Â∞äÈÅµÊò®Â∑¶‰ΩêÊüûÂÅö‰ΩúÂùêÂ∫ß"],["d840","Ë∞∏",8,"Ë±ÇË±ÉË±ÑË±ÖË±àË±äË±ãË±ç",7,"Ë±ñË±óË±òË±ôË±õ",5,"Ë±£",6,"Ë±¨",6,"Ë±¥Ë±µË±∂Ë±∑Ë±ª",6,"Ë≤ÉË≤ÑË≤ÜË≤á"],["d880","Ë≤àË≤ãË≤ç",6,"Ë≤ïË≤ñË≤óË≤ô",20,"‰∫ç‰∏åÂÖÄ‰∏êÂªøÂçÖ‰∏ï‰∫ò‰∏ûÈ¨≤Â≠¨Âô©‰∏®Á¶∫‰∏øÂåï‰πáÂ§≠ÁàªÂçÆÊ∞êÂõüËÉ§È¶óÊØìÁùæÈºó‰∏∂‰∫üÈºê‰πú‰π©‰∫ìËäàÂ≠õÂï¨Âòè‰ªÑÂéçÂéùÂé£Âé•ÂéÆÈù•ËµùÂåöÂèµÂå¶ÂåÆÂåæËµúÂç¶Âç£ÂàÇÂààÂàéÂà≠Âà≥ÂàøÂâÄÂâåÂâûÂâ°ÂâúËíØÂâΩÂäÇÂäÅÂäêÂäìÂÜÇÁΩî‰∫ª‰ªÉ‰ªâ‰ªÇ‰ª®‰ª°‰ª´‰ªû‰ºõ‰ª≥‰º¢‰Ω§‰ªµ‰º•‰ºß‰ºâ‰º´‰Ωû‰ΩßÊî∏‰Ωö‰Ωù"],["d940","Ë≤Æ",62],["d980","Ë≥≠",32,"‰Ωü‰Ωó‰º≤‰ºΩ‰Ω∂‰Ω¥‰æë‰æâ‰æÉ‰æè‰Ωæ‰Ωª‰æ™‰Ωº‰æ¨‰æî‰ø¶‰ø®‰ø™‰øÖ‰øö‰ø£‰øú‰øë‰øü‰ø∏ÂÄ©ÂÅå‰ø≥ÂÄ¨ÂÄèÂÄÆÂÄ≠‰øæÂÄúÂÄåÂÄ•ÂÄ®ÂÅæÂÅÉÂÅïÂÅàÂÅéÂÅ¨ÂÅªÂÇ•ÂÇßÂÇ©ÂÇ∫ÂÉñÂÑÜÂÉ≠ÂÉ¨ÂÉ¶ÂÉÆÂÑáÂÑã‰ªùÊ∞Ω‰Ωò‰Ω•‰øéÈæ†Ê±ÜÁ±¥ÂÖÆÂ∑ΩÈªâÈ¶òÂÜÅÂ§îÂãπÂåçË®áÂåêÂá´Â§ôÂÖï‰∫†ÂÖñ‰∫≥Ë°ÆË¢§‰∫µËÑîË£íÁ¶ÄÂ¨¥Ë†ÉÁæ∏ÂÜ´ÂÜ±ÂÜΩÂÜº"],["da40","Ë¥é",14,"Ë¥†ËµëËµíËµóËµüËµ•Ëµ®Ëµ©Ëµ™Ëµ¨ËµÆËµØËµ±Ëµ≤Ëµ∏",8,"Ë∂ÇË∂ÉË∂ÜË∂áË∂àË∂âË∂å",4,"Ë∂íË∂ìË∂ï",9,"Ë∂†Ë∂°"],["da80","Ë∂¢Ë∂§",12,"Ë∂≤Ë∂∂Ë∂∑Ë∂πË∂ªË∂ΩË∑ÄË∑ÅË∑ÇË∑ÖË∑áË∑àË∑âË∑äË∑çË∑êË∑íË∑ìË∑îÂááÂÜñÂÜ¢ÂÜ•ËÆ†ËÆ¶ËÆßËÆ™ËÆ¥ËÆµËÆ∑ËØÇËØÉËØãËØèËØéËØíËØìËØîËØñËØòËØôËØúËØüËØ†ËØ§ËØ®ËØ©ËØÆËØ∞ËØ≥ËØ∂ËØπËØºËØøË∞ÄË∞ÇË∞ÑË∞áË∞åË∞èË∞ëË∞íË∞îË∞ïË∞ñË∞ôË∞õË∞òË∞ùË∞üË∞†Ë∞°Ë∞•Ë∞ßË∞™Ë∞´Ë∞ÆË∞ØË∞≤Ë∞≥Ë∞µË∞∂Âç©Âç∫ÈòùÈò¢Èò°Èò±Èò™ÈòΩÈòºÈôÇÈôâÈôîÈôüÈôßÈô¨Èô≤Èô¥ÈöàÈöçÈöóÈö∞ÈÇóÈÇõÈÇùÈÇôÈÇ¨ÈÇ°ÈÇ¥ÈÇ≥ÈÇ∂ÈÇ∫"],["db40","Ë∑ïË∑òË∑ôË∑úË∑†Ë∑°Ë∑¢Ë∑•Ë∑¶Ë∑ßË∑©Ë∑≠Ë∑ÆË∑∞Ë∑±Ë∑≤Ë∑¥Ë∑∂Ë∑ºË∑æ",6,"Ë∏ÜË∏áË∏àË∏ãË∏çË∏éË∏êË∏ëË∏íË∏ìË∏ï",7,"Ë∏†Ë∏°Ë∏§",4,"Ë∏´Ë∏≠Ë∏∞Ë∏≤Ë∏≥Ë∏¥Ë∏∂Ë∏∑Ë∏∏Ë∏ªË∏ºË∏æ"],["db80","Ë∏øËπÉËπÖËπÜËπå",4,"Ëπì",5,"Ëπö",11,"ËπßËπ®Ëπ™Ëπ´ËπÆËπ±ÈÇ∏ÈÇ∞ÈÉèÈÉÖÈÇæÈÉêÈÉÑÈÉáÈÉìÈÉ¶ÈÉ¢ÈÉúÈÉóÈÉõÈÉ´ÈÉØÈÉæÈÑÑÈÑ¢ÈÑûÈÑ£ÈÑ±ÈÑØÈÑπÈÖÉÈÖÜÂàçÂ•ÇÂä¢Âä¨Âä≠ÂäæÂìøÂãêÂãñÂã∞ÂèüÁáÆÁüçÂª¥ÂáµÂáºÈ¨ØÂé∂ÂºÅÁïöÂ∑ØÂùåÂû©Âû°Â°æÂ¢ºÂ£ÖÂ£ëÂú©Âú¨Âú™Âú≥ÂúπÂúÆÂúØÂùúÂúªÂùÇÂù©ÂûÖÂù´ÂûÜÂùºÂùªÂù®Âù≠Âù∂Âù≥Âû≠Âû§ÂûåÂû≤ÂüèÂûßÂû¥ÂûìÂû†ÂüïÂüòÂüöÂüôÂüíÂû∏Âü¥ÂüØÂü∏Âü§Âüù"],["dc40","Ëπ≥ËπµËπ∑",4,"ËπΩËπæË∫ÄË∫ÇË∫ÉË∫ÑË∫ÜË∫à",6,"Ë∫ëË∫íË∫ìË∫ï",6,"Ë∫ùË∫ü",11,"Ë∫≠Ë∫ÆË∫∞Ë∫±Ë∫≥",6,"Ë∫ª",7],["dc80","ËªÉ",10,"Ëªè",21,"Â†ãÂ†çÂüΩÂü≠Â†ÄÂ†ûÂ†ôÂ°ÑÂ††Â°•Â°¨Â¢ÅÂ¢âÂ¢öÂ¢ÄÈ¶®ÈºôÊáøËâπËâΩËâøËäèËääËä®ËäÑËäéËäëËäóËäôËä´Ëä∏ËäæËä∞ËãàËãäËã£ËäòËä∑ËäÆËããËãåËãÅËä©Ëä¥Ëä°Ëä™ËäüËãÑËãéËä§Ëã°ËåâËã∑Ëã§ËåèËåáËãúËã¥ËãíËãòËååËãªËãìËåëËåöËåÜËåîËåïËã†ËãïËåúËçëËçõËçúËåàËéíËåºËå¥Ëå±ËéõËçûËåØËçèËçáËçÉËçüËçÄËåóËç†Ëå≠Ëå∫Ëå≥Ëç¶Ëç•"],["dd40","Ëª•",62],["dd80","Ëº§",32,"Ëç®ËåõËç©Ëç¨Ëç™Ëç≠ËçÆËé∞Ëç∏Ëé≥Ëé¥Ëé†Ëé™ËéìËéúËéÖËçºËé∂Ëé©ËçΩËé∏ËçªËéòËéûËé®Ëé∫ËéºËèÅËêÅËè•ËèòÂ†áËêòËêãËèùËèΩËèñËêúËê∏ËêëËêÜËèîËèüËêèËêÉËè∏ËèπËè™ËèÖËèÄËê¶Ëè∞Ëè°ËëúËëëËëöËëôËë≥ËíáËíàËë∫ËíâËë∏ËêºËëÜËë©Ëë∂ËíåËíéËê±Ëë≠ËìÅËìçËìêËì¶ËíΩËììËìäËíøËí∫Ëì†Ëí°ËíπËí¥ËíóËì•Ëì£ËîåÁîçËî∏Ëì∞ËîπËîüËî∫"],["de40","ËΩÖ",32,"ËΩ™ËæÄËæåËæíËæùËæ†Ëæ°Ëæ¢Ëæ§Ëæ•Ëæ¶ËæßËæ™Ëæ¨Ëæ≠ËæÆËæØËæ≤Ëæ≥Ëæ¥ËæµËæ∑Ëæ∏Ëæ∫ËæªËæºËæøËøÄËøÉËøÜ"],["de80","Ëøâ",4,"ËøèËøíËøñËøóËøöËø†Ëø°Ëø£ËøßËø¨ËøØËø±Ëø≤Ëø¥ËøµËø∂Ëø∫ËøªËøºËøæËøøÈÄáÈÄàÈÄåÈÄéÈÄìÈÄïÈÄòËïñËîªËìøËìºËïôËïàËï®Ëï§ËïûËï∫Áû¢ËïÉËï≤ËïªËñ§Ëñ®ËñáËñèËïπËñÆËñúËñÖËñπËñ∑Ëñ∞ËóìËóÅËóúËóøËòßËòÖËò©ËòñËòºÂªæÂºàÂ§ºÂ•ÅËÄ∑Â•ïÂ•öÂ•òÂåèÂ∞¢Â∞•Â∞¨Â∞¥ÊâåÊâ™ÊäüÊäªÊãäÊãöÊãóÊãÆÊå¢Êã∂ÊåπÊçãÊçÉÊé≠Êè∂Êç±Êç∫ÊééÊé¥Êç≠Êé¨ÊéäÊç©ÊéÆÊéºÊè≤Êè∏Êè†ÊèøÊèÑÊèûÊèéÊëíÊèÜÊéæÊëÖÊëÅÊêãÊêõÊê†ÊêåÊê¶Êê°ÊëûÊíÑÊë≠Êíñ"],["df40","ÈÄôÈÄúÈÄ£ÈÄ§ÈÄ•ÈÄß",5,"ÈÄ∞",4,"ÈÄ∑ÈÄπÈÄ∫ÈÄΩÈÄøÈÅÄÈÅÉÈÅÖÈÅÜÈÅà",4,"ÈÅéÈÅîÈÅïÈÅñÈÅôÈÅöÈÅú",5,"ÈÅ§ÈÅ¶ÈÅßÈÅ©ÈÅ™ÈÅ´ÈÅ¨ÈÅØ",4,"ÈÅ∂",6,"ÈÅæÈÇÅ"],["df80","ÈÇÑÈÇÖÈÇÜÈÇáÈÇâÈÇäÈÇå",4,"ÈÇíÈÇîÈÇñÈÇòÈÇöÈÇúÈÇûÈÇüÈÇ†ÈÇ§ÈÇ•ÈÇßÈÇ®ÈÇ©ÈÇ´ÈÇ≠ÈÇ≤ÈÇ∑ÈÇºÈÇΩÈÇøÈÉÄÊë∫Êí∑Êí∏ÊíôÊí∫ÊìÄÊìêÊìóÊì§Êì¢ÊîâÊî•ÊîÆÂºãÂøíÁîôÂºëÂçüÂè±ÂèΩÂè©Âè®ÂèªÂêíÂêñÂêÜÂëãÂëíÂëìÂëîÂëñÂëÉÂê°ÂëóÂëôÂê£Âê≤ÂíÇÂíîÂë∑Âë±Âë§ÂíöÂíõÂíÑÂë∂Âë¶ÂíùÂìêÂí≠ÂìÇÂí¥ÂìíÂíßÂí¶ÂììÂìîÂë≤Âí£ÂìïÂíªÂíøÂìåÂìôÂìöÂìúÂí©Âí™Âí§ÂìùÂìèÂìûÂîõÂìßÂî†ÂìΩÂîîÂì≥Âî¢Âî£ÂîèÂîëÂîßÂî™ÂïßÂñèÂñµÂïâÂï≠ÂïÅÂïïÂîøÂïêÂîº"],["e040","ÈÉÇÈÉÉÈÉÜÈÉàÈÉâÈÉãÈÉåÈÉçÈÉíÈÉîÈÉïÈÉñÈÉòÈÉôÈÉöÈÉûÈÉüÈÉ†ÈÉ£ÈÉ§ÈÉ•ÈÉ©ÈÉ™ÈÉ¨ÈÉÆÈÉ∞ÈÉ±ÈÉ≤ÈÉ≥ÈÉµÈÉ∂ÈÉ∑ÈÉπÈÉ∫ÈÉªÈÉºÈÉøÈÑÄÈÑÅÈÑÉÈÑÖ",19,"ÈÑöÈÑõÈÑú"],["e080","ÈÑùÈÑüÈÑ†ÈÑ°ÈÑ§",10,"ÈÑ∞ÈÑ≤",6,"ÈÑ∫",8,"ÈÖÑÂî∑ÂïñÂïµÂï∂Âï∑Âî≥Âî∞ÂïúÂñãÂóíÂñÉÂñ±ÂñπÂñàÂñÅÂñüÂïæÂóñÂñëÂïªÂóüÂñΩÂñæÂñîÂñôÂó™Âó∑ÂóâÂòüÂóëÂó´Âó¨ÂóîÂó¶ÂóùÂóÑÂóØÂó•Âó≤Âó≥ÂóåÂóçÂó®ÂóµÂó§ËæîÂòûÂòàÂòåÂòÅÂò§Âò£ÂóæÂòÄÂòßÂò≠ÂôòÂòπÂôóÂò¨ÂôçÂô¢ÂôôÂôúÂôåÂôîÂöÜÂô§Âô±Âô´ÂôªÂôºÂöÖÂöìÂöØÂõîÂõóÂõùÂõ°ÂõµÂõ´ÂõπÂõøÂúÑÂúäÂúâÂúúÂ∏èÂ∏ôÂ∏îÂ∏ëÂ∏±Â∏ªÂ∏º"],["e140","ÈÖÖÈÖáÈÖàÈÖëÈÖìÈÖîÈÖïÈÖñÈÖòÈÖôÈÖõÈÖúÈÖüÈÖ†ÈÖ¶ÈÖßÈÖ®ÈÖ´ÈÖ≠ÈÖ≥ÈÖ∫ÈÖªÈÖºÈÜÄ",4,"ÈÜÜÈÜàÈÜäÈÜéÈÜèÈÜì",6,"ÈÜú",5,"ÈÜ§",5,"ÈÜ´ÈÜ¨ÈÜ∞ÈÜ±ÈÜ≤ÈÜ≥ÈÜ∂ÈÜ∑ÈÜ∏ÈÜπÈÜª"],["e180","ÈÜº",10,"ÈáàÈáãÈáêÈáí",9,"Èáù",8,"Â∏∑ÂπÑÂπîÂπõÂπûÂπ°Â≤åÂ±∫Â≤çÂ≤êÂ≤ñÂ≤àÂ≤òÂ≤ôÂ≤ëÂ≤öÂ≤úÂ≤µÂ≤¢Â≤ΩÂ≤¨Â≤´Â≤±Â≤£Â≥ÅÂ≤∑Â≥ÑÂ≥íÂ≥§Â≥ãÂ≥•Â¥ÇÂ¥ÉÂ¥ßÂ¥¶Â¥ÆÂ¥§Â¥ûÂ¥ÜÂ¥õÂµòÂ¥æÂ¥¥Â¥ΩÂµ¨ÂµõÂµØÂµùÂµ´ÂµãÂµäÂµ©Âµ¥Â∂ÇÂ∂ôÂ∂ùË±≥Â∂∑Â∑ÖÂΩ≥ÂΩ∑ÂæÇÂæáÂæâÂæåÂæïÂæôÂæúÂæ®Âæ≠ÂæµÂæºË°¢ÂΩ°Áä≠Áä∞Áä¥Áä∑Áä∏ÁãÉÁãÅÁãéÁãçÁãíÁã®ÁãØÁã©Áã≤Áã¥Áã∑ÁåÅÁã≥ÁåÉÁã∫"],["e240","Èá¶",62],["e280","Èà•",32,"ÁãªÁåóÁåìÁå°ÁåäÁåûÁåùÁåïÁå¢ÁåπÁå•Áå¨Áå∏Áå±ÁçêÁççÁçóÁç†Áç¨ÁçØÁçæËàõÂ§•È£ßÂ§§Â§ÇÈ•£È•ß",5,"È•¥È•∑È•ΩÈ¶ÄÈ¶ÑÈ¶áÈ¶äÈ¶çÈ¶êÈ¶ëÈ¶ìÈ¶îÈ¶ïÂ∫ÄÂ∫ëÂ∫ãÂ∫ñÂ∫•Â∫†Â∫πÂ∫µÂ∫æÂ∫≥ËµìÂªíÂªëÂªõÂª®Âª™ËÜ∫ÂøÑÂøâÂøñÂøèÊÄÉÂøÆÊÄÑÂø°Âø§ÂøæÊÄÖÊÄÜÂø™Âø≠Âø∏ÊÄôÊÄµÊÄ¶ÊÄõÊÄèÊÄçÊÄ©ÊÄ´ÊÄäÊÄøÊÄ°ÊÅ∏ÊÅπÊÅªÊÅ∫ÊÅÇ"],["e340","ÈâÜ",45,"Èâµ",16],["e380","ÈäÜ",7,"Èäè",24,"ÊÅ™ÊÅΩÊÇñÊÇöÊÇ≠ÊÇùÊÇÉÊÇíÊÇåÊÇõÊÉ¨ÊÇªÊÇ±ÊÉùÊÉòÊÉÜÊÉöÊÇ¥ÊÑ†ÊÑ¶ÊÑïÊÑ£ÊÉ¥ÊÑÄÊÑéÊÑ´ÊÖäÊÖµÊÜ¨ÊÜîÊÜßÊÜ∑ÊáîÊáµÂøùÈö≥Èó©Èó´Èó±Èó≥ÈóµÈó∂ÈóºÈóæÈòÉÈòÑÈòÜÈòàÈòäÈòãÈòåÈòçÈòèÈòíÈòïÈòñÈòóÈòôÈòö‰∏¨ÁàøÊàïÊ∞µÊ±îÊ±úÊ±äÊ≤£Ê≤ÖÊ≤êÊ≤îÊ≤åÊ±®Ê±©Ê±¥Ê±∂Ê≤ÜÊ≤©Ê≥êÊ≥îÊ≤≠Ê≥∑Ê≥∏Ê≥±Ê≥óÊ≤≤Ê≥†Ê≥ñÊ≥∫Ê≥´Ê≥ÆÊ≤±Ê≥ìÊ≥ØÊ≥æ"],["e440","Èä®",5,"ÈäØ",24,"Èãâ",31],["e480","Èã©",32,"Ê¥πÊ¥ßÊ¥åÊµÉÊµàÊ¥áÊ¥ÑÊ¥ôÊ¥éÊ¥´ÊµçÊ¥ÆÊ¥µÊ¥öÊµèÊµíÊµîÊ¥≥Ê∂ëÊµØÊ∂ûÊ∂†ÊµûÊ∂ìÊ∂îÊµúÊµ†ÊµºÊµ£Ê∏öÊ∑áÊ∑ÖÊ∑ûÊ∏éÊ∂øÊ∑†Ê∏ëÊ∑¶Ê∑ùÊ∑ôÊ∏ñÊ∂´Ê∏åÊ∂ÆÊ∏´ÊπÆÊπéÊπ´Ê∫≤ÊπüÊ∫ÜÊπìÊπîÊ∏≤Ê∏•ÊπÑÊªüÊ∫±Ê∫òÊª†Êº≠Êª¢Ê∫•Ê∫ßÊ∫ΩÊ∫ªÊ∫∑ÊªóÊ∫¥ÊªèÊ∫èÊªÇÊ∫üÊΩ¢ÊΩÜÊΩáÊº§ÊºïÊªπÊºØÊº∂ÊΩãÊΩ¥Êº™ÊºâÊº©ÊæâÊæçÊæåÊΩ∏ÊΩ≤ÊΩºÊΩ∫Êøë"],["e540","Èåä",51,"Èåø",10],["e580","Èçä",31,"Èç´ÊøâÊæßÊæπÊæ∂ÊøÇÊø°ÊøÆÊøûÊø†ÊøØÁÄöÁÄ£ÁÄõÁÄπÁÄµÁÅèÁÅûÂÆÄÂÆÑÂÆïÂÆìÂÆ•ÂÆ∏ÁîØÈ™ûÊê¥ÂØ§ÂØÆË§∞ÂØ∞ËπáË¨áËæ∂ËøìËøïËø•ËøÆËø§Ëø©Ëø¶Ëø≥Ëø®ÈÄÖÈÄÑÈÄãÈÄ¶ÈÄëÈÄçÈÄñÈÄ°ÈÄµÈÄ∂ÈÄ≠ÈÄØÈÅÑÈÅëÈÅíÈÅêÈÅ®ÈÅòÈÅ¢ÈÅõÊöπÈÅ¥ÈÅΩÈÇÇÈÇàÈÇÉÈÇãÂΩêÂΩóÂΩñÂΩòÂ∞ªÂí´Â±êÂ±ôÂ≠±Â±£Â±¶ÁæºÂº™Âº©Âº≠Ëâ¥ÂººÈ¨ªÂ±ÆÂ¶ÅÂ¶ÉÂ¶çÂ¶©Â¶™Â¶£"],["e640","Èç¨",34,"Èéê",27],["e680","Èé¨",29,"ÈèãÈèåÈèçÂ¶óÂßäÂ¶´Â¶ûÂ¶§ÂßíÂ¶≤Â¶ØÂßóÂ¶æÂ®ÖÂ®ÜÂßùÂ®àÂß£ÂßòÂßπÂ®åÂ®âÂ®≤Â®¥Â®ëÂ®£Â®ìÂ©ÄÂ©ßÂ©äÂ©ïÂ®ºÂ©¢Â©µËÉ¨Â™™Â™õÂ©∑Â©∫Â™æÂ´´Â™≤Â´íÂ´îÂ™∏Â´†Â´£Â´±Â´ñÂ´¶Â´òÂ´úÂ¨âÂ¨óÂ¨ñÂ¨≤Â¨∑Â≠ÄÂ∞ïÂ∞úÂ≠öÂ≠•Â≠≥Â≠ëÂ≠ìÂ≠¢È©µÈ©∑È©∏È©∫È©øÈ©ΩÈ™ÄÈ™ÅÈ™ÖÈ™àÈ™äÈ™êÈ™íÈ™ìÈ™ñÈ™òÈ™õÈ™úÈ™ùÈ™üÈ™†È™¢È™£È™•È™ßÁ∫üÁ∫°Á∫£Á∫•Á∫®Á∫©"],["e740","Èèé",7,"Èèó",54],["e780","Èêé",32,"Á∫≠Á∫∞Á∫æÁªÄÁªÅÁªÇÁªâÁªãÁªåÁªêÁªîÁªóÁªõÁª†Áª°Áª®Áª´ÁªÆÁªØÁª±Áª≤ÁºçÁª∂Áª∫ÁªªÁªæÁºÅÁºÇÁºÉÁºáÁºàÁºãÁºåÁºèÁºëÁºíÁºóÁºôÁºúÁºõÁºüÁº°",6,"Áº™Áº´Áº¨Áº≠ÁºØ",4,"ÁºµÂπ∫ÁïøÂ∑õÁîæÈÇïÁééÁéëÁéÆÁé¢ÁéüÁèèÁèÇÁèëÁé∑Áé≥ÁèÄÁèâÁèàÁè•ÁèôÈ°ºÁêäÁè©ÁèßÁèûÁé∫Áè≤ÁêèÁê™ÁëõÁê¶Áê•Áê®Áê∞ÁêÆÁê¨"],["e840","ÈêØ",14,"Èêø",43,"Èë¨Èë≠ÈëÆÈëØ"],["e880","Èë∞",20,"ÈíëÈíñÈíòÈìáÈìèÈììÈìîÈìöÈì¶ÈìªÈîúÈî†ÁêõÁêöÁëÅÁëúÁëóÁëïÁëôÁë∑Áë≠ÁëæÁíúÁíéÁíÄÁíÅÁíáÁíãÁíûÁí®Áí©ÁíêÁíßÁìíÁí∫Èü™Èü´Èü¨ÊùåÊùìÊùûÊùàÊù©Êû•ÊûáÊù™Êù≥ÊûòÊûßÊùµÊû®ÊûûÊû≠ÊûãÊù∑ÊùºÊü∞Ê†âÊüòÊ†äÊü©Êû∞Ê†åÊüôÊûµÊüöÊû≥ÊüùÊ†ÄÊüÉÊû∏Êü¢Ê†éÊüÅÊüΩÊ†≤Ê†≥Ê°†Ê°°Ê°éÊ°¢Ê°ÑÊ°§Ê¢ÉÊ†ùÊ°ïÊ°¶Ê°ÅÊ°ßÊ°ÄÊ†æÊ°äÊ°âÊ†©Ê¢µÊ¢èÊ°¥Ê°∑Ê¢ìÊ°´Ê£ÇÊ•ÆÊ£ºÊ§üÊ§†Ê£π"],["e940","ÈîßÈî≥ÈîΩÈïÉÈïàÈïãÈïïÈïöÈï†ÈïÆÈï¥ÈïµÈï∑",7,"ÈñÄ",42],["e980","Èñ´",32,"Ê§§Ê£∞Ê§ãÊ§ÅÊ•óÊ££Ê§êÊ•±Ê§πÊ•†Ê•ÇÊ•ùÊ¶ÑÊ•´Ê¶ÄÊ¶òÊ•∏Ê§¥ÊßåÊ¶áÊ¶àÊßéÊ¶âÊ•¶Ê•£Ê•πÊ¶õÊ¶ßÊ¶ªÊ¶´Ê¶≠ÊßîÊ¶±ÊßÅÊßäÊßüÊ¶ïÊß†Ê¶çÊßøÊ®ØÊß≠Ê®óÊ®òÊ©•Êß≤Ê©ÑÊ®æÊ™†Ê©êÊ©õÊ®µÊ™éÊ©πÊ®ΩÊ®®Ê©òÊ©ºÊ™ëÊ™êÊ™©Ê™óÊ™´Áå∑ÁçíÊÆÅÊÆÇÊÆáÊÆÑÊÆíÊÆìÊÆçÊÆöÊÆõÊÆ°ÊÆ™ËΩ´ËΩ≠ËΩ±ËΩ≤ËΩ≥ËΩµËΩ∂ËΩ∏ËΩ∑ËΩπËΩ∫ËΩºËΩæËæÅËæÇËæÑËæáËæã"],["ea40","Èóå",27,"Èó¨ÈóøÈòáÈòìÈòòÈòõÈòûÈò†Èò£",6,"Èò´Èò¨Èò≠ÈòØÈò∞Èò∑Èò∏ÈòπÈò∫ÈòæÈôÅÈôÉÈôäÈôéÈôèÈôëÈôíÈôìÈôñÈôó"],["ea80","ÈôòÈôôÈôöÈôúÈôùÈôûÈô†Èô£Èô•Èô¶Èô´Èô≠",4,"Èô≥Èô∏",12,"ÈöáÈöâÈöäËæçËæéËæèËæòËæöËªéÊàãÊàóÊàõÊàüÊà¢Êà°Êà•Êà§Êà¨ËáßÁìØÁì¥ÁìøÁîèÁîëÁîìÊî¥ÊóÆÊóØÊó∞ÊòäÊòôÊù≤ÊòÉÊòïÊòÄÁÇÖÊõ∑ÊòùÊò¥Êò±Êò∂ÊòµËÄÜÊôüÊôîÊôÅÊôèÊôñÊô°ÊôóÊô∑ÊöÑÊöåÊößÊöùÊöæÊõõÊõúÊõ¶Êõ©Ë¥≤Ë¥≥Ë¥∂Ë¥ªË¥ΩËµÄËµÖËµÜËµàËµâËµáËµçËµïËµôËßáËßäËßãËßåËßéËßèËßêËßëÁâÆÁäüÁâùÁâ¶ÁâØÁâæÁâøÁäÑÁäãÁäçÁäèÁäíÊåàÊå≤Êé∞"],["eb40","ÈöåÈöéÈöëÈöíÈöìÈöïÈöñÈööÈöõÈöù",9,"Èö®",7,"Èö±Èö≤Èö¥ÈöµÈö∑Èö∏Èö∫ÈöªÈöøÈõÇÈõÉÈõàÈõäÈõãÈõêÈõëÈõìÈõîÈõñ",9,"Èõ°",6,"Èõ´"],["eb80","Èõ¨Èõ≠ÈõÆÈõ∞Èõ±Èõ≤Èõ¥ÈõµÈõ∏Èõ∫ÈõªÈõºÈõΩÈõøÈúÇÈúÉÈúÖÈúäÈúãÈúåÈúêÈúëÈúíÈúîÈúïÈúó",4,"ÈúùÈúüÈú†ÊêøÊìòËÄÑÊØ™ÊØ≥ÊØΩÊØµÊØπÊ∞ÖÊ∞áÊ∞ÜÊ∞çÊ∞ïÊ∞òÊ∞ôÊ∞öÊ∞°Ê∞©Ê∞§Ê∞™Ê∞≤ÊîµÊïïÊï´ÁâçÁâíÁâñÁà∞Ëô¢ÂàñËÇüËÇúËÇìËÇºÊúäËÇΩËÇ±ËÇ´ËÇ≠ËÇ¥ËÇ∑ËÉßËÉ®ËÉ©ËÉ™ËÉõËÉÇËÉÑËÉôËÉçËÉóÊúêËÉùËÉ´ËÉ±ËÉ¥ËÉ≠ËÑçËÑéËÉ≤ËÉºÊúïËÑíË±öËÑ∂ËÑûËÑ¨ËÑòËÑ≤ËÖàËÖåËÖìËÖ¥ËÖôËÖöËÖ±ËÖ†ËÖ©ËÖºËÖΩËÖ≠ËÖßÂ°çÂ™µËÜàËÜÇËÜëÊªïËÜ£ËÜ™ËáåÊú¶ËáäËÜª"],["ec40","Èú°",8,"Èú´Èú¨ÈúÆÈúØÈú±Èú≥",4,"Èú∫ÈúªÈúºÈúΩÈúø",18,"ÈùîÈùïÈùóÈùòÈùöÈùúÈùùÈùüÈù£Èù§Èù¶ÈùßÈù®Èù™",7],["ec80","Èù≤ÈùµÈù∑",4,"ÈùΩ",7,"ÈûÜ",4,"ÈûåÈûéÈûèÈûêÈûìÈûïÈûñÈûóÈûô",4,"ËáÅËÜ¶Ê¨§Ê¨∑Ê¨πÊ≠ÉÊ≠ÜÊ≠ôÈ£ëÈ£íÈ£ìÈ£ïÈ£ôÈ£öÊÆ≥ÂΩÄÊØÇËß≥ÊñêÈΩëÊñìÊñºÊóÜÊóÑÊóÉÊóåÊóéÊóíÊóñÁÇÄÁÇúÁÇñÁÇùÁÇªÁÉÄÁÇ∑ÁÇ´ÁÇ±ÁÉ®ÁÉäÁÑêÁÑìÁÑñÁÑØÁÑ±ÁÖ≥ÁÖúÁÖ®ÁÖÖÁÖ≤ÁÖäÁÖ∏ÁÖ∫ÁÜòÁÜ≥ÁÜµÁÜ®ÁÜ†Áá†ÁáîÁáßÁáπÁàùÁà®ÁÅ¨ÁÑòÁÖ¶ÁÜπÊàæÊàΩÊâÉÊâàÊââÁ§ªÁ•ÄÁ•ÜÁ•âÁ•õÁ•úÁ•ìÁ•öÁ•¢Á•óÁ•†Á•ØÁ•ßÁ•∫Á¶ÖÁ¶äÁ¶öÁ¶ßÁ¶≥ÂøëÂøê"],["ed40","ÈûûÈûüÈû°Èû¢Èû§",6,"Èû¨ÈûÆÈû∞Èû±Èû≥Èûµ",46],["ed80","Èü§Èü•Èü®ÈüÆ",4,"Èü¥Èü∑",23,"ÊÄºÊÅùÊÅöÊÅßÊÅÅÊÅôÊÅ£ÊÇ´ÊÑÜÊÑçÊÖùÊÜ©ÊÜùÊáãÊáëÊàÜËÇÄËÅøÊ≤ìÊ≥∂Ê∑ºÁü∂Áü∏Á†ÄÁ†âÁ†óÁ†òÁ†ëÊñ´Á†≠Á†úÁ†ùÁ†πÁ†∫Á†ªÁ†üÁ†ºÁ†•Á†¨Á†£Á†©Á°éÁ°≠Á°ñÁ°óÁ†¶Á°êÁ°áÁ°åÁ°™Á¢õÁ¢ìÁ¢öÁ¢áÁ¢úÁ¢°Á¢£Á¢≤Á¢πÁ¢•Á£îÁ£ôÁ£âÁ£¨Á£≤Á§ÖÁ£¥Á§ìÁ§§Á§ûÁ§¥ÈæõÈªπÈªªÈªºÁõ±ÁúÑÁúçÁõπÁúáÁúàÁúöÁú¢ÁúôÁú≠Áú¶ÁúµÁú∏ÁùêÁùëÁùáÁùÉÁùöÁù®"],["ee40","È†è",62],["ee80","È°é",32,"Áù¢Áù•ÁùøÁûçÁùΩÁûÄÁûåÁûëÁûüÁû†Áû∞ÁûµÁûΩÁî∫ÁïÄÁïéÁïãÁïàÁïõÁï≤ÁïπÁñÉÁΩòÁΩ°ÁΩüË©àÁΩ®ÁΩ¥ÁΩ±ÁΩπÁæÅÁΩæÁõçÁõ•Ë†≤ÈíÖÈíÜÈíáÈíãÈíäÈíåÈíçÈíèÈíêÈíîÈíóÈíïÈíöÈíõÈíúÈí£Èí§Èí´Èí™Èí≠Èí¨ÈíØÈí∞Èí≤Èí¥Èí∂",4,"ÈíºÈíΩÈíøÈìÑÈìà",6,"ÈìêÈìëÈìíÈìïÈìñÈìóÈìôÈìòÈìõÈìûÈìüÈì†Èì¢Èì§Èì•ÈìßÈì®Èì™"],["ef40","È°Ø",5,"È¢ãÈ¢éÈ¢íÈ¢ïÈ¢ôÈ¢£È¢®",37,"È£èÈ£êÈ£îÈ£ñÈ£óÈ£õÈ£úÈ£ùÈ£†",4],["ef80","È£•È£¶È£©",30,"Èì©Èì´ÈìÆÈìØÈì≥Èì¥ÈìµÈì∑ÈìπÈìºÈìΩÈìøÈîÉÈîÇÈîÜÈîáÈîâÈîäÈîçÈîéÈîèÈîí",4,"ÈîòÈîõÈîùÈîûÈîüÈî¢Èî™Èî´Èî©Èî¨Èî±Èî≤Èî¥Èî∂Èî∑Èî∏ÈîºÈîæÈîøÈïÇÈîµÈïÑÈïÖÈïÜÈïâÈïåÈïéÈïèÈïíÈïìÈïîÈïñÈïóÈïòÈïôÈïõÈïûÈïüÈïùÈï°Èï¢Èï§",8,"ÈïØÈï±Èï≤Èï≥Èî∫ÁüßÁü¨ÈõâÁßïÁß≠Áß£Áß´Á®ÜÂµáÁ®ÉÁ®ÇÁ®ûÁ®î"],["f040","È§à",4,"È§éÈ§èÈ§ë",28,"È§Ø",26],["f080","È•ä",9,"È•ñ",12,"È•§È•¶È•≥È•∏È•πÈ•ªÈ•æÈ¶ÇÈ¶ÉÈ¶âÁ®πÁ®∑Á©ëÈªèÈ¶•Á©∞ÁöàÁöéÁöìÁöôÁö§ÁìûÁì†Áî¨È∏†È∏¢È∏®",4,"È∏≤È∏±È∏∂È∏∏È∏∑È∏πÈ∏∫È∏æÈπÅÈπÇÈπÑÈπÜÈπáÈπàÈπâÈπãÈπåÈπéÈπëÈπïÈπóÈπöÈπõÈπúÈπûÈπ£Èπ¶",6,"Èπ±Èπ≠Èπ≥ÁñíÁñîÁññÁñ†ÁñùÁñ¨Áñ£Áñ≥Áñ¥Áñ∏ÁóÑÁñ±Áñ∞ÁóÉÁóÇÁóñÁóçÁó£Áó®Áó¶Áó§Áó´ÁóßÁòÉÁó±ÁóºÁóøÁòêÁòÄÁòÖÁòåÁòóÁòäÁò•ÁòòÁòïÁòô"],["f140","È¶åÈ¶éÈ¶ö",10,"È¶¶È¶ßÈ¶©",47],["f180","Èßô",32,"ÁòõÁòºÁò¢Áò†ÁôÄÁò≠Áò∞ÁòøÁòµÁôÉÁòæÁò≥ÁôçÁôûÁôîÁôúÁôñÁô´ÁôØÁøäÁ´¶Á©∏Á©πÁ™ÄÁ™ÜÁ™àÁ™ïÁ™¶Á™†Á™¨Á™®Á™≠Á™≥Ë°§Ë°©Ë°≤Ë°ΩË°øË¢ÇË¢¢Ë£ÜË¢∑Ë¢ºË£âË£¢Ë£éË££Ë£•Ë£±Ë§öË£ºË£®Ë£æË£∞Ë§°Ë§ôË§ìË§õË§äË§¥Ë§´Ë§∂Ë•ÅË•¶Ë•ªÁñãËÉ•Áö≤Áö¥ÁüúËÄíËÄîËÄñËÄúËÄ†ËÄ¢ËÄ•ËÄ¶ËÄßËÄ©ËÄ®ËÄ±ËÄãËÄµËÅÉËÅÜËÅçËÅíËÅ©ËÅ±Ë¶ÉÈ°∏È¢ÄÈ¢É"],["f240","Èß∫",62],["f280","È®π",32,"È¢âÈ¢åÈ¢çÈ¢èÈ¢îÈ¢öÈ¢õÈ¢ûÈ¢üÈ¢°È¢¢È¢•È¢¶ËôçËôîËô¨ËôÆËôøËô∫ËôºËôªËö®ËöçËöãËö¨ËöùËößËö£Ëö™ËöìËö©Ëö∂ËõÑËöµËõéËö∞Ëö∫Ëö±ËöØËõâËõèËö¥Ëõ©Ëõ±Ëõ≤Ëõ≠Ëõ≥ËõêËúìËõûËõ¥ËõüËõòËõëËúÉËúáËõ∏ËúàËúäËúçËúâËú£ËúªËúûËú•ËúÆËúöËúæËùàËú¥Ëú±Ëú©Ëú∑ËúøËûÇËú¢ËùΩËùæËùªËù†Ëù∞ËùåËùÆËûãËùìËù£ËùºËù§ËùôËù•ËûìËûØËû®Ëüí"],["f340","È©ö",17,"È©≤È™ÉÈ™âÈ™çÈ™éÈ™îÈ™ïÈ™ôÈ™¶È™©",6,"È™≤È™≥È™¥È™µÈ™πÈ™ªÈ™ΩÈ™æÈ™øÈ´ÉÈ´ÑÈ´Ü",4,"È´çÈ´éÈ´èÈ´êÈ´íÈ´îÈ´ïÈ´ñÈ´óÈ´ôÈ´öÈ´õÈ´ú"],["f380","È´ùÈ´ûÈ´†È´¢È´£È´§È´•È´ßÈ´®È´©È´™È´¨È´ÆÈ´∞",8,"È´∫È´º",6,"È¨ÑÈ¨ÖÈ¨ÜËüÜËûàËûÖËû≠ËûóËûÉËû´Ëü•Ëû¨ËûµËû≥ËüãËüìËûΩËüëËüÄËüäËüõËü™Ëü†ËüÆË†ñË†ìËüæË†äË†õË†°Ë†πË†ºÁº∂ÁΩÇÁΩÑÁΩÖËàêÁ´∫Á´ΩÁ¨àÁ¨ÉÁ¨ÑÁ¨ïÁ¨äÁ¨´Á¨èÁ≠áÁ¨∏Á¨™Á¨ôÁ¨ÆÁ¨±Á¨†Á¨•Á¨§Á¨≥Á¨æÁ¨ûÁ≠òÁ≠öÁ≠ÖÁ≠µÁ≠åÁ≠ùÁ≠†Á≠ÆÁ≠ªÁ≠¢Á≠≤Á≠±ÁÆêÁÆ¶ÁÆßÁÆ∏ÁÆ¨ÁÆùÁÆ®ÁÆÖÁÆ™ÁÆúÁÆ¢ÁÆ´ÁÆ¥ÁØëÁØÅÁØåÁØùÁØöÁØ•ÁØ¶ÁØ™Á∞åÁØæÁØºÁ∞èÁ∞ñÁ∞ã"],["f440","È¨áÈ¨â",5,"È¨êÈ¨ëÈ¨íÈ¨î",10,"È¨†È¨°È¨¢È¨§",10,"È¨∞È¨±È¨≥",7,"È¨ΩÈ¨æÈ¨øÈ≠ÄÈ≠ÜÈ≠äÈ≠ãÈ≠åÈ≠éÈ≠êÈ≠íÈ≠ìÈ≠ï",5],["f480","È≠õ",32,"Á∞üÁ∞™Á∞¶Á∞∏Á±ÅÁ±ÄËáæËàÅËàÇËàÑËá¨Ë°ÑËà°Ëà¢Ëà£Ëà≠ËàØËà®Ëà´Ëà∏ËàªËà≥Ëà¥ËàæËâÑËââËâãËâèËâöËâüËâ®Ë°æË¢ÖË¢àË£òË£üË•ûÁæùÁæüÁæßÁæØÁæ∞Áæ≤Á±ºÊïâÁ≤ëÁ≤ùÁ≤úÁ≤ûÁ≤¢Á≤≤Á≤ºÁ≤ΩÁ≥ÅÁ≥áÁ≥åÁ≥çÁ≥àÁ≥ÖÁ≥óÁ≥®ËâÆÊö®ÁæøÁøéÁøïÁø•Áø°Áø¶Áø©ÁøÆÁø≥Á≥∏Áµ∑Á∂¶Á∂ÆÁπáÁ∫õÈ∫∏È∫¥Ëµ≥Ë∂ÑË∂îË∂ëË∂±ËµßËµ≠Ë±áË±âÈÖäÈÖêÈÖéÈÖèÈÖ§"],["f540","È≠º",62],["f580","ÈÆª",32,"ÈÖ¢ÈÖ°ÈÖ∞ÈÖ©ÈÖØÈÖΩÈÖæÈÖ≤ÈÖ¥ÈÖπÈÜåÈÜÖÈÜêÈÜçÈÜëÈÜ¢ÈÜ£ÈÜ™ÈÜ≠ÈÜÆÈÜØÈÜµÈÜ¥ÈÜ∫Ë±ïÈπæË∂∏Ë∑´Ë∏ÖËπôËπ©Ë∂µË∂øË∂ºË∂∫Ë∑ÑË∑ñË∑óË∑öË∑ûË∑éË∑èË∑õË∑ÜË∑¨Ë∑∑Ë∑∏Ë∑£Ë∑πË∑ªË∑§Ë∏âË∑ΩË∏îË∏ùË∏üË∏¨Ë∏ÆË∏£Ë∏ØË∏∫ËπÄË∏πË∏µË∏ΩË∏±ËπâËπÅËπÇËπëËπíËπäËπ∞Ëπ∂ËπºËπØËπ¥Ë∫ÖË∫èË∫îË∫êË∫úË∫ûË±∏Ë≤ÇË≤äË≤ÖË≤òË≤îÊñõËßñËßûËßöËßú"],["f640","ÈØú",62],["f680","È∞õ",32,"Ëß•Ëß´ËßØË®æË¨¶ÈùìÈõ©Èõ≥ÈõØÈúÜÈúÅÈúàÈúèÈúéÈú™Èú≠Èú∞ÈúæÈæÄÈæÉÈæÖ",5,"ÈæåÈªæÈºãÈºçÈöπÈöºÈöΩÈõéÈõíÁûøÈõ†ÈäéÈäÆÈãàÈåæÈç™ÈèäÈéèÈêæÈë´È±øÈ≤ÇÈ≤ÖÈ≤ÜÈ≤áÈ≤àÁ®£È≤ãÈ≤éÈ≤êÈ≤ëÈ≤íÈ≤îÈ≤ïÈ≤öÈ≤õÈ≤û",5,"È≤•",4,"È≤´È≤≠È≤ÆÈ≤∞",7,"È≤∫È≤ªÈ≤ºÈ≤ΩÈ≥ÑÈ≥ÖÈ≥ÜÈ≥áÈ≥äÈ≥ã"],["f740","È∞º",62],["f780","È±ªÈ±ΩÈ±æÈ≤ÄÈ≤ÉÈ≤ÑÈ≤âÈ≤äÈ≤åÈ≤èÈ≤ìÈ≤ñÈ≤óÈ≤òÈ≤ôÈ≤ùÈ≤™È≤¨È≤ØÈ≤πÈ≤æ",4,"È≥àÈ≥âÈ≥ëÈ≥íÈ≥öÈ≥õÈ≥†È≥°È≥å",4,"È≥ìÈ≥îÈ≥ïÈ≥óÈ≥òÈ≥ôÈ≥úÈ≥ùÈ≥üÈ≥¢ÈùºÈûÖÈûëÈûíÈûîÈûØÈû´Èû£Èû≤Èû¥È™±È™∞È™∑ÈπòÈ™∂È™∫È™ºÈ´ÅÈ´ÄÈ´ÖÈ´ÇÈ´ãÈ´åÈ´ëÈ≠ÖÈ≠ÉÈ≠áÈ≠âÈ≠àÈ≠çÈ≠ëÈ£®È§çÈ§ÆÈ•ïÈ•îÈ´üÈ´°È´¶È´ØÈ´´È´ªÈ´≠È´πÈ¨àÈ¨èÈ¨ìÈ¨üÈ¨£È∫ΩÈ∫æÁ∏ªÈ∫ÇÈ∫áÈ∫àÈ∫ãÈ∫íÈèñÈ∫ùÈ∫üÈªõÈªúÈªùÈª†ÈªüÈª¢Èª©ÈªßÈª•Èª™ÈªØÈº¢Èº¨ÈºØÈºπÈº∑ÈºΩÈºæÈΩÑ"],["f840","È≥£",62],["f880","È¥¢",32],["f940","ÈµÉ",62],["f980","È∂Ç",32],["fa40","È∂£",62],["fa80","È∑¢",32],["fb40","È∏É",27,"È∏§È∏ßÈ∏ÆÈ∏∞È∏¥È∏ªÈ∏ºÈπÄÈπçÈπêÈπíÈπìÈπîÈπñÈπôÈπùÈπüÈπ†Èπ°Èπ¢Èπ•ÈπÆÈπØÈπ≤Èπ¥",9,"È∫Ä"],["fb80","È∫ÅÈ∫ÉÈ∫ÑÈ∫ÖÈ∫ÜÈ∫âÈ∫äÈ∫å",5,"È∫î",8,"È∫ûÈ∫†",5,"È∫ßÈ∫®È∫©È∫™"],["fc40","È∫´",8,"È∫µÈ∫∂È∫∑È∫πÈ∫∫È∫ºÈ∫ø",4,"ÈªÖÈªÜÈªáÈªàÈªäÈªãÈªåÈªêÈªíÈªìÈªïÈªñÈªóÈªôÈªöÈªûÈª°Èª£Èª§Èª¶Èª®Èª´Èª¨Èª≠ÈªÆÈª∞",8,"Èª∫ÈªΩÈªø",6],["fc80","ÈºÜ",4,"ÈºåÈºèÈºëÈºíÈºîÈºïÈºñÈºòÈºö",5,"Èº°Èº£",8,"Èº≠ÈºÆÈº∞Èº±"],["fd40","Èº≤",4,"Èº∏Èº∫ÈººÈºø",4,"ÈΩÖ",10,"ÈΩí",38],["fd80","ÈΩπ",5,"ÈæÅÈæÇÈæç",11,"ÈæúÈæùÈæûÈæ°",4,"Ô§¨Ô•πÔ¶ïÔßßÔß±"],["fe40","Ô®åÔ®çÔ®éÔ®èÔ®ëÔ®ìÔ®îÔ®òÔ®üÔ®†Ô®°Ô®£Ô®§Ô®ßÔ®®Ô®©"]]');

/***/ }),

/***/ 82753:
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('[["0","\\u0000",127],["8141","Í∞ÇÍ∞ÉÍ∞ÖÍ∞ÜÍ∞ã",4,"Í∞òÍ∞ûÍ∞üÍ∞°Í∞¢Í∞£Í∞•",6,"Í∞ÆÍ∞≤Í∞≥Í∞¥"],["8161","Í∞µÍ∞∂Í∞∑Í∞∫Í∞ªÍ∞ΩÍ∞æÍ∞øÍ±Å",9,"Í±åÍ±é",5,"Í±ï"],["8181","Í±ñÍ±óÍ±ôÍ±öÍ±õÍ±ù",18,"Í±≤Í±≥Í±µÍ±∂Í±πÍ±ª",4,"Í≤ÇÍ≤áÍ≤àÍ≤çÍ≤éÍ≤èÍ≤ëÍ≤íÍ≤ìÍ≤ï",6,"Í≤ûÍ≤¢",5,"Í≤´Í≤≠Í≤ÆÍ≤±",6,"Í≤∫Í≤æÍ≤øÍ≥ÄÍ≥ÇÍ≥ÉÍ≥ÖÍ≥ÜÍ≥áÍ≥âÍ≥äÍ≥ãÍ≥ç",7,"Í≥ñÍ≥ò",7,"Í≥¢Í≥£Í≥•Í≥¶Í≥©Í≥´Í≥≠Í≥ÆÍ≥≤Í≥¥Í≥∑",4,"Í≥æÍ≥øÍ¥ÅÍ¥ÇÍ¥ÉÍ¥ÖÍ¥á",4,"Í¥éÍ¥êÍ¥íÍ¥ì"],["8241","Í¥îÍ¥ïÍ¥ñÍ¥óÍ¥ôÍ¥öÍ¥õÍ¥ùÍ¥ûÍ¥üÍ¥°",7,"Í¥™Í¥´Í¥Æ",5],["8261","Í¥∂Í¥∑Í¥πÍ¥∫Í¥ªÍ¥Ω",6,"ÍµÜÍµàÍµä",5,"ÍµëÍµíÍµìÍµïÍµñÍµó"],["8281","Íµô",7,"Íµ¢Íµ§",7,"ÍµÆÍµØÍµ±Íµ≤Íµ∑Íµ∏ÍµπÍµ∫ÍµæÍ∂ÄÍ∂É",4,"Í∂äÍ∂ãÍ∂çÍ∂éÍ∂èÍ∂ë",10,"Í∂û",5,"Í∂•",17,"Í∂∏",7,"Í∑ÇÍ∑ÉÍ∑ÖÍ∑ÜÍ∑áÍ∑â",6,"Í∑íÍ∑î",7,"Í∑ùÍ∑ûÍ∑üÍ∑°Í∑¢Í∑£Í∑•",18],["8341","Í∑∫Í∑ªÍ∑ΩÍ∑æÍ∏Ç",5,"Í∏äÍ∏åÍ∏é",5,"Í∏ï",7],["8361","Í∏ù",18,"Í∏≤Í∏≥Í∏µÍ∏∂Í∏πÍ∏ªÍ∏º"],["8381","Í∏ΩÍ∏æÍ∏øÍπÇÍπÑÍπáÍπàÍπâÍπãÍπèÍπëÍπíÍπìÍπïÍπó",4,"ÍπûÍπ¢Íπ£Íπ§Íπ¶ÍπßÍπ™Íπ´Íπ≠ÍπÆÍπØÍπ±",6,"Íπ∫Íπæ",5,"Í∫Ü",5,"Í∫ç",46,"Í∫øÍªÅÍªÇÍªÉÍªÖ",6,"ÍªéÍªí",5,"ÍªöÍªõÍªù",8],["8441","Íª¶ÍªßÍª©Íª™Íª¨ÍªÆ",5,"ÍªµÍª∂Íª∑ÍªπÍª∫ÍªªÍªΩ",8],["8461","ÍºÜÍºâÍºäÍºãÍºåÍºéÍºèÍºë",18],["8481","Íº§",7,"ÍºÆÍºØÍº±Íº≥Íºµ",6,"ÍºæÍΩÄÍΩÑÍΩÖÍΩÜÍΩáÍΩä",5,"ÍΩë",10,"ÍΩû",5,"ÍΩ¶",18,"ÍΩ∫",5,"ÍæÅÍæÇÍæÉÍæÖÍæÜÍæáÍæâ",6,"ÍæíÍæìÍæîÍæñ",5,"Íæù",26,"Íæ∫ÍæªÍæΩÍææ"],["8541","ÍæøÍøÅ",5,"ÍøäÍøåÍøè",4,"Íøï",6,"Íøù",4],["8561","Íø¢",5,"Íø™",5,"Íø≤Íø≥ÍøµÍø∂Íø∑Íøπ",6,"ÎÄÇÎÄÉ"],["8581","ÎÄÖ",6,"ÎÄçÎÄéÎÄèÎÄëÎÄíÎÄìÎÄï",6,"ÎÄû",9,"ÎÄ©",26,"ÎÅÜÎÅáÎÅâÎÅãÎÅçÎÅèÎÅêÎÅëÎÅíÎÅñÎÅòÎÅöÎÅõÎÅúÎÅû",29,"ÎÅæÎÅøÎÇÅÎÇÇÎÇÉÎÇÖ",6,"ÎÇéÎÇêÎÇí",5,"ÎÇõÎÇùÎÇûÎÇ£ÎÇ§"],["8641","ÎÇ•ÎÇ¶ÎÇßÎÇ™ÎÇ∞ÎÇ≤ÎÇ∂ÎÇ∑ÎÇπÎÇ∫ÎÇªÎÇΩ",6,"ÎÉÜÎÉä",5,"ÎÉí"],["8661","ÎÉìÎÉïÎÉñÎÉóÎÉô",6,"ÎÉ°ÎÉ¢ÎÉ£ÎÉ§ÎÉ¶",10],["8681","ÎÉ±",22,"ÎÑäÎÑçÎÑéÎÑèÎÑëÎÑîÎÑïÎÑñÎÑóÎÑöÎÑû",4,"ÎÑ¶ÎÑßÎÑ©ÎÑ™ÎÑ´ÎÑ≠",6,"ÎÑ∂ÎÑ∫",5,"ÎÖÇÎÖÉÎÖÖÎÖÜÎÖáÎÖâ",6,"ÎÖíÎÖìÎÖñÎÖóÎÖôÎÖöÎÖõÎÖùÎÖûÎÖüÎÖ°",22,"ÎÖ∫ÎÖªÎÖΩÎÖæÎÖøÎÜÅÎÜÉ",4,"ÎÜäÎÜåÎÜéÎÜèÎÜêÎÜëÎÜïÎÜñÎÜóÎÜôÎÜöÎÜõÎÜù"],["8741","ÎÜû",9,"ÎÜ©",15],["8761","ÎÜπ",18,"ÎáçÎáéÎáèÎáëÎáíÎáìÎáï"],["8781","Îáñ",5,"ÎáûÎá†",7,"Îá™Îá´Îá≠ÎáÆÎáØÎá±",7,"Îá∫ÎáºÎáæ",5,"ÎàÜÎàáÎàâÎàäÎàç",6,"ÎàñÎàòÎàö",5,"Îà°",18,"Îàµ",6,"ÎàΩ",26,"ÎâôÎâöÎâõÎâùÎâûÎâüÎâ°",6,"Îâ™",4],["8841","ÎâØ",4,"Îâ∂",5,"ÎâΩ",6,"ÎäÜÎäáÎäàÎää",4],["8861","ÎäèÎäíÎäìÎäïÎäñÎäóÎäõ",4,"Îä¢Îä§ÎäßÎä®Îä©Îä´Îä≠ÎäÆÎäØÎä±Îä≤Îä≥ÎäµÎä∂Îä∑"],["8881","Îä∏",15,"ÎãäÎããÎãçÎãéÎãèÎãëÎãì",4,"ÎãöÎãúÎãûÎãüÎã†Îã°Îã£ÎãßÎã©Îã™Îã∞Îã±Îã≤Îã∂ÎãºÎãΩÎãæÎåÇÎåÉÎåÖÎåÜÎåáÎåâ",6,"ÎåíÎåñ",5,"Îåù",54,"ÎçóÎçôÎçöÎçùÎç†Îç°Îç¢Îç£"],["8941","Îç¶Îç®Îç™Îç¨Îç≠ÎçØÎç≤Îç≥ÎçµÎç∂Îç∑Îçπ",6,"ÎéÇÎéÜ",5,"Îéç"],["8961","ÎééÎéèÎéëÎéíÎéìÎéï",10,"Îé¢",5,"Îé©Îé™Îé´Îé≠"],["8981","ÎéÆ",21,"ÎèÜÎèáÎèâÎèäÎèçÎèèÎèëÎèíÎèìÎèñÎèòÎèöÎèúÎèûÎèüÎè°Îè¢Îè£Îè•Îè¶ÎèßÎè©",18,"ÎèΩ",18,"Îêë",6,"ÎêôÎêöÎêõÎêùÎêûÎêüÎê°",6,"Îê™Îê¨",7,"Îêµ",15],["8a41","ÎëÖ",10,"ÎëíÎëìÎëïÎëñÎëóÎëô",6,"Îë¢Îë§Îë¶"],["8a61","Îëß",4,"Îë≠",18,"ÎíÅÎíÇ"],["8a81","ÎíÉ",4,"Îíâ",19,"Îíû",5,"Îí•Îí¶ÎíßÎí©Îí™Îí´Îí≠",7,"Îí∂Îí∏Îí∫",5,"ÎìÅÎìÇÎìÉÎìÖÎìÜÎìáÎìâ",6,"ÎìëÎìíÎììÎìîÎìñ",5,"ÎìûÎìüÎì°Îì¢Îì•Îìß",4,"ÎìÆÎì∞Îì≤",5,"Îìπ",26,"ÎîñÎîóÎîôÎîöÎîù"],["8b41","Îîû",5,"Îî¶Îî´",4,"Îî≤Îî≥ÎîµÎî∂Îî∑Îîπ",6,"ÎïÇÎïÜ"],["8b61","ÎïáÎïàÎïâÎïäÎïéÎïèÎïëÎïíÎïìÎïï",6,"ÎïûÎï¢",8],["8b81","Îï´",52,"Îñ¢Îñ£Îñ•Îñ¶ÎñßÎñ©Îñ¨Îñ≠ÎñÆÎñØÎñ≤Îñ∂",4,"ÎñæÎñøÎóÅÎóÇÎóÉÎóÖ",6,"ÎóéÎóí",5,"Îóô",18,"Îó≠",18],["8c41","ÎòÄ",15,"ÎòíÎòìÎòïÎòñÎòóÎòô",4],["8c61","Îòû",6,"Îò¶",5,"Îò≠",6,"Îòµ",5],["8c81","Îòª",12,"Îôâ",26,"Îô•Îô¶ÎôßÎô©",50,"ÎöûÎöüÎö°Îö¢Îö£Îö•",5,"Îö≠ÎöÆÎöØÎö∞Îö≤",16],["8d41","ÎõÉ",16,"Îõï",8],["8d61","Îõû",17,"Îõ±Îõ≤Îõ≥ÎõµÎõ∂Îõ∑ÎõπÎõ∫"],["8d81","Îõª",4,"ÎúÇÎúÉÎúÑÎúÜ",33,"Îú™Îú´Îú≠ÎúÆÎú±",6,"Îú∫Îúº",7,"ÎùÖÎùÜÎùáÎùâÎùäÎùãÎùç",6,"Îùñ",9,"Îù°Îù¢Îù£Îù•Îù¶ÎùßÎù©",6,"Îù≤Îù¥Îù∂",5,"ÎùæÎùøÎûÅÎûÇÎûÉÎûÖ",6,"ÎûéÎûìÎûîÎûïÎûöÎûõÎûùÎûû"],["8e41","ÎûüÎû°",6,"Îû™ÎûÆ",5,"Îû∂Îû∑Îûπ",8],["8e61","ÎüÇ",4,"ÎüàÎüä",19],["8e81","Îüû",13,"ÎüÆÎüØÎü±Îü≤Îü≥Îüµ",6,"ÎüæÎ†Ç",4,"Î†äÎ†ãÎ†çÎ†éÎ†èÎ†ë",6,"Î†öÎ†úÎ†û",5,"Î†¶Î†ßÎ†©Î†™Î†´Î†≠",6,"Î†∂Î†∫",5,"Î°ÅÎ°ÇÎ°ÉÎ°Ö",11,"Î°íÎ°î",7,"Î°ûÎ°üÎ°°Î°¢Î°£Î°•",6,"Î°ÆÎ°∞Î°≤",5,"Î°πÎ°∫Î°ªÎ°Ω",7],["8f41","Î¢Ö",7,"Î¢é",17],["8f61","Î¢†",7,"Î¢©",6,"Î¢±Î¢≤Î¢≥Î¢µÎ¢∂Î¢∑Î¢π",4],["8f81","Î¢æÎ¢øÎ£ÇÎ£ÑÎ£Ü",5,"Î£çÎ£éÎ£èÎ£ëÎ£íÎ£ìÎ£ï",7,"Î£ûÎ£†Î£¢",5,"Î£™Î£´Î£≠Î£ÆÎ£ØÎ£±",6,"Î£∫Î£ºÎ£æ",5,"Î§Ö",18,"Î§ô",6,"Î§°",26,"Î§æÎ§øÎ•ÅÎ•ÇÎ•ÉÎ•Ö",6,"Î•çÎ•éÎ•êÎ•í",5],["9041","Î•öÎ•õÎ•ùÎ•ûÎ•üÎ•°",6,"Î•™Î•¨Î•Æ",5,"Î•∂Î•∑Î•πÎ•∫Î•ªÎ•Ω"],["9061","Î•æ",5,"Î¶ÜÎ¶àÎ¶ãÎ¶åÎ¶è",15],["9081","Î¶ü",12,"Î¶ÆÎ¶ØÎ¶±Î¶≤Î¶≥Î¶µ",6,"Î¶æÎßÄÎßÇ",5,"ÎßäÎßãÎßçÎßì",4,"ÎßöÎßúÎßüÎß†Îß¢Îß¶ÎßßÎß©Îß™Îß´Îß≠",6,"Îß∂Îßª",4,"Î®Ç",5,"Î®â",11,"Î®ñ",33,"Î®∫Î®ªÎ®ΩÎ®æÎ®øÎ©ÅÎ©ÉÎ©ÑÎ©ÖÎ©Ü"],["9141","Î©áÎ©äÎ©åÎ©èÎ©êÎ©ëÎ©íÎ©ñÎ©óÎ©ôÎ©öÎ©õÎ©ù",6,"Î©¶Î©™",5],["9161","Î©≤Î©≥Î©µÎ©∂Î©∑Î©π",9,"Î™ÜÎ™àÎ™âÎ™äÎ™ãÎ™ç",5],["9181","Î™ì",20,"Î™™Î™≠Î™ÆÎ™ØÎ™±Î™≥",4,"Î™∫Î™ºÎ™æ",5,"Î´ÖÎ´ÜÎ´áÎ´â",14,"Î´ö",33,"Î´ΩÎ´æÎ´øÎ¨ÅÎ¨ÇÎ¨ÉÎ¨Ö",7,"Î¨éÎ¨êÎ¨í",5,"Î¨ôÎ¨öÎ¨õÎ¨ùÎ¨ûÎ¨üÎ¨°",6],["9241","Î¨®Î¨™Î¨¨",7,"Î¨∑Î¨πÎ¨∫Î¨ø",4,"Î≠ÜÎ≠àÎ≠äÎ≠ãÎ≠åÎ≠éÎ≠ëÎ≠í"],["9261","Î≠ìÎ≠ïÎ≠ñÎ≠óÎ≠ô",7,"Î≠¢Î≠§",7,"Î≠≠",4],["9281","Î≠≤",21,"ÎÆâÎÆäÎÆãÎÆçÎÆéÎÆèÎÆë",18,"ÎÆ•ÎÆ¶ÎÆßÎÆ©ÎÆ™ÎÆ´ÎÆ≠",6,"ÎÆµÎÆ∂ÎÆ∏",7,"ÎØÅÎØÇÎØÉÎØÖÎØÜÎØáÎØâ",6,"ÎØëÎØíÎØî",35,"ÎØ∫ÎØªÎØΩÎØæÎ∞Å"],["9341","Î∞É",4,"Î∞äÎ∞éÎ∞êÎ∞íÎ∞ìÎ∞ôÎ∞öÎ∞†Î∞°Î∞¢Î∞£Î∞¶Î∞®Î∞™Î∞´Î∞¨Î∞ÆÎ∞ØÎ∞≤Î∞≥Î∞µ"],["9361","Î∞∂Î∞∑Î∞π",6,"Î±ÇÎ±ÜÎ±áÎ±àÎ±äÎ±ãÎ±éÎ±èÎ±ë",8],["9381","Î±öÎ±õÎ±úÎ±û",37,"Î≤ÜÎ≤áÎ≤âÎ≤äÎ≤çÎ≤è",4,"Î≤ñÎ≤òÎ≤õ",4,"Î≤¢Î≤£Î≤•Î≤¶Î≤©",6,"Î≤≤Î≤∂",5,"Î≤æÎ≤øÎ≥ÅÎ≥ÇÎ≥ÉÎ≥Ö",7,"Î≥éÎ≥íÎ≥ìÎ≥îÎ≥ñÎ≥óÎ≥ôÎ≥öÎ≥õÎ≥ù",22,"Î≥∑Î≥πÎ≥∫Î≥ªÎ≥Ω"],["9441","Î≥æ",5,"Î¥ÜÎ¥àÎ¥ä",5,"Î¥ëÎ¥íÎ¥ìÎ¥ï",8],["9461","Î¥û",5,"Î¥•",6,"Î¥≠",12],["9481","Î¥∫",5,"ÎµÅ",6,"ÎµäÎµãÎµçÎµéÎµèÎµë",6,"Îµö",9,"Îµ•Îµ¶ÎµßÎµ©",22,"Î∂ÇÎ∂ÉÎ∂ÖÎ∂ÜÎ∂ã",4,"Î∂íÎ∂îÎ∂ñÎ∂óÎ∂òÎ∂õÎ∂ù",6,"Î∂•",10,"Î∂±",6,"Î∂π",24],["9541","Î∑íÎ∑ìÎ∑ñÎ∑óÎ∑ôÎ∑öÎ∑õÎ∑ù",11,"Î∑™",5,"Î∑±"],["9561","Î∑≤Î∑≥Î∑µÎ∑∂Î∑∑Î∑π",6,"Î∏ÅÎ∏ÇÎ∏ÑÎ∏Ü",5,"Î∏éÎ∏èÎ∏ëÎ∏íÎ∏ì"],["9581","Î∏ï",6,"Î∏ûÎ∏†",35,"ÎπÜÎπáÎπâÎπäÎπãÎπçÎπè",4,"ÎπñÎπòÎπúÎπùÎπûÎπüÎπ¢Îπ£Îπ•Îπ¶ÎπßÎπ©Îπ´",4,"Îπ≤Îπ∂",4,"ÎπæÎπøÎ∫ÅÎ∫ÇÎ∫ÉÎ∫Ö",6,"Î∫éÎ∫í",5,"Î∫ö",13,"Î∫©",14],["9641","Î∫∏",23,"ÎªíÎªì"],["9661","ÎªïÎªñÎªô",6,"Îª°Îª¢Îª¶",5,"Îª≠",8],["9681","Îª∂",10,"ÎºÇ",5,"Îºä",13,"ÎºöÎºû",33,"ÎΩÇÎΩÉÎΩÖÎΩÜÎΩáÎΩâ",6,"ÎΩíÎΩìÎΩîÎΩñ",44],["9741","ÎæÉ",16,"Îæï",8],["9761","Îæû",17,"Îæ±",7],["9781","Îæπ",11,"ÎøÜ",5,"ÎøéÎøèÎøëÎøíÎøìÎøï",6,"ÎøùÎøûÎø†Îø¢",89,"ÏÄΩÏÄæÏÄø"],["9841","ÏÅÄ",16,"ÏÅí",5,"ÏÅôÏÅöÏÅõ"],["9861","ÏÅùÏÅûÏÅüÏÅ°",6,"ÏÅ™",15],["9881","ÏÅ∫",21,"ÏÇíÏÇìÏÇïÏÇñÏÇóÏÇô",6,"ÏÇ¢ÏÇ§ÏÇ¶",5,"ÏÇÆÏÇ±ÏÇ≤ÏÇ∑",4,"ÏÇæÏÉÇÏÉÉÏÉÑÏÉÜÏÉáÏÉäÏÉãÏÉçÏÉéÏÉèÏÉë",6,"ÏÉöÏÉû",5,"ÏÉ¶ÏÉßÏÉ©ÏÉ™ÏÉ´ÏÉ≠",6,"ÏÉ∂ÏÉ∏ÏÉ∫",5,"ÏÑÅÏÑÇÏÑÉÏÑÖÏÑÜÏÑáÏÑâ",6,"ÏÑëÏÑíÏÑìÏÑîÏÑñ",5,"ÏÑ°ÏÑ¢ÏÑ•ÏÑ®ÏÑ©ÏÑ™ÏÑ´ÏÑÆ"],["9941","ÏÑ≤ÏÑ≥ÏÑ¥ÏÑµÏÑ∑ÏÑ∫ÏÑªÏÑΩÏÑæÏÑøÏÖÅ",6,"ÏÖäÏÖé",5,"ÏÖñÏÖó"],["9961","ÏÖôÏÖöÏÖõÏÖù",6,"ÏÖ¶ÏÖ™",5,"ÏÖ±ÏÖ≤ÏÖ≥ÏÖµÏÖ∂ÏÖ∑ÏÖπÏÖ∫ÏÖª"],["9981","ÏÖº",8,"ÏÜÜ",5,"ÏÜèÏÜëÏÜíÏÜìÏÜïÏÜó",4,"ÏÜûÏÜ†ÏÜ¢ÏÜ£ÏÜ§ÏÜ¶ÏÜßÏÜ™ÏÜ´ÏÜ≠ÏÜÆÏÜØÏÜ±",11,"ÏÜæ",5,"ÏáÖÏáÜÏááÏáâÏáäÏáãÏáç",6,"ÏáïÏáñÏáô",6,"Ïá°Ïá¢Ïá£Ïá•Ïá¶ÏáßÏá©",6,"Ïá≤Ïá¥",7,"ÏáæÏáøÏàÅÏàÇÏàÉÏàÖ",6,"ÏàéÏàêÏàí",5,"ÏàöÏàõÏàùÏàûÏà°Ïà¢Ïà£"],["9a41","Ïà§Ïà•Ïà¶ÏàßÏà™Ïà¨ÏàÆÏà∞Ïà≥Ïàµ",16],["9a61","ÏâÜÏâáÏââ",6,"ÏâíÏâìÏâïÏâñÏâóÏâô",6,"Ïâ°Ïâ¢Ïâ£Ïâ§Ïâ¶"],["9a81","Ïâß",4,"ÏâÆÏâØÏâ±Ïâ≤Ïâ≥Ïâµ",6,"ÏâæÏäÄÏäÇ",5,"Ïää",5,"Ïäë",6,"ÏäôÏäöÏäúÏäû",5,"Ïä¶ÏäßÏä©Ïä™Ïä´ÏäÆ",5,"Ïä∂Ïä∏Ïä∫",33,"ÏãûÏãüÏã°Ïã¢Ïã•",5,"ÏãÆÏã∞Ïã≤Ïã≥Ïã¥ÏãµÏã∑Ïã∫ÏãΩÏãæÏãøÏåÅ",6,"ÏåäÏåãÏåéÏåè"],["9b41","ÏåêÏåëÏåíÏåñÏåóÏåôÏåöÏåõÏåù",6,"Ïå¶ÏåßÏå™",8],["9b61","Ïå≥",17,"ÏçÜ",7],["9b81","Ïçé",25,"Ïç™Ïç´Ïç≠ÏçÆÏçØÏç±Ïç≥",4,"Ïç∫ÏçªÏçæ",5,"ÏéÖÏéÜÏéáÏéâÏéäÏéãÏéç",50,"ÏèÅ",22,"Ïèö"],["9c41","ÏèõÏèùÏèûÏè°Ïè£",4,"Ïè™Ïè´Ïè¨ÏèÆ",5,"Ïè∂Ïè∑Ïèπ",5],["9c61","Ïèø",8,"Ïêâ",6,"Ïêë",9],["9c81","Ïêõ",8,"Ïê•",6,"Ïê≠ÏêÆÏêØÏê±Ïê≤Ïê≥Ïêµ",6,"Ïêæ",9,"Ïëâ",26,"Ïë¶ÏëßÏë©Ïë™Ïë´Ïë≠",6,"Ïë∂Ïë∑Ïë∏Ïë∫",5,"ÏíÅ",18,"Ïíï",6,"Ïíù",12],["9d41","Ïí™",13,"ÏíπÏí∫ÏíªÏíΩ",8],["9d61","ÏìÜ",25],["9d81","Ïì†",8,"Ïì™",5,"Ïì≤Ïì≥ÏìµÏì∂Ïì∑ÏìπÏìªÏìºÏìΩÏìæÏîÇ",9,"ÏîçÏîéÏîèÏîëÏîíÏîìÏîï",6,"Ïîù",10,"Ïî™Ïî´Ïî≠ÏîÆÏîØÏî±",6,"Ïî∫ÏîºÏîæ",5,"ÏïÜÏïáÏïãÏïèÏïêÏïëÏïíÏïñÏïöÏïõÏïúÏïüÏï¢Ïï£Ïï•Ïï¶ÏïßÏï©",6,"Ïï≤Ïï∂",5,"ÏïæÏïøÏñÅÏñÇÏñÉÏñÖÏñÜÏñàÏñâÏñäÏñãÏñéÏñêÏñíÏñìÏñî"],["9e41","ÏññÏñôÏñöÏñõÏñùÏñûÏñüÏñ°",7,"Ïñ™",9,"Ïñ∂"],["9e61","Ïñ∑Ïñ∫Ïñø",4,"ÏóãÏóçÏóèÏóíÏóìÏóïÏóñÏóóÏóô",6,"Ïó¢Ïó§Ïó¶Ïóß"],["9e81","Ïó®Ïó©Ïó™Ïó´ÏóØÏó±Ïó≤Ïó≥ÏóµÏó∏ÏóπÏó∫ÏóªÏòÇÏòÉÏòÑÏòâÏòäÏòãÏòçÏòéÏòèÏòë",6,"ÏòöÏòù",6,"Ïò¶ÏòßÏò©Ïò™Ïò´ÏòØÏò±Ïò≤Ïò∂Ïò∏Ïò∫ÏòºÏòΩÏòæÏòøÏôÇÏôÉÏôÖÏôÜÏôáÏôâ",6,"ÏôíÏôñ",5,"ÏôûÏôüÏô°",10,"Ïô≠ÏôÆÏô∞Ïô≤",5,"Ïô∫ÏôªÏôΩÏôæÏôøÏöÅ",6,"ÏöäÏöåÏöé",5,"ÏöñÏöóÏöôÏööÏöõÏöù",6,"Ïö¶"],["9f41","Ïö®Ïö™",5,"Ïö≤Ïö≥ÏöµÏö∂Ïö∑Ïöª",4,"ÏõÇÏõÑÏõÜ",5,"Ïõé"],["9f61","ÏõèÏõëÏõíÏõìÏõï",6,"ÏõûÏõüÏõ¢",5,"Ïõ™Ïõ´Ïõ≠ÏõÆÏõØÏõ±Ïõ≤"],["9f81","Ïõ≥",4,"Ïõ∫ÏõªÏõºÏõæ",5,"ÏúÜÏúáÏúâÏúäÏúãÏúç",6,"ÏúñÏúòÏúö",5,"Ïú¢Ïú£Ïú•Ïú¶ÏúßÏú©",6,"Ïú≤Ïú¥Ïú∂Ïú∏ÏúπÏú∫ÏúªÏúæÏúøÏùÅÏùÇÏùÉÏùÖ",4,"ÏùãÏùéÏùêÏùôÏùöÏùõÏùùÏùûÏùüÏù°",6,"Ïù©Ïù™Ïù¨",7,"Ïù∂Ïù∑ÏùπÏù∫ÏùªÏùøÏûÄÏûÅÏûÇÏûÜÏûãÏûåÏûçÏûèÏûíÏûìÏûïÏûôÏûõ",4,"Ïû¢Ïûß",4,"ÏûÆÏûØÏû±Ïû≤Ïû≥ÏûµÏû∂Ïû∑"],["a041","Ïû∏ÏûπÏû∫ÏûªÏûæÏüÇ",5,"ÏüäÏüãÏüçÏüèÏüë",6,"ÏüôÏüöÏüõÏüú"],["a061","Ïüû",5,"Ïü•Ïü¶ÏüßÏü©Ïü™Ïü´Ïü≠",13],["a081","Ïüª",4,"Ï†ÇÏ†ÉÏ†ÖÏ†ÜÏ†áÏ†âÏ†ã",4,"Ï†íÏ†îÏ†ó",4,"Ï†ûÏ†üÏ†°Ï†¢Ï†£Ï†•",6,"Ï†ÆÏ†∞Ï†≤",5,"Ï†πÏ†∫Ï†ªÏ†ΩÏ†æÏ†øÏ°Å",6,"Ï°äÏ°ãÏ°é",5,"Ï°ï",26,"Ï°≤Ï°≥Ï°µÏ°∂Ï°∑Ï°πÏ°ª",4,"Ï¢ÇÏ¢ÑÏ¢àÏ¢âÏ¢äÏ¢é",5,"Ï¢ï",7,"Ï¢ûÏ¢†Ï¢¢Ï¢£Ï¢§"],["a141","Ï¢•Ï¢¶Ï¢ßÏ¢©",18,"Ï¢æÏ¢øÏ£ÄÏ£Å"],["a161","Ï£ÇÏ£ÉÏ£ÖÏ£ÜÏ£áÏ£âÏ£äÏ£ãÏ£ç",6,"Ï£ñÏ£òÏ£ö",5,"Ï£¢Ï££Ï£•"],["a181","Ï£¶",14,"Ï£∂",5,"Ï£æÏ£øÏ§ÅÏ§ÇÏ§ÉÏ§á",4,"Ï§é„ÄÄ„ÄÅ„ÄÇ¬∑‚Ä•‚Ä¶¬®„ÄÉ¬≠‚Äï‚à•Ôºº‚àº‚Äò‚Äô‚Äú‚Äù„Äî„Äï„Äà",9,"¬±√ó√∑‚â†‚â§‚â•‚àû‚à¥¬∞‚Ä≤‚Ä≥‚ÑÉ‚Ñ´Ôø†Ôø°Ôø•‚ôÇ‚ôÄ‚à†‚ä•‚åí‚àÇ‚àá‚â°‚âí¬ß‚Äª‚òÜ‚òÖ‚óã‚óè‚óé‚óá‚óÜ‚ñ°‚ñ†‚ñ≥‚ñ≤‚ñΩ‚ñº‚Üí‚Üê‚Üë‚Üì‚Üî„Äì‚â™‚â´‚àö‚àΩ‚àù‚àµ‚à´‚à¨‚àà‚àã‚äÜ‚äá‚äÇ‚äÉ‚à™‚à©‚àß‚à®Ôø¢"],["a241","Ï§êÏ§í",5,"Ï§ô",18],["a261","Ï§≠",6,"Ï§µ",18],["a281","Ï•à",7,"Ï•íÏ•ìÏ•ïÏ•ñÏ•óÏ•ô",6,"Ï•¢Ï•§",7,"Ï•≠Ï•ÆÏ•Ø‚áí‚áî‚àÄ‚àÉ¬¥ÔΩûÀáÀòÀùÀöÀô¬∏Àõ¬°¬øÀê‚àÆ‚àë‚àè¬§‚Ñâ‚Ä∞‚óÅ‚óÄ‚ñ∑‚ñ∂‚ô§‚ô†‚ô°‚ô•‚ôß‚ô£‚äô‚óà‚ñ£‚óê‚óë‚ñí‚ñ§‚ñ•‚ñ®‚ñß‚ñ¶‚ñ©‚ô®‚òè‚òé‚òú‚òû¬∂‚Ä†‚Ä°‚Üï‚Üó‚Üô‚Üñ‚Üò‚ô≠‚ô©‚ô™‚ô¨„âø„àú‚Ññ„èá‚Ñ¢„èÇ„èò‚Ñ°‚Ç¨¬Æ"],["a341","Ï•±Ï•≤Ï•≥Ï•µ",6,"Ï•Ω",10,"Ï¶äÏ¶ãÏ¶çÏ¶éÏ¶è"],["a361","Ï¶ë",6,"Ï¶öÏ¶úÏ¶û",16],["a381","Ï¶Ø",16,"ÏßÇÏßÉÏßÖÏßÜÏßâÏßã",4,"ÏßíÏßîÏßóÏßòÏßõÔºÅ",58,"Ôø¶ÔºΩ",32,"Ôø£"],["a441","ÏßûÏßüÏß°Ïß£Ïß•Ïß¶Ïß®Ïß©Ïß™Ïß´ÏßÆÏß≤",5,"Ïß∫ÏßªÏßΩÏßæÏßøÏ®ÅÏ®ÇÏ®ÉÏ®Ñ"],["a461","Ï®ÖÏ®ÜÏ®áÏ®äÏ®é",5,"Ï®ïÏ®ñÏ®óÏ®ô",12],["a481","Ï®¶Ï®ßÏ®®Ï®™",28,"„Ñ±",93],["a541","Ï©á",4,"Ï©éÏ©èÏ©ëÏ©íÏ©ìÏ©ï",6,"Ï©ûÏ©¢",5,"Ï©©Ï©™"],["a561","Ï©´",17,"Ï©æ",5,"Ï™ÖÏ™Ü"],["a581","Ï™á",16,"Ï™ô",14,"‚Ö∞",9],["a5b0","‚Ö†",9],["a5c1","Œë",16,"Œ£",6],["a5e1","Œ±",16,"œÉ",6],["a641","Ï™®",19,"Ï™æÏ™øÏ´ÅÏ´ÇÏ´ÉÏ´Ö"],["a661","Ï´Ü",5,"Ï´éÏ´êÏ´íÏ´îÏ´ïÏ´ñÏ´óÏ´ö",5,"Ï´°",6],["a681","Ï´®Ï´©Ï´™Ï´´Ï´≠",6,"Ï´µ",18,"Ï¨âÏ¨ä‚îÄ‚îÇ‚îå‚îê‚îò‚îî‚îú‚î¨‚î§‚î¥‚îº‚îÅ‚îÉ‚îè‚îì‚îõ‚îó‚î£‚î≥‚î´‚îª‚ïã‚î†‚îØ‚î®‚î∑‚îø‚îù‚î∞‚î•‚î∏‚ïÇ‚îí‚îë‚îö‚îô‚îñ‚îï‚îé‚îç‚îû‚îü‚î°‚î¢‚î¶‚îß‚î©‚î™‚î≠‚îÆ‚î±‚î≤‚îµ‚î∂‚îπ‚î∫‚îΩ‚îæ‚ïÄ‚ïÅ‚ïÉ",7],["a741","Ï¨ã",4,"Ï¨ëÏ¨íÏ¨ìÏ¨ïÏ¨ñÏ¨óÏ¨ô",6,"Ï¨¢",7],["a761","Ï¨™",22,"Ï≠ÇÏ≠ÉÏ≠Ñ"],["a781","Ï≠ÖÏ≠ÜÏ≠áÏ≠äÏ≠ãÏ≠çÏ≠éÏ≠èÏ≠ë",6,"Ï≠öÏ≠õÏ≠úÏ≠û",5,"Ï≠•",7,"„éï„éñ„éó‚Ñì„éò„èÑ„é£„é§„é•„é¶„éô",9,"„èä„éç„éé„éè„èè„éà„éâ„èà„éß„é®„é∞",9,"„éÄ",4,"„é∫",5,"„éê",4,"‚Ñ¶„èÄ„èÅ„éä„éã„éå„èñ„èÖ„é≠„éÆ„éØ„èõ„é©„é™„é´„é¨„èù„èê„èì„èÉ„èâ„èú„èÜ"],["a841","Ï≠≠",10,"Ï≠∫",14],["a861","ÏÆâ",18,"ÏÆù",6],["a881","ÏÆ§",19,"ÏÆπ",11,"√Ü√ê¬™ƒ¶"],["a8a6","ƒ≤"],["a8a8","ƒø≈Å√ò≈í¬∫√û≈¶≈ä"],["a8b1","„â†",27,"‚ìê",25,"‚ë†",14,"¬Ω‚Öì‚Öî¬º¬æ‚Öõ‚Öú‚Öù‚Öû"],["a941","ÏØÖ",14,"ÏØï",10],["a961","ÏØ†ÏØ°ÏØ¢ÏØ£ÏØ•ÏØ¶ÏØ®ÏØ™",18],["a981","ÏØΩ",14,"Ï∞éÏ∞èÏ∞ëÏ∞íÏ∞ìÏ∞ï",6,"Ï∞ûÏ∞üÏ∞†Ï∞£Ï∞§√¶ƒë√∞ƒßƒ±ƒ≥ƒ∏≈Ä≈Ç√∏≈ì√ü√æ≈ß≈ã≈â„àÄ",27,"‚íú",25,"‚ë¥",14,"¬π¬≤¬≥‚Å¥‚Åø‚ÇÅ‚ÇÇ‚ÇÉ‚ÇÑ"],["aa41","Ï∞•Ï∞¶Ï∞™Ï∞´Ï∞≠Ï∞ØÏ∞±",6,"Ï∞∫Ï∞ø",4,"Ï±ÜÏ±áÏ±âÏ±äÏ±ãÏ±çÏ±é"],["aa61","Ï±è",4,"Ï±ñÏ±ö",5,"Ï±°Ï±¢Ï±£Ï±•Ï±ßÏ±©",6,"Ï±±Ï±≤"],["aa81","Ï±≥Ï±¥Ï±∂",29,"„ÅÅ",82],["ab41","Ï≤îÏ≤ïÏ≤ñÏ≤óÏ≤öÏ≤õÏ≤ùÏ≤ûÏ≤üÏ≤°",6,"Ï≤™Ï≤Æ",5,"Ï≤∂Ï≤∑Ï≤π"],["ab61","Ï≤∫Ï≤ªÏ≤Ω",6,"Ï≥ÜÏ≥àÏ≥ä",5,"Ï≥ëÏ≥íÏ≥ìÏ≥ï",5],["ab81","Ï≥õ",8,"Ï≥•",6,"Ï≥≠Ï≥ÆÏ≥ØÏ≥±",12,"„Ç°",85],["ac41","Ï≥æÏ≥øÏ¥ÄÏ¥Ç",5,"Ï¥äÏ¥ãÏ¥çÏ¥éÏ¥èÏ¥ë",6,"Ï¥öÏ¥úÏ¥ûÏ¥üÏ¥†"],["ac61","Ï¥°Ï¥¢Ï¥£Ï¥•Ï¥¶Ï¥ßÏ¥©Ï¥™Ï¥´Ï¥≠",11,"Ï¥∫",4],["ac81","Ï¥ø",28,"ÏµùÏµûÏµü–ê",5,"–Å–ñ",25],["acd1","–∞",5,"—ë–∂",25],["ad41","Ïµ°Ïµ¢Ïµ£Ïµ•",6,"ÏµÆÏµ∞Ïµ≤",5,"Ïµπ",7],["ad61","Ï∂Å",6,"Ï∂â",10,"Ï∂ñÏ∂óÏ∂ôÏ∂öÏ∂õÏ∂ùÏ∂ûÏ∂ü"],["ad81","Ï∂†Ï∂°Ï∂¢Ï∂£Ï∂¶Ï∂®Ï∂™",5,"Ï∂±",18,"Ï∑Ö"],["ae41","Ï∑Ü",5,"Ï∑çÏ∑éÏ∑èÏ∑ë",16],["ae61","Ï∑¢",5,"Ï∑©Ï∑™Ï∑´Ï∑≠Ï∑ÆÏ∑ØÏ∑±",6,"Ï∑∫Ï∑ºÏ∑æ",4],["ae81","Ï∏ÉÏ∏ÖÏ∏ÜÏ∏áÏ∏âÏ∏äÏ∏ãÏ∏ç",6,"Ï∏ïÏ∏ñÏ∏óÏ∏òÏ∏ö",5,"Ï∏¢Ï∏£Ï∏•Ï∏¶Ï∏ßÏ∏©Ï∏™Ï∏´"],["af41","Ï∏¨Ï∏≠Ï∏ÆÏ∏ØÏ∏≤Ï∏¥Ï∏∂",19],["af61","Ïπä",13,"ÏπöÏπõÏπùÏπûÏπ¢",5,"Ïπ™Ïπ¨"],["af81","ÏπÆ",5,"Ïπ∂Ïπ∑ÏππÏπ∫ÏπªÏπΩ",6,"Ï∫ÜÏ∫àÏ∫ä",5,"Ï∫íÏ∫ìÏ∫ïÏ∫ñÏ∫óÏ∫ô"],["b041","Ï∫ö",5,"Ï∫¢Ï∫¶",5,"Ï∫Æ",12],["b061","Ï∫ª",5,"ÏªÇ",19],["b081","Ïªñ",13,"Ïª¶ÏªßÏª©Ïª™Ïª≠",6,"Ïª∂Ïª∫",5,"Í∞ÄÍ∞ÅÍ∞ÑÍ∞áÍ∞àÍ∞âÍ∞äÍ∞ê",7,"Í∞ô",4,"Í∞†Í∞§Í∞¨Í∞≠Í∞ØÍ∞∞Í∞±Í∞∏Í∞πÍ∞ºÍ±ÄÍ±ãÍ±çÍ±îÍ±òÍ±úÍ±∞Í±±Í±¥Í±∑Í±∏Í±∫Í≤ÄÍ≤ÅÍ≤ÉÍ≤ÑÍ≤ÖÍ≤ÜÍ≤âÍ≤äÍ≤ãÍ≤åÍ≤êÍ≤îÍ≤úÍ≤ùÍ≤üÍ≤†Í≤°Í≤®Í≤©Í≤™Í≤¨Í≤ØÍ≤∞Í≤∏Í≤πÍ≤ªÍ≤ºÍ≤ΩÍ≥ÅÍ≥ÑÍ≥àÍ≥åÍ≥ïÍ≥óÍ≥†Í≥°Í≥§Í≥ßÍ≥®Í≥™Í≥¨Í≥ØÍ≥∞Í≥±Í≥≥Í≥µÍ≥∂Í≥ºÍ≥ΩÍ¥ÄÍ¥ÑÍ¥Ü"],["b141","ÏºÇÏºÉÏºÖÏºÜÏºáÏºâ",6,"ÏºíÏºîÏºñ",5,"ÏºùÏºûÏºüÏº°Ïº¢Ïº£"],["b161","Ïº•",6,"ÏºÆÏº≤",5,"Ïºπ",11],["b181","ÏΩÖ",14,"ÏΩñÏΩóÏΩôÏΩöÏΩõÏΩù",6,"ÏΩ¶ÏΩ®ÏΩ™ÏΩ´ÏΩ¨Í¥åÍ¥çÍ¥èÍ¥ëÍ¥òÍ¥úÍ¥†Í¥©Í¥¨Í¥≠Í¥¥Í¥µÍ¥∏Í¥ºÍµÑÍµÖÍµáÍµâÍµêÍµîÍµòÍµ°Íµ£Íµ¨Íµ≠Íµ∞Íµ≥Íµ¥ÍµµÍµ∂ÍµªÍµºÍµΩÍµøÍ∂ÅÍ∂ÇÍ∂àÍ∂âÍ∂åÍ∂êÍ∂úÍ∂ùÍ∂§Í∂∑Í∑ÄÍ∑ÅÍ∑ÑÍ∑àÍ∑êÍ∑ëÍ∑ìÍ∑úÍ∑†Í∑§Í∑∏Í∑πÍ∑ºÍ∑øÍ∏ÄÍ∏ÅÍ∏àÍ∏âÍ∏ãÍ∏çÍ∏îÍ∏∞Í∏±Í∏¥Í∏∑Í∏∏Í∏∫ÍπÄÍπÅÍπÉÍπÖÍπÜÍπäÍπåÍπçÍπéÍπêÍπîÍπñÍπúÍπùÍπüÍπ†Íπ°Íπ•Íπ®Íπ©Íπ¨Íπ∞Íπ∏"],["b241","ÏΩ≠ÏΩÆÏΩØÏΩ≤ÏΩ≥ÏΩµÏΩ∂ÏΩ∑ÏΩπ",6,"ÏæÅÏæÇÏæÉÏæÑÏæÜ",5,"Ïæç"],["b261","Ïæé",18,"Ïæ¢",5,"Ïæ©"],["b281","Ïæ™",5,"Ïæ±",18,"ÏøÖ",6,"ÍππÍπªÍπºÍπΩÍ∫ÑÍ∫ÖÍ∫åÍ∫ºÍ∫ΩÍ∫æÍªÄÍªÑÍªåÍªçÍªèÍªêÍªëÍªòÍªôÍªúÍª®Íª´Íª≠Íª¥Íª∏ÍªºÍºáÍºàÍºçÍºêÍº¨Íº≠Íº∞Íº≤Íº¥ÍººÍºΩÍºøÍΩÅÍΩÇÍΩÉÍΩàÍΩâÍΩêÍΩúÍΩùÍΩ§ÍΩ•ÍΩπÍæÄÍæÑÍæàÍæêÍæëÍæïÍæúÍæ∏ÍæπÍæºÍøÄÍøáÍøàÍøâÍøãÍøçÍøéÍøîÍøúÍø®Íø©Íø∞Íø±Íø¥Íø∏ÎÄÄÎÄÅÎÄÑÎÄåÎÄêÎÄîÎÄúÎÄùÎÄ®ÎÅÑÎÅÖÎÅàÎÅäÎÅåÎÅéÎÅìÎÅîÎÅïÎÅóÎÅô"],["b341","Ïøå",19,"Ïø¢Ïø£Ïø•Ïø¶ÏøßÏø©"],["b361","Ïø™",5,"Ïø≤Ïø¥Ïø∂",5,"ÏøΩÏøæÏøøÌÄÅÌÄÇÌÄÉÌÄÖ",5],["b381","ÌÄã",5,"ÌÄí",5,"ÌÄô",19,"ÎÅùÎÅºÎÅΩÎÇÄÎÇÑÎÇåÎÇçÎÇèÎÇëÎÇòÎÇôÎÇöÎÇúÎÇüÎÇ†ÎÇ°ÎÇ¢ÎÇ®ÎÇ©ÎÇ´",4,"ÎÇ±ÎÇ≥ÎÇ¥ÎÇµÎÇ∏ÎÇºÎÉÑÎÉÖÎÉáÎÉàÎÉâÎÉêÎÉëÎÉîÎÉòÎÉ†ÎÉ•ÎÑàÎÑâÎÑãÎÑåÎÑêÎÑíÎÑìÎÑòÎÑôÎÑõÎÑúÎÑùÎÑ£ÎÑ§ÎÑ•ÎÑ®ÎÑ¨ÎÑ¥ÎÑµÎÑ∑ÎÑ∏ÎÑπÎÖÄÎÖÅÎÖÑÎÖàÎÖêÎÖëÎÖîÎÖïÎÖòÎÖúÎÖ†ÎÖ∏ÎÖπÎÖºÎÜÄÎÜÇÎÜàÎÜâÎÜãÎÜçÎÜíÎÜìÎÜîÎÜòÎÜúÎÜ®ÎáåÎáêÎáîÎáúÎáù"],["b441","ÌÄÆ",5,"ÌÄ∂ÌÄ∑ÌÄπÌÄ∫ÌÄªÌÄΩ",6,"ÌÅÜÌÅàÌÅä",5],["b461","ÌÅëÌÅíÌÅìÌÅïÌÅñÌÅóÌÅô",6,"ÌÅ°",10,"ÌÅÆÌÅØ"],["b481","ÌÅ±ÌÅ≤ÌÅ≥ÌÅµ",6,"ÌÅæÌÅøÌÇÄÌÇÇ",18,"ÎáüÎá®Îá©Îá¨Îá∞ÎáπÎáªÎáΩÎàÑÎàÖÎààÎàãÎàåÎàîÎàïÎàóÎàôÎà†Îà¥ÎàºÎâòÎâúÎâ†Îâ®Îâ©Îâ¥ÎâµÎâºÎäÑÎäÖÎäâÎäêÎäëÎäîÎäòÎäôÎäöÎä†Îä°Îä£Îä•Îä¶Îä™Îä¨Îä∞Îä¥ÎãàÎãâÎãåÎãêÎãíÎãòÎãôÎãõÎãùÎã¢Îã§Îã•Îã¶Îã®Îã´",4,"Îã≥Îã¥ÎãµÎã∑",4,"ÎãøÎåÄÎåÅÎåÑÎåàÎåêÎåëÎåìÎåîÎåïÎåúÎçîÎçïÎçñÎçòÎçõÎçúÎçûÎçüÎç§Îç•"],["b541","ÌÇï",14,"ÌÇ¶ÌÇßÌÇ©ÌÇ™ÌÇ´ÌÇ≠",5],["b561","ÌÇ≥ÌÇ∂ÌÇ∏ÌÇ∫",5,"ÌÉÇÌÉÉÌÉÖÌÉÜÌÉáÌÉä",5,"ÌÉíÌÉñ",4],["b581","ÌÉõÌÉûÌÉüÌÉ°ÌÉ¢ÌÉ£ÌÉ•",6,"ÌÉÆÌÉ≤",5,"ÌÉπ",11,"ÎçßÎç©Îç´ÎçÆÎç∞Îç±Îç¥Îç∏ÎéÄÎéÅÎéÉÎéÑÎéÖÎéåÎéêÎéîÎé†Îé°Îé®Îé¨ÎèÑÎèÖÎèàÎèãÎèåÎèéÎèêÎèîÎèïÎèóÎèôÎèõÎèùÎè†Îè§Îè®ÎèºÎêêÎêòÎêúÎê†Îê®Îê©Îê´Îê¥ÎëêÎëëÎëîÎëòÎë†Îë°Îë£Îë•Îë¨ÎíÄÎíàÎíùÎí§Îí®Îí¨ÎíµÎí∑ÎíπÎìÄÎìÑÎìàÎìêÎìïÎìúÎìùÎì†Îì£Îì§Îì¶Îì¨Îì≠ÎìØÎì±Îì∏ÎîîÎîïÎîòÎîõÎîúÎî§Îî•ÎîßÎî®Îî©Îî™Îî∞Îî±Îî¥Îî∏"],["b641","ÌÑÖ",7,"ÌÑé",17],["b661","ÌÑ†",15,"ÌÑ≤ÌÑ≥ÌÑµÌÑ∂ÌÑ∑ÌÑπÌÑªÌÑºÌÑΩÌÑæ"],["b681","ÌÑøÌÖÇÌÖÜ",5,"ÌÖéÌÖèÌÖëÌÖíÌÖìÌÖï",6,"ÌÖûÌÖ†ÌÖ¢",5,"ÌÖ©ÌÖ™ÌÖ´ÌÖ≠ÎïÄÎïÅÎïÉÎïÑÎïÖÎïãÎïåÎïçÎïêÎïîÎïúÎïùÎïüÎï†Îï°Îñ†Îñ°Îñ§Îñ®Îñ™Îñ´Îñ∞Îñ±Îñ≥Îñ¥ÎñµÎñªÎñºÎñΩÎóÄÎóÑÎóåÎóçÎóèÎóêÎóëÎóòÎó¨ÎòêÎòëÎòîÎòòÎò•Îò¨Îò¥ÎôàÎô§Îô®ÎöúÎöùÎö†Îö§Îö´Îö¨Îö±ÎõîÎõ∞Îõ¥Îõ∏ÎúÄÎúÅÎúÖÎú®Îú©Îú¨ÎúØÎú∞Îú∏ÎúπÎúªÎùÑÎùàÎùåÎùîÎùïÎù†Îù§Îù®Îù∞Îù±Îù≥ÎùµÎùºÎùΩÎûÄÎûÑÎûåÎûçÎûèÎûêÎûëÎûíÎûñÎûó"],["b741","ÌÖÆ",13,"ÌÖΩ",6,"ÌÜÖÌÜÜÌÜáÌÜâÌÜä"],["b761","ÌÜã",20,"ÌÜ¢ÌÜ£ÌÜ•ÌÜ¶ÌÜß"],["b781","ÌÜ©",6,"ÌÜ≤ÌÜ¥ÌÜ∂ÌÜ∑ÌÜ∏ÌÜπÌÜªÌÜΩÌÜæÌÜøÌáÅ",14,"ÎûòÎûôÎûúÎû†Îû®Îû©Îû´Îû¨Îû≠Îû¥ÎûµÎû∏ÎüáÎüâÎü¨Îü≠Îü∞Îü¥ÎüºÎüΩÎüøÎ†ÄÎ†ÅÎ†áÎ†àÎ†âÎ†åÎ†êÎ†òÎ†ôÎ†õÎ†ùÎ†§Î†•Î†®Î†¨Î†¥Î†µÎ†∑Î†∏Î†πÎ°ÄÎ°ÑÎ°ëÎ°ìÎ°úÎ°ùÎ°†Î°§Î°¨Î°≠Î°ØÎ°±Î°∏Î°ºÎ¢çÎ¢®Î¢∞Î¢¥Î¢∏Î£ÄÎ£ÅÎ£ÉÎ£ÖÎ£åÎ£êÎ£îÎ£ùÎ£üÎ£°Î£®Î£©Î£¨Î£∞Î£∏Î£πÎ£ªÎ£ΩÎ§ÑÎ§òÎ§†Î§ºÎ§ΩÎ•ÄÎ•ÑÎ•åÎ•èÎ•ëÎ•òÎ•ôÎ•úÎ•†Î•®Î•©"],["b841","Ìáê",7,"Ìáô",17],["b861","Ìá´",8,"ÌáµÌá∂Ìá∑Ìáπ",13],["b881","ÌààÌàä",5,"Ìàë",24,"Î•´Î•≠Î•¥Î•µÎ•∏Î•ºÎ¶ÑÎ¶ÖÎ¶áÎ¶âÎ¶äÎ¶çÎ¶éÎ¶¨Î¶≠Î¶∞Î¶¥Î¶ºÎ¶ΩÎ¶øÎßÅÎßàÎßâÎßåÎßé",4,"ÎßòÎßôÎßõÎßùÎßûÎß°Îß£Îß§Îß•Îß®Îß¨Îß¥ÎßµÎß∑Îß∏ÎßπÎß∫Î®ÄÎ®ÅÎ®àÎ®ïÎ®∏Î®πÎ®ºÎ©ÄÎ©ÇÎ©àÎ©âÎ©ãÎ©çÎ©éÎ©ìÎ©îÎ©ïÎ©òÎ©úÎ©§Î©•Î©ßÎ©®Î©©Î©∞Î©±Î©¥Î©∏Î™ÉÎ™ÑÎ™ÖÎ™áÎ™åÎ™®Î™©Î™´Î™¨Î™∞Î™≤Î™∏Î™πÎ™ªÎ™ΩÎ´ÑÎ´àÎ´òÎ´ôÎ´º"],["b941","Ìà™Ìà´ÌàÆÌàØÌà±Ìà≤Ìà≥Ìàµ",6,"ÌàæÌâÄÌâÇ",5,"ÌââÌâäÌâãÌâå"],["b961","Ìâç",14,"Ìâù",6,"Ìâ•Ìâ¶ÌâßÌâ®"],["b981","Ìâ©",22,"ÌäÇÌäÉÌäÖÌäÜÌäáÌäâÌääÌäãÌäåÎ¨ÄÎ¨ÑÎ¨çÎ¨èÎ¨ëÎ¨òÎ¨úÎ¨†Î¨©Î¨´Î¨¥Î¨µÎ¨∂Î¨∏Î¨ªÎ¨ºÎ¨ΩÎ¨æÎ≠ÑÎ≠ÖÎ≠áÎ≠âÎ≠çÎ≠èÎ≠êÎ≠îÎ≠òÎ≠°Î≠£Î≠¨ÎÆàÎÆåÎÆêÎÆ§ÎÆ®ÎÆ¨ÎÆ¥ÎÆ∑ÎØÄÎØÑÎØàÎØêÎØìÎØ∏ÎØπÎØºÎØøÎ∞ÄÎ∞ÇÎ∞àÎ∞âÎ∞ãÎ∞åÎ∞çÎ∞èÎ∞ëÎ∞î",4,"Î∞õ",4,"Î∞§Î∞•Î∞ßÎ∞©Î∞≠Î∞∞Î∞±Î∞¥Î∞∏Î±ÄÎ±ÅÎ±ÉÎ±ÑÎ±ÖÎ±âÎ±åÎ±çÎ±êÎ±ùÎ≤ÑÎ≤ÖÎ≤àÎ≤ãÎ≤åÎ≤éÎ≤îÎ≤ïÎ≤ó"],["ba41","ÌäçÌäéÌäèÌäíÌäìÌäîÌäñ",5,"ÌäùÌäûÌäüÌä°Ìä¢Ìä£Ìä•",6,"Ìä≠"],["ba61","ÌäÆÌäØÌä∞Ìä≤",5,"Ìä∫ÌäªÌäΩÌäæÌãÅÌãÉ",4,"ÌãäÌãå",5],["ba81","ÌãíÌãìÌãïÌãñÌãóÌãôÌãöÌãõÌãù",6,"Ìã¶",9,"Ìã≤Ìã≥ÌãµÌã∂Ìã∑ÌãπÌã∫Î≤ôÎ≤öÎ≤†Î≤°Î≤§Î≤ßÎ≤®Î≤∞Î≤±Î≤≥Î≤¥Î≤µÎ≤ºÎ≤ΩÎ≥ÄÎ≥ÑÎ≥çÎ≥èÎ≥êÎ≥ëÎ≥ïÎ≥òÎ≥úÎ≥¥Î≥µÎ≥∂Î≥∏Î≥ºÎ¥ÑÎ¥ÖÎ¥áÎ¥âÎ¥êÎ¥îÎ¥§Î¥¨ÎµÄÎµàÎµâÎµåÎµêÎµòÎµôÎµ§Îµ®Î∂ÄÎ∂ÅÎ∂ÑÎ∂áÎ∂àÎ∂âÎ∂äÎ∂êÎ∂ëÎ∂ìÎ∂ïÎ∂ôÎ∂öÎ∂úÎ∂§Î∂∞Î∂∏Î∑îÎ∑ïÎ∑òÎ∑úÎ∑©Î∑∞Î∑¥Î∑∏Î∏ÄÎ∏ÉÎ∏ÖÎ∏åÎ∏çÎ∏êÎ∏îÎ∏úÎ∏ùÎ∏üÎπÑÎπÖÎπàÎπåÎπéÎπîÎπïÎπóÎπôÎπöÎπõÎπ†Îπ°Îπ§"],["bb41","Ìãª",4,"ÌåÇÌåÑÌåÜ",5,"ÌåèÌåëÌåíÌåìÌåïÌåó",4,"ÌåûÌå¢Ìå£"],["bb61","Ìå§Ìå¶ÌåßÌå™Ìå´Ìå≠ÌåÆÌåØÌå±",6,"Ìå∫Ìåæ",5,"ÌçÜÌçáÌçàÌçâ"],["bb81","Ìçä",31,"Îπ®Îπ™Îπ∞Îπ±Îπ≥Îπ¥ÎπµÎπªÎπºÎπΩÎ∫ÄÎ∫ÑÎ∫åÎ∫çÎ∫èÎ∫êÎ∫ëÎ∫òÎ∫ôÎ∫®ÎªêÎªëÎªîÎªóÎªòÎª†Îª£Îª§Îª•Îª¨ÎºÅÎºàÎºâÎºòÎºôÎºõÎºúÎºùÎΩÄÎΩÅÎΩÑÎΩàÎΩêÎΩëÎΩïÎæîÎæ∞ÎøÖÎøåÎøçÎøêÎøîÎøúÎøüÎø°ÏÄºÏÅëÏÅòÏÅúÏÅ†ÏÅ®ÏÅ©ÏÇêÏÇëÏÇîÏÇòÏÇ†ÏÇ°ÏÇ£ÏÇ•ÏÇ¨ÏÇ≠ÏÇØÏÇ∞ÏÇ≥ÏÇ¥ÏÇµÏÇ∂ÏÇºÏÇΩÏÇøÏÉÄÏÉÅÏÉÖÏÉàÏÉâÏÉåÏÉêÏÉòÏÉôÏÉõÏÉúÏÉùÏÉ§"],["bc41","Ìç™",17,"ÌçæÌçøÌéÅÌéÇÌéÉÌéÖÌéÜÌéá"],["bc61","ÌéàÌéâÌéäÌéãÌééÌéí",5,"ÌéöÌéõÌéùÌéûÌéüÌé°",6,"Ìé™Ìé¨ÌéÆ"],["bc81","ÌéØ",4,"ÌéµÌé∂Ìé∑ÌéπÌé∫ÌéªÌéΩ",6,"ÌèÜÌèáÌèä",5,"Ìèë",5,"ÏÉ•ÏÉ®ÏÉ¨ÏÉ¥ÏÉµÏÉ∑ÏÉπÏÑÄÏÑÑÏÑàÏÑêÏÑïÏÑú",4,"ÏÑ£ÏÑ§ÏÑ¶ÏÑßÏÑ¨ÏÑ≠ÏÑØÏÑ∞ÏÑ±ÏÑ∂ÏÑ∏ÏÑπÏÑºÏÖÄÏÖàÏÖâÏÖãÏÖåÏÖçÏÖîÏÖïÏÖòÏÖúÏÖ§ÏÖ•ÏÖßÏÖ®ÏÖ©ÏÖ∞ÏÖ¥ÏÖ∏ÏÜÖÏÜåÏÜçÏÜéÏÜêÏÜîÏÜñÏÜúÏÜùÏÜüÏÜ°ÏÜ•ÏÜ®ÏÜ©ÏÜ¨ÏÜ∞ÏÜΩÏáÑÏáàÏáåÏáîÏáóÏáòÏá†Ïá§Ïá®Ïá∞Ïá±Ïá≥ÏáºÏáΩÏàÄÏàÑÏàåÏàçÏàèÏàëÏàòÏàôÏàúÏàüÏà†Ïà®Ïà©Ïà´Ïà≠"],["bd41","ÌèóÌèô",7,"Ìè¢Ìè§",7,"ÌèÆÌèØÌè±Ìè≤Ìè≥ÌèµÌè∂Ìè∑"],["bd61","Ìè∏ÌèπÌè∫ÌèªÌèæÌêÄÌêÇ",5,"Ìêâ",13],["bd81","Ìêó",5,"Ìêû",25,"ÏàØÏà±Ïà≤Ïà¥ÏâàÏâêÏâëÏâîÏâòÏâ†Ïâ•Ïâ¨Ïâ≠Ïâ∞Ïâ¥ÏâºÏâΩÏâøÏäÅÏäàÏäâÏäêÏäòÏäõÏäùÏä§Ïä•Ïä®Ïä¨Ïä≠Ïä¥ÏäµÏä∑ÏäπÏãúÏãùÏã†Ïã£Ïã§Ïã´Ïã¨Ïã≠ÏãØÏã±Ïã∂Ïã∏ÏãπÏãªÏãºÏåÄÏåàÏåâÏååÏåçÏåìÏåîÏåïÏåòÏåúÏå§Ïå•Ïå®Ïå©ÏçÖÏç®Ïç©Ïç¨Ïç∞Ïç≤Ïç∏ÏçπÏçºÏçΩÏéÑÏéàÏéåÏèÄÏèòÏèôÏèúÏèüÏè†Ïè¢Ïè®Ïè©Ïè≠Ïè¥ÏèµÏè∏ÏêàÏêêÏê§Ïê¨Ïê∞"],["be41","Ìê∏",7,"ÌëÅÌëÇÌëÉÌëÖ",14],["be61","Ìëî",7,"ÌëùÌëûÌëüÌë°Ìë¢Ìë£Ìë•",7,"ÌëÆÌë∞Ìë±Ìë≤"],["be81","Ìë≥",4,"Ìë∫ÌëªÌëΩÌëæÌíÅÌíÉ",4,"ÌíäÌíåÌíé",5,"Ìíï",8,"Ïê¥ÏêºÏêΩÏëàÏë§Ïë•Ïë®Ïë¨Ïë¥ÏëµÏëπÏíÄÏíîÏíúÏí∏ÏíºÏì©Ïì∞Ïì±Ïì¥Ïì∏Ïì∫ÏìøÏîÄÏîÅÏîåÏîêÏîîÏîúÏî®Ïî©Ïî¨Ïî∞Ïî∏ÏîπÏîªÏîΩÏïÑÏïÖÏïàÏïâÏïäÏïåÏïçÏïéÏïìÏïîÏïïÏïóÏïòÏïôÏïùÏïûÏï†Ïï°Ïï§Ïï®Ïï∞Ïï±Ïï≥Ïï¥ÏïµÏïºÏïΩÏñÄÏñÑÏñáÏñåÏñçÏñèÏñëÏñïÏñóÏñòÏñúÏñ†Ïñ©Ïñ¥ÏñµÏñ∏ÏñπÏñªÏñºÏñΩÏñæÏóÑ",6,"ÏóåÏóé"],["bf41","Ìíû",10,"Ìí™",14],["bf61","Ìíπ",18,"ÌìçÌìéÌìèÌìëÌìíÌììÌìï"],["bf81","Ììñ",5,"ÌìùÌìûÌì†",7,"Ìì©Ìì™Ìì´Ìì≠ÌìÆÌìØÌì±",6,"ÌìπÌì∫ÌìºÏóêÏóëÏóîÏóòÏó†Ïó°Ïó£Ïó•Ïó¨Ïó≠ÏóÆÏó∞Ïó¥Ïó∂Ïó∑Ïóº",5,"ÏòÖÏòÜÏòáÏòàÏòåÏòêÏòòÏòôÏòõÏòúÏò§Ïò•Ïò®Ïò¨Ïò≠ÏòÆÏò∞Ïò≥Ïò¥ÏòµÏò∑ÏòπÏòªÏôÄÏôÅÏôÑÏôàÏôêÏôëÏôìÏôîÏôïÏôúÏôùÏô†Ïô¨ÏôØÏô±Ïô∏ÏôπÏôºÏöÄÏöàÏöâÏöãÏöçÏöîÏöïÏöòÏöúÏö§Ïö•ÏößÏö©Ïö∞Ïö±Ïö¥Ïö∏ÏöπÏö∫ÏõÄÏõÅÏõÉÏõÖÏõåÏõçÏõêÏõîÏõúÏõùÏõ†Ïõ°Ïõ®"],["c041","Ììæ",5,"ÌîÖÌîÜÌîáÌîâÌîäÌîãÌîç",6,"ÌîñÌîò",5],["c061","Ìîû",25],["c081","Ìî∏ÌîπÌî∫ÌîªÌîæÌîøÌïÅÌïÇÌïÉÌïÖ",6,"ÌïéÌïêÌïí",5,"ÌïöÌïõÌïùÌïûÌïüÌï°Ìï¢Ìï£Ïõ©Ïõ¨Ïõ∞Ïõ∏ÏõπÏõΩÏúÑÏúÖÏúàÏúåÏúîÏúïÏúóÏúôÏú†Ïú°Ïú§Ïú®Ïú∞Ïú±Ïú≥ÏúµÏú∑ÏúºÏúΩÏùÄÏùÑÏùäÏùåÏùçÏùèÏùë",7,"ÏùúÏù†Ïù®Ïù´Ïù¥ÏùµÏù∏ÏùºÏùΩÏùæÏûÉÏûÑÏûÖÏûáÏûàÏûâÏûäÏûéÏûêÏûëÏûîÏûñÏûóÏûòÏûöÏû†Ïû°Ïû£Ïû§Ïû•Ïû¶Ïû¨Ïû≠Ïû∞Ïû¥ÏûºÏûΩÏûøÏüÄÏüÅÏüàÏüâÏüåÏüéÏüêÏüòÏüùÏü§Ïü®Ïü¨Ï†ÄÏ†ÅÏ†ÑÏ†àÏ†ä"],["c141","Ìï§Ìï¶ÌïßÌï™Ìï¨ÌïÆ",5,"Ìï∂Ìï∑ÌïπÌï∫ÌïªÌïΩ",6,"ÌñÜÌñäÌñã"],["c161","ÌñåÌñçÌñéÌñèÌñë",19,"Ìñ¶Ìñß"],["c181","Ìñ®",31,"Ï†êÏ†ëÏ†ìÏ†ïÏ†ñÏ†úÏ†ùÏ††Ï†§Ï†¨Ï†≠Ï†ØÏ†±Ï†∏Ï†ºÏ°ÄÏ°àÏ°âÏ°åÏ°çÏ°îÏ°∞Ï°±Ï°¥Ï°∏Ï°∫Ï¢ÄÏ¢ÅÏ¢ÉÏ¢ÖÏ¢ÜÏ¢áÏ¢ãÏ¢åÏ¢çÏ¢îÏ¢ùÏ¢üÏ¢°Ï¢®Ï¢ºÏ¢ΩÏ£ÑÏ£àÏ£åÏ£îÏ£ïÏ£óÏ£ôÏ£†Ï£°Ï£§Ï£µÏ£ºÏ£ΩÏ§ÄÏ§ÑÏ§ÖÏ§ÜÏ§åÏ§çÏ§èÏ§ëÏ§òÏ§¨Ï§¥Ï•êÏ•ëÏ•îÏ•òÏ•†Ï•°Ï•£Ï•¨Ï•∞Ï•¥Ï•ºÏ¶àÏ¶âÏ¶åÏ¶êÏ¶òÏ¶ôÏ¶õÏ¶ùÏßÄÏßÅÏßÑÏßáÏßàÏßäÏßêÏßëÏßì"],["c241","ÌóäÌóãÌóçÌóéÌóèÌóëÌóì",4,"ÌóöÌóúÌóû",5,"Ìó¶ÌóßÌó©Ìó™Ìó´Ìó≠ÌóÆ"],["c261","ÌóØ",4,"Ìó∂Ìó∏Ìó∫",5,"ÌòÇÌòÉÌòÖÌòÜÌòáÌòâ",6,"Ìòí"],["c281","Ìòñ",5,"ÌòùÌòûÌòüÌò°Ìò¢Ìò£Ìò•",7,"ÌòÆ",9,"Ìò∫ÌòªÏßïÏßñÏßôÏßöÏßúÏßùÏß†Ïß¢Ïß§ÏßßÏß¨Ïß≠ÏßØÏß∞Ïß±Ïß∏ÏßπÏßºÏ®ÄÏ®àÏ®âÏ®ãÏ®åÏ®çÏ®îÏ®òÏ®©Ï©åÏ©çÏ©êÏ©îÏ©úÏ©ùÏ©üÏ©†Ï©°Ï©®Ï©ΩÏ™ÑÏ™òÏ™ºÏ™ΩÏ´ÄÏ´ÑÏ´åÏ´çÏ´èÏ´ëÏ´ìÏ´òÏ´ôÏ´†Ï´¨Ï´¥Ï¨àÏ¨êÏ¨îÏ¨òÏ¨†Ï¨°Ï≠ÅÏ≠àÏ≠âÏ≠åÏ≠êÏ≠òÏ≠ôÏ≠ùÏ≠§Ï≠∏Ï≠πÏÆúÏÆ∏ÏØîÏØ§ÏØßÏØ©Ï∞åÏ∞çÏ∞êÏ∞îÏ∞úÏ∞ùÏ∞°Ï∞¢Ï∞ßÏ∞®Ï∞©Ï∞¨Ï∞ÆÏ∞∞Ï∞∏Ï∞πÏ∞ª"],["c341","ÌòΩÌòæÌòøÌôÅÌôÇÌôÉÌôÑÌôÜÌôáÌôäÌôåÌôéÌôèÌôêÌôíÌôìÌôñÌôóÌôôÌôöÌôõÌôù",4],["c361","Ìô¢",4,"Ìô®Ìô™",5,"Ìô≤Ìô≥Ìôµ",11],["c381","ÌöÅÌöÇÌöÑÌöÜ",5,"ÌöéÌöèÌöëÌöíÌöìÌöï",7,"ÌöûÌö†Ìö¢",5,"Ìö©Ìö™Ï∞ºÏ∞ΩÏ∞æÏ±ÑÏ±ÖÏ±àÏ±åÏ±îÏ±ïÏ±óÏ±òÏ±ôÏ±†Ï±§Ï±¶Ï±®Ï±∞Ï±µÏ≤òÏ≤ôÏ≤úÏ≤†Ï≤®Ï≤©Ï≤´Ï≤¨Ï≤≠Ï≤¥Ï≤µÏ≤∏Ï≤ºÏ≥ÑÏ≥ÖÏ≥áÏ≥âÏ≥êÏ≥îÏ≥§Ï≥¨Ï≥∞Ï¥ÅÏ¥àÏ¥âÏ¥åÏ¥êÏ¥òÏ¥ôÏ¥õÏ¥ùÏ¥§Ï¥®Ï¥¨Ï¥πÏµúÏµ†Ïµ§Ïµ¨Ïµ≠ÏµØÏµ±Ïµ∏Ï∂àÏ∂îÏ∂ïÏ∂òÏ∂úÏ∂§Ï∂•Ï∂ßÏ∂©Ï∂∞Ï∑ÑÏ∑åÏ∑êÏ∑®Ï∑¨Ï∑∞Ï∑∏Ï∑πÏ∑ªÏ∑ΩÏ∏ÑÏ∏àÏ∏åÏ∏îÏ∏ôÏ∏†Ï∏°Ï∏§Ï∏®Ï∏∞Ï∏±Ï∏≥Ï∏µ"],["c441","Ìö´Ìö≠ÌöÆÌöØÌö±",7,"Ìö∫Ìöº",7,"ÌõÜÌõáÌõâÌõäÌõã"],["c461","ÌõçÌõéÌõèÌõêÌõíÌõìÌõïÌõñÌõòÌõö",5,"Ìõ°Ìõ¢Ìõ£Ìõ•Ìõ¶ÌõßÌõ©",4],["c481","ÌõÆÌõØÌõ±Ìõ≤Ìõ≥Ìõ¥Ìõ∂",5,"ÌõæÌõøÌúÅÌúÇÌúÉÌúÖ",11,"ÌúíÌúìÌúîÏπòÏπôÏπúÏπüÏπ†Ïπ°Ïπ®Ïπ©Ïπ´Ïπ≠Ïπ¥ÏπµÏπ∏ÏπºÏ∫ÑÏ∫ÖÏ∫áÏ∫âÏ∫êÏ∫ëÏ∫îÏ∫òÏ∫†Ï∫°Ï∫£Ï∫§Ï∫•Ï∫¨Ï∫≠ÏªÅÏª§Ïª•Ïª®Ïª´Ïª¨Ïª¥ÏªµÏª∑Ïª∏ÏªπÏºÄÏºÅÏºÑÏºàÏºêÏºëÏºìÏºïÏºúÏº†Ïº§Ïº¨Ïº≠ÏºØÏº∞Ïº±Ïº∏ÏΩîÏΩïÏΩòÏΩúÏΩ§ÏΩ•ÏΩßÏΩ©ÏΩ∞ÏΩ±ÏΩ¥ÏΩ∏ÏæÄÏæÖÏæåÏæ°Ïæ®Ïæ∞ÏøÑÏø†Ïø°Ïø§Ïø®Ïø∞Ïø±Ïø≥ÏøµÏøºÌÄÄÌÄÑÌÄëÌÄòÌÄ≠ÌÄ¥ÌÄµÌÄ∏ÌÄº"],["c541","ÌúïÌúñÌúóÌúöÌúõÌúùÌúûÌúüÌú°",6,"Ìú™Ìú¨ÌúÆ",5,"Ìú∂Ìú∑Ìúπ"],["c561","Ìú∫ÌúªÌúΩ",6,"ÌùÖÌùÜÌùàÌùä",5,"ÌùíÌùìÌùïÌùö",4],["c581","ÌùüÌù¢Ìù§Ìù¶ÌùßÌù®Ìù™Ìù´Ìù≠ÌùÆÌùØÌù±Ìù≤Ìù≥Ìùµ",6,"ÌùæÌùøÌûÄÌûÇ",5,"ÌûäÌûãÌÅÑÌÅÖÌÅáÌÅâÌÅêÌÅîÌÅòÌÅ†ÌÅ¨ÌÅ≠ÌÅ∞ÌÅ¥ÌÅºÌÅΩÌÇÅÌÇ§ÌÇ•ÌÇ®ÌÇ¨ÌÇ¥ÌÇµÌÇ∑ÌÇπÌÉÄÌÉÅÌÉÑÌÉàÌÉâÌÉêÌÉëÌÉìÌÉîÌÉïÌÉúÌÉùÌÉ†ÌÉ§ÌÉ¨ÌÉ≠ÌÉØÌÉ∞ÌÉ±ÌÉ∏ÌÑçÌÑ∞ÌÑ±ÌÑ¥ÌÑ∏ÌÑ∫ÌÖÄÌÖÅÌÖÉÌÖÑÌÖÖÌÖåÌÖçÌÖêÌÖîÌÖúÌÖùÌÖüÌÖ°ÌÖ®ÌÖ¨ÌÖºÌÜÑÌÜàÌÜ†ÌÜ°ÌÜ§ÌÜ®ÌÜ∞ÌÜ±ÌÜ≥ÌÜµÌÜ∫ÌÜºÌáÄÌáòÌá¥Ìá∏ÌàáÌàâÌàêÌà¨Ìà≠Ìà∞Ìà¥ÌàºÌàΩÌàøÌâÅÌâàÌâú"],["c641","ÌûçÌûéÌûèÌûë",6,"ÌûöÌûúÌûû",5],["c6a1","Ìâ§ÌäÄÌäÅÌäÑÌäàÌäêÌäëÌäïÌäúÌä†Ìä§Ìä¨Ìä±Ìä∏ÌäπÌäºÌäøÌãÄÌãÇÌãàÌãâÌããÌãîÌãòÌãúÌã§Ìã•Ìã∞Ìã±Ìã¥Ìã∏ÌåÄÌåÅÌåÉÌåÖÌååÌåçÌåéÌåêÌåîÌåñÌåúÌåùÌåüÌå†Ìå°Ìå•Ìå®Ìå©Ìå¨Ìå∞Ìå∏ÌåπÌåªÌåºÌåΩÌçÑÌçÖÌçºÌçΩÌéÄÌéÑÌéåÌéçÌéèÌéêÌéëÌéòÌéôÌéúÌé†Ìé®Ìé©Ìé´Ìé≠Ìé¥Ìé∏ÌéºÌèÑÌèÖÌèàÌèâÌèêÌèòÌè°Ìè£Ìè¨Ìè≠Ìè∞Ìè¥ÌèºÌèΩÌèøÌêÅ"],["c7a1","ÌêàÌêùÌëÄÌëÑÌëúÌë†Ìë§Ìë≠ÌëØÌë∏ÌëπÌëºÌëøÌíÄÌíÇÌíàÌíâÌíãÌíçÌíîÌí©ÌìåÌìêÌìîÌìúÌìüÌì®Ìì¨Ìì∞Ìì∏ÌìªÌìΩÌîÑÌîàÌîåÌîîÌîïÌîóÌîºÌîΩÌïÄÌïÑÌïåÌïçÌïèÌïëÌïòÌïôÌïúÌï†Ìï•Ìï®Ìï©Ìï´Ìï≠Ìï¥ÌïµÌï∏ÌïºÌñÑÌñÖÌñáÌñàÌñâÌñêÌñ•ÌóàÌóâÌóåÌóêÌóíÌóòÌóôÌóõÌóùÌó§Ìó•Ìó®Ìó¨Ìó¥ÌóµÌó∑ÌóπÌòÄÌòÅÌòÑÌòàÌòêÌòëÌòìÌòîÌòïÌòúÌò†"],["c8a1","Ìò§Ìò≠Ìò∏ÌòπÌòºÌôÄÌôÖÌôàÌôâÌôãÌôçÌôëÌôîÌôïÌôòÌôúÌôßÌô©Ìô∞Ìô±Ìô¥ÌöÉÌöÖÌöåÌöçÌöêÌöîÌöùÌöüÌö°Ìö®Ìö¨Ìö∞ÌöπÌöªÌõÑÌõÖÌõàÌõåÌõëÌõîÌõóÌõôÌõ†Ìõ§Ìõ®Ìõ∞ÌõµÌõºÌõΩÌúÄÌúÑÌúëÌúòÌúôÌúúÌú†Ìú®Ìú©Ìú´Ìú≠Ìú¥ÌúµÌú∏ÌúºÌùÑÌùáÌùâÌùêÌùëÌùîÌùñÌùóÌùòÌùôÌù†Ìù°Ìù£Ìù•Ìù©Ìù¨Ìù∞Ìù¥ÌùºÌùΩÌûÅÌûàÌûâÌûåÌûêÌûòÌûôÌûõÌûù"],["caa1","‰ºΩ‰Ω≥ÂÅáÂÉπÂä†ÂèØÂëµÂì•ÂòâÂ´ÅÂÆ∂ÊöáÊû∂Êû∑ÊüØÊ≠åÁèÇÁóÇÁ®ºËãõËåÑË°óË¢àË®∂Ë≥àË∑èËªªËø¶ÈßïÂàªÂç¥ÂêÑÊÅ™ÊÖ§ÊÆºÁèèËÑöË¶∫ËßíÈñ£‰æÉÂàäÂ¢æÂ•∏Âß¶Âπ≤ÂππÊááÊèÄÊùÜÊü¨Ê°øÊæóÁôéÁúãÁ£µÁ®àÁ´øÁ∞°ËÇùËâÆËâ±Ë´´Èñì‰π´ÂñùÊõ∑Ê∏¥Á¢£Á´≠ËëõË§êËùéÈû®ÂãòÂùéÂ†™ÂµåÊÑüÊÜæÊà°Êï¢ÊüëÊ©ÑÊ∏õÁîòÁñ≥Áõ£Áû∞Á¥∫ÈÇØÈëëÈëíÈæï"],["cba1","Âå£Â≤¨Áî≤ËÉõÈâÄÈñòÂâõÂ†àÂßúÂ≤°Â¥óÂ∫∑Âº∫ÂΩäÊÖ∑Ê±üÁï∫ÁñÜÁ≥†Áµ≥Á∂±ÁæåËÖîËà°ËñëË•ÅË¨õÈãºÈôçÈ±á‰ªã‰ª∑ÂÄãÂá±Â°èÊÑ∑ÊÑæÊÖ®ÊîπÊß™ÊºëÁñ•ÁöÜÁõñÁÆáËä•ËìãÔ§ÄÈéßÈñãÂñÄÂÆ¢ÂùëÔ§ÅÁ≤≥ÁæπÈÜµÂÄ®ÂéªÂ±ÖÂ∑®ÊãíÊçÆÊìöÊìßÊ∏†ÁÇ¨Á•õË∑ùË∏ûÔ§ÇÈÅΩÈâÖÈã∏‰πæ‰ª∂ÂÅ•Â∑æÂª∫ÊÑÜÊ•óËÖ±ËôîËπáÈçµÈ®´‰πûÂÇëÊù∞Ê°ÄÂÑâÂäçÂäíÊ™¢"],["cca1","ÁûºÈàêÈªîÂä´ÊÄØËø≤ÂÅàÊÜ©Êè≠ÊìäÊ†ºÊ™ÑÊøÄËÜàË¶°ÈöîÂ†ÖÁâΩÁä¨ÁîÑÁµπÁπ≠ËÇ©Ë¶ãË≠¥ÈÅ£ÈµëÊäâÊ±∫ÊΩîÁµêÁº∫Ë®£ÂÖºÊÖäÁÆùË¨ôÈâóÈéå‰∫¨‰øìÂÄûÂÇæÂÑÜÂãÅÂãçÂçøÂù∞Â¢ÉÂ∫öÂæëÊÖ∂ÊÜ¨ÊìéÊï¨ÊôØÊöªÊõ¥Ê¢óÊ∂áÁÇÖÁÉ±ÁíüÁí•ÁìäÁóôÁ°¨Á£¨Á´üÁ´∂ÁµÖÁ∂ìËÄïËÄøËÑõËéñË≠¶ËºïÈÄïÈè°È†ÉÈ†∏È©öÈØ®‰øÇÂïìÂ†∫Â•ëÂ≠£Â±ÜÊÇ∏ÊàíÊ°ÇÊ¢∞"],["cda1","Ê£®Ê∫™ÁïåÁô∏Á£éÁ®ΩÁ≥ªÁπ´ÁπºË®àË™°Ë∞øÈöéÈ∑ÑÂè§Âè©ÂëäÂë±Âõ∫ÂßëÂ≠§Â∞ªÂ∫´Êã∑Êî∑ÊïÖÊï≤Êö†ÊûØÊßÅÊ≤ΩÁóºÁöêÁùæÁ®øÁæîËÄÉËÇ°ËÜèËã¶ËãΩËè∞ËóÅË†±Ë¢¥Ë™•Ô§ÉËæúÈåÆÈõáÈ°ßÈ´òÈºìÂì≠ÊñõÊõ≤Ê¢èÁ©ÄË∞∑Èµ†Âõ∞Âù§Â¥ëÊòÜÊ¢±Ê£çÊªæÁê®Ë¢ûÈØ§Ê±®Ô§ÑÈ™®‰æõÂÖ¨ÂÖ±ÂäüÂ≠îÂ∑•ÊÅêÊÅ≠Êã±ÊéßÊîªÁèôÁ©∫Ëö£Ë≤¢Èûè‰∏≤ÂØ°ÊààÊûúÁìú"],["cea1","ÁßëËèìË™áË™≤Ë∑®ÈÅéÈçãÈ°ÜÂªìÊß®ËóøÈÉ≠Ô§ÖÂÜ†ÂÆòÂØ¨ÊÖ£Ê£∫Ê¨æÁÅåÁêØÁìòÁÆ°ÁΩêËèÖËßÄË≤´ÈóúÈ§®ÂàÆÊÅùÊã¨ÈÄÇ‰æäÂÖâÂå°Â£ôÂª£Êõ†Ê¥∏ÁÇöÁãÇÁèñÁ≠êËÉ±ÈëõÂç¶ÊéõÁΩ´‰πñÂÇÄÂ°äÂ£ûÊÄ™ÊÑßÊãêÊßêÈ≠ÅÂÆèÁ¥òËÇ±ËΩü‰∫§ÂÉëÂí¨Âñ¨Â¨åÂ∂†Â∑ßÊî™ÊïéÊ†°Ê©ãÁã°ÁöéÁüØÁµûÁøπËÜ†ËïéËõüËºÉËΩéÈÉäÈ§ÉÈ©ïÈÆ´‰∏ò‰πÖ‰πù‰ªá‰ø±ÂÖ∑Âãæ"],["cfa1","ÂçÄÂè£Âè•ÂíéÂòîÂùµÂû¢ÂØáÂ∂áÂªêÊáºÊãòÊïëÊû∏Êü©ÊßãÊ≠êÊØÜÊØ¨Ê±ÇÊ∫ùÁÅ∏ÁãóÁéñÁêÉÁûøÁü©Á©∂ÁµøËÄâËáºËàÖËàäËãüË°¢Ë¨≥Ë≥ºËªÄÈÄëÈÇ±Èâ§Èä∂ÈßíÈ©ÖÈ≥©È∑óÈæúÂúãÂ±ÄËèäÈû†Èû´È∫¥ÂêõÁ™òÁæ§Ë£ôËªçÈÉ°Â†ÄÂ±àÊéòÁ™üÂÆÆÂºìÁ©πÁ™ÆËäéË∫¨ÂÄ¶Âà∏Âã∏Âç∑ÂúàÊã≥Êç≤Ê¨äÊ∑ÉÁú∑Âé•ÁçóËï®Ëπ∂ÈóïÊú∫Ê´ÉÊΩ∞Ë©≠ËªåÈ•ãÔ§ÜÊô∑Ê≠∏Ë≤¥"],["d0a1","È¨ºÔ§áÂè´Âú≠Â•éÊèÜÊßªÁè™Á°ÖÁ™∫Á´ÖÁ≥æËëµË¶èËµ≥ÈÄµÈñ®ÂãªÂùáÁïáÁ≠†ËèåÈàûÔ§àÊ©òÂÖãÂâãÂäáÊàüÊ£òÊ•µÈöôÂÉÖÂä§Âã§ÊáÉÊñ§Ê†πÊßøÁëæÁ≠ãËäπËè´Ë¶≤Ë¨πËøëÈ•âÔ§â‰ªäÂ¶óÊìíÊòëÊ™éÁê¥Á¶ÅÁ¶ΩËä©Ë°æË°øË•üÔ§äÈå¶‰ºãÂèäÊÄ•Êâ±Ê±≤Á¥öÁµ¶‰∫òÂÖ¢ÁüúËÇØ‰ºÅ‰ºéÂÖ∂ÂÜÄÂóúÂô®ÂúªÂü∫ÂüºÂ§îÂ•áÂ¶ìÂØÑÂ≤êÂ¥éÂ∑±ÂπæÂøåÊäÄÊóóÊó£"],["d1a1","ÊúûÊúüÊùûÊ£ãÊ£ÑÊ©üÊ¨∫Ê∞£Ê±ΩÊ≤ÇÊ∑áÁéòÁê¶Áê™ÁíÇÁí£Áï∏ÁïøÁ¢ÅÁ£ØÁ•ÅÁ•áÁ•àÁ•∫ÁÆïÁ¥ÄÁ∂∫ÁæàËÄÜËÄ≠ËÇåË®òË≠èË±àËµ∑Èå°Èå§È£¢È•ëÈ®éÈ®èÈ©•È∫íÁ∑ä‰Ω∂ÂêâÊãÆÊ°îÈáëÂñ´ÂÑ∫Ô§ãÔ§åÂ®úÊá¶Ô§çÊãèÊãøÔ§é",5,"ÈÇ£Ô§î",4,"Ë´æÔ§ôÔ§öÔ§õÔ§úÊöñÔ§ùÁÖñÔ§ûÔ§üÈõ£Ô§†ÊçèÊç∫ÂçóÔ§°ÊûèÊ•†Êπ≥Ô§¢Áî∑Ô§£Ô§§Ô§•"],["d2a1","Á¥çÔ§¶Ô§ßË°≤ÂõäÂ®òÔ§®",4,"‰πÉÔ§≠ÂÖßÂ•àÊü∞ËÄêÔ§ÆÂ•≥Âπ¥ÊíöÁßäÂøµÊÅ¨ÊãàÊçªÂØßÂØóÂä™Ô§ØÂ•¥Âº©ÊÄíÔ§∞Ô§±Ô§≤ÁëôÔ§≥",5,"ÈßëÔ§π",10,"ÊøÉÔ•ÑÔ•ÖËÜøËæ≤ÊÉ±Ô•ÜÔ•áËÖ¶Ô•àÔ•âÂ∞øÔ•ä",7,"Â´©Ë®•ÊùªÁ¥êÔ•í",5,"ËÉΩÔ•òÔ•ôÂ∞ºÊ≥•ÂåøÊ∫∫Â§öËå∂"],["d3a1","‰∏π‰∫∂‰ΩÜÂñÆÂúòÂ£áÂΩñÊñ∑Êó¶Ê™ÄÊÆµÊπçÁü≠Á´ØÁ∞ûÁ∑ûËõãË¢íÈÑ≤ÈçõÊíªÊææÁç∫Áñ∏ÈÅîÂïñÂùçÊÜ∫ÊìîÊõáÊ∑°ÊπõÊΩ≠ÊæπÁó∞ËÅÉËÜΩËïÅË¶ÉË´áË≠öÈåüÊ≤ìÁïìÁ≠îË∏èÈÅùÂîêÂ†ÇÂ°òÂπ¢ÊàáÊíûÊ£†Áï∂Á≥ñËû≥Èª®‰ª£ÂûàÂùÆÂ§ßÂ∞çÂ≤±Â∏∂ÂæÖÊà¥Êì°Áé≥Ëá∫Ë¢ãË≤∏ÈöäÈªõÂÆÖÂæ∑ÊÇ≥ÂÄíÂàÄÂà∞ÂúñÂ†µÂ°óÂ∞éÂ±†Â≥∂Â∂ãÂ∫¶ÂæíÊÇºÊåëÊéâÊêóÊ°É"],["d4a1","Ê£πÊ´ÇÊ∑òÊ∏°ÊªîÊø§ÁáæÁõúÁùπÁ¶±Á®ªËêÑË¶©Ë≥≠Ë∑≥ËπàÈÄÉÈÄîÈÅìÈÉΩÈççÈô∂ÈüúÊØíÁÄÜÁâòÁä¢Áç®Áù£Á¶øÁØ§Á∫õËÆÄÂ¢©ÊÉáÊï¶ÊóΩÊöæÊ≤åÁÑûÁáâË±öÈ†ì‰π≠Á™Å‰ªùÂÜ¨ÂáçÂãïÂêåÊÜßÊù±Ê°êÊ£üÊ¥ûÊΩºÁñºÁû≥Á´•ËÉ¥Ëë£ÈäÖÂÖúÊñóÊùúÊûìÁóòÁ´áËç≥Ô•öË±ÜÈÄóÈ†≠Â±ØËáÄËäöÈÅÅÈÅØÈàçÂæóÂ∂ùÊ©ôÁáàÁôªÁ≠âËó§Ë¨ÑÈÑßÈ®∞ÂñáÊá∂Ô•õÁô©ÁæÖ"],["d5a1","ËòøËû∫Ë£∏ÈÇèÔ•úÊ¥õÁÉôÁèûÁµ°ËêΩÔ•ùÈÖ™Èß±Ô•û‰∫ÇÂçµÊ¨ÑÊ¨íÁÄæÁàõËò≠È∏ûÂâåËæ£ÂµêÊì•Êî¨Ê¨ñÊø´Á±ÉÁ∫úËóçË•§Ë¶ΩÊãâËáòË†üÂªäÊúóÊµ™ÁãºÁêÖÁëØËûÇÈÉû‰æÜÂ¥çÂæ†ËêäÂÜ∑Êé†Áï•‰∫ÆÂÄÜÂÖ©ÂáâÊ¢ÅÊ®ëÁ≤ÆÁ≤±Á≥ßËâØË´íËºõÈáè‰æ∂ÂÑ∑ÂãµÂëÇÂª¨ÊÖÆÊàæÊóÖÊ´öÊøæÁ§™ËóúË†£Èñ≠È©¢È©™È∫óÈªéÂäõÊõÜÊ≠∑ÁÄùÁ§´ËΩ¢ÈùÇÊÜêÊàÄÊî£Êº£"],["d6a1","ÁÖâÁíâÁ∑¥ËÅØËìÆËº¶ÈÄ£ÈçäÂÜΩÂàóÂä£Ê¥åÁÉàË£ÇÂªâÊñÇÊÆÆÊøÇÁ∞æÁçµ‰ª§‰º∂ÂõπÔ•üÂ≤∫Â∂∫ÊÄúÁé≤Á¨≠ÁæöÁøéËÅÜÈÄûÈà¥Èõ∂ÈùàÈ†òÈΩ°‰æãÊæßÁ¶ÆÈÜ¥Èö∑ÂãûÔ•†ÊíàÊìÑÊ´ìÊΩûÁÄòÁàêÁõßËÄÅËòÜËôúË∑ØËºÖÈú≤È≠ØÈ∑∫ÈπµÁ¢åÁ•øÁ∂†ËèâÈåÑÈπøÈ∫ìË´ñÂ£üÂºÑÊúßÁÄßÁìèÁ±†ËÅæÂÑ°ÁÄ®Áâ¢Á£äË≥ÇË≥öË≥¥Èõ∑‰∫ÜÂÉöÂØÆÂªñÊñôÁáéÁôÇÁû≠ËÅäËìº"],["d7a1","ÈÅºÈ¨ßÈæçÂ£òÂ©ÅÂ±¢Ê®ìÊ∑öÊºèÁòªÁ¥ØÁ∏∑ËîûË§∏Èè§ÈôãÂäâÊóíÊü≥Ê¶¥ÊµÅÊ∫úÁÄèÁêâÁë†ÁïôÁò§Á°´Ë¨¨È°ûÂÖ≠ÊàÆÈô∏‰æñÂÄ´Â¥ôÊ∑™Á∂∏Ëº™ÂæãÊÖÑÊ†óÔ•°ÈöÜÂãíËÇãÂáúÂáåÊ•ûÁ®úÁ∂æËè±Èôµ‰øöÂà©ÂéòÂêèÂîéÂ±•ÊÇßÊùéÊ¢®Êµ¨ÁäÅÁã∏ÁêÜÁíÉÔ•¢Áó¢Á±¨ÁΩπÁæ∏ËéâË£èË£°ÈáåÈáêÈõ¢ÈØâÂêùÊΩæÁáêÁíòËó∫Ë∫™Èö£È±óÈ∫üÊûóÊ∑ãÁê≥Ëá®ÈúñÁ†¨"],["d8a1","Á´ãÁ¨†Á≤íÊë©Áë™Áó≤Á¢ºÁ£®È¶¨È≠îÈ∫ªÂØûÂπïÊº†ËÜúËé´ÈÇà‰∏áÂççÂ®©Â∑íÂΩéÊÖ¢ÊåΩÊô©ÊõºÊªøÊº´ÁÅ£ÁûûËê¨ËîìË†ªËºìÈ•ÖÈ∞ªÂîúÊäπÊú´Ê≤´ËåâË•™Èù∫‰∫°Â¶ÑÂøòÂøôÊúõÁ∂≤ÁΩîËäíËå´ËéΩËºûÈÇôÂüãÂ¶πÂ™íÂØêÊòßÊûöÊ¢ÖÊØèÁÖ§ÁΩµË≤∑Ë≥£ÈÇÅÈ≠ÖËÑàË≤äÈôåÈ©ÄÈ∫•Â≠üÊ∞ìÁåõÁõ≤ÁõüËêåÂÜ™Ë¶ìÂÖçÂÜïÂãâÊ£âÊ≤îÁúÑÁú†Á∂øÁ∑¨Èù¢È∫µÊªÖ"],["d9a1","ËîëÂÜ•ÂêçÂëΩÊòéÊöùÊ§ßÊ∫üÁöøÁûëËåóËìÇËûüÈÖ©ÈäòÈ≥¥Ë¢Ç‰æÆÂÜíÂãüÂßÜÂ∏ΩÊÖïÊë∏ÊëπÊöÆÊüêÊ®°ÊØçÊØõÁâüÁâ°ÁëÅÁú∏ÁüõËÄóËäºËåÖË¨ÄË¨®Ë≤åÊú®Ê≤êÁâßÁõÆÁù¶Á©ÜÈ∂©Ê≠øÊ≤íÂ§¢Êú¶ËíôÂçØÂ¢ìÂ¶ôÂªüÊèèÊò¥Êù≥Ê∏∫Áå´Á´óËãóÈå®ÂãôÂ∑´ÊÜÆÊáãÊàäÊãáÊí´Êó†Ê•ôÊ≠¶ÊØãÁÑ°Áè∑ÁïùÁπÜËàûËåÇËï™Ë™£Ë≤øÈúßÈµ°Â¢®ÈªòÂÄëÂàéÂêªÂïèÊñá"],["daa1","Ê±∂Á¥äÁ¥ãËÅûËöäÈñÄÈõØÂãøÊ≤ïÁâ©Âë≥Â™öÂ∞æÂµãÂΩåÂæÆÊú™Ê¢∂Ê•£Ê∏ºÊπÑÁúâÁ±≥ÁæéËñáË¨éËø∑Èù°Èª¥Â≤∑ÊÇ∂ÊÑçÊÜ´ÊïèÊóªÊóºÊ∞ëÊ≥ØÁéüÁèâÁ∑°ÈñîÂØÜËúúË¨êÂâùÂçöÊãçÊêèÊí≤Êú¥Ê®∏Ê≥äÁèÄÁíûÁÆîÁ≤ïÁ∏õËÜäËà∂ËñÑËø´ÈõπÈßÅ‰º¥ÂçäÂèçÂèõÊãåÊê¨ÊîÄÊñëÊßÉÊ≥ÆÊΩòÁè≠ÁïîÁò¢Áõ§ÁõºÁ£êÁ£ªÁ§¨ÁµÜËà¨Ëü†ËøîÈ†íÈ£ØÂãÉÊãîÊí•Ê∏§ÊΩë"],["dba1","ÁôºË∑ãÈÜ±Èâ¢È´ÆÈ≠ÉÂÄ£ÂÇçÂùäÂ¶®Â∞®ÂπáÂΩ∑ÊàøÊîæÊñπÊóÅÊòâÊûãÊ¶úÊªÇÁ£ÖÁ¥°ËÇ™ËÜÄËà´Ëä≥Ëí°ËöåË®™Ë¨óÈÇ¶Èò≤ÈæêÂÄç‰ø≥Ô•£ÂüπÂæòÊãúÊéíÊùØÊπÉÁÑôÁõÉËÉåËÉöË£¥Ë£µË§ôË≥†Ëº©ÈÖçÈô™‰ºØ‰Ω∞Â∏õÊüèÊ†¢ÁôΩÁôæÈ≠ÑÂπ°Ê®äÁÖ©ÁáîÁï™Ô•§ÁπÅËïÉËó©È£ú‰ºêÁ≠èÁΩ∞Èñ•Âá°Â∏ÜÊ¢µÊ∞æÊ±éÊ≥õÁäØÁØÑËåÉÊ≥ïÁê∫ÂÉªÂäàÂ£ÅÊìòÊ™óÁíßÁôñ"],["dca1","Á¢ßËòóÈó¢ÈúπÔ••ÂçûÂºÅËÆäËæ®ËæØÈÇäÂà•Áû•È±âÈºà‰∏ôÂÄÇÂÖµÂ±õÂπ∑ÊòûÊò∫ÊüÑÊ£ÖÁÇ≥ÁîÅÁóÖÁßâÁ´ùËºßÈ§†È®à‰øùÂ†°Â†±ÂØ∂ÊôÆÊ≠•Ê¥ëÊπ∫ÊΩΩÁè§Áî´Ëè©Ë£úË§ìË≠úËºî‰ºèÂÉïÂåêÂçúÂÆìÂæ©ÊúçÁ¶èËÖπËåØËîîË§áË¶ÜËºπËºªÈ¶•È∞íÊú¨‰π∂‰ø∏Â•âÂ∞ÅÂ≥ØÂ≥∞ÊçßÊ£íÁÉΩÁÜ¢Áê´Á∏´Ëì¨ËúÇÈÄ¢ÈãíÈ≥≥‰∏ç‰ªò‰øØÂÇÖÂâñÂâØÂê¶ÂíêÂü†Â§´Â©¶"],["dda1","Â≠öÂ≠µÂØåÂ∫úÔ•¶Êâ∂Êï∑ÊñßÊµÆÊ∫•Áà∂Á¨¶Á∞øÁº∂ËÖêËÖëËÜöËâÄËäôËé©Ë®ÉË≤†Ë≥¶Ë≥ªËµ¥Ë∂∫ÈÉ®ÈáúÈòúÈôÑÈßôÈ≥ßÂåóÂàÜÂê©Âô¥Â¢≥Â•îÂ•ÆÂøøÊÜ§ÊâÆÊòêÊ±æÁÑöÁõÜÁ≤âÁ≥ûÁ¥õËä¨Ë≥ÅÈõ∞Ô•ß‰ΩõÂºóÂΩøÊãÇÂ¥©ÊúãÊ£öÁ°ºÁπÉÈµ¨‰∏ïÂÇôÂåïÂå™ÂçëÂ¶ÉÂ©¢Â∫áÊÇ≤ÊÜäÊââÊâπÊñêÊûáÊ¶ßÊØîÊØñÊØóÊØòÊ≤∏Ô•®ÁêµÁó∫Á†íÁ¢ëÁßïÁßòÁ≤ÉÁ∑ãÁø°ËÇ•"],["dea1","ËÑæËáÇËè≤ËúöË£®Ë™πË≠¨Ë≤ªÈÑôÈùûÈ£õÈºªÂö¨Â¨™ÂΩ¨ÊñåÊ™≥ÊÆØÊµúÊø±ÁÄïÁâùÁé≠Ë≤ßË≥ìÈ†ªÊÜëÊ∞∑ËÅòÈ®Å‰πç‰∫ã‰∫õ‰ªï‰º∫‰ºº‰Ωø‰øüÂÉøÂè≤Âè∏ÂîÜÂó£ÂõõÂ£´Â•¢Â®ëÂØ´ÂØ∫Â∞ÑÂ∑≥Â∏´ÂæôÊÄùÊç®ÊñúÊñØÊü∂ÊüªÊ¢≠Ê≠ªÊ≤ôÊ≥óÊ∏£ÁÄâÁçÖÁ†ÇÁ§æÁ•ÄÁ•†ÁßÅÁØ©Á¥óÁµ≤ËÇÜËàçËééËìëËõáË£üË©êË©ûË¨ùË≥úËµ¶Ëæ≠ÈÇ™È£ºÈßüÈ∫ùÂâäÔ•©ÊúîÔ•™"],["dfa1","ÂÇòÂà™Â±±Êï£Ê±ïÁèäÁî£ÁñùÁÆóËíúÈÖ∏Èú∞‰π∑ÊííÊÆ∫ÁÖûËñ©‰∏âÔ•´ÊùâÊ£ÆÊ∏óËäüËîòË°´Êè∑ÊæÅÈàíÈ¢Ø‰∏äÂÇ∑ÂÉèÂÑüÂïÜÂñ™ÂòóÂ≠ÄÂ∞ôÂ≥†Â∏∏Â∫äÂ∫†ÂªÇÊÉ≥Ê°ëÊ©°ÊπòÁàΩÁâÄÁãÄÁõ∏Á••ÁÆ±ÁøîË£≥Ëß¥Ë©≥Ë±°Ë≥ûÈúúÂ°ûÁíΩË≥ΩÂóáÔ•¨Á©°Á¥¢Ëâ≤Áâ≤ÁîüÁî•Ô•≠Á¨ôÂ¢ÖÂ£ªÂ∂ºÂ∫èÂ∫∂ÂæêÊÅïÊäíÊçøÊïçÊöëÊõôÊõ∏Ê†ñÊ£≤ÁäÄÁëûÁ≠ÆÁµÆÁ∑ñÁΩ≤"],["e0a1","ËÉ•ËàíËñØË•øË™ìÈÄùÈã§ÈªçÈº†Â§ïÂ•≠Â∏≠ÊÉúÊòîÊô≥ÊûêÊ±êÊ∑ÖÊΩüÁü≥Á¢©ËìÜÈáãÈå´‰ªôÂÉäÂÖàÂñÑÂ¨ãÂÆ£ÊâáÊïæÊóãÊ∏≤ÁÖΩÁêÅÁëÑÁíáÁíøÁô¨Á¶™Á∑öÁπïÁæ®ËÖ∫ËÜ≥ËàπËòöËü¨Ë©µË∑£ÈÅ∏ÈäëÈê•È•çÈÆÆÂç®Â±ëÊ•îÊ≥ÑÊ¥©Ê∏´ËàåËñõË§ªË®≠Ë™™Èõ™ÈΩßÂâ°ÊöπÊÆ≤Á∫ñËüæË¥çÈñÉÈôùÊîùÊ∂âÁáÆÔ•ÆÂüéÂßìÂÆ¨ÊÄßÊÉ∫ÊàêÊòüÊôüÁå©ÁèπÁõõÁúÅÁ≠¨"],["e1a1","ËÅñËÅ≤ËÖ•Ë™†ÈÜí‰∏ñÂã¢Ê≠≤Ê¥óÁ®ÖÁ¨πÁ¥∞Ô•ØË≤∞Âè¨ÂòØÂ°ëÂÆµÂ∞èÂ∞ëÂ∑¢ÊâÄÊéÉÊêîÊò≠Ê¢≥Ê≤ºÊ∂àÊ∫ØÁÄüÁÇ§ÁáíÁî¶ÁñèÁñéÁòôÁ¨ëÁØ†Á∞´Á¥†Á¥πËî¨Ëï≠ËòáË®¥ÈÄçÈÅ°ÈÇµÈä∑Èü∂È®∑‰øóÂ±¨ÊùüÊ∂ëÁ≤üÁ∫åË¨ñË¥ñÈÄüÂ≠´Â∑ΩÊêçËìÄÈÅúÈ£°ÁéáÂÆãÊÇöÊùæÊ∑ûË®üË™¶ÈÄÅÈ†åÂà∑Ô•∞ÁÅëÁ¢éÈéñË°∞Èáó‰øÆÂèóÂóΩÂõöÂûÇÂ£ΩÂ´ÇÂÆàÂ≤´Â≥ÄÂ∏•ÊÑÅ"],["e2a1","ÊàçÊâãÊéàÊêúÊî∂Êï∏Ê®πÊÆäÊ∞¥Ê¥ôÊº±ÁáßÁã©Áç∏ÁêáÁí≤Áò¶Áù°ÁßÄÁ©óÁ´™Á≤πÁ∂èÁ∂¨Áπ°ÁæûËÑ©Ëå±ËíêËìöËó™Ë¢ñË™∞ËÆêËº∏ÈÅÇÈÇÉÈÖ¨ÈäñÈäπÈöãÈößÈö®ÈõñÈúÄÈ†àÈ¶ñÈ´ìÈ¨öÂèîÂ°æÂ§ôÂ≠∞ÂÆøÊ∑ëÊΩöÁÜüÁê°ÁíπËÇÖËèΩÂ∑°ÂæáÂæ™ÊÅÇÊó¨Ê†íÊ•ØÊ©ìÊÆâÊ¥µÊ∑≥Áè£ÁõæÁû¨Á≠çÁ¥îËÑ£ËàúËçÄËì¥Ëï£Ë©¢Ë´ÑÈÜáÈåûÈ†ÜÈ¶¥ÊàåË°ìËø∞Èâ•Â¥áÂ¥ß"],["e3a1","Âµ©ÁëüËÜùËù®ÊøïÊãæÁøíË§∂Ë•≤‰∏û‰πòÂÉßÂãùÂçáÊâøÊòáÁπ©Ë†ÖÈôû‰æçÂåôÂò∂ÂßãÂ™§Â∞∏Â±éÂ±çÂ∏ÇÂºëÊÅÉÊñΩÊòØÊôÇÊûæÊü¥ÁåúÁü¢Á§∫ÁøÖËíîËìçË¶ñË©¶Ë©©Ë´°Ë±ïË±∫Âü¥ÂØîÂºèÊÅØÊã≠Ê§çÊÆñÊπúÁÜÑÁØíËùïË≠òËªæÈ£üÈ£æ‰º∏‰æÅ‰ø°ÂëªÂ®†ÂÆ∏ÊÑºÊñ∞Êô®ÁáºÁî≥Á•ûÁ¥≥ËÖéËá£ËéòËñ™ËóéËúÉË®äË∫´ËæõÔ•±ËøÖÂ§±ÂÆ§ÂØ¶ÊÇâÂØ©Â∞ãÂøÉÊ≤Å"],["e4a1","Ô•≤Ê∑±ÁÄãÁîöËäØË´∂‰ªÄÂçÅÔ•≥ÈõôÊ∞è‰∫û‰øÑÂÖíÂïûÂ®•Â≥®ÊàëÁâôËäΩËé™ËõæË°ôË®ùÈòøÈõÖÈ§ìÈ¥âÈµùÂ†äÂ≤≥Â∂ΩÂπÑÊÉ°ÊÑïÊè°Ê®ÇÊ∏•ÈÑÇÈçîÈ°éÈ∞êÈΩ∑ÂÆâÂ≤∏ÊåâÊôèÊ°àÁúºÈõÅÈûçÈ°îÈÆüÊñ°Ë¨ÅËªãÈñºÂîµÂ≤©Â∑ñÂ∫µÊöóÁôåËè¥ÈóáÂ£ìÊäºÁãéÈ¥®‰ª∞Â§ÆÊÄèÊòªÊÆÉÁßßÈ¥¶ÂéìÂìÄÂüÉÂ¥ñÊÑõÊõñÊ∂ØÁ¢çËâæÈöòÈùÑÂéÑÊâºÊéñÊ∂≤Á∏äËÖãÈ°ç"],["e5a1","Ê´ªÁΩåÈ∂ØÈ∏ö‰πüÂÄªÂÜ∂Â§úÊÉπÊè∂Ê§∞Áà∫ËÄ∂Ô•¥ÈáéÂº±Ô•µÔ•∂Á¥ÑËã•ËëØËíªËó•Ë∫çÔ•∑‰ΩØÔ•∏Ô•πÂ£§Â≠ÉÊÅôÊèöÊîòÊï≠ÊöòÔ•∫Ê•äÊ®£Ê¥ãÁÄÅÁÖ¨ÁóíÁòçÁ¶≥Á©∞Ô•ªÁæäÔ•ºË•ÑÔ•ΩËÆìÈáÄÈôΩÔ•æÈ§äÂúÑÂæ°ÊñºÊºÅÁòÄÁ¶¶Ë™ûÈ¶≠È≠öÈΩ¨ÂÑÑÊÜ∂ÊäëÊ™çËáÜÂÅÉÂ†∞ÂΩ¶ÁÑâË®ÄË´∫Â≠ºËòñ‰ø∫ÂÑºÂö¥Â•ÑÊé©Ê∑πÂ∂™Ê•≠ÂÜÜ‰∫à‰ΩôÔ•øÔ¶ÄÔ¶ÅÂ¶ÇÔ¶Ç"],["e6a1","Ô¶ÉÊ≠üÊ±ùÔ¶ÑÁíµÁ§ñÔ¶ÖËàáËâÖËåπËºøËΩùÔ¶ÜÈ§òÔ¶áÔ¶àÔ¶â‰∫¶Ô¶äÂüüÂΩπÊòìÔ¶ãÔ¶åÁñ´ÁππË≠ØÔ¶çÈÄÜÈ©õÂö•Â†ßÂß∏Â®üÂÆ¥Ô¶éÂª∂Ô¶èÔ¶êÊçêÊåªÔ¶ëÊ§ΩÊ≤áÊ≤øÊ∂éÊ∂ìÊ∑µÊºîÔ¶íÁÉüÁÑ∂ÁÖôÔ¶ìÁáÉÁáïÔ¶îÁ°èÁ°ØÔ¶ïÁ≠µÁ∑£Ô¶ñÁ∏ØÔ¶óË°çËªüÔ¶òÔ¶ôÔ¶öÈâõÔ¶õÈ≥∂Ô¶úÔ¶ùÔ¶ûÊÇÖÊ∂ÖÔ¶üÁÜ±Ô¶†Ô¶°Èñ±Âé≠Ô¶¢Ô¶£Ô¶§ÊüìÔ¶•ÁÇéÁÑ∞Áê∞Ëâ∂Ëãí"],["e7a1","Ô¶¶ÈñªÈ´•ÈπΩÊõÑÔ¶ßÁáÅËëâÔ¶®Ô¶©Â°ãÔ¶™Ô¶´Â∂∏ÂΩ±Ô¶¨Êò†ÊöéÊ•πÊ¶ÆÊ∞∏Ê≥≥Ê∏∂ÊΩÅÊøöÁÄõÁÄØÁÖêÁáüÁç∞Ô¶≠ÁëõÔ¶ÆÁìîÁõàÁ©éÁ∫ìÔ¶ØÔ¶∞Ëã±Ë©†ËøéÔ¶±ÈçàÔ¶≤ÈúôÔ¶≥Ô¶¥‰πÇÂÄ™Ô¶µÂààÂè°Êõ≥Ê±≠ÊøäÁåäÁùøÁ©¢ËäÆËóùËòÇÔ¶∂Ë£îË©£Ë≠ΩË±´Ô¶∑Èä≥Ô¶∏ÈúìÈ†ê‰∫î‰ºç‰øâÂÇ≤ÂçàÂêæÂê≥ÂóöÂ°¢Â¢∫Â•ßÂ®õÂØ§ÊÇüÔ¶πÊáäÊïñÊóøÊô§Ê¢ßÊ±öÊæ≥"],["e8a1","ÁÉèÁÜ¨ÁçíÁ≠ΩËúàË™§È∞≤ÈºáÂ±ãÊ≤ÉÁçÑÁéâÈà∫Ê∫´Áë•ÁòüÁ©©Á∏ïËòäÂÖÄÂ£ÖÊìÅÁìÆÁîïÁô∞ÁøÅÈÇïÈõçÈ•îÊ∏¶Áì¶Á™©Á™™Ëá•ËõôËù∏Ë®õÂ©âÂÆåÂÆõÊ¢°Ê§ÄÊµ£Áé©ÁêìÁê¨Á¢óÁ∑©Áø´ËÑòËÖïËéûË±åÈòÆÈ†ëÊõ∞ÂæÄÊó∫ÊûâÊ±™ÁéãÂÄ≠Â®ÉÊ≠™ÁüÆÂ§ñÂµ¨Â∑çÁå•ÁïèÔ¶∫Ô¶ªÂÉ•ÂáπÂ†ØÂ§≠Â¶ñÂßöÂØ•Ô¶ºÔ¶ΩÂ∂¢ÊãóÊêñÊíìÊìæÔ¶æÊõúÔ¶øÊ©àÔßÄÁáøÁë§ÔßÅ"],["e9a1","Á™àÁ™ØÁπáÁπûËÄÄËÖ∞ÔßÇËüØË¶ÅË¨†ÈÅôÔßÉÈÇÄÈ•íÊÖæÊ¨≤Êµ¥Á∏üË§•Ëæ±‰øëÂÇ≠ÂÜóÂãáÂüáÂ¢âÂÆπÂ∫∏ÊÖÇÊ¶ïÊ∂åÊπßÊ∫∂ÁÜîÁë¢Áî®Áî¨ËÅ≥Ëå∏ËìâË∏äÈéîÈèûÔßÑ‰∫é‰ΩëÂÅ∂ÂÑ™ÂèàÂèãÂè≥ÂÆáÂØìÂ∞§ÊÑöÊÜÇÊó¥ÁâõÁéóÁëÄÁõÇÁ•êÁ¶ëÁ¶πÁ¥ÜÁæΩËäãËóïËôûËøÇÈÅáÈÉµÈá™ÈöÖÈõ®Èõ©ÂãñÂΩßÊó≠Êò±Ê†ØÁÖúÁ®∂ÈÉÅÈ†ä‰∫ëÔßÖÊ©íÊÆûÊæêÁÜâËÄòËä∏Ëïì"],["eaa1","ÈÅãÈöïÈõ≤ÈüªËîöÈ¨±‰∫êÁÜäÈõÑÂÖÉÂéüÂì°ÂúìÂúíÂû£Â™õÂ´ÑÂØÉÊÄ®ÊÑøÊè¥Ê≤ÖÊ¥πÊπ≤Ê∫êÁà∞ÁåøÁëóËãëË¢ÅËΩÖÈÅ†ÔßÜÈô¢È°òÈ¥õÊúàË∂äÈâû‰ΩçÂÅâÂÉûÂç±ÂúçÂßîÂ®ÅÂ∞âÊÖ∞ÊöêÊ∏≠Áà≤ÁëãÁ∑ØËÉÉËêéËë¶ËîøËùüË°õË§òË¨ÇÈÅïÈüãÈ≠è‰π≥‰æëÂÑíÂÖ™ÔßáÂîØÂñ©Â≠∫ÂÆ•ÂπºÂπΩÂ∫æÊÇ†ÊÉüÊÑàÊÑâÊèÑÊî∏ÊúâÔßàÊüîÊüöÔßâÊ•°Ê•¢Ê≤πÊ¥ßÔßäÊ∏∏Ôßã"],["eba1","Êø°Áå∂Áå∑ÔßåÁëúÁî±ÔßçÁôíÔßéÔßèÁ∂≠ËáæËê∏Ë£ïË™òË´õË´≠Ë∏∞ËπÇÈÅäÈÄæÈÅ∫ÈÖâÈáâÈçÆÔßêÔßëÂ†âÔßíÊØìËÇâËÇ≤ÔßìÔßîÂÖÅÂ•´Â∞πÔßïÔßñÊΩ§ÁéßËÉ§Ë¥áÔßóÈàóÈñèÔßòÔßôÔßöÔßõËÅøÊàéÁÄúÁµ®ËûçÔßúÂû†ÊÅ©ÊÖáÊÆ∑Ë™æÈäÄÈö±‰πôÂêüÊ∑´Ëî≠Èô∞Èü≥È£ÆÊèñÊ≥£ÈÇëÂáùÊáâËÜ∫È∑π‰æùÂÄöÂÑÄÂÆúÊÑèÊáøÊì¨Ê§ÖÊØÖÁñëÁü£Áæ©Ëâ§ËñèËüªË°£Ë™º"],["eca1","Ë≠∞ÈÜ´‰∫å‰ª•‰ºäÔßùÔßûÂ§∑Âß®ÔßüÂ∑≤ÂºõÂΩõÊÄ°Ôß†Ôß°Ôß¢Ôß£ÁàæÁè•Ôß§Áï∞ÁóçÔß•ÁßªÔß¶ËÄåËÄ≥ËÇÑËã°ËçëÔßßÔß®Ë≤ΩË≤≥ÈÇáÔß©Ôß™È£¥È§åÔß´Ôß¨ÁÄ∑ÁõäÁøäÁøåÁøºË¨ö‰∫∫‰ªÅÂàÉÂç∞Ôß≠ÂíΩÂõ†ÂßªÂØÖÂºïÂøçÊπÆÔßÆÔßØÁµ™ËåµÔß∞ËöìË™çÔß±Èù≠Èù∑Ôß≤Ôß≥‰∏Ä‰Ωö‰ΩæÂ£πÊó•Ê∫¢ÈÄ∏Èé∞È¶π‰ªªÂ£¨Â¶äÂßôÊÅÅÔß¥ÔßµÁ®îÔß∂ËçèË≥ÉÂÖ•ÂçÑ"],["eda1","Ôß∑Ôß∏Ôßπ‰ªçÂâ©Â≠ïËäø‰ªîÂà∫Âí®ÂßâÂßøÂ≠êÂ≠óÂ≠úÊÅ£ÊÖàÊªãÁÇôÁÖÆÁéÜÁì∑ÁñµÁ£ÅÁ¥´ËÄÖËá™Ëå®ËîóËóâË´ÆË≥áÈõå‰ΩúÂã∫ÂöºÊñ´Êò®ÁÅºÁÇ∏ÁàµÁ∂ΩËäçÈÖåÈõÄÈµ≤Â≠±Ê£ßÊÆòÊΩ∫ÁõûÂ≤ëÊö´ÊΩõÁÆ¥Á∞™Ë†∂Èõú‰∏à‰ªóÂå†Â†¥Â¢ªÂ£ØÂ•¨Â∞áÂ∏≥Â∫ÑÂºµÊéåÊö≤ÊùñÊ®üÊ™£Ê¨åÊºøÁâÜÔß∫ÁçêÁíãÁ´†Á≤ßËÖ∏ËáüËáßËéäËë¨Ëî£ËñîËóèË£ùË¥ìÈÜ¨Èï∑"],["eea1","ÈöúÂÜçÂìâÂú®ÂÆ∞ÊâçÊùêÊ†ΩÊ¢ìÊ∏ΩÊªìÁÅΩÁ∏°Ë£ÅË≤°ËºâÈΩãÈΩéÁà≠ÁÆèË´çÈåö‰Ωá‰ΩéÂÑ≤ÂíÄÂßêÂ∫ïÊäµÊùµÊ•ÆÊ®óÊ≤ÆÊ∏öÁãôÁå™ÁñΩÁÆ∏Á¥µËãßËèπËëóËó∑Ë©õË≤ØË∫áÈÄôÈÇ∏ÈõéÈΩüÂã£ÂêäÂ´°ÂØÇÊëòÊïµÊª¥ÁãÑÔßªÁöÑÁ©çÁ¨õÁ±çÁ∏æÁøüËçªË¨´Ë≥äËµ§Ë∑°ËπüËø™ËøπÈÅ©Èèë‰ΩÉ‰Ω∫ÂÇ≥ÂÖ®ÂÖ∏ÂâçÂâ™Â°°Â°ºÂ•†Â∞àÂ±ïÂªõÊÇõÊà∞Ê†ìÊÆøÊ∞àÊæ±"],["efa1","ÁÖéÁê†Áî∞Áî∏ÁïëÁô≤Á≠åÁÆãÁÆ≠ÁØÜÁ∫èË©ÆËºæËΩâÈàøÈäìÈå¢Èê´ÈõªÈ°öÈ°´È§ûÂàáÊà™ÊäòÊµôÁô§Á´äÁØÄÁµ∂Âç†Â≤æÂ∫óÊº∏ÁÇπÁ≤òÈúëÈÆéÈªûÊé•Êë∫Ëù∂‰∏Å‰∫ï‰∫≠ÂÅúÂÅµÂëàÂßÉÂÆöÂπÄÂ∫≠Âª∑ÂæÅÊÉÖÊå∫ÊîøÊï¥ÊóåÊô∂Êô∏ÊüæÊ•®Ê™âÊ≠£Ê±ÄÊ∑ÄÊ∑®Ê∏üÊπûÁÄûÁÇ°ÁééÁèΩÁî∫ÁùõÁ¢áÁ¶éÁ®ãÁ©ΩÁ≤æÁ∂éËâáË®ÇË´™Ë≤ûÈÑ≠ÈÖäÈáòÈâ¶ÈãåÈå†ÈúÜÈùñ"],["f0a1","ÈùúÈ†ÇÈºéÂà∂ÂäëÂïºÂ†§Â∏ùÂºüÊÇåÊèêÊ¢ØÊøüÁ•≠Á¨¨ËáçËñ∫Ë£ΩË´∏ËπÑÈÜçÈô§ÈöõÈúΩÈ°åÈΩä‰øéÂÖÜÂáãÂä©Âò≤ÂºîÂΩ´Êé™ÊìçÊó©ÊôÅÊõ∫ÊõπÊúùÊ¢ùÊ£óÊßΩÊºïÊΩÆÁÖßÁá•Áà™Áí™Áú∫Á•ñÁ•öÁßüÁ®†Á™ïÁ≤óÁ≥üÁµÑÁπ∞ËÇáËóªËö§Ë©îË™øË∂ôË∫ÅÈÄ†ÈÅ≠Èá£ÈòªÈõïÈ≥•ÊóèÁ∞áË∂≥ÈèÉÂ≠òÂ∞äÂçíÊãôÁåùÂÄßÂÆóÂæûÊÇ∞ÊÖ´Ê£ïÊ∑ôÁêÆÁ®ÆÁµÇÁ∂úÁ∏±ËÖ´"],["f1a1","Ë∏™Ë∏µÈçæÈêò‰ΩêÂùêÂ∑¶Â∫ßÊå´ÁΩ™‰∏ª‰Ωè‰æèÂÅöÂßùËÉÑÂë™Âë®ÂóæÂ•èÂÆôÂ∑ûÂªöÊôùÊú±Êü±Ê†™Ê≥®Ê¥≤ÊπäÊæçÁÇ∑Áè†ÁñáÁ±åÁ¥ÇÁ¥¨Á∂¢ËàüËõõË®ªË™ÖËµ∞Ë∫äËº≥ÈÄ±ÈÖéÈÖíÈëÑÈßêÁ´πÁ≤•‰øäÂÑÅÂáÜÂüàÂØØÂ≥ªÊôôÊ®ΩÊµöÊ∫ñÊø¨ÁÑåÁïØÁ´£Ë†¢ÈÄ°ÈÅµÈõãÈßøËåÅ‰∏≠‰ª≤Ë°ÜÈáçÂçΩÊ´õÊ•´Ê±ÅËë∫Â¢ûÊÜéÊõæÊãØÁÉùÁîëÁóáÁπíËí∏Ë≠âË¥à‰πãÂè™"],["f2a1","Âí´Âú∞ÂùÄÂøóÊåÅÊåáÊëØÊîØÊó®Êô∫ÊûùÊû≥Ê≠¢Ê±†Ê≤öÊº¨Áü•Á†•Á•âÁ•óÁ¥ôËÇ¢ËÑÇËá≥ËäùËä∑ËúòË™åÔßºË¥ÑË∂æÈÅ≤Áõ¥Á®ôÁ®∑ÁπîËÅ∑ÂîáÂóîÂ°µÊåØÊê¢ÊôâÊôãÊ°≠Ê¶õÊÆÑÊ¥•Ê∫±ÁèçÁë®Áí°ÁïõÁñπÁõ°ÁúûÁûãÁß¶Á∏âÁ∏ùËáªËîØË¢óË®∫Ë≥ëËª´Ëæ∞ÈÄ≤Èé≠Èô£Èô≥Èúá‰æÑÂè±Âß™Â´âÂ∏ôÊ°éÁìÜÁñæÁß©Á™íËÜ£Ëõ≠Ë≥™Ë∑åËø≠ÊñüÊúïÔßΩÂü∑ÊΩóÁ∑ùËºØ"],["f3a1","Èè∂ÈõÜÂæµÊá≤ÊæÑ‰∏î‰æòÂÄüÂèâÂóüÂµØÂ∑ÆÊ¨°Ê≠§Á£ãÁÆöÔßæËπâËªäÈÅÆÊçâÊêæÁùÄÁ™ÑÈåØÈëøÈΩ™Êí∞ÊæØÁá¶Áí®ÁìöÁ´ÑÁ∞íÁ∫ÇÁ≤≤Á∫òËÆöË¥äÈëΩÈ§êÈ•åÂàπÂØüÊì¶Êú≠Á¥ÆÂÉ≠ÂèÉÂ°πÊÖòÊÖôÊá∫Êñ¨Á´ôËÆíËÆñÂÄâÂÄ°ÂâµÂî±Â®ºÂª†ÂΩ∞ÊÑ¥ÊïûÊòåÊò∂Êö¢ÊßçÊªÑÊº≤ÁåñÁò°Á™ìËÑπËâôËèñËíºÂÇµÂü∞ÂØÄÂØ®ÂΩ©Êé°Á†¶Á∂µËèúËî°ÈááÈáµÂÜäÊüµÁ≠ñ"],["f4a1","Ë≤¨ÂáÑÂ¶ªÊÇΩËôïÂÄúÔßøÂâîÂ∞∫ÊÖΩÊàöÊãìÊì≤Êñ•ÊªåÁò†ËÑäËπ†ÈôüÈöª‰ªüÂçÉÂñòÂ§©Â∑ùÊìÖÊ≥âÊ∑∫ÁéîÁ©øËàõËñ¶Ë≥§Ë∏êÈÅ∑ÈáßÈó°Èò°ÈüÜÂá∏Âì≤ÂñÜÂæπÊí§ÊæàÁ∂¥ËºüËΩçÈêµÂÉâÂ∞ñÊ≤æÊ∑ªÁîõÁûªÁ∞ΩÁ±§Ë©πË´ÇÂ†ûÂ¶æÂ∏ñÊç∑ÁâíÁñäÁù´Ë´úË≤ºËºíÂª≥Êô¥Ê∑∏ËÅΩËèÅË´ãÈùëÈØñÔ®ÄÂâÉÊõøÊ∂ïÊªØÁ∑†Ë´¶ÈÄÆÈÅûÈ´îÂàùÂâøÂì®ÊÜîÊäÑÊãõÊ¢¢"],["f5a1","Ê§íÊ•öÊ®µÁÇíÁÑ¶Á°ùÁ§ÅÁ§éÁßíÁ®çËÇñËâ∏ËãïËçâËïâË≤ÇË∂ÖÈÖ¢ÈÜãÈÜÆ‰øÉÂõëÁá≠ÁüóËúÄËß∏ÂØ∏ÂøñÊùëÈÇ®Âè¢Â°öÂØµÊÇ§ÊÜÅÊë†Á∏ΩËÅ∞Ëî•ÈäÉÊíÆÂÇ¨Â¥îÊúÄÂ¢úÊäΩÊé®Ê§éÊ•∏Ê®ûÊπ´Áö∫ÁßãËäªËê©Ë´èË∂®ËøΩÈÑíÈÖãÈÜúÈåêÈåòÈéöÈõõÈ®∂È∞ç‰∏ëÁïúÁ•ùÁ´∫Á≠ëÁØâÁ∏ÆËìÑËπôËπ¥Ëª∏ÈÄêÊò•Ê§øÁëÉÂá∫ÊúÆÈªúÂÖÖÂø†Ê≤ñËü≤Ë°ùË°∑ÊÇ¥ËÜµËêÉ"],["f6a1","Ë¥ÖÂèñÂêπÂò¥Â®∂Â∞±ÁÇäÁø†ËÅöËÑÜËá≠Ë∂£ÈÜâÈ©üÈ∑≤ÂÅ¥‰ªÑÂé†ÊÉªÊ∏¨Â±§‰æàÂÄ§Âó§Â≥ôÂπüÊÅ•Ê¢îÊ≤ªÊ∑ÑÁÜæÁóîÁó¥Áô°Á®öÁ©âÁ∑áÁ∑ªÁΩÆËá¥Ëö©ËºúÈõâÈ¶≥ÈΩíÂâáÂãÖÈ£≠Ë¶™‰∏ÉÊüíÊºÜ‰æµÂØ¢ÊûïÊ≤àÊµ∏ÁêõÁ†ßÈáùÈçºËüÑÁß§Á®±Âø´‰ªñÂí§ÂîæÂ¢ÆÂ¶•ÊÉ∞ÊâìÊãñÊú∂Ê•ïËàµÈôÄÈ¶±ÈßùÂÄ¨ÂçìÂïÑÂùºÔ®ÅÊâòÔ®ÇÊì¢Êô´ÊüùÊøÅÊøØÁê¢Áê∏Ë®ó"],["f7a1","Èê∏ÂëëÂòÜÂù¶ÂΩàÊÜöÊ≠éÁÅòÁÇ≠Á∂ªË™ïÂ•™ËÑ´Êé¢ÁúàËÄΩË≤™Â°îÊê≠Ê¶ªÂÆïÂ∏ëÊπØÔ®ÉËï©ÂÖåÂè∞Â§™ÊÄ†ÊÖãÊÆÜÊ±∞Ê≥∞Á¨ûËÉéËãîË∑ÜÈÇ∞È¢±Ô®ÑÊìáÊæ§ÊíëÊîÑÂÖéÂêêÂúüË®éÊÖüÊ°∂Ô®ÖÁóõÁ≠íÁµ±ÈÄöÂ†ÜÊßåËÖøË§™ÈÄÄÈ†πÂÅ∏Â•óÂ¶¨ÊäïÈÄèÈ¨™ÊÖùÁâπÈóñÂù°Â©ÜÂ∑¥ÊääÊí≠Êì∫Êù∑Ê≥¢Ê¥æÁà¨Áê∂Á†¥ÁΩ∑Ëä≠Ë∑õÈ†óÂà§ÂùÇÊùøÁâàÁì£Ë≤©Ëæ¶Èàë"],["f8a1","Èò™ÂÖ´Âè≠Êçå‰Ω©ÂîÑÊÇñÊïóÊ≤õÊµøÁâåÁãΩÁ®óË¶áË≤ùÂΩ≠ÊæéÁÉπËÜ®ÊÑé‰æøÂÅèÊâÅÁâáÁØáÁ∑®Áø©ÈÅçÈû≠È®ôË≤∂Âù™Âπ≥Êû∞ËêçË©ïÂê†Â¨ñÂπ£Âª¢ÂºäÊñÉËÇ∫ËîΩÈñâÈôõ‰ΩàÂåÖÂåçÂåèÂíÜÂì∫ÂúÉÂ∏ÉÊÄñÊäõÊä±ÊçïÔ®ÜÊ≥°Êµ¶Áñ±Á†≤ËÉûËÑØËãûËë°Ëí≤Ë¢çË§íÈÄãÈã™È£ΩÈÆëÂπÖÊö¥ÊõùÁÄëÁàÜÔ®á‰øµÂâΩÂΩ™ÊÖìÊùìÊ®ôÊºÇÁì¢Á•®Ë°®Ë±πÈ£áÈ£ÑÈ©É"],["f9a1","ÂìÅÁ®üÊ•ìË´∑Ë±äÈ¢®È¶ÆÂΩºÊä´Áñ≤ÁöÆË¢´ÈÅøÈôÇÂåπÂººÂøÖÊ≥åÁèåÁï¢ÁñãÁ≠ÜËãæÈ¶ù‰πèÈÄº‰∏ã‰ΩïÂé¶Â§èÂªàÊò∞Ê≤≥ÁëïËç∑Ëù¶Ë≥ÄÈÅêÈúûÈ∞ïÂ£ëÂ≠∏ËôêË¨îÈ∂¥ÂØíÊÅ®ÊÇçÊó±Ê±óÊº¢Êæ£ÁÄöÁΩïÁø∞ÈñëÈñíÈôêÈüìÂâ≤ËΩÑÂáΩÂê´Âí∏Âï£ÂñäÊ™ªÊ∂µÁ∑òËâ¶ÈäúÈô∑ÈππÂêàÂìàÁõíËõ§Èñ§ÈóîÈôú‰∫¢‰ºâÂßÆÂ´¶Â∑∑ÊÅíÊäóÊù≠Ê°ÅÊ≤ÜÊ∏ØÁº∏ËÇõËà™"],["faa1","Ô®àÔ®âÈ†Ö‰∫•ÂÅïÂí≥ÂûìÂ•öÂ≠©ÂÆ≥ÊáàÊ•∑Êµ∑ÁÄ£ËüπËß£Ë©≤Ë´ßÈÇÇÈß≠È™∏ÂäæÊ†∏ÂÄñÂπ∏ÊùèËçáË°å‰∫´ÂêëÂöÆÁè¶ÈÑïÈüøÈ§âÈ•óÈ¶ôÂôìÂ¢üËôõË®±ÊÜ≤Ê´∂ÁçªËªíÊ≠áÈö™È©óÂ•ïÁàÄËµ´Èù©‰øîÂ≥¥Âº¶Êá∏ÊôõÊ≥´ÁÇ´ÁéÑÁéπÁèæÁú©ÁùçÁµÉÁµ¢Á∏£Ëà∑Ë°íÔ®äË≥¢ÈââÈ°ØÂ≠ëÁ©¥Ë°ÄÈ†ÅÂ´å‰ø†ÂçîÂ§æÂ≥ΩÊåæÊµπÁãπËÑÖËÑáËé¢ÈãèÈ†∞‰∫®ÂÖÑÂàëÂûã"],["fba1","ÂΩ¢Ê≥ÇÊªéÁÄÖÁÅêÁÇØÁÜíÁè©Áë©ËçäËû¢Ë°°ÈÄàÈÇ¢Èé£È¶®ÂÖÆÂΩóÊÉ†ÊÖßÊö≥ËïôËπäÈÜØÈûã‰πé‰∫íÂëºÂ£ïÂ£∫Â•ΩÂ≤µÂºßÊà∂ÊâàÊòäÊôßÊØ´Êµ©Ê∑èÊπñÊª∏ÊæîÊø†Êø©ÁÅùÁãêÁê•ÁëöÁì†ÁöìÁ•úÁ≥äÁ∏ûËÉ°Ëä¶Ëë´ËíøËôéËôüËù¥Ë≠∑Ë±™Èé¨È†ÄÈ°•ÊÉëÊàñÈÖ∑Â©öÊòèÊ∑∑Ê∏æÁêøÈ≠ÇÂøΩÊÉöÁ¨èÂìÑÂºòÊ±ûÊ≥ìÊ¥™ÁÉòÁ¥ÖËôπË®åÈ¥ªÂåñÂíåÂ¨ÖÊ®∫ÁÅ´Áïµ"],["fca1","Á¶çÁ¶æËä±ËèØË©±Ë≠ÅË≤®Èù¥Ô®ãÊì¥Êî´Á¢∫Á¢ªÁ©´‰∏∏ÂñöÂ•êÂÆ¶ÂπªÊÇ£ÊèõÊ≠°Êô•Ê°ìÊ∏ôÁÖ•Áí∞Á¥àÈÇÑÈ©©È∞•Ê¥ªÊªëÁåæË±ÅÈóäÂá∞ÂπåÂæ®ÊÅçÊÉ∂ÊÑ∞ÊÖåÊôÉÊôÑÊ¶•Ê≥ÅÊπüÊªâÊΩ¢ÁÖåÁíúÁöáÁØÅÁ∞ßËçíËùóÈÅëÈöçÈªÉÂåØÂõûÂªªÂæäÊÅ¢ÊÇîÊá∑Êô¶ÊúÉÊ™úÊ∑ÆÊæÆÁÅ∞Áç™Áπ™ËÜæËå¥ËõîË™®Ë≥ÑÂäÉÁç≤ÂÆñÊ©´ÈêÑÂìÆÂöÜÂ≠ùÊïàÊñÖÊõâÊ¢üÊ∂çÊ∑Ü"],["fda1","ÁàªËÇ¥ÈÖµÈ©ç‰æØÂÄôÂéöÂêéÂêºÂñâÂóÖÂ∏øÂæåÊúΩÁÖ¶ÁèùÈÄÖÂãõÂã≥Â°§Â£éÁÑÑÁÜèÁáªËñ∞Ë®ìÊöàËñ®ÂñßÊöÑÁÖäËê±ÂçâÂñôÊØÅÂΩôÂæΩÊèÆÊöâÁÖáË´±ËºùÈ∫æ‰ºëÊê∫ÁÉãÁï¶ËôßÊÅ§Ë≠éÈ∑∏ÂÖáÂá∂ÂåàÊ¥∂ËÉ∏ÈªëÊòïÊ¨£ÁÇòÁóïÂêÉÂ±πÁ¥áË®ñÊ¨†Ê¨ΩÊ≠ÜÂê∏ÊÅ∞Ê¥ΩÁøïËààÂÉñÂáûÂñúÂô´ÂõçÂß¨Â¨âÂ∏åÊÜôÊÜòÊà±ÊôûÊõ¶ÁÜôÁÜπÁÜ∫ÁäßÁ¶ßÁ®ÄÁæ≤Ë©∞"]]');

/***/ }),

/***/ 8115:
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('[["0","\\u0000",127],["a140","„ÄÄÔºå„ÄÅ„ÄÇÔºé‚ÄßÔºõÔºöÔºüÔºÅÔ∏∞‚Ä¶‚Ä•ÔπêÔπëÔπí¬∑ÔπîÔπïÔπñÔπóÔΩú‚ÄìÔ∏±‚ÄîÔ∏≥‚ï¥Ô∏¥ÔπèÔºàÔºâÔ∏µÔ∏∂ÔΩõÔΩùÔ∏∑Ô∏∏„Äî„ÄïÔ∏πÔ∏∫„Äê„ÄëÔ∏ªÔ∏º„Ää„ÄãÔ∏ΩÔ∏æ„Äà„ÄâÔ∏øÔπÄ„Äå„ÄçÔπÅÔπÇ„Äé„ÄèÔπÉÔπÑÔπôÔπö"],["a1a1","ÔπõÔπúÔπùÔπû‚Äò‚Äô‚Äú‚Äù„Äù„Äû‚Äµ‚Ä≤ÔºÉÔºÜÔºä‚Äª¬ß„ÄÉ‚óã‚óè‚ñ≥‚ñ≤‚óé‚òÜ‚òÖ‚óá‚óÜ‚ñ°‚ñ†‚ñΩ‚ñº„ä£‚ÑÖ¬ØÔø£ÔºøÀçÔπâÔπäÔπçÔπéÔπãÔπåÔπüÔπ†Ôπ°ÔºãÔºç√ó√∑¬±‚àöÔºúÔºûÔºù‚â¶‚âß‚â†‚àû‚âí‚â°Ôπ¢",4,"ÔΩû‚à©‚à™‚ä•‚à†‚àü‚äø„èí„èë‚à´‚àÆ‚àµ‚à¥‚ôÄ‚ôÇ‚äï‚äô‚Üë‚Üì‚Üê‚Üí‚Üñ‚Üó‚Üô‚Üò‚à•‚à£Ôºè"],["a240","Ôºº‚àïÔπ®ÔºÑÔø•„ÄíÔø†Ôø°ÔºÖÔº†‚ÑÉ‚ÑâÔπ©Ôπ™Ôπ´„èï„éú„éù„éû„èé„é°„éé„éè„èÑ¬∞ÂÖôÂÖõÂÖûÂÖùÂÖ°ÂÖ£ÂóßÁì©Á≥é‚ñÅ",7,"‚ñè‚ñé‚ñç‚ñå‚ñã‚ñä‚ñâ‚îº‚î¥‚î¨‚î§‚îú‚ñî‚îÄ‚îÇ‚ñï‚îå‚îê‚îî‚îò‚ï≠"],["a2a1","‚ïÆ‚ï∞‚ïØ‚ïê‚ïû‚ï™‚ï°‚ó¢‚ó£‚ó•‚ó§‚ï±‚ï≤‚ï≥Ôºê",9,"‚Ö†",9,"„Ä°",8,"ÂçÅÂçÑÂçÖÔº°",25,"ÔΩÅ",21],["a340","ÔΩóÔΩòÔΩôÔΩöŒë",16,"Œ£",6,"Œ±",16,"œÉ",6,"„ÑÖ",10],["a3a1","„Ñê",25,"ÀôÀâÀäÀáÀã"],["a3e1","‚Ç¨"],["a440","‰∏Ä‰πô‰∏Å‰∏É‰πÉ‰πù‰∫Ü‰∫å‰∫∫ÂÑøÂÖ•ÂÖ´Âá†ÂàÄÂàÅÂäõÂåïÂçÅÂçúÂèà‰∏â‰∏ã‰∏à‰∏ä‰∏´‰∏∏Âá°‰πÖ‰πà‰πü‰πû‰∫é‰∫°ÂÖÄÂàÉÂã∫ÂçÉÂèâÂè£ÂúüÂ£´Â§ïÂ§ßÂ•≥Â≠êÂ≠ëÂ≠ìÂØ∏Â∞èÂ∞¢Â∞∏Â±±Â∑ùÂ∑•Â∑±Â∑≤Â∑≥Â∑æÂπ≤ÂªæÂºãÂºìÊâç"],["a4a1","‰∏ë‰∏ê‰∏ç‰∏≠‰∏∞‰∏π‰πãÂ∞π‰∫à‰∫ë‰∫ï‰∫í‰∫î‰∫¢‰ªÅ‰ªÄ‰ªÉ‰ªÜ‰ªá‰ªç‰ªä‰ªã‰ªÑÂÖÉÂÖÅÂÖßÂÖ≠ÂÖÆÂÖ¨ÂÜóÂá∂ÂàÜÂàáÂààÂãªÂãæÂãøÂåñÂåπÂçàÂçáÂçÖÂçûÂéÑÂèãÂèäÂèçÂ£¨Â§©Â§´Â§™Â§≠Â≠îÂ∞ëÂ∞§Â∞∫Â±ØÂ∑¥ÂπªÂªøÂºîÂºïÂøÉÊààÊà∂ÊâãÊâéÊîØÊñáÊñóÊñ§ÊñπÊó•Êõ∞ÊúàÊú®Ê¨†Ê≠¢Ê≠πÊØãÊØîÊØõÊ∞èÊ∞¥ÁÅ´Áà™Áà∂ÁàªÁâáÁâôÁâõÁä¨Áéã‰∏ô"],["a540","‰∏ñ‰∏ï‰∏î‰∏ò‰∏ª‰πç‰πè‰πé‰ª•‰ªò‰ªî‰ªï‰ªñ‰ªó‰ª£‰ª§‰ªô‰ªûÂÖÖÂÖÑÂÜâÂÜäÂÜ¨ÂáπÂá∫Âá∏ÂàäÂä†ÂäüÂåÖÂåÜÂåóÂåù‰ªüÂçäÂçâÂç°Âç†ÂçØÂçÆÂéªÂèØÂè§Âè≥Âè¨ÂèÆÂè©Âè®ÂèºÂè∏ÂèµÂè´Âè¶Âè™Âè≤Âè±Âè∞Âè•Âè≠ÂèªÂõõÂõöÂ§ñ"],["a5a1","Â§ÆÂ§±Â•¥Â•∂Â≠ïÂÆÉÂ∞ºÂ∑®Â∑ßÂ∑¶Â∏ÇÂ∏ÉÂπ≥ÂπºÂºÅÂºòÂºóÂøÖÊàäÊâìÊâîÊâíÊâëÊñ•Êó¶ÊúÆÊú¨Êú™Êú´Êú≠Ê≠£ÊØçÊ∞ëÊ∞êÊ∞∏Ê±ÅÊ±ÄÊ∞æÁäØÁéÑÁéâÁìúÁì¶ÁîòÁîüÁî®Áî©Áî∞Áî±Áî≤Áî≥ÁñãÁôΩÁöÆÁöøÁõÆÁüõÁü¢Áü≥Á§∫Á¶æÁ©¥Á´ã‰∏û‰∏ü‰πí‰πì‰π©‰∫ô‰∫§‰∫¶‰∫•‰ªø‰ºâ‰ºô‰ºä‰ºï‰ºç‰ºê‰ºë‰ºè‰ª≤‰ª∂‰ªª‰ª∞‰ª≥‰ªΩ‰ºÅ‰ºãÂÖâÂÖáÂÖÜÂÖàÂÖ®"],["a640","ÂÖ±ÂÜçÂÜ∞ÂàóÂàëÂàíÂàéÂàñÂä£ÂåàÂå°Âå†Âç∞Âç±ÂêâÂêèÂêåÂêäÂêêÂêÅÂêãÂêÑÂêëÂêçÂêàÂêÉÂêéÂêÜÂêíÂõ†ÂõûÂõùÂú≥Âú∞Âú®Âú≠Âú¨ÂúØÂú©Â§ôÂ§öÂ§∑Â§∏Â¶ÑÂ•∏Â¶ÉÂ•ΩÂ•πÂ¶ÇÂ¶ÅÂ≠óÂ≠òÂÆáÂÆàÂÆÖÂÆâÂØ∫Â∞ñÂ±πÂ∑ûÂ∏ÜÂπ∂Âπ¥"],["a6a1","ÂºèÂºõÂøôÂøñÊàéÊàåÊàçÊàêÊâ£ÊâõÊâòÊî∂Êó©Êó®Êó¨Êó≠Êõ≤Êõ≥ÊúâÊúΩÊú¥Êú±ÊúµÊ¨°Ê≠§Ê≠ªÊ∞ñÊ±ùÊ±óÊ±ôÊ±üÊ±†Ê±êÊ±ïÊ±°Ê±õÊ±çÊ±éÁÅ∞ÁâüÁâùÁôæÁ´πÁ±≥Á≥∏Áº∂ÁæäÁæΩËÄÅËÄÉËÄåËÄíËÄ≥ËÅøËÇâËÇãËÇåËá£Ëá™Ëá≥ËáºËàåËàõËàüËâÆËâ≤ËâæËô´Ë°ÄË°åË°£Ë•øÈò°‰∏≤‰∫®‰Ωç‰Ωè‰Ωá‰Ωó‰Ωû‰º¥‰Ωõ‰Ωï‰º∞‰Ωê‰Ωë‰ºΩ‰º∫‰º∏‰ΩÉ‰Ωî‰ºº‰ΩÜ‰Ω£"],["a740","‰Ωú‰Ω†‰ºØ‰Ωé‰º∂‰Ωô‰Ωù‰Ωà‰ΩöÂÖåÂÖãÂÖçÂÖµÂÜ∂ÂÜ∑Âà•Âà§Âà©Âà™Âà®Âä´Âä©Âä™Âä¨Âå£Âç≥ÂçµÂêùÂê≠ÂêûÂêæÂê¶ÂëéÂêßÂëÜÂëÉÂê≥ÂëàÂëÇÂêõÂê©ÂëäÂêπÂêªÂê∏ÂêÆÂêµÂê∂Âê†ÂêºÂëÄÂê±Âê´ÂêüÂê¨Âõ™Âõ∞Âõ§Âõ´ÂùäÂùëÂùÄÂùç"],["a7a1","ÂùáÂùéÂúæÂùêÂùèÂúªÂ£ØÂ§æÂ¶ùÂ¶íÂ¶®Â¶ûÂ¶£Â¶ôÂ¶ñÂ¶çÂ¶§Â¶ìÂ¶äÂ¶•Â≠ùÂ≠úÂ≠öÂ≠õÂÆåÂÆãÂÆèÂ∞¨Â±ÄÂ±ÅÂ∞øÂ∞æÂ≤êÂ≤ëÂ≤îÂ≤åÂ∑´Â∏åÂ∫èÂ∫áÂ∫äÂª∑ÂºÑÂºüÂΩ§ÂΩ¢ÂΩ∑ÂΩπÂøòÂøåÂøóÂøçÂø±Âø´Âø∏Âø™ÊàíÊàëÊäÑÊäóÊäñÊäÄÊâ∂ÊäâÊâ≠ÊääÊâºÊâæÊâπÊâ≥ÊäíÊâØÊäòÊâÆÊäïÊäìÊäëÊäÜÊîπÊîªÊî∏Êó±Êõ¥ÊùüÊùéÊùèÊùêÊùëÊùúÊùñÊùûÊùâÊùÜÊù†"],["a840","ÊùìÊùóÊ≠•ÊØèÊ±ÇÊ±ûÊ≤ôÊ≤ÅÊ≤àÊ≤âÊ≤ÖÊ≤õÊ±™Ê±∫Ê≤êÊ±∞Ê≤åÊ±®Ê≤ñÊ≤íÊ±ΩÊ≤ÉÊ±≤Ê±æÊ±¥Ê≤ÜÊ±∂Ê≤çÊ≤îÊ≤òÊ≤ÇÁÅ∂ÁÅºÁÅΩÁÅ∏Áâ¢Áâ°Áâ†ÁãÑÁãÇÁéñÁî¨Áî´Áî∑Áî∏ÁöÇÁõØÁü£ÁßÅÁßÄÁ¶øÁ©∂Á≥ªÁΩïËÇñËÇìËÇùËÇòËÇõËÇöËÇ≤ËâØËäí"],["a8a1","ËäãËäçË¶ãËßíË®ÄË∞∑Ë±ÜË±ïË≤ùËµ§Ëµ∞Ë∂≥Ë∫´ËªäËæõËæ∞ËøÇËøÜËøÖËøÑÂ∑°ÈÇëÈÇ¢ÈÇ™ÈÇ¶ÈÇ£ÈÖâÈáÜÈáåÈò≤ÈòÆÈò±Èò™Èò¨‰∏¶‰πñ‰π≥‰∫ã‰∫õ‰∫û‰∫´‰∫¨‰ΩØ‰æù‰æç‰Ω≥‰Ωø‰Ω¨‰æõ‰æã‰æÜ‰æÉ‰Ω∞‰Ωµ‰æà‰Ω©‰Ωª‰æñ‰Ωæ‰æè‰æë‰Ω∫ÂÖîÂÖíÂÖïÂÖ©ÂÖ∑ÂÖ∂ÂÖ∏ÂÜΩÂáΩÂàªÂà∏Âà∑Âà∫Âà∞ÂàÆÂà∂ÂâÅÂäæÂäªÂçíÂçîÂçìÂçëÂç¶Âç∑Âç∏ÂçπÂèñÂèîÂèóÂë≥Âëµ"],["a940","ÂíñÂë∏ÂíïÂíÄÂëªÂë∑ÂíÑÂííÂíÜÂëºÂíêÂë±Âë∂ÂíåÂíöÂë¢Âë®ÂíãÂëΩÂíéÂõ∫ÂûÉÂù∑Âù™Âù©Âù°Âù¶Âù§ÂùºÂ§úÂ•âÂ•áÂ•àÂ•ÑÂ•îÂ¶æÂ¶ªÂßîÂ¶πÂ¶ÆÂßëÂßÜÂßêÂßçÂßãÂßìÂßäÂ¶ØÂ¶≥ÂßíÂßÖÂ≠üÂ≠§Â≠£ÂÆóÂÆöÂÆòÂÆúÂÆôÂÆõÂ∞öÂ±àÂ±Ö"],["a9a1","Â±ÜÂ≤∑Â≤°Â≤∏Â≤©Â≤´Â≤±Â≤≥Â∏òÂ∏öÂ∏ñÂ∏ïÂ∏õÂ∏ëÂπ∏Â∫öÂ∫óÂ∫úÂ∫ïÂ∫ñÂª∂Âº¶ÂºßÂº©ÂæÄÂæÅÂΩøÂΩºÂøùÂø†ÂøΩÂøµÂøøÊÄèÊÄîÊÄØÊÄµÊÄñÊÄ™ÊÄïÊÄ°ÊÄßÊÄ©ÊÄ´ÊÄõÊàñÊàïÊàøÊàæÊâÄÊâøÊãâÊãåÊãÑÊäøÊãÇÊäπÊãíÊãõÊä´ÊãìÊãîÊããÊãàÊä®ÊäΩÊäºÊãêÊãôÊãáÊãçÊäµÊãöÊä±ÊãòÊãñÊãóÊãÜÊä¨ÊãéÊîæÊñßÊñºÊó∫ÊòîÊòìÊòåÊòÜÊòÇÊòéÊòÄÊòèÊòïÊòä"],["aa40","ÊòáÊúçÊúãÊù≠ÊûãÊûïÊù±ÊûúÊù≥Êù∑ÊûáÊûùÊûóÊùØÊù∞ÊùøÊûâÊùæÊûêÊùµÊûöÊûìÊùºÊù™Êù≤Ê¨£Ê≠¶Ê≠ßÊ≠øÊ∞ìÊ∞õÊ≥£Ê≥®Ê≥≥Ê≤±Ê≥åÊ≥•Ê≤≥Ê≤ΩÊ≤æÊ≤ºÊ≥¢Ê≤´Ê≥ïÊ≥ìÊ≤∏Ê≥ÑÊ≤πÊ≥ÅÊ≤ÆÊ≥óÊ≥ÖÊ≥±Ê≤øÊ≤ªÊ≥°Ê≥õÊ≥äÊ≤¨Ê≥ØÊ≥úÊ≥ñÊ≥†"],["aaa1","ÁÇïÁÇéÁÇíÁÇäÁÇôÁà¨Áà≠Áà∏ÁâàÁâßÁâ©ÁãÄÁãéÁãôÁãóÁãêÁé©Áé®ÁéüÁé´Áé•ÁîΩÁñùÁñôÁñöÁöÑÁõÇÁõ≤Áõ¥Áü•ÁüΩÁ§æÁ•ÄÁ•ÅÁßâÁßàÁ©∫Á©πÁ´∫Á≥æÁΩîÁæåÁæãËÄÖËÇ∫ËÇ•ËÇ¢ËÇ±ËÇ°ËÇ´ËÇ©ËÇ¥ËÇ™ËÇØËá•ËáæËàçËä≥ËäùËäôËä≠ËäΩËäüËäπËä±Ëä¨Ëä•ËäØËä∏Ëä£Ëä∞ËäæËä∑ËôéËô±ÂàùË°®ËªãËøéËøîËøëÈÇµÈÇ∏ÈÇ±ÈÇ∂ÈááÈáëÈï∑ÈñÄÈòúÈôÄÈòøÈòªÈôÑ"],["ab40","ÈôÇÈöπÈõ®ÈùíÈùû‰∫ü‰∫≠‰∫Æ‰ø°‰æµ‰æØ‰æø‰ø†‰øë‰øè‰øù‰øÉ‰æ∂‰øò‰øü‰øä‰øó‰æÆ‰øê‰øÑ‰øÇ‰øö‰øé‰øû‰æ∑ÂÖóÂÜíÂÜëÂÜ†ÂâéÂâÉÂâäÂâçÂâåÂâãÂâáÂãáÂãâÂãÉÂãÅÂåçÂçóÂçªÂéöÂèõÂí¨ÂìÄÂí®ÂìéÂìâÂí∏Âí¶Âí≥ÂìáÂìÇÂíΩÂí™ÂìÅ"],["aba1","ÂìÑÂìàÂíØÂí´Âí±ÂíªÂí©ÂíßÂíøÂõøÂûÇÂûãÂû†Âû£Âû¢ÂüéÂûÆÂûìÂ•ïÂ•ëÂ•èÂ•éÂ•êÂßúÂßòÂßøÂß£Âß®Â®ÉÂß•Âß™ÂßöÂß¶Â®ÅÂßªÂ≠©ÂÆ£ÂÆ¶ÂÆ§ÂÆ¢ÂÆ•Â∞ÅÂ±éÂ±èÂ±çÂ±ãÂ≥ôÂ≥íÂ∑∑Â∏ùÂ∏•Â∏üÂπΩÂ∫†Â∫¶Âª∫ÂºàÂº≠ÂΩ•ÂæàÂæÖÂæäÂæãÂæáÂæåÂæâÊÄíÊÄùÊÄ†ÊÄ•ÊÄéÊÄ®ÊÅçÊÅ∞ÊÅ®ÊÅ¢ÊÅÜÊÅÉÊÅ¨ÊÅ´ÊÅ™ÊÅ§ÊâÅÊãúÊåñÊåâÊãºÊã≠ÊåÅÊãÆÊãΩÊåáÊã±Êã∑"],["ac40","ÊãØÊã¨ÊãæÊã¥ÊåëÊåÇÊîøÊïÖÊñ´ÊñΩÊó¢Êò•Êò≠Êò†ÊòßÊòØÊòüÊò®Êò±Êò§Êõ∑ÊüøÊüìÊü±ÊüîÊüêÊü¨Êû∂ÊûØÊüµÊü©ÊüØÊüÑÊüëÊû¥ÊüöÊü•Êû∏ÊüèÊüûÊü≥Êû∞ÊüôÊü¢ÊüùÊüíÊ≠™ÊÆÉÊÆÜÊÆµÊØíÊØóÊ∞üÊ≥âÊ¥ãÊ¥≤Ê¥™ÊµÅÊ¥•Ê¥åÊ¥±Ê¥ûÊ¥ó"],["aca1","Ê¥ªÊ¥ΩÊ¥æÊ¥∂Ê¥õÊ≥µÊ¥πÊ¥ßÊ¥∏Ê¥©Ê¥ÆÊ¥µÊ¥éÊ¥´ÁÇ´ÁÇ∫ÁÇ≥ÁÇ¨ÁÇØÁÇ≠ÁÇ∏ÁÇÆÁÇ§Áà∞Áâ≤ÁâØÁâ¥Áã©Áã†Áã°Áé∑ÁèäÁéªÁé≤ÁèçÁèÄÁé≥ÁîöÁî≠ÁïèÁïåÁïéÁïãÁñ´Áñ§Áñ•Áñ¢Áñ£Áô∏ÁöÜÁöáÁöàÁõàÁõÜÁõÉÁõÖÁúÅÁõπÁõ∏ÁúâÁúãÁõæÁõºÁúáÁüúÁ†ÇÁ†îÁ†åÁ†çÁ•ÜÁ•âÁ•àÁ•áÁ¶πÁ¶∫ÁßëÁßíÁßãÁ©øÁ™ÅÁ´øÁ´ΩÁ±ΩÁ¥ÇÁ¥ÖÁ¥ÄÁ¥âÁ¥áÁ¥ÑÁ¥ÜÁº∏ÁæéÁæøËÄÑ"],["ad40","ËÄêËÄçËÄëËÄ∂ËÉñËÉ•ËÉöËÉÉËÉÑËÉåËÉ°ËÉõËÉéËÉûËÉ§ËÉùËá¥Ëà¢ËãßËåÉËåÖËã£ËãõËã¶ËåÑËã•ËåÇËåâËãíËãóËã±ËåÅËãúËãîËãëËãûËãìËãüËãØËåÜËôêËôπËôªËô∫Ë°çË°´Ë¶ÅËßîË®àË®ÇË®ÉË≤ûË≤†Ëµ¥Ëµ≥Ë∂¥ËªçËªåËø∞Ëø¶Ëø¢Ëø™Ëø•"],["ada1","Ëø≠Ëø´Ëø§Ëø®ÈÉäÈÉéÈÉÅÈÉÉÈÖãÈÖäÈáçÈñÇÈôêÈôãÈôåÈôçÈù¢Èù©ÈüãÈü≠Èü≥È†ÅÈ¢®È£õÈ£üÈ¶ñÈ¶ô‰πò‰∫≥ÂÄåÂÄçÂÄ£‰øØÂÄ¶ÂÄ•‰ø∏ÂÄ©ÂÄñÂÄÜÂÄºÂÄüÂÄöÂÄíÂÄë‰ø∫ÂÄÄÂÄîÂÄ®‰ø±ÂÄ°ÂÄãÂÄôÂÄò‰ø≥‰øÆÂÄ≠ÂÄ™‰øæÂÄ´ÂÄâÂÖºÂÜ§ÂÜ•ÂÜ¢ÂáçÂáåÂáÜÂáãÂâñÂâúÂâîÂâõÂâùÂå™ÂçøÂéüÂéùÂèüÂì®ÂîêÂîÅÂî∑ÂìºÂì•Âì≤ÂîÜÂì∫ÂîîÂì©Âì≠Âì°ÂîâÂìÆÂì™"],["ae40","Âì¶ÂîßÂîáÂìΩÂîèÂúÉÂúÑÂüÇÂüîÂüãÂüÉÂ†âÂ§èÂ•óÂ•òÂ•öÂ®ëÂ®òÂ®úÂ®üÂ®õÂ®ìÂß¨Â®†Â®£Â®©Â®•Â®åÂ®âÂ≠´Â±òÂÆ∞ÂÆ≥ÂÆ∂ÂÆ¥ÂÆÆÂÆµÂÆπÂÆ∏Â∞ÑÂ±ëÂ±ïÂ±êÂ≥≠Â≥ΩÂ≥ªÂ≥™Â≥®Â≥∞Â≥∂Â¥ÅÂ≥¥Â∑ÆÂ∏≠Â∏´Â∫´Â∫≠Â∫ßÂº±ÂæíÂæëÂæêÊÅô"],["aea1","ÊÅ£ÊÅ•ÊÅêÊÅïÊÅ≠ÊÅ©ÊÅØÊÇÑÊÇüÊÇöÊÇçÊÇîÊÇåÊÇÖÊÇñÊâáÊã≥ÊåàÊãøÊçéÊåæÊåØÊçïÊçÇÊçÜÊçèÊçâÊå∫ÊçêÊåΩÊå™Êå´Êå®ÊççÊçåÊïàÊïâÊñôÊóÅÊóÖÊôÇÊôâÊôèÊôÉÊôíÊôåÊôÖÊôÅÊõ∏ÊúîÊúïÊúóÊ†°Ê†∏Ê°àÊ°ÜÊ°ìÊ†πÊ°ÇÊ°îÊ†©Ê¢≥Ê†óÊ°åÊ°ëÊ†ΩÊü¥Ê°êÊ°ÄÊ†ºÊ°ÉÊ†™Ê°ÖÊ†ìÊ†òÊ°ÅÊÆäÊÆâÊÆ∑Ê∞£Ê∞ßÊ∞®Ê∞¶Ê∞§Ê≥∞Êµ™Ê∂ïÊ∂àÊ∂áÊµ¶Êµ∏Êµ∑ÊµôÊ∂ì"],["af40","Êµ¨Ê∂âÊµÆÊµöÊµ¥Êµ©Ê∂åÊ∂äÊµπÊ∂ÖÊµ•Ê∂îÁÉäÁÉòÁÉ§ÁÉôÁÉàÁÉèÁàπÁâπÁãºÁãπÁãΩÁã∏Áã∑ÁéÜÁè≠ÁêâÁèÆÁè†Áè™ÁèûÁïîÁïùÁïúÁïöÁïôÁñæÁóÖÁóáÁñ≤Áñ≥ÁñΩÁñºÁñπÁóÇÁñ∏ÁöãÁö∞ÁõäÁõçÁõéÁú©ÁúüÁú†Áú®Áü©Á†∞Á†ßÁ†∏Á†ùÁ†¥Á†∑"],["afa1","Á†•Á†≠Á††Á†üÁ†≤Á•ïÁ•êÁ•†Á•üÁ•ñÁ•ûÁ•ùÁ•óÁ•öÁß§Áß£ÁßßÁßüÁß¶Áß©ÁßòÁ™ÑÁ™àÁ´ôÁ¨ÜÁ¨ëÁ≤âÁ¥°Á¥óÁ¥ãÁ¥äÁ¥†Á¥¢Á¥îÁ¥êÁ¥ïÁ¥öÁ¥úÁ¥çÁ¥ôÁ¥õÁº∫ÁΩüÁæîÁøÖÁøÅËÄÜËÄòËÄïËÄôËÄóËÄΩËÄøËÉ±ËÑÇËÉ∞ËÑÖËÉ≠ËÉ¥ËÑÜËÉ∏ËÉ≥ËÑàËÉΩËÑäËÉºËÉØËá≠Ëá¨ËàÄËàêËà™Ëà´Ëà®Ëà¨ËäªËå´ËçíËçîËçäËå∏ËçêËçâËåµËå¥ËçèËå≤ËåπËå∂ËåóËçÄËå±Ëå®ËçÉ"],["b040","ËôîËöäËö™ËöìËö§Ëö©ËöåËö£ËöúË°∞Ë°∑Ë¢ÅË¢ÇË°ΩË°πË®òË®êË®éË®åË®ïË®äË®óË®ìË®ñË®èË®ëË±àË±∫Ë±πË≤°Ë≤¢Ëµ∑Ë∫¨ËªíËªîËªèËæ±ÈÄÅÈÄÜËø∑ÈÄÄËø∫Ëø¥ÈÄÉËøΩÈÄÖËø∏ÈÇïÈÉ°ÈÉùÈÉ¢ÈÖíÈÖçÈÖåÈáòÈáùÈáóÈáúÈáôÈñÉÈô¢Èô£Èô°"],["b0a1","ÈôõÈôùÈô§ÈôòÈôûÈöªÈ£¢È¶¨È™®È´òÈ¨•È¨≤È¨º‰πæÂÅ∫ÂÅΩÂÅúÂÅáÂÅÉÂÅåÂÅöÂÅâÂÅ•ÂÅ∂ÂÅéÂÅïÂÅµÂÅ¥ÂÅ∑ÂÅèÂÄèÂÅØÂÅ≠ÂÖúÂÜïÂá∞Ââ™ÂâØÂãíÂãôÂãòÂãïÂåêÂåèÂåôÂåøÂçÄÂåæÂèÉÊõºÂïÜÂï™Âï¶ÂïÑÂïûÂï°ÂïÉÂïäÂî±ÂïñÂïèÂïïÂîØÂï§Âî∏ÂîÆÂïúÂî¨Âï£Âî≥ÂïÅÂïóÂúàÂúãÂúâÂüüÂ†ÖÂ†äÂ†ÜÂü†Âü§Âü∫Â†ÇÂ†µÂü∑ÂüπÂ§†Â•¢Â®∂Â©ÅÂ©âÂ©¶Â©™Â©Ä"],["b140","Â®ºÂ©¢Â©öÂ©ÜÂ©äÂ≠∞ÂØáÂØÖÂØÑÂØÇÂÆøÂØÜÂ∞âÂ∞àÂ∞áÂ±†Â±úÂ±ùÂ¥áÂ¥ÜÂ¥éÂ¥õÂ¥ñÂ¥¢Â¥ëÂ¥©Â¥îÂ¥ôÂ¥§Â¥ßÂ¥óÂ∑¢Â∏∏Â∏∂Â∏≥Â∏∑Â∫∑Â∫∏Â∫∂Â∫µÂ∫æÂºµÂº∑ÂΩóÂΩ¨ÂΩ©ÂΩ´ÂæóÂæôÂæûÂæòÂæ°Âæ†ÂæúÊÅøÊÇ£ÊÇâÊÇ†ÊÇ®ÊÉãÊÇ¥ÊÉ¶ÊÇΩ"],["b1a1","ÊÉÖÊÇªÊÇµÊÉúÊÇºÊÉòÊÉïÊÉÜÊÉüÊÇ∏ÊÉöÊÉáÊàöÊàõÊâàÊé†ÊéßÊç≤ÊéñÊé¢Êé•Êç∑ÊçßÊéòÊé™Êç±Êé©ÊéâÊéÉÊéõÊç´Êé®ÊéÑÊéàÊéôÊé°Êé¨ÊéíÊéèÊéÄÊçªÊç©Êç®Êç∫ÊïùÊïñÊïëÊïôÊïóÂïüÊïèÊïòÊïïÊïîÊñúÊñõÊñ¨ÊóèÊóãÊóåÊóéÊôùÊôöÊô§Êô®Êô¶ÊôûÊõπÂãóÊúõÊ¢ÅÊ¢ØÊ¢¢Ê¢ìÊ¢µÊ°øÊ°∂Ê¢±Ê¢ßÊ¢óÊ¢∞Ê¢ÉÊ£ÑÊ¢≠Ê¢ÜÊ¢ÖÊ¢îÊ¢ùÊ¢®Ê¢üÊ¢°Ê¢ÇÊ¨≤ÊÆ∫"],["b240","ÊØ´ÊØ¨Ê∞´Ê∂éÊ∂ºÊ∑≥Ê∑ôÊ∂≤Ê∑°Ê∑åÊ∑§Ê∑ªÊ∑∫Ê∏ÖÊ∑áÊ∑ãÊ∂ØÊ∑ëÊ∂ÆÊ∑ûÊ∑πÊ∂∏Ê∑∑Ê∑µÊ∑ÖÊ∑íÊ∏öÊ∂µÊ∑öÊ∑´Ê∑òÊ∑™Ê∑±Ê∑ÆÊ∑®Ê∑ÜÊ∑ÑÊ∂™Ê∑¨Ê∂øÊ∑¶ÁÉπÁÑâÁÑäÁÉΩÁÉØÁàΩÁâΩÁäÅÁåúÁåõÁåñÁåìÁåôÁéáÁêÖÁêäÁêÉÁêÜÁèæÁêçÁì†Áì∂"],["b2a1","Áì∑ÁîúÁî¢Áï•Áï¶Áï¢Áï∞ÁñèÁóîÁóïÁñµÁóäÁóçÁöéÁõîÁõíÁõõÁú∑ÁúæÁúºÁú∂Áú∏Áú∫Á°´Á°ÉÁ°éÁ••Á•®Á•≠ÁßªÁ™íÁ™ïÁ¨†Á¨®Á¨õÁ¨¨Á¨¶Á¨ôÁ¨ûÁ¨ÆÁ≤íÁ≤óÁ≤ïÁµÜÁµÉÁµ±Á¥ÆÁ¥πÁ¥ºÁµÄÁ¥∞Á¥≥ÁµÑÁ¥ØÁµÇÁ¥≤Á¥±ÁºΩÁæûÁæöÁøåÁøéÁøíËÄúËÅäËÅÜËÑØËÑñËÑ£ËÑ´ËÑ©ËÑ∞ËÑ§ËàÇËàµËà∑Ëà∂ËàπËééËéûËéòËç∏Ëé¢ËéñËéΩËé´ËéíËéäËéìËéâËé†Ëç∑ËçªËçº"],["b340","ËéÜËéßËôïÂΩ™ËõáËõÄËö∂ËõÑËöµËõÜËõãËö±ËöØËõâË°ìË¢ûË¢àË¢´Ë¢íË¢ñË¢çË¢ãË¶ìË¶èË®™Ë®ùË®£Ë®•Ë®±Ë®≠Ë®üË®õË®¢Ë±âË±öË≤©Ë≤¨Ë≤´Ë≤®Ë≤™Ë≤ßËµßËµ¶Ë∂æË∂∫ËªõËªüÈÄôÈÄçÈÄöÈÄóÈÄ£ÈÄüÈÄùÈÄêÈÄïÈÄûÈÄ†ÈÄèÈÄ¢ÈÄñÈÄõÈÄî"],["b3a1","ÈÉ®ÈÉ≠ÈÉΩÈÖóÈáéÈáµÈá¶Èá£ÈáßÈá≠Èá©ÈñâÈô™ÈôµÈô≥Èô∏Èô∞Èô¥Èô∂Èô∑Èô¨ÈõÄÈõ™Èõ©Á´†Á´üÈ†ÇÈ†ÉÈ≠öÈ≥•ÈπµÈπøÈ∫•È∫ªÂÇ¢ÂÇçÂÇÖÂÇôÂÇëÂÇÄÂÇñÂÇòÂÇöÊúÄÂá±Ââ≤Ââ¥ÂâµÂâ©ÂãûÂãùÂãõÂçöÂé•ÂïªÂñÄÂñßÂïºÂñäÂñùÂñòÂñÇÂñúÂñ™ÂñîÂñáÂñãÂñÉÂñ≥ÂñÆÂñüÂîæÂñ≤ÂñöÂñªÂñ¨Âñ±ÂïæÂñâÂñ´ÂñôÂúçÂ†ØÂ†™Â†¥Â†§Â†∞Â†±Â†°Â†ùÂ††Â£πÂ£∫Â•†"],["b440","Â©∑Â™öÂ©øÂ™íÂ™õÂ™ßÂ≠≥Â≠±ÂØíÂØåÂØìÂØêÂ∞äÂ∞ãÂ∞±ÂµåÂµêÂ¥¥ÂµáÂ∑ΩÂπÖÂ∏ΩÂπÄÂπÉÂπæÂªäÂªÅÂªÇÂªÑÂººÂΩ≠Âæ©Âæ™Âæ®ÊÉëÊÉ°ÊÇ≤ÊÇ∂ÊÉ†ÊÑúÊÑ£ÊÉ∫ÊÑïÊÉ∞ÊÉªÊÉ¥ÊÖ®ÊÉ±ÊÑéÊÉ∂ÊÑâÊÑÄÊÑíÊàüÊââÊé£ÊéåÊèèÊèÄÊè©ÊèâÊèÜÊèç"],["b4a1","ÊèíÊè£ÊèêÊè°ÊèñÊè≠ÊèÆÊç∂Êè¥Êè™ÊèõÊëíÊèöÊèπÊïûÊï¶Êï¢Êï£ÊñëÊñêÊñØÊôÆÊô∞Êô¥Êô∂ÊôØÊöëÊô∫ÊôæÊô∑ÊõæÊõøÊúüÊúùÊ£∫Ê£ïÊ£†Ê£òÊ£óÊ§ÖÊ£üÊ£µÊ£ÆÊ£ßÊ£πÊ£íÊ£≤Ê££Ê£ãÊ£çÊ§çÊ§íÊ§éÊ£âÊ£öÊ•ÆÊ£ªÊ¨æÊ¨∫Ê¨ΩÊÆòÊÆñÊÆºÊØØÊ∞ÆÊ∞ØÊ∞¨Ê∏ØÊ∏∏ÊπîÊ∏°Ê∏≤ÊπßÊπäÊ∏†Ê∏•Ê∏£Ê∏õÊπõÊπòÊ∏§ÊπñÊπÆÊ∏≠Ê∏¶ÊπØÊ∏¥ÊπçÊ∏∫Ê∏¨ÊπÉÊ∏ùÊ∏æÊªã"],["b540","Ê∫âÊ∏ôÊπéÊπ£ÊπÑÊπ≤Êπ©ÊπüÁÑôÁÑöÁÑ¶ÁÑ∞ÁÑ°ÁÑ∂ÁÖÆÁÑúÁâåÁäÑÁäÄÁå∂Áå•Áå¥Áå©Áê∫Áê™Áê≥Áê¢Áê•ÁêµÁê∂Áê¥ÁêØÁêõÁê¶Áê®Áî•Áî¶Áï´Áï™Áó¢ÁóõÁó£ÁóôÁóòÁóûÁó†ÁôªÁôºÁöñÁöìÁö¥ÁõúÁùèÁü≠Á°ùÁ°¨Á°ØÁ®çÁ®àÁ®ãÁ®ÖÁ®ÄÁ™ò"],["b5a1","Á™óÁ™ñÁ´•Á´£Á≠âÁ≠ñÁ≠ÜÁ≠êÁ≠íÁ≠îÁ≠çÁ≠ãÁ≠èÁ≠ëÁ≤üÁ≤•ÁµûÁµêÁµ®ÁµïÁ¥´ÁµÆÁµ≤Áµ°Áµ¶Áµ¢Áµ∞Áµ≥ÂñÑÁøîÁøïËÄãËÅíËÇÖËÖïËÖîËÖãËÖëËÖéËÑπËÖÜËÑæËÖåËÖìËÖ¥ËàíËàúËè©ËêÉËè∏ËêçËè†ËèÖËêãËèÅËèØËè±Ëè¥ËëóËêäËè∞ËêåËèåËèΩËè≤ËèäËê∏ËêéËêÑËèúËêáËèîËèüËôõËõüËõôËõ≠ËõîËõõËõ§ËõêËõûË°óË£ÅË£ÇË¢±Ë¶ÉË¶ñË®ªË©†Ë©ïË©ûË®ºË©Å"],["b640","Ë©îË©õË©êË©ÜË®¥Ë®∫Ë®∂Ë©ñË±°Ë≤ÇË≤ØË≤ºË≤≥Ë≤ΩË≥ÅË≤ªË≥ÄË≤¥Ë≤∑Ë≤∂Ë≤øË≤∏Ë∂äË∂ÖË∂ÅË∑éË∑ùË∑ãË∑öË∑ëË∑åË∑õË∑ÜËªªËª∏ËªºËæúÈÄÆÈÄµÈÄ±ÈÄ∏ÈÄ≤ÈÄ∂ÈÑÇÈÉµÈÑâÈÉæÈÖ£ÈÖ•ÈáèÈàîÈàïÈà£ÈàâÈàûÈàçÈàêÈàáÈàëÈñîÈñèÈñãÈñë"],["b6a1","ÈñìÈñíÈñéÈöäÈöéÈöãÈôΩÈöÖÈöÜÈöçÈô≤ÈöÑÈõÅÈõÖÈõÑÈõÜÈõáÈõØÈõ≤ÈüåÈ†ÖÈ†ÜÈ†àÈ£ßÈ£™È£ØÈ£©È£≤È£≠È¶ÆÈ¶≠ÈªÉÈªçÈªë‰∫ÇÂÇ≠ÂÇµÂÇ≤ÂÇ≥ÂÉÖÂÇæÂÇ¨ÂÇ∑ÂÇªÂÇØÂÉáÂâøÂâ∑ÂâΩÂãüÂã¶Âã§Âã¢Âã£ÂåØÂóüÂó®ÂóìÂó¶ÂóéÂóúÂóáÂóëÂó£Âó§ÂóØÂóöÂó°ÂóÖÂóÜÂó•ÂóâÂúíÂúìÂ°ûÂ°ëÂ°òÂ°óÂ°öÂ°îÂ°´Â°åÂ°≠Â°äÂ°¢Â°íÂ°ãÂ•ßÂ´ÅÂ´âÂ´åÂ™æÂ™ΩÂ™º"],["b740","Â™≥Â´ÇÂ™≤Âµ©ÂµØÂπåÂππÂªâÂªàÂºíÂΩôÂæ¨ÂæÆÊÑöÊÑèÊÖàÊÑüÊÉ≥ÊÑõÊÉπÊÑÅÊÑàÊÖéÊÖåÊÖÑÊÖçÊÑæÊÑ¥ÊÑßÊÑçÊÑÜÊÑ∑Êà°Êà¢ÊêìÊêæÊêûÊê™Êê≠ÊêΩÊê¨ÊêèÊêúÊêîÊêçÊê∂ÊêñÊêóÊêÜÊï¨ÊñüÊñ∞ÊöóÊöâÊöáÊöàÊöñÊöÑÊöòÊöçÊúÉÊ¶îÊ•≠"],["b7a1","Ê•öÊ•∑Ê•†Ê•îÊ•µÊ§∞Ê¶ÇÊ•äÊ•®Ê•´Ê•ûÊ•ìÊ•πÊ¶ÜÊ•ùÊ•£Ê•õÊ≠áÊ≠≤ÊØÄÊÆøÊØìÊØΩÊ∫¢Ê∫ØÊªìÊ∫∂ÊªÇÊ∫êÊ∫ùÊªáÊªÖÊ∫•Ê∫òÊ∫ºÊ∫∫Ê∫´ÊªëÊ∫ñÊ∫úÊªÑÊªîÊ∫™Ê∫ßÊ∫¥ÁÖéÁÖôÁÖ©ÁÖ§ÁÖâÁÖßÁÖúÁÖ¨ÁÖ¶ÁÖåÁÖ•ÁÖûÁÖÜÁÖ®ÁÖñÁà∫ÁâíÁå∑ÁçÖÁåøÁåæÁëØÁëöÁëïÁëüÁëûÁëÅÁêøÁëôÁëõÁëúÁï∂Áï∏ÁòÄÁó∞ÁòÅÁó≤Áó±Áó∫ÁóøÁó¥Áó≥ÁõûÁõüÁùõÁù´Áù¶ÁùûÁù£"],["b840","ÁùπÁù™Áù¨ÁùúÁù•Áù®Áù¢ÁüÆÁ¢éÁ¢∞Á¢óÁ¢òÁ¢åÁ¢âÁ°ºÁ¢ëÁ¢ìÁ°øÁ•∫Á•øÁ¶ÅËê¨Á¶ΩÁ®úÁ®öÁ®†Á®îÁ®üÁ®ûÁ™üÁ™†Á≠∑ÁØÄÁ≠†Á≠ÆÁ≠ßÁ≤±Á≤≥Á≤µÁ∂ìÁµπÁ∂ëÁ∂ÅÁ∂èÁµõÁΩÆÁΩ©ÁΩ™ÁΩ≤Áæ©Áæ®Áæ§ËÅñËÅòËÇÜËÇÑËÖ±ËÖ∞ËÖ∏ËÖ•ËÖÆËÖ≥ËÖ´"],["b8a1","ËÖπËÖ∫ËÖ¶ËàÖËâáËíÇËë∑ËêΩËê±ËëµËë¶Ëë´ËëâËë¨ËëõËêºËêµËë°Ëë£Ëë©Ëë≠ËëÜËôûËôúËôüËõπËúìËúàËúáËúÄËõæËõªËúÇËúÉËúÜËúäË°ôË£üË£îË£ôË£úË£òË£ùË£°Ë£äË£ïË£íË¶úËß£Ë©´Ë©≤Ë©≥Ë©¶Ë©©Ë©∞Ë™áË©ºË©£Ë™†Ë©±Ë™ÖË©≠Ë©¢Ë©ÆË©¨Ë©πË©ªË®æË©®Ë±¢Ë≤äË≤âË≥äË≥áË≥àË≥ÑË≤≤Ë≥ÉË≥ÇË≥ÖË∑°Ë∑üË∑®Ë∑ØË∑≥Ë∑∫Ë∑™Ë∑§Ë∑¶Ë∫≤ËºÉËºâËªæËºä"],["b940","ËæüËæ≤ÈÅãÈÅäÈÅìÈÅÇÈÅîÈÄºÈÅïÈÅêÈÅáÈÅèÈÅéÈÅçÈÅëÈÄæÈÅÅÈÑíÈÑóÈÖ¨ÈÖ™ÈÖ©ÈáâÈà∑ÈâóÈà∏ÈàΩÈâÄÈàæÈâõÈâãÈâ§ÈâëÈà¥ÈââÈâçÈâÖÈàπÈàøÈâöÈñòÈöòÈöîÈöïÈõçÈõãÈõâÈõäÈõ∑ÈõªÈõπÈõ∂ÈùñÈù¥Èù∂È†êÈ†ëÈ†ìÈ†äÈ†íÈ†åÈ£ºÈ£¥"],["b9a1","È£ΩÈ£æÈ¶≥È¶±È¶¥È´°È≥©È∫ÇÈºéÈºìÈº†ÂÉßÂÉÆÂÉ•ÂÉñÂÉ≠ÂÉöÂÉïÂÉèÂÉëÂÉ±ÂÉéÂÉ©ÂÖ¢Âá≥ÂäÉÂäÇÂå±Âé≠ÂóæÂòÄÂòõÂòóÂóΩÂòîÂòÜÂòâÂòçÂòéÂó∑ÂòñÂòüÂòàÂòêÂó∂ÂúòÂúñÂ°µÂ°æÂ¢ÉÂ¢ìÂ¢äÂ°πÂ¢ÖÂ°ΩÂ£ΩÂ§•Â§¢Â§§Â•™Â•©Â´°Â´¶Â´©Â´óÂ´ñÂ´òÂ´£Â≠µÂØûÂØßÂØ°ÂØ•ÂØ¶ÂØ®ÂØ¢ÂØ§ÂØüÂ∞çÂ±¢Â∂ÑÂ∂áÂπõÂπ£ÂπïÂπóÂπîÂªìÂªñÂºäÂΩÜÂΩ∞ÂæπÊÖá"],["ba40","ÊÑøÊÖãÊÖ∑ÊÖ¢ÊÖ£ÊÖüÊÖöÊÖòÊÖµÊà™ÊíáÊëòÊëîÊí§Êë∏ÊëüÊë∫ÊëëÊëßÊê¥Êë≠ÊëªÊï≤Êñ°ÊóóÊóñÊö¢Êö®ÊöùÊ¶úÊ¶®Ê¶ïÊßÅÊ¶ÆÊßìÊßãÊ¶õÊ¶∑Ê¶ªÊ¶´Ê¶¥ÊßêÊßçÊ¶≠ÊßåÊ¶¶ÊßÉÊ¶£Ê≠âÊ≠åÊ∞≥Êº≥ÊºîÊªæÊºìÊª¥Êº©ÊºæÊº†Êº¨ÊºèÊºÇÊº¢"],["baa1","ÊªøÊªØÊºÜÊº±Êº∏Êº≤Êº£ÊºïÊº´ÊºØÊæàÊº™Êª¨ÊºÅÊª≤ÊªåÊª∑ÁÜîÁÜôÁÖΩÁÜäÁÜÑÁÜíÁàæÁäíÁäñÁçÑÁçêÁë§Áë£Áë™Áë∞Áë≠ÁîÑÁñëÁòßÁòçÁòãÁòâÁòìÁõ°Áõ£ÁûÑÁùΩÁùøÁù°Á£ÅÁ¢üÁ¢ßÁ¢≥Á¢©Á¢£Á¶éÁ¶èÁ¶çÁ®ÆÁ®±Á™™Á™©Á´≠Á´ØÁÆ°ÁÆïÁÆãÁ≠µÁÆóÁÆùÁÆîÁÆèÁÆ∏ÁÆáÁÆÑÁ≤πÁ≤ΩÁ≤æÁ∂ªÁ∂∞Á∂úÁ∂ΩÁ∂æÁ∂†Á∑äÁ∂¥Á∂≤Á∂±Á∂∫Á∂¢Á∂øÁ∂µÁ∂∏Á∂≠Á∑íÁ∑áÁ∂¨"],["bb40","ÁΩ∞Áø†Áø°ÁøüËÅûËÅöËÇáËÖêËÜÄËÜèËÜàËÜäËÖøËÜÇËáßËá∫ËàáËàîËàûËâãËìâËíøËìÜËìÑËíôËíûËí≤ËíúËìãËí∏ËìÄËììËíêËíºËìëËìäËúøËúúËúªËú¢Ëú•Ëú¥ËúòËùïËú∑Ëú©Ë£≥Ë§ÇË£¥Ë£πË£∏Ë£ΩË£®Ë§öË£ØË™¶Ë™åË™ûË™£Ë™çË™°Ë™ìË™§"],["bba1","Ë™™Ë™•Ë™®Ë™òË™ëË™öË™ßË±™Ë≤çË≤åË≥ìË≥ëË≥íËµ´Ë∂ôË∂ïË∑ºËºîËºíËºïËºìËæ£ÈÅ†ÈÅòÈÅúÈÅ£ÈÅôÈÅûÈÅ¢ÈÅùÈÅõÈÑôÈÑòÈÑûÈÖµÈÖ∏ÈÖ∑ÈÖ¥Èâ∏ÈäÄÈäÖÈäòÈäñÈâªÈäìÈäúÈä®ÈâºÈäëÈñ°Èñ®Èñ©Èñ£Èñ•Èñ§ÈöôÈöúÈöõÈõåÈõíÈúÄÈùºÈûÖÈü∂È†óÈ†òÈ¢ØÈ¢±È§ÉÈ§ÖÈ§åÈ§âÈßÅÈ™ØÈ™∞È´¶È≠ÅÈ≠ÇÈ≥¥È≥∂È≥≥È∫ºÈºªÈΩäÂÑÑÂÑÄÂÉªÂÉµÂÉπÂÑÇÂÑàÂÑâÂÑÖÂáú"],["bc40","ÂäáÂäàÂäâÂäçÂääÂã∞Âé≤ÂòÆÂòªÂòπÂò≤ÂòøÂò¥Âò©ÂôìÂôéÂôóÂô¥Âò∂ÂòØÂò∞Â¢ÄÂ¢üÂ¢ûÂ¢≥Â¢úÂ¢ÆÂ¢©Â¢¶Â•≠Â¨âÂ´ªÂ¨ãÂ´µÂ¨åÂ¨àÂØÆÂØ¨ÂØ©ÂØ´Â±§Â±•Â∂ùÂ∂îÂπ¢ÂπüÂπ°Âª¢ÂªöÂªüÂªùÂª£Âª†ÂΩàÂΩ±Âæ∑ÂæµÊÖ∂ÊÖßÊÖÆÊÖùÊÖïÊÜÇ"],["bca1","ÊÖºÊÖ∞ÊÖ´ÊÖæÊÜßÊÜêÊÜ´ÊÜéÊÜ¨ÊÜöÊÜ§ÊÜîÊÜÆÊàÆÊë©ÊëØÊëπÊíûÊí≤ÊíàÊíêÊí∞Êí•ÊíìÊíïÊí©ÊííÊíÆÊí≠Êí´ÊíöÊí¨ÊíôÊí¢Êí≥ÊïµÊï∑Êï∏ÊöÆÊö´Êö¥Êö±Ê®£Ê®üÊß®Ê®ÅÊ®ûÊ®ôÊßΩÊ®°Ê®ìÊ®äÊß≥Ê®ÇÊ®ÖÊß≠Ê®ëÊ≠êÊ≠éÊÆ§ÊØÖÊØÜÊºøÊΩºÊæÑÊΩëÊΩ¶ÊΩîÊæÜÊΩ≠ÊΩõÊΩ∏ÊΩÆÊæéÊΩ∫ÊΩ∞ÊΩ§ÊæóÊΩòÊªïÊΩØÊΩ†ÊΩüÁÜüÁÜ¨ÁÜ±ÁÜ®ÁâñÁäõÁçéÁçóÁë©ÁíãÁíÉ"],["bd40","ÁëæÁíÄÁïøÁò†Áò©ÁòüÁò§Áò¶Áò°Áò¢ÁööÁö∫Áõ§ÁûéÁûáÁûåÁûëÁûãÁ£ãÁ£ÖÁ¢∫Á£äÁ¢æÁ£ïÁ¢ºÁ£êÁ®øÁ®ºÁ©ÄÁ®ΩÁ®∑Á®ªÁ™ØÁ™ÆÁÆ≠ÁÆ±ÁØÑÁÆ¥ÁØÜÁØáÁØÅÁÆ†ÁØåÁ≥äÁ∑†Á∑¥Á∑ØÁ∑ªÁ∑òÁ∑¨Á∑ùÁ∑®Á∑£Á∑öÁ∑ûÁ∑©Á∂ûÁ∑ôÁ∑≤Á∑πÁΩµÁΩ∑ÁæØ"],["bda1","Áø©ËÄ¶ËÜõËÜúËÜùËÜ†ËÜöËÜòËîóËîΩËîöËìÆËî¨Ëî≠ËîìËîëËî£Ëî°ËîîËì¨Ëî•ËìøËîÜËûÇËù¥Ëù∂Ëù†Ëù¶Ëù∏Ëù®ËùôËùóËùåËùìË°õË°ùË§êË§áË§íË§ìË§ïË§äË™ºË´íË´áË´ÑË™ïË´ãË´∏Ë™≤Ë´âË´ÇË™øË™∞Ë´ñË´çË™∂Ë™πË´õË±åË±éË±¨Ë≥†Ë≥ûË≥¶Ë≥§Ë≥¨Ë≥≠Ë≥¢Ë≥£Ë≥úË≥™Ë≥°Ëµ≠Ë∂üË∂£Ë∏´Ë∏êË∏ùË∏¢Ë∏èË∏©Ë∏üË∏°Ë∏ûË∫∫ËºùËºõËºüËº©Ëº¶Ëº™ËºúËºû"],["be40","Ëº•ÈÅ©ÈÅÆÈÅ®ÈÅ≠ÈÅ∑ÈÑ∞ÈÑ≠ÈÑßÈÑ±ÈÜáÈÜâÈÜãÈÜÉÈãÖÈäªÈä∑Èã™Èä¨Èã§ÈãÅÈä≥ÈäºÈãíÈãáÈã∞Èä≤Èñ≠Èñ±ÈúÑÈúÜÈúáÈúâÈù†ÈûçÈûãÈûèÈ†°È†´È†úÈ¢≥È§äÈ§ìÈ§íÈ§òÈßùÈßêÈßüÈßõÈßëÈßïÈßíÈßôÈ™∑È´ÆÈ´ØÈ¨ßÈ≠ÖÈ≠ÑÈ≠∑È≠ØÈ¥ÜÈ¥â"],["bea1","È¥ÉÈ∫©È∫æÈªéÂ¢®ÈΩíÂÑíÂÑòÂÑîÂÑêÂÑïÂÜÄÂÜ™ÂáùÂäëÂäìÂã≥ÂôôÂô´ÂôπÂô©Âô§Âô∏Âô™Âô®Âô•Âô±ÂôØÂô¨Âô¢Âô∂Â£ÅÂ¢æÂ£áÂ£ÖÂ•ÆÂ¨ùÂ¨¥Â≠∏ÂØ∞Â∞éÂΩäÊÜ≤ÊÜëÊÜ©ÊÜäÊáçÊÜ∂ÊÜæÊáäÊáàÊà∞ÊìÖÊìÅÊìãÊíªÊíºÊìöÊìÑÊìáÊìÇÊìçÊíøÊìíÊìîÊíæÊï¥ÊõÜÊõâÊöπÊõÑÊõáÊö∏Ê®ΩÊ®∏Ê®∫Ê©ôÊ©´Ê©òÊ®πÊ©ÑÊ©¢Ê©°Ê©ãÊ©áÊ®µÊ©üÊ©àÊ≠ôÊ≠∑Ê∞ÖÊøÇÊæ±Êæ°"],["bf40","ÊøÉÊæ§ÊøÅÊæßÊæ≥ÊøÄÊæπÊæ∂Êæ¶Êæ†Êæ¥ÁÜæÁáâÁáêÁáíÁáàÁáïÁÜπÁáéÁáôÁáúÁáÉÁáÑÁç®ÁíúÁí£ÁíòÁíüÁíûÁì¢ÁîåÁîçÁò¥Áò∏Áò∫ÁõßÁõ•Áû†ÁûûÁûüÁû•Á£®Á£öÁ£¨Á£ßÁ¶¶Á©çÁ©éÁ©ÜÁ©åÁ©ãÁ™∫ÁØôÁ∞ëÁØâÁØ§ÁØõÁØ°ÁØ©ÁØ¶Á≥ïÁ≥ñÁ∏ä"],["bfa1","Á∏ëÁ∏àÁ∏õÁ∏£Á∏ûÁ∏ùÁ∏âÁ∏êÁΩπÁæ≤Áø∞Áø±ÁøÆËÄ®ËÜ≥ËÜ©ËÜ®ËáªËààËâòËâôËïäËïôËïàËï®Ëï©ËïÉËïâËï≠Ëï™ËïûËûÉËûüËûûËû¢ËûçË°°Ë§™Ë§≤Ë§•Ë§´Ë§°Ë¶™Ë¶¶Ë´¶Ë´∫Ë´´Ë´±Ë¨ÄË´úË´ßË´ÆË´æË¨ÅË¨ÇË´∑Ë´≠Ë´≥Ë´∂Ë´ºË±´Ë±≠Ë≤ìË≥¥ËπÑË∏±Ë∏¥ËπÇË∏πË∏µËºªËºØËº∏Ëº≥Ëæ®Ëæ¶ÈÅµÈÅ¥ÈÅ∏ÈÅ≤ÈÅºÈÅ∫ÈÑ¥ÈÜíÈå†Èå∂Èã∏Èå≥ÈåØÈå¢ÈãºÈå´ÈåÑÈåö"],["c040","ÈåêÈå¶Èå°ÈåïÈåÆÈåôÈñªÈößÈö®Èö™ÈõïÈúéÈúëÈúñÈúçÈúìÈúèÈùõÈùúÈù¶ÈûòÈ†∞È†∏È†ªÈ†∑È†≠È†πÈ†§È§êÈ§®È§ûÈ§õÈ§°È§öÈß≠Èß¢Èß±È™∏È™ºÈ´ªÈ´≠È¨®ÈÆëÈ¥ïÈ¥£È¥¶È¥®È¥íÈ¥õÈªòÈªîÈæçÈæúÂÑ™ÂÑüÂÑ°ÂÑ≤ÂãµÂöéÂöÄÂöêÂöÖÂöá"],["c0a1","ÂöèÂ£ïÂ£ìÂ£ëÂ£éÂ¨∞Â¨™Â¨§Â≠∫Â∞∑Â±®Â∂ºÂ∂∫Â∂ΩÂ∂∏Âπ´ÂΩåÂæΩÊáâÊáÇÊááÊá¶ÊáãÊà≤Êà¥ÊìéÊìäÊìòÊì†Êì∞Êì¶Êì¨Êì±Êì¢Êì≠ÊñÇÊñÉÊõôÊõñÊ™ÄÊ™îÊ™ÑÊ™¢Ê™úÊ´õÊ™£Ê©æÊ™óÊ™êÊ™†Ê≠úÊÆÆÊØöÊ∞àÊøòÊø±ÊøüÊø†ÊøõÊø§Êø´ÊøØÊæÄÊø¨Êø°Êø©ÊøïÊøÆÊø∞ÁáßÁáüÁáÆÁá¶Áá•Áá≠Áá¨Áá¥Áá†ÁàµÁâÜÁç∞Áç≤Áí©Áí∞Áí¶Áí®ÁôÜÁôÇÁôåÁõ™Áû≥Áû™Áû∞Áû¨"],["c140","ÁûßÁû≠ÁüØÁ£∑Á£∫Á£¥Á£ØÁ§ÅÁ¶ßÁ¶™Á©óÁ™øÁ∞áÁ∞çÁØæÁØ∑Á∞åÁØ†Á≥†Á≥úÁ≥ûÁ≥¢Á≥üÁ≥ôÁ≥ùÁ∏ÆÁ∏æÁπÜÁ∏∑Á∏≤ÁπÉÁ∏´Á∏ΩÁ∏±ÁπÖÁπÅÁ∏¥Á∏πÁπàÁ∏µÁ∏øÁ∏ØÁΩÑÁø≥ÁøºËÅ±ËÅ≤ËÅ∞ËÅØËÅ≥ËáÜËáÉËÜ∫ËáÇËáÄËÜøËÜΩËáâËÜæËá®ËàâËâ±Ëñ™"],["c1a1","ËñÑËïæËñúËñëËñîËñØËñõËñáËñ®ËñäËôßËüÄËüëËû≥ËüíËüÜËû´ËûªËû∫ËüàËüãË§ªË§∂Ë•ÑË§∏Ë§ΩË¶¨Ë¨éË¨óË¨ôË¨õË¨äË¨†Ë¨ùË¨ÑË¨êË±ÅË∞øË±≥Ë≥∫Ë≥ΩË≥ºË≥∏Ë≥ªË∂®ËπâËπãËπàËπäËΩÑËºæËΩÇËΩÖËºøÈÅøÈÅΩÈÇÑÈÇÅÈÇÇÈÇÄÈÑπÈÜ£ÈÜûÈÜúÈççÈéÇÈå®ÈçµÈçäÈç•ÈçãÈåòÈçæÈç¨ÈçõÈç∞ÈçöÈçîÈóäÈóãÈóåÈóàÈóÜÈö±Èö∏ÈõñÈúúÈúûÈû†ÈüìÈ°ÜÈ¢∂È§µÈ®Å"],["c240","ÈßøÈÆÆÈÆ´ÈÆ™ÈÆ≠È¥ªÈ¥øÈ∫ãÈªèÈªûÈªúÈªùÈªõÈºæÈΩãÂè¢ÂöïÂöÆÂ£ôÂ£òÂ¨∏ÂΩùÊá£Êà≥Êì¥Êì≤ÊìæÊîÜÊì∫ÊìªÊì∑Êñ∑ÊõúÊú¶Ê™≥Ê™¨Ê´ÉÊ™ªÊ™∏Ê´ÇÊ™ÆÊ™ØÊ≠üÊ≠∏ÊÆØÁÄâÁÄãÊøæÁÄÜÊø∫ÁÄëÁÄèÁáªÁáºÁáæÁá∏Áç∑ÁçµÁíßÁíøÁîïÁôñÁôò"],["c2a1","ÁôíÁûΩÁûøÁûªÁûºÁ§éÁ¶ÆÁ©°Á©¢Á©†Á´ÑÁ´ÖÁ∞´Á∞ßÁ∞™Á∞ûÁ∞£Á∞°Á≥ßÁπîÁπïÁπûÁπöÁπ°ÁπíÁπôÁΩàÁøπÁøªËÅ∑ËÅ∂ËáçËáèËàäËóèËñ©ËóçËóêËóâËñ∞Ëñ∫ËñπËñ¶ËüØËü¨Ëü≤Ëü†Ë¶ÜË¶≤Ëß¥Ë¨®Ë¨πË¨¨Ë¨´Ë±êË¥ÖËπôËπ£Ëπ¶Ëπ§ËπüËπïËªÄËΩâËΩçÈÇáÈÇÉÈÇàÈÜ´ÈÜ¨ÈáêÈéîÈéäÈéñÈé¢Èé≥ÈéÆÈé¨Èé∞ÈéòÈéöÈéóÈóîÈóñÈóêÈóïÈõ¢ÈõúÈõôÈõõÈõûÈú§Èû£Èû¶"],["c340","Èû≠ÈüπÈ°çÈ°èÈ°åÈ°éÈ°ìÈ¢∫È§æÈ§øÈ§ΩÈ§ÆÈ¶•È®éÈ´ÅÈ¨ÉÈ¨ÜÈ≠èÈ≠éÈ≠çÈØäÈØâÈØΩÈØàÈØÄÈµëÈµùÈµ†Èª†ÈºïÈº¨ÂÑ≥Âö•Â£ûÂ£üÂ£¢ÂØµÈæêÂª¨Êá≤Êá∑Êá∂ÊáµÊîÄÊîèÊõ†ÊõùÊ´•Ê´ùÊ´öÊ´ìÁÄõÁÄüÁÄ®ÁÄöÁÄùÁÄïÁÄòÁàÜÁàçÁâòÁä¢Áç∏"],["c3a1","Áç∫ÁíΩÁìäÁì£ÁñáÁñÜÁôüÁô°ÁüáÁ§ôÁ¶±Á©´Á©©Á∞æÁ∞øÁ∞∏Á∞ΩÁ∞∑Á±ÄÁπ´Áπ≠ÁππÁπ©Áπ™ÁæÖÁπ≥Áæ∂ÁæπÁæ∏ËáòËó©ËóùËó™ËóïËó§Ëó•Ëó∑ËüªË†ÖË†çËüπËüæË•†Ë•üË•ñË•ûË≠ÅË≠úË≠òË≠âË≠öË≠éË≠èË≠ÜË≠ôË¥àË¥äËπºËπ≤Ë∫áËπ∂Ëπ¨Ëπ∫Ëπ¥ËΩîËΩéËæ≠ÈÇäÈÇãÈÜ±ÈÜÆÈè°ÈèëÈèüÈèÉÈèàÈèúÈèùÈèñÈè¢ÈèçÈèòÈè§ÈèóÈè®ÈóúÈö¥Èõ£Èú™ÈúßÈù°ÈüúÈüªÈ°û"],["c440","È°òÈ°õÈ¢ºÈ•ÖÈ•âÈ®ñÈ®ôÈ¨çÈØ®ÈØßÈØñÈØõÈ∂âÈµ°Èµ≤Èµ™Èµ¨È∫íÈ∫óÈ∫ìÈ∫¥Âã∏Âö®Âö∑Âö∂Âö¥ÂöºÂ£§Â≠ÄÂ≠ÉÂ≠ΩÂØ∂Â∑âÊá∏Êá∫ÊîòÊîîÊîôÊõ¶ÊúßÊ´¨ÁÄæÁÄ∞ÁÄ≤ÁàêÁçªÁìèÁô¢Áô•Á§¶Á§™Á§¨Á§´Á´áÁ´∂Á±åÁ±ÉÁ±çÁ≥ØÁ≥∞ËæÆÁπΩÁπº"],["c4a1","Á∫ÇÁΩåËÄÄËáöËâ¶ËóªËóπËòëËó∫ËòÜËòãËòáËòäË†îË†ïË•§Ë¶∫Ëß∏Ë≠∞Ë≠¨Ë≠¶Ë≠ØË≠üË≠´Ë¥èË¥çË∫âË∫ÅË∫ÖË∫ÇÈÜ¥ÈáãÈêòÈêÉÈèΩÈó°Èú∞È£ÑÈ•íÈ•ëÈ¶®È®´È®∞È®∑È®µÈ∞ìÈ∞çÈππÈ∫µÈª®ÈºØÈΩüÈΩ£ÈΩ°ÂÑ∑ÂÑ∏ÂõÅÂõÄÂõÇÂ§îÂ±¨Â∑çÊáºÊáæÊîùÊîúÊñïÊõ©Ê´ªÊ¨ÑÊ´∫ÊÆ≤ÁÅåÁàõÁäßÁìñÁìîÁô©ÁüìÁ±êÁ∫èÁ∫åÁæºËòóËò≠ËòöË†£Ë†¢Ë†°Ë†üË•™Ë•¨Ë¶ΩË≠¥"],["c540","Ë≠∑Ë≠ΩË¥ìË∫äË∫çË∫ãËΩüËæØÈÜ∫ÈêÆÈê≥ÈêµÈê∫Èê∏Èê≤Èê´Èó¢Èú∏ÈúπÈú≤ÈüøÈ°ßÈ°•È•óÈ©ÖÈ©ÉÈ©ÄÈ®æÈ´èÈ≠îÈ≠ëÈ∞≠È∞•È∂ØÈ∂¥È∑ÇÈ∂∏È∫ùÈªØÈºôÈΩúÈΩ¶ÈΩßÂÑºÂÑªÂõàÂõäÂõâÂ≠øÂ∑îÂ∑íÂΩéÊáøÊî§Ê¨äÊ≠°ÁÅëÁÅòÁéÄÁì§ÁñäÁôÆÁô¨"],["c5a1","Á¶≥Á±†Á±üËÅæËÅΩËáüË•≤Ë•ØËßºËÆÄË¥ñË¥óË∫ëË∫ìËΩ°ÈÖàÈëÑÈëëÈëíÈúΩÈúæÈüÉÈüÅÈ°´È•ïÈ©ïÈ©çÈ´íÈ¨öÈ±âÈ∞±È∞æÈ∞ªÈ∑ìÈ∑óÈº¥ÈΩ¨ÈΩ™ÈæîÂõåÂ∑ñÊàÄÊî£Êî´Êî™Êõ¨Ê¨êÁìöÁ´äÁ±§Á±£Á±•Á∫ìÁ∫ñÁ∫îËá¢Ëò∏ËòøË†±ËÆäÈÇêÈÇèÈë£Èë†Èë§Èù®È°ØÈ•úÈ©öÈ©õÈ©óÈ´ìÈ´îÈ´ëÈ±îÈ±óÈ±ñÈ∑•È∫üÈª¥ÂõëÂ£©Êî¨ÁÅûÁô±Áô≤ÁüóÁΩêÁæàË†∂Ë†πË°¢ËÆìËÆí"],["c640","ËÆñËâ∑Ë¥õÈáÄÈë™ÈùÇÈùàÈùÑÈüÜÈ°∞È©üÈ¨¢È≠òÈ±üÈ∑πÈ∑∫ÈπºÈπΩÈºáÈΩ∑ÈΩ≤Âª≥Ê¨ñÁÅ£Á±¨Á±ÆË†ªËßÄË∫°ÈáÅÈë≤Èë∞È°±È•ûÈ´ñÈ¨£ÈªåÁÅ§ÁüöËÆöÈë∑ÈüâÈ©¢È©•Á∫úËÆúË∫™ÈáÖÈëΩÈëæÈëºÈ±∑È±∏Èª∑Ë±îÈëøÈ∏öÁà®È©™È¨±È∏õÈ∏ûÁ±≤"],["c940","‰πÇ‰πúÂáµÂåöÂéÇ‰∏á‰∏å‰πá‰∫çÂõóÔ®åÂ±ÆÂΩ≥‰∏èÂÜá‰∏é‰∏Æ‰∫ì‰ªÇ‰ªâ‰ªàÂÜòÂãºÂç¨ÂéπÂú†Â§ÉÂ§¨Â∞êÂ∑øÊó°ÊÆ≥ÊØåÊ∞îÁàø‰∏±‰∏º‰ª®‰ªú‰ª©‰ª°‰ªù‰ªöÂàåÂåúÂçåÂú¢Âú£Â§óÂ§ØÂÆÅÂÆÑÂ∞íÂ∞ªÂ±¥Â±≥Â∏ÑÂ∫ÄÂ∫ÇÂøâÊàâÊâêÊ∞ï"],["c9a1","Ê∞∂Ê±ÉÊ∞øÊ∞ªÁäÆÁä∞ÁéäÁ¶∏ËÇäÈòû‰ºé‰ºò‰º¨‰ªµ‰ºî‰ª±‰ºÄ‰ª∑‰ºà‰ºù‰ºÇ‰ºÖ‰º¢‰ºì‰ºÑ‰ª¥‰ºíÂÜ±ÂàìÂàâÂàêÂä¶Âå¢ÂåüÂççÂéäÂêáÂõ°ÂõüÂúÆÂú™Âú¥Â§ºÂ¶ÄÂ•ºÂ¶ÖÂ•ªÂ•æÂ•∑Â•øÂ≠ñÂ∞ïÂ∞•Â±ºÂ±∫Â±ªÂ±æÂ∑üÂπµÂ∫ÑÂºÇÂºöÂΩ¥ÂøïÂøîÂøèÊâúÊâûÊâ§Êâ°Êâ¶Êâ¢ÊâôÊâ†ÊâöÊâ•ÊóØÊóÆÊúæÊúπÊú∏ÊúªÊú∫ÊúøÊúºÊú≥Ê∞òÊ±ÜÊ±íÊ±úÊ±èÊ±äÊ±îÊ±ã"],["ca40","Ê±åÁÅ±ÁâûÁä¥ÁäµÁééÁî™ÁôøÁ©µÁΩëËâ∏ËâºËäÄËâΩËâøËôçË•æÈÇôÈÇóÈÇòÈÇõÈÇîÈò¢Èò§Èò†Èò£‰Ωñ‰ºª‰Ω¢‰Ωâ‰Ωì‰Ω§‰ºæ‰Ωß‰Ωí‰Ωü‰ΩÅ‰Ωò‰º≠‰º≥‰ºø‰Ω°ÂÜèÂÜπÂàúÂàûÂà°Âä≠ÂäÆÂåâÂç£Âç≤ÂééÂéèÂê∞Âê∑Âê™ÂëîÂëÖÂêôÂêúÂê•Âêò"],["caa1","ÂêΩÂëèÂëÅÂê®Âê§ÂëáÂõÆÂõßÂõ•ÂùÅÂùÖÂùåÂùâÂùãÂùíÂ§ÜÂ•ÄÂ¶¶Â¶òÂ¶†Â¶óÂ¶éÂ¶¢Â¶êÂ¶èÂ¶ßÂ¶°ÂÆéÂÆíÂ∞®Â∞™Â≤çÂ≤èÂ≤àÂ≤ãÂ≤âÂ≤íÂ≤äÂ≤ÜÂ≤ìÂ≤ïÂ∑†Â∏äÂ∏éÂ∫ãÂ∫âÂ∫åÂ∫àÂ∫çÂºÖÂºùÂΩ∏ÂΩ∂ÂøíÂøëÂøêÂø≠Âø®ÂøÆÂø≥Âø°Âø§Âø£Âø∫ÂøØÂø∑ÂøªÊÄÄÂø¥Êà∫ÊäÉÊäåÊäéÊäèÊäîÊäáÊâ±ÊâªÊâ∫Êâ∞ÊäÅÊäàÊâ∑ÊâΩÊâ≤Êâ¥Êî∑Êó∞Êó¥Êó≥Êó≤ÊóµÊùÖÊùá"],["cb40","ÊùôÊùïÊùåÊùàÊùùÊùçÊùöÊùãÊØêÊ∞ôÊ∞öÊ±∏Ê±ßÊ±´Ê≤ÑÊ≤ãÊ≤èÊ±±Ê±ØÊ±©Ê≤öÊ±≠Ê≤áÊ≤ïÊ≤úÊ±¶Ê±≥Ê±•Ê±ªÊ≤éÁÅ¥ÁÅ∫Áâ£ÁäøÁäΩÁãÉÁãÜÁãÅÁä∫ÁãÖÁéïÁéóÁéìÁéîÁéíÁî∫ÁîπÁñîÁñïÁöÅÁ§ΩËÄ¥ËÇïËÇôËÇêËÇíËÇúËäêËäèËäÖËäéËäëËäì"],["cba1","ËääËäÉËäÑË±∏ËøâËæøÈÇüÈÇ°ÈÇ•ÈÇûÈÇßÈÇ†Èò∞Èò®ÈòØÈò≠‰∏≥‰æò‰Ωº‰æÖ‰ΩΩ‰æÄ‰æá‰Ω∂‰Ω¥‰æâ‰æÑ‰Ω∑‰Ωå‰æó‰Ω™‰æö‰Ωπ‰æÅ‰Ω∏‰æê‰æú‰æî‰æû‰æí‰æÇ‰æï‰Ω´‰ΩÆÂÜûÂÜºÂÜæÂàµÂà≤Âà≥ÂâÜÂà±ÂäºÂåäÂåãÂåºÂéíÂéîÂíáÂëøÂíÅÂíëÂíÇÂíàÂë´Âë∫ÂëæÂë•Âë¨Âë¥Âë¶ÂíçÂëØÂë°Âë†ÂíòÂë£ÂëßÂë§Âõ∑ÂõπÂùØÂù≤Âù≠Âù´Âù±Âù∞Âù∂ÂûÄÂùµÂùªÂù≥Âù¥Âù¢"],["cc40","Âù®ÂùΩÂ§åÂ•ÖÂ¶µÂ¶∫ÂßèÂßéÂ¶≤ÂßåÂßÅÂ¶∂Â¶ºÂßÉÂßñÂ¶±Â¶ΩÂßÄÂßàÂ¶¥ÂßáÂ≠¢Â≠•ÂÆìÂÆïÂ±ÑÂ±áÂ≤ÆÂ≤§Â≤†Â≤µÂ≤ØÂ≤®Â≤¨Â≤üÂ≤£Â≤≠Â≤¢Â≤™Â≤ßÂ≤ùÂ≤•Â≤∂Â≤∞Â≤¶Â∏óÂ∏îÂ∏ôÂº®Âº¢Âº£Âº§ÂΩîÂæÇÂΩæÂΩΩÂøûÂø•ÊÄ≠ÊÄ¶ÊÄôÊÄ≤ÊÄã"],["cca1","ÊÄ¥ÊÄäÊÄóÊÄ≥ÊÄöÊÄûÊÄ¨ÊÄ¢ÊÄçÊÄêÊÄÆÊÄìÊÄëÊÄåÊÄâÊÄúÊàîÊàΩÊä≠Êä¥ÊãëÊäæÊä™Êä∂ÊãäÊäÆÊä≥ÊäØÊäªÊä©Êä∞Êä∏ÊîΩÊñ®ÊñªÊòâÊóºÊòÑÊòíÊòàÊóªÊòÉÊòãÊòçÊòÖÊóΩÊòëÊòêÊõ∂ÊúäÊûÖÊù¨ÊûéÊûíÊù∂ÊùªÊûòÊûÜÊûÑÊù¥ÊûçÊûåÊù∫ÊûüÊûëÊûôÊûÉÊùΩÊûÅÊù∏ÊùπÊûîÊ¨•ÊÆÄÊ≠æÊØûÊ∞ùÊ≤ìÊ≥¨Ê≥´Ê≥ÆÊ≥ôÊ≤∂Ê≥îÊ≤≠Ê≥ßÊ≤∑Ê≥êÊ≥ÇÊ≤∫Ê≥ÉÊ≥ÜÊ≥≠Ê≥≤"],["cd40","Ê≥íÊ≥ùÊ≤¥Ê≤äÊ≤ùÊ≤ÄÊ≥ûÊ≥ÄÊ¥∞Ê≥çÊ≥áÊ≤∞Ê≥πÊ≥èÊ≥©Ê≥ëÁÇîÁÇòÁÇÖÁÇìÁÇÜÁÇÑÁÇëÁÇñÁÇÇÁÇöÁÇÉÁâ™ÁãñÁããÁãòÁãâÁãúÁãíÁãîÁãöÁãåÁãëÁé§Áé°Áé≠Áé¶Áé¢Áé†Áé¨ÁéùÁìùÁì®ÁîøÁïÄÁîæÁñåÁñòÁöØÁõ≥Áõ±Áõ∞ÁõµÁü∏ÁüºÁüπÁüªÁü∫"],["cda1","Áü∑Á•ÇÁ§øÁßÖÁ©∏Á©ªÁ´ªÁ±µÁ≥ΩËÄµËÇèËÇÆËÇ£ËÇ∏ËÇµËÇ≠Ëà†Ëä†ËãÄËä´ËäöËäòËäõËäµËäßËäÆËäºËäûËä∫Ëä¥Ëä®Ëä°Ëä©ËãÇËä§ËãÉËä∂Ëä¢Ëô∞ËôØËô≠ËôÆË±ñËøíËøãËøìËøçËøñËøïËøóÈÇ≤ÈÇ¥ÈÇØÈÇ≥ÈÇ∞ÈòπÈòΩÈòºÈò∫ÈôÉ‰øç‰øÖ‰øì‰æ≤‰øâ‰øã‰øÅ‰øî‰øú‰øô‰æª‰æ≥‰øõ‰øá‰øñ‰æ∫‰øÄ‰æπ‰ø¨ÂâÑÂââÂãÄÂãÇÂåΩÂçºÂéóÂéñÂéôÂéòÂí∫Âí°Âí≠Âí•Âìè"],["ce40","ÂìÉËåçÂí∑ÂíÆÂìñÂí∂ÂìÖÂìÜÂí†Âë∞ÂíºÂí¢ÂíæÂë≤ÂìûÂí∞ÂûµÂûûÂûüÂû§ÂûåÂûóÂûùÂûõÂûîÂûòÂûèÂûôÂû•ÂûöÂûïÂ£¥Â§çÂ•ìÂß°ÂßûÂßÆÂ®ÄÂß±ÂßùÂß∫ÂßΩÂßºÂß∂Âß§Âß≤Âß∑ÂßõÂß©Âß≥ÂßµÂß†ÂßæÂß¥Âß≠ÂÆ®Â±åÂ≥êÂ≥òÂ≥åÂ≥óÂ≥ãÂ≥õ"],["cea1","Â≥ûÂ≥öÂ≥âÂ≥áÂ≥äÂ≥ñÂ≥ìÂ≥îÂ≥èÂ≥àÂ≥ÜÂ≥éÂ≥üÂ≥∏Â∑πÂ∏°Â∏¢Â∏£Â∏†Â∏§Â∫∞Â∫§Â∫¢Â∫õÂ∫£Â∫•ÂºáÂºÆÂΩñÂæÜÊÄ∑ÊÄπÊÅîÊÅ≤ÊÅûÊÅÖÊÅìÊÅáÊÅâÊÅõÊÅåÊÅÄÊÅÇÊÅüÊÄ§ÊÅÑÊÅòÊÅ¶ÊÅÆÊâÇÊâÉÊãèÊåçÊåãÊãµÊåéÊåÉÊã´ÊãπÊåèÊååÊã∏Êã∂ÊåÄÊåìÊåîÊã∫ÊåïÊãªÊã∞ÊïÅÊïÉÊñ™ÊñøÊò∂Êò°Êò≤ÊòµÊòúÊò¶Êò¢Êò≥Êò´Êò∫ÊòùÊò¥ÊòπÊòÆÊúèÊúêÊüÅÊü≤ÊüàÊû∫"],["cf40","ÊüúÊûªÊü∏ÊüòÊüÄÊû∑ÊüÖÊü´Êü§ÊüüÊûµÊüçÊû≥Êü∑Êü∂ÊüÆÊü£ÊüÇÊûπÊüéÊüßÊü∞Êû≤ÊüºÊüÜÊü≠ÊüåÊûÆÊü¶ÊüõÊü∫ÊüâÊüäÊüÉÊü™ÊüãÊ¨®ÊÆÇÊÆÑÊÆ∂ÊØñÊØòÊØ†Ê∞†Ê∞°Ê¥®Ê¥¥Ê¥≠Ê¥üÊ¥ºÊ¥øÊ¥íÊ¥äÊ≥öÊ¥≥Ê¥ÑÊ¥ôÊ¥∫Ê¥öÊ¥ëÊ¥ÄÊ¥ùÊµÇ"],["cfa1","Ê¥ÅÊ¥òÊ¥∑Ê¥ÉÊ¥èÊµÄÊ¥áÊ¥†Ê¥¨Ê¥àÊ¥¢Ê¥âÊ¥êÁÇ∑ÁÇüÁÇæÁÇ±ÁÇ∞ÁÇ°ÁÇ¥ÁÇµÁÇ©ÁâÅÁââÁâäÁâ¨Áâ∞Áâ≥ÁâÆÁãäÁã§Áã®Áã´ÁãüÁã™Áã¶Áã£ÁéÖÁèåÁèÇÁèàÁèÖÁéπÁé∂ÁéµÁé¥Áè´ÁéøÁèáÁéæÁèÉÁèÜÁé∏ÁèãÁì¨ÁìÆÁîÆÁïáÁïàÁñßÁñ™ÁôπÁõÑÁúàÁúÉÁúÑÁúÖÁúäÁõ∑ÁõªÁõ∫ÁüßÁü®Á†ÜÁ†ëÁ†íÁ†ÖÁ†êÁ†èÁ†éÁ†âÁ†ÉÁ†ìÁ•äÁ•åÁ•ãÁ•ÖÁ•ÑÁßïÁßçÁßèÁßñÁßéÁ™Ä"],["d040","Á©æÁ´ëÁ¨ÄÁ¨ÅÁ±∫Á±∏Á±πÁ±øÁ≤ÄÁ≤ÅÁ¥ÉÁ¥àÁ¥ÅÁΩòÁæëÁæçÁææËÄáËÄéËÄèËÄîËÄ∑ËÉòËÉáËÉ†ËÉëËÉàËÉÇËÉêËÉÖËÉ£ËÉôËÉúËÉäËÉïËÉâËÉèËÉóËÉ¶ËÉçËáøËà°ËäîËãôËãæËãπËåáËã®ËåÄËãïËå∫Ëã´ËãñËã¥Ëã¨Ëã°Ëã≤ËãµËååËãªËã∂Ëã∞Ëã™"],["d0a1","Ëã§Ëã†Ëã∫Ëã≥Ëã≠Ëô∑Ëô¥ËôºËô≥Ë°ÅË°éË°ßË°™Ë°©ËßìË®ÑË®áËµ≤Ëø£Ëø°ËøÆËø†ÈÉ±ÈÇΩÈÇøÈÉïÈÉÖÈÇæÈÉáÈÉãÈÉàÈáîÈáìÈôîÈôèÈôëÈôìÈôäÈôéÂÄûÂÄÖÂÄáÂÄìÂÄ¢ÂÄ∞ÂÄõ‰øµ‰ø¥ÂÄ≥ÂÄ∑ÂÄ¨‰ø∂‰ø∑ÂÄóÂÄúÂÄ†ÂÄßÂÄµÂÄØÂÄ±ÂÄéÂÖöÂÜîÂÜìÂáäÂáÑÂáÖÂáàÂáéÂâ°ÂâöÂâíÂâûÂâüÂâïÂâ¢ÂãçÂåéÂéûÂî¶Âì¢ÂîóÂîíÂìßÂì≥Âì§ÂîöÂìøÂîÑÂîàÂì´ÂîëÂîÖÂì±"],["d140","ÂîäÂìªÂì∑Âì∏Âì†ÂîéÂîÉÂîãÂúÅÂúÇÂüåÂ†≤ÂüïÂüíÂû∫ÂüÜÂûΩÂûºÂû∏Âû∂ÂûøÂüáÂüêÂûπÂüÅÂ§éÂ•äÂ®ôÂ®ñÂ®≠Â®ÆÂ®ïÂ®èÂ®óÂ®äÂ®ûÂ®≥Â≠¨ÂÆßÂÆ≠ÂÆ¨Â∞ÉÂ±ñÂ±îÂ≥¨Â≥øÂ≥ÆÂ≥±Â≥∑Â¥ÄÂ≥πÂ∏©Â∏®Â∫®Â∫ÆÂ∫™Â∫¨Âº≥Âº∞ÂΩßÊÅùÊÅöÊÅß"],["d1a1","ÊÅÅÊÇ¢ÊÇàÊÇÄÊÇíÊÇÅÊÇùÊÇÉÊÇïÊÇõÊÇóÊÇáÊÇúÊÇéÊàôÊâÜÊã≤ÊåêÊçñÊå¨ÊçÑÊçÖÊå∂ÊçÉÊè§ÊåπÊçãÊçäÊåºÊå©ÊçÅÊå¥ÊçòÊçîÊçôÊå≠ÊçáÊå≥ÊçöÊçëÊå∏ÊçóÊçÄÊçàÊïäÊïÜÊóÜÊóÉÊóÑÊóÇÊôäÊôüÊôáÊôëÊúíÊúìÊ†üÊ†öÊ°âÊ†≤Ê†≥Ê†ªÊ°ãÊ°èÊ†ñÊ†±Ê†úÊ†µÊ†´Ê†≠Ê†ØÊ°éÊ°ÑÊ†¥Ê†ùÊ†íÊ†îÊ†¶Ê†®Ê†ÆÊ°çÊ†∫Ê†•Ê††Ê¨¨Ê¨ØÊ¨≠Ê¨±Ê¨¥Ê≠≠ËÇÇÊÆàÊØ¶ÊØ§"],["d240","ÊØ®ÊØ£ÊØ¢ÊØßÊ∞•Êµ∫Êµ£Êµ§Êµ∂Ê¥çÊµ°Ê∂íÊµòÊµ¢Êµ≠ÊµØÊ∂ëÊ∂çÊ∑ØÊµøÊ∂ÜÊµûÊµßÊµ†Ê∂óÊµ∞ÊµºÊµüÊ∂ÇÊ∂òÊ¥ØÊµ®Ê∂ãÊµæÊ∂ÄÊ∂ÑÊ¥ñÊ∂ÉÊµªÊµΩÊµµÊ∂êÁÉúÁÉìÁÉëÁÉùÁÉãÁºπÁÉ¢ÁÉóÁÉíÁÉûÁÉ†ÁÉîÁÉçÁÉÖÁÉÜÁÉáÁÉöÁÉéÁÉ°ÁâÇÁâ∏"],["d2a1","Áâ∑Áâ∂ÁåÄÁã∫Áã¥ÁãæÁã∂Áã≥ÁãªÁåÅÁèìÁèôÁè•ÁèñÁéºÁèßÁè£Áè©ÁèúÁèíÁèõÁèîÁèùÁèöÁèóÁèòÁè®ÁìûÁìüÁì¥ÁìµÁî°ÁïõÁïüÁñ∞ÁóÅÁñªÁóÑÁóÄÁñøÁñ∂Áñ∫ÁöäÁõâÁúùÁúõÁúêÁúìÁúíÁú£ÁúëÁúïÁúôÁúöÁú¢ÁúßÁ†£Á†¨Á†¢Á†µÁ†ØÁ†®Á†ÆÁ†´Á†°Á†©Á†≥Á†™Á†±Á•îÁ•õÁ•èÁ•úÁ•ìÁ•íÁ•ëÁß´Áß¨Áß†ÁßÆÁß≠Áß™ÁßúÁßûÁßùÁ™ÜÁ™âÁ™ÖÁ™ãÁ™åÁ™äÁ™áÁ´òÁ¨ê"],["d340","Á¨ÑÁ¨ìÁ¨ÖÁ¨èÁ¨àÁ¨äÁ¨éÁ¨âÁ¨íÁ≤ÑÁ≤ëÁ≤äÁ≤åÁ≤àÁ≤çÁ≤ÖÁ¥ûÁ¥ùÁ¥ëÁ¥éÁ¥òÁ¥ñÁ¥ìÁ¥üÁ¥íÁ¥èÁ¥åÁΩúÁΩ°ÁΩûÁΩ†ÁΩùÁΩõÁæñÁæíÁøÉÁøÇÁøÄËÄñËÄæËÄπËÉ∫ËÉ≤ËÉπËÉµËÑÅËÉªËÑÄËàÅËàØËà•Ëå≥Ëå≠ËçÑËåôËçëËå•ËçñËåøËçÅËå¶ËåúËå¢"],["d3a1","ËçÇËçéËåõËå™ËåàËåºËççËåñËå§Ëå†Ëå∑ËåØËå©ËçáËçÖËçåËçìËåûËå¨ËçãËåßËçàËôìËôíËö¢Ëö®ËöñËöçËöëËöûËöáËöóËöÜËöãËööËöÖËö•ËöôËö°ËößËöïËöòËöéËöùËöêËöîË°ÉË°ÑË°≠Ë°µË°∂Ë°≤Ë¢ÄË°±Ë°øË°ØË¢ÉË°æË°¥Ë°ºË®íË±áË±óË±ªË≤§Ë≤£Ëµ∂Ëµ∏Ë∂µË∂∑Ë∂∂ËªëËªìËøæËøµÈÄÇËøøËøªÈÄÑËøºËø∂ÈÉñÈÉ†ÈÉôÈÉöÈÉ£ÈÉüÈÉ•ÈÉòÈÉõÈÉóÈÉúÈÉ§ÈÖê"],["d440","ÈÖéÈÖèÈáïÈá¢ÈáöÈôúÈôüÈöºÈ££È´üÈ¨Ø‰πøÂÅ∞ÂÅ™ÂÅ°ÂÅûÂÅ†ÂÅìÂÅãÂÅùÂÅ≤ÂÅàÂÅçÂÅÅÂÅõÂÅäÂÅ¢ÂÄïÂÅÖÂÅüÂÅ©ÂÅ´ÂÅ£ÂÅ§ÂÅÜÂÅÄÂÅÆÂÅ≥ÂÅóÂÅëÂáêÂâ´Ââ≠Ââ¨ÂâÆÂãñÂãìÂå≠ÂéúÂïµÂï∂ÂîºÂïçÂïêÂî¥Âî™ÂïëÂï¢Âî∂ÂîµÂî∞ÂïíÂïÖ"],["d4a1","ÂîåÂî≤Âï•ÂïéÂîπÂïàÂî≠ÂîªÂïÄÂïãÂúäÂúáÂüªÂ†îÂü¢Âü∂ÂüúÂü¥Â†ÄÂü≠ÂüΩÂ†àÂü∏Â†ãÂü≥ÂüèÂ†áÂüÆÂü£Âü≤Âü•Âü¨Âü°Â†éÂüºÂ†êÂüßÂ†ÅÂ†åÂü±Âü©Âü∞Â†çÂ†ÑÂ•úÂ©†Â©òÂ©ïÂ©ßÂ©ûÂ®∏Â®µÂ©≠Â©êÂ©üÂ©•Â©¨Â©ìÂ©§Â©óÂ©ÉÂ©ùÂ©íÂ©ÑÂ©õÂ©àÂ™éÂ®æÂ©çÂ®πÂ©åÂ©∞Â©©Â©áÂ©ëÂ©ñÂ©ÇÂ©úÂ≠≤Â≠ÆÂØÅÂØÄÂ±ôÂ¥ûÂ¥ãÂ¥ùÂ¥öÂ¥†Â¥åÂ¥®Â¥çÂ¥¶Â¥•Â¥è"],["d540","Â¥∞Â¥íÂ¥£Â¥üÂ¥ÆÂ∏æÂ∏¥Â∫±Â∫¥Â∫πÂ∫≤Â∫≥Âº∂Âº∏ÂæõÂæñÂæüÊÇäÊÇêÊÇÜÊÇæÊÇ∞ÊÇ∫ÊÉìÊÉîÊÉèÊÉ§ÊÉôÊÉùÊÉàÊÇ±ÊÉõÊÇ∑ÊÉäÊÇøÊÉÉÊÉçÊÉÄÊå≤Êç•ÊéäÊéÇÊçΩÊéΩÊéûÊé≠ÊéùÊéóÊé´ÊééÊçØÊéáÊéêÊçÆÊéØÊçµÊéúÊç≠ÊéÆÊçºÊé§ÊåªÊéü"],["d5a1","Êç∏ÊéÖÊéÅÊéëÊéçÊç∞ÊïìÊóçÊô•Êô°ÊôõÊôôÊôúÊô¢ÊúòÊ°πÊ¢áÊ¢êÊ¢úÊ°≠Ê°ÆÊ¢ÆÊ¢´Ê•ñÊ°ØÊ¢£Ê¢¨Ê¢©Ê°µÊ°¥Ê¢≤Ê¢èÊ°∑Ê¢íÊ°ºÊ°´Ê°≤Ê¢™Ê¢ÄÊ°±Ê°æÊ¢õÊ¢ñÊ¢ãÊ¢†Ê¢âÊ¢§Ê°∏Ê°ªÊ¢ëÊ¢åÊ¢äÊ°ΩÊ¨∂Ê¨≥Ê¨∑Ê¨∏ÊÆëÊÆèÊÆçÊÆéÊÆåÊ∞™Ê∑ÄÊ∂´Ê∂¥Ê∂≥Êπ¥Ê∂¨Ê∑©Ê∑¢Ê∂∑Ê∑∂Ê∑îÊ∏ÄÊ∑àÊ∑†Ê∑üÊ∑ñÊ∂æÊ∑•Ê∑úÊ∑ùÊ∑õÊ∑¥Ê∑äÊ∂ΩÊ∑≠Ê∑∞Ê∂∫Ê∑ïÊ∑ÇÊ∑èÊ∑â"],["d640","Ê∑êÊ∑≤Ê∑ìÊ∑ΩÊ∑óÊ∑çÊ∑£Ê∂ªÁÉ∫ÁÑçÁÉ∑ÁÑóÁÉ¥ÁÑåÁÉ∞ÁÑÑÁÉ≥ÁÑêÁÉºÁÉøÁÑÜÁÑìÁÑÄÁÉ∏ÁÉ∂ÁÑãÁÑÇÁÑéÁâæÁâªÁâºÁâøÁåùÁåóÁåáÁåëÁåòÁåäÁåàÁãøÁåèÁåûÁéàÁè∂Áè∏ÁèµÁêÑÁêÅÁèΩÁêáÁêÄÁè∫ÁèºÁèøÁêåÁêãÁè¥ÁêàÁï§Áï£ÁóéÁóíÁóè"],["d6a1","ÁóãÁóåÁóëÁóêÁöèÁöâÁõìÁúπÁúØÁú≠Áú±Áú≤Áú¥Áú≥ÁúΩÁú•ÁúªÁúµÁ°àÁ°íÁ°âÁ°çÁ°äÁ°åÁ†¶Á°ÖÁ°êÁ•§Á•ßÁ•©Á•™Á•£Á•´Á•°Á¶ªÁß∫Áß∏Áß∂Áß∑Á™èÁ™îÁ™êÁ¨µÁ≠áÁ¨¥Á¨•Á¨∞Á¨¢Á¨§Á¨≥Á¨òÁ¨™Á¨ùÁ¨±Á¨´Á¨≠Á¨ØÁ¨≤Á¨∏Á¨öÁ¨£Á≤îÁ≤òÁ≤ñÁ≤£Á¥µÁ¥ΩÁ¥∏Á¥∂Á¥∫ÁµÖÁ¥¨Á¥©ÁµÅÁµáÁ¥æÁ¥øÁµäÁ¥ªÁ¥®ÁΩ£ÁæïÁæúÁæùÁæõÁøäÁøãÁøçÁøêÁøëÁøáÁøèÁøâËÄü"],["d740","ËÄûËÄõËÅáËÅÉËÅàËÑòËÑ•ËÑôËÑõËÑ≠ËÑüËÑ¨ËÑûËÑ°ËÑïËÑßËÑùËÑ¢ËàëËà∏Ëà≥Ëà∫Ëà¥Ëà≤Ëâ¥ËéêËé£Ëé®ËéçËç∫Ëç≥Ëé§Ëç¥ËéèËéÅËéïËéôËçµËéîËé©ËçΩËéÉËéåËéùËéõËé™ËéãËçæËé•ËéØËéàËéóËé∞ËçøËé¶ËéáËéÆËç∂ËéöËôôËôñËöøËö∑"],["d7a1","ËõÇËõÅËõÖËö∫Ëö∞ËõàËöπËö≥Ëö∏ËõåËö¥ËöªËöºËõÉËöΩËöæË°íË¢âË¢ïË¢®Ë¢¢Ë¢™Ë¢öË¢ëË¢°Ë¢üË¢òË¢ßË¢ôË¢õË¢óË¢§Ë¢¨Ë¢åË¢ìË¢éË¶ÇËßñËßôËßïË®∞Ë®ßË®¨Ë®ûË∞πË∞ªË±úË±ùË±ΩË≤•ËµΩËµªËµπË∂ºË∑ÇË∂πË∂øË∑ÅËªòËªûËªùËªúËªóËª†Ëª°ÈÄ§ÈÄãÈÄëÈÄúÈÄåÈÄ°ÈÉØÈÉ™ÈÉ∞ÈÉ¥ÈÉ≤ÈÉ≥ÈÉîÈÉ´ÈÉ¨ÈÉ©ÈÖñÈÖòÈÖöÈÖìÈÖïÈá¨Èá¥Èá±Èá≥Èá∏Èá§ÈáπÈá™"],["d840","Èá´Èá∑Èá®ÈáÆÈï∫ÈñÜÈñàÈôºÈô≠Èô´Èô±ÈôØÈöøÈù™È†ÑÈ£•È¶óÂÇõÂÇïÂÇîÂÇûÂÇãÂÇ£ÂÇÉÂÇåÂÇéÂÇùÂÅ®ÂÇúÂÇíÂÇÇÂÇáÂÖüÂáîÂåíÂåëÂé§ÂéßÂñëÂñ®Âñ•Âñ≠Âï∑ÂôÖÂñ¢ÂñìÂñàÂñèÂñµÂñÅÂñ£ÂñíÂñ§ÂïΩÂñåÂñ¶ÂïøÂñïÂñ°ÂñéÂúåÂ†©Â†∑"],["d8a1","Â†ôÂ†ûÂ†ßÂ†£Â†®ÂüµÂ°àÂ†•Â†úÂ†õÂ†≥Â†øÂ†∂Â†ÆÂ†πÂ†∏Â†≠Â†¨Â†ªÂ•°Â™ØÂ™îÂ™üÂ©∫Â™¢Â™ûÂ©∏Â™¶Â©ºÂ™•Â™¨Â™ïÂ™ÆÂ®∑Â™ÑÂ™äÂ™óÂ™ÉÂ™ãÂ™©Â©ªÂ©ΩÂ™åÂ™úÂ™èÂ™ìÂ™ùÂØ™ÂØçÂØãÂØîÂØëÂØäÂØéÂ∞åÂ∞∞Â¥∑ÂµÉÂµ´ÂµÅÂµãÂ¥øÂ¥µÂµëÂµéÂµïÂ¥≥Â¥∫ÂµíÂ¥ΩÂ¥±ÂµôÂµÇÂ¥πÂµâÂ¥∏Â¥ºÂ¥≤Â¥∂ÂµÄÂµÖÂπÑÂπÅÂΩòÂæ¶Âæ•Âæ´ÊÉâÊÇπÊÉåÊÉ¢ÊÉéÊÉÑÊÑî"],["d940","ÊÉ≤ÊÑäÊÑñÊÑÖÊÉµÊÑìÊÉ∏ÊÉºÊÉæÊÉÅÊÑÉÊÑòÊÑùÊÑêÊÉøÊÑÑÊÑãÊâäÊéîÊé±Êé∞ÊèéÊè•Êè®ÊèØÊèÉÊíùÊè≥ÊèäÊè†Êè∂ÊèïÊè≤ÊèµÊë°ÊèüÊéæÊèùÊèúÊèÑÊèòÊèìÊèÇÊèáÊèåÊèãÊèàÊè∞ÊèóÊèôÊî≤ÊïßÊï™Êï§ÊïúÊï®Êï•ÊñåÊñùÊñûÊñÆÊóêÊóí"],["d9a1","ÊôºÊô¨ÊôªÊöÄÊô±ÊôπÊô™Êô≤ÊúÅÊ§åÊ£ìÊ§ÑÊ£úÊ§™Ê£¨Ê£™Ê£±Ê§èÊ£ñÊ£∑Ê£´Ê£§Ê£∂Ê§ìÊ§êÊ£≥Ê£°Ê§áÊ£åÊ§àÊ•∞Ê¢¥Ê§ëÊ£ØÊ£ÜÊ§îÊ£∏Ê£êÊ£ΩÊ£ºÊ£®Ê§ãÊ§äÊ§óÊ£éÊ£àÊ£ùÊ£ûÊ£¶Ê£¥Ê£ëÊ§ÜÊ£îÊ£©Ê§ïÊ§•Ê£áÊ¨πÊ¨ªÊ¨øÊ¨ºÊÆîÊÆóÊÆôÊÆïÊÆΩÊØ∞ÊØ≤ÊØ≥Ê∞∞Ê∑ºÊπÜÊπáÊ∏üÊπâÊ∫àÊ∏ºÊ∏ΩÊπÖÊπ¢Ê∏´Ê∏øÊπÅÊπùÊπ≥Ê∏úÊ∏≥ÊπãÊπÄÊπëÊ∏ªÊ∏ÉÊ∏ÆÊπû"],["da40","Êπ®ÊπúÊπ°Ê∏±Ê∏®Êπ†Êπ±Êπ´Ê∏πÊ∏¢Ê∏∞ÊπìÊπ•Ê∏ßÊπ∏Êπ§Êπ∑ÊπïÊππÊπíÊπ¶Ê∏µÊ∏∂ÊπöÁÑ†ÁÑûÁÑØÁÉªÁÑÆÁÑ±ÁÑ£ÁÑ•ÁÑ¢ÁÑ≤ÁÑüÁÑ®ÁÑ∫ÁÑõÁâãÁâöÁäàÁäâÁäÜÁäÖÁäãÁåíÁåãÁå∞Áå¢Áå±Áå≥ÁåßÁå≤Áå≠Áå¶Áå£ÁåµÁååÁêÆÁê¨Áê∞Áê´Áêñ"],["daa1","ÁêöÁê°Áê≠Áê±Áê§Áê£ÁêùÁê©Áê†Áê≤ÁìªÁîØÁïØÁï¨ÁóßÁóöÁó°Áó¶ÁóùÁóüÁó§ÁóóÁöïÁöíÁõöÁùÜÁùáÁùÑÁùçÁùÖÁùäÁùéÁùãÁùåÁüûÁü¨Á°†Á°§Á°•Á°úÁ°≠Á°±Á°™Á°ÆÁ°∞Á°©Á°®Á°ûÁ°¢Á•¥Á•≥Á•≤Á•∞Á®ÇÁ®äÁ®ÉÁ®åÁ®ÑÁ™ôÁ´¶Á´§Á≠äÁ¨ªÁ≠ÑÁ≠àÁ≠åÁ≠éÁ≠ÄÁ≠òÁ≠ÖÁ≤¢Á≤ûÁ≤®Á≤°ÁµòÁµØÁµ£ÁµìÁµñÁµßÁµ™ÁµèÁµ≠ÁµúÁµ´ÁµíÁµîÁµ©ÁµëÁµüÁµéÁºæÁºøÁΩ•"],["db40","ÁΩ¶Áæ¢Áæ†Áæ°ÁøóËÅëËÅèËÅêËÉæËÉîËÖÉËÖäËÖíËÖèËÖáËÑΩËÖçËÑ∫Ëá¶ËáÆËá∑Ëá∏ËáπËàÑËàºËàΩËàøËâµËåªËèèËèπËê£ËèÄËè®ËêíËèßËè§ËèºËè∂ËêêËèÜËèàËè´Ëè£ËéøËêÅËèùËè•ËèòËèøËè°ËèãËèéËèñËèµËèâËêâËêèËèûËêëËêÜËèÇËè≥"],["dba1","ËèïËè∫ËèáËèëËè™ËêìËèÉËè¨ËèÆËèÑËèªËèóËè¢ËêõËèõËèæËõòËõ¢Ëõ¶ËõìËõ£ËõöËõ™ËõùËõ´ËõúËõ¨Ëõ©ËõóËõ®ËõëË°àË°ñË°ïË¢∫Ë£óË¢πË¢∏Ë£ÄË¢æË¢∂Ë¢ºË¢∑Ë¢ΩË¢≤Ë§ÅË£âË¶ïË¶òË¶óËßùËßöËßõË©éË©çË®πË©ôË©ÄË©óË©òË©ÑË©ÖË©íË©àË©ëË©äË©åË©èË±üË≤ÅË≤ÄË≤∫Ë≤æË≤∞Ë≤πË≤µË∂ÑË∂ÄË∂âË∑òË∑ìË∑çË∑áË∑ñË∑úË∑èË∑ïË∑ôË∑àË∑óË∑ÖËªØËª∑Ëª∫"],["dc40","ËªπËª¶ËªÆËª•ËªµËªßËª®Ëª∂Ëª´Ëª±Ëª¨Ëª¥Ëª©ÈÄ≠ÈÄ¥ÈÄØÈÑÜÈÑ¨ÈÑÑÈÉøÈÉºÈÑàÈÉπÈÉªÈÑÅÈÑÄÈÑáÈÑÖÈÑÉÈÖ°ÈÖ§ÈÖüÈÖ¢ÈÖ†ÈàÅÈàäÈà•ÈàÉÈàöÈà¶ÈàèÈàåÈàÄÈàíÈáøÈáΩÈàÜÈàÑÈàßÈàÇÈàúÈà§ÈàôÈàóÈàÖÈàñÈïªÈñçÈñåÈñêÈöáÈôæÈöà"],["dca1","ÈöâÈöÉÈöÄÈõÇÈõàÈõÉÈõ±Èõ∞Èù¨Èù∞ÈùÆÈ†áÈ¢©È£´È≥¶Èªπ‰∫É‰∫Ñ‰∫∂ÂÇΩÂÇøÂÉÜÂÇÆÂÉÑÂÉäÂÇ¥ÂÉàÂÉÇÂÇ∞ÂÉÅÂÇ∫ÂÇ±ÂÉãÂÉâÂÇ∂ÂÇ∏ÂáóÂâ∫Ââ∏ÂâªÂâºÂóÉÂóõÂóåÂóêÂóãÂóäÂóùÂóÄÂóîÂóÑÂó©ÂñøÂóíÂñçÂóèÂóïÂó¢ÂóñÂóàÂó≤ÂóçÂóôÂóÇÂúîÂ°ìÂ°®Â°§Â°èÂ°çÂ°âÂ°ØÂ°ïÂ°éÂ°ùÂ°ôÂ°•Â°õÂ†ΩÂ°£Â°±Â£ºÂ´áÂ´ÑÂ´ãÂ™∫Â™∏Â™±Â™µÂ™∞Â™øÂ´àÂ™ªÂ´Ü"],["dd40","Â™∑Â´ÄÂ´äÂ™¥Â™∂Â´çÂ™πÂ™êÂØñÂØòÂØôÂ∞üÂ∞≥Âµ±Âµ£ÂµäÂµ•Âµ≤Âµ¨ÂµûÂµ®ÂµßÂµ¢Â∑∞ÂπèÂπéÂπäÂπçÂπãÂªÖÂªåÂªÜÂªãÂªáÂΩÄÂæØÂæ≠ÊÉ∑ÊÖâÊÖäÊÑ´ÊÖÖÊÑ∂ÊÑ≤ÊÑÆÊÖÜÊÑØÊÖèÊÑ©ÊÖÄÊà†ÈÖ®Êà£Êà•Êà§ÊèÖÊè±Êè´ÊêêÊêíÊêâÊê†Êê§"],["dda1","Êê≥ÊëÉÊêüÊêïÊêòÊêπÊê∑Êê¢Êê£ÊêåÊê¶Êê∞Êê®ÊëÅÊêµÊêØÊêäÊêöÊëÄÊê•ÊêßÊêãÊèßÊêõÊêÆÊê°ÊêéÊïØÊñíÊóìÊöÜÊöåÊöïÊöêÊöãÊöäÊöôÊöîÊô∏Êú†Ê•¶Ê•üÊ§∏Ê•éÊ•¢Ê•±Ê§øÊ•ÖÊ•™Ê§πÊ•ÇÊ•óÊ•ôÊ•∫Ê•àÊ•âÊ§µÊ•¨Ê§≥Ê§ΩÊ••Ê£∞Ê•∏Ê§¥Ê•©Ê•ÄÊ•ØÊ•ÑÊ•∂Ê•òÊ•ÅÊ•¥Ê•åÊ§ªÊ•ãÊ§∑Ê•úÊ•èÊ•ëÊ§≤Ê•íÊ§ØÊ•ªÊ§ºÊ≠ÜÊ≠ÖÊ≠ÉÊ≠ÇÊ≠àÊ≠ÅÊÆõÔ®çÊØªÊØº"],["de40","ÊØπÊØ∑ÊØ∏Ê∫õÊªñÊªàÊ∫èÊªÄÊ∫üÊ∫ìÊ∫îÊ∫†Ê∫±Ê∫πÊªÜÊªíÊ∫ΩÊªÅÊ∫ûÊªâÊ∫∑Ê∫∞ÊªçÊ∫¶ÊªèÊ∫≤Ê∫æÊªÉÊªúÊªòÊ∫ôÊ∫íÊ∫éÊ∫çÊ∫§Ê∫°Ê∫øÊ∫≥ÊªêÊªäÊ∫óÊ∫ÆÊ∫£ÁÖáÁÖîÁÖíÁÖ£ÁÖ†ÁÖÅÁÖùÁÖ¢ÁÖ≤ÁÖ∏ÁÖ™ÁÖ°ÁÖÇÁÖòÁÖÉÁÖãÁÖ∞ÁÖüÁÖêÁÖì"],["dea1","ÁÖÑÁÖçÁÖöÁâèÁäçÁäåÁäëÁäêÁäéÁåºÁçÇÁåªÁå∫ÁçÄÁçäÁçâÁëÑÁëäÁëãÁëíÁëëÁëóÁëÄÁëèÁëêÁëéÁëÇÁëÜÁëçÁëîÁì°ÁìøÁìæÁìΩÁîùÁïπÁï∑Ê¶ÉÁóØÁòèÁòÉÁó∑ÁóæÁóºÁóπÁó∏ÁòêÁóªÁó∂Áó≠ÁóµÁóΩÁöôÁöµÁõùÁùïÁùüÁù†ÁùíÁùñÁùöÁù©ÁùßÁùîÁùôÁù≠Áü†Á¢áÁ¢öÁ¢îÁ¢èÁ¢ÑÁ¢ïÁ¢ÖÁ¢ÜÁ¢°Á¢ÉÁ°πÁ¢ôÁ¢ÄÁ¢ñÁ°ªÁ•ºÁ¶ÇÁ•ΩÁ•πÁ®ëÁ®òÁ®ôÁ®íÁ®óÁ®ïÁ®¢Á®ì"],["df40","Á®õÁ®êÁ™£Á™¢Á™ûÁ´´Á≠¶Á≠§Á≠≠Á≠¥Á≠©Á≠≤Á≠•Á≠≥Á≠±Á≠∞Á≠°Á≠∏Á≠∂Á≠£Á≤≤Á≤¥Á≤ØÁ∂àÁ∂ÜÁ∂ÄÁ∂çÁµøÁ∂ÖÁµ∫Á∂éÁµªÁ∂ÉÁµºÁ∂åÁ∂îÁ∂ÑÁµΩÁ∂íÁΩ≠ÁΩ´ÁΩßÁΩ®ÁΩ¨Áæ¶Áæ•ÁæßÁøõÁøúËÄ°ËÖ§ËÖ†ËÖ∑ËÖúËÖ©ËÖõËÖ¢ËÖ≤Êú°ËÖûËÖ∂ËÖßËÖØ"],["dfa1","ËÖÑËÖ°ËàùËââËâÑËâÄËâÇËâÖËì±ËêøËëñËë∂ËëπËíèËíçËë•ËëëËëÄËíÜËëßËê∞ËëçËëΩËëöËëôËë¥Ëë≥ËëùËîáËëûËê∑Ëê∫Ëê¥Ëë∫ËëÉËë∏Ëê≤ËëÖËê©ËèôËëãËêØËëÇËê≠ËëüËë∞ËêπËëéËëåËëíËëØËìÖËíéËêªËëáËê∂Ëê≥Ëë®ËëæËëÑËê´Ëë†ËëîËëÆËëêËúãËúÑËõ∑ËúåËõ∫ËõñËõµËùçËõ∏ËúéËúâËúÅËõ∂ËúçËúÖË£ñË£ãË£çË£éË£ûË£õË£öË£åË£êË¶ÖË¶õËßüËß•Ëß§"],["e040","Ëß°Ëß†Ëß¢ËßúËß¶Ë©∂Ë™ÜË©øË©°Ë®øË©∑Ë™ÇË™ÑË©µË™ÉË™ÅË©¥Ë©∫Ë∞ºË±ãË±äË±•Ë±§Ë±¶Ë≤ÜË≤ÑË≤ÖË≥åËµ®Ëµ©Ë∂ëË∂åË∂éË∂èË∂çË∂ìË∂îË∂êË∂íË∑∞Ë∑†Ë∑¨Ë∑±Ë∑ÆË∑êË∑©Ë∑£Ë∑¢Ë∑ßË∑≤Ë∑´Ë∑¥ËºÜËªøËºÅËºÄËºÖËºáËºàËºÇËºãÈÅíÈÄø"],["e0a1","ÈÅÑÈÅâÈÄΩÈÑêÈÑçÈÑèÈÑëÈÑñÈÑîÈÑãÈÑéÈÖÆÈÖØÈâàÈâíÈà∞Èà∫Èâ¶Èà≥Èâ•ÈâûÈäÉÈàÆÈâäÈâÜÈâ≠Èâ¨ÈâèÈâ†ÈâßÈâØÈà∂Èâ°Èâ∞Èà±ÈâîÈâ£ÈâêÈâ≤ÈâéÈâìÈâåÈâñÈà≤ÈñüÈñúÈñûÈñõÈöíÈöìÈöëÈöóÈõéÈõ∫ÈõΩÈõ∏ÈõµÈù≥Èù∑Èù∏Èù≤È†èÈ†çÈ†éÈ¢¨È£∂È£πÈ¶ØÈ¶≤È¶∞È¶µÈ™≠È™´È≠õÈ≥™È≥≠È≥ßÈ∫ÄÈªΩÂÉ¶ÂÉîÂÉóÂÉ®ÂÉ≥ÂÉõÂÉ™ÂÉùÂÉ§ÂÉìÂÉ¨ÂÉ∞ÂÉØÂÉ£ÂÉ†"],["e140","ÂáòÂäÄÂäÅÂã©Âã´Âå∞Âé¨ÂòßÂòïÂòåÂòíÂóºÂòèÂòúÂòÅÂòìÂòÇÂó∫ÂòùÂòÑÂóøÂóπÂ¢âÂ°ºÂ¢êÂ¢òÂ¢ÜÂ¢ÅÂ°øÂ°¥Â¢ãÂ°∫Â¢áÂ¢ëÂ¢éÂ°∂Â¢ÇÂ¢àÂ°ªÂ¢îÂ¢èÂ£æÂ•´Â´úÂ´ÆÂ´•Â´ïÂ´™Â´öÂ´≠Â´´Â´≥Â´¢Â´†Â´õÂ´¨Â´ûÂ´ùÂ´ôÂ´®Â´üÂ≠∑ÂØ†"],["e1a1","ÂØ£Â±£Â∂ÇÂ∂ÄÂµΩÂ∂ÜÂµ∫Â∂ÅÂµ∑Â∂äÂ∂âÂ∂àÂµæÂµºÂ∂çÂµπÂµøÂπòÂπôÂπìÂªòÂªëÂªóÂªéÂªúÂªïÂªôÂªíÂªîÂΩÑÂΩÉÂΩØÂæ∂ÊÑ¨ÊÑ®ÊÖÅÊÖûÊÖ±ÊÖ≥ÊÖíÊÖìÊÖ≤ÊÖ¨ÊÜÄÊÖ¥ÊÖîÊÖ∫ÊÖõÊÖ•ÊÑªÊÖ™ÊÖ°ÊÖñÊà©ÊàßÊà´Êê´ÊëçÊëõÊëùÊë¥Êë∂Êë≤Êë≥ÊëΩÊëµÊë¶Êí¶ÊëéÊíÇÊëûÊëúÊëãÊëìÊë†ÊëêÊëøÊêøÊë¨Êë´ÊëôÊë•Êë∑Êï≥Êñ†Êö°Êö†ÊöüÊúÖÊúÑÊú¢Ê¶±Ê¶∂Êßâ"],["e240","Ê¶†ÊßéÊ¶ñÊ¶∞Ê¶¨Ê¶ºÊ¶ëÊ¶ôÊ¶éÊ¶ßÊ¶çÊ¶©Ê¶æÊ¶ØÊ¶øÊßÑÊ¶ΩÊ¶§ÊßîÊ¶πÊßäÊ¶öÊßèÊ¶≥Ê¶ìÊ¶™Ê¶°Ê¶ûÊßôÊ¶óÊ¶êÊßÇÊ¶µÊ¶•ÊßÜÊ≠äÊ≠çÊ≠ãÊÆûÊÆüÊÆ†ÊØÉÊØÑÊØæÊªéÊªµÊª±ÊºÉÊº•Êª∏Êº∑ÊªªÊºÆÊºâÊΩéÊºôÊºöÊºßÊºòÊºªÊºíÊª≠Êºä"],["e2a1","Êº∂ÊΩ≥ÊªπÊªÆÊº≠ÊΩÄÊº∞ÊººÊºµÊª´ÊºáÊºéÊΩÉÊºÖÊªΩÊª∂ÊºπÊºúÊªºÊº∫ÊºüÊºçÊºûÊºàÊº°ÁÜáÁÜêÁÜâÁÜÄÁÜÖÁÜÇÁÜèÁÖªÁÜÜÁÜÅÁÜóÁâÑÁâìÁäóÁäïÁäìÁçÉÁççÁçëÁçåÁë¢Áë≥Áë±ÁëµÁë≤ÁëßÁëÆÁîÄÁîÇÁîÉÁïΩÁñêÁòñÁòàÁòåÁòïÁòëÁòäÁòîÁö∏ÁûÅÁùºÁûÖÁûÇÁùÆÁûÄÁùØÁùæÁûÉÁ¢≤Á¢™Á¢¥Á¢≠Á¢®Á°æÁ¢´Á¢ûÁ¢•Á¢†Á¢¨Á¢¢Á¢§Á¶òÁ¶äÁ¶ãÁ¶ñÁ¶ïÁ¶îÁ¶ì"],["e340","Á¶óÁ¶àÁ¶íÁ¶êÁ®´Á©äÁ®∞Á®ØÁ®®Á®¶Á™®Á™´Á™¨Á´ÆÁÆàÁÆúÁÆäÁÆëÁÆêÁÆñÁÆçÁÆåÁÆõÁÆéÁÆÖÁÆòÂäÑÁÆôÁÆ§ÁÆÇÁ≤ªÁ≤øÁ≤ºÁ≤∫Á∂ßÁ∂∑Á∑ÇÁ∂£Á∂™Á∑ÅÁ∑ÄÁ∑ÖÁ∂ùÁ∑éÁ∑ÑÁ∑ÜÁ∑ãÁ∑åÁ∂ØÁ∂πÁ∂ñÁ∂ºÁ∂üÁ∂¶Á∂ÆÁ∂©Á∂°Á∑âÁΩ≥Áø¢Áø£Áø•Áøû"],["e3a1","ËÄ§ËÅùËÅúËÜâËÜÜËÜÉËÜáËÜçËÜåËÜãËàïËíóËí§Ëí°ËíüËí∫ËìéËìÇËí¨ËíÆËí´ËíπËí¥ËìÅËìçËí™ËíöËí±ËìêËíùËíßËíªËí¢ËíîËìáËìåËíõËí©ËíØËí®ËìñËíòËí∂ËìèËí†ËìóËìîËìíËìõËí∞ËíëËô°Ëú≥Ëú£Ëú®Ëù´ËùÄËúÆËúûËú°ËúôËúõËùÉËú¨ËùÅËúæËùÜËú†Ëú≤Ëú™Ëú≠ËúºËúíËú∫Ëú±ËúµËùÇËú¶ËúßËú∏Ëú§ËúöËú∞ËúëË£∑Ë£ßË£±Ë£≤Ë£∫Ë£æË£ÆË£ºË£∂Ë£ª"],["e440","Ë£∞Ë£¨Ë£´Ë¶ùË¶°Ë¶üË¶ûËß©Ëß´Ëß®Ë™´Ë™ôË™ãË™íË™èË™ñË∞ΩË±®Ë±©Ë≥ïË≥èË≥óË∂ñË∏âË∏ÇË∑øË∏çË∑ΩË∏äË∏ÉË∏áË∏ÜË∏ÖË∑æË∏ÄË∏ÑËºêËºëËºéËºçÈÑ£ÈÑúÈÑ†ÈÑ¢ÈÑüÈÑùÈÑöÈÑ§ÈÑ°ÈÑõÈÖ∫ÈÖ≤ÈÖπÈÖ≥Èä•Èä§Èâ∂ÈäõÈâ∫Èä†ÈäîÈä™Èäç"],["e4a1","Èä¶ÈäöÈä´ÈâπÈäóÈâøÈä£ÈãÆÈäéÈäÇÈäïÈä¢ÈâΩÈäàÈä°ÈääÈäÜÈäåÈäôÈäßÈâæÈäáÈä©ÈäùÈäãÈà≠ÈöûÈö°ÈõøÈùòÈùΩÈù∫ÈùæÈûÉÈûÄÈûÇÈùªÈûÑÈûÅÈùøÈüéÈüçÈ†ñÈ¢≠È¢ÆÈ§ÇÈ§ÄÈ§áÈ¶ùÈ¶úÈßÉÈ¶πÈ¶ªÈ¶∫ÈßÇÈ¶ΩÈßáÈ™±È´£È´ßÈ¨æÈ¨øÈ≠†È≠°È≠üÈ≥±È≥≤È≥µÈ∫ßÂÉøÂÑÉÂÑ∞ÂÉ∏ÂÑÜÂÑáÂÉ∂ÂÉæÂÑãÂÑåÂÉΩÂÑäÂäãÂäåÂã±ÂãØÂôàÂôÇÂôåÂòµÂôÅÂôäÂôâÂôÜÂôò"],["e540","ÂôöÂôÄÂò≥ÂòΩÂò¨ÂòæÂò∏Âò™Âò∫ÂúöÂ¢´Â¢ùÂ¢±Â¢†Â¢£Â¢ØÂ¢¨Â¢•Â¢°Â£øÂ´øÂ´¥Â´ΩÂ´∑Â´∂Â¨ÉÂ´∏Â¨ÇÂ´πÂ¨ÅÂ¨áÂ¨ÖÂ¨èÂ±ßÂ∂ôÂ∂óÂ∂üÂ∂íÂ∂¢Â∂ìÂ∂ïÂ∂†Â∂úÂ∂°Â∂öÂ∂ûÂπ©ÂπùÂπ†ÂπúÁ∑≥ÂªõÂªûÂª°ÂΩâÂæ≤ÊÜãÊÜÉÊÖπÊÜ±ÊÜ∞ÊÜ¢ÊÜâ"],["e5a1","ÊÜõÊÜìÊÜØÊÜ≠ÊÜüÊÜíÊÜ™ÊÜ°ÊÜçÊÖ¶ÊÜ≥Êà≠ÊëÆÊë∞ÊíñÊí†ÊíÖÊíóÊíúÊíèÊíãÊíäÊíåÊí£ÊíüÊë®Êí±ÊíòÊï∂Êï∫ÊïπÊïªÊñ≤Êñ≥ÊöµÊö∞Êö©Êö≤Êö∑Êö™ÊöØÊ®ÄÊ®ÜÊ®óÊß•Êß∏Ê®ïÊß±Êß§Ê®†ÊßøÊß¨Êß¢Ê®õÊ®ùÊßæÊ®ßÊß≤ÊßÆÊ®îÊß∑ÊßßÊ©ÄÊ®àÊß¶ÊßªÊ®çÊßºÊß´Ê®âÊ®ÑÊ®òÊ®•Ê®èÊß∂Ê®¶Ê®áÊß¥Ê®ñÊ≠ëÊÆ•ÊÆ£ÊÆ¢ÊÆ¶Ê∞ÅÊ∞ÄÊØøÊ∞ÇÊΩÅÊº¶ÊΩæÊæáÊøÜÊæí"],["e640","ÊæçÊæâÊæåÊΩ¢ÊΩèÊæÖÊΩöÊæñÊΩ∂ÊΩ¨ÊæÇÊΩïÊΩ≤ÊΩíÊΩêÊΩóÊæîÊæìÊΩùÊºÄÊΩ°ÊΩ´ÊΩΩÊΩßÊæêÊΩìÊæãÊΩ©ÊΩøÊæïÊΩ£ÊΩ∑ÊΩ™ÊΩªÁÜ≤ÁÜØÁÜõÁÜ∞ÁÜ†ÁÜöÁÜ©ÁÜµÁÜùÁÜ•ÁÜûÁÜ§ÁÜ°ÁÜ™ÁÜúÁÜßÁÜ≥ÁäòÁäöÁçòÁçíÁçûÁçüÁç†ÁçùÁçõÁç°ÁçöÁçô"],["e6a1","Áç¢ÁíáÁíâÁíäÁíÜÁíÅÁëΩÁíÖÁíàÁëºÁëπÁîàÁîáÁïæÁò•ÁòûÁòôÁòùÁòúÁò£ÁòöÁò®ÁòõÁöúÁöùÁöûÁöõÁûçÁûèÁûâÁûàÁ£çÁ¢ªÁ£èÁ£åÁ£ëÁ£éÁ£îÁ£àÁ£ÉÁ£ÑÁ£âÁ¶öÁ¶°Á¶†Á¶úÁ¶¢Á¶õÊ≠∂Á®πÁ™≤Á™¥Á™≥ÁÆ∑ÁØãÁÆæÁÆ¨ÁØéÁÆØÁÆπÁØäÁÆµÁ≥ÖÁ≥àÁ≥åÁ≥ãÁ∑∑Á∑õÁ∑™Á∑ßÁ∑óÁ∑°Á∏ÉÁ∑∫Á∑¶Á∑∂Á∑±Á∑∞Á∑ÆÁ∑üÁΩ∂Áæ¨Áæ∞Áæ≠Áø≠Áø´Áø™Áø¨Áø¶Áø®ËÅ§ËÅßËÜ£ËÜü"],["e740","ËÜûËÜïËÜ¢ËÜôËÜóËàñËâèËâìËâíËâêËâéËâëËî§ËîªËîèËîÄËî©ËîéËîâËîçËîüËîäËîßËîúËìªËî´Ëì∫ËîàËîåËì¥Ëî™Ëì≤ËîïËì∑Ëì´Ëì≥ËìºËîíËì™Ëì©ËîñËìæËî®ËîùËîÆËîÇËìΩËîûËì∂Ëî±Ëî¶ËìßËì®Ëì∞ËìØËìπËîòËî†Ëî∞ËîãËîôËîØËô¢"],["e7a1","ËùñËù£Ëù§Ëù∑Ëü°Ëù≥ËùòËùîËùõËùíËù°ËùöËùëËùûËù≠Ëù™ËùêËùéËùüËùùËùØËù¨Ëù∫ËùÆËùúËù•ËùèËùªËùµËù¢ËùßËù©Ë°öË§ÖË§åË§îË§ãË§óË§òË§ôË§ÜË§ñË§ëË§éË§âË¶¢Ë¶§Ë¶£Ëß≠Ëß∞Ëß¨Ë´èË´ÜË™∏Ë´ìË´ëË´îË´ïË™ªË´óË™æË´ÄË´ÖË´òË´ÉË™∫Ë™ΩË´ôË∞æË±çË≤èË≥•Ë≥üË≥ôË≥®Ë≥öË≥ùË≥ßË∂†Ë∂úË∂°Ë∂õË∏†Ë∏£Ë∏•Ë∏§Ë∏ÆË∏ïË∏õË∏ñË∏ëË∏ôË∏¶Ë∏ß"],["e840","Ë∏îË∏íË∏òË∏ìË∏úË∏óË∏öËº¨Ëº§ËºòËºöËº†Ëº£ËºñËºóÈÅ≥ÈÅ∞ÈÅØÈÅßÈÅ´ÈÑØÈÑ´ÈÑ©ÈÑ™ÈÑ≤ÈÑ¶ÈÑÆÈÜÖÈÜÜÈÜäÈÜÅÈÜÇÈÜÑÈÜÄÈãêÈãÉÈãÑÈãÄÈãôÈä∂ÈãèÈã±ÈãüÈãòÈã©ÈãóÈãùÈãåÈãØÈãÇÈã®ÈãäÈãàÈãéÈã¶ÈãçÈãïÈãâÈã†ÈãûÈãßÈãëÈãì"],["e8a1","ÈäµÈã°ÈãÜÈä¥ÈïºÈñ¨Èñ´ÈñÆÈñ∞Èö§Èö¢ÈõìÈúÖÈúàÈúÇÈùöÈûäÈûéÈûàÈüêÈüèÈ†ûÈ†ùÈ†¶È†©È†®È††È†õÈ†ßÈ¢≤È§àÈ£∫È§ëÈ§îÈ§ñÈ§óÈ§ïÈßúÈßçÈßèÈßìÈßîÈßéÈßâÈßñÈßòÈßãÈßóÈßåÈ™≥È´¨È´´È´≥È´≤È´±È≠ÜÈ≠ÉÈ≠ßÈ≠¥È≠±È≠¶È≠∂È≠µÈ≠∞È≠®È≠§È≠¨È≥ºÈ≥∫È≥ΩÈ≥øÈ≥∑È¥áÈ¥ÄÈ≥πÈ≥ªÈ¥àÈ¥ÖÈ¥ÑÈ∫ÉÈªìÈºèÈºêÂÑúÂÑìÂÑóÂÑöÂÑëÂáûÂå¥Âè°Âô∞Âô†ÂôÆ"],["e940","Âô≥Âô¶Âô£Âô≠Âô≤ÂôûÂô∑ÂúúÂúõÂ£àÂ¢ΩÂ£âÂ¢øÂ¢∫Â£ÇÂ¢ºÂ£ÜÂ¨óÂ¨ôÂ¨õÂ¨°Â¨îÂ¨ìÂ¨êÂ¨ñÂ¨®Â¨öÂ¨†Â¨ûÂØØÂ∂¨Â∂±Â∂©Â∂ßÂ∂µÂ∂∞Â∂ÆÂ∂™Â∂®Â∂≤Â∂≠Â∂ØÂ∂¥ÂπßÂπ®Âπ¶ÂπØÂª©ÂªßÂª¶Âª®Âª•ÂΩãÂæºÊÜùÊÜ®ÊÜñÊáÖÊÜ¥ÊáÜÊáÅÊáåÊÜ∫"],["e9a1","ÊÜøÊÜ∏ÊÜåÊìóÊìñÊìêÊìèÊìâÊíΩÊíâÊìÉÊìõÊì≥ÊìôÊî≥ÊïøÊïºÊñ¢ÊõàÊöæÊõÄÊõäÊõãÊõèÊöΩÊöªÊö∫ÊõåÊú£Ê®¥Ê©¶Ê©âÊ©ßÊ®≤Ê©®Ê®æÊ©ùÊ©≠Ê©∂Ê©õÊ©ëÊ®®Ê©öÊ®ªÊ®øÊ©ÅÊ©™Ê©§Ê©êÊ©èÊ©îÊ©ØÊ©©Ê©†Ê®ºÊ©ûÊ©ñÊ©ïÊ©çÊ©éÊ©ÜÊ≠ïÊ≠îÊ≠ñÊÆßÊÆ™ÊÆ´ÊØàÊØáÊ∞ÑÊ∞ÉÊ∞ÜÊæ≠ÊøãÊæ£ÊøáÊæºÊøéÊøàÊΩûÊøÑÊæΩÊæûÊøäÊæ®ÁÄÑÊæ•ÊæÆÊæ∫Êæ¨Êæ™ÊøèÊæøÊæ∏"],["ea40","Êæ¢ÊøâÊæ´ÊøçÊæØÊæ≤Êæ∞ÁáÖÁáÇÁÜøÁÜ∏ÁáñÁáÄÁáÅÁáãÁáîÁáäÁááÁáèÁÜΩÁáòÁÜºÁáÜÁáöÁáõÁäùÁäûÁç©Áç¶ÁçßÁç¨Áç•Áç´Áç™ÁëøÁíöÁí†ÁíîÁííÁíïÁí°ÁîãÁñÄÁòØÁò≠Áò±ÁòΩÁò≥ÁòºÁòµÁò≤Áò∞ÁöªÁõ¶ÁûöÁûùÁû°ÁûúÁûõÁû¢Áû£ÁûïÁûô"],["eaa1","ÁûóÁ£ùÁ£©Á£•Á£™Á£ûÁ££Á£õÁ£°Á£¢Á£≠Á£üÁ£†Á¶§Á©ÑÁ©àÁ©áÁ™∂Á™∏Á™µÁ™±Á™∑ÁØûÁØ£ÁØßÁØùÁØïÁØ•ÁØöÁØ®ÁØπÁØîÁØ™ÁØ¢ÁØúÁØ´ÁØòÁØüÁ≥íÁ≥îÁ≥óÁ≥êÁ≥ëÁ∏íÁ∏°Á∏óÁ∏åÁ∏üÁ∏†Á∏ìÁ∏éÁ∏úÁ∏ïÁ∏öÁ∏¢Á∏ãÁ∏èÁ∏ñÁ∏çÁ∏îÁ∏•Á∏§ÁΩÉÁΩªÁΩºÁΩ∫Áæ±ÁøØËÄ™ËÄ©ËÅ¨ËÜ±ËÜ¶ËÜÆËÜπËÜµËÜ´ËÜ∞ËÜ¨ËÜ¥ËÜ≤ËÜ∑ËÜßËá≤ËâïËâñËâóËïñËïÖËï´ËïçËïìËï°Ëïò"],["eb40","ËïÄËïÜËï§ËïÅËï¢ËïÑËïëËïáËï£ËîæËïõËï±ËïéËïÆËïµËïïËïßËï†ËñåËï¶ËïùËïîËï•Ëï¨Ëô£Ëô•Ëô§ËûõËûèËûóËûìËûíËûàËûÅËûñËûòËùπËûáËû£ËûÖËûêËûëËûùËûÑËûîËûúËûöËûâË§ûË§¶Ë§∞Ë§≠Ë§ÆË§ßË§±Ë§¢Ë§©Ë§£Ë§ØË§¨Ë§üËß±Ë´†"],["eba1","Ë´¢Ë´≤Ë´¥Ë´µË´ùË¨îË´§Ë´üË´∞Ë´àË´ûË´°Ë´®Ë´øË´ØË´ªË≤ëË≤íË≤êË≥µË≥ÆË≥±Ë≥∞Ë≥≥Ëµ¨ËµÆË∂•Ë∂ßË∏≥Ë∏æË∏∏ËπÄËπÖË∏∂Ë∏ºË∏ΩËπÅË∏∞Ë∏øË∫ΩËº∂ËºÆËºµËº≤ËºπËº∑Ëº¥ÈÅ∂ÈÅπÈÅªÈÇÜÈÉ∫ÈÑ≥ÈÑµÈÑ∂ÈÜìÈÜêÈÜëÈÜçÈÜèÈåßÈåûÈåàÈåüÈåÜÈåèÈç∫Èå∏ÈåºÈåõÈå£ÈåíÈåÅÈçÜÈå≠ÈåéÈåçÈããÈåùÈã∫Èå•ÈåìÈãπÈã∑Èå¥ÈåÇÈå§ÈãøÈå©ÈåπÈåµÈå™ÈåîÈåå"],["ec40","ÈåãÈãæÈåâÈåÄÈãªÈåñÈñºÈóçÈñæÈñπÈñ∫Èñ∂ÈñøÈñµÈñΩÈö©ÈõîÈúãÈúíÈúêÈûôÈûóÈûîÈü∞Èü∏È†µÈ†ØÈ†≤È§§È§üÈ§ßÈ§©È¶ûÈßÆÈß¨Èß•Èß§Èß∞Èß£Èß™Èß©ÈßßÈ™πÈ™øÈ™¥È™ªÈ´∂È´∫È´πÈ´∑È¨≥ÈÆÄÈÆÖÈÆáÈ≠ºÈ≠æÈ≠ªÈÆÇÈÆìÈÆíÈÆêÈ≠∫ÈÆï"],["eca1","È≠ΩÈÆàÈ¥•È¥óÈ¥†È¥ûÈ¥îÈ¥©È¥ùÈ¥òÈ¥¢È¥êÈ¥ôÈ¥üÈ∫àÈ∫ÜÈ∫áÈ∫ÆÈ∫≠ÈªïÈªñÈª∫ÈºíÈºΩÂÑ¶ÂÑ•ÂÑ¢ÂÑ§ÂÑ†ÂÑ©Âã¥ÂöìÂöåÂöçÂöÜÂöÑÂöÉÂôæÂöÇÂôøÂöÅÂ£ñÂ£îÂ£èÂ£íÂ¨≠Â¨•Â¨≤Â¨£Â¨¨Â¨ßÂ¨¶Â¨ØÂ¨ÆÂ≠ªÂØ±ÂØ≤Â∂∑Âπ¨Âπ™ÂææÂæªÊáÉÊÜµÊÜºÊáßÊá†Êá•Êá§Êá®ÊáûÊìØÊì©Êì£Êì´Êì§Êì®ÊñÅÊñÄÊñ∂ÊóöÊõíÊ™çÊ™ñÊ™ÅÊ™•Ê™âÊ™üÊ™õÊ™°Ê™ûÊ™áÊ™ìÊ™é"],["ed40","Ê™ïÊ™ÉÊ™®Ê™§Ê™ëÊ©øÊ™¶Ê™öÊ™ÖÊ™åÊ™íÊ≠õÊÆ≠Ê∞âÊøåÊæ©Êø¥ÊøîÊø£ÊøúÊø≠ÊøßÊø¶ÊøûÊø≤ÊøùÊø¢Êø®Áá°Áá±Áá®Áá≤Áá§Áá∞Áá¢Áç≥ÁçÆÁçØÁíóÁí≤Áí´ÁíêÁí™Áí≠Áí±Áí•ÁíØÁîêÁîëÁîíÁîèÁñÑÁôÉÁôàÁôâÁôáÁö§Áõ©ÁûµÁû´Áû≤Áû∑Áû∂"],["eda1","Áû¥Áû±Áû®Áü∞Á£≥Á£ΩÁ§ÇÁ£ªÁ£ºÁ£≤Á§ÖÁ£πÁ£æÁ§ÑÁ¶´Á¶®Á©úÁ©õÁ©ñÁ©òÁ©îÁ©öÁ™æÁ´ÄÁ´ÅÁ∞ÖÁ∞èÁØ≤Á∞ÄÁØøÁØªÁ∞éÁØ¥Á∞ãÁØ≥Á∞ÇÁ∞âÁ∞ÉÁ∞ÅÁØ∏ÁØΩÁ∞ÜÁØ∞ÁØ±Á∞êÁ∞äÁ≥®Á∏≠Á∏ºÁπÇÁ∏≥È°àÁ∏∏Á∏™ÁπâÁπÄÁπáÁ∏©ÁπåÁ∏∞Á∏ªÁ∏∂ÁπÑÁ∏∫ÁΩÖÁΩøÁΩæÁΩΩÁø¥Áø≤ËÄ¨ËÜªËáÑËáåËáäËáÖËááËÜºËá©ËâõËâöËâúËñÉËñÄËñèËñßËñïËñ†ËñãËñ£ËïªËñ§ËñöËñû"],["ee40","Ëï∑ËïºËñâËñ°Ëï∫Ëï∏ËïóËñéËññËñÜËñçËñôËñùËñÅËñ¢ËñÇËñàËñÖËïπËï∂ËñòËñêËñüËô®ËûæËû™Ëû≠ËüÖËû∞Ëû¨ËûπËûµËûºËûÆËüâËüÉËüÇËüåËû∑ËûØËüÑËüäËû¥Ëû∂ËûøËû∏ËûΩËüûËû≤Ë§µË§≥Ë§ºË§æË•ÅË•íË§∑Ë•ÇË¶≠Ë¶ØË¶ÆËß≤Ëß≥Ë¨û"],["eea1","Ë¨òË¨ñË¨ëË¨ÖË¨ãË¨¢Ë¨èË¨íË¨ïË¨áË¨çË¨àË¨ÜË¨úË¨ìË¨öË±èË±∞Ë±≤Ë±±Ë±ØË≤ïË≤îË≥πËµØËπéËπçËπìËπêËπåËπáËΩÉËΩÄÈÇÖÈÅæÈÑ∏ÈÜöÈÜ¢ÈÜõÈÜôÈÜüÈÜ°ÈÜùÈÜ†Èé°ÈéÉÈéØÈç§ÈçñÈçáÈçºÈçòÈçúÈç∂ÈçâÈçêÈçëÈç†Èç≠ÈéèÈçåÈç™ÈçπÈçóÈçïÈçíÈçèÈç±Èç∑ÈçªÈç°ÈçûÈç£ÈçßÈéÄÈçéÈçôÈóáÈóÄÈóâÈóÉÈóÖÈñ∑ÈöÆÈö∞Èö¨Èú†ÈúüÈúòÈúùÈúôÈûöÈû°Èûú"],["ef40","ÈûûÈûùÈüïÈüîÈü±È°ÅÈ°ÑÈ°äÈ°âÈ°ÖÈ°ÉÈ§•È§´È§¨È§™È§≥È§≤È§ØÈ§≠È§±È§∞È¶òÈ¶£È¶°È®ÇÈß∫Èß¥Èß∑ÈßπÈß∏Èß∂ÈßªÈßΩÈßæÈßºÈ®ÉÈ™æÈ´æÈ´ΩÈ¨ÅÈ´ºÈ≠àÈÆöÈÆ®ÈÆûÈÆõÈÆ¶ÈÆ°ÈÆ•ÈÆ§ÈÆÜÈÆ¢ÈÆ†ÈÆØÈ¥≥ÈµÅÈµßÈ¥∂È¥ÆÈ¥ØÈ¥±È¥∏È¥∞"],["efa1","ÈµÖÈµÇÈµÉÈ¥æÈ¥∑ÈµÄÈ¥ΩÁøµÈ¥≠È∫äÈ∫âÈ∫çÈ∫∞ÈªàÈªöÈªªÈªøÈº§Èº£Èº¢ÈΩîÈæ†ÂÑ±ÂÑ≠ÂÑÆÂöòÂöúÂöóÂööÂöùÂöôÂ•∞Â¨ºÂ±©Â±™Â∑ÄÂπ≠ÂπÆÊáòÊáüÊá≠ÊáÆÊá±Êá™Êá∞Êá´ÊáñÊá©ÊìøÊîÑÊìΩÊì∏ÊîÅÊîÉÊìºÊñîÊóõÊõöÊõõÊõòÊ´ÖÊ™πÊ™ΩÊ´°Ê´ÜÊ™∫Ê™∂Ê™∑Ê´áÊ™¥Ê™≠Ê≠ûÊØâÊ∞ãÁÄáÁÄåÁÄçÁÄÅÁÄÖÁÄîÁÄéÊøøÁÄÄÊøªÁÄ¶ÊøºÊø∑ÁÄäÁàÅÁáøÁáπÁàÉÁáΩÁç∂"],["f040","Áí∏ÁìÄÁíµÁìÅÁíæÁí∂ÁíªÁìÇÁîîÁîìÁôúÁô§ÁôôÁôêÁôìÁôóÁôöÁö¶ÁöΩÁõ¨ÁüÇÁû∫Á£øÁ§åÁ§ìÁ§îÁ§âÁ§êÁ§íÁ§ëÁ¶≠Á¶¨Á©üÁ∞úÁ∞©Á∞ôÁ∞†Á∞üÁ∞≠Á∞ùÁ∞¶Á∞®Á∞¢Á∞•Á∞∞ÁπúÁπêÁπñÁπ£ÁπòÁπ¢ÁπüÁπëÁπ†ÁπóÁπìÁæµÁæ≥Áø∑Áø∏ËÅµËáëËáí"],["f0a1","ËáêËâüËâûËñ¥ËóÜËóÄËóÉËóÇËñ≥ËñµËñΩËóáËóÑËñøËóãËóéËóàËóÖËñ±Ëñ∂ËóíËò§Ëñ∏Ëñ∑ËñæËô©ËüßËü¶Ëü¢ËüõËü´Ëü™Ëü•ËüüËü≥Ëü§ËüîËüúËüìËü≠ËüòËü£Ëû§ËüóËüôË†ÅËü¥Ëü®ËüùË•ìË•ãË•èË•åË•ÜË•êË•ëË•âË¨™Ë¨ßË¨£Ë¨≥Ë¨∞Ë¨µË≠áË¨ØË¨ºË¨æË¨±Ë¨•Ë¨∑Ë¨¶Ë¨∂Ë¨ÆË¨§Ë¨ªË¨ΩË¨∫Ë±ÇË±µË≤ôË≤òË≤óË≥æË¥ÑË¥ÇË¥ÄËπúËπ¢Ëπ†ËπóËπñËπûËπ•Ëπß"],["f140","ËπõËπöËπ°ËπùËπ©ËπîËΩÜËΩáËΩàËΩãÈÑ®ÈÑ∫ÈÑªÈÑæÈÜ®ÈÜ•ÈÜßÈÜØÈÜ™ÈéµÈéåÈéíÈé∑ÈéõÈéùÈéâÈéßÈééÈé™ÈéûÈé¶ÈéïÈéàÈéôÈéüÈéçÈé±ÈéëÈé≤Èé§Èé®Èé¥Èé£Èé•ÈóíÈóìÈóëÈö≥ÈõóÈõöÂ∑ÇÈõüÈõòÈõùÈú£Èú¢Èú•Èû¨ÈûÆÈû®Èû´Èû§Èû™"],["f1a1","Èû¢Èû•ÈüóÈüôÈüñÈüòÈü∫È°êÈ°ëÈ°íÈ¢∏È•ÅÈ§ºÈ§∫È®èÈ®ãÈ®âÈ®çÈ®ÑÈ®ëÈ®äÈ®ÖÈ®áÈ®ÜÈ´ÄÈ´úÈ¨àÈ¨ÑÈ¨ÖÈ¨©È¨µÈ≠äÈ≠åÈ≠ãÈØáÈØÜÈØÉÈÆøÈØÅÈÆµÈÆ∏ÈØìÈÆ∂ÈØÑÈÆπÈÆΩÈµúÈµìÈµèÈµäÈµõÈµãÈµôÈµñÈµåÈµóÈµíÈµîÈµüÈµòÈµöÈ∫éÈ∫åÈªüÈºÅÈºÄÈºñÈº•Èº´Èº™Èº©Èº®ÈΩåÈΩïÂÑ¥ÂÑµÂäñÂã∑Âé¥Âö´Âö≠Âö¶ÂößÂö™Âö¨Â£öÂ£ùÂ£õÂ§íÂ¨ΩÂ¨æÂ¨øÂ∑ÉÂπ∞"],["f240","ÂæøÊáªÊîáÊîêÊîçÊîâÊîåÊîéÊñÑÊóûÊóùÊõûÊ´ßÊ´†Ê´åÊ´ëÊ´ôÊ´ãÊ´üÊ´úÊ´êÊ´´Ê´èÊ´çÊ´ûÊ≠†ÊÆ∞Ê∞åÁÄôÁÄßÁÄ†ÁÄñÁÄ´ÁÄ°ÁÄ¢ÁÄ£ÁÄ©ÁÄóÁÄ§ÁÄúÁÄ™ÁàåÁàäÁàáÁàÇÁàÖÁä•Áä¶Áä§Áä£Áä°ÁìãÁìÖÁí∑ÁìÉÁîñÁô†ÁüâÁüäÁüÑÁü±Á§ùÁ§õ"],["f2a1","Á§°Á§úÁ§óÁ§ûÁ¶∞Á©ßÁ©®Á∞≥Á∞ºÁ∞πÁ∞¨Á∞ªÁ≥¨Á≥™Áπ∂ÁπµÁπ∏Áπ∞Áπ∑ÁπØÁπ∫Áπ≤Áπ¥Áπ®ÁΩãÁΩäÁæÉÁæÜÁæ∑ÁøΩÁøæËÅ∏ËáóËáïËâ§Ëâ°Ëâ£Ëó´Ëó±Ëó≠ËóôËó°Ëó®ËóöËóóËó¨Ëó≤Ëó∏ËóòËóüËó£ËóúËóëËó∞Ëó¶ËóØËóûËó¢Ë†ÄËü∫Ë†ÉËü∂Ëü∑Ë†âË†åË†ãË†ÜËüºË†àËüøË†äË†ÇË•¢Ë•öË•õË•óË•°Ë•úË•òË•ùË•ôË¶àË¶∑Ë¶∂Ëß∂Ë≠êË≠àË≠äË≠ÄË≠ìË≠ñË≠îË≠ãË≠ï"],["f340","Ë≠ëË≠ÇË≠íË≠óË±ÉË±∑Ë±∂Ë≤öË¥ÜË¥áË¥âË∂¨Ë∂™Ë∂≠Ë∂´Ëπ≠Ëπ∏Ëπ≥Ëπ™ËπØËπªËªÇËΩíËΩëËΩèËΩêËΩìËæ¥ÈÖÄÈÑøÈÜ∞ÈÜ≠ÈèûÈèáÈèèÈèÇÈèöÈèêÈèπÈè¨ÈèåÈèôÈé©Èè¶ÈèäÈèîÈèÆÈè£ÈèïÈèÑÈèéÈèÄÈèíÈèßÈïΩÈóöÈóõÈõ°Èú©Èú´Èú¨Èú®Èú¶"],["f3a1","Èû≥Èû∑Èû∂ÈüùÈüûÈüüÈ°úÈ°ôÈ°ùÈ°óÈ¢øÈ¢ΩÈ¢ªÈ¢æÈ•àÈ•áÈ•ÉÈ¶¶È¶ßÈ®öÈ®ïÈ®•È®ùÈ®§È®õÈ®¢È®†È®ßÈ®£È®ûÈ®úÈ®îÈ´ÇÈ¨ãÈ¨äÈ¨éÈ¨åÈ¨∑ÈØ™ÈØ´ÈØ†ÈØûÈØ§ÈØ¶ÈØ¢ÈØ∞ÈØîÈØóÈØ¨ÈØúÈØôÈØ•ÈØïÈØ°ÈØöÈµ∑È∂ÅÈ∂äÈ∂ÑÈ∂àÈµ±È∂ÄÈµ∏È∂ÜÈ∂ãÈ∂åÈµΩÈµ´Èµ¥ÈµµÈµ∞Èµ©È∂ÖÈµ≥ÈµªÈ∂ÇÈµØÈµπÈµøÈ∂áÈµ®È∫îÈ∫ëÈªÄÈªºÈº≠ÈΩÄÈΩÅÈΩçÈΩñÈΩóÈΩòÂå∑Âö≤"],["f440","ÂöµÂö≥Â££Â≠ÖÂ∑ÜÂ∑áÂªÆÂªØÂøÄÂøÅÊáπÊîóÊîñÊîïÊîìÊóüÊõ®Êõ£Êõ§Ê´≥Ê´∞Ê´™Ê´®Ê´πÊ´±Ê´ÆÊ´ØÁÄºÁÄµÁÄØÁÄ∑ÁÄ¥ÁÄ±ÁÅÇÁÄ∏ÁÄøÁÄ∫ÁÄπÁÅÄÁÄªÁÄ≥ÁÅÅÁàìÁàîÁä®ÁçΩÁçºÁí∫Áö´Áö™ÁöæÁõ≠ÁüåÁüéÁüèÁüçÁü≤Á§•Á§£Á§ßÁ§®Á§§Á§©"],["f4a1","Á¶≤Á©ÆÁ©¨Á©≠Á´∑Á±âÁ±àÁ±äÁ±áÁ±ÖÁ≥ÆÁπªÁπæÁ∫ÅÁ∫ÄÁæ∫ÁøøËÅπËáõËáôËàãËâ®Ëâ©Ëò¢ËóøËòÅËóæËòõËòÄËó∂ËòÑËòâËòÖËòåËóΩË†ôË†êË†ëË†óË†ìË†ñË•£Ë•¶Ë¶πËß∑Ë≠†Ë≠™Ë≠ùË≠®Ë≠£Ë≠•Ë≠ßË≠≠Ë∂ÆË∫ÜË∫àË∫ÑËΩôËΩñËΩóËΩïËΩòËΩöÈÇçÈÖÉÈÖÅÈÜ∑ÈÜµÈÜ≤ÈÜ≥ÈêãÈêìÈèªÈê†ÈêèÈêîÈèæÈêïÈêêÈê®ÈêôÈêçÈèµÈêÄÈè∑ÈêáÈêéÈêñÈêíÈè∫ÈêâÈè∏ÈêäÈèø"],["f540","ÈèºÈêåÈè∂ÈêëÈêÜÈóûÈó†ÈóüÈúÆÈúØÈûπÈûªÈüΩÈüæÈ°†È°¢È°£È°üÈ£ÅÈ£ÇÈ•êÈ•éÈ•ôÈ•åÈ•ãÈ•ìÈ®≤È®¥È®±È®¨È®™È®∂È®©È®ÆÈ®∏È®≠È´áÈ´äÈ´ÜÈ¨êÈ¨íÈ¨ëÈ∞ãÈ∞àÈØ∑È∞ÖÈ∞íÈØ∏È±ÄÈ∞áÈ∞éÈ∞ÜÈ∞óÈ∞îÈ∞âÈ∂üÈ∂ôÈ∂§È∂ùÈ∂íÈ∂òÈ∂êÈ∂õ"],["f5a1","È∂†È∂îÈ∂úÈ∂™È∂óÈ∂°È∂öÈ∂¢È∂®È∂ûÈ∂£È∂øÈ∂©È∂ñÈ∂¶È∂ßÈ∫ôÈ∫õÈ∫öÈª•Èª§ÈªßÈª¶Èº∞ÈºÆÈΩõÈΩ†ÈΩûÈΩùÈΩôÈæëÂÑ∫ÂÑπÂäòÂäóÂõÉÂöΩÂöæÂ≠àÂ≠áÂ∑ãÂ∑èÂª±ÊáΩÊîõÊ¨ÇÊ´ºÊ¨ÉÊ´∏Ê¨ÄÁÅÉÁÅÑÁÅäÁÅàÁÅâÁÅÖÁÅÜÁàùÁàöÁàôÁçæÁîóÁô™ÁüêÁ§≠Á§±Á§ØÁ±îÁ±ìÁ≥≤Á∫äÁ∫áÁ∫àÁ∫ãÁ∫ÜÁ∫çÁΩçÁæªËÄ∞ËáùËòòËò™Ëò¶ËòüËò£ËòúËòôËòßËòÆËò°Ëò†Ëò©ËòûËò•"],["f640","Ë†©Ë†ùË†õË††Ë†§Ë†úË†´Ë°äË•≠Ë•©Ë•ÆË•´Ëß∫Ë≠πË≠∏Ë≠ÖË≠∫Ë≠ªË¥êË¥îË∂ØË∫éË∫åËΩûËΩõËΩùÈÖÜÈÖÑÈÖÖÈÜπÈêøÈêªÈê∂Èê©ÈêΩÈêºÈê∞ÈêπÈê™Èê∑Èê¨ÈëÄÈê±Èó•Èó§Èó£ÈúµÈú∫ÈûøÈü°È°§È£âÈ£ÜÈ£ÄÈ•òÈ•ñÈ®πÈ®ΩÈ©ÜÈ©ÑÈ©ÇÈ©ÅÈ®∫"],["f6a1","È®øÈ´çÈ¨ïÈ¨óÈ¨òÈ¨ñÈ¨∫È≠íÈ∞´È∞ùÈ∞úÈ∞¨È∞£È∞®È∞©È∞§È∞°È∂∑È∂∂È∂ºÈ∑ÅÈ∑áÈ∑äÈ∑èÈ∂æÈ∑ÖÈ∑ÉÈ∂ªÈ∂µÈ∑éÈ∂πÈ∂∫È∂¨È∑àÈ∂±È∂≠È∑åÈ∂≥È∑çÈ∂≤Èπ∫È∫úÈª´ÈªÆÈª≠ÈºõÈºòÈºöÈº±ÈΩéÈΩ•ÈΩ§Èæí‰∫πÂõÜÂõÖÂõãÂ•±Â≠ãÂ≠åÂ∑ïÂ∑ëÂª≤Êî°Êî†Êî¶Êî¢Ê¨ãÊ¨àÊ¨âÊ∞çÁÅïÁÅñÁÅóÁÅíÁàûÁàüÁä©ÁçøÁìòÁìïÁìôÁìóÁô≠Áö≠Á§µÁ¶¥Á©∞Á©±Á±óÁ±úÁ±ôÁ±õÁ±ö"],["f740","Á≥¥Á≥±Á∫ëÁΩèÁæáËáûËâ´Ëò¥ËòµËò≥Ëò¨Ëò≤Ëò∂Ë†¨Ë†®Ë†¶Ë†™Ë†•Ë•±Ë¶øË¶æËßªË≠æËÆÑËÆÇËÆÜËÆÖË≠øË¥ïË∫ïË∫îË∫öË∫íË∫êË∫ñË∫óËΩ†ËΩ¢ÈÖáÈëåÈëêÈëäÈëãÈëèÈëáÈëÖÈëàÈëâÈëÜÈúøÈü£È°™È°©È£ãÈ•îÈ•õÈ©éÈ©ìÈ©îÈ©åÈ©èÈ©àÈ©ä"],["f7a1","È©âÈ©íÈ©êÈ´êÈ¨ôÈ¨´È¨ªÈ≠ñÈ≠ïÈ±ÜÈ±àÈ∞øÈ±ÑÈ∞πÈ∞≥È±ÅÈ∞ºÈ∞∑È∞¥È∞≤È∞ΩÈ∞∂È∑õÈ∑íÈ∑ûÈ∑öÈ∑ãÈ∑êÈ∑úÈ∑ëÈ∑üÈ∑©È∑ôÈ∑òÈ∑ñÈ∑µÈ∑ïÈ∑ùÈ∫∂Èª∞ÈºµÈº≥Èº≤ÈΩÇÈΩ´ÈæïÈæ¢ÂÑΩÂäôÂ£®Â£ßÂ•≤Â≠çÂ∑òË†ØÂΩèÊàÅÊàÉÊàÑÊî©Êî•ÊññÊõ´Ê¨ëÊ¨íÊ¨èÊØäÁÅõÁÅöÁà¢ÁéÇÁéÅÁéÉÁô∞ÁüîÁ±ßÁ±¶Á∫ïËâ¨Ëò∫ËôÄËòπËòºËò±ËòªËòæË†∞Ë†≤Ë†ÆË†≥Ë•∂Ë•¥Ë•≥Ëßæ"],["f840","ËÆåËÆéËÆãËÆàË±ÖË¥ôË∫òËΩ§ËΩ£ÈÜºÈë¢ÈëïÈëùÈëóÈëûÈüÑÈüÖÈ†ÄÈ©ñÈ©ôÈ¨ûÈ¨üÈ¨†È±íÈ±òÈ±êÈ±äÈ±çÈ±ãÈ±ïÈ±ôÈ±åÈ±éÈ∑ªÈ∑∑È∑ØÈ∑£È∑´È∑∏È∑§È∑∂È∑°È∑ÆÈ∑¶È∑≤È∑∞È∑¢È∑¨È∑¥È∑≥È∑®È∑≠ÈªÇÈªêÈª≤Èª≥ÈºÜÈºúÈº∏Èº∑Èº∂ÈΩÉÈΩè"],["f8a1","ÈΩ±ÈΩ∞ÈΩÆÈΩØÂõìÂõçÂ≠éÂ±≠Êî≠Êõ≠ÊõÆÊ¨ìÁÅüÁÅ°ÁÅùÁÅ†Áà£ÁìõÁì•ÁüïÁ§∏Á¶∑Á¶∂Á±™Á∫óÁæâËâ≠ËôÉË†∏Ë†∑Ë†µË°ãËÆîËÆïË∫ûË∫üË∫†Ë∫ùÈÜæÈÜΩÈáÇÈë´Èë®Èë©Èõ•ÈùÜÈùÉÈùáÈüáÈü•È©ûÈ´ïÈ≠ôÈ±£È±ßÈ±¶È±¢È±ûÈ±†È∏ÇÈ∑æÈ∏áÈ∏ÉÈ∏ÜÈ∏ÖÈ∏ÄÈ∏ÅÈ∏âÈ∑øÈ∑ΩÈ∏ÑÈ∫†ÈºûÈΩÜÈΩ¥ÈΩµÈΩ∂ÂõîÊîÆÊñ∏Ê¨òÊ¨ôÊ¨óÊ¨öÁÅ¢Áà¶Áä™ÁüòÁüôÁ§πÁ±©Á±´Á≥∂Á∫ö"],["f940","Á∫òÁ∫õÁ∫ôËá†Ëá°ËôÜËôáËôàË•πË•∫Ë•ºË•ªËßøËÆòËÆôË∫•Ë∫§Ë∫£ÈëÆÈë≠ÈëØÈë±Èë≥ÈùâÈ°≤È•üÈ±®È±ÆÈ±≠È∏ãÈ∏çÈ∏êÈ∏èÈ∏íÈ∏ëÈ∫°ÈªµÈºâÈΩáÈΩ∏ÈΩªÈΩ∫ÈΩπÂúûÁÅ¶Á±ØË†ºË∂≤Ë∫¶ÈáÉÈë¥Èë∏Èë∂ÈëµÈ©†È±¥È±≥È±±È±µÈ∏îÈ∏ìÈª∂Èºä"],["f9a1","Èæ§ÁÅ®ÁÅ•Á≥∑Ëô™Ë†æË†ΩË†øËÆûË≤úË∫©ËªâÈùãÈ°≥È°¥È£åÈ•°È¶´È©§È©¶È©ßÈ¨§È∏ïÈ∏óÈΩàÊàáÊ¨ûÁàßËôåË∫®ÈíÇÈíÄÈíÅÈ©©È©®È¨ÆÈ∏ôÁà©ËôãËÆüÈíÉÈ±πÈ∫∑ÁôµÈ©´È±∫È∏ùÁÅ©ÁÅ™È∫§ÈΩæÈΩâÈæòÁ¢ÅÈäπË£èÂ¢ªÊÅíÁ≤ßÂ´∫‚ïî‚ï¶‚ïó‚ï†‚ï¨‚ï£‚ïö‚ï©‚ïù‚ïí‚ï§‚ïï‚ïû‚ï™‚ï°‚ïò‚ïß‚ïõ‚ïì‚ï•‚ïñ‚ïü‚ï´‚ï¢‚ïô‚ï®‚ïú‚ïë‚ïê‚ï≠‚ïÆ‚ï∞‚ïØ‚ñì"]]');

/***/ }),

/***/ 57185:
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('[["0","\\u0000",127],["8ea1","ÔΩ°",62],["a1a1","„ÄÄ„ÄÅ„ÄÇÔºåÔºé„ÉªÔºöÔºõÔºüÔºÅ„Çõ„Çú¬¥ÔΩÄ¬®ÔºæÔø£Ôºø„ÉΩ„Éæ„Çù„Çû„ÄÉ‰ªù„ÄÖ„ÄÜ„Äá„Éº‚Äï‚ÄêÔºèÔººÔΩû‚à•ÔΩú‚Ä¶‚Ä•‚Äò‚Äô‚Äú‚ÄùÔºàÔºâ„Äî„ÄïÔºªÔºΩÔΩõÔΩù„Äà",9,"ÔºãÔºç¬±√ó√∑Ôºù‚â†ÔºúÔºû‚â¶‚âß‚àû‚à¥‚ôÇ‚ôÄ¬∞‚Ä≤‚Ä≥‚ÑÉÔø•ÔºÑÔø†Ôø°ÔºÖÔºÉÔºÜÔºäÔº†¬ß‚òÜ‚òÖ‚óã‚óè‚óé‚óá"],["a2a1","‚óÜ‚ñ°‚ñ†‚ñ≥‚ñ≤‚ñΩ‚ñº‚Äª„Äí‚Üí‚Üê‚Üë‚Üì„Äì"],["a2ba","‚àà‚àã‚äÜ‚äá‚äÇ‚äÉ‚à™‚à©"],["a2ca","‚àß‚à®Ôø¢‚áí‚áî‚àÄ‚àÉ"],["a2dc","‚à†‚ä•‚åí‚àÇ‚àá‚â°‚âí‚â™‚â´‚àö‚àΩ‚àù‚àµ‚à´‚à¨"],["a2f2","‚Ñ´‚Ä∞‚ôØ‚ô≠‚ô™‚Ä†‚Ä°¬∂"],["a2fe","‚óØ"],["a3b0","Ôºê",9],["a3c1","Ôº°",25],["a3e1","ÔΩÅ",25],["a4a1","„ÅÅ",82],["a5a1","„Ç°",85],["a6a1","Œë",16,"Œ£",6],["a6c1","Œ±",16,"œÉ",6],["a7a1","–ê",5,"–Å–ñ",25],["a7d1","–∞",5,"—ë–∂",25],["a8a1","‚îÄ‚îÇ‚îå‚îê‚îò‚îî‚îú‚î¨‚î§‚î¥‚îº‚îÅ‚îÉ‚îè‚îì‚îõ‚îó‚î£‚î≥‚î´‚îª‚ïã‚î†‚îØ‚î®‚î∑‚îø‚îù‚î∞‚î•‚î∏‚ïÇ"],["ada1","‚ë†",19,"‚Ö†",9],["adc0","„çâ„åî„å¢„çç„åò„åß„åÉ„å∂„çë„çó„åç„å¶„å£„å´„çä„åª„éú„éù„éû„éé„éè„èÑ„é°"],["addf","„çª„Äù„Äü‚Ññ„èç‚Ñ°„ä§",4,"„à±„à≤„àπ„çæ„çΩ„çº‚âí‚â°‚à´‚àÆ‚àë‚àö‚ä•‚à†‚àü‚äø‚àµ‚à©‚à™"],["b0a1","‰∫úÂîñÂ®ÉÈòøÂìÄÊÑõÊå®Âß∂ÈÄ¢ËëµËåúÁ©êÊÇ™Êè°Ê∏•Êó≠Ëë¶Ëä¶ÈØµÊ¢ìÂúßÊñ°Êâ±ÂÆõÂßêËôªÈ£¥Áµ¢Á∂æÈÆéÊàñÁ≤üË¢∑ÂÆâÂ∫µÊåâÊöóÊ°àÈóáÈûçÊùè‰ª•‰ºä‰Ωç‰æùÂÅâÂõ≤Â§∑ÂßîÂ®ÅÂ∞âÊÉüÊÑèÊÖ∞ÊòìÊ§ÖÁÇ∫ÁïèÁï∞ÁßªÁ∂≠Á∑ØËÉÉËêéË°£Ë¨ÇÈÅïÈÅ∫Âåª‰∫ï‰∫•ÂüüËÇ≤ÈÉÅÁ£Ø‰∏ÄÂ£±Ê∫¢ÈÄ∏Á®≤Ëå®ËäãÈ∞ØÂÖÅÂç∞ÂíΩÂì°Âõ†ÂßªÂºïÈ£≤Ê∑´ËÉ§Ëî≠"],["b1a1","Èô¢Èô∞Èö†ÈüªÂêãÂè≥ÂÆáÁÉèÁæΩËøÇÈõ®ÂçØÈµúÁ™∫‰∏ëÁ¢ìËáºÊ∏¶ÂòòÂîÑÊ¨ùËîöÈ∞ªÂß•Âé©Êµ¶ÁìúÈñèÂôÇ‰∫ëÈÅãÈõ≤ËçèÈ§åÂè°Âñ∂Â¨∞ÂΩ±Êò†Êõ≥Ê†ÑÊ∞∏Ê≥≥Ê¥©ÁëõÁõàÁ©éÈ†¥Ëã±Ë°õË©†Èã≠Ê∂≤Áñ´ÁõäÈßÖÊÇ¶Ë¨ÅË∂äÈñ≤Ê¶éÂé≠ÂÜÜÂúíÂ†∞Â•ÑÂÆ¥Âª∂ÊÄ®Êé©Êè¥Ê≤øÊºîÁÇéÁÑîÁÖôÁáïÁåøÁ∏ÅËâ∂ËãëËñóÈÅ†ÈâõÈ¥õÂ°©ÊñºÊ±öÁî•ÂáπÂ§ÆÂ••ÂæÄÂøú"],["b2a1","ÊäºÊó∫Ê®™Ê¨ßÊÆ¥ÁéãÁøÅË•ñÈ¥¨È¥éÈªÑÂ≤°Ê≤ñËçªÂÑÑÂ±ãÊÜ∂ËáÜÊ°∂Áâ°‰πô‰ø∫Âç∏ÊÅ©Ê∏©Á©èÈü≥‰∏ãÂåñ‰ªÆ‰Ωï‰ºΩ‰æ°‰Ω≥Âä†ÂèØÂòâÂ§èÂ´ÅÂÆ∂ÂØ°ÁßëÊöáÊûúÊû∂Ê≠åÊ≤≥ÁÅ´ÁèÇÁ¶çÁ¶æÁ®ºÁÆáËä±ËãõËåÑËç∑ËèØËèìËù¶Ë™≤Âò©Ë≤®Ëø¶ÈÅéÈúûËöä‰øÑÂ≥®ÊàëÁâôÁîªËá•ËäΩËõæË≥ÄÈõÖÈ§ìÈßï‰ªã‰ºöËß£ÂõûÂ°äÂ£äÂªªÂø´ÊÄ™ÊÇîÊÅ¢ÊáêÊàíÊãêÊîπ"],["b3a1","È≠ÅÊô¶Ê¢∞Êµ∑ÁÅ∞ÁïåÁöÜÁµµËä•ËüπÈñãÈöéË≤ùÂá±ÂäæÂ§ñÂí≥ÂÆ≥Â¥ñÊÖ®Ê¶ÇÊ∂ØÁ¢çËìãË°óË©≤ÈéßÈ™∏Êµ¨È¶®ËõôÂû£ÊüøËõéÈàéÂäÉÂöáÂêÑÂªìÊã°ÊíπÊ†ºÊ†∏ÊÆªÁç≤Á¢∫Á©´Ë¶öËßíËµ´ËºÉÈÉ≠Èñ£ÈöîÈù©Â≠¶Â≤≥Ê•ΩÈ°çÈ°éÊéõÁ¨†Ê®´Ê©øÊ¢∂È∞çÊΩüÂâ≤ÂñùÊÅ∞Êã¨Ê¥ªÊ∏áÊªëËëõË§êËΩÑ‰∏îÈ∞πÂè∂Ê§õÊ®∫ÈûÑÊ†™ÂÖúÁ´ÉËí≤ÈáúÈéåÂôõÈ¥®Ê†¢ËåÖËê±"],["b4a1","Á≤•ÂààËãÖÁì¶‰πæ‰æÉÂÜ†ÂØíÂàäÂãòÂãßÂ∑ªÂñöÂ†™Âß¶ÂÆåÂÆòÂØõÂπ≤ÂππÊÇ£ÊÑüÊÖ£ÊÜæÊèõÊï¢ÊüëÊ°ìÊ£∫Ê¨æÊ≠ìÊ±óÊº¢ÊæóÊΩÖÁí∞ÁîòÁõ£ÁúãÁ´øÁÆ°Á∞°Á∑©Áº∂Áø∞ËÇùËâ¶ËéûË¶≥Ë´åË≤´ÈÇÑÈëëÈñìÈñëÈñ¢Èô•ÈüìÈ§®Ëàò‰∏∏Âê´Â≤∏Â∑åÁé©ÁôåÁúºÂ≤©Áø´Ë¥ãÈõÅÈ†ëÈ°îÈ°ò‰ºÅ‰ºéÂç±ÂñúÂô®Âü∫Â•áÂ¨âÂØÑÂ≤êÂ∏åÂπæÂøåÊèÆÊú∫ÊóóÊó¢ÊúüÊ£ãÊ£Ñ"],["b5a1","Ê©üÂ∏∞ÊØÖÊ∞óÊ±ΩÁïøÁ•àÂ≠£Á®ÄÁ¥ÄÂæΩË¶èË®òË≤¥Ëµ∑ËªåËºùÈ£¢È®éÈ¨º‰∫ÄÂÅΩÂÑÄÂ¶ìÂÆúÊàØÊäÄÊì¨Ê¨∫Áä†ÁñëÁ•áÁæ©ËüªË™ºË≠∞Êé¨ËèäÈû†ÂêâÂêÉÂñ´Ê°îÊ©òË©∞Á†ßÊùµÈªçÂç¥ÂÆ¢ËÑöËôêÈÄÜ‰∏ò‰πÖ‰ªá‰ºëÂèäÂê∏ÂÆÆÂºìÊÄ•ÊïëÊúΩÊ±ÇÊ±≤Ê≥£ÁÅ∏ÁêÉÁ©∂Á™ÆÁ¨àÁ¥öÁ≥æÁµ¶ÊóßÁâõÂéªÂ±ÖÂ∑®ÊãíÊã†ÊåôÊ∏†ËôöË®±Ë∑ùÈã∏ÊºÅÁ¶¶È≠ö‰∫®‰∫´‰∫¨"],["b6a1","‰æõ‰æ†ÂÉëÂÖáÁ´∂ÂÖ±Âá∂ÂçîÂå°ÂçøÂè´Âñ¨Â¢ÉÂ≥°Âº∑ÂΩäÊÄØÊÅêÊÅ≠ÊåüÊïôÊ©ãÊ≥ÅÁãÇÁã≠ÁüØËÉ∏ËÑÖËààËïéÈÉ∑Èè°ÈüøÈ•óÈ©ö‰ª∞ÂáùÂ∞≠ÊöÅÊ•≠Â±ÄÊõ≤Ê•µÁéâÊ°êÁ≤ÅÂÉÖÂã§ÂùáÂ∑æÈå¶Êñ§Ê¨£Ê¨ΩÁê¥Á¶ÅÁ¶ΩÁ≠ãÁ∑äËäπËèåË°øË•üË¨πËøëÈáëÂêüÈäÄ‰πùÂÄ∂Âè•Âå∫ÁãóÁéñÁü©Ëã¶Ë∫ØÈßÜÈßàÈßíÂÖ∑ÊÑöËôûÂñ∞Á©∫ÂÅ∂ÂØìÈÅáÈöÖ‰∏≤Ê´õÈáßÂ±ëÂ±à"],["b7a1","ÊéòÁ™üÊ≤ìÈù¥ËΩ°Á™™ÁÜäÈöàÁ≤ÇÊ†óÁπ∞Ê°ëÈç¨Âã≤ÂêõËñ´Ë®ìÁæ§ËªçÈÉ°Âç¶Ë¢àÁ•Å‰øÇÂÇæÂàëÂÖÑÂïìÂú≠Áè™ÂûãÂ•ëÂΩ¢ÂæÑÊÅµÊÖ∂ÊÖßÊÜ©Êé≤Êê∫Êï¨ÊôØÊ°ÇÊ∏ìÁï¶Á®ΩÁ≥ªÁµåÁ∂ôÁπãÁΩ´ËåéËçäËõçË®àË©£Ë≠¶ËªΩÈ†öÈ∂èËä∏ËøéÈØ®ÂäáÊàüÊíÉÊøÄÈöôÊ°ÅÂÇëÊ¨†Ê±∫ÊΩîÁ©¥ÁµêË°ÄË®£Êúà‰ª∂ÂÄπÂÄ¶ÂÅ•ÂÖºÂà∏Ââ£ÂñßÂúèÂ†ÖÂ´åÂª∫ÊÜ≤Êá∏Êã≥Êç≤"],["b8a1","Ê§úÊ®©ÁâΩÁä¨ÁåÆÁ†îÁ°ØÁµπÁúåËÇ©Ë¶ãË¨ôË≥¢ËªíÈÅ£ÈçµÈô∫È°ïÈ®ìÈπ∏ÂÖÉÂéüÂé≥ÂπªÂº¶Ê∏õÊ∫êÁéÑÁèæÁµÉËà∑Ë®ÄË´∫Èôê‰πéÂÄãÂè§ÂëºÂõ∫ÂßëÂ≠§Â∑±Â∫´ÂºßÊà∏ÊïÖÊûØÊπñÁãêÁ≥äË¢¥ËÇ°ËÉ°Ëè∞ËôéË™áË∑®Èà∑ÈõáÈ°ßÈºì‰∫î‰∫í‰ºçÂçàÂëâÂêæÂ®ØÂæåÂæ°ÊÇüÊ¢ßÊ™éÁëöÁ¢ÅË™ûË™§Ë≠∑ÈÜê‰πûÈØâ‰∫§‰Ωº‰æØÂÄôÂÄñÂÖâÂÖ¨ÂäüÂäπÂãæÂéöÂè£Âêë"],["b9a1","ÂêéÂñâÂùëÂû¢Â•ΩÂ≠îÂ≠ùÂÆèÂ∑•Â∑ßÂ∑∑Âπ∏Â∫ÉÂ∫öÂ∫∑ÂºòÊÅíÊÖåÊäóÊãòÊéßÊîªÊòÇÊôÉÊõ¥Êù≠Ê†°Ê¢óÊßãÊ±üÊ¥™Êµ©Ê∏ØÊ∫ùÁî≤ÁöáÁ°¨Á®øÁ≥†Á¥ÖÁ¥òÁµûÁ∂±ËÄïËÄÉËÇØËÇ±ËÖîËÜèËà™ËçíË°åË°°Ë¨õË≤¢Ë≥ºÈÉäÈÖµÈâ±Á†øÈãºÈñ§ÈôçÈ†ÖÈ¶ôÈ´òÈ¥ªÂâõÂä´Âè∑ÂêàÂ£ïÊã∑Êø†Ë±™ËΩüÈ∫πÂÖãÂàªÂëäÂõΩÁ©ÄÈÖ∑Èµ†ÈªíÁçÑÊºâËÖ∞ÁîëÂøΩÊÉöÈ™®ÁãõËæº"],["baa1","Ê≠§È†É‰ªäÂõ∞Âù§Â¢æÂ©öÊÅ®ÊááÊòèÊòÜÊ†πÊ¢±Ê∑∑ÁóïÁ¥∫ËâÆÈ≠Ç‰∫õ‰ΩêÂèâÂîÜÂµØÂ∑¶Â∑ÆÊüªÊ≤ôÁë≥Á†ÇË©êÈéñË£üÂùêÂ∫ßÊå´ÂÇµÂÇ¨ÂÜçÊúÄÂìâÂ°ûÂ¶ªÂÆ∞ÂΩ©ÊâçÊé°Ê†ΩÊ≠≥Ê∏àÁÅΩÈááÁäÄÁ†ïÁ†¶Á•≠ÊñéÁ¥∞ËèúË£ÅËºâÈöõÂâ§Âú®ÊùêÁΩ™Ë≤°ÂÜ¥ÂùÇÈò™Â†∫Ê¶äËÇ¥Âí≤Â¥éÂüºÁ¢ïÈ∑∫‰ΩúÂâäÂíãÊêæÊò®ÊúîÊüµÁ™ÑÁ≠ñÁ¥¢ÈåØÊ°úÈÆ≠Á¨πÂåôÂÜäÂà∑"],["bba1","ÂØüÊã∂ÊíÆÊì¶Êú≠ÊÆ∫Ëñ©ÈõëÁöêÈØñÊçåÈåÜÈÆ´ÁöøÊôí‰∏âÂÇòÂèÇÂ±±ÊÉ®ÊííÊï£Ê°üÁá¶ÁèäÁî£ÁÆóÁ∫ÇËöïËÆÉË≥õÈÖ∏È§êÊñ¨Êö´ÊÆã‰ªï‰ªî‰º∫‰ΩøÂà∫Âè∏Âè≤Âó£ÂõõÂ£´ÂßãÂßâÂßøÂ≠êÂ±çÂ∏ÇÂ∏´ÂøóÊÄùÊåáÊîØÂ≠úÊñØÊñΩÊó®ÊûùÊ≠¢Ê≠ªÊ∞èÁçÖÁ•âÁßÅÁ≥∏Á¥ôÁ¥´ËÇ¢ËÑÇËá≥Ë¶ñË©ûË©©Ë©¶Ë™åË´ÆË≥áË≥úÈõåÈ£ºÊ≠Ø‰∫ã‰ºº‰æçÂÖêÂ≠óÂØ∫ÊÖàÊåÅÊôÇ"],["bca1","Ê¨°ÊªãÊ≤ªÁàæÁíΩÁóîÁ£ÅÁ§∫ËÄåËÄ≥Ëá™ËíîËæûÊ±êÈπøÂºèË≠òÈ¥´Á´∫Ëª∏ÂÆçÈõ´‰∏ÉÂè±Âü∑Â§±Â´âÂÆ§ÊÇâÊπøÊºÜÁñæË≥™ÂÆüËîÄÁØ†ÂÅ≤Êü¥ËäùÂ±°ËïäÁ∏ûËàéÂÜôÂ∞ÑÊç®Ëµ¶ÊñúÁÖÆÁ§æÁ¥óËÄÖË¨ùËªäÈÅÆËõáÈÇ™ÂÄüÂã∫Â∞∫ÊùìÁÅºÁàµÈÖåÈáàÈå´Ëã•ÂØÇÂº±ÊÉπ‰∏ªÂèñÂÆàÊâãÊú±ÊÆäÁã©Áè†Á®ÆËÖ´Ë∂£ÈÖíÈ¶ñÂÑíÂèóÂë™ÂØøÊéàÊ®πÁ∂¨ÈúÄÂõöÂèéÂë®"],["bda1","ÂÆóÂ∞±Â∑û‰øÆÊÑÅÊãæÊ¥≤ÁßÄÁßãÁµÇÁπçÁøíËá≠ËàüËíêË°ÜË•≤ËÆêËπ¥ËºØÈÄ±ÈÖãÈÖ¨ÈõÜÈÜú‰ªÄ‰ΩèÂÖÖÂçÅÂæìÊàéÊüîÊ±ÅÊ∏ãÁç£Á∏¶ÈáçÈäÉÂèîÂ§ôÂÆøÊ∑ëÁ•ùÁ∏ÆÁ≤õÂ°æÁÜüÂá∫Ë°ìËø∞‰øäÂ≥ªÊò•Áû¨Á´£ËàúÈßøÂáÜÂæ™Êó¨Ê•ØÊÆâÊ∑≥Ê∫ñÊΩ§ÁõæÁ¥îÂ∑°ÈÅµÈÜáÈ†ÜÂá¶ÂàùÊâÄÊöëÊõôÊ∏öÂ∫∂Á∑íÁΩ≤Êõ∏ËñØËó∑Ë´∏Âä©ÂèôÂ•≥Â∫èÂæêÊÅïÈã§Èô§ÂÇ∑ÂÑü"],["bea1","ÂãùÂå†ÂçáÂè¨Âì®ÂïÜÂî±ÂòóÂ•®Â¶æÂ®ºÂÆµÂ∞ÜÂ∞èÂ∞ëÂ∞öÂ∫ÑÂ∫äÂª†ÂΩ∞ÊâøÊäÑÊãõÊéåÊç∑ÊòáÊòåÊò≠Êô∂ÊùæÊ¢¢Ê®üÊ®µÊ≤ºÊ∂àÊ∏âÊπòÁÑºÁÑ¶ÁÖßÁóáÁúÅÁ°ùÁ§ÅÁ••Áß∞Á´†Á¨ëÁ≤ßÁ¥πËÇñËèñËíãËïâË°ùË£≥Ë®üË®ºË©îË©≥Ë±°Ë≥ûÈÜ§Èâ¶ÈçæÈêòÈöúÈûò‰∏ä‰∏à‰∏û‰πóÂÜóÂâ∞ÂüéÂ†¥Â£åÂ¨¢Â∏∏ÊÉÖÊìæÊù°ÊùñÊµÑÁä∂Áï≥Á©£Ëí∏Ë≠≤ÈÜ∏Èå†Âò±Âü¥È£æ"],["bfa1","Êã≠Ê§çÊÆñÁá≠ÁπîËÅ∑Ëâ≤Ëß¶È£üËùïËæ±Â∞ª‰º∏‰ø°‰æµÂîáÂ®†ÂØùÂØ©ÂøÉÊÖéÊåØÊñ∞ÊôãÊ£ÆÊ¶õÊµ∏Ê∑±Áî≥ÁñπÁúüÁ•ûÁß¶Á¥≥Ëá£ËäØËñ™Ë¶™Ë®∫Ë∫´ËæõÈÄ≤ÈáùÈúá‰∫∫‰ªÅÂàÉÂ°µÂ£¨Â∞ãÁîöÂ∞ΩËÖéË®äËøÖÈô£Èù≠Á¨•Ë´èÈ†àÈÖ¢Âõ≥Âé®ÈÄóÂêπÂûÇÂ∏•Êé®Ê∞¥ÁÇäÁù°Á≤ãÁø†Ë°∞ÈÅÇÈÖîÈåêÈåòÈöèÁëûÈ´ÑÂ¥áÂµ©Êï∞Êû¢Ë∂®ÈõõÊçÆÊùâÊ§ôËèÖÈ†óÈõÄË£æ"],["c0a1","ÊæÑÊë∫ÂØ∏‰∏ñÁÄ¨ÁïùÊòØÂáÑÂà∂Âã¢ÂßìÂæÅÊÄßÊàêÊîøÊï¥ÊòüÊô¥Ê£≤Ê†ñÊ≠£Ê∏ÖÁâ≤ÁîüÁõõÁ≤æËÅñÂ£∞Ë£ΩË•øË™†Ë™ìË´ãÈÄùÈÜíÈùíÈùôÊñâÁ®éËÑÜÈöªÂ∏≠ÊÉúÊàöÊñ•ÊòîÊûêÁü≥Á©çÁ±çÁ∏æËÑäË≤¨Ëµ§Ë∑°ËπüÁ¢©ÂàáÊãôÊé•ÊëÇÊäòË®≠Á™ÉÁØÄË™¨Èõ™Áµ∂ËàåËùâ‰ªôÂÖàÂçÉÂç†ÂÆ£Â∞ÇÂ∞ñÂ∑ùÊà¶ÊâáÊí∞Ê†ìÊ†¥Ê≥âÊµÖÊ¥óÊüìÊΩúÁÖéÁÖΩÊóãÁ©øÁÆ≠Á∑ö"],["c1a1","ÁπäÁæ®ËÖ∫ËàõËàπËñ¶Ë©ÆË≥éË∑µÈÅ∏ÈÅ∑Èä≠ÈäëÈñÉÈÆÆÂâçÂñÑÊº∏ÁÑ∂ÂÖ®Á¶ÖÁπïËÜ≥Á≥éÂôåÂ°ëÂ≤®Êé™ÊõæÊõΩÊ•öÁãôÁñèÁñéÁ§éÁ•ñÁßüÁ≤óÁ¥†ÁµÑËòáË®¥ÈòªÈÅ°Èº†ÂÉßÂâµÂèåÂè¢ÂÄâÂñ™Â£ÆÂ•èÁàΩÂÆãÂ±§ÂåùÊÉ£ÊÉ≥ÊçúÊéÉÊåøÊéªÊìçÊó©ÊõπÂ∑£ÊßçÊßΩÊºïÁá•‰∫âÁó©Áõ∏Á™ìÁ≥üÁ∑èÁ∂úËÅ°ËçâËçòËë¨ËíºËóªË£ÖËµ∞ÈÄÅÈÅ≠ÈéóÈúúÈ®íÂÉèÂ¢óÊÜé"],["c2a1","ËáìËîµË¥àÈÄ†‰øÉÂÅ¥ÂâáÂç≥ÊÅØÊçâÊùüÊ∏¨Ë∂≥ÈÄü‰øóÂ±ûË≥äÊóèÁ∂öÂçíË¢ñÂÖ∂ÊèÉÂ≠òÂ≠´Â∞äÊêçÊùëÈÅú‰ªñÂ§öÂ§™Ê±∞Ë©ëÂîæÂ†ïÂ¶•ÊÉ∞ÊâìÊüÅËàµÊ•ïÈôÄÈßÑÈ®®‰ΩìÂ†ÜÂØæËÄêÂ≤±Â∏ØÂæÖÊÄ†ÊÖãÊà¥ÊõøÊ≥∞ÊªûËÉéËÖøËãîË¢ãË≤∏ÈÄÄÈÄÆÈöäÈªõÈØõ‰ª£Âè∞Â§ßÁ¨¨ÈÜçÈ°åÈ∑πÊªùÁÄßÂçìÂïÑÂÆÖÊâòÊäûÊãìÊ≤¢ÊøØÁê¢Ë®óÈê∏ÊøÅË´æËå∏ÂáßËõ∏Âè™"],["c3a1","Âè©‰ΩÜÈÅîËæ∞Â•™ËÑ±Â∑ΩÁ´™ËæøÊ£öË∞∑Áã∏È±àÊ®ΩË™∞‰∏πÂçòÂòÜÂù¶ÊãÖÊé¢Êó¶Ê≠éÊ∑°ÊπõÁÇ≠Áü≠Á´ØÁÆ™Á∂ªËÄΩËÉÜËõãË™ïÈçõÂõ£Â£áÂºæÊñ≠ÊöñÊ™ÄÊÆµÁî∑Ë´áÂÄ§Áü•Âú∞ÂºõÊÅ•Êô∫Ê±†Áó¥Á®öÁΩÆËá¥ËúòÈÅÖÈ¶≥ÁØâÁïúÁ´πÁ≠ëËìÑÈÄêÁß©Á™íËå∂Â´°ÁùÄ‰∏≠‰ª≤ÂÆôÂø†ÊäΩÊòºÊü±Ê≥®Ëô´Ë°∑Ë®ªÈÖéÈã≥ÈßêÊ®óÁÄ¶Áå™ËãßËëóË≤Ø‰∏ÅÂÖÜÂáãÂñãÂØµ"],["c4a1","Â∏ñÂ∏≥Â∫ÅÂºîÂºµÂΩ´Âæ¥Êá≤ÊåëÊö¢ÊúùÊΩÆÁâíÁî∫Áú∫ËÅ¥ËÑπËÖ∏Ëù∂Ë™øË´úË∂ÖË∑≥ÈäöÈï∑È†ÇÈ≥•ÂãÖÊçóÁõ¥ÊúïÊ≤àÁèçË≥ÉÈéÆÈô≥Ê¥•Â¢úÊ§éÊßåËøΩÈéöÁóõÈÄöÂ°öÊ†ÇÊé¥Êßª‰ΩÉÊº¨ÊüòËæªËî¶Á∂¥ÈçîÊ§øÊΩ∞Âù™Â£∑Â¨¨Á¥¨Áà™ÂêäÈá£È∂¥‰∫≠‰ΩéÂÅúÂÅµÂâÉË≤ûÂëàÂ†§ÂÆöÂ∏ùÂ∫ïÂ∫≠Âª∑ÂºüÊÇåÊäµÊå∫ÊèêÊ¢ØÊ±ÄÁ¢áÁ¶éÁ®ãÁ∑†ËâáË®ÇË´¶ËπÑÈÄì"],["c5a1","ÈÇ∏ÈÑ≠ÈáòÈºéÊ≥•ÊëòÊì¢ÊïµÊª¥ÁöÑÁ¨õÈÅ©ÈèëÊ∫∫Âì≤ÂæπÊí§ËΩçËø≠ÈâÑÂÖ∏Â°´Â§©Â±ïÂ∫óÊ∑ªÁ∫èÁîúË≤ºËª¢È°õÁÇπ‰ºùÊÆøÊæ±Áî∞ÈõªÂÖéÂêêÂ†µÂ°óÂ¶¨Â±†ÂæíÊñóÊùúÊ∏°ÁôªËèüË≥≠ÈÄîÈÉΩÈççÁ†•Á†∫Âä™Â∫¶ÂúüÂ•¥ÊÄíÂÄíÂÖöÂÜ¨ÂáçÂàÄÂîêÂ°îÂ°òÂ•óÂÆïÂ≥∂Â∂ãÊÇºÊäïÊê≠Êù±Ê°ÉÊ¢ºÊ£üÁõóÊ∑òÊπØÊ∂õÁÅØÁáàÂΩìÁóòÁ•∑Á≠âÁ≠îÁ≠íÁ≥ñÁµ±Âà∞"],["c6a1","Ëë£Ëï©Ëó§Ë®éË¨ÑË±ÜË∏èÈÄÉÈÄèÈêôÈô∂È†≠È®∞ÈóòÂÉçÂãïÂêåÂ†ÇÂ∞éÊÜßÊíûÊ¥ûÁû≥Á´•ËÉ¥ËêÑÈÅìÈäÖÂ≥†È¥áÂåøÂæóÂæ≥Ê∂úÁâπÁù£Á¶øÁØ§ÊØíÁã¨Ë™≠Ê†ÉÊ©°Âá∏Á™ÅÊ§¥Â±äÈ≥∂Ëã´ÂØÖÈÖâÁÄûÂô∏Â±ØÊÉáÊï¶Ê≤åË±öÈÅÅÈ†ìÂëëÊõáÈàçÂ•àÈÇ£ÂÜÖ‰πçÂá™ËñôË¨éÁÅòÊç∫ÈçãÊ•¢È¶¥Á∏ÑÁï∑ÂçóÊ•†ËªüÈõ£Ê±ù‰∫åÂ∞ºÂºêËø©ÂåÇË≥ëËÇâËôπÂªøÊó•‰π≥ÂÖ•"],["c7a1","Â¶ÇÂ∞øÈüÆ‰ªªÂ¶äÂøçË™çÊø°Á¶∞Á•¢ÂØßËë±Áå´ÁÜ±Âπ¥ÂøµÊçªÊíöÁáÉÁ≤ò‰πÉÂªº‰πãÂüúÂö¢ÊÇ©ÊøÉÁ¥çËÉΩËÑ≥ËÜøËæ≤Ë¶óËö§Â∑¥ÊääÊí≠Ë¶áÊù∑Ê≥¢Ê¥æÁê∂Á†¥Â©ÜÁΩµËä≠È¶¨‰ø≥ÂªÉÊãùÊéíÊïóÊùØÁõÉÁâåËÉåËÇ∫Ëº©ÈÖçÂÄçÂüπÂ™íÊ¢ÖÊ•≥ÁÖ§ÁãΩË≤∑Â£≤Ë≥†Èô™ÈÄôËùøÁß§ÁüßËê©‰ºØÂâ•ÂçöÊãçÊüèÊ≥äÁôΩÁÆîÁ≤ïËà∂ËñÑËø´ÊõùÊº†ÁàÜÁ∏õËé´ÈßÅÈ∫¶"],["c8a1","ÂáΩÁÆ±Á°≤ÁÆ∏ËÇáÁ≠àÊ´®Âπ°ËÇåÁïëÁï†ÂÖ´Èâ¢Ê∫åÁô∫ÈÜóÈ´™‰ºêÁΩ∞ÊäúÁ≠èÈñ•È≥©Âô∫Â°ôËõ§Èöº‰º¥Âà§ÂçäÂèçÂèõÂ∏ÜÊê¨ÊñëÊùøÊ∞æÊ±éÁâàÁäØÁè≠ÁïîÁπÅËà¨Ëó©Ë≤©ÁØÑÈáÜÁÖ©È†íÈ£ØÊåΩÊô©Áï™Áõ§Á£êËïÉËõÆÂå™ÂçëÂê¶Â¶ÉÂ∫áÂΩºÊÇ≤ÊââÊâπÊä´ÊñêÊØîÊ≥åÁñ≤ÁöÆÁ¢ëÁßòÁ∑ãÁΩ∑ËÇ•Ë¢´Ë™πË≤ªÈÅøÈùûÈ£õÊ®ãÁ∞∏ÂÇôÂ∞æÂæÆÊûáÊØòÁêµÁúâÁæé"],["c9a1","ÈºªÊüäÁ®óÂåπÁñãÈ´≠ÂΩ¶ËÜùËè±ËÇòÂººÂøÖÁï¢Á≠ÜÈÄºÊ°ßÂß´Â™õÁ¥êÁôæË¨¨‰øµÂΩ™Ê®ôÊ∞∑ÊºÇÁì¢Á•®Ë°®Ë©ïË±πÂªüÊèèÁóÖÁßíËãóÈå®Èã≤ËíúËõ≠È∞≠ÂìÅÂΩ¨ÊñåÊµúÁÄïË≤ßË≥ìÈ†ªÊïèÁì∂‰∏ç‰ªòÂü†Â§´Â©¶ÂØåÂÜ®Â∏ÉÂ∫úÊÄñÊâ∂Êï∑ÊñßÊôÆÊµÆÁà∂Á¨¶ËÖêËÜöËäôË≠úË≤†Ë≥¶Ëµ¥ÈòúÈôÑ‰æÆÊí´Ê≠¶ËàûËë°Ëï™ÈÉ®Â∞ÅÊ•ìÈ¢®Ëë∫Ëïó‰ºèÂâØÂæ©ÂπÖÊúç"],["caa1","Á¶èËÖπË§áË¶ÜÊ∑µÂºóÊâïÊ≤∏‰ªèÁâ©ÈÆíÂàÜÂêªÂô¥Â¢≥ÊÜ§ÊâÆÁÑöÂ•ÆÁ≤âÁ≥ûÁ¥õÈõ∞ÊñáËÅû‰∏ô‰ΩµÂÖµÂ°ÄÂπ£Âπ≥ÂºäÊüÑ‰∏¶ËîΩÈñâÈôõÁ±≥È†ÅÂÉªÂ£ÅÁôñÁ¢ßÂà•Áû•ËîëÁÆÜÂÅèÂ§âÁâáÁØáÁ∑®Ëæ∫ËøîÈÅç‰æøÂãâÂ®©ÂºÅÈû≠‰øùËàóÈã™ÂúÉÊçïÊ≠©Áî´Ë£úËºîÁ©ÇÂãüÂ¢ìÊÖïÊàäÊöÆÊØçÁ∞øËè©ÂÄ£‰ø∏ÂåÖÂëÜÂ†±Â•âÂÆùÂ≥∞Â≥ØÂ¥©Â∫ñÊä±ÊçßÊîæÊñπÊúã"],["cba1","Ê≥ïÊ≥°ÁÉπÁ†≤Á∏´ËÉûËä≥ËêåËì¨ËúÇË§íË®™Ë±äÈÇ¶ÈãíÈ£ΩÈ≥≥Èµ¨‰πè‰∫°ÂÇçÂâñÂùäÂ¶®Â∏ΩÂøòÂøôÊàøÊö¥ÊúõÊüêÊ£íÂÜíÁ¥°ËÇ™ËÜ®Ë¨ÄË≤åË≤øÈâæÈò≤Âê†È†¨ÂåóÂÉïÂçúÂ¢®Êí≤Êú¥ÁâßÁù¶Á©ÜÈá¶ÂãÉÊ≤°ÊÆÜÂ†ÄÂπåÂ•îÊú¨ÁøªÂá°ÁõÜÊë©Á£®È≠îÈ∫ªÂüãÂ¶πÊòßÊûöÊØéÂì©ÊßôÂπïËÜúÊûïÈÆ™ÊüæÈ±íÊ°ù‰∫¶‰ø£ÂèàÊäπÊú´Ê≤´ËøÑ‰æ≠Áπ≠È∫ø‰∏áÊÖ¢Ê∫Ä"],["cca1","Êº´ËîìÂë≥Êú™È≠ÖÂ∑≥ÁÆïÂ≤¨ÂØÜËúúÊπäËìëÁ®îËÑàÂ¶ôÁ≤çÊ∞ëÁú†ÂãôÂ§¢ÁÑ°ÁâüÁüõÈúßÈµ°Ê§ãÂ©øÂ®òÂÜ•ÂêçÂëΩÊòéÁõüËø∑ÈäòÈ≥¥Âß™ÁâùÊªÖÂÖçÊ£âÁ∂øÁ∑¨Èù¢È∫∫Êë∏Ê®°ËåÇÂ¶ÑÂ≠üÊØõÁåõÁõ≤Á∂≤ËÄóËíôÂÑ≤Êú®ÈªôÁõÆÊù¢ÂãøÈ§ÖÂ∞§ÊàªÁ±æË≤∞ÂïèÊÇ∂Á¥ãÈñÄÂåÅ‰πüÂÜ∂Â§úÁà∫ËÄ∂ÈáéÂº•Áü¢ÂéÑÂΩπÁ¥ÑËñ¨Ë®≥Ë∫çÈùñÊü≥ËñÆÈëìÊÑâÊÑàÊ≤πÁôí"],["cda1","Ë´≠Ëº∏ÂîØ‰ΩëÂÑ™ÂãáÂèãÂÆ•ÂπΩÊÇ†ÊÜÇÊèñÊúâÊüöÊπßÊ∂åÁå∂Áå∑Áî±Á•êË£ïË™òÈÅäÈÇëÈÉµÈõÑËûçÂ§ï‰∫à‰Ωô‰∏éË™âËºøÈ†êÂÇ≠ÂπºÂ¶ñÂÆπÂ∫∏ÊèöÊè∫ÊìÅÊõúÊ•äÊßòÊ¥ãÊ∫∂ÁÜîÁî®Á™ØÁæäËÄÄËëâËìâË¶ÅË¨°Ë∏äÈÅ•ÈôΩÈ§äÊÖæÊäëÊ¨≤Ê≤ÉÊµ¥ÁøåÁøºÊ∑ÄÁæÖËû∫Ë£∏Êù•Ëé±È†ºÈõ∑Ê¥õÁµ°ËêΩÈÖ™‰π±ÂçµÂµêÊ¨ÑÊø´ËóçËò≠Ë¶ßÂà©ÂêèÂ±•ÊùéÊ¢®ÁêÜÁíÉ"],["cea1","Áó¢Ë£èË£°ÈáåÈõ¢Èô∏ÂæãÁéáÁ´ãËëéÊé†Áï•ÂäâÊµÅÊ∫úÁêâÁïôÁ°´Á≤íÈöÜÁ´úÈæç‰æ∂ÊÖÆÊóÖËôú‰∫Ü‰∫ÆÂÉö‰∏°ÂáåÂØÆÊñôÊ¢ÅÊ∂ºÁåüÁôÇÁû≠Á®úÁ≥ßËâØË´íÈÅºÈáèÈôµÈ†òÂäõÁ∑ëÂÄ´ÂéòÊûóÊ∑ãÁáêÁê≥Ëá®Ëº™Èö£È±óÈ∫üÁë†Â°ÅÊ∂ôÁ¥ØÈ°û‰ª§‰º∂‰æãÂÜ∑Âä±Â∂∫ÊÄúÁé≤Á§ºËãìÈà¥Èö∑Èõ∂ÈúäÈ∫óÈΩ¢Êö¶Ê≠¥ÂàóÂä£ÁÉàË£ÇÂªâÊÅãÊÜêÊº£ÁÖâÁ∞æÁ∑¥ËÅØ"],["cfa1","ËìÆÈÄ£Èå¨ÂëÇÈ≠ØÊ´ìÁÇâË≥ÇË∑ØÈú≤Âä¥Â©ÅÂªäÂºÑÊúóÊ•ºÊ¶îÊµ™ÊºèÁâ¢ÁãºÁØ≠ËÄÅËÅæËùãÈÉéÂÖ≠È∫ìÁ¶ÑËÇãÈå≤Ë´ñÂÄ≠ÂíåË©±Ê≠™Ë≥ÑËÑáÊÉëÊû†È∑≤‰∫ô‰∫òÈ∞êË©´ËóÅËï®Ê§ÄÊπæÁ¢óËÖï"],["d0a1","Âºå‰∏ê‰∏ï‰∏™‰∏±‰∏∂‰∏º‰∏ø‰πÇ‰πñ‰πò‰∫Ç‰∫ÖË±´‰∫äËàíÂºç‰∫é‰∫û‰∫ü‰∫†‰∫¢‰∫∞‰∫≥‰∫∂‰ªé‰ªç‰ªÑ‰ªÜ‰ªÇ‰ªó‰ªû‰ª≠‰ªü‰ª∑‰ºâ‰Ωö‰º∞‰Ωõ‰Ωù‰Ωó‰Ωá‰Ω∂‰æà‰æè‰æò‰Ωª‰Ω©‰Ω∞‰æë‰ΩØ‰æÜ‰æñÂÑò‰øî‰øü‰øé‰øò‰øõ‰øë‰øö‰øê‰ø§‰ø•ÂÄöÂÄ®ÂÄîÂÄ™ÂÄ•ÂÄÖ‰ºú‰ø∂ÂÄ°ÂÄ©ÂÄ¨‰øæ‰øØÂÄëÂÄÜÂÅÉÂÅáÊúÉÂÅïÂÅêÂÅàÂÅöÂÅñÂÅ¨ÂÅ∏ÂÇÄÂÇöÂÇÖÂÇ¥ÂÇ≤"],["d1a1","ÂÉâÂÉäÂÇ≥ÂÉÇÂÉñÂÉûÂÉ•ÂÉ≠ÂÉ£ÂÉÆÂÉπÂÉµÂÑâÂÑÅÂÑÇÂÑñÂÑïÂÑîÂÑöÂÑ°ÂÑ∫ÂÑ∑ÂÑºÂÑªÂÑøÂÖÄÂÖíÂÖåÂÖîÂÖ¢Á´∏ÂÖ©ÂÖ™ÂÖÆÂÜÄÂÜÇÂõòÂÜåÂÜâÂÜèÂÜëÂÜìÂÜïÂÜñÂÜ§ÂÜ¶ÂÜ¢ÂÜ©ÂÜ™ÂÜ´ÂÜ≥ÂÜ±ÂÜ≤ÂÜ∞ÂÜµÂÜΩÂáÖÂáâÂáõÂá†ËôïÂá©Âá≠Âá∞ÂáµÂáæÂàÑÂàãÂàîÂàéÂàßÂà™ÂàÆÂà≥ÂàπÂâèÂâÑÂâãÂâåÂâûÂâîÂâ™Ââ¥Ââ©Ââ≥ÂâøÂâΩÂäçÂäîÂäíÂâ±ÂäàÂäëËæ®"],["d2a1","ËæßÂä¨Âä≠ÂäºÂäµÂãÅÂãçÂãóÂãûÂã£Âã¶È£≠Âã†Âã≥ÂãµÂã∏ÂãπÂåÜÂåàÁî∏ÂåçÂåêÂåèÂåïÂåöÂå£ÂåØÂå±Âå≥Âå∏ÂçÄÂçÜÂçÖ‰∏óÂçâÂççÂáñÂçûÂç©ÂçÆÂ§òÂçªÂç∑ÂéÇÂéñÂé†Âé¶Âé•ÂéÆÂé∞Âé∂ÂèÉÁ∞íÈõôÂèüÊõºÁáÆÂèÆÂè®Âè≠Âè∫ÂêÅÂêΩÂëÄÂê¨Âê≠ÂêºÂêÆÂê∂Âê©ÂêùÂëéÂíèÂëµÂíéÂëüÂë±Âë∑Âë∞ÂííÂëªÂíÄÂë∂ÂíÑÂíêÂíÜÂìáÂí¢Âí∏Âí•Âí¨ÂìÑÂìàÂí®"],["d3a1","Âí´ÂìÇÂí§ÂíæÂíºÂìòÂì•Âì¶ÂîèÂîîÂìΩÂìÆÂì≠Âì∫Âì¢ÂîπÂïÄÂï£ÂïåÂîÆÂïúÂïÖÂïñÂïóÂî∏Âî≥ÂïùÂñôÂñÄÂíØÂñäÂñüÂïªÂïæÂñòÂñûÂñÆÂïºÂñÉÂñ©ÂñáÂñ®ÂóöÂóÖÂóüÂóÑÂóúÂó§ÂóîÂòîÂó∑ÂòñÂóæÂóΩÂòõÂóπÂôéÂôêÁáüÂò¥Âò∂Âò≤Âò∏Âô´Âô§ÂòØÂô¨Âô™ÂöÜÂöÄÂöäÂö†ÂöîÂöèÂö•ÂöÆÂö∂Âö¥ÂõÇÂöºÂõÅÂõÉÂõÄÂõàÂõéÂõëÂõìÂõóÂõÆÂõπÂúÄÂõøÂúÑÂúâ"],["d4a1","ÂúàÂúãÂúçÂúìÂúòÂúñÂóáÂúúÂú¶Âú∑Âú∏ÂùéÂúªÂùÄÂùèÂù©ÂüÄÂûàÂù°ÂùøÂûâÂûìÂû†Âû≥Âû§Âû™Âû∞ÂüÉÂüÜÂüîÂüíÂüìÂ†äÂüñÂü£Â†ãÂ†ôÂ†ùÂ°≤Â†°Â°¢Â°ãÂ°∞ÊØÄÂ°íÂ†ΩÂ°πÂ¢ÖÂ¢πÂ¢üÂ¢´Â¢∫Â£ûÂ¢ªÂ¢∏Â¢ÆÂ£ÖÂ£ìÂ£ëÂ£óÂ£ôÂ£òÂ£•Â£úÂ£§Â£üÂ£ØÂ£∫Â£πÂ£ªÂ£ºÂ£ΩÂ§ÇÂ§äÂ§êÂ§õÊ¢¶Â§•Â§¨Â§≠Â§≤Â§∏Â§æÁ´íÂ•ïÂ•êÂ•éÂ•öÂ•òÂ•¢Â•†Â•ßÂ•¨Â•©"],["d5a1","Â•∏Â¶ÅÂ¶ù‰Ωû‰æ´Â¶£Â¶≤ÂßÜÂß®ÂßúÂ¶çÂßôÂßöÂ®•Â®üÂ®ëÂ®úÂ®âÂ®öÂ©ÄÂ©¨Â©âÂ®µÂ®∂Â©¢Â©™Â™öÂ™ºÂ™æÂ´ãÂ´ÇÂ™ΩÂ´£Â´óÂ´¶Â´©Â´ñÂ´∫Â´ªÂ¨åÂ¨ãÂ¨ñÂ¨≤Â´êÂ¨™Â¨∂Â¨æÂ≠ÉÂ≠ÖÂ≠ÄÂ≠ëÂ≠ïÂ≠öÂ≠õÂ≠•Â≠©Â≠∞Â≠≥Â≠µÂ≠∏ÊñàÂ≠∫ÂÆÄÂÆÉÂÆ¶ÂÆ∏ÂØÉÂØáÂØâÂØîÂØêÂØ§ÂØ¶ÂØ¢ÂØûÂØ•ÂØ´ÂØ∞ÂØ∂ÂØ≥Â∞ÖÂ∞áÂ∞àÂ∞çÂ∞ìÂ∞†Â∞¢Â∞®Â∞∏Â∞πÂ±ÅÂ±ÜÂ±éÂ±ì"],["d6a1","Â±êÂ±èÂ≠±Â±¨Â±Æ‰π¢Â±∂Â±πÂ≤åÂ≤ëÂ≤îÂ¶õÂ≤´Â≤ªÂ≤∂Â≤ºÂ≤∑Â≥ÖÂ≤æÂ≥áÂ≥ôÂ≥©Â≥ΩÂ≥∫Â≥≠Â∂åÂ≥™Â¥ãÂ¥ïÂ¥óÂµúÂ¥üÂ¥õÂ¥ëÂ¥îÂ¥¢Â¥öÂ¥ôÂ¥òÂµåÂµíÂµéÂµãÂµ¨Âµ≥Âµ∂Â∂áÂ∂ÑÂ∂ÇÂ∂¢Â∂ùÂ∂¨Â∂ÆÂ∂ΩÂ∂êÂ∂∑Â∂ºÂ∑âÂ∑çÂ∑ìÂ∑íÂ∑ñÂ∑õÂ∑´Â∑≤Â∑µÂ∏ãÂ∏öÂ∏ôÂ∏ëÂ∏õÂ∏∂Â∏∑ÂπÑÂπÉÂπÄÂπéÂπóÂπîÂπüÂπ¢Âπ§ÂπáÂπµÂπ∂Âπ∫È∫ºÂπøÂ∫†ÂªÅÂªÇÂªàÂªêÂªè"],["d7a1","ÂªñÂª£ÂªùÂªöÂªõÂª¢Âª°Âª®Âª©Âª¨Âª±Âª≥Âª∞Âª¥Âª∏ÂªæÂºÉÂºâÂΩùÂΩúÂºãÂºëÂºñÂº©Âº≠Âº∏ÂΩÅÂΩàÂΩåÂΩéÂºØÂΩëÂΩñÂΩóÂΩôÂΩ°ÂΩ≠ÂΩ≥ÂΩ∑ÂæÉÂæÇÂΩøÂæäÂæàÂæëÂæáÂæûÂæôÂæòÂæ†Âæ®Âæ≠ÂæºÂøñÂøªÂø§Âø∏Âø±ÂøùÊÇ≥ÂøøÊÄ°ÊÅ†ÊÄôÊÄêÊÄ©ÊÄéÊÄ±ÊÄõÊÄïÊÄ´ÊÄ¶ÊÄèÊÄ∫ÊÅöÊÅÅÊÅ™ÊÅ∑ÊÅüÊÅäÊÅÜÊÅçÊÅ£ÊÅÉÊÅ§ÊÅÇÊÅ¨ÊÅ´ÊÅôÊÇÅÊÇçÊÉßÊÇÉÊÇö"],["d8a1","ÊÇÑÊÇõÊÇñÊÇóÊÇíÊÇßÊÇãÊÉ°ÊÇ∏ÊÉ†ÊÉìÊÇ¥Âø∞ÊÇΩÊÉÜÊÇµÊÉòÊÖçÊÑïÊÑÜÊÉ∂ÊÉ∑ÊÑÄÊÉ¥ÊÉ∫ÊÑÉÊÑ°ÊÉªÊÉ±ÊÑçÊÑéÊÖáÊÑæÊÑ®ÊÑßÊÖäÊÑøÊÑºÊÑ¨ÊÑ¥ÊÑΩÊÖÇÊÖÑÊÖ≥ÊÖ∑ÊÖòÊÖôÊÖöÊÖ´ÊÖ¥ÊÖØÊÖ•ÊÖ±ÊÖüÊÖùÊÖìÊÖµÊÜôÊÜñÊÜáÊÜ¨ÊÜîÊÜöÊÜäÊÜëÊÜ´ÊÜÆÊáåÊáäÊáâÊá∑ÊáàÊáÉÊáÜÊÜ∫ÊáãÁΩπÊáçÊá¶Êá£Êá∂Êá∫Êá¥ÊáøÊáΩÊáºÊáæÊàÄÊààÊàâÊàçÊàåÊàîÊàõ"],["d9a1","ÊàûÊà°Êà™ÊàÆÊà∞Êà≤Êà≥ÊâÅÊâéÊâûÊâ£ÊâõÊâ†Êâ®ÊâºÊäÇÊäâÊâæÊäíÊäìÊäñÊãîÊäÉÊäîÊãóÊãëÊäªÊãèÊãøÊãÜÊìîÊãàÊãúÊãåÊãäÊãÇÊãáÊäõÊãâÊååÊãÆÊã±ÊåßÊåÇÊåàÊãØÊãµÊçêÊåæÊççÊêúÊçèÊéñÊééÊéÄÊé´Êç∂Êé£ÊéèÊéâÊéüÊéµÊç´Êç©ÊéæÊè©ÊèÄÊèÜÊè£ÊèâÊèíÊè∂ÊèÑÊêñÊê¥ÊêÜÊêìÊê¶Êê∂ÊîùÊêóÊê®ÊêèÊëßÊëØÊë∂ÊëéÊî™ÊíïÊíìÊí•Êí©ÊíàÊíº"],["daa1","ÊìöÊìíÊìÖÊìáÊíªÊìòÊìÇÊì±ÊìßËàâÊì†Êì°Êä¨Êì£ÊìØÊî¨Êì∂Êì¥Êì≤Êì∫ÊîÄÊìΩÊîòÊîúÊîÖÊî§Êî£Êî´Êî¥ÊîµÊî∑Êî∂Êî∏ÁïãÊïàÊïñÊïïÊïçÊïòÊïûÊïùÊï≤Êï∏ÊñÇÊñÉËÆäÊñõÊñüÊñ´Êñ∑ÊóÉÊóÜÊóÅÊóÑÊóåÊóíÊóõÊóôÊó†Êó°Êó±Êù≤ÊòäÊòÉÊóªÊù≥ÊòµÊò∂Êò¥ÊòúÊôèÊôÑÊôâÊôÅÊôûÊôùÊô§ÊôßÊô®ÊôüÊô¢Êô∞ÊöÉÊöàÊöéÊöâÊöÑÊöòÊöùÊõÅÊöπÊõâÊöæÊöº"],["dba1","ÊõÑÊö∏ÊõñÊõöÊõ†ÊòøÊõ¶Êõ©Êõ∞ÊõµÊõ∑ÊúèÊúñÊúûÊú¶ÊúßÈú∏ÊúÆÊúøÊú∂ÊùÅÊú∏Êú∑ÊùÜÊùûÊù†ÊùôÊù£Êù§ÊûâÊù∞Êû©ÊùºÊù™ÊûåÊûãÊû¶Êû°ÊûÖÊû∑ÊüØÊû¥Êü¨Êû≥Êü©Êû∏Êü§ÊüûÊüùÊü¢ÊüÆÊûπÊüéÊüÜÊüßÊ™úÊ†ûÊ°ÜÊ†©Ê°ÄÊ°çÊ†≤Ê°éÊ¢≥Ê†´Ê°ôÊ°£Ê°∑Ê°øÊ¢üÊ¢èÊ¢≠Ê¢îÊ¢ùÊ¢õÊ¢ÉÊ™ÆÊ¢πÊ°¥Ê¢µÊ¢†Ê¢∫Ê§èÊ¢çÊ°æÊ§ÅÊ£äÊ§àÊ£òÊ§¢Ê§¶Ê£°Ê§åÊ£ç"],["dca1","Ê£îÊ£ßÊ£ïÊ§∂Ê§íÊ§ÑÊ£óÊ££Ê§•Ê£πÊ£†Ê£ØÊ§®Ê§™Ê§öÊ§£Ê§°Ê£ÜÊ•πÊ•∑Ê•úÊ•∏Ê•´Ê•îÊ•æÊ•ÆÊ§πÊ•¥Ê§ΩÊ•ôÊ§∞Ê•°Ê•ûÊ•ùÊ¶ÅÊ•™Ê¶≤Ê¶ÆÊßêÊ¶øÊßÅÊßìÊ¶æÊßéÂØ®ÊßäÊßùÊ¶ªÊßÉÊ¶ßÊ®ÆÊ¶ëÊ¶†Ê¶úÊ¶ïÊ¶¥ÊßûÊß®Ê®ÇÊ®õÊßøÊ¨äÊßπÊß≤ÊßßÊ®ÖÊ¶±Ê®ûÊß≠Ê®îÊß´Ê®äÊ®íÊ´ÅÊ®£Ê®ìÊ©ÑÊ®åÊ©≤Ê®∂Ê©∏Ê©áÊ©¢Ê©ôÊ©¶Ê©àÊ®∏Ê®¢Ê™êÊ™çÊ™†Ê™ÑÊ™¢Ê™£"],["dda1","Ê™óËòóÊ™ªÊ´ÉÊ´ÇÊ™∏Ê™≥Ê™¨Ê´ûÊ´ëÊ´üÊ™™Ê´öÊ´™Ê´ªÊ¨ÖËòñÊ´∫Ê¨íÊ¨ñÈ¨±Ê¨üÊ¨∏Ê¨∑ÁõúÊ¨πÈ£ÆÊ≠áÊ≠ÉÊ≠âÊ≠êÊ≠ôÊ≠îÊ≠õÊ≠üÊ≠°Ê≠∏Ê≠πÊ≠øÊÆÄÊÆÑÊÆÉÊÆçÊÆòÊÆïÊÆûÊÆ§ÊÆ™ÊÆ´ÊÆØÊÆ≤ÊÆ±ÊÆ≥ÊÆ∑ÊÆºÊØÜÊØãÊØìÊØüÊØ¨ÊØ´ÊØ≥ÊØØÈ∫æÊ∞àÊ∞ìÊ∞îÊ∞õÊ∞§Ê∞£Ê±ûÊ±ïÊ±¢Ê±™Ê≤ÇÊ≤çÊ≤öÊ≤ÅÊ≤õÊ±æÊ±®Ê±≥Ê≤íÊ≤êÊ≥ÑÊ≥±Ê≥ìÊ≤ΩÊ≥óÊ≥ÖÊ≥ùÊ≤ÆÊ≤±Ê≤æ"],["dea1","Ê≤∫Ê≥õÊ≥ØÊ≥ôÊ≥™Ê¥üË°çÊ¥∂Ê¥´Ê¥ΩÊ¥∏Ê¥ôÊ¥µÊ¥≥Ê¥íÊ¥åÊµ£Ê∂ìÊµ§ÊµöÊµπÊµôÊ∂éÊ∂ïÊø§Ê∂ÖÊ∑πÊ∏ïÊ∏äÊ∂µÊ∑áÊ∑¶Ê∂∏Ê∑ÜÊ∑¨Ê∑ûÊ∑åÊ∑®Ê∑íÊ∑ÖÊ∑∫Ê∑ôÊ∑§Ê∑ïÊ∑™Ê∑ÆÊ∏≠ÊπÆÊ∏ÆÊ∏ôÊπ≤ÊπüÊ∏æÊ∏£Êπ´Ê∏´Êπ∂ÊπçÊ∏üÊπÉÊ∏∫ÊπéÊ∏§ÊªøÊ∏ùÊ∏∏Ê∫ÇÊ∫™Ê∫òÊªâÊ∫∑ÊªìÊ∫ΩÊ∫ØÊªÑÊ∫≤ÊªîÊªïÊ∫èÊ∫•ÊªÇÊ∫üÊΩÅÊºëÁÅåÊª¨Êª∏ÊªæÊºøÊª≤Êº±ÊªØÊº≤Êªå"],["dfa1","ÊºæÊºìÊª∑ÊæÜÊΩ∫ÊΩ∏ÊæÅÊæÄÊΩØÊΩõÊø≥ÊΩ≠ÊæÇÊΩºÊΩòÊæéÊæëÊøÇÊΩ¶Êæ≥Êæ£Êæ°Êæ§ÊæπÊøÜÊæ™ÊøüÊøïÊø¨ÊøîÊøòÊø±ÊøÆÊøõÁÄâÁÄãÊø∫ÁÄëÁÄÅÁÄèÊøæÁÄõÁÄöÊΩ¥ÁÄùÁÄòÁÄüÁÄ∞ÁÄæÁÄ≤ÁÅëÁÅ£ÁÇôÁÇíÁÇØÁÉ±ÁÇ¨ÁÇ∏ÁÇ≥ÁÇÆÁÉüÁÉãÁÉùÁÉôÁÑâÁÉΩÁÑúÁÑôÁÖ•ÁÖïÁÜàÁÖ¶ÁÖ¢ÁÖåÁÖñÁÖ¨ÁÜèÁáªÁÜÑÁÜïÁÜ®ÁÜ¨ÁáóÁÜπÁÜæÁáíÁáâÁáîÁáéÁá†Áá¨ÁáßÁáµÁáº"],["e0a1","ÁáπÁáøÁàçÁàêÁàõÁà®Áà≠Áà¨Áà∞Áà≤ÁàªÁàºÁàøÁâÄÁâÜÁâãÁâòÁâ¥ÁâæÁäÇÁäÅÁäáÁäíÁäñÁä¢ÁäßÁäπÁä≤ÁãÉÁãÜÁãÑÁãéÁãíÁã¢Áã†Áã°ÁãπÁã∑ÂÄèÁåóÁåäÁåúÁåñÁåùÁå¥ÁåØÁå©Áå•ÁåæÁçéÁçèÈªòÁçóÁç™Áç®Áç∞Áç∏ÁçµÁçªÁç∫ÁèàÁé≥ÁèéÁéªÁèÄÁè•ÁèÆÁèûÁí¢ÁêÖÁëØÁê•Áè∏Áê≤Áê∫ÁëïÁêøÁëüÁëôÁëÅÁëúÁë©Áë∞Áë£Áë™Áë∂ÁëæÁíãÁíûÁíßÁìäÁìèÁìîÁè±"],["e1a1","Áì†Áì£ÁìßÁì©ÁìÆÁì≤Áì∞Áì±Áì∏Áì∑ÁîÑÁîÉÁîÖÁîåÁîéÁîçÁîïÁîìÁîûÁî¶Áî¨ÁîºÁïÑÁïçÁïäÁïâÁïõÁïÜÁïöÁï©Áï§ÁïßÁï´Áï≠Áï∏Áï∂ÁñÜÁñáÁï¥ÁñäÁñâÁñÇÁñîÁñöÁñùÁñ•Áñ£ÁóÇÁñ≥ÁóÉÁñµÁñΩÁñ∏ÁñºÁñ±ÁóçÁóäÁóíÁóôÁó£ÁóûÁóæÁóøÁóºÁòÅÁó∞Áó∫Áó≤Áó≥ÁòãÁòçÁòâÁòüÁòßÁò†Áò°Áò¢Áò§Áò¥Áò∞ÁòªÁôáÁôàÁôÜÁôúÁôòÁô°Áô¢Áô®Áô©Áô™ÁôßÁô¨Áô∞"],["e2a1","Áô≤Áô∂Áô∏ÁôºÁöÄÁöÉÁöàÁöãÁöéÁöñÁöìÁöôÁööÁö∞Áö¥Áö∏ÁöπÁö∫ÁõÇÁõçÁõñÁõíÁõûÁõ°Áõ•ÁõßÁõ™ËòØÁõªÁúàÁúáÁúÑÁú©Áú§ÁúûÁú•Áú¶ÁúõÁú∑Áú∏ÁùáÁùöÁù®Áù´ÁùõÁù•ÁùøÁùæÁùπÁûéÁûãÁûëÁû†ÁûûÁû∞Áû∂ÁûπÁûøÁûºÁûΩÁûªÁüáÁüçÁüóÁüöÁüúÁü£ÁüÆÁüºÁ†åÁ†íÁ§¶Á††Á§™Á°ÖÁ¢éÁ°¥Á¢ÜÁ°ºÁ¢öÁ¢åÁ¢£Á¢µÁ¢™Á¢ØÁ£ëÁ£ÜÁ£ãÁ£îÁ¢æÁ¢ºÁ£ÖÁ£äÁ£¨"],["e3a1","Á£ßÁ£öÁ£ΩÁ£¥Á§áÁ§íÁ§ëÁ§ôÁ§¨Á§´Á•ÄÁ•†Á•óÁ•üÁ•öÁ•ïÁ•ìÁ•∫Á•øÁ¶äÁ¶ùÁ¶ßÈΩãÁ¶™Á¶ÆÁ¶≥Á¶πÁ¶∫ÁßâÁßïÁßßÁß¨Áß°Áß£Á®àÁ®çÁ®òÁ®ôÁ®†Á®üÁ¶ÄÁ®±Á®ªÁ®æÁ®∑Á©ÉÁ©óÁ©âÁ©°Á©¢Á©©ÈæùÁ©∞Á©πÁ©ΩÁ™àÁ™óÁ™ïÁ™òÁ™ñÁ™©Á´àÁ™∞Á™∂Á´ÖÁ´ÑÁ™øÈÇÉÁ´áÁ´äÁ´çÁ´èÁ´ïÁ´ìÁ´ôÁ´öÁ´ùÁ´°Á´¢Á´¶Á´≠Á´∞Á¨ÇÁ¨èÁ¨äÁ¨ÜÁ¨≥Á¨òÁ¨ôÁ¨ûÁ¨µÁ¨®Á¨∂Á≠ê"],["e4a1","Á≠∫Á¨ÑÁ≠çÁ¨ãÁ≠åÁ≠ÖÁ≠µÁ≠•Á≠¥Á≠ßÁ≠∞Á≠±Á≠¨Á≠ÆÁÆùÁÆòÁÆüÁÆçÁÆúÁÆöÁÆãÁÆíÁÆèÁ≠ùÁÆôÁØãÁØÅÁØåÁØèÁÆ¥ÁØÜÁØùÁØ©Á∞ëÁ∞îÁØ¶ÁØ•Á±†Á∞ÄÁ∞áÁ∞ìÁØ≥ÁØ∑Á∞óÁ∞çÁØ∂Á∞£Á∞ßÁ∞™Á∞üÁ∞∑Á∞´Á∞ΩÁ±åÁ±ÉÁ±îÁ±èÁ±ÄÁ±êÁ±òÁ±üÁ±§Á±ñÁ±•Á±¨Á±µÁ≤ÉÁ≤êÁ≤§Á≤≠Á≤¢Á≤´Á≤°Á≤®Á≤≥Á≤≤Á≤±Á≤ÆÁ≤πÁ≤ΩÁ≥ÄÁ≥ÖÁ≥ÇÁ≥òÁ≥íÁ≥úÁ≥¢È¨ªÁ≥ØÁ≥≤Á≥¥Á≥∂Á≥∫Á¥Ü"],["e5a1","Á¥ÇÁ¥úÁ¥ïÁ¥äÁµÖÁµãÁ¥ÆÁ¥≤Á¥øÁ¥µÁµÜÁµ≥ÁµñÁµéÁµ≤Áµ®ÁµÆÁµèÁµ£Á∂ìÁ∂âÁµõÁ∂èÁµΩÁ∂õÁ∂∫Á∂ÆÁ∂£Á∂µÁ∑áÁ∂ΩÁ∂´Á∏ΩÁ∂¢Á∂ØÁ∑úÁ∂∏Á∂üÁ∂∞Á∑òÁ∑ùÁ∑§Á∑ûÁ∑ªÁ∑≤Á∑°Á∏ÖÁ∏äÁ∏£Á∏°Á∏íÁ∏±Á∏üÁ∏âÁ∏ãÁ∏¢ÁπÜÁπ¶Á∏ªÁ∏µÁ∏πÁπÉÁ∏∑Á∏≤Á∏∫ÁπßÁπùÁπñÁπûÁπôÁπöÁππÁπ™Áπ©ÁπºÁπªÁ∫ÉÁ∑ïÁπΩËæÆÁπøÁ∫àÁ∫âÁ∫åÁ∫íÁ∫êÁ∫ìÁ∫îÁ∫ñÁ∫éÁ∫õÁ∫úÁº∏Áº∫"],["e6a1","ÁΩÖÁΩåÁΩçÁΩéÁΩêÁΩëÁΩïÁΩîÁΩòÁΩüÁΩ†ÁΩ®ÁΩ©ÁΩßÁΩ∏ÁæÇÁæÜÁæÉÁæàÁæáÁæåÁæîÁæûÁæùÁæöÁæ£ÁæØÁæ≤ÁæπÁæÆÁæ∂Áæ∏Ë≠±ÁøÖÁøÜÁøäÁøïÁøîÁø°Áø¶Áø©Áø≥ÁøπÈ£úËÄÜËÄÑËÄãËÄíËÄòËÄôËÄúËÄ°ËÄ®ËÄøËÄªËÅäËÅÜËÅíËÅòËÅöËÅüËÅ¢ËÅ®ËÅ≥ËÅ≤ËÅ∞ËÅ∂ËÅπËÅΩËÅøËÇÑËÇÜËÇÖËÇõËÇìËÇöËÇ≠ÂÜêËÇ¨ËÉõËÉ•ËÉôËÉùËÉÑËÉöËÉñËÑâËÉØËÉ±ËÑõËÑ©ËÑ£ËÑØËÖã"],["e7a1","ÈöãËÖÜËÑæËÖìËÖëËÉºËÖ±ËÖÆËÖ•ËÖ¶ËÖ¥ËÜÉËÜàËÜäËÜÄËÜÇËÜ†ËÜïËÜ§ËÜ£ËÖüËÜìËÜ©ËÜ∞ËÜµËÜæËÜ∏ËÜΩËáÄËáÇËÜ∫ËáâËáçËáëËáôËáòËáàËáöËáüËá†ËáßËá∫ËáªËáæËàÅËàÇËàÖËàáËàäËàçËàêËàñËà©Ëà´Ëà∏Ëà≥ËâÄËâôËâòËâùËâöËâüËâ§Ëâ¢Ëâ®Ëâ™Ëâ´ËàÆËâ±Ëâ∑Ëâ∏ËâæËäçËäíËä´ËäüËäªËä¨Ëã°Ëã£ËãüËãíËã¥Ëã≥Ëã∫ËéìËåÉËãªËãπËãûËåÜËãúËåâËãô"],["e8a1","ËåµËå¥ËåñËå≤Ëå±ËçÄËåπËçêËçÖËåØËå´ËåóËåòËéÖËéöËé™ËéüËé¢ËéñËå£ËééËéáËéäËçºËéµËç≥ËçµËé†ËéâËé®Ëè¥ËêìËè´ËèéËèΩËêÉËèòËêãËèÅËè∑ËêáËè†Ëè≤ËêçËê¢Ëê†ËéΩËê∏ËîÜËèªËë≠Ëê™ËêºËïöËíÑËë∑Ëë´Ëí≠ËëÆËíÇËë©ËëÜËê¨ËëØËëπËêµËìäËë¢ËíπËíøËíüËìôËìçËíªËìöËìêËìÅËìÜËìñËí°Ëî°ËìøËì¥ËîóËîòËî¨ËîüËîïËîîËìºËïÄËï£ËïòËïà"],["e9a1","ËïÅËòÇËïãËïïËñÄËñ§ËñàËñëËñäËñ®Ëï≠ËñîËñõËó™ËñáËñúËï∑ËïæËñêËóâËñ∫ËóèËñπËóêËóïËóùËó•ËóúËóπËòäËòìËòãËóæËó∫ËòÜËò¢ËòöËò∞ËòøËôç‰πïËôîËôüËôßËô±ËöìËö£Ëö©Ëö™ËöãËöåËö∂ËöØËõÑËõÜËö∞ËõâË†£Ëö´ËõîËõûËõ©Ëõ¨ËõüËõõËõØËúíËúÜËúàËúÄËúÉËõªËúëËúâËúçËõπËúäËú¥ËúøËú∑ËúªËú•Ëú©ËúöËù†ËùüËù∏ËùåËùéËù¥ËùóËù®ËùÆËùô"],["eaa1","ËùìËù£Ëù™Ë†ÖËû¢ËûüËûÇËûØËüãËûΩËüÄËüêÈõñËû´ËüÑËû≥ËüáËüÜËûªËüØËü≤Ëü†Ë†èË†çËüæËü∂Ëü∑Ë†éËüíË†ëË†ñË†ïË†¢Ë†°Ë†±Ë†∂Ë†πË†ßË†ªË°ÑË°ÇË°íË°ôË°ûË°¢Ë°´Ë¢ÅË°æË¢ûË°µË°ΩË¢µË°≤Ë¢ÇË¢óË¢íË¢ÆË¢ôË¢¢Ë¢çË¢§Ë¢∞Ë¢øË¢±Ë£ÉË£ÑË£îË£òË£ôË£ùË£πË§ÇË£ºË£¥Ë£®Ë£≤Ë§ÑË§åË§äË§ìË•ÉË§ûË§•Ë§™Ë§´Ë•ÅË•ÑË§ªË§∂Ë§∏Ë•åË§ùË•†Ë•û"],["eba1","Ë•¶Ë•§Ë•≠Ë•™Ë•ØË•¥Ë•∑Ë•æË¶ÉË¶àË¶äË¶ìË¶òË¶°Ë¶©Ë¶¶Ë¶¨Ë¶ØË¶≤Ë¶∫Ë¶ΩË¶øËßÄËßöËßúËßùËßßËß¥Ëß∏Ë®ÉË®ñË®êË®åË®õË®ùË®•Ë®∂Ë©ÅË©õË©íË©ÜË©àË©ºË©≠Ë©¨Ë©¢Ë™ÖË™ÇË™ÑË™®Ë™°Ë™ëË™•Ë™¶Ë™öË™£Ë´ÑË´çË´ÇË´öË´´Ë´≥Ë´ßË´§Ë´±Ë¨îË´†Ë´¢Ë´∑Ë´ûË´õË¨åË¨áË¨öË´°Ë¨ñË¨êË¨óË¨†Ë¨≥Èû´Ë¨¶Ë¨´Ë¨æË¨®Ë≠ÅË≠åË≠èË≠éË≠âË≠ñË≠õË≠öË≠´"],["eca1","Ë≠üË≠¨Ë≠ØË≠¥Ë≠ΩËÆÄËÆåËÆéËÆíËÆìËÆñËÆôËÆöË∞∫Ë±ÅË∞øË±àË±åË±éË±êË±ïË±¢Ë±¨Ë±∏Ë±∫Ë≤ÇË≤âË≤ÖË≤äË≤çË≤éË≤îË±ºË≤òÊàùË≤≠Ë≤™Ë≤ΩË≤≤Ë≤≥Ë≤ÆË≤∂Ë≥àË≥ÅË≥§Ë≥£Ë≥öË≥ΩË≥∫Ë≥ªË¥ÑË¥ÖË¥äË¥áË¥èË¥çË¥êÈΩéË¥ìË≥çË¥îË¥ñËµßËµ≠Ëµ±Ëµ≥Ë∂ÅË∂ôË∑ÇË∂æË∂∫Ë∑èË∑öË∑ñË∑åË∑õË∑ãË∑™Ë∑´Ë∑üË∑£Ë∑ºË∏àË∏âË∑øË∏ùË∏ûË∏êË∏üËπÇË∏µË∏∞Ë∏¥Ëπä"],["eda1","ËπáËπâËπåËπêËπàËπôËπ§Ëπ†Ë∏™Ëπ£ËπïËπ∂Ëπ≤ËπºË∫ÅË∫áË∫ÖË∫ÑË∫ãË∫äË∫ìË∫ëË∫îË∫ôË∫™Ë∫°Ë∫¨Ë∫∞ËªÜË∫±Ë∫æËªÖËªàËªãËªõËª£ËªºËªªËª´ËªæËºäËºÖËºïËºíËºôËºìËºúËºüËºõËºåËº¶Ëº≥ËºªËºπËΩÖËΩÇËºæËΩåËΩâËΩÜËΩéËΩóËΩúËΩ¢ËΩ£ËΩ§ËæúËæüËæ£Ëæ≠ËæØËæ∑ËøöËø•Ëø¢Ëø™ËøØÈÇáËø¥ÈÄÖËøπËø∫ÈÄëÈÄïÈÄ°ÈÄçÈÄûÈÄñÈÄãÈÄßÈÄ∂ÈÄµÈÄπËø∏"],["eea1","ÈÅèÈÅêÈÅëÈÅíÈÄéÈÅâÈÄæÈÅñÈÅòÈÅûÈÅ®ÈÅØÈÅ∂Èö®ÈÅ≤ÈÇÇÈÅΩÈÇÅÈÇÄÈÇäÈÇâÈÇèÈÇ®ÈÇØÈÇ±ÈÇµÈÉ¢ÈÉ§ÊâàÈÉõÈÑÇÈÑíÈÑôÈÑ≤ÈÑ∞ÈÖäÈÖñÈÖòÈÖ£ÈÖ•ÈÖ©ÈÖ≥ÈÖ≤ÈÜãÈÜâÈÜÇÈÜ¢ÈÜ´ÈÜØÈÜ™ÈÜµÈÜ¥ÈÜ∫ÈáÄÈáÅÈáâÈáãÈáêÈáñÈáüÈá°ÈáõÈáºÈáµÈá∂ÈàûÈáøÈàîÈà¨ÈàïÈàëÈâûÈâóÈâÖÈââÈâ§ÈâàÈäïÈàøÈâãÈâêÈäúÈäñÈäìÈäõÈâöÈãèÈäπÈä∑Èã©ÈåèÈã∫ÈçÑÈåÆ"],["efa1","ÈåôÈå¢ÈåöÈå£Èå∫ÈåµÈåªÈçúÈç†ÈçºÈçÆÈçñÈé∞Èé¨Èé≠ÈéîÈéπÈèñÈèóÈè®Èè•ÈèòÈèÉÈèùÈèêÈèàÈè§ÈêöÈêîÈêìÈêÉÈêáÈêêÈê∂Èê´ÈêµÈê°Èê∫ÈëÅÈëíÈëÑÈëõÈë†Èë¢ÈëûÈë™Èà©Èë∞ÈëµÈë∑ÈëΩÈëöÈëºÈëæÈíÅÈëøÈñÇÈñáÈñäÈñîÈññÈñòÈñôÈñ†Èñ®ÈñßÈñ≠ÈñºÈñªÈñπÈñæÈóäÊø∂ÈóÉÈóçÈóåÈóïÈóîÈóñÈóúÈó°Èó•Èó¢Èò°Èò®ÈòÆÈòØÈôÇÈôåÈôèÈôãÈô∑ÈôúÈôû"],["f0a1","ÈôùÈôüÈô¶Èô≤Èô¨ÈöçÈöòÈöïÈöóÈö™ÈößÈö±Èö≤Èö∞Èö¥Èö∂Èö∏ÈöπÈõéÈõãÈõâÈõçË•çÈõúÈúçÈõïÈõπÈúÑÈúÜÈúàÈúìÈúéÈúëÈúèÈúñÈúôÈú§Èú™Èú∞ÈúπÈúΩÈúæÈùÑÈùÜÈùàÈùÇÈùâÈùúÈù†Èù§Èù¶Èù®ÂãíÈù´Èù±ÈùπÈûÖÈùºÈûÅÈù∫ÈûÜÈûãÈûèÈûêÈûúÈû®Èû¶Èû£Èû≥Èû¥ÈüÉÈüÜÈüàÈüãÈüúÈü≠ÈΩèÈü≤Á´üÈü∂ÈüµÈ†èÈ†åÈ†∏È†§È†°È†∑È†ΩÈ°ÜÈ°èÈ°ãÈ°´È°ØÈ°∞"],["f1a1","È°±È°¥È°≥È¢™È¢ØÈ¢±È¢∂È£ÑÈ£ÉÈ£ÜÈ£©È£´È§ÉÈ§âÈ§íÈ§îÈ§òÈ§°È§ùÈ§ûÈ§§È§†È§¨È§ÆÈ§ΩÈ§æÈ•ÇÈ•âÈ•ÖÈ•êÈ•ãÈ•ëÈ•íÈ•åÈ•ïÈ¶óÈ¶òÈ¶•È¶≠È¶ÆÈ¶ºÈßüÈßõÈßùÈßòÈßëÈß≠ÈßÆÈß±Èß≤ÈßªÈß∏È®ÅÈ®èÈ®ÖÈß¢È®ôÈ®´È®∑È©ÖÈ©ÇÈ©ÄÈ©ÉÈ®æÈ©ïÈ©çÈ©õÈ©óÈ©üÈ©¢È©•È©§È©©È©´È©™È™≠È™∞È™ºÈ´ÄÈ´èÈ´ëÈ´ìÈ´îÈ´ûÈ´üÈ´¢È´£È´¶È´ØÈ´´È´ÆÈ´¥È´±È´∑"],["f2a1","È´ªÈ¨ÜÈ¨òÈ¨öÈ¨üÈ¨¢È¨£È¨•È¨ßÈ¨®È¨©È¨™È¨ÆÈ¨ØÈ¨≤È≠ÑÈ≠ÉÈ≠èÈ≠çÈ≠éÈ≠ëÈ≠òÈ≠¥ÈÆìÈÆÉÈÆëÈÆñÈÆóÈÆüÈÆ†ÈÆ®ÈÆ¥ÈØÄÈØäÈÆπÈØÜÈØèÈØëÈØíÈØ£ÈØ¢ÈØ§ÈØîÈØ°È∞∫ÈØ≤ÈØ±ÈØ∞È∞ïÈ∞îÈ∞âÈ∞ìÈ∞åÈ∞ÜÈ∞àÈ∞íÈ∞äÈ∞ÑÈ∞ÆÈ∞õÈ∞•È∞§È∞°È∞∞È±áÈ∞≤È±ÜÈ∞æÈ±öÈ±†È±ßÈ±∂È±∏È≥ßÈ≥¨È≥∞È¥âÈ¥àÈ≥´È¥ÉÈ¥ÜÈ¥™È¥¶È∂ØÈ¥£È¥üÈµÑÈ¥ïÈ¥íÈµÅÈ¥øÈ¥æÈµÜÈµà"],["f3a1","ÈµùÈµûÈµ§ÈµëÈµêÈµôÈµ≤È∂âÈ∂áÈ∂´ÈµØÈµ∫È∂öÈ∂§È∂©È∂≤È∑ÑÈ∑ÅÈ∂ªÈ∂∏È∂∫È∑ÜÈ∑èÈ∑ÇÈ∑ôÈ∑ìÈ∑∏È∑¶È∑≠È∑ØÈ∑ΩÈ∏öÈ∏õÈ∏ûÈπµÈππÈπΩÈ∫ÅÈ∫àÈ∫ãÈ∫åÈ∫íÈ∫ïÈ∫ëÈ∫ùÈ∫•È∫©È∫∏È∫™È∫≠Èù°ÈªåÈªéÈªèÈªêÈªîÈªúÈªûÈªùÈª†Èª•Èª®ÈªØÈª¥Èª∂Èª∑ÈªπÈªªÈªºÈªΩÈºáÈºàÁö∑ÈºïÈº°Èº¨ÈºæÈΩäÈΩíÈΩîÈΩ£ÈΩüÈΩ†ÈΩ°ÈΩ¶ÈΩßÈΩ¨ÈΩ™ÈΩ∑ÈΩ≤ÈΩ∂ÈæïÈæúÈæ†"],["f4a1","Â†ØÊßáÈÅôÁë§ÂáúÁÜô"],["f9a1","Á∫äË§úÈçàÈäàËìú‰øâÁÇªÊò±Ê£àÈãπÊõªÂΩÖ‰∏®‰ª°‰ªº‰ºÄ‰ºÉ‰ºπ‰Ωñ‰æí‰æä‰æö‰æî‰øçÂÅÄÂÄ¢‰øøÂÄûÂÅÜÂÅ∞ÂÅÇÂÇîÂÉ¥ÂÉòÂÖäÂÖ§ÂÜùÂÜæÂá¨ÂàïÂäúÂä¶ÂãÄÂãõÂåÄÂåáÂå§Âç≤ÂéìÂé≤ÂèùÔ®éÂíúÂíäÂí©ÂìøÂñÜÂùôÂù•Âû¨ÂüàÂüáÔ®èÔ®êÂ¢ûÂ¢≤Â§ãÂ•ìÂ•õÂ•ùÂ•£Â¶§Â¶∫Â≠ñÂØÄÁîØÂØòÂØ¨Â∞ûÂ≤¶Â≤∫Â≥µÂ¥ßÂµìÔ®ëÂµÇÂµ≠Â∂∏Â∂πÂ∑êÂº°Âº¥ÂΩßÂæ∑"],["faa1","ÂøûÊÅùÊÇÖÊÇäÊÉûÊÉïÊÑ†ÊÉ≤ÊÑëÊÑ∑ÊÑ∞ÊÜòÊàìÊä¶ÊèµÊë†ÊíùÊìéÊïéÊòÄÊòïÊòªÊòâÊòÆÊòûÊò§Êô•ÊôóÊôôÔ®íÊô≥ÊöôÊö†Êö≤ÊöøÊõ∫ÊúéÔ§©Êù¶ÊûªÊ°íÊüÄÊ†ÅÊ°ÑÊ£èÔ®ìÊ•®Ô®îÊ¶òÊß¢Ê®∞Ê©´Ê©ÜÊ©≥Ê©æÊ´¢Ê´§ÊØñÊ∞øÊ±úÊ≤ÜÊ±ØÊ≥öÊ¥ÑÊ∂áÊµØÊ∂ñÊ∂¨Ê∑èÊ∑∏Ê∑≤Ê∑ºÊ∏πÊπúÊ∏ßÊ∏ºÊ∫øÊæàÊæµÊøµÁÄÖÁÄáÁÄ®ÁÇÖÁÇ´ÁÑèÁÑÑÁÖúÁÖÜÁÖáÔ®ïÁáÅÁáæÁä±"],["fba1","ÁäæÁå§Ô®ñÁç∑ÁéΩÁèâÁèñÁè£ÁèíÁêáÁèµÁê¶Áê™Áê©ÁêÆÁë¢ÁíâÁíüÁîÅÁïØÁöÇÁöúÁöûÁöõÁö¶Ô®óÁùÜÂäØÁ†°Á°éÁ°§Á°∫Á§∞Ô®òÔ®ôÔ®öÁ¶îÔ®õÁ¶õÁ´ëÁ´ßÔ®úÁ´´ÁÆûÔ®ùÁµàÁµúÁ∂∑Á∂†Á∑ñÁπíÁΩáÁæ°Ô®ûËåÅËç¢ËçøËèáËè∂ËëàËí¥ËïìËïôËï´Ô®üËñ∞Ô®†Ô®°Ë†áË£µË®íË®∑Ë©πË™ßË™æË´üÔ®¢Ë´∂Ë≠ìË≠øË≥∞Ë≥¥Ë¥íËµ∂Ô®£ËªèÔ®§Ô®•ÈÅßÈÉûÔ®¶ÈÑïÈÑßÈáö"],["fca1","ÈáóÈáûÈá≠ÈáÆÈá§Èá•ÈàÜÈàêÈàäÈà∫ÈâÄÈàºÈâéÈâôÈâëÈàπÈâßÈäßÈâ∑Èâ∏ÈãßÈãóÈãôÈãêÔ®ßÈãïÈã†ÈãìÈå•Èå°ÈãªÔ®®ÈåûÈãøÈåùÈåÇÈç∞ÈçóÈé§ÈèÜÈèûÈè∏Èê±ÈëÖÈëàÈñíÔßúÔ®©ÈöùÈöØÈú≥ÈúªÈùÉÈùçÈùèÈùëÈùïÈ°óÈ°•Ô®™Ô®´È§ßÔ®¨È¶ûÈ©éÈ´ôÈ´úÈ≠µÈ≠≤ÈÆèÈÆ±ÈÆªÈ∞ÄÈµ∞Èµ´Ô®≠È∏ôÈªë"],["fcf1","‚Ö∞",9,"Ôø¢Ôø§ÔºáÔºÇ"],["8fa2af","ÀòÀá¬∏ÀôÀù¬ØÀõÀöÔΩûŒÑŒÖ"],["8fa2c2","¬°¬¶¬ø"],["8fa2eb","¬∫¬™¬©¬Æ‚Ñ¢¬§‚Ññ"],["8fa6e1","ŒÜŒàŒâŒäŒ™"],["8fa6e7","Œå"],["8fa6e9","ŒéŒ´"],["8fa6ec","Œè"],["8fa6f1","Œ¨Œ≠ŒÆŒØœäŒêœåœÇœçœãŒ∞œé"],["8fa7c2","–Ç",10,"–é–è"],["8fa7f2","—í",10,"—û—ü"],["8fa9a1","√Üƒê"],["8fa9a4","ƒ¶"],["8fa9a6","ƒ≤"],["8fa9a8","≈Åƒø"],["8fa9ab","≈ä√ò≈í"],["8fa9af","≈¶√û"],["8fa9c1","√¶ƒë√∞ƒßƒ±ƒ≥ƒ∏≈Ç≈Ä≈â≈ã√∏≈ì√ü≈ß√æ"],["8faaa1","√Å√Ä√Ñ√ÇƒÇ«çƒÄƒÑ√Ö√ÉƒÜƒàƒå√áƒäƒé√â√à√ã√äƒöƒñƒíƒò"],["8faaba","ƒúƒûƒ¢ƒ†ƒ§√ç√å√è√é«èƒ∞ƒ™ƒÆƒ®ƒ¥ƒ∂ƒπƒΩƒª≈É≈á≈Ö√ë√ì√í√ñ√î«ë≈ê≈å√ï≈î≈ò≈ñ≈ö≈ú≈†≈û≈§≈¢√ö√ô√ú√õ≈¨«ì≈∞≈™≈≤≈Æ≈®«ó«õ«ô«ï≈¥√ù≈∏≈∂≈π≈Ω≈ª"],["8faba1","√°√†√§√¢ƒÉ«éƒÅƒÖ√•√£ƒáƒâƒç√ßƒãƒè√©√®√´√™ƒõƒóƒìƒô«µƒùƒü"],["8fabbd","ƒ°ƒ•√≠√¨√Ø√Æ«ê"],["8fabc5","ƒ´ƒØƒ©ƒµƒ∑ƒ∫ƒæƒº≈Ñ≈à≈Ü√±√≥√≤√∂√¥«í≈ë≈ç√µ≈ï≈ô≈ó≈õ≈ù≈°≈ü≈•≈£√∫√π√º√ª≈≠«î≈±≈´≈≥≈Ø≈©«ò«ú«ö«ñ≈µ√Ω√ø≈∑≈∫≈æ≈º"],["8fb0a1","‰∏Ç‰∏Ñ‰∏Ö‰∏å‰∏í‰∏ü‰∏£‰∏§‰∏®‰∏´‰∏Æ‰∏Ø‰∏∞‰∏µ‰πÄ‰πÅ‰πÑ‰πá‰πë‰πö‰πú‰π£‰π®‰π©‰π¥‰πµ‰ππ‰πø‰∫ç‰∫ñ‰∫ó‰∫ù‰∫Ø‰∫π‰ªÉ‰ªê‰ªö‰ªõ‰ª†‰ª°‰ª¢‰ª®‰ªØ‰ª±‰ª≥‰ªµ‰ªΩ‰ªæ‰ªø‰ºÄ‰ºÇ‰ºÉ‰ºà‰ºã‰ºå‰ºí‰ºï‰ºñ‰ºó‰ºô‰ºÆ‰º±‰Ω†‰º≥‰ºµ‰º∑‰ºπ‰ºª‰ºæ‰ΩÄ‰ΩÇ‰Ωà‰Ωâ‰Ωã‰Ωå‰Ωí‰Ωî‰Ωñ‰Ωò‰Ωü‰Ω£‰Ω™‰Ω¨‰ΩÆ‰Ω±‰Ω∑‰Ω∏‰Ωπ‰Ω∫‰ΩΩ‰Ωæ‰æÅ‰æÇ‰æÑ"],["8fb1a1","‰æÖ‰æâ‰æä‰æå‰æé‰æê‰æí‰æì‰æî‰æó‰æô‰æö‰æû‰æü‰æ≤‰æ∑‰æπ‰æª‰æº‰æΩ‰ææ‰øÄ‰øÅ‰øÖ‰øÜ‰øà‰øâ‰øã‰øå‰øç‰øè‰øí‰øú‰ø†‰ø¢‰ø∞‰ø≤‰øº‰øΩ‰øøÂÄÄÂÄÅÂÄÑÂÄáÂÄäÂÄåÂÄéÂÄêÂÄìÂÄóÂÄòÂÄõÂÄúÂÄùÂÄûÂÄ¢ÂÄßÂÄÆÂÄ∞ÂÄ≤ÂÄ≥ÂÄµÂÅÄÂÅÅÂÅÇÂÅÖÂÅÜÂÅäÂÅåÂÅéÂÅëÂÅíÂÅìÂÅóÂÅôÂÅüÂÅ†ÂÅ¢ÂÅ£ÂÅ¶ÂÅßÂÅ™ÂÅ≠ÂÅ∞ÂÅ±ÂÄªÂÇÅÂÇÉÂÇÑÂÇÜÂÇäÂÇéÂÇèÂÇê"],["8fb2a1","ÂÇíÂÇìÂÇîÂÇñÂÇõÂÇúÂÇû",4,"ÂÇ™ÂÇØÂÇ∞ÂÇπÂÇ∫ÂÇΩÂÉÄÂÉÉÂÉÑÂÉáÂÉåÂÉéÂÉêÂÉìÂÉîÂÉòÂÉúÂÉùÂÉüÂÉ¢ÂÉ§ÂÉ¶ÂÉ®ÂÉ©ÂÉØÂÉ±ÂÉ∂ÂÉ∫ÂÉæÂÑÉÂÑÜÂÑáÂÑàÂÑãÂÑåÂÑçÂÑéÂÉ≤ÂÑêÂÑóÂÑôÂÑõÂÑúÂÑùÂÑûÂÑ£ÂÑßÂÑ®ÂÑ¨ÂÑ≠ÂÑØÂÑ±ÂÑ≥ÂÑ¥ÂÑµÂÑ∏ÂÑπÂÖÇÂÖäÂÖèÂÖìÂÖïÂÖóÂÖòÂÖüÂÖ§ÂÖ¶ÂÖæÂÜÉÂÜÑÂÜãÂÜéÂÜòÂÜùÂÜ°ÂÜ£ÂÜ≠ÂÜ∏ÂÜ∫ÂÜºÂÜæÂÜøÂáÇ"],["8fb3a1","ÂáàÂáèÂáëÂáíÂáìÂáïÂáòÂáûÂá¢Âá•ÂáÆÂá≤Âá≥Âá¥Âá∑ÂàÅÂàÇÂàÖÂàíÂàìÂàïÂàñÂàòÂà¢Âà®Âà±Âà≤ÂàµÂàºÂâÖÂââÂâïÂâóÂâòÂâöÂâúÂâüÂâ†Ââ°Ââ¶ÂâÆÂâ∑Ââ∏ÂâπÂäÄÂäÇÂäÖÂääÂäåÂäìÂäïÂäñÂäóÂäòÂäöÂäúÂä§Âä•Âä¶ÂäßÂäØÂä∞Âä∂Âä∑Âä∏Âä∫ÂäªÂäΩÂãÄÂãÑÂãÜÂãàÂãåÂãèÂãëÂãîÂãñÂãõÂãúÂã°Âã•Âã®Âã©Âã™Âã¨Âã∞Âã±Âã¥Âã∂Âã∑ÂåÄÂåÉÂåäÂåã"],["8fb4a1","ÂååÂåëÂåìÂåòÂåõÂåúÂåûÂåüÂå•ÂåßÂå®Âå©Âå´Âå¨Âå≠Âå∞Âå≤ÂåµÂåºÂåΩÂåæÂçÇÂçåÂçãÂçôÂçõÂç°Âç£Âç•Âç¨Âç≠Âç≤ÂçπÂçæÂéÉÂéáÂéàÂééÂéìÂéîÂéôÂéùÂé°Âé§Âé™Âé´ÂéØÂé≤Âé¥ÂéµÂé∑Âé∏Âé∫ÂéΩÂèÄÂèÖÂèèÂèíÂèìÂèïÂèöÂèùÂèûÂè†Âè¶ÂèßÂèµÂêÇÂêìÂêöÂê°ÂêßÂê®Âê™ÂêØÂê±Âê¥ÂêµÂëÉÂëÑÂëáÂëçÂëèÂëûÂë¢Âë§Âë¶ÂëßÂë©Âë´Âë≠ÂëÆÂë¥Âëø"],["8fb5a1","ÂíÅÂíÉÂíÖÂíàÂíâÂíçÂíëÂíïÂíñÂíúÂíüÂí°Âí¶ÂíßÂí©Âí™Âí≠ÂíÆÂí±Âí∑ÂíπÂí∫ÂíªÂíøÂìÜÂìäÂìçÂìéÂì†Âì™Âì¨ÂìØÂì∂ÂìºÂìæÂìøÂîÄÂîÅÂîÖÂîàÂîâÂîåÂîçÂîéÂîïÂî™Âî´Âî≤ÂîµÂî∂ÂîªÂîºÂîΩÂïÅÂïáÂïâÂïäÂïçÂïêÂïëÂïòÂïöÂïõÂïûÂï†Âï°Âï§Âï¶ÂïøÂñÅÂñÇÂñÜÂñàÂñéÂñèÂñëÂñíÂñìÂñîÂñóÂñ£Âñ§Âñ≠Âñ≤ÂñøÂóÅÂóÉÂóÜÂóâÂóãÂóåÂóéÂóëÂóí"],["8fb6a1","ÂóìÂóóÂóòÂóõÂóûÂó¢Âó©Âó∂ÂóøÂòÖÂòàÂòäÂòç",5,"ÂòôÂò¨Âò∞Âò≥ÂòµÂò∑ÂòπÂòªÂòºÂòΩÂòøÂôÄÂôÅÂôÉÂôÑÂôÜÂôâÂôãÂôçÂôèÂôîÂôûÂô†Âô°Âô¢Âô£Âô¶Âô©Âô≠ÂôØÂô±Âô≤ÂôµÂöÑÂöÖÂöàÂöãÂöåÂöïÂöôÂööÂöùÂöûÂöüÂö¶ÂößÂö®Âö©Âö´Âö¨Âö≠Âö±Âö≥Âö∑ÂöæÂõÖÂõâÂõäÂõãÂõèÂõêÂõåÂõçÂõôÂõúÂõùÂõüÂõ°Âõ§",4,"Âõ±Âõ´Âõ≠"],["8fb7a1","Âõ∂Âõ∑ÂúÅÂúÇÂúáÂúäÂúåÂúëÂúïÂúöÂúõÂúùÂú†Âú¢Âú£Âú§Âú•Âú©Âú™Âú¨ÂúÆÂúØÂú≥Âú¥ÂúΩÂúæÂúøÂùÖÂùÜÂùåÂùçÂùíÂù¢Âù•ÂùßÂù®Âù´Âù≠",4,"Âù≥Âù¥ÂùµÂù∑ÂùπÂù∫ÂùªÂùºÂùæÂûÅÂûÉÂûåÂûîÂûóÂûôÂûöÂûúÂûùÂûûÂûüÂû°ÂûïÂûßÂû®Âû©Âû¨Âû∏ÂûΩÂüáÂüàÂüåÂüèÂüïÂüùÂüûÂü§Âü¶ÂüßÂü©Âü≠Âü∞ÂüµÂü∂Âü∏ÂüΩÂüæÂüøÂ†ÉÂ†ÑÂ†àÂ†âÂü°"],["8fb8a1","Â†åÂ†çÂ†õÂ†ûÂ†üÂ††Â†¶Â†ßÂ†≠Â†≤Â†πÂ†øÂ°âÂ°åÂ°çÂ°èÂ°êÂ°ïÂ°üÂ°°Â°§Â°ßÂ°®Â°∏Â°ºÂ°øÂ¢ÄÂ¢ÅÂ¢áÂ¢àÂ¢âÂ¢äÂ¢åÂ¢çÂ¢èÂ¢êÂ¢îÂ¢ñÂ¢ùÂ¢†Â¢°Â¢¢Â¢¶Â¢©Â¢±Â¢≤Â£ÑÂ¢ºÂ£ÇÂ£àÂ£çÂ£éÂ£êÂ£íÂ£îÂ£ñÂ£öÂ£ùÂ£°Â£¢Â£©Â£≥Â§ÖÂ§ÜÂ§ãÂ§åÂ§íÂ§ìÂ§îËôÅÂ§ùÂ§°Â§£Â§§Â§®Â§ØÂ§∞Â§≥Â§µÂ§∂Â§øÂ•ÉÂ•ÜÂ•íÂ•ìÂ•ôÂ•õÂ•ùÂ•ûÂ•üÂ•°Â•£Â•´Â•≠"],["8fb9a1","Â•ØÂ•≤Â•µÂ•∂Â•πÂ•ªÂ•ºÂ¶ãÂ¶åÂ¶éÂ¶íÂ¶ïÂ¶óÂ¶üÂ¶§Â¶ßÂ¶≠Â¶ÆÂ¶ØÂ¶∞Â¶≥Â¶∑Â¶∫Â¶ºÂßÅÂßÉÂßÑÂßàÂßäÂßçÂßíÂßùÂßûÂßüÂß£Âß§ÂßßÂßÆÂßØÂß±Âß≤Âß¥Âß∑Â®ÄÂ®ÑÂ®åÂ®çÂ®éÂ®íÂ®ìÂ®ûÂ®£Â®§Â®ßÂ®®Â®™Â®≠Â®∞Â©ÑÂ©ÖÂ©áÂ©àÂ©åÂ©êÂ©ïÂ©ûÂ©£Â©•Â©ßÂ©≠Â©∑Â©∫Â©ªÂ©æÂ™ãÂ™êÂ™ìÂ™ñÂ™ôÂ™úÂ™ûÂ™üÂ™†Â™¢Â™ßÂ™¨Â™±Â™≤Â™≥Â™µÂ™∏Â™∫Â™ªÂ™ø"],["8fbaa1","Â´ÑÂ´ÜÂ´àÂ´èÂ´öÂ´úÂ´†Â´•Â´™Â´ÆÂ´µÂ´∂Â´ΩÂ¨ÄÂ¨ÅÂ¨àÂ¨óÂ¨¥Â¨ôÂ¨õÂ¨ùÂ¨°Â¨•Â¨≠Â¨∏Â≠ÅÂ≠ãÂ≠åÂ≠íÂ≠ñÂ≠ûÂ≠®Â≠ÆÂ≠ØÂ≠ºÂ≠ΩÂ≠æÂ≠øÂÆÅÂÆÑÂÆÜÂÆäÂÆéÂÆêÂÆëÂÆìÂÆîÂÆñÂÆ®ÂÆ©ÂÆ¨ÂÆ≠ÂÆØÂÆ±ÂÆ≤ÂÆ∑ÂÆ∫ÂÆºÂØÄÂØÅÂØçÂØèÂØñ",4,"ÂØ†ÂØØÂØ±ÂØ¥ÂØΩÂ∞åÂ∞óÂ∞ûÂ∞üÂ∞£Â∞¶Â∞©Â∞´Â∞¨Â∞ÆÂ∞∞Â∞≤Â∞µÂ∞∂Â±ôÂ±öÂ±úÂ±¢Â±£Â±ßÂ±®Â±©"],["8fbba1","Â±≠Â±∞Â±¥Â±µÂ±∫Â±ªÂ±ºÂ±ΩÂ≤áÂ≤àÂ≤äÂ≤èÂ≤íÂ≤ùÂ≤üÂ≤†Â≤¢Â≤£Â≤¶Â≤™Â≤≤Â≤¥Â≤µÂ≤∫Â≥âÂ≥ãÂ≥íÂ≥ùÂ≥óÂ≥ÆÂ≥±Â≥≤Â≥¥Â¥ÅÂ¥ÜÂ¥çÂ¥íÂ¥´Â¥£Â¥§Â¥¶Â¥ßÂ¥±Â¥¥Â¥πÂ¥ΩÂ¥øÂµÇÂµÉÂµÜÂµàÂµïÂµëÂµôÂµäÂµüÂµ†Âµ°Âµ¢Âµ§Âµ™Âµ≠Âµ∞ÂµπÂµ∫ÂµæÂµøÂ∂ÅÂ∂ÉÂ∂àÂ∂äÂ∂íÂ∂ìÂ∂îÂ∂ïÂ∂ôÂ∂õÂ∂üÂ∂†Â∂ßÂ∂´Â∂∞Â∂¥Â∂∏Â∂πÂ∑ÉÂ∑áÂ∑ãÂ∑êÂ∑éÂ∑òÂ∑ôÂ∑†Â∑§"],["8fbca1","Â∑©Â∑∏Â∑πÂ∏ÄÂ∏áÂ∏çÂ∏íÂ∏îÂ∏ïÂ∏òÂ∏üÂ∏†Â∏ÆÂ∏®Â∏≤Â∏µÂ∏æÂπãÂπêÂπâÂπëÂπñÂπòÂπõÂπúÂπûÂπ®Âπ™",4,"Âπ∞Â∫ÄÂ∫ãÂ∫éÂ∫¢Â∫§Â∫•Â∫®Â∫™Â∫¨Â∫±Â∫≥Â∫ΩÂ∫æÂ∫øÂªÜÂªåÂªãÂªéÂªëÂªíÂªîÂªïÂªúÂªûÂª•Âª´ÂºÇÂºÜÂºáÂºàÂºéÂºôÂºúÂºùÂº°Âº¢Âº£Âº§Âº®Âº´Âº¨ÂºÆÂº∞Âº¥Âº∂ÂºªÂºΩÂºøÂΩÄÂΩÑÂΩÖÂΩáÂΩçÂΩêÂΩîÂΩòÂΩõÂΩ†ÂΩ£ÂΩ§ÂΩß"],["8fbda1","ÂΩØÂΩ≤ÂΩ¥ÂΩµÂΩ∏ÂΩ∫ÂΩΩÂΩæÂæâÂæçÂæèÂæñÂæúÂæùÂæ¢ÂæßÂæ´Âæ§Âæ¨ÂæØÂæ∞Âæ±Âæ∏ÂøÑÂøáÂøàÂøâÂøãÂøê",4,"ÂøûÂø°Âø¢Âø®Âø©Âø™Âø¨Âø≠ÂøÆÂøØÂø≤Âø≥Âø∂Âø∫ÂøºÊÄáÊÄäÊÄçÊÄìÊÄîÊÄóÊÄòÊÄöÊÄüÊÄ§ÊÄ≠ÊÄ≥ÊÄµÊÅÄÊÅáÊÅàÊÅâÊÅåÊÅëÊÅîÊÅñÊÅóÊÅùÊÅ°ÊÅßÊÅ±ÊÅæÊÅøÊÇÇÊÇÜÊÇàÊÇäÊÇéÊÇëÊÇìÊÇïÊÇòÊÇùÊÇûÊÇ¢ÊÇ§ÊÇ•ÊÇ®ÊÇ∞ÊÇ±ÊÇ∑"],["8fbea1","ÊÇªÊÇæÊÉÇÊÉÑÊÉàÊÉâÊÉäÊÉãÊÉéÊÉèÊÉîÊÉïÊÉôÊÉõÊÉùÊÉûÊÉ¢ÊÉ•ÊÉ≤ÊÉµÊÉ∏ÊÉºÊÉΩÊÑÇÊÑáÊÑäÊÑåÊÑê",4,"ÊÑñÊÑóÊÑôÊÑúÊÑûÊÑ¢ÊÑ™ÊÑ´ÊÑ∞ÊÑ±ÊÑµÊÑ∂ÊÑ∑ÊÑπÊÖÅÊÖÖÊÖÜÊÖâÊÖûÊÖ†ÊÖ¨ÊÖ≤ÊÖ∏ÊÖªÊÖºÊÖøÊÜÄÊÜÅÊÜÉÊÜÑÊÜãÊÜçÊÜíÊÜìÊÜóÊÜòÊÜúÊÜùÊÜüÊÜ†ÊÜ•ÊÜ®ÊÜ™ÊÜ≠ÊÜ∏ÊÜπÊÜºÊáÄÊáÅÊáÇÊáéÊáèÊáïÊáúÊáùÊáûÊáüÊá°Êá¢ÊáßÊá©Êá•"],["8fbfa1","Êá¨Êá≠ÊáØÊàÅÊàÉÊàÑÊàáÊàìÊàïÊàúÊà†Êà¢Êà£ÊàßÊà©Êà´ÊàπÊàΩÊâÇÊâÉÊâÑÊâÜÊâåÊâêÊâëÊâíÊâîÊâñÊâöÊâúÊâ§Êâ≠ÊâØÊâ≥Êâ∫ÊâΩÊäçÊäéÊäèÊäêÊä¶Êä®Êä≥Êä∂Êä∑Êä∫ÊäæÊäøÊãÑÊãéÊãïÊãñÊãöÊã™Êã≤Êã¥ÊãºÊãΩÊåÉÊåÑÊåäÊåãÊåçÊåêÊåìÊåñÊåòÊå©Êå™Êå≠ÊåµÊå∂ÊåπÊåºÊçÅÊçÇÊçÉÊçÑÊçÜÊçäÊçãÊçéÊçíÊçìÊçîÊçòÊçõÊç•Êç¶Êç¨Êç≠Êç±Êç¥Êçµ"],["8fc0a1","Êç∏ÊçºÊçΩÊçøÊéÇÊéÑÊéáÊéäÊéêÊéîÊéïÊéôÊéöÊéûÊé§Êé¶Êé≠ÊéÆÊéØÊéΩÊèÅÊèÖÊèàÊèéÊèëÊèìÊèîÊèïÊèúÊè†Êè•Êè™Êè¨Êè≤Êè≥ÊèµÊè∏ÊèπÊêâÊêäÊêêÊêíÊêîÊêòÊêûÊê†Êê¢Êê§Êê•Êê©Êê™ÊêØÊê∞ÊêµÊêΩÊêøÊëãÊëèÊëëÊëíÊëìÊëîÊëöÊëõÊëúÊëùÊëüÊë†Êë°Êë£Êë≠Êë≥Êë¥ÊëªÊëΩÊíÖÊíáÊíèÊíêÊíëÊíòÊíôÊíõÊíùÊíüÊí°Êí£Êí¶Êí®Êí¨Êí≥ÊíΩÊíæÊíø"],["8fc1a1","ÊìÑÊìâÊìäÊìãÊìåÊìéÊìêÊìëÊìïÊìóÊì§Êì•Êì©Êì™Êì≠Êì∞ÊìµÊì∑ÊìªÊìøÊîÅÊîÑÊîàÊîâÊîäÊîèÊîìÊîîÊîñÊîôÊîõÊîûÊîüÊî¢Êî¶Êî©ÊîÆÊî±Êî∫ÊîºÊîΩÊïÉÊïáÊïâÊïêÊïíÊïîÊïüÊï†ÊïßÊï´Êï∫ÊïΩÊñÅÊñÖÊñäÊñíÊñïÊñòÊñùÊñ†Êñ£Êñ¶ÊñÆÊñ≤Êñ≥Êñ¥ÊñøÊóÇÊóàÊóâÊóéÊóêÊóîÊóñÊóòÊóüÊó∞Êó≤Êó¥ÊóµÊóπÊóæÊóøÊòÄÊòÑÊòàÊòâÊòçÊòëÊòíÊòïÊòñÊòù"],["8fc2a1","ÊòûÊò°Êò¢Êò£Êò§Êò¶Êò©Êò™Êò´Êò¨ÊòÆÊò∞Êò±Êò≥ÊòπÊò∑ÊôÄÊôÖÊôÜÊôäÊôåÊôëÊôéÊôóÊôòÊôôÊôõÊôúÊô†Êô°ÊõªÊô™Êô´Êô¨ÊôæÊô≥ÊôµÊôøÊô∑Êô∏ÊôπÊôªÊöÄÊôºÊöãÊöåÊöçÊöêÊöíÊöôÊööÊöõÊöúÊöüÊö†Êö§Êö≠Êö±Êö≤ÊöµÊöªÊöøÊõÄÊõÇÊõÉÊõàÊõåÊõéÊõèÊõîÊõõÊõüÊõ®Êõ´Êõ¨ÊõÆÊõ∫ÊúÖÊúáÊúéÊúìÊúôÊúúÊú†Êú¢Êú≥ÊúæÊùÖÊùáÊùàÊùåÊùîÊùïÊùù"],["8fc3a1","Êù¶Êù¨ÊùÆÊù¥Êù∂ÊùªÊûÅÊûÑÊûéÊûèÊûëÊûìÊûñÊûòÊûôÊûõÊû∞Êû±Êû≤ÊûµÊûªÊûºÊûΩÊüπÊüÄÊüÇÊüÉÊüÖÊüàÊüâÊüíÊüóÊüôÊüúÊü°Êü¶Êü∞Êü≤Êü∂Êü∑Ê°íÊ†îÊ†ôÊ†ùÊ†üÊ†®Ê†ßÊ†¨Ê†≠Ê†ØÊ†∞Ê†±Ê†≥Ê†ªÊ†øÊ°ÑÊ°ÖÊ°äÊ°åÊ°ïÊ°óÊ°òÊ°õÊ°´Ê°Æ",4,"Ê°µÊ°πÊ°∫Ê°ªÊ°ºÊ¢ÇÊ¢ÑÊ¢ÜÊ¢àÊ¢ñÊ¢òÊ¢öÊ¢úÊ¢°Ê¢£Ê¢•Ê¢©Ê¢™Ê¢ÆÊ¢≤Ê¢ªÊ£ÖÊ£àÊ£åÊ£è"],["8fc4a1","Ê£êÊ£ëÊ£ìÊ£ñÊ£ôÊ£úÊ£ùÊ£•Ê£®Ê£™Ê£´Ê£¨Ê£≠Ê£∞Ê£±Ê£µÊ£∂Ê£ªÊ£ºÊ£ΩÊ§ÜÊ§âÊ§äÊ§êÊ§ëÊ§ìÊ§ñÊ§óÊ§±Ê§≥Ê§µÊ§∏Ê§ªÊ•ÇÊ•ÖÊ•âÊ•éÊ•óÊ•õÊ•£Ê•§Ê••Ê•¶Ê•®Ê•©Ê•¨Ê•∞Ê•±Ê•≤Ê•∫Ê•ªÊ•øÊ¶ÄÊ¶çÊ¶íÊ¶ñÊ¶òÊ¶°Ê¶•Ê¶¶Ê¶®Ê¶´Ê¶≠Ê¶ØÊ¶∑Ê¶∏Ê¶∫Ê¶ºÊßÖÊßàÊßëÊßñÊßóÊß¢Êß•ÊßÆÊßØÊß±Êß≥ÊßµÊßæÊ®ÄÊ®ÅÊ®ÉÊ®èÊ®ëÊ®ïÊ®öÊ®ùÊ®†Ê®§Ê®®Ê®∞Ê®≤"],["8fc5a1","Ê®¥Ê®∑Ê®ªÊ®æÊ®øÊ©ÖÊ©ÜÊ©âÊ©äÊ©éÊ©êÊ©ëÊ©íÊ©ïÊ©ñÊ©õÊ©§Ê©ßÊ©™Ê©±Ê©≥Ê©æÊ™ÅÊ™ÉÊ™ÜÊ™áÊ™âÊ™ãÊ™ëÊ™õÊ™ùÊ™ûÊ™üÊ™•Ê™´Ê™ØÊ™∞Ê™±Ê™¥Ê™ΩÊ™æÊ™øÊ´ÜÊ´âÊ´àÊ´åÊ´êÊ´îÊ´ïÊ´ñÊ´úÊ´ùÊ´§Ê´ßÊ´¨Ê´∞Ê´±Ê´≤Ê´ºÊ´ΩÊ¨ÇÊ¨ÉÊ¨ÜÊ¨áÊ¨âÊ¨èÊ¨êÊ¨ëÊ¨óÊ¨õÊ¨ûÊ¨§Ê¨®Ê¨´Ê¨¨Ê¨ØÊ¨µÊ¨∂Ê¨ªÊ¨øÊ≠ÜÊ≠äÊ≠çÊ≠íÊ≠ñÊ≠òÊ≠ùÊ≠†Ê≠ßÊ≠´Ê≠ÆÊ≠∞Ê≠µÊ≠Ω"],["8fc6a1","Ê≠æÊÆÇÊÆÖÊÆóÊÆõÊÆüÊÆ†ÊÆ¢ÊÆ£ÊÆ®ÊÆ©ÊÆ¨ÊÆ≠ÊÆÆÊÆ∞ÊÆ∏ÊÆπÊÆΩÊÆæÊØÉÊØÑÊØâÊØåÊØñÊØöÊØ°ÊØ£ÊØ¶ÊØßÊØÆÊØ±ÊØ∑ÊØπÊØøÊ∞ÇÊ∞ÑÊ∞ÖÊ∞âÊ∞çÊ∞éÊ∞êÊ∞íÊ∞ôÊ∞üÊ∞¶Ê∞ßÊ∞®Ê∞¨Ê∞ÆÊ∞≥Ê∞µÊ∞∂Ê∞∫Ê∞ªÊ∞øÊ±äÊ±ãÊ±çÊ±èÊ±íÊ±îÊ±ôÊ±õÊ±úÊ±´Ê±≠Ê±ØÊ±¥Ê±∂Ê±∏Ê±πÊ±ªÊ≤ÖÊ≤ÜÊ≤áÊ≤âÊ≤îÊ≤ïÊ≤óÊ≤òÊ≤úÊ≤üÊ≤∞Ê≤≤Ê≤¥Ê≥ÇÊ≥ÜÊ≥çÊ≥èÊ≥êÊ≥ëÊ≥íÊ≥îÊ≥ñ"],["8fc7a1","Ê≥öÊ≥úÊ≥†Ê≥ßÊ≥©Ê≥´Ê≥¨Ê≥ÆÊ≥≤Ê≥¥Ê¥ÑÊ¥áÊ¥äÊ¥éÊ¥èÊ¥ëÊ¥ìÊ¥öÊ¥¶Ê¥ßÊ¥®Ê±ßÊ¥ÆÊ¥ØÊ¥±Ê¥πÊ¥ºÊ¥øÊµóÊµûÊµüÊµ°Êµ•ÊµßÊµØÊµ∞ÊµºÊ∂ÇÊ∂áÊ∂ëÊ∂íÊ∂îÊ∂ñÊ∂óÊ∂òÊ∂™Ê∂¨Ê∂¥Ê∂∑Ê∂πÊ∂ΩÊ∂øÊ∑ÑÊ∑àÊ∑äÊ∑éÊ∑èÊ∑ñÊ∑õÊ∑ùÊ∑üÊ∑†Ê∑¢Ê∑•Ê∑©Ê∑ØÊ∑∞Ê∑¥Ê∑∂Ê∑ºÊ∏ÄÊ∏ÑÊ∏ûÊ∏¢Ê∏ßÊ∏≤Ê∏∂Ê∏πÊ∏ªÊ∏ºÊπÑÊπÖÊπàÊπâÊπãÊπèÊπëÊπíÊπìÊπîÊπóÊπúÊπùÊπû"],["8fc8a1","Êπ¢Êπ£Êπ®Êπ≥ÊπªÊπΩÊ∫çÊ∫ìÊ∫ôÊ∫†Ê∫ßÊ∫≠Ê∫ÆÊ∫±Ê∫≥Ê∫ªÊ∫øÊªÄÊªÅÊªÉÊªáÊªàÊªäÊªçÊªéÊªèÊª´Êª≠ÊªÆÊªπÊªªÊªΩÊºÑÊºàÊºäÊºåÊºçÊºñÊºòÊºöÊºõÊº¶Êº©Êº™ÊºØÊº∞Êº≥Êº∂ÊºªÊººÊº≠ÊΩèÊΩëÊΩíÊΩìÊΩóÊΩôÊΩöÊΩùÊΩûÊΩ°ÊΩ¢ÊΩ®ÊΩ¨ÊΩΩÊΩæÊæÉÊæáÊæàÊæãÊæåÊæçÊæêÊæíÊæìÊæîÊæñÊæöÊæüÊæ†Êæ•Êæ¶ÊæßÊæ®ÊæÆÊæØÊæ∞ÊæµÊæ∂ÊæºÊøÖÊøáÊøàÊøä"],["8fc9a1","ÊøöÊøûÊø®Êø©Êø∞ÊøµÊøπÊøºÊøΩÁÄÄÁÄÖÁÄÜÁÄáÁÄçÁÄóÁÄ†ÁÄ£ÁÄØÁÄ¥ÁÄ∑ÁÄπÁÄºÁÅÉÁÅÑÁÅàÁÅâÁÅäÁÅãÁÅîÁÅïÁÅùÁÅûÁÅéÁÅ§ÁÅ•ÁÅ¨ÁÅÆÁÅµÁÅ∂ÁÅæÁÇÅÁÇÖÁÇÜÁÇî",4,"ÁÇõÁÇ§ÁÇ´ÁÇ∞ÁÇ±ÁÇ¥ÁÇ∑ÁÉäÁÉëÁÉìÁÉîÁÉïÁÉñÁÉòÁÉúÁÉ§ÁÉ∫ÁÑÉ",4,"ÁÑãÁÑåÁÑèÁÑûÁÑ†ÁÑ´ÁÑ≠ÁÑØÁÑ∞ÁÑ±ÁÑ∏ÁÖÅÁÖÖÁÖÜÁÖáÁÖäÁÖãÁÖêÁÖíÁÖóÁÖöÁÖúÁÖûÁÖ†"],["8fcaa1","ÁÖ®ÁÖπÁÜÄÁÜÖÁÜáÁÜåÁÜíÁÜöÁÜõÁÜ†ÁÜ¢ÁÜØÁÜ∞ÁÜ≤ÁÜ≥ÁÜ∫ÁÜøÁáÄÁáÅÁáÑÁáãÁáåÁáìÁáñÁáôÁáöÁáúÁá∏ÁáæÁàÄÁàáÁààÁàâÁàìÁàóÁàöÁàùÁàüÁà§Áà´ÁàØÁà¥Áà∏ÁàπÁâÅÁâÇÁâÉÁâÖÁâéÁâèÁâêÁâìÁâïÁâñÁâöÁâúÁâûÁâ†Áâ£Áâ®Áâ´ÁâÆÁâØÁâ±Áâ∑Áâ∏ÁâªÁâºÁâøÁäÑÁäâÁäçÁäéÁäìÁäõÁä®Áä≠ÁäÆÁä±Áä¥ÁäæÁãÅÁãáÁãâÁãåÁãïÁãñÁãòÁãüÁã•Áã≥Áã¥Áã∫Áãª"],["8fcba1","ÁãæÁåÇÁåÑÁåÖÁåáÁåãÁåçÁåíÁåìÁåòÁåôÁåûÁå¢Áå§ÁåßÁå®Áå¨Áå±Áå≤ÁåµÁå∫ÁåªÁåΩÁçÉÁççÁçêÁçíÁçñÁçòÁçùÁçûÁçüÁç†Áç¶ÁçßÁç©Áç´Áç¨ÁçÆÁçØÁç±Áç∑ÁçπÁçºÁéÄÁéÅÁéÉÁéÖÁéÜÁééÁéêÁéìÁéïÁéóÁéòÁéúÁéûÁéüÁé†Áé¢Áé•Áé¶Áé™Áé´Áé≠ÁéµÁé∑ÁéπÁéºÁéΩÁéøÁèÖÁèÜÁèâÁèãÁèåÁèèÁèíÁèìÁèñÁèôÁèùÁè°Áè£Áè¶ÁèßÁè©Áè¥ÁèµÁè∑ÁèπÁè∫ÁèªÁèΩ"],["8fcca1","ÁèøÁêÄÁêÅÁêÑÁêáÁêäÁêëÁêöÁêõÁê§Áê¶Áê®",9,"ÁêπÁëÄÁëÉÁëÑÁëÜÁëáÁëãÁëçÁëëÁëíÁëóÁëùÁë¢Áë¶ÁëßÁë®Áë´Áë≠ÁëÆÁë±Áë≤ÁíÄÁíÅÁíÖÁíÜÁíáÁíâÁíèÁíêÁíëÁííÁíòÁíôÁíöÁíúÁíüÁí†Áí°Áí£Áí¶Áí®Áí©Áí™Áí´ÁíÆÁíØÁí±Áí≤ÁíµÁíπÁíªÁíøÁìàÁìâÁìåÁìêÁììÁìòÁìöÁìõÁìûÁìüÁì§Áì®Áì™Áì´ÁìØÁì¥Áì∫ÁìªÁìºÁìøÁîÜ"],["8fcda1","ÁîíÁîñÁîóÁî†Áî°Áî§ÁîßÁî©Áî™ÁîØÁî∂ÁîπÁîΩÁîæÁîøÁïÄÁïÉÁïáÁïàÁïéÁïêÁïíÁïóÁïûÁïüÁï°ÁïØÁï±Áïπ",5,"ÁñÅÁñÖÁñêÁñíÁñìÁñïÁñôÁñúÁñ¢Áñ§Áñ¥Áñ∫ÁñøÁóÄÁóÅÁóÑÁóÜÁóåÁóéÁóèÁóóÁóúÁóüÁó†Áó°Áó§ÁóßÁó¨ÁóÆÁóØÁó±ÁóπÁòÄÁòÇÁòÉÁòÑÁòáÁòàÁòäÁòåÁòèÁòíÁòìÁòïÁòñÁòôÁòõÁòúÁòùÁòûÁò£Áò•Áò¶Áò©Áò≠Áò≤Áò≥ÁòµÁò∏Áòπ"],["8fcea1","Áò∫ÁòºÁôäÁôÄÁôÅÁôÉÁôÑÁôÖÁôâÁôãÁôïÁôôÁôüÁô§Áô•Áô≠ÁôÆÁôØÁô±Áô¥ÁöÅÁöÖÁöåÁöçÁöïÁöõÁöúÁöùÁöüÁö†Áö¢",6,"Áö™Áö≠ÁöΩÁõÅÁõÖÁõâÁõãÁõåÁõéÁõîÁõôÁõ†Áõ¶Áõ®Áõ¨Áõ∞Áõ±Áõ∂ÁõπÁõºÁúÄÁúÜÁúäÁúéÁúíÁúîÁúïÁúóÁúôÁúöÁúúÁú¢Áú®Áú≠ÁúÆÁúØÁú¥ÁúµÁú∂ÁúπÁúΩÁúæÁùÇÁùÖÁùÜÁùäÁùçÁùéÁùèÁùíÁùñÁùóÁùúÁùûÁùüÁù†Áù¢"],["8fcfa1","Áù§ÁùßÁù™Áù¨Áù∞Áù≤Áù≥Áù¥Áù∫ÁùΩÁûÄÁûÑÁûåÁûçÁûîÁûïÁûñÁûöÁûüÁû¢ÁûßÁû™ÁûÆÁûØÁû±ÁûµÁûæÁüÉÁüâÁüëÁüíÁüïÁüôÁüûÁüüÁü†Áü§Áü¶Áü™Áü¨Áü∞Áü±Áü¥Áü∏ÁüªÁ†ÖÁ†ÜÁ†âÁ†çÁ†éÁ†ëÁ†ùÁ†°Á†¢Á†£Á†≠Á†ÆÁ†∞Á†µÁ†∑Á°ÉÁ°ÑÁ°áÁ°àÁ°åÁ°éÁ°íÁ°úÁ°ûÁ°†Á°°Á°£Á°§Á°®Á°™Á°ÆÁ°∫Á°æÁ¢äÁ¢èÁ¢îÁ¢òÁ¢°Á¢ùÁ¢ûÁ¢üÁ¢§Á¢®Á¢¨Á¢≠Á¢∞Á¢±Á¢≤Á¢≥"],["8fd0a1","Á¢ªÁ¢ΩÁ¢øÁ£áÁ£àÁ£âÁ£åÁ£éÁ£íÁ£ìÁ£ïÁ£ñÁ£§Á£õÁ£üÁ£†Á£°Á£¶Á£™Á£≤Á£≥Á§ÄÁ£∂Á£∑Á£∫Á£ªÁ£øÁ§ÜÁ§åÁ§êÁ§öÁ§úÁ§ûÁ§üÁ§†Á§•Á§ßÁ§©Á§≠Á§±Á§¥Á§µÁ§ªÁ§ΩÁ§øÁ•ÑÁ•ÖÁ•ÜÁ•äÁ•ãÁ•èÁ•ëÁ•îÁ•òÁ•õÁ•úÁ•ßÁ•©Á•´Á•≤Á•πÁ•ªÁ•ºÁ•æÁ¶ãÁ¶åÁ¶ëÁ¶ìÁ¶îÁ¶ïÁ¶ñÁ¶òÁ¶õÁ¶úÁ¶°Á¶®Á¶©Á¶´Á¶ØÁ¶±Á¶¥Á¶∏Á¶ªÁßÇÁßÑÁßáÁßàÁßäÁßèÁßîÁßñÁßöÁßùÁßû"],["8fd1a1","Áß†Áß¢Áß•Áß™Áß´Áß≠Áß±Áß∏ÁßºÁ®ÇÁ®ÉÁ®áÁ®âÁ®äÁ®åÁ®ëÁ®ïÁ®õÁ®ûÁ®°Á®ßÁ®´Á®≠Á®ØÁ®∞Á®¥Á®µÁ®∏Á®πÁ®∫Á©ÑÁ©ÖÁ©áÁ©àÁ©åÁ©ïÁ©ñÁ©ôÁ©úÁ©ùÁ©üÁ©†Á©•Á©ßÁ©™Á©≠Á©µÁ©∏Á©æÁ™ÄÁ™ÇÁ™ÖÁ™ÜÁ™äÁ™ãÁ™êÁ™ëÁ™îÁ™ûÁ™†Á™£Á™¨Á™≥Á™µÁ™πÁ™ªÁ™ºÁ´ÜÁ´âÁ´åÁ´éÁ´ëÁ´õÁ´®Á´©Á´´Á´¨Á´±Á´¥Á´ªÁ´ΩÁ´æÁ¨áÁ¨îÁ¨üÁ¨£Á¨ßÁ¨©Á¨™Á¨´Á¨≠Á¨ÆÁ¨ØÁ¨∞"],["8fd2a1","Á¨±Á¨¥Á¨ΩÁ¨øÁ≠ÄÁ≠ÅÁ≠áÁ≠éÁ≠ïÁ≠†Á≠§Á≠¶Á≠©Á≠™Á≠≠Á≠ØÁ≠≤Á≠≥Á≠∑ÁÆÑÁÆâÁÆéÁÆêÁÆëÁÆñÁÆõÁÆûÁÆ†ÁÆ•ÁÆ¨ÁÆØÁÆ∞ÁÆ≤ÁÆµÁÆ∂ÁÆ∫ÁÆªÁÆºÁÆΩÁØÇÁØÖÁØàÁØäÁØîÁØñÁØóÁØôÁØöÁØõÁØ®ÁØ™ÁØ≤ÁØ¥ÁØµÁØ∏ÁØπÁØ∫ÁØºÁØæÁ∞ÅÁ∞ÇÁ∞ÉÁ∞ÑÁ∞ÜÁ∞âÁ∞ãÁ∞åÁ∞éÁ∞èÁ∞ôÁ∞õÁ∞†Á∞•Á∞¶Á∞®Á∞¨Á∞±Á∞≥Á∞¥Á∞∂Á∞πÁ∞∫Á±ÜÁ±äÁ±ïÁ±ëÁ±íÁ±ìÁ±ô",5],["8fd3a1","Á±°Á±£Á±ßÁ±©Á±≠Á±ÆÁ±∞Á±≤Á±πÁ±ºÁ±ΩÁ≤ÜÁ≤áÁ≤èÁ≤îÁ≤ûÁ≤†Á≤¶Á≤∞Á≤∂Á≤∑Á≤∫Á≤ªÁ≤ºÁ≤øÁ≥ÑÁ≥áÁ≥àÁ≥âÁ≥çÁ≥èÁ≥ìÁ≥îÁ≥ïÁ≥óÁ≥ôÁ≥öÁ≥ùÁ≥¶Á≥©Á≥´Á≥µÁ¥ÉÁ¥áÁ¥àÁ¥âÁ¥èÁ¥ëÁ¥íÁ¥ìÁ¥ñÁ¥ùÁ¥ûÁ¥£Á¥¶Á¥™Á¥≠Á¥±Á¥ºÁ¥ΩÁ¥æÁµÄÁµÅÁµáÁµàÁµçÁµëÁµìÁµóÁµôÁµöÁµúÁµùÁµ•ÁµßÁµ™Áµ∞Áµ∏Áµ∫ÁµªÁµøÁ∂ÅÁ∂ÇÁ∂ÉÁ∂ÖÁ∂ÜÁ∂àÁ∂ãÁ∂åÁ∂çÁ∂ëÁ∂ñÁ∂óÁ∂ù"],["8fd4a1","Á∂ûÁ∂¶Á∂ßÁ∂™Á∂≥Á∂∂Á∂∑Á∂πÁ∑Ç",4,"Á∑åÁ∑çÁ∑éÁ∑óÁ∑ôÁ∏ÄÁ∑¢Á∑•Á∑¶Á∑™Á∑´Á∑≠Á∑±Á∑µÁ∑∂Á∑πÁ∑∫Á∏àÁ∏êÁ∏ëÁ∏ïÁ∏óÁ∏úÁ∏ùÁ∏†Á∏ßÁ∏®Á∏¨Á∏≠Á∏ØÁ∏≥Á∏∂Á∏øÁπÑÁπÖÁπáÁπéÁπêÁπíÁπòÁπüÁπ°Áπ¢Áπ•Áπ´ÁπÆÁπØÁπ≥Áπ∏ÁπæÁ∫ÅÁ∫ÜÁ∫áÁ∫äÁ∫çÁ∫ëÁ∫ïÁ∫òÁ∫öÁ∫ùÁ∫ûÁººÁºªÁºΩÁºæÁºøÁΩÉÁΩÑÁΩáÁΩèÁΩíÁΩìÁΩõÁΩúÁΩùÁΩ°ÁΩ£ÁΩ§ÁΩ•ÁΩ¶ÁΩ≠"],["8fd5a1","ÁΩ±ÁΩΩÁΩæÁΩøÁæÄÁæãÁæçÁæèÁæêÁæëÁæñÁæóÁæúÁæ°Áæ¢Áæ¶Áæ™Áæ≠Áæ¥ÁæºÁæøÁøÄÁøÉÁøàÁøéÁøèÁøõÁøüÁø£Áø•Áø®Áø¨ÁøÆÁøØÁø≤Áø∫ÁøΩÁøæÁøøËÄáËÄàËÄäËÄçËÄéËÄèËÄëËÄìËÄîËÄñËÄùËÄûËÄüËÄ†ËÄ§ËÄ¶ËÄ¨ËÄÆËÄ∞ËÄ¥ËÄµËÄ∑ËÄπËÄ∫ËÄºËÄæËÅÄËÅÑËÅ†ËÅ§ËÅ¶ËÅ≠ËÅ±ËÅµËÇÅËÇàËÇéËÇúËÇûËÇ¶ËÇßËÇ´ËÇ∏ËÇπËÉàËÉçËÉèËÉíËÉîËÉïËÉóËÉòËÉ†ËÉ≠ËÉÆ"],["8fd6a1","ËÉ∞ËÉ≤ËÉ≥ËÉ∂ËÉπËÉ∫ËÉæËÑÉËÑãËÑñËÑóËÑòËÑúËÑûËÑ†ËÑ§ËÑßËÑ¨ËÑ∞ËÑµËÑ∫ËÑºËÖÖËÖáËÖäËÖåËÖíËÖóËÖ†ËÖ°ËÖßËÖ®ËÖ©ËÖ≠ËÖØËÖ∑ËÜÅËÜêËÜÑËÜÖËÜÜËÜãËÜéËÜñËÜòËÜõËÜûËÜ¢ËÜÆËÜ≤ËÜ¥ËÜªËáãËáÉËáÖËáäËáéËáèËáïËáóËáõËáùËáûËá°Ëá§Ëá´Ëá¨Ëá∞Ëá±Ëá≤ËáµËá∂Ëá∏ËáπËáΩËáøËàÄËàÉËàèËàìËàîËàôËàöËàùËà°Ëà¢Ëà®Ëà≤Ëà¥Ëà∫ËâÉËâÑËâÖËâÜ"],["8fd7a1","ËâãËâéËâèËâëËâñËâúËâ†Ëâ£ËâßËâ≠Ëâ¥ËâªËâΩËâøËäÄËäÅËäÉËäÑËäáËäâËääËäéËäëËäîËäñËäòËäöËäõËä†Ëä°Ëä£Ëä§ËäßËä®Ëä©Ëä™ËäÆËä∞Ëä≤Ëä¥Ëä∑Ëä∫ËäºËäæËäøËãÜËãêËãïËãöËã†Ëã¢Ëã§Ëã®Ëã™Ëã≠ËãØËã∂Ëã∑ËãΩËãæËåÄËåÅËåáËåàËåäËåãËçîËåõËåùËåûËåüËå°Ëå¢Ëå¨Ëå≠ËåÆËå∞Ëå≥Ëå∑Ëå∫ËåºËåΩËçÇËçÉËçÑËçáËççËçéËçëËçïËçñËçóËç∞Ëç∏"],["8fd8a1","ËçΩËçøËéÄËéÇËéÑËéÜËéçËéíËéîËéïËéòËéôËéõËéúËéùËé¶ËéßËé©Ëé¨ËéæËéøËèÄËèáËèâËèèËèêËèëËèîËèùËçìËè®Ëè™Ëè∂Ëè∏ËèπËèºËêÅËêÜËêäËêèËêëËêïËêôËé≠ËêØËêπËëÖËëáËëàËëäËëçËëèËëëËëíËëñËëòËëôËëöËëúËë†Ëë§Ëë•ËëßËë™Ëë∞Ëë≥Ëë¥Ëë∂Ëë∏ËëºËëΩËíÅËíÖËííËíìËíïËíûËí¶Ëí®Ëí©Ëí™ËíØËí±Ëí¥Ëí∫ËíΩËíæËìÄËìÇËìáËìàËìåËìèËìì"],["8fd9a1","ËìúËìßËì™ËìØËì∞Ëì±Ëì≤Ëì∑Ëî≤Ëì∫ËìªËìΩËîÇËîÉËîáËîåËîéËîêËîúËîûËî¢Ëî£Ëî§Ëî•ËîßËî™Ëî´ËîØËî≥Ëî¥Ëî∂ËîøËïÜËïè",4,"ËïñËïôËïú",6,"Ëï§Ëï´ËïØËïπËï∫ËïªËïΩËïøËñÅËñÖËñÜËñâËñãËñåËñèËñìËñòËñùËñüËñ†Ëñ¢Ëñ•ËñßËñ¥Ëñ∂Ëñ∑Ëñ∏ËñºËñΩËñæËñøËóÇËóáËóäËóãËóéËñ≠ËóòËóöËóüËó†Ëó¶Ëó®Ëó≠Ëó≥Ëó∂Ëóº"],["8fdaa1","ËóøËòÄËòÑËòÖËòçËòéËòêËòëËòíËòòËòôËòõËòûËò°ËòßËò©Ëò∂Ëò∏Ëò∫ËòºËòΩËôÄËôÇËôÜËôíËôìËôñËôóËôòËôôËôùËô†",4,"Ëô©Ëô¨ËôØËôµËô∂Ëô∑Ëô∫ËöçËöëËöñËöòËööËöúËö°Ëö¶ËößËö®Ëö≠Ëö±Ëö≥Ëö¥ËöµËö∑Ëö∏ËöπËöøËõÄËõÅËõÉËõÖËõëËõíËõïËõóËõöËõúËõ†Ëõ£Ëõ•ËõßËöàËõ∫ËõºËõΩËúÑËúÖËúáËúãËúéËúèËúêËúìËúîËúôËúûËúüËú°Ëú£"],["8fdba1","Ëú®ËúÆËúØËú±Ëú≤ËúπËú∫ËúºËúΩËúæËùÄËùÉËùÖËùçËùòËùùËù°Ëù§Ëù•ËùØËù±Ëù≤ËùªËûÉ",6,"ËûãËûåËûêËûìËûïËûóËûòËûôËûûËû†Ëû£ËûßËû¨Ëû≠ËûÆËû±ËûµËûæËûøËüÅËüàËüâËüäËüéËüïËüñËüôËüöËüúËüüËü¢Ëü£Ëü§Ëü™Ëü´Ëü≠Ëü±Ëü≥Ëü∏Ëü∫ËüøË†ÅË†ÉË†ÜË†âË†äË†ãË†êË†ôË†íË†ìË†îË†òË†öË†õË†úË†ûË†üË†®Ë†≠Ë†ÆË†∞Ë†≤Ë†µ"],["8fdca1","Ë†∫Ë†ºË°ÅË°ÉË°ÖË°àË°âË°äË°ãË°éË°ëË°ïË°ñË°òË°öË°úË°üË°†Ë°§Ë°©Ë°±Ë°πË°ªË¢ÄË¢òË¢öË¢õË¢úË¢üË¢†Ë¢®Ë¢™Ë¢∫Ë¢ΩË¢æË£ÄË£ä",4,"Ë£ëË£íË£ìË£õË£ûË£ßË£ØË£∞Ë£±Ë£µË£∑Ë§ÅË§ÜË§çË§éË§èË§ïË§ñË§òË§ôË§öË§úË§†Ë§¶Ë§ßË§®Ë§∞Ë§±Ë§≤Ë§µË§πË§∫Ë§æË•ÄË•ÇË•ÖË•ÜË•âË•èË•íË•óË•öË•õË•úË•°Ë•¢Ë•£Ë•´Ë•ÆË•∞Ë•≥Ë•µË•∫"],["8fdda1","Ë•ªË•ºË•ΩË¶âË¶çË¶êË¶îË¶ïË¶õË¶úË¶üË¶†Ë¶•Ë¶∞Ë¶¥Ë¶µË¶∂Ë¶∑Ë¶ºËßî",4,"Ëß•Ëß©Ëß´Ëß≠Ëß±Ëß≥Ëß∂ËßπËßΩËßøË®ÑË®ÖË®áË®èË®ëË®íË®îË®ïË®ûË®†Ë®¢Ë®§Ë®¶Ë®´Ë®¨Ë®ØË®µË®∑Ë®ΩË®æË©ÄË©ÉË©ÖË©áË©âË©çË©éË©ìË©ñË©óË©òË©úË©ùË©°Ë©•Ë©ßË©µË©∂Ë©∑Ë©πË©∫Ë©ªË©æË©øË™ÄË™ÉË™ÜË™ãË™èË™êË™íË™ñË™óË™ôË™üË™ßË™©Ë™ÆË™ØË™≥"],["8fdea1","Ë™∂Ë™∑Ë™ªË™æË´ÉË´ÜË´àË´âË´äË´ëË´ìË´îË´ïË´óË´ùË´üË´¨Ë´∞Ë´¥Ë´µË´∂Ë´ºË´øË¨ÖË¨ÜË¨ãË¨ëË¨úË¨ûË¨üË¨äË¨≠Ë¨∞Ë¨∑Ë¨ºË≠Ç",4,"Ë≠àË≠íË≠ìË≠îË≠ôË≠çË≠ûË≠£Ë≠≠Ë≠∂Ë≠∏Ë≠πË≠ºË≠æËÆÅËÆÑËÆÖËÆãËÆçËÆèËÆîËÆïËÆúËÆûËÆüË∞∏Ë∞πË∞ΩË∞æË±ÖË±áË±âË±ãË±èË±ëË±ìË±îË±óË±òË±õË±ùË±ôË±£Ë±§Ë±¶Ë±®Ë±©Ë±≠Ë±≥Ë±µË±∂Ë±ªË±æË≤Ü"],["8fdfa1","Ë≤áË≤ãË≤êË≤íË≤ìË≤ôË≤õË≤úË≤§Ë≤πË≤∫Ë≥ÖË≥ÜË≥âË≥ãË≥èË≥ñË≥ïË≥ôË≥ùË≥°Ë≥®Ë≥¨Ë≥ØË≥∞Ë≥≤Ë≥µË≥∑Ë≥∏Ë≥æË≥øË¥ÅË¥ÉË¥âË¥íË¥óË¥õËµ•Ëµ©Ëµ¨ËµÆËµøË∂ÇË∂ÑË∂àË∂çË∂êË∂ëË∂ïË∂ûË∂üË∂†Ë∂¶Ë∂´Ë∂¨Ë∂ØË∂≤Ë∂µË∂∑Ë∂πË∂ªË∑ÄË∑ÖË∑ÜË∑áË∑àË∑äË∑éË∑ëË∑îË∑ïË∑óË∑ôË∑§Ë∑•Ë∑ßË∑¨Ë∑∞Ë∂ºË∑±Ë∑≤Ë∑¥Ë∑ΩË∏ÅË∏ÑË∏ÖË∏ÜË∏ãË∏ëË∏îË∏ñË∏†Ë∏°Ë∏¢"],["8fe0a1","Ë∏£Ë∏¶Ë∏ßË∏±Ë∏≥Ë∏∂Ë∏∑Ë∏∏Ë∏πË∏ΩËπÄËπÅËπãËπçËπéËπèËπîËπõËπúËπùËπûËπ°Ëπ¢Ëπ©Ëπ¨Ëπ≠ËπØËπ∞Ëπ±ËππËπ∫ËπªË∫ÇË∫ÉË∫âË∫êË∫íË∫ïË∫öË∫õË∫ùË∫ûË∫¢Ë∫ßË∫©Ë∫≠Ë∫ÆË∫≥Ë∫µË∫∫Ë∫ªËªÄËªÅËªÉËªÑËªáËªèËªëËªîËªúËª®ËªÆËª∞Ëª±Ëª∑ËªπËª∫Ëª≠ËºÄËºÇËºáËºàËºèËºêËºñËºóËºòËºûËº†Ëº°Ëº£Ëº•ËºßËº®Ëº¨Ëº≠ËºÆËº¥ËºµËº∂Ëº∑Ëº∫ËΩÄËΩÅ"],["8fe1a1","ËΩÉËΩáËΩèËΩë",4,"ËΩòËΩùËΩûËΩ•ËæùËæ†Ëæ°Ëæ§Ëæ•Ëæ¶ËæµËæ∂Ëæ∏ËææËøÄËøÅËøÜËøäËøãËøçËøêËøíËøìËøïËø†Ëø£Ëø§Ëø®ËøÆËø±ËøµËø∂ËøªËøæÈÄÇÈÄÑÈÄàÈÄåÈÄòÈÄõÈÄ®ÈÄ©ÈÄØÈÄ™ÈÄ¨ÈÄ≠ÈÄ≥ÈÄ¥ÈÄ∑ÈÄøÈÅÉÈÅÑÈÅåÈÅõÈÅùÈÅ¢ÈÅ¶ÈÅßÈÅ¨ÈÅ∞ÈÅ¥ÈÅπÈÇÖÈÇàÈÇãÈÇåÈÇéÈÇêÈÇïÈÇóÈÇòÈÇôÈÇõÈÇ†ÈÇ°ÈÇ¢ÈÇ•ÈÇ∞ÈÇ≤ÈÇ≥ÈÇ¥ÈÇ∂ÈÇΩÈÉåÈÇæÈÉÉ"],["8fe2a1","ÈÉÑÈÉÖÈÉáÈÉàÈÉïÈÉóÈÉòÈÉôÈÉúÈÉùÈÉüÈÉ•ÈÉíÈÉ∂ÈÉ´ÈÉØÈÉ∞ÈÉ¥ÈÉæÈÉøÈÑÄÈÑÑÈÑÖÈÑÜÈÑàÈÑçÈÑêÈÑîÈÑñÈÑóÈÑòÈÑöÈÑúÈÑûÈÑ†ÈÑ•ÈÑ¢ÈÑ£ÈÑßÈÑ©ÈÑÆÈÑØÈÑ±ÈÑ¥ÈÑ∂ÈÑ∑ÈÑπÈÑ∫ÈÑºÈÑΩÈÖÉÈÖáÈÖàÈÖèÈÖìÈÖóÈÖôÈÖöÈÖõÈÖ°ÈÖ§ÈÖßÈÖ≠ÈÖ¥ÈÖπÈÖ∫ÈÖªÈÜÅÈÜÉÈÜÖÈÜÜÈÜäÈÜéÈÜëÈÜìÈÜîÈÜïÈÜòÈÜûÈÜ°ÈÜ¶ÈÜ®ÈÜ¨ÈÜ≠ÈÜÆÈÜ∞ÈÜ±ÈÜ≤ÈÜ≥ÈÜ∂ÈÜªÈÜºÈÜΩÈÜø"],["8fe3a1","ÈáÇÈáÉÈáÖÈáìÈáîÈáóÈáôÈáöÈáûÈá§Èá•Èá©Èá™Èá¨",5,"Èá∑ÈáπÈáªÈáΩÈàÄÈàÅÈàÑÈàÖÈàÜÈàáÈàâÈàäÈàåÈàêÈàíÈàìÈàñÈàòÈàúÈàùÈà£Èà§Èà•Èà¶Èà®ÈàÆÈàØÈà∞Èà≥ÈàµÈà∂Èà∏ÈàπÈà∫ÈàºÈàæÈâÄÈâÇÈâÉÈâÜÈâáÈâäÈâçÈâéÈâèÈâëÈâòÈâôÈâúÈâùÈâ†Èâ°Èâ•ÈâßÈâ®Èâ©ÈâÆÈâØÈâ∞Èâµ",4,"ÈâªÈâºÈâΩÈâøÈäàÈäâÈääÈäçÈäéÈäíÈäó"],["8fe4a1","ÈäôÈäüÈä†Èä§Èä•ÈäßÈä®Èä´ÈäØÈä≤Èä∂Èä∏Èä∫ÈäªÈäºÈäΩÈäø",4,"ÈãÖÈãÜÈãáÈãàÈããÈãåÈãçÈãéÈãêÈãìÈãïÈãóÈãòÈãôÈãúÈãùÈãüÈã†Èã°Èã£Èã•ÈãßÈã®Èã¨ÈãÆÈã∞ÈãπÈãªÈãøÈåÄÈåÇÈåàÈåçÈåëÈåîÈåïÈåúÈåùÈåûÈåüÈå°Èå§Èå•ÈåßÈå©Èå™Èå≥Èå¥Èå∂Èå∑ÈçáÈçàÈçâÈçêÈçëÈçíÈçïÈçóÈçòÈçöÈçûÈç§Èç•ÈçßÈç©Èç™Èç≠ÈçØÈç∞Èç±Èç≥Èç¥Èç∂"],["8fe5a1","Èç∫ÈçΩÈçøÈéÄÈéÅÈéÇÈéàÈéäÈéãÈéçÈéèÈéíÈéïÈéòÈéõÈéûÈé°Èé£Èé§Èé¶Èé®Èé´Èé¥ÈéµÈé∂Èé∫Èé©ÈèÅÈèÑÈèÖÈèÜÈèáÈèâ",4,"ÈèìÈèôÈèúÈèûÈèüÈè¢Èè¶ÈèßÈèπÈè∑Èè∏Èè∫ÈèªÈèΩÈêÅÈêÇÈêÑÈêàÈêâÈêçÈêéÈêèÈêïÈêñÈêóÈêüÈêÆÈêØÈê±Èê≤Èê≥Èê¥ÈêªÈêøÈêΩÈëÉÈëÖÈëàÈëäÈëåÈëïÈëôÈëúÈëüÈë°Èë£Èë®Èë´Èë≠ÈëÆÈëØÈë±Èë≤ÈíÑÈíÉÈï∏Èïπ"],["8fe6a1","ÈïæÈñÑÈñàÈñåÈñçÈñéÈñùÈñûÈñüÈñ°Èñ¶Èñ©Èñ´Èñ¨Èñ¥Èñ∂Èñ∫ÈñΩÈñøÈóÜÈóàÈóâÈóãÈóêÈóëÈóíÈóìÈóôÈóöÈóùÈóûÈóüÈó†Èó§Èó¶ÈòùÈòûÈò¢Èò§Èò•Èò¶Èò¨Èò±Èò≥Èò∑Èò∏ÈòπÈò∫ÈòºÈòΩÈôÅÈôíÈôîÈôñÈôóÈôòÈô°ÈôÆÈô¥ÈôªÈôºÈôæÈôøÈöÅÈöÇÈöÉÈöÑÈöâÈöëÈöñÈööÈöùÈöüÈö§Èö•Èö¶Èö©ÈöÆÈöØÈö≥Èö∫ÈõäÈõíÂ∂≤ÈõòÈõöÈõùÈõûÈõüÈõ©ÈõØÈõ±Èõ∫ÈúÇ"],["8fe7a1","ÈúÉÈúÖÈúâÈúöÈúõÈúùÈú°Èú¢Èú£Èú®Èú±Èú≥ÈùÅÈùÉÈùäÈùéÈùèÈùïÈùóÈùòÈùöÈùõÈù£ÈùßÈù™ÈùÆÈù≥Èù∂Èù∑Èù∏ÈùªÈùΩÈùøÈûÄÈûâÈûïÈûñÈûóÈûôÈûöÈûûÈûüÈû¢Èû¨ÈûÆÈû±Èû≤ÈûµÈû∂Èû∏ÈûπÈû∫ÈûºÈûæÈûøÈüÅÈüÑÈüÖÈüáÈüâÈüäÈüåÈüçÈüéÈüêÈüëÈüîÈüóÈüòÈüôÈüùÈüûÈü†ÈüõÈü°Èü§ÈüØÈü±Èü¥Èü∑Èü∏Èü∫È†áÈ†äÈ†ôÈ†çÈ†éÈ†îÈ†ñÈ†úÈ†ûÈ††È†£È†¶"],["8fe8a1","È†´È†ÆÈ†ØÈ†∞È†≤È†≥È†µÈ†•È†æÈ°ÑÈ°áÈ°äÈ°ëÈ°íÈ°ìÈ°ñÈ°óÈ°ôÈ°öÈ°¢È°£È°•È°¶È°™È°¨È¢´È¢≠È¢ÆÈ¢∞È¢¥È¢∑È¢∏È¢∫È¢ªÈ¢øÈ£ÇÈ£ÖÈ£àÈ£åÈ£°È££È£•È£¶È£ßÈ£™È£≥È£∂È§ÇÈ§áÈ§àÈ§ëÈ§ïÈ§ñÈ§óÈ§öÈ§õÈ§úÈ§üÈ§¢È§¶È§ßÈ§´È§±",4,"È§πÈ§∫È§ªÈ§ºÈ•ÄÈ•ÅÈ•ÜÈ•áÈ•àÈ•çÈ•éÈ•îÈ•òÈ•ôÈ•õÈ•úÈ•ûÈ•üÈ•†È¶õÈ¶ùÈ¶üÈ¶¶È¶∞È¶±È¶≤È¶µ"],["8fe9a1","È¶πÈ¶∫È¶ΩÈ¶øÈßÉÈßâÈßìÈßîÈßôÈßöÈßúÈßûÈßßÈß™Èß´Èß¨Èß∞Èß¥ÈßµÈßπÈßΩÈßæÈ®ÇÈ®ÉÈ®ÑÈ®ãÈ®åÈ®êÈ®ëÈ®ñÈ®ûÈ®†È®¢È®£È®§È®ßÈ®≠È®ÆÈ®≥È®µÈ®∂È®∏È©áÈ©ÅÈ©ÑÈ©äÈ©ãÈ©åÈ©éÈ©ëÈ©îÈ©ñÈ©ùÈ™™È™¨È™ÆÈ™ØÈ™≤È™¥È™µÈ™∂È™πÈ™ªÈ™æÈ™øÈ´ÅÈ´ÉÈ´ÜÈ´àÈ´éÈ´êÈ´íÈ´ïÈ´ñÈ´óÈ´õÈ´úÈ´†È´§È´•È´ßÈ´©È´¨È´≤È´≥È´µÈ´πÈ´∫È´ΩÈ´ø",4],["8feaa1","È¨ÑÈ¨ÖÈ¨àÈ¨âÈ¨ãÈ¨åÈ¨çÈ¨éÈ¨êÈ¨íÈ¨ñÈ¨ôÈ¨õÈ¨úÈ¨†È¨¶È¨´È¨≠È¨≥È¨¥È¨µÈ¨∑È¨πÈ¨∫È¨ΩÈ≠àÈ≠ãÈ≠åÈ≠ïÈ≠ñÈ≠óÈ≠õÈ≠ûÈ≠°È≠£È≠•È≠¶È≠®È≠™",4,"È≠≥È≠µÈ≠∑È≠∏È≠πÈ≠øÈÆÄÈÆÑÈÆÖÈÆÜÈÆáÈÆâÈÆäÈÆãÈÆçÈÆèÈÆêÈÆîÈÆöÈÆùÈÆûÈÆ¶ÈÆßÈÆ©ÈÆ¨ÈÆ∞ÈÆ±ÈÆ≤ÈÆ∑ÈÆ∏ÈÆªÈÆºÈÆæÈÆøÈØÅÈØáÈØàÈØéÈØêÈØóÈØòÈØùÈØüÈØ•ÈØßÈØ™ÈØ´ÈØØÈØ≥ÈØ∑ÈØ∏"],["8feba1","ÈØπÈØ∫ÈØΩÈØøÈ∞ÄÈ∞ÇÈ∞ãÈ∞èÈ∞ëÈ∞ñÈ∞òÈ∞ôÈ∞öÈ∞úÈ∞ûÈ∞¢È∞£È∞¶",4,"È∞±È∞µÈ∞∂È∞∑È∞ΩÈ±ÅÈ±ÉÈ±ÑÈ±ÖÈ±âÈ±äÈ±éÈ±èÈ±êÈ±ìÈ±îÈ±ñÈ±òÈ±õÈ±ùÈ±ûÈ±üÈ±£È±©È±™È±úÈ±´È±®È±ÆÈ±∞È±≤È±µÈ±∑È±ªÈ≥¶È≥≤È≥∑È≥πÈ¥ãÈ¥ÇÈ¥ëÈ¥óÈ¥òÈ¥úÈ¥ùÈ¥ûÈ¥ØÈ¥∞È¥≤È¥≥È¥¥È¥∫È¥ºÈµÖÈ¥ΩÈµÇÈµÉÈµáÈµäÈµìÈµîÈµüÈµ£Èµ¢Èµ•Èµ©Èµ™Èµ´Èµ∞Èµ∂Èµ∑Èµª"],["8feca1","ÈµºÈµæÈ∂ÉÈ∂ÑÈ∂ÜÈ∂äÈ∂çÈ∂éÈ∂íÈ∂ìÈ∂ïÈ∂ñÈ∂óÈ∂òÈ∂°È∂™È∂¨È∂ÆÈ∂±È∂µÈ∂πÈ∂ºÈ∂øÈ∑ÉÈ∑áÈ∑âÈ∑äÈ∑îÈ∑ïÈ∑ñÈ∑óÈ∑öÈ∑ûÈ∑üÈ∑†È∑•È∑ßÈ∑©È∑´È∑ÆÈ∑∞È∑≥È∑¥È∑æÈ∏äÈ∏ÇÈ∏áÈ∏éÈ∏êÈ∏ëÈ∏íÈ∏ïÈ∏ñÈ∏ôÈ∏úÈ∏ùÈπ∫ÈπªÈπºÈ∫ÄÈ∫ÇÈ∫ÉÈ∫ÑÈ∫ÖÈ∫áÈ∫éÈ∫èÈ∫ñÈ∫òÈ∫õÈ∫ûÈ∫§È∫®È∫¨È∫ÆÈ∫ØÈ∫∞È∫≥È∫¥È∫µÈªÜÈªàÈªãÈªïÈªüÈª§ÈªßÈª¨Èª≠ÈªÆÈª∞Èª±Èª≤Èªµ"],["8feda1","Èª∏ÈªøÈºÇÈºÉÈºâÈºèÈºêÈºëÈºíÈºîÈºñÈºóÈºôÈºöÈºõÈºüÈº¢Èº¶Èº™Èº´ÈºØÈº±Èº≤Èº¥Èº∑ÈºπÈº∫ÈººÈºΩÈºøÈΩÅÈΩÉ",4,"ÈΩìÈΩïÈΩñÈΩóÈΩòÈΩöÈΩùÈΩûÈΩ®ÈΩ©ÈΩ≠",4,"ÈΩ≥ÈΩµÈΩ∫ÈΩΩÈæèÈæêÈæëÈæíÈæîÈæñÈæóÈæûÈæ°Èæ¢Èæ£Èæ•"]]');

/***/ }),

/***/ 67936:
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('{"uChars":[128,165,169,178,184,216,226,235,238,244,248,251,253,258,276,284,300,325,329,334,364,463,465,467,469,471,473,475,477,506,594,610,712,716,730,930,938,962,970,1026,1104,1106,8209,8215,8218,8222,8231,8241,8244,8246,8252,8365,8452,8454,8458,8471,8482,8556,8570,8596,8602,8713,8720,8722,8726,8731,8737,8740,8742,8748,8751,8760,8766,8777,8781,8787,8802,8808,8816,8854,8858,8870,8896,8979,9322,9372,9548,9588,9616,9622,9634,9652,9662,9672,9676,9680,9702,9735,9738,9793,9795,11906,11909,11913,11917,11928,11944,11947,11951,11956,11960,11964,11979,12284,12292,12312,12319,12330,12351,12436,12447,12535,12543,12586,12842,12850,12964,13200,13215,13218,13253,13263,13267,13270,13384,13428,13727,13839,13851,14617,14703,14801,14816,14964,15183,15471,15585,16471,16736,17208,17325,17330,17374,17623,17997,18018,18212,18218,18301,18318,18760,18811,18814,18820,18823,18844,18848,18872,19576,19620,19738,19887,40870,59244,59336,59367,59413,59417,59423,59431,59437,59443,59452,59460,59478,59493,63789,63866,63894,63976,63986,64016,64018,64021,64025,64034,64037,64042,65074,65093,65107,65112,65127,65132,65375,65510,65536],"gbChars":[0,36,38,45,50,81,89,95,96,100,103,104,105,109,126,133,148,172,175,179,208,306,307,308,309,310,311,312,313,341,428,443,544,545,558,741,742,749,750,805,819,820,7922,7924,7925,7927,7934,7943,7944,7945,7950,8062,8148,8149,8152,8164,8174,8236,8240,8262,8264,8374,8380,8381,8384,8388,8390,8392,8393,8394,8396,8401,8406,8416,8419,8424,8437,8439,8445,8482,8485,8496,8521,8603,8936,8946,9046,9050,9063,9066,9076,9092,9100,9108,9111,9113,9131,9162,9164,9218,9219,11329,11331,11334,11336,11346,11361,11363,11366,11370,11372,11375,11389,11682,11686,11687,11692,11694,11714,11716,11723,11725,11730,11736,11982,11989,12102,12336,12348,12350,12384,12393,12395,12397,12510,12553,12851,12962,12973,13738,13823,13919,13933,14080,14298,14585,14698,15583,15847,16318,16434,16438,16481,16729,17102,17122,17315,17320,17402,17418,17859,17909,17911,17915,17916,17936,17939,17961,18664,18703,18814,18962,19043,33469,33470,33471,33484,33485,33490,33497,33501,33505,33513,33520,33536,33550,37845,37921,37948,38029,38038,38064,38065,38066,38069,38075,38076,38078,39108,39109,39113,39114,39115,39116,39265,39394,189000]}');

/***/ }),

/***/ 93617:
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('[["a140","ÓìÜ",62],["a180","ÓîÖ",32],["a240","Óî¶",62],["a280","Óï•",32],["a2ab","Óù¶",5],["a2e3","‚Ç¨Óù≠"],["a2ef","ÓùÆÓùØ"],["a2fd","Óù∞Óù±"],["a340","ÓñÜ",62],["a380","ÓóÖ",31,"„ÄÄ"],["a440","Óó¶",62],["a480","Óò•",32],["a4f4","Óù≤",10],["a540","ÓôÜ",62],["a580","ÓöÖ",32],["a5f7","ÓùΩ",7],["a640","Óö¶",62],["a680","Óõ•",32],["a6b9","ÓûÖ",7],["a6d9","Óûç",6],["a6ec","ÓûîÓûï"],["a6f3","Óûñ"],["a6f6","Óûó",8],["a740","ÓúÜ",62],["a780","ÓùÖ",32],["a7c2","Óû†",14],["a7f2","ÓûØ",12],["a896","Óûº",10],["a8bc","Óüá"],["a8bf","«π"],["a8c1","ÓüâÓüäÓüãÓüå"],["a8ea","Óüç",20],["a958","Óü¢"],["a95b","Óü£"],["a95d","Óü§Óü•Óü¶"],["a989","„Äæ‚ø∞",11],["a997","Óü¥",12],["a9f0","Ó†Å",14],["aaa1","ÓÄÄ",93],["aba1","ÓÅû",93],["aca1","ÓÇº",93],["ada1","ÓÑö",93],["aea1","ÓÖ∏",93],["afa1","Óáñ",93],["d7fa","Ó†ê",4],["f8a1","Óà¥",93],["f9a1","Óäí",93],["faa1","Óã∞",93],["fba1","Óçé",93],["fca1","Óé¨",93],["fda1","Óêä",93],["fe50","‚∫ÅÓ†ñÓ†óÓ†ò‚∫Ñ„ë≥„ëá‚∫à‚∫ãÓ†û„ñû„òö„òé‚∫å‚∫ó„•Æ„§òÓ†¶„ßè„ßü„©≥„ßêÓ†´Ó†¨„≠é„±Æ„≥†‚∫ßÓ†±Ó†≤‚∫™‰Åñ‰Öü‚∫Æ‰å∑‚∫≥‚∫∂‚∫∑Ó†ª‰é±‰é¨‚∫ª‰èù‰ìñ‰ô°‰ôåÓ°É"],["fe80","‰ú£‰ú©‰ùº‰ûç‚ªä‰•á‰•∫‰•Ω‰¶Ç‰¶É‰¶Ö‰¶Ü‰¶ü‰¶õ‰¶∑‰¶∂Ó°îÓ°ï‰≤£‰≤ü‰≤†‰≤°‰±∑‰≤¢‰¥ì",6,"‰∂ÆÓ°§Óë®",93]]');

/***/ }),

/***/ 14450:
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('[["0","\\u0000",128],["a1","ÔΩ°",62],["8140","„ÄÄ„ÄÅ„ÄÇÔºåÔºé„ÉªÔºöÔºõÔºüÔºÅ„Çõ„Çú¬¥ÔΩÄ¬®ÔºæÔø£Ôºø„ÉΩ„Éæ„Çù„Çû„ÄÉ‰ªù„ÄÖ„ÄÜ„Äá„Éº‚Äï‚ÄêÔºèÔººÔΩû‚à•ÔΩú‚Ä¶‚Ä•‚Äò‚Äô‚Äú‚ÄùÔºàÔºâ„Äî„ÄïÔºªÔºΩÔΩõÔΩù„Äà",9,"ÔºãÔºç¬±√ó"],["8180","√∑Ôºù‚â†ÔºúÔºû‚â¶‚âß‚àû‚à¥‚ôÇ‚ôÄ¬∞‚Ä≤‚Ä≥‚ÑÉÔø•ÔºÑÔø†Ôø°ÔºÖÔºÉÔºÜÔºäÔº†¬ß‚òÜ‚òÖ‚óã‚óè‚óé‚óá‚óÜ‚ñ°‚ñ†‚ñ≥‚ñ≤‚ñΩ‚ñº‚Äª„Äí‚Üí‚Üê‚Üë‚Üì„Äì"],["81b8","‚àà‚àã‚äÜ‚äá‚äÇ‚äÉ‚à™‚à©"],["81c8","‚àß‚à®Ôø¢‚áí‚áî‚àÄ‚àÉ"],["81da","‚à†‚ä•‚åí‚àÇ‚àá‚â°‚âí‚â™‚â´‚àö‚àΩ‚àù‚àµ‚à´‚à¨"],["81f0","‚Ñ´‚Ä∞‚ôØ‚ô≠‚ô™‚Ä†‚Ä°¬∂"],["81fc","‚óØ"],["824f","Ôºê",9],["8260","Ôº°",25],["8281","ÔΩÅ",25],["829f","„ÅÅ",82],["8340","„Ç°",62],["8380","„É†",22],["839f","Œë",16,"Œ£",6],["83bf","Œ±",16,"œÉ",6],["8440","–ê",5,"–Å–ñ",25],["8470","–∞",5,"—ë–∂",7],["8480","–æ",17],["849f","‚îÄ‚îÇ‚îå‚îê‚îò‚îî‚îú‚î¨‚î§‚î¥‚îº‚îÅ‚îÉ‚îè‚îì‚îõ‚îó‚î£‚î≥‚î´‚îª‚ïã‚î†‚îØ‚î®‚î∑‚îø‚îù‚î∞‚î•‚î∏‚ïÇ"],["8740","‚ë†",19,"‚Ö†",9],["875f","„çâ„åî„å¢„çç„åò„åß„åÉ„å∂„çë„çó„åç„å¶„å£„å´„çä„åª„éú„éù„éû„éé„éè„èÑ„é°"],["877e","„çª"],["8780","„Äù„Äü‚Ññ„èç‚Ñ°„ä§",4,"„à±„à≤„àπ„çæ„çΩ„çº‚âí‚â°‚à´‚àÆ‚àë‚àö‚ä•‚à†‚àü‚äø‚àµ‚à©‚à™"],["889f","‰∫úÂîñÂ®ÉÈòøÂìÄÊÑõÊå®Âß∂ÈÄ¢ËëµËåúÁ©êÊÇ™Êè°Ê∏•Êó≠Ëë¶Ëä¶ÈØµÊ¢ìÂúßÊñ°Êâ±ÂÆõÂßêËôªÈ£¥Áµ¢Á∂æÈÆéÊàñÁ≤üË¢∑ÂÆâÂ∫µÊåâÊöóÊ°àÈóáÈûçÊùè‰ª•‰ºä‰Ωç‰æùÂÅâÂõ≤Â§∑ÂßîÂ®ÅÂ∞âÊÉüÊÑèÊÖ∞ÊòìÊ§ÖÁÇ∫ÁïèÁï∞ÁßªÁ∂≠Á∑ØËÉÉËêéË°£Ë¨ÇÈÅïÈÅ∫Âåª‰∫ï‰∫•ÂüüËÇ≤ÈÉÅÁ£Ø‰∏ÄÂ£±Ê∫¢ÈÄ∏Á®≤Ëå®ËäãÈ∞ØÂÖÅÂç∞ÂíΩÂì°Âõ†ÂßªÂºïÈ£≤Ê∑´ËÉ§Ëî≠"],["8940","Èô¢Èô∞Èö†ÈüªÂêãÂè≥ÂÆáÁÉèÁæΩËøÇÈõ®ÂçØÈµúÁ™∫‰∏ëÁ¢ìËáºÊ∏¶ÂòòÂîÑÊ¨ùËîöÈ∞ªÂß•Âé©Êµ¶ÁìúÈñèÂôÇ‰∫ëÈÅãÈõ≤ËçèÈ§åÂè°Âñ∂Â¨∞ÂΩ±Êò†Êõ≥Ê†ÑÊ∞∏Ê≥≥Ê¥©ÁëõÁõàÁ©éÈ†¥Ëã±Ë°õË©†Èã≠Ê∂≤Áñ´ÁõäÈßÖÊÇ¶Ë¨ÅË∂äÈñ≤Ê¶éÂé≠ÂÜÜ"],["8980","ÂúíÂ†∞Â•ÑÂÆ¥Âª∂ÊÄ®Êé©Êè¥Ê≤øÊºîÁÇéÁÑîÁÖôÁáïÁåøÁ∏ÅËâ∂ËãëËñóÈÅ†ÈâõÈ¥õÂ°©ÊñºÊ±öÁî•ÂáπÂ§ÆÂ••ÂæÄÂøúÊäºÊó∫Ê®™Ê¨ßÊÆ¥ÁéãÁøÅË•ñÈ¥¨È¥éÈªÑÂ≤°Ê≤ñËçªÂÑÑÂ±ãÊÜ∂ËáÜÊ°∂Áâ°‰πô‰ø∫Âç∏ÊÅ©Ê∏©Á©èÈü≥‰∏ãÂåñ‰ªÆ‰Ωï‰ºΩ‰æ°‰Ω≥Âä†ÂèØÂòâÂ§èÂ´ÅÂÆ∂ÂØ°ÁßëÊöáÊûúÊû∂Ê≠åÊ≤≥ÁÅ´ÁèÇÁ¶çÁ¶æÁ®ºÁÆáËä±ËãõËåÑËç∑ËèØËèìËù¶Ë™≤Âò©Ë≤®Ëø¶ÈÅéÈúûËöä‰øÑÂ≥®ÊàëÁâôÁîªËá•ËäΩËõæË≥ÄÈõÖÈ§ìÈßï‰ªã‰ºöËß£ÂõûÂ°äÂ£äÂªªÂø´ÊÄ™ÊÇîÊÅ¢ÊáêÊàíÊãêÊîπ"],["8a40","È≠ÅÊô¶Ê¢∞Êµ∑ÁÅ∞ÁïåÁöÜÁµµËä•ËüπÈñãÈöéË≤ùÂá±ÂäæÂ§ñÂí≥ÂÆ≥Â¥ñÊÖ®Ê¶ÇÊ∂ØÁ¢çËìãË°óË©≤ÈéßÈ™∏Êµ¨È¶®ËõôÂû£ÊüøËõéÈàéÂäÉÂöáÂêÑÂªìÊã°ÊíπÊ†ºÊ†∏ÊÆªÁç≤Á¢∫Á©´Ë¶öËßíËµ´ËºÉÈÉ≠Èñ£ÈöîÈù©Â≠¶Â≤≥Ê•ΩÈ°çÈ°éÊéõÁ¨†Ê®´"],["8a80","Ê©øÊ¢∂È∞çÊΩüÂâ≤ÂñùÊÅ∞Êã¨Ê¥ªÊ∏áÊªëËëõË§êËΩÑ‰∏îÈ∞πÂè∂Ê§õÊ®∫ÈûÑÊ†™ÂÖúÁ´ÉËí≤ÈáúÈéåÂôõÈ¥®Ê†¢ËåÖËê±Á≤•ÂààËãÖÁì¶‰πæ‰æÉÂÜ†ÂØíÂàäÂãòÂãßÂ∑ªÂñöÂ†™Âß¶ÂÆåÂÆòÂØõÂπ≤ÂππÊÇ£ÊÑüÊÖ£ÊÜæÊèõÊï¢ÊüëÊ°ìÊ£∫Ê¨æÊ≠ìÊ±óÊº¢ÊæóÊΩÖÁí∞ÁîòÁõ£ÁúãÁ´øÁÆ°Á∞°Á∑©Áº∂Áø∞ËÇùËâ¶ËéûË¶≥Ë´åË≤´ÈÇÑÈëëÈñìÈñëÈñ¢Èô•ÈüìÈ§®Ëàò‰∏∏Âê´Â≤∏Â∑åÁé©ÁôåÁúºÂ≤©Áø´Ë¥ãÈõÅÈ†ëÈ°îÈ°ò‰ºÅ‰ºéÂç±ÂñúÂô®Âü∫Â•áÂ¨âÂØÑÂ≤êÂ∏åÂπæÂøåÊèÆÊú∫ÊóóÊó¢ÊúüÊ£ãÊ£Ñ"],["8b40","Ê©üÂ∏∞ÊØÖÊ∞óÊ±ΩÁïøÁ•àÂ≠£Á®ÄÁ¥ÄÂæΩË¶èË®òË≤¥Ëµ∑ËªåËºùÈ£¢È®éÈ¨º‰∫ÄÂÅΩÂÑÄÂ¶ìÂÆúÊàØÊäÄÊì¨Ê¨∫Áä†ÁñëÁ•áÁæ©ËüªË™ºË≠∞Êé¨ËèäÈû†ÂêâÂêÉÂñ´Ê°îÊ©òË©∞Á†ßÊùµÈªçÂç¥ÂÆ¢ËÑöËôêÈÄÜ‰∏ò‰πÖ‰ªá‰ºëÂèäÂê∏ÂÆÆÂºìÊÄ•Êïë"],["8b80","ÊúΩÊ±ÇÊ±≤Ê≥£ÁÅ∏ÁêÉÁ©∂Á™ÆÁ¨àÁ¥öÁ≥æÁµ¶ÊóßÁâõÂéªÂ±ÖÂ∑®ÊãíÊã†ÊåôÊ∏†ËôöË®±Ë∑ùÈã∏ÊºÅÁ¶¶È≠ö‰∫®‰∫´‰∫¨‰æõ‰æ†ÂÉëÂÖáÁ´∂ÂÖ±Âá∂ÂçîÂå°ÂçøÂè´Âñ¨Â¢ÉÂ≥°Âº∑ÂΩäÊÄØÊÅêÊÅ≠ÊåüÊïôÊ©ãÊ≥ÅÁãÇÁã≠ÁüØËÉ∏ËÑÖËààËïéÈÉ∑Èè°ÈüøÈ•óÈ©ö‰ª∞ÂáùÂ∞≠ÊöÅÊ•≠Â±ÄÊõ≤Ê•µÁéâÊ°êÁ≤ÅÂÉÖÂã§ÂùáÂ∑æÈå¶Êñ§Ê¨£Ê¨ΩÁê¥Á¶ÅÁ¶ΩÁ≠ãÁ∑äËäπËèåË°øË•üË¨πËøëÈáëÂêüÈäÄ‰πùÂÄ∂Âè•Âå∫ÁãóÁéñÁü©Ëã¶Ë∫ØÈßÜÈßàÈßíÂÖ∑ÊÑöËôûÂñ∞Á©∫ÂÅ∂ÂØìÈÅáÈöÖ‰∏≤Ê´õÈáßÂ±ëÂ±à"],["8c40","ÊéòÁ™üÊ≤ìÈù¥ËΩ°Á™™ÁÜäÈöàÁ≤ÇÊ†óÁπ∞Ê°ëÈç¨Âã≤ÂêõËñ´Ë®ìÁæ§ËªçÈÉ°Âç¶Ë¢àÁ•Å‰øÇÂÇæÂàëÂÖÑÂïìÂú≠Áè™ÂûãÂ•ëÂΩ¢ÂæÑÊÅµÊÖ∂ÊÖßÊÜ©Êé≤Êê∫Êï¨ÊôØÊ°ÇÊ∏ìÁï¶Á®ΩÁ≥ªÁµåÁ∂ôÁπãÁΩ´ËåéËçäËõçË®àË©£Ë≠¶ËªΩÈ†öÈ∂èËä∏ËøéÈØ®"],["8c80","ÂäáÊàüÊíÉÊøÄÈöôÊ°ÅÂÇëÊ¨†Ê±∫ÊΩîÁ©¥ÁµêË°ÄË®£Êúà‰ª∂ÂÄπÂÄ¶ÂÅ•ÂÖºÂà∏Ââ£ÂñßÂúèÂ†ÖÂ´åÂª∫ÊÜ≤Êá∏Êã≥Êç≤Ê§úÊ®©ÁâΩÁä¨ÁåÆÁ†îÁ°ØÁµπÁúåËÇ©Ë¶ãË¨ôË≥¢ËªíÈÅ£ÈçµÈô∫È°ïÈ®ìÈπ∏ÂÖÉÂéüÂé≥ÂπªÂº¶Ê∏õÊ∫êÁéÑÁèæÁµÉËà∑Ë®ÄË´∫Èôê‰πéÂÄãÂè§ÂëºÂõ∫ÂßëÂ≠§Â∑±Â∫´ÂºßÊà∏ÊïÖÊûØÊπñÁãêÁ≥äË¢¥ËÇ°ËÉ°Ëè∞ËôéË™áË∑®Èà∑ÈõáÈ°ßÈºì‰∫î‰∫í‰ºçÂçàÂëâÂêæÂ®ØÂæåÂæ°ÊÇüÊ¢ßÊ™éÁëöÁ¢ÅË™ûË™§Ë≠∑ÈÜê‰πûÈØâ‰∫§‰Ωº‰æØÂÄôÂÄñÂÖâÂÖ¨ÂäüÂäπÂãæÂéöÂè£Âêë"],["8d40","ÂêéÂñâÂùëÂû¢Â•ΩÂ≠îÂ≠ùÂÆèÂ∑•Â∑ßÂ∑∑Âπ∏Â∫ÉÂ∫öÂ∫∑ÂºòÊÅíÊÖåÊäóÊãòÊéßÊîªÊòÇÊôÉÊõ¥Êù≠Ê†°Ê¢óÊßãÊ±üÊ¥™Êµ©Ê∏ØÊ∫ùÁî≤ÁöáÁ°¨Á®øÁ≥†Á¥ÖÁ¥òÁµûÁ∂±ËÄïËÄÉËÇØËÇ±ËÖîËÜèËà™ËçíË°åË°°Ë¨õË≤¢Ë≥ºÈÉäÈÖµÈâ±Á†øÈãºÈñ§Èôç"],["8d80","È†ÖÈ¶ôÈ´òÈ¥ªÂâõÂä´Âè∑ÂêàÂ£ïÊã∑Êø†Ë±™ËΩüÈ∫πÂÖãÂàªÂëäÂõΩÁ©ÄÈÖ∑Èµ†ÈªíÁçÑÊºâËÖ∞ÁîëÂøΩÊÉöÈ™®ÁãõËæºÊ≠§È†É‰ªäÂõ∞Âù§Â¢æÂ©öÊÅ®ÊááÊòèÊòÜÊ†πÊ¢±Ê∑∑ÁóïÁ¥∫ËâÆÈ≠Ç‰∫õ‰ΩêÂèâÂîÜÂµØÂ∑¶Â∑ÆÊüªÊ≤ôÁë≥Á†ÇË©êÈéñË£üÂùêÂ∫ßÊå´ÂÇµÂÇ¨ÂÜçÊúÄÂìâÂ°ûÂ¶ªÂÆ∞ÂΩ©ÊâçÊé°Ê†ΩÊ≠≥Ê∏àÁÅΩÈááÁäÄÁ†ïÁ†¶Á•≠ÊñéÁ¥∞ËèúË£ÅËºâÈöõÂâ§Âú®ÊùêÁΩ™Ë≤°ÂÜ¥ÂùÇÈò™Â†∫Ê¶äËÇ¥Âí≤Â¥éÂüºÁ¢ïÈ∑∫‰ΩúÂâäÂíãÊêæÊò®ÊúîÊüµÁ™ÑÁ≠ñÁ¥¢ÈåØÊ°úÈÆ≠Á¨πÂåôÂÜäÂà∑"],["8e40","ÂØüÊã∂ÊíÆÊì¶Êú≠ÊÆ∫Ëñ©ÈõëÁöêÈØñÊçåÈåÜÈÆ´ÁöøÊôí‰∏âÂÇòÂèÇÂ±±ÊÉ®ÊííÊï£Ê°üÁá¶ÁèäÁî£ÁÆóÁ∫ÇËöïËÆÉË≥õÈÖ∏È§êÊñ¨Êö´ÊÆã‰ªï‰ªî‰º∫‰ΩøÂà∫Âè∏Âè≤Âó£ÂõõÂ£´ÂßãÂßâÂßøÂ≠êÂ±çÂ∏ÇÂ∏´ÂøóÊÄùÊåáÊîØÂ≠úÊñØÊñΩÊó®ÊûùÊ≠¢"],["8e80","Ê≠ªÊ∞èÁçÖÁ•âÁßÅÁ≥∏Á¥ôÁ¥´ËÇ¢ËÑÇËá≥Ë¶ñË©ûË©©Ë©¶Ë™åË´ÆË≥áË≥úÈõåÈ£ºÊ≠Ø‰∫ã‰ºº‰æçÂÖêÂ≠óÂØ∫ÊÖàÊåÅÊôÇÊ¨°ÊªãÊ≤ªÁàæÁíΩÁóîÁ£ÅÁ§∫ËÄåËÄ≥Ëá™ËíîËæûÊ±êÈπøÂºèË≠òÈ¥´Á´∫Ëª∏ÂÆçÈõ´‰∏ÉÂè±Âü∑Â§±Â´âÂÆ§ÊÇâÊπøÊºÜÁñæË≥™ÂÆüËîÄÁØ†ÂÅ≤Êü¥ËäùÂ±°ËïäÁ∏ûËàéÂÜôÂ∞ÑÊç®Ëµ¶ÊñúÁÖÆÁ§æÁ¥óËÄÖË¨ùËªäÈÅÆËõáÈÇ™ÂÄüÂã∫Â∞∫ÊùìÁÅºÁàµÈÖåÈáàÈå´Ëã•ÂØÇÂº±ÊÉπ‰∏ªÂèñÂÆàÊâãÊú±ÊÆäÁã©Áè†Á®ÆËÖ´Ë∂£ÈÖíÈ¶ñÂÑíÂèóÂë™ÂØøÊéàÊ®πÁ∂¨ÈúÄÂõöÂèéÂë®"],["8f40","ÂÆóÂ∞±Â∑û‰øÆÊÑÅÊãæÊ¥≤ÁßÄÁßãÁµÇÁπçÁøíËá≠ËàüËíêË°ÜË•≤ËÆêËπ¥ËºØÈÄ±ÈÖãÈÖ¨ÈõÜÈÜú‰ªÄ‰ΩèÂÖÖÂçÅÂæìÊàéÊüîÊ±ÅÊ∏ãÁç£Á∏¶ÈáçÈäÉÂèîÂ§ôÂÆøÊ∑ëÁ•ùÁ∏ÆÁ≤õÂ°æÁÜüÂá∫Ë°ìËø∞‰øäÂ≥ªÊò•Áû¨Á´£ËàúÈßøÂáÜÂæ™Êó¨Ê•ØÊÆâÊ∑≥"],["8f80","Ê∫ñÊΩ§ÁõæÁ¥îÂ∑°ÈÅµÈÜáÈ†ÜÂá¶ÂàùÊâÄÊöëÊõôÊ∏öÂ∫∂Á∑íÁΩ≤Êõ∏ËñØËó∑Ë´∏Âä©ÂèôÂ•≥Â∫èÂæêÊÅïÈã§Èô§ÂÇ∑ÂÑüÂãùÂå†ÂçáÂè¨Âì®ÂïÜÂî±ÂòóÂ•®Â¶æÂ®ºÂÆµÂ∞ÜÂ∞èÂ∞ëÂ∞öÂ∫ÑÂ∫äÂª†ÂΩ∞ÊâøÊäÑÊãõÊéåÊç∑ÊòáÊòåÊò≠Êô∂ÊùæÊ¢¢Ê®üÊ®µÊ≤ºÊ∂àÊ∏âÊπòÁÑºÁÑ¶ÁÖßÁóáÁúÅÁ°ùÁ§ÅÁ••Áß∞Á´†Á¨ëÁ≤ßÁ¥πËÇñËèñËíãËïâË°ùË£≥Ë®üË®ºË©îË©≥Ë±°Ë≥ûÈÜ§Èâ¶ÈçæÈêòÈöúÈûò‰∏ä‰∏à‰∏û‰πóÂÜóÂâ∞ÂüéÂ†¥Â£åÂ¨¢Â∏∏ÊÉÖÊìæÊù°ÊùñÊµÑÁä∂Áï≥Á©£Ëí∏Ë≠≤ÈÜ∏Èå†Âò±Âü¥È£æ"],["9040","Êã≠Ê§çÊÆñÁá≠ÁπîËÅ∑Ëâ≤Ëß¶È£üËùïËæ±Â∞ª‰º∏‰ø°‰æµÂîáÂ®†ÂØùÂØ©ÂøÉÊÖéÊåØÊñ∞ÊôãÊ£ÆÊ¶õÊµ∏Ê∑±Áî≥ÁñπÁúüÁ•ûÁß¶Á¥≥Ëá£ËäØËñ™Ë¶™Ë®∫Ë∫´ËæõÈÄ≤ÈáùÈúá‰∫∫‰ªÅÂàÉÂ°µÂ£¨Â∞ãÁîöÂ∞ΩËÖéË®äËøÖÈô£Èù≠Á¨•Ë´èÈ†àÈÖ¢Âõ≥Âé®"],["9080","ÈÄóÂêπÂûÇÂ∏•Êé®Ê∞¥ÁÇäÁù°Á≤ãÁø†Ë°∞ÈÅÇÈÖîÈåêÈåòÈöèÁëûÈ´ÑÂ¥áÂµ©Êï∞Êû¢Ë∂®ÈõõÊçÆÊùâÊ§ôËèÖÈ†óÈõÄË£æÊæÑÊë∫ÂØ∏‰∏ñÁÄ¨ÁïùÊòØÂáÑÂà∂Âã¢ÂßìÂæÅÊÄßÊàêÊîøÊï¥ÊòüÊô¥Ê£≤Ê†ñÊ≠£Ê∏ÖÁâ≤ÁîüÁõõÁ≤æËÅñÂ£∞Ë£ΩË•øË™†Ë™ìË´ãÈÄùÈÜíÈùíÈùôÊñâÁ®éËÑÜÈöªÂ∏≠ÊÉúÊàöÊñ•ÊòîÊûêÁü≥Á©çÁ±çÁ∏æËÑäË≤¨Ëµ§Ë∑°ËπüÁ¢©ÂàáÊãôÊé•ÊëÇÊäòË®≠Á™ÉÁØÄË™¨Èõ™Áµ∂ËàåËùâ‰ªôÂÖàÂçÉÂç†ÂÆ£Â∞ÇÂ∞ñÂ∑ùÊà¶ÊâáÊí∞Ê†ìÊ†¥Ê≥âÊµÖÊ¥óÊüìÊΩúÁÖéÁÖΩÊóãÁ©øÁÆ≠Á∑ö"],["9140","ÁπäÁæ®ËÖ∫ËàõËàπËñ¶Ë©ÆË≥éË∑µÈÅ∏ÈÅ∑Èä≠ÈäëÈñÉÈÆÆÂâçÂñÑÊº∏ÁÑ∂ÂÖ®Á¶ÖÁπïËÜ≥Á≥éÂôåÂ°ëÂ≤®Êé™ÊõæÊõΩÊ•öÁãôÁñèÁñéÁ§éÁ•ñÁßüÁ≤óÁ¥†ÁµÑËòáË®¥ÈòªÈÅ°Èº†ÂÉßÂâµÂèåÂè¢ÂÄâÂñ™Â£ÆÂ•èÁàΩÂÆãÂ±§ÂåùÊÉ£ÊÉ≥ÊçúÊéÉÊåøÊéª"],["9180","ÊìçÊó©ÊõπÂ∑£ÊßçÊßΩÊºïÁá•‰∫âÁó©Áõ∏Á™ìÁ≥üÁ∑èÁ∂úËÅ°ËçâËçòËë¨ËíºËóªË£ÖËµ∞ÈÄÅÈÅ≠ÈéóÈúúÈ®íÂÉèÂ¢óÊÜéËáìËîµË¥àÈÄ†‰øÉÂÅ¥ÂâáÂç≥ÊÅØÊçâÊùüÊ∏¨Ë∂≥ÈÄü‰øóÂ±ûË≥äÊóèÁ∂öÂçíË¢ñÂÖ∂ÊèÉÂ≠òÂ≠´Â∞äÊêçÊùëÈÅú‰ªñÂ§öÂ§™Ê±∞Ë©ëÂîæÂ†ïÂ¶•ÊÉ∞ÊâìÊüÅËàµÊ•ïÈôÄÈßÑÈ®®‰ΩìÂ†ÜÂØæËÄêÂ≤±Â∏ØÂæÖÊÄ†ÊÖãÊà¥ÊõøÊ≥∞ÊªûËÉéËÖøËãîË¢ãË≤∏ÈÄÄÈÄÆÈöäÈªõÈØõ‰ª£Âè∞Â§ßÁ¨¨ÈÜçÈ°åÈ∑πÊªùÁÄßÂçìÂïÑÂÆÖÊâòÊäûÊãìÊ≤¢ÊøØÁê¢Ë®óÈê∏ÊøÅË´æËå∏ÂáßËõ∏Âè™"],["9240","Âè©‰ΩÜÈÅîËæ∞Â•™ËÑ±Â∑ΩÁ´™ËæøÊ£öË∞∑Áã∏È±àÊ®ΩË™∞‰∏πÂçòÂòÜÂù¶ÊãÖÊé¢Êó¶Ê≠éÊ∑°ÊπõÁÇ≠Áü≠Á´ØÁÆ™Á∂ªËÄΩËÉÜËõãË™ïÈçõÂõ£Â£áÂºæÊñ≠ÊöñÊ™ÄÊÆµÁî∑Ë´áÂÄ§Áü•Âú∞ÂºõÊÅ•Êô∫Ê±†Áó¥Á®öÁΩÆËá¥ËúòÈÅÖÈ¶≥ÁØâÁïúÁ´πÁ≠ëËìÑ"],["9280","ÈÄêÁß©Á™íËå∂Â´°ÁùÄ‰∏≠‰ª≤ÂÆôÂø†ÊäΩÊòºÊü±Ê≥®Ëô´Ë°∑Ë®ªÈÖéÈã≥ÈßêÊ®óÁÄ¶Áå™ËãßËëóË≤Ø‰∏ÅÂÖÜÂáãÂñãÂØµÂ∏ñÂ∏≥Â∫ÅÂºîÂºµÂΩ´Âæ¥Êá≤ÊåëÊö¢ÊúùÊΩÆÁâíÁî∫Áú∫ËÅ¥ËÑπËÖ∏Ëù∂Ë™øË´úË∂ÖË∑≥ÈäöÈï∑È†ÇÈ≥•ÂãÖÊçóÁõ¥ÊúïÊ≤àÁèçË≥ÉÈéÆÈô≥Ê¥•Â¢úÊ§éÊßåËøΩÈéöÁóõÈÄöÂ°öÊ†ÇÊé¥Êßª‰ΩÉÊº¨ÊüòËæªËî¶Á∂¥ÈçîÊ§øÊΩ∞Âù™Â£∑Â¨¨Á¥¨Áà™ÂêäÈá£È∂¥‰∫≠‰ΩéÂÅúÂÅµÂâÉË≤ûÂëàÂ†§ÂÆöÂ∏ùÂ∫ïÂ∫≠Âª∑ÂºüÊÇåÊäµÊå∫ÊèêÊ¢ØÊ±ÄÁ¢áÁ¶éÁ®ãÁ∑†ËâáË®ÇË´¶ËπÑÈÄì"],["9340","ÈÇ∏ÈÑ≠ÈáòÈºéÊ≥•ÊëòÊì¢ÊïµÊª¥ÁöÑÁ¨õÈÅ©ÈèëÊ∫∫Âì≤ÂæπÊí§ËΩçËø≠ÈâÑÂÖ∏Â°´Â§©Â±ïÂ∫óÊ∑ªÁ∫èÁîúË≤ºËª¢È°õÁÇπ‰ºùÊÆøÊæ±Áî∞ÈõªÂÖéÂêêÂ†µÂ°óÂ¶¨Â±†ÂæíÊñóÊùúÊ∏°ÁôªËèüË≥≠ÈÄîÈÉΩÈççÁ†•Á†∫Âä™Â∫¶ÂúüÂ•¥ÊÄíÂÄíÂÖöÂÜ¨"],["9380","ÂáçÂàÄÂîêÂ°îÂ°òÂ•óÂÆïÂ≥∂Â∂ãÊÇºÊäïÊê≠Êù±Ê°ÉÊ¢ºÊ£üÁõóÊ∑òÊπØÊ∂õÁÅØÁáàÂΩìÁóòÁ•∑Á≠âÁ≠îÁ≠íÁ≥ñÁµ±Âà∞Ëë£Ëï©Ëó§Ë®éË¨ÑË±ÜË∏èÈÄÉÈÄèÈêôÈô∂È†≠È®∞ÈóòÂÉçÂãïÂêåÂ†ÇÂ∞éÊÜßÊíûÊ¥ûÁû≥Á´•ËÉ¥ËêÑÈÅìÈäÖÂ≥†È¥áÂåøÂæóÂæ≥Ê∂úÁâπÁù£Á¶øÁØ§ÊØíÁã¨Ë™≠Ê†ÉÊ©°Âá∏Á™ÅÊ§¥Â±äÈ≥∂Ëã´ÂØÖÈÖâÁÄûÂô∏Â±ØÊÉáÊï¶Ê≤åË±öÈÅÅÈ†ìÂëëÊõáÈàçÂ•àÈÇ£ÂÜÖ‰πçÂá™ËñôË¨éÁÅòÊç∫ÈçãÊ•¢È¶¥Á∏ÑÁï∑ÂçóÊ•†ËªüÈõ£Ê±ù‰∫åÂ∞ºÂºêËø©ÂåÇË≥ëËÇâËôπÂªøÊó•‰π≥ÂÖ•"],["9440","Â¶ÇÂ∞øÈüÆ‰ªªÂ¶äÂøçË™çÊø°Á¶∞Á•¢ÂØßËë±Áå´ÁÜ±Âπ¥ÂøµÊçªÊíöÁáÉÁ≤ò‰πÉÂªº‰πãÂüúÂö¢ÊÇ©ÊøÉÁ¥çËÉΩËÑ≥ËÜøËæ≤Ë¶óËö§Â∑¥ÊääÊí≠Ë¶áÊù∑Ê≥¢Ê¥æÁê∂Á†¥Â©ÜÁΩµËä≠È¶¨‰ø≥ÂªÉÊãùÊéíÊïóÊùØÁõÉÁâåËÉåËÇ∫Ëº©ÈÖçÂÄçÂüπÂ™íÊ¢Ö"],["9480","Ê•≥ÁÖ§ÁãΩË≤∑Â£≤Ë≥†Èô™ÈÄôËùøÁß§ÁüßËê©‰ºØÂâ•ÂçöÊãçÊüèÊ≥äÁôΩÁÆîÁ≤ïËà∂ËñÑËø´ÊõùÊº†ÁàÜÁ∏õËé´ÈßÅÈ∫¶ÂáΩÁÆ±Á°≤ÁÆ∏ËÇáÁ≠àÊ´®Âπ°ËÇåÁïëÁï†ÂÖ´Èâ¢Ê∫åÁô∫ÈÜóÈ´™‰ºêÁΩ∞ÊäúÁ≠èÈñ•È≥©Âô∫Â°ôËõ§Èöº‰º¥Âà§ÂçäÂèçÂèõÂ∏ÜÊê¨ÊñëÊùøÊ∞æÊ±éÁâàÁäØÁè≠ÁïîÁπÅËà¨Ëó©Ë≤©ÁØÑÈáÜÁÖ©È†íÈ£ØÊåΩÊô©Áï™Áõ§Á£êËïÉËõÆÂå™ÂçëÂê¶Â¶ÉÂ∫áÂΩºÊÇ≤ÊââÊâπÊä´ÊñêÊØîÊ≥åÁñ≤ÁöÆÁ¢ëÁßòÁ∑ãÁΩ∑ËÇ•Ë¢´Ë™πË≤ªÈÅøÈùûÈ£õÊ®ãÁ∞∏ÂÇôÂ∞æÂæÆÊûáÊØòÁêµÁúâÁæé"],["9540","ÈºªÊüäÁ®óÂåπÁñãÈ´≠ÂΩ¶ËÜùËè±ËÇòÂººÂøÖÁï¢Á≠ÜÈÄºÊ°ßÂß´Â™õÁ¥êÁôæË¨¨‰øµÂΩ™Ê®ôÊ∞∑ÊºÇÁì¢Á•®Ë°®Ë©ïË±πÂªüÊèèÁóÖÁßíËãóÈå®Èã≤ËíúËõ≠È∞≠ÂìÅÂΩ¨ÊñåÊµúÁÄïË≤ßË≥ìÈ†ªÊïèÁì∂‰∏ç‰ªòÂü†Â§´Â©¶ÂØåÂÜ®Â∏ÉÂ∫úÊÄñÊâ∂Êï∑"],["9580","ÊñßÊôÆÊµÆÁà∂Á¨¶ËÖêËÜöËäôË≠úË≤†Ë≥¶Ëµ¥ÈòúÈôÑ‰æÆÊí´Ê≠¶ËàûËë°Ëï™ÈÉ®Â∞ÅÊ•ìÈ¢®Ëë∫Ëïó‰ºèÂâØÂæ©ÂπÖÊúçÁ¶èËÖπË§áË¶ÜÊ∑µÂºóÊâïÊ≤∏‰ªèÁâ©ÈÆíÂàÜÂêªÂô¥Â¢≥ÊÜ§ÊâÆÁÑöÂ•ÆÁ≤âÁ≥ûÁ¥õÈõ∞ÊñáËÅû‰∏ô‰ΩµÂÖµÂ°ÄÂπ£Âπ≥ÂºäÊüÑ‰∏¶ËîΩÈñâÈôõÁ±≥È†ÅÂÉªÂ£ÅÁôñÁ¢ßÂà•Áû•ËîëÁÆÜÂÅèÂ§âÁâáÁØáÁ∑®Ëæ∫ËøîÈÅç‰æøÂãâÂ®©ÂºÅÈû≠‰øùËàóÈã™ÂúÉÊçïÊ≠©Áî´Ë£úËºîÁ©ÇÂãüÂ¢ìÊÖïÊàäÊöÆÊØçÁ∞øËè©ÂÄ£‰ø∏ÂåÖÂëÜÂ†±Â•âÂÆùÂ≥∞Â≥ØÂ¥©Â∫ñÊä±ÊçßÊîæÊñπÊúã"],["9640","Ê≥ïÊ≥°ÁÉπÁ†≤Á∏´ËÉûËä≥ËêåËì¨ËúÇË§íË®™Ë±äÈÇ¶ÈãíÈ£ΩÈ≥≥Èµ¨‰πè‰∫°ÂÇçÂâñÂùäÂ¶®Â∏ΩÂøòÂøôÊàøÊö¥ÊúõÊüêÊ£íÂÜíÁ¥°ËÇ™ËÜ®Ë¨ÄË≤åË≤øÈâæÈò≤Âê†È†¨ÂåóÂÉïÂçúÂ¢®Êí≤Êú¥ÁâßÁù¶Á©ÜÈá¶ÂãÉÊ≤°ÊÆÜÂ†ÄÂπåÂ•îÊú¨ÁøªÂá°ÁõÜ"],["9680","Êë©Á£®È≠îÈ∫ªÂüãÂ¶πÊòßÊûöÊØéÂì©ÊßôÂπïËÜúÊûïÈÆ™ÊüæÈ±íÊ°ù‰∫¶‰ø£ÂèàÊäπÊú´Ê≤´ËøÑ‰æ≠Áπ≠È∫ø‰∏áÊÖ¢Ê∫ÄÊº´ËîìÂë≥Êú™È≠ÖÂ∑≥ÁÆïÂ≤¨ÂØÜËúúÊπäËìëÁ®îËÑàÂ¶ôÁ≤çÊ∞ëÁú†ÂãôÂ§¢ÁÑ°ÁâüÁüõÈúßÈµ°Ê§ãÂ©øÂ®òÂÜ•ÂêçÂëΩÊòéÁõüËø∑ÈäòÈ≥¥Âß™ÁâùÊªÖÂÖçÊ£âÁ∂øÁ∑¨Èù¢È∫∫Êë∏Ê®°ËåÇÂ¶ÑÂ≠üÊØõÁåõÁõ≤Á∂≤ËÄóËíôÂÑ≤Êú®ÈªôÁõÆÊù¢ÂãøÈ§ÖÂ∞§ÊàªÁ±æË≤∞ÂïèÊÇ∂Á¥ãÈñÄÂåÅ‰πüÂÜ∂Â§úÁà∫ËÄ∂ÈáéÂº•Áü¢ÂéÑÂΩπÁ¥ÑËñ¨Ë®≥Ë∫çÈùñÊü≥ËñÆÈëìÊÑâÊÑàÊ≤πÁôí"],["9740","Ë´≠Ëº∏ÂîØ‰ΩëÂÑ™ÂãáÂèãÂÆ•ÂπΩÊÇ†ÊÜÇÊèñÊúâÊüöÊπßÊ∂åÁå∂Áå∑Áî±Á•êË£ïË™òÈÅäÈÇëÈÉµÈõÑËûçÂ§ï‰∫à‰Ωô‰∏éË™âËºøÈ†êÂÇ≠ÂπºÂ¶ñÂÆπÂ∫∏ÊèöÊè∫ÊìÅÊõúÊ•äÊßòÊ¥ãÊ∫∂ÁÜîÁî®Á™ØÁæäËÄÄËëâËìâË¶ÅË¨°Ë∏äÈÅ•ÈôΩÈ§äÊÖæÊäëÊ¨≤"],["9780","Ê≤ÉÊµ¥ÁøåÁøºÊ∑ÄÁæÖËû∫Ë£∏Êù•Ëé±È†ºÈõ∑Ê¥õÁµ°ËêΩÈÖ™‰π±ÂçµÂµêÊ¨ÑÊø´ËóçËò≠Ë¶ßÂà©ÂêèÂ±•ÊùéÊ¢®ÁêÜÁíÉÁó¢Ë£èË£°ÈáåÈõ¢Èô∏ÂæãÁéáÁ´ãËëéÊé†Áï•ÂäâÊµÅÊ∫úÁêâÁïôÁ°´Á≤íÈöÜÁ´úÈæç‰æ∂ÊÖÆÊóÖËôú‰∫Ü‰∫ÆÂÉö‰∏°ÂáåÂØÆÊñôÊ¢ÅÊ∂ºÁåüÁôÇÁû≠Á®úÁ≥ßËâØË´íÈÅºÈáèÈôµÈ†òÂäõÁ∑ëÂÄ´ÂéòÊûóÊ∑ãÁáêÁê≥Ëá®Ëº™Èö£È±óÈ∫üÁë†Â°ÅÊ∂ôÁ¥ØÈ°û‰ª§‰º∂‰æãÂÜ∑Âä±Â∂∫ÊÄúÁé≤Á§ºËãìÈà¥Èö∑Èõ∂ÈúäÈ∫óÈΩ¢Êö¶Ê≠¥ÂàóÂä£ÁÉàË£ÇÂªâÊÅãÊÜêÊº£ÁÖâÁ∞æÁ∑¥ËÅØ"],["9840","ËìÆÈÄ£Èå¨ÂëÇÈ≠ØÊ´ìÁÇâË≥ÇË∑ØÈú≤Âä¥Â©ÅÂªäÂºÑÊúóÊ•ºÊ¶îÊµ™ÊºèÁâ¢ÁãºÁØ≠ËÄÅËÅæËùãÈÉéÂÖ≠È∫ìÁ¶ÑËÇãÈå≤Ë´ñÂÄ≠ÂíåË©±Ê≠™Ë≥ÑËÑáÊÉëÊû†È∑≤‰∫ô‰∫òÈ∞êË©´ËóÅËï®Ê§ÄÊπæÁ¢óËÖï"],["989f","Âºå‰∏ê‰∏ï‰∏™‰∏±‰∏∂‰∏º‰∏ø‰πÇ‰πñ‰πò‰∫Ç‰∫ÖË±´‰∫äËàíÂºç‰∫é‰∫û‰∫ü‰∫†‰∫¢‰∫∞‰∫≥‰∫∂‰ªé‰ªç‰ªÑ‰ªÜ‰ªÇ‰ªó‰ªû‰ª≠‰ªü‰ª∑‰ºâ‰Ωö‰º∞‰Ωõ‰Ωù‰Ωó‰Ωá‰Ω∂‰æà‰æè‰æò‰Ωª‰Ω©‰Ω∞‰æë‰ΩØ‰æÜ‰æñÂÑò‰øî‰øü‰øé‰øò‰øõ‰øë‰øö‰øê‰ø§‰ø•ÂÄöÂÄ®ÂÄîÂÄ™ÂÄ•ÂÄÖ‰ºú‰ø∂ÂÄ°ÂÄ©ÂÄ¨‰øæ‰øØÂÄëÂÄÜÂÅÉÂÅáÊúÉÂÅïÂÅêÂÅàÂÅöÂÅñÂÅ¨ÂÅ∏ÂÇÄÂÇöÂÇÖÂÇ¥ÂÇ≤"],["9940","ÂÉâÂÉäÂÇ≥ÂÉÇÂÉñÂÉûÂÉ•ÂÉ≠ÂÉ£ÂÉÆÂÉπÂÉµÂÑâÂÑÅÂÑÇÂÑñÂÑïÂÑîÂÑöÂÑ°ÂÑ∫ÂÑ∑ÂÑºÂÑªÂÑøÂÖÄÂÖíÂÖåÂÖîÂÖ¢Á´∏ÂÖ©ÂÖ™ÂÖÆÂÜÄÂÜÇÂõòÂÜåÂÜâÂÜèÂÜëÂÜìÂÜïÂÜñÂÜ§ÂÜ¶ÂÜ¢ÂÜ©ÂÜ™ÂÜ´ÂÜ≥ÂÜ±ÂÜ≤ÂÜ∞ÂÜµÂÜΩÂáÖÂáâÂáõÂá†ËôïÂá©Âá≠"],["9980","Âá∞ÂáµÂáæÂàÑÂàãÂàîÂàéÂàßÂà™ÂàÆÂà≥ÂàπÂâèÂâÑÂâãÂâåÂâûÂâîÂâ™Ââ¥Ââ©Ââ≥ÂâøÂâΩÂäçÂäîÂäíÂâ±ÂäàÂäëËæ®ËæßÂä¨Âä≠ÂäºÂäµÂãÅÂãçÂãóÂãûÂã£Âã¶È£≠Âã†Âã≥ÂãµÂã∏ÂãπÂåÜÂåàÁî∏ÂåçÂåêÂåèÂåïÂåöÂå£ÂåØÂå±Âå≥Âå∏ÂçÄÂçÜÂçÖ‰∏óÂçâÂççÂáñÂçûÂç©ÂçÆÂ§òÂçªÂç∑ÂéÇÂéñÂé†Âé¶Âé•ÂéÆÂé∞Âé∂ÂèÉÁ∞íÈõôÂèüÊõºÁáÆÂèÆÂè®Âè≠Âè∫ÂêÅÂêΩÂëÄÂê¨Âê≠ÂêºÂêÆÂê∂Âê©ÂêùÂëéÂíèÂëµÂíéÂëüÂë±Âë∑Âë∞ÂííÂëªÂíÄÂë∂ÂíÑÂíêÂíÜÂìáÂí¢Âí∏Âí•Âí¨ÂìÑÂìàÂí®"],["9a40","Âí´ÂìÇÂí§ÂíæÂíºÂìòÂì•Âì¶ÂîèÂîîÂìΩÂìÆÂì≠Âì∫Âì¢ÂîπÂïÄÂï£ÂïåÂîÆÂïúÂïÖÂïñÂïóÂî∏Âî≥ÂïùÂñôÂñÄÂíØÂñäÂñüÂïªÂïæÂñòÂñûÂñÆÂïºÂñÉÂñ©ÂñáÂñ®ÂóöÂóÖÂóüÂóÑÂóúÂó§ÂóîÂòîÂó∑ÂòñÂóæÂóΩÂòõÂóπÂôéÂôêÁáüÂò¥Âò∂Âò≤Âò∏"],["9a80","Âô´Âô§ÂòØÂô¨Âô™ÂöÜÂöÄÂöäÂö†ÂöîÂöèÂö•ÂöÆÂö∂Âö¥ÂõÇÂöºÂõÅÂõÉÂõÄÂõàÂõéÂõëÂõìÂõóÂõÆÂõπÂúÄÂõøÂúÑÂúâÂúàÂúãÂúçÂúìÂúòÂúñÂóáÂúúÂú¶Âú∑Âú∏ÂùéÂúªÂùÄÂùèÂù©ÂüÄÂûàÂù°ÂùøÂûâÂûìÂû†Âû≥Âû§Âû™Âû∞ÂüÉÂüÜÂüîÂüíÂüìÂ†äÂüñÂü£Â†ãÂ†ôÂ†ùÂ°≤Â†°Â°¢Â°ãÂ°∞ÊØÄÂ°íÂ†ΩÂ°πÂ¢ÖÂ¢πÂ¢üÂ¢´Â¢∫Â£ûÂ¢ªÂ¢∏Â¢ÆÂ£ÖÂ£ìÂ£ëÂ£óÂ£ôÂ£òÂ£•Â£úÂ£§Â£üÂ£ØÂ£∫Â£πÂ£ªÂ£ºÂ£ΩÂ§ÇÂ§äÂ§êÂ§õÊ¢¶Â§•Â§¨Â§≠Â§≤Â§∏Â§æÁ´íÂ•ïÂ•êÂ•éÂ•öÂ•òÂ•¢Â•†Â•ßÂ•¨Â•©"],["9b40","Â•∏Â¶ÅÂ¶ù‰Ωû‰æ´Â¶£Â¶≤ÂßÜÂß®ÂßúÂ¶çÂßôÂßöÂ®•Â®üÂ®ëÂ®úÂ®âÂ®öÂ©ÄÂ©¨Â©âÂ®µÂ®∂Â©¢Â©™Â™öÂ™ºÂ™æÂ´ãÂ´ÇÂ™ΩÂ´£Â´óÂ´¶Â´©Â´ñÂ´∫Â´ªÂ¨åÂ¨ãÂ¨ñÂ¨≤Â´êÂ¨™Â¨∂Â¨æÂ≠ÉÂ≠ÖÂ≠ÄÂ≠ëÂ≠ïÂ≠öÂ≠õÂ≠•Â≠©Â≠∞Â≠≥Â≠µÂ≠∏ÊñàÂ≠∫ÂÆÄ"],["9b80","ÂÆÉÂÆ¶ÂÆ∏ÂØÉÂØáÂØâÂØîÂØêÂØ§ÂØ¶ÂØ¢ÂØûÂØ•ÂØ´ÂØ∞ÂØ∂ÂØ≥Â∞ÖÂ∞áÂ∞àÂ∞çÂ∞ìÂ∞†Â∞¢Â∞®Â∞∏Â∞πÂ±ÅÂ±ÜÂ±éÂ±ìÂ±êÂ±èÂ≠±Â±¨Â±Æ‰π¢Â±∂Â±πÂ≤åÂ≤ëÂ≤îÂ¶õÂ≤´Â≤ªÂ≤∂Â≤ºÂ≤∑Â≥ÖÂ≤æÂ≥áÂ≥ôÂ≥©Â≥ΩÂ≥∫Â≥≠Â∂åÂ≥™Â¥ãÂ¥ïÂ¥óÂµúÂ¥üÂ¥õÂ¥ëÂ¥îÂ¥¢Â¥öÂ¥ôÂ¥òÂµåÂµíÂµéÂµãÂµ¨Âµ≥Âµ∂Â∂áÂ∂ÑÂ∂ÇÂ∂¢Â∂ùÂ∂¨Â∂ÆÂ∂ΩÂ∂êÂ∂∑Â∂ºÂ∑âÂ∑çÂ∑ìÂ∑íÂ∑ñÂ∑õÂ∑´Â∑≤Â∑µÂ∏ãÂ∏öÂ∏ôÂ∏ëÂ∏õÂ∏∂Â∏∑ÂπÑÂπÉÂπÄÂπéÂπóÂπîÂπüÂπ¢Âπ§ÂπáÂπµÂπ∂Âπ∫È∫ºÂπøÂ∫†ÂªÅÂªÇÂªàÂªêÂªè"],["9c40","ÂªñÂª£ÂªùÂªöÂªõÂª¢Âª°Âª®Âª©Âª¨Âª±Âª≥Âª∞Âª¥Âª∏ÂªæÂºÉÂºâÂΩùÂΩúÂºãÂºëÂºñÂº©Âº≠Âº∏ÂΩÅÂΩàÂΩåÂΩéÂºØÂΩëÂΩñÂΩóÂΩôÂΩ°ÂΩ≠ÂΩ≥ÂΩ∑ÂæÉÂæÇÂΩøÂæäÂæàÂæëÂæáÂæûÂæôÂæòÂæ†Âæ®Âæ≠ÂæºÂøñÂøªÂø§Âø∏Âø±ÂøùÊÇ≥ÂøøÊÄ°ÊÅ†"],["9c80","ÊÄôÊÄêÊÄ©ÊÄéÊÄ±ÊÄõÊÄïÊÄ´ÊÄ¶ÊÄèÊÄ∫ÊÅöÊÅÅÊÅ™ÊÅ∑ÊÅüÊÅäÊÅÜÊÅçÊÅ£ÊÅÉÊÅ§ÊÅÇÊÅ¨ÊÅ´ÊÅôÊÇÅÊÇçÊÉßÊÇÉÊÇöÊÇÑÊÇõÊÇñÊÇóÊÇíÊÇßÊÇãÊÉ°ÊÇ∏ÊÉ†ÊÉìÊÇ¥Âø∞ÊÇΩÊÉÜÊÇµÊÉòÊÖçÊÑïÊÑÜÊÉ∂ÊÉ∑ÊÑÄÊÉ¥ÊÉ∫ÊÑÉÊÑ°ÊÉªÊÉ±ÊÑçÊÑéÊÖáÊÑæÊÑ®ÊÑßÊÖäÊÑøÊÑºÊÑ¨ÊÑ¥ÊÑΩÊÖÇÊÖÑÊÖ≥ÊÖ∑ÊÖòÊÖôÊÖöÊÖ´ÊÖ¥ÊÖØÊÖ•ÊÖ±ÊÖüÊÖùÊÖìÊÖµÊÜôÊÜñÊÜáÊÜ¨ÊÜîÊÜöÊÜäÊÜëÊÜ´ÊÜÆÊáåÊáäÊáâÊá∑ÊáàÊáÉÊáÜÊÜ∫ÊáãÁΩπÊáçÊá¶Êá£Êá∂Êá∫Êá¥ÊáøÊáΩÊáºÊáæÊàÄÊààÊàâÊàçÊàåÊàîÊàõ"],["9d40","ÊàûÊà°Êà™ÊàÆÊà∞Êà≤Êà≥ÊâÅÊâéÊâûÊâ£ÊâõÊâ†Êâ®ÊâºÊäÇÊäâÊâæÊäíÊäìÊäñÊãîÊäÉÊäîÊãóÊãëÊäªÊãèÊãøÊãÜÊìîÊãàÊãúÊãåÊãäÊãÇÊãáÊäõÊãâÊååÊãÆÊã±ÊåßÊåÇÊåàÊãØÊãµÊçêÊåæÊççÊêúÊçèÊéñÊééÊéÄÊé´Êç∂Êé£ÊéèÊéâÊéüÊéµÊç´"],["9d80","Êç©ÊéæÊè©ÊèÄÊèÜÊè£ÊèâÊèíÊè∂ÊèÑÊêñÊê¥ÊêÜÊêìÊê¶Êê∂ÊîùÊêóÊê®ÊêèÊëßÊëØÊë∂ÊëéÊî™ÊíïÊíìÊí•Êí©ÊíàÊíºÊìöÊìíÊìÖÊìáÊíªÊìòÊìÇÊì±ÊìßËàâÊì†Êì°Êä¨Êì£ÊìØÊî¨Êì∂Êì¥Êì≤Êì∫ÊîÄÊìΩÊîòÊîúÊîÖÊî§Êî£Êî´Êî¥ÊîµÊî∑Êî∂Êî∏ÁïãÊïàÊïñÊïïÊïçÊïòÊïûÊïùÊï≤Êï∏ÊñÇÊñÉËÆäÊñõÊñüÊñ´Êñ∑ÊóÉÊóÜÊóÅÊóÑÊóåÊóíÊóõÊóôÊó†Êó°Êó±Êù≤ÊòäÊòÉÊóªÊù≥ÊòµÊò∂Êò¥ÊòúÊôèÊôÑÊôâÊôÅÊôûÊôùÊô§ÊôßÊô®ÊôüÊô¢Êô∞ÊöÉÊöàÊöéÊöâÊöÑÊöòÊöùÊõÅÊöπÊõâÊöæÊöº"],["9e40","ÊõÑÊö∏ÊõñÊõöÊõ†ÊòøÊõ¶Êõ©Êõ∞ÊõµÊõ∑ÊúèÊúñÊúûÊú¶ÊúßÈú∏ÊúÆÊúøÊú∂ÊùÅÊú∏Êú∑ÊùÜÊùûÊù†ÊùôÊù£Êù§ÊûâÊù∞Êû©ÊùºÊù™ÊûåÊûãÊû¶Êû°ÊûÖÊû∑ÊüØÊû¥Êü¨Êû≥Êü©Êû∏Êü§ÊüûÊüùÊü¢ÊüÆÊûπÊüéÊüÜÊüßÊ™úÊ†ûÊ°ÜÊ†©Ê°ÄÊ°çÊ†≤Ê°é"],["9e80","Ê¢≥Ê†´Ê°ôÊ°£Ê°∑Ê°øÊ¢üÊ¢èÊ¢≠Ê¢îÊ¢ùÊ¢õÊ¢ÉÊ™ÆÊ¢πÊ°¥Ê¢µÊ¢†Ê¢∫Ê§èÊ¢çÊ°æÊ§ÅÊ£äÊ§àÊ£òÊ§¢Ê§¶Ê£°Ê§åÊ£çÊ£îÊ£ßÊ£ïÊ§∂Ê§íÊ§ÑÊ£óÊ££Ê§•Ê£πÊ£†Ê£ØÊ§®Ê§™Ê§öÊ§£Ê§°Ê£ÜÊ•πÊ•∑Ê•úÊ•∏Ê•´Ê•îÊ•æÊ•ÆÊ§πÊ•¥Ê§ΩÊ•ôÊ§∞Ê•°Ê•ûÊ•ùÊ¶ÅÊ•™Ê¶≤Ê¶ÆÊßêÊ¶øÊßÅÊßìÊ¶æÊßéÂØ®ÊßäÊßùÊ¶ªÊßÉÊ¶ßÊ®ÆÊ¶ëÊ¶†Ê¶úÊ¶ïÊ¶¥ÊßûÊß®Ê®ÇÊ®õÊßøÊ¨äÊßπÊß≤ÊßßÊ®ÖÊ¶±Ê®ûÊß≠Ê®îÊß´Ê®äÊ®íÊ´ÅÊ®£Ê®ìÊ©ÑÊ®åÊ©≤Ê®∂Ê©∏Ê©áÊ©¢Ê©ôÊ©¶Ê©àÊ®∏Ê®¢Ê™êÊ™çÊ™†Ê™ÑÊ™¢Ê™£"],["9f40","Ê™óËòóÊ™ªÊ´ÉÊ´ÇÊ™∏Ê™≥Ê™¨Ê´ûÊ´ëÊ´üÊ™™Ê´öÊ´™Ê´ªÊ¨ÖËòñÊ´∫Ê¨íÊ¨ñÈ¨±Ê¨üÊ¨∏Ê¨∑ÁõúÊ¨πÈ£ÆÊ≠áÊ≠ÉÊ≠âÊ≠êÊ≠ôÊ≠îÊ≠õÊ≠üÊ≠°Ê≠∏Ê≠πÊ≠øÊÆÄÊÆÑÊÆÉÊÆçÊÆòÊÆïÊÆûÊÆ§ÊÆ™ÊÆ´ÊÆØÊÆ≤ÊÆ±ÊÆ≥ÊÆ∑ÊÆºÊØÜÊØãÊØìÊØüÊØ¨ÊØ´ÊØ≥ÊØØ"],["9f80","È∫æÊ∞àÊ∞ìÊ∞îÊ∞õÊ∞§Ê∞£Ê±ûÊ±ïÊ±¢Ê±™Ê≤ÇÊ≤çÊ≤öÊ≤ÅÊ≤õÊ±æÊ±®Ê±≥Ê≤íÊ≤êÊ≥ÑÊ≥±Ê≥ìÊ≤ΩÊ≥óÊ≥ÖÊ≥ùÊ≤ÆÊ≤±Ê≤æÊ≤∫Ê≥õÊ≥ØÊ≥ôÊ≥™Ê¥üË°çÊ¥∂Ê¥´Ê¥ΩÊ¥∏Ê¥ôÊ¥µÊ¥≥Ê¥íÊ¥åÊµ£Ê∂ìÊµ§ÊµöÊµπÊµôÊ∂éÊ∂ïÊø§Ê∂ÖÊ∑πÊ∏ïÊ∏äÊ∂µÊ∑áÊ∑¶Ê∂∏Ê∑ÜÊ∑¨Ê∑ûÊ∑åÊ∑®Ê∑íÊ∑ÖÊ∑∫Ê∑ôÊ∑§Ê∑ïÊ∑™Ê∑ÆÊ∏≠ÊπÆÊ∏ÆÊ∏ôÊπ≤ÊπüÊ∏æÊ∏£Êπ´Ê∏´Êπ∂ÊπçÊ∏üÊπÉÊ∏∫ÊπéÊ∏§ÊªøÊ∏ùÊ∏∏Ê∫ÇÊ∫™Ê∫òÊªâÊ∫∑ÊªìÊ∫ΩÊ∫ØÊªÑÊ∫≤ÊªîÊªïÊ∫èÊ∫•ÊªÇÊ∫üÊΩÅÊºëÁÅåÊª¨Êª∏ÊªæÊºøÊª≤Êº±ÊªØÊº≤Êªå"],["e040","ÊºæÊºìÊª∑ÊæÜÊΩ∫ÊΩ∏ÊæÅÊæÄÊΩØÊΩõÊø≥ÊΩ≠ÊæÇÊΩºÊΩòÊæéÊæëÊøÇÊΩ¶Êæ≥Êæ£Êæ°Êæ§ÊæπÊøÜÊæ™ÊøüÊøïÊø¨ÊøîÊøòÊø±ÊøÆÊøõÁÄâÁÄãÊø∫ÁÄëÁÄÅÁÄèÊøæÁÄõÁÄöÊΩ¥ÁÄùÁÄòÁÄüÁÄ∞ÁÄæÁÄ≤ÁÅëÁÅ£ÁÇôÁÇíÁÇØÁÉ±ÁÇ¨ÁÇ∏ÁÇ≥ÁÇÆÁÉüÁÉãÁÉù"],["e080","ÁÉôÁÑâÁÉΩÁÑúÁÑôÁÖ•ÁÖïÁÜàÁÖ¶ÁÖ¢ÁÖåÁÖñÁÖ¨ÁÜèÁáªÁÜÑÁÜïÁÜ®ÁÜ¨ÁáóÁÜπÁÜæÁáíÁáâÁáîÁáéÁá†Áá¨ÁáßÁáµÁáºÁáπÁáøÁàçÁàêÁàõÁà®Áà≠Áà¨Áà∞Áà≤ÁàªÁàºÁàøÁâÄÁâÜÁâãÁâòÁâ¥ÁâæÁäÇÁäÅÁäáÁäíÁäñÁä¢ÁäßÁäπÁä≤ÁãÉÁãÜÁãÑÁãéÁãíÁã¢Áã†Áã°ÁãπÁã∑ÂÄèÁåóÁåäÁåúÁåñÁåùÁå¥ÁåØÁå©Áå•ÁåæÁçéÁçèÈªòÁçóÁç™Áç®Áç∞Áç∏ÁçµÁçªÁç∫ÁèàÁé≥ÁèéÁéªÁèÄÁè•ÁèÆÁèûÁí¢ÁêÖÁëØÁê•Áè∏Áê≤Áê∫ÁëïÁêøÁëüÁëôÁëÅÁëúÁë©Áë∞Áë£Áë™Áë∂ÁëæÁíãÁíûÁíßÁìäÁìèÁìîÁè±"],["e140","Áì†Áì£ÁìßÁì©ÁìÆÁì≤Áì∞Áì±Áì∏Áì∑ÁîÑÁîÉÁîÖÁîåÁîéÁîçÁîïÁîìÁîûÁî¶Áî¨ÁîºÁïÑÁïçÁïäÁïâÁïõÁïÜÁïöÁï©Áï§ÁïßÁï´Áï≠Áï∏Áï∂ÁñÜÁñáÁï¥ÁñäÁñâÁñÇÁñîÁñöÁñùÁñ•Áñ£ÁóÇÁñ≥ÁóÉÁñµÁñΩÁñ∏ÁñºÁñ±ÁóçÁóäÁóíÁóôÁó£ÁóûÁóæÁóø"],["e180","ÁóºÁòÅÁó∞Áó∫Áó≤Áó≥ÁòãÁòçÁòâÁòüÁòßÁò†Áò°Áò¢Áò§Áò¥Áò∞ÁòªÁôáÁôàÁôÜÁôúÁôòÁô°Áô¢Áô®Áô©Áô™ÁôßÁô¨Áô∞Áô≤Áô∂Áô∏ÁôºÁöÄÁöÉÁöàÁöãÁöéÁöñÁöìÁöôÁööÁö∞Áö¥Áö∏ÁöπÁö∫ÁõÇÁõçÁõñÁõíÁõûÁõ°Áõ•ÁõßÁõ™ËòØÁõªÁúàÁúáÁúÑÁú©Áú§ÁúûÁú•Áú¶ÁúõÁú∑Áú∏ÁùáÁùöÁù®Áù´ÁùõÁù•ÁùøÁùæÁùπÁûéÁûãÁûëÁû†ÁûûÁû∞Áû∂ÁûπÁûøÁûºÁûΩÁûªÁüáÁüçÁüóÁüöÁüúÁü£ÁüÆÁüºÁ†åÁ†íÁ§¶Á††Á§™Á°ÖÁ¢éÁ°¥Á¢ÜÁ°ºÁ¢öÁ¢åÁ¢£Á¢µÁ¢™Á¢ØÁ£ëÁ£ÜÁ£ãÁ£îÁ¢æÁ¢ºÁ£ÖÁ£äÁ£¨"],["e240","Á£ßÁ£öÁ£ΩÁ£¥Á§áÁ§íÁ§ëÁ§ôÁ§¨Á§´Á•ÄÁ•†Á•óÁ•üÁ•öÁ•ïÁ•ìÁ•∫Á•øÁ¶äÁ¶ùÁ¶ßÈΩãÁ¶™Á¶ÆÁ¶≥Á¶πÁ¶∫ÁßâÁßïÁßßÁß¨Áß°Áß£Á®àÁ®çÁ®òÁ®ôÁ®†Á®üÁ¶ÄÁ®±Á®ªÁ®æÁ®∑Á©ÉÁ©óÁ©âÁ©°Á©¢Á©©ÈæùÁ©∞Á©πÁ©ΩÁ™àÁ™óÁ™ïÁ™òÁ™ñÁ™©Á´àÁ™∞"],["e280","Á™∂Á´ÖÁ´ÑÁ™øÈÇÉÁ´áÁ´äÁ´çÁ´èÁ´ïÁ´ìÁ´ôÁ´öÁ´ùÁ´°Á´¢Á´¶Á´≠Á´∞Á¨ÇÁ¨èÁ¨äÁ¨ÜÁ¨≥Á¨òÁ¨ôÁ¨ûÁ¨µÁ¨®Á¨∂Á≠êÁ≠∫Á¨ÑÁ≠çÁ¨ãÁ≠åÁ≠ÖÁ≠µÁ≠•Á≠¥Á≠ßÁ≠∞Á≠±Á≠¨Á≠ÆÁÆùÁÆòÁÆüÁÆçÁÆúÁÆöÁÆãÁÆíÁÆèÁ≠ùÁÆôÁØãÁØÅÁØåÁØèÁÆ¥ÁØÜÁØùÁØ©Á∞ëÁ∞îÁØ¶ÁØ•Á±†Á∞ÄÁ∞áÁ∞ìÁØ≥ÁØ∑Á∞óÁ∞çÁØ∂Á∞£Á∞ßÁ∞™Á∞üÁ∞∑Á∞´Á∞ΩÁ±åÁ±ÉÁ±îÁ±èÁ±ÄÁ±êÁ±òÁ±üÁ±§Á±ñÁ±•Á±¨Á±µÁ≤ÉÁ≤êÁ≤§Á≤≠Á≤¢Á≤´Á≤°Á≤®Á≤≥Á≤≤Á≤±Á≤ÆÁ≤πÁ≤ΩÁ≥ÄÁ≥ÖÁ≥ÇÁ≥òÁ≥íÁ≥úÁ≥¢È¨ªÁ≥ØÁ≥≤Á≥¥Á≥∂Á≥∫Á¥Ü"],["e340","Á¥ÇÁ¥úÁ¥ïÁ¥äÁµÖÁµãÁ¥ÆÁ¥≤Á¥øÁ¥µÁµÜÁµ≥ÁµñÁµéÁµ≤Áµ®ÁµÆÁµèÁµ£Á∂ìÁ∂âÁµõÁ∂èÁµΩÁ∂õÁ∂∫Á∂ÆÁ∂£Á∂µÁ∑áÁ∂ΩÁ∂´Á∏ΩÁ∂¢Á∂ØÁ∑úÁ∂∏Á∂üÁ∂∞Á∑òÁ∑ùÁ∑§Á∑ûÁ∑ªÁ∑≤Á∑°Á∏ÖÁ∏äÁ∏£Á∏°Á∏íÁ∏±Á∏üÁ∏âÁ∏ãÁ∏¢ÁπÜÁπ¶Á∏ªÁ∏µÁ∏πÁπÉÁ∏∑"],["e380","Á∏≤Á∏∫ÁπßÁπùÁπñÁπûÁπôÁπöÁππÁπ™Áπ©ÁπºÁπªÁ∫ÉÁ∑ïÁπΩËæÆÁπøÁ∫àÁ∫âÁ∫åÁ∫íÁ∫êÁ∫ìÁ∫îÁ∫ñÁ∫éÁ∫õÁ∫úÁº∏Áº∫ÁΩÖÁΩåÁΩçÁΩéÁΩêÁΩëÁΩïÁΩîÁΩòÁΩüÁΩ†ÁΩ®ÁΩ©ÁΩßÁΩ∏ÁæÇÁæÜÁæÉÁæàÁæáÁæåÁæîÁæûÁæùÁæöÁæ£ÁæØÁæ≤ÁæπÁæÆÁæ∂Áæ∏Ë≠±ÁøÖÁøÜÁøäÁøïÁøîÁø°Áø¶Áø©Áø≥ÁøπÈ£úËÄÜËÄÑËÄãËÄíËÄòËÄôËÄúËÄ°ËÄ®ËÄøËÄªËÅäËÅÜËÅíËÅòËÅöËÅüËÅ¢ËÅ®ËÅ≥ËÅ≤ËÅ∞ËÅ∂ËÅπËÅΩËÅøËÇÑËÇÜËÇÖËÇõËÇìËÇöËÇ≠ÂÜêËÇ¨ËÉõËÉ•ËÉôËÉùËÉÑËÉöËÉñËÑâËÉØËÉ±ËÑõËÑ©ËÑ£ËÑØËÖã"],["e440","ÈöãËÖÜËÑæËÖìËÖëËÉºËÖ±ËÖÆËÖ•ËÖ¶ËÖ¥ËÜÉËÜàËÜäËÜÄËÜÇËÜ†ËÜïËÜ§ËÜ£ËÖüËÜìËÜ©ËÜ∞ËÜµËÜæËÜ∏ËÜΩËáÄËáÇËÜ∫ËáâËáçËáëËáôËáòËáàËáöËáüËá†ËáßËá∫ËáªËáæËàÅËàÇËàÖËàáËàäËàçËàêËàñËà©Ëà´Ëà∏Ëà≥ËâÄËâôËâòËâùËâöËâüËâ§"],["e480","Ëâ¢Ëâ®Ëâ™Ëâ´ËàÆËâ±Ëâ∑Ëâ∏ËâæËäçËäíËä´ËäüËäªËä¨Ëã°Ëã£ËãüËãíËã¥Ëã≥Ëã∫ËéìËåÉËãªËãπËãûËåÜËãúËåâËãôËåµËå¥ËåñËå≤Ëå±ËçÄËåπËçêËçÖËåØËå´ËåóËåòËéÖËéöËé™ËéüËé¢ËéñËå£ËééËéáËéäËçºËéµËç≥ËçµËé†ËéâËé®Ëè¥ËêìËè´ËèéËèΩËêÉËèòËêãËèÅËè∑ËêáËè†Ëè≤ËêçËê¢Ëê†ËéΩËê∏ËîÜËèªËë≠Ëê™ËêºËïöËíÑËë∑Ëë´Ëí≠ËëÆËíÇËë©ËëÜËê¨ËëØËëπËêµËìäËë¢ËíπËíøËíüËìôËìçËíªËìöËìêËìÅËìÜËìñËí°Ëî°ËìøËì¥ËîóËîòËî¨ËîüËîïËîîËìºËïÄËï£ËïòËïà"],["e540","ËïÅËòÇËïãËïïËñÄËñ§ËñàËñëËñäËñ®Ëï≠ËñîËñõËó™ËñáËñúËï∑ËïæËñêËóâËñ∫ËóèËñπËóêËóïËóùËó•ËóúËóπËòäËòìËòãËóæËó∫ËòÜËò¢ËòöËò∞ËòøËôç‰πïËôîËôüËôßËô±ËöìËö£Ëö©Ëö™ËöãËöåËö∂ËöØËõÑËõÜËö∞ËõâË†£Ëö´ËõîËõûËõ©Ëõ¨"],["e580","ËõüËõõËõØËúíËúÜËúàËúÄËúÉËõªËúëËúâËúçËõπËúäËú¥ËúøËú∑ËúªËú•Ëú©ËúöËù†ËùüËù∏ËùåËùéËù¥ËùóËù®ËùÆËùôËùìËù£Ëù™Ë†ÖËû¢ËûüËûÇËûØËüãËûΩËüÄËüêÈõñËû´ËüÑËû≥ËüáËüÜËûªËüØËü≤Ëü†Ë†èË†çËüæËü∂Ëü∑Ë†éËüíË†ëË†ñË†ïË†¢Ë†°Ë†±Ë†∂Ë†πË†ßË†ªË°ÑË°ÇË°íË°ôË°ûË°¢Ë°´Ë¢ÅË°æË¢ûË°µË°ΩË¢µË°≤Ë¢ÇË¢óË¢íË¢ÆË¢ôË¢¢Ë¢çË¢§Ë¢∞Ë¢øË¢±Ë£ÉË£ÑË£îË£òË£ôË£ùË£πË§ÇË£ºË£¥Ë£®Ë£≤Ë§ÑË§åË§äË§ìË•ÉË§ûË§•Ë§™Ë§´Ë•ÅË•ÑË§ªË§∂Ë§∏Ë•åË§ùË•†Ë•û"],["e640","Ë•¶Ë•§Ë•≠Ë•™Ë•ØË•¥Ë•∑Ë•æË¶ÉË¶àË¶äË¶ìË¶òË¶°Ë¶©Ë¶¶Ë¶¨Ë¶ØË¶≤Ë¶∫Ë¶ΩË¶øËßÄËßöËßúËßùËßßËß¥Ëß∏Ë®ÉË®ñË®êË®åË®õË®ùË®•Ë®∂Ë©ÅË©õË©íË©ÜË©àË©ºË©≠Ë©¨Ë©¢Ë™ÖË™ÇË™ÑË™®Ë™°Ë™ëË™•Ë™¶Ë™öË™£Ë´ÑË´çË´ÇË´öË´´Ë´≥Ë´ß"],["e680","Ë´§Ë´±Ë¨îË´†Ë´¢Ë´∑Ë´ûË´õË¨åË¨áË¨öË´°Ë¨ñË¨êË¨óË¨†Ë¨≥Èû´Ë¨¶Ë¨´Ë¨æË¨®Ë≠ÅË≠åË≠èË≠éË≠âË≠ñË≠õË≠öË≠´Ë≠üË≠¨Ë≠ØË≠¥Ë≠ΩËÆÄËÆåËÆéËÆíËÆìËÆñËÆôËÆöË∞∫Ë±ÅË∞øË±àË±åË±éË±êË±ïË±¢Ë±¨Ë±∏Ë±∫Ë≤ÇË≤âË≤ÖË≤äË≤çË≤éË≤îË±ºË≤òÊàùË≤≠Ë≤™Ë≤ΩË≤≤Ë≤≥Ë≤ÆË≤∂Ë≥àË≥ÅË≥§Ë≥£Ë≥öË≥ΩË≥∫Ë≥ªË¥ÑË¥ÖË¥äË¥áË¥èË¥çË¥êÈΩéË¥ìË≥çË¥îË¥ñËµßËµ≠Ëµ±Ëµ≥Ë∂ÅË∂ôË∑ÇË∂æË∂∫Ë∑èË∑öË∑ñË∑åË∑õË∑ãË∑™Ë∑´Ë∑üË∑£Ë∑ºË∏àË∏âË∑øË∏ùË∏ûË∏êË∏üËπÇË∏µË∏∞Ë∏¥Ëπä"],["e740","ËπáËπâËπåËπêËπàËπôËπ§Ëπ†Ë∏™Ëπ£ËπïËπ∂Ëπ≤ËπºË∫ÅË∫áË∫ÖË∫ÑË∫ãË∫äË∫ìË∫ëË∫îË∫ôË∫™Ë∫°Ë∫¨Ë∫∞ËªÜË∫±Ë∫æËªÖËªàËªãËªõËª£ËªºËªªËª´ËªæËºäËºÖËºïËºíËºôËºìËºúËºüËºõËºåËº¶Ëº≥ËºªËºπËΩÖËΩÇËºæËΩåËΩâËΩÜËΩéËΩóËΩú"],["e780","ËΩ¢ËΩ£ËΩ§ËæúËæüËæ£Ëæ≠ËæØËæ∑ËøöËø•Ëø¢Ëø™ËøØÈÇáËø¥ÈÄÖËøπËø∫ÈÄëÈÄïÈÄ°ÈÄçÈÄûÈÄñÈÄãÈÄßÈÄ∂ÈÄµÈÄπËø∏ÈÅèÈÅêÈÅëÈÅíÈÄéÈÅâÈÄæÈÅñÈÅòÈÅûÈÅ®ÈÅØÈÅ∂Èö®ÈÅ≤ÈÇÇÈÅΩÈÇÅÈÇÄÈÇäÈÇâÈÇèÈÇ®ÈÇØÈÇ±ÈÇµÈÉ¢ÈÉ§ÊâàÈÉõÈÑÇÈÑíÈÑôÈÑ≤ÈÑ∞ÈÖäÈÖñÈÖòÈÖ£ÈÖ•ÈÖ©ÈÖ≥ÈÖ≤ÈÜãÈÜâÈÜÇÈÜ¢ÈÜ´ÈÜØÈÜ™ÈÜµÈÜ¥ÈÜ∫ÈáÄÈáÅÈáâÈáãÈáêÈáñÈáüÈá°ÈáõÈáºÈáµÈá∂ÈàûÈáøÈàîÈà¨ÈàïÈàëÈâûÈâóÈâÖÈââÈâ§ÈâàÈäïÈàøÈâãÈâêÈäúÈäñÈäìÈäõÈâöÈãèÈäπÈä∑Èã©ÈåèÈã∫ÈçÑÈåÆ"],["e840","ÈåôÈå¢ÈåöÈå£Èå∫ÈåµÈåªÈçúÈç†ÈçºÈçÆÈçñÈé∞Èé¨Èé≠ÈéîÈéπÈèñÈèóÈè®Èè•ÈèòÈèÉÈèùÈèêÈèàÈè§ÈêöÈêîÈêìÈêÉÈêáÈêêÈê∂Èê´ÈêµÈê°Èê∫ÈëÅÈëíÈëÑÈëõÈë†Èë¢ÈëûÈë™Èà©Èë∞ÈëµÈë∑ÈëΩÈëöÈëºÈëæÈíÅÈëøÈñÇÈñáÈñäÈñîÈññÈñòÈñô"],["e880","Èñ†Èñ®ÈñßÈñ≠ÈñºÈñªÈñπÈñæÈóäÊø∂ÈóÉÈóçÈóåÈóïÈóîÈóñÈóúÈó°Èó•Èó¢Èò°Èò®ÈòÆÈòØÈôÇÈôåÈôèÈôãÈô∑ÈôúÈôûÈôùÈôüÈô¶Èô≤Èô¨ÈöçÈöòÈöïÈöóÈö™ÈößÈö±Èö≤Èö∞Èö¥Èö∂Èö∏ÈöπÈõéÈõãÈõâÈõçË•çÈõúÈúçÈõïÈõπÈúÑÈúÜÈúàÈúìÈúéÈúëÈúèÈúñÈúôÈú§Èú™Èú∞ÈúπÈúΩÈúæÈùÑÈùÜÈùàÈùÇÈùâÈùúÈù†Èù§Èù¶Èù®ÂãíÈù´Èù±ÈùπÈûÖÈùºÈûÅÈù∫ÈûÜÈûãÈûèÈûêÈûúÈû®Èû¶Èû£Èû≥Èû¥ÈüÉÈüÜÈüàÈüãÈüúÈü≠ÈΩèÈü≤Á´üÈü∂ÈüµÈ†èÈ†åÈ†∏È†§È†°È†∑È†ΩÈ°ÜÈ°èÈ°ãÈ°´È°ØÈ°∞"],["e940","È°±È°¥È°≥È¢™È¢ØÈ¢±È¢∂È£ÑÈ£ÉÈ£ÜÈ£©È£´È§ÉÈ§âÈ§íÈ§îÈ§òÈ§°È§ùÈ§ûÈ§§È§†È§¨È§ÆÈ§ΩÈ§æÈ•ÇÈ•âÈ•ÖÈ•êÈ•ãÈ•ëÈ•íÈ•åÈ•ïÈ¶óÈ¶òÈ¶•È¶≠È¶ÆÈ¶ºÈßüÈßõÈßùÈßòÈßëÈß≠ÈßÆÈß±Èß≤ÈßªÈß∏È®ÅÈ®èÈ®ÖÈß¢È®ôÈ®´È®∑È©ÖÈ©ÇÈ©ÄÈ©É"],["e980","È®æÈ©ïÈ©çÈ©õÈ©óÈ©üÈ©¢È©•È©§È©©È©´È©™È™≠È™∞È™ºÈ´ÄÈ´èÈ´ëÈ´ìÈ´îÈ´ûÈ´üÈ´¢È´£È´¶È´ØÈ´´È´ÆÈ´¥È´±È´∑È´ªÈ¨ÜÈ¨òÈ¨öÈ¨üÈ¨¢È¨£È¨•È¨ßÈ¨®È¨©È¨™È¨ÆÈ¨ØÈ¨≤È≠ÑÈ≠ÉÈ≠èÈ≠çÈ≠éÈ≠ëÈ≠òÈ≠¥ÈÆìÈÆÉÈÆëÈÆñÈÆóÈÆüÈÆ†ÈÆ®ÈÆ¥ÈØÄÈØäÈÆπÈØÜÈØèÈØëÈØíÈØ£ÈØ¢ÈØ§ÈØîÈØ°È∞∫ÈØ≤ÈØ±ÈØ∞È∞ïÈ∞îÈ∞âÈ∞ìÈ∞åÈ∞ÜÈ∞àÈ∞íÈ∞äÈ∞ÑÈ∞ÆÈ∞õÈ∞•È∞§È∞°È∞∞È±áÈ∞≤È±ÜÈ∞æÈ±öÈ±†È±ßÈ±∂È±∏È≥ßÈ≥¨È≥∞È¥âÈ¥àÈ≥´È¥ÉÈ¥ÜÈ¥™È¥¶È∂ØÈ¥£È¥üÈµÑÈ¥ïÈ¥íÈµÅÈ¥øÈ¥æÈµÜÈµà"],["ea40","ÈµùÈµûÈµ§ÈµëÈµêÈµôÈµ≤È∂âÈ∂áÈ∂´ÈµØÈµ∫È∂öÈ∂§È∂©È∂≤È∑ÑÈ∑ÅÈ∂ªÈ∂∏È∂∫È∑ÜÈ∑èÈ∑ÇÈ∑ôÈ∑ìÈ∑∏È∑¶È∑≠È∑ØÈ∑ΩÈ∏öÈ∏õÈ∏ûÈπµÈππÈπΩÈ∫ÅÈ∫àÈ∫ãÈ∫åÈ∫íÈ∫ïÈ∫ëÈ∫ùÈ∫•È∫©È∫∏È∫™È∫≠Èù°ÈªåÈªéÈªèÈªêÈªîÈªúÈªûÈªùÈª†Èª•Èª®ÈªØ"],["ea80","Èª¥Èª∂Èª∑ÈªπÈªªÈªºÈªΩÈºáÈºàÁö∑ÈºïÈº°Èº¨ÈºæÈΩäÈΩíÈΩîÈΩ£ÈΩüÈΩ†ÈΩ°ÈΩ¶ÈΩßÈΩ¨ÈΩ™ÈΩ∑ÈΩ≤ÈΩ∂ÈæïÈæúÈæ†Â†ØÊßáÈÅôÁë§ÂáúÁÜô"],["ed40","Á∫äË§úÈçàÈäàËìú‰øâÁÇªÊò±Ê£àÈãπÊõªÂΩÖ‰∏®‰ª°‰ªº‰ºÄ‰ºÉ‰ºπ‰Ωñ‰æí‰æä‰æö‰æî‰øçÂÅÄÂÄ¢‰øøÂÄûÂÅÜÂÅ∞ÂÅÇÂÇîÂÉ¥ÂÉòÂÖäÂÖ§ÂÜùÂÜæÂá¨ÂàïÂäúÂä¶ÂãÄÂãõÂåÄÂåáÂå§Âç≤ÂéìÂé≤ÂèùÔ®éÂíúÂíäÂí©ÂìøÂñÜÂùôÂù•Âû¨ÂüàÂüáÔ®è"],["ed80","Ô®êÂ¢ûÂ¢≤Â§ãÂ•ìÂ•õÂ•ùÂ•£Â¶§Â¶∫Â≠ñÂØÄÁîØÂØòÂØ¨Â∞ûÂ≤¶Â≤∫Â≥µÂ¥ßÂµìÔ®ëÂµÇÂµ≠Â∂∏Â∂πÂ∑êÂº°Âº¥ÂΩßÂæ∑ÂøûÊÅùÊÇÖÊÇäÊÉûÊÉïÊÑ†ÊÉ≤ÊÑëÊÑ∑ÊÑ∞ÊÜòÊàìÊä¶ÊèµÊë†ÊíùÊìéÊïéÊòÄÊòïÊòªÊòâÊòÆÊòûÊò§Êô•ÊôóÊôôÔ®íÊô≥ÊöôÊö†Êö≤ÊöøÊõ∫ÊúéÔ§©Êù¶ÊûªÊ°íÊüÄÊ†ÅÊ°ÑÊ£èÔ®ìÊ•®Ô®îÊ¶òÊß¢Ê®∞Ê©´Ê©ÜÊ©≥Ê©æÊ´¢Ê´§ÊØñÊ∞øÊ±úÊ≤ÜÊ±ØÊ≥öÊ¥ÑÊ∂áÊµØÊ∂ñÊ∂¨Ê∑èÊ∑∏Ê∑≤Ê∑ºÊ∏πÊπúÊ∏ßÊ∏ºÊ∫øÊæàÊæµÊøµÁÄÖÁÄáÁÄ®ÁÇÖÁÇ´ÁÑèÁÑÑÁÖúÁÖÜÁÖáÔ®ïÁáÅÁáæÁä±"],["ee40","ÁäæÁå§Ô®ñÁç∑ÁéΩÁèâÁèñÁè£ÁèíÁêáÁèµÁê¶Áê™Áê©ÁêÆÁë¢ÁíâÁíüÁîÅÁïØÁöÇÁöúÁöûÁöõÁö¶Ô®óÁùÜÂäØÁ†°Á°éÁ°§Á°∫Á§∞Ô®òÔ®ôÔ®öÁ¶îÔ®õÁ¶õÁ´ëÁ´ßÔ®úÁ´´ÁÆûÔ®ùÁµàÁµúÁ∂∑Á∂†Á∑ñÁπíÁΩáÁæ°Ô®ûËåÅËç¢ËçøËèáËè∂ËëàËí¥ËïìËïô"],["ee80","Ëï´Ô®üËñ∞Ô®†Ô®°Ë†áË£µË®íË®∑Ë©πË™ßË™æË´üÔ®¢Ë´∂Ë≠ìË≠øË≥∞Ë≥¥Ë¥íËµ∂Ô®£ËªèÔ®§Ô®•ÈÅßÈÉûÔ®¶ÈÑïÈÑßÈáöÈáóÈáûÈá≠ÈáÆÈá§Èá•ÈàÜÈàêÈàäÈà∫ÈâÄÈàºÈâéÈâôÈâëÈàπÈâßÈäßÈâ∑Èâ∏ÈãßÈãóÈãôÈãêÔ®ßÈãïÈã†ÈãìÈå•Èå°ÈãªÔ®®ÈåûÈãøÈåùÈåÇÈç∞ÈçóÈé§ÈèÜÈèûÈè∏Èê±ÈëÖÈëàÈñíÔßúÔ®©ÈöùÈöØÈú≥ÈúªÈùÉÈùçÈùèÈùëÈùïÈ°óÈ°•Ô®™Ô®´È§ßÔ®¨È¶ûÈ©éÈ´ôÈ´úÈ≠µÈ≠≤ÈÆèÈÆ±ÈÆªÈ∞ÄÈµ∞Èµ´Ô®≠È∏ôÈªë"],["eeef","‚Ö∞",9,"Ôø¢Ôø§ÔºáÔºÇ"],["f040","ÓÄÄ",62],["f080","ÓÄø",124],["f140","ÓÇº",62],["f180","ÓÉª",124],["f240","ÓÖ∏",62],["f280","ÓÜ∑",124],["f340","Óà¥",62],["f380","Óâ≥",124],["f440","Óã∞",62],["f480","ÓåØ",124],["f540","Óé¨",62],["f580","Óè´",124],["f640","Óë®",62],["f680","Óíß",124],["f740","Óî§",62],["f780","Óï£",124],["f840","Óó†",62],["f880","Óòü",124],["f940","Óöú"],["fa40","‚Ö∞",9,"‚Ö†",9,"Ôø¢Ôø§ÔºáÔºÇ„à±‚Ññ‚Ñ°‚àµÁ∫äË§úÈçàÈäàËìú‰øâÁÇªÊò±Ê£àÈãπÊõªÂΩÖ‰∏®‰ª°‰ªº‰ºÄ‰ºÉ‰ºπ‰Ωñ‰æí‰æä‰æö‰æî‰øçÂÅÄÂÄ¢‰øøÂÄûÂÅÜÂÅ∞ÂÅÇÂÇîÂÉ¥ÂÉòÂÖä"],["fa80","ÂÖ§ÂÜùÂÜæÂá¨ÂàïÂäúÂä¶ÂãÄÂãõÂåÄÂåáÂå§Âç≤ÂéìÂé≤ÂèùÔ®éÂíúÂíäÂí©ÂìøÂñÜÂùôÂù•Âû¨ÂüàÂüáÔ®èÔ®êÂ¢ûÂ¢≤Â§ãÂ•ìÂ•õÂ•ùÂ•£Â¶§Â¶∫Â≠ñÂØÄÁîØÂØòÂØ¨Â∞ûÂ≤¶Â≤∫Â≥µÂ¥ßÂµìÔ®ëÂµÇÂµ≠Â∂∏Â∂πÂ∑êÂº°Âº¥ÂΩßÂæ∑ÂøûÊÅùÊÇÖÊÇäÊÉûÊÉïÊÑ†ÊÉ≤ÊÑëÊÑ∑ÊÑ∞ÊÜòÊàìÊä¶ÊèµÊë†ÊíùÊìéÊïéÊòÄÊòïÊòªÊòâÊòÆÊòûÊò§Êô•ÊôóÊôôÔ®íÊô≥ÊöôÊö†Êö≤ÊöøÊõ∫ÊúéÔ§©Êù¶ÊûªÊ°íÊüÄÊ†ÅÊ°ÑÊ£èÔ®ìÊ•®Ô®îÊ¶òÊß¢Ê®∞Ê©´Ê©ÜÊ©≥Ê©æÊ´¢Ê´§ÊØñÊ∞øÊ±úÊ≤ÜÊ±ØÊ≥öÊ¥ÑÊ∂áÊµØ"],["fb40","Ê∂ñÊ∂¨Ê∑èÊ∑∏Ê∑≤Ê∑ºÊ∏πÊπúÊ∏ßÊ∏ºÊ∫øÊæàÊæµÊøµÁÄÖÁÄáÁÄ®ÁÇÖÁÇ´ÁÑèÁÑÑÁÖúÁÖÜÁÖáÔ®ïÁáÅÁáæÁä±ÁäæÁå§Ô®ñÁç∑ÁéΩÁèâÁèñÁè£ÁèíÁêáÁèµÁê¶Áê™Áê©ÁêÆÁë¢ÁíâÁíüÁîÅÁïØÁöÇÁöúÁöûÁöõÁö¶Ô®óÁùÜÂäØÁ†°Á°éÁ°§Á°∫Á§∞Ô®òÔ®ô"],["fb80","Ô®öÁ¶îÔ®õÁ¶õÁ´ëÁ´ßÔ®úÁ´´ÁÆûÔ®ùÁµàÁµúÁ∂∑Á∂†Á∑ñÁπíÁΩáÁæ°Ô®ûËåÅËç¢ËçøËèáËè∂ËëàËí¥ËïìËïôËï´Ô®üËñ∞Ô®†Ô®°Ë†áË£µË®íË®∑Ë©πË™ßË™æË´üÔ®¢Ë´∂Ë≠ìË≠øË≥∞Ë≥¥Ë¥íËµ∂Ô®£ËªèÔ®§Ô®•ÈÅßÈÉûÔ®¶ÈÑïÈÑßÈáöÈáóÈáûÈá≠ÈáÆÈá§Èá•ÈàÜÈàêÈàäÈà∫ÈâÄÈàºÈâéÈâôÈâëÈàπÈâßÈäßÈâ∑Èâ∏ÈãßÈãóÈãôÈãêÔ®ßÈãïÈã†ÈãìÈå•Èå°ÈãªÔ®®ÈåûÈãøÈåùÈåÇÈç∞ÈçóÈé§ÈèÜÈèûÈè∏Èê±ÈëÖÈëàÈñíÔßúÔ®©ÈöùÈöØÈú≥ÈúªÈùÉÈùçÈùèÈùëÈùïÈ°óÈ°•Ô®™Ô®´È§ßÔ®¨È¶ûÈ©éÈ´ô"],["fc40","È´úÈ≠µÈ≠≤ÈÆèÈÆ±ÈÆªÈ∞ÄÈµ∞Èµ´Ô®≠È∏ôÈªë"]]');

/***/ }),

/***/ 59593:
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('{"application/andrew-inset":["ez"],"application/applixware":["aw"],"application/atom+xml":["atom"],"application/atomcat+xml":["atomcat"],"application/atomsvc+xml":["atomsvc"],"application/bdoc":["bdoc"],"application/ccxml+xml":["ccxml"],"application/cdmi-capability":["cdmia"],"application/cdmi-container":["cdmic"],"application/cdmi-domain":["cdmid"],"application/cdmi-object":["cdmio"],"application/cdmi-queue":["cdmiq"],"application/cu-seeme":["cu"],"application/dash+xml":["mpd"],"application/davmount+xml":["davmount"],"application/docbook+xml":["dbk"],"application/dssc+der":["dssc"],"application/dssc+xml":["xdssc"],"application/ecmascript":["ecma"],"application/emma+xml":["emma"],"application/epub+zip":["epub"],"application/exi":["exi"],"application/font-tdpfr":["pfr"],"application/font-woff":[],"application/font-woff2":[],"application/geo+json":["geojson"],"application/gml+xml":["gml"],"application/gpx+xml":["gpx"],"application/gxf":["gxf"],"application/gzip":["gz"],"application/hyperstudio":["stk"],"application/inkml+xml":["ink","inkml"],"application/ipfix":["ipfix"],"application/java-archive":["jar","war","ear"],"application/java-serialized-object":["ser"],"application/java-vm":["class"],"application/javascript":["js","mjs"],"application/json":["json","map"],"application/json5":["json5"],"application/jsonml+json":["jsonml"],"application/ld+json":["jsonld"],"application/lost+xml":["lostxml"],"application/mac-binhex40":["hqx"],"application/mac-compactpro":["cpt"],"application/mads+xml":["mads"],"application/manifest+json":["webmanifest"],"application/marc":["mrc"],"application/marcxml+xml":["mrcx"],"application/mathematica":["ma","nb","mb"],"application/mathml+xml":["mathml"],"application/mbox":["mbox"],"application/mediaservercontrol+xml":["mscml"],"application/metalink+xml":["metalink"],"application/metalink4+xml":["meta4"],"application/mets+xml":["mets"],"application/mods+xml":["mods"],"application/mp21":["m21","mp21"],"application/mp4":["mp4s","m4p"],"application/msword":["doc","dot"],"application/mxf":["mxf"],"application/octet-stream":["bin","dms","lrf","mar","so","dist","distz","pkg","bpk","dump","elc","deploy","exe","dll","deb","dmg","iso","img","msi","msp","msm","buffer"],"application/oda":["oda"],"application/oebps-package+xml":["opf"],"application/ogg":["ogx"],"application/omdoc+xml":["omdoc"],"application/onenote":["onetoc","onetoc2","onetmp","onepkg"],"application/oxps":["oxps"],"application/patch-ops-error+xml":["xer"],"application/pdf":["pdf"],"application/pgp-encrypted":["pgp"],"application/pgp-signature":["asc","sig"],"application/pics-rules":["prf"],"application/pkcs10":["p10"],"application/pkcs7-mime":["p7m","p7c"],"application/pkcs7-signature":["p7s"],"application/pkcs8":["p8"],"application/pkix-attr-cert":["ac"],"application/pkix-cert":["cer"],"application/pkix-crl":["crl"],"application/pkix-pkipath":["pkipath"],"application/pkixcmp":["pki"],"application/pls+xml":["pls"],"application/postscript":["ai","eps","ps"],"application/prs.cww":["cww"],"application/pskc+xml":["pskcxml"],"application/raml+yaml":["raml"],"application/rdf+xml":["rdf"],"application/reginfo+xml":["rif"],"application/relax-ng-compact-syntax":["rnc"],"application/resource-lists+xml":["rl"],"application/resource-lists-diff+xml":["rld"],"application/rls-services+xml":["rs"],"application/rpki-ghostbusters":["gbr"],"application/rpki-manifest":["mft"],"application/rpki-roa":["roa"],"application/rsd+xml":["rsd"],"application/rss+xml":["rss"],"application/rtf":["rtf"],"application/sbml+xml":["sbml"],"application/scvp-cv-request":["scq"],"application/scvp-cv-response":["scs"],"application/scvp-vp-request":["spq"],"application/scvp-vp-response":["spp"],"application/sdp":["sdp"],"application/set-payment-initiation":["setpay"],"application/set-registration-initiation":["setreg"],"application/shf+xml":["shf"],"application/smil+xml":["smi","smil"],"application/sparql-query":["rq"],"application/sparql-results+xml":["srx"],"application/srgs":["gram"],"application/srgs+xml":["grxml"],"application/sru+xml":["sru"],"application/ssdl+xml":["ssdl"],"application/ssml+xml":["ssml"],"application/tei+xml":["tei","teicorpus"],"application/thraud+xml":["tfi"],"application/timestamped-data":["tsd"],"application/vnd.3gpp.pic-bw-large":["plb"],"application/vnd.3gpp.pic-bw-small":["psb"],"application/vnd.3gpp.pic-bw-var":["pvb"],"application/vnd.3gpp2.tcap":["tcap"],"application/vnd.3m.post-it-notes":["pwn"],"application/vnd.accpac.simply.aso":["aso"],"application/vnd.accpac.simply.imp":["imp"],"application/vnd.acucobol":["acu"],"application/vnd.acucorp":["atc","acutc"],"application/vnd.adobe.air-application-installer-package+zip":["air"],"application/vnd.adobe.formscentral.fcdt":["fcdt"],"application/vnd.adobe.fxp":["fxp","fxpl"],"application/vnd.adobe.xdp+xml":["xdp"],"application/vnd.adobe.xfdf":["xfdf"],"application/vnd.ahead.space":["ahead"],"application/vnd.airzip.filesecure.azf":["azf"],"application/vnd.airzip.filesecure.azs":["azs"],"application/vnd.amazon.ebook":["azw"],"application/vnd.americandynamics.acc":["acc"],"application/vnd.amiga.ami":["ami"],"application/vnd.android.package-archive":["apk"],"application/vnd.anser-web-certificate-issue-initiation":["cii"],"application/vnd.anser-web-funds-transfer-initiation":["fti"],"application/vnd.antix.game-component":["atx"],"application/vnd.apple.installer+xml":["mpkg"],"application/vnd.apple.mpegurl":["m3u8"],"application/vnd.apple.pkpass":["pkpass"],"application/vnd.aristanetworks.swi":["swi"],"application/vnd.astraea-software.iota":["iota"],"application/vnd.audiograph":["aep"],"application/vnd.blueice.multipass":["mpm"],"application/vnd.bmi":["bmi"],"application/vnd.businessobjects":["rep"],"application/vnd.chemdraw+xml":["cdxml"],"application/vnd.chipnuts.karaoke-mmd":["mmd"],"application/vnd.cinderella":["cdy"],"application/vnd.claymore":["cla"],"application/vnd.cloanto.rp9":["rp9"],"application/vnd.clonk.c4group":["c4g","c4d","c4f","c4p","c4u"],"application/vnd.cluetrust.cartomobile-config":["c11amc"],"application/vnd.cluetrust.cartomobile-config-pkg":["c11amz"],"application/vnd.commonspace":["csp"],"application/vnd.contact.cmsg":["cdbcmsg"],"application/vnd.cosmocaller":["cmc"],"application/vnd.crick.clicker":["clkx"],"application/vnd.crick.clicker.keyboard":["clkk"],"application/vnd.crick.clicker.palette":["clkp"],"application/vnd.crick.clicker.template":["clkt"],"application/vnd.crick.clicker.wordbank":["clkw"],"application/vnd.criticaltools.wbs+xml":["wbs"],"application/vnd.ctc-posml":["pml"],"application/vnd.cups-ppd":["ppd"],"application/vnd.curl.car":["car"],"application/vnd.curl.pcurl":["pcurl"],"application/vnd.dart":["dart"],"application/vnd.data-vision.rdz":["rdz"],"application/vnd.dece.data":["uvf","uvvf","uvd","uvvd"],"application/vnd.dece.ttml+xml":["uvt","uvvt"],"application/vnd.dece.unspecified":["uvx","uvvx"],"application/vnd.dece.zip":["uvz","uvvz"],"application/vnd.denovo.fcselayout-link":["fe_launch"],"application/vnd.dna":["dna"],"application/vnd.dolby.mlp":["mlp"],"application/vnd.dpgraph":["dpg"],"application/vnd.dreamfactory":["dfac"],"application/vnd.ds-keypoint":["kpxx"],"application/vnd.dvb.ait":["ait"],"application/vnd.dvb.service":["svc"],"application/vnd.dynageo":["geo"],"application/vnd.ecowin.chart":["mag"],"application/vnd.enliven":["nml"],"application/vnd.epson.esf":["esf"],"application/vnd.epson.msf":["msf"],"application/vnd.epson.quickanime":["qam"],"application/vnd.epson.salt":["slt"],"application/vnd.epson.ssf":["ssf"],"application/vnd.eszigno3+xml":["es3","et3"],"application/vnd.ezpix-album":["ez2"],"application/vnd.ezpix-package":["ez3"],"application/vnd.fdf":["fdf"],"application/vnd.fdsn.mseed":["mseed"],"application/vnd.fdsn.seed":["seed","dataless"],"application/vnd.flographit":["gph"],"application/vnd.fluxtime.clip":["ftc"],"application/vnd.framemaker":["fm","frame","maker","book"],"application/vnd.frogans.fnc":["fnc"],"application/vnd.frogans.ltf":["ltf"],"application/vnd.fsc.weblaunch":["fsc"],"application/vnd.fujitsu.oasys":["oas"],"application/vnd.fujitsu.oasys2":["oa2"],"application/vnd.fujitsu.oasys3":["oa3"],"application/vnd.fujitsu.oasysgp":["fg5"],"application/vnd.fujitsu.oasysprs":["bh2"],"application/vnd.fujixerox.ddd":["ddd"],"application/vnd.fujixerox.docuworks":["xdw"],"application/vnd.fujixerox.docuworks.binder":["xbd"],"application/vnd.fuzzysheet":["fzs"],"application/vnd.genomatix.tuxedo":["txd"],"application/vnd.geogebra.file":["ggb"],"application/vnd.geogebra.tool":["ggt"],"application/vnd.geometry-explorer":["gex","gre"],"application/vnd.geonext":["gxt"],"application/vnd.geoplan":["g2w"],"application/vnd.geospace":["g3w"],"application/vnd.gmx":["gmx"],"application/vnd.google-apps.document":["gdoc"],"application/vnd.google-apps.presentation":["gslides"],"application/vnd.google-apps.spreadsheet":["gsheet"],"application/vnd.google-earth.kml+xml":["kml"],"application/vnd.google-earth.kmz":["kmz"],"application/vnd.grafeq":["gqf","gqs"],"application/vnd.groove-account":["gac"],"application/vnd.groove-help":["ghf"],"application/vnd.groove-identity-message":["gim"],"application/vnd.groove-injector":["grv"],"application/vnd.groove-tool-message":["gtm"],"application/vnd.groove-tool-template":["tpl"],"application/vnd.groove-vcard":["vcg"],"application/vnd.hal+xml":["hal"],"application/vnd.handheld-entertainment+xml":["zmm"],"application/vnd.hbci":["hbci"],"application/vnd.hhe.lesson-player":["les"],"application/vnd.hp-hpgl":["hpgl"],"application/vnd.hp-hpid":["hpid"],"application/vnd.hp-hps":["hps"],"application/vnd.hp-jlyt":["jlt"],"application/vnd.hp-pcl":["pcl"],"application/vnd.hp-pclxl":["pclxl"],"application/vnd.hydrostatix.sof-data":["sfd-hdstx"],"application/vnd.ibm.minipay":["mpy"],"application/vnd.ibm.modcap":["afp","listafp","list3820"],"application/vnd.ibm.rights-management":["irm"],"application/vnd.ibm.secure-container":["sc"],"application/vnd.iccprofile":["icc","icm"],"application/vnd.igloader":["igl"],"application/vnd.immervision-ivp":["ivp"],"application/vnd.immervision-ivu":["ivu"],"application/vnd.insors.igm":["igm"],"application/vnd.intercon.formnet":["xpw","xpx"],"application/vnd.intergeo":["i2g"],"application/vnd.intu.qbo":["qbo"],"application/vnd.intu.qfx":["qfx"],"application/vnd.ipunplugged.rcprofile":["rcprofile"],"application/vnd.irepository.package+xml":["irp"],"application/vnd.is-xpr":["xpr"],"application/vnd.isac.fcs":["fcs"],"application/vnd.jam":["jam"],"application/vnd.jcp.javame.midlet-rms":["rms"],"application/vnd.jisp":["jisp"],"application/vnd.joost.joda-archive":["joda"],"application/vnd.kahootz":["ktz","ktr"],"application/vnd.kde.karbon":["karbon"],"application/vnd.kde.kchart":["chrt"],"application/vnd.kde.kformula":["kfo"],"application/vnd.kde.kivio":["flw"],"application/vnd.kde.kontour":["kon"],"application/vnd.kde.kpresenter":["kpr","kpt"],"application/vnd.kde.kspread":["ksp"],"application/vnd.kde.kword":["kwd","kwt"],"application/vnd.kenameaapp":["htke"],"application/vnd.kidspiration":["kia"],"application/vnd.kinar":["kne","knp"],"application/vnd.koan":["skp","skd","skt","skm"],"application/vnd.kodak-descriptor":["sse"],"application/vnd.las.las+xml":["lasxml"],"application/vnd.llamagraphics.life-balance.desktop":["lbd"],"application/vnd.llamagraphics.life-balance.exchange+xml":["lbe"],"application/vnd.lotus-1-2-3":["123"],"application/vnd.lotus-approach":["apr"],"application/vnd.lotus-freelance":["pre"],"application/vnd.lotus-notes":["nsf"],"application/vnd.lotus-organizer":["org"],"application/vnd.lotus-screencam":["scm"],"application/vnd.lotus-wordpro":["lwp"],"application/vnd.macports.portpkg":["portpkg"],"application/vnd.mcd":["mcd"],"application/vnd.medcalcdata":["mc1"],"application/vnd.mediastation.cdkey":["cdkey"],"application/vnd.mfer":["mwf"],"application/vnd.mfmp":["mfm"],"application/vnd.micrografx.flo":["flo"],"application/vnd.micrografx.igx":["igx"],"application/vnd.mif":["mif"],"application/vnd.mobius.daf":["daf"],"application/vnd.mobius.dis":["dis"],"application/vnd.mobius.mbk":["mbk"],"application/vnd.mobius.mqy":["mqy"],"application/vnd.mobius.msl":["msl"],"application/vnd.mobius.plc":["plc"],"application/vnd.mobius.txf":["txf"],"application/vnd.mophun.application":["mpn"],"application/vnd.mophun.certificate":["mpc"],"application/vnd.mozilla.xul+xml":["xul"],"application/vnd.ms-artgalry":["cil"],"application/vnd.ms-cab-compressed":["cab"],"application/vnd.ms-excel":["xls","xlm","xla","xlc","xlt","xlw"],"application/vnd.ms-excel.addin.macroenabled.12":["xlam"],"application/vnd.ms-excel.sheet.binary.macroenabled.12":["xlsb"],"application/vnd.ms-excel.sheet.macroenabled.12":["xlsm"],"application/vnd.ms-excel.template.macroenabled.12":["xltm"],"application/vnd.ms-fontobject":["eot"],"application/vnd.ms-htmlhelp":["chm"],"application/vnd.ms-ims":["ims"],"application/vnd.ms-lrm":["lrm"],"application/vnd.ms-officetheme":["thmx"],"application/vnd.ms-outlook":["msg"],"application/vnd.ms-pki.seccat":["cat"],"application/vnd.ms-pki.stl":["stl"],"application/vnd.ms-powerpoint":["ppt","pps","pot"],"application/vnd.ms-powerpoint.addin.macroenabled.12":["ppam"],"application/vnd.ms-powerpoint.presentation.macroenabled.12":["pptm"],"application/vnd.ms-powerpoint.slide.macroenabled.12":["sldm"],"application/vnd.ms-powerpoint.slideshow.macroenabled.12":["ppsm"],"application/vnd.ms-powerpoint.template.macroenabled.12":["potm"],"application/vnd.ms-project":["mpp","mpt"],"application/vnd.ms-word.document.macroenabled.12":["docm"],"application/vnd.ms-word.template.macroenabled.12":["dotm"],"application/vnd.ms-works":["wps","wks","wcm","wdb"],"application/vnd.ms-wpl":["wpl"],"application/vnd.ms-xpsdocument":["xps"],"application/vnd.mseq":["mseq"],"application/vnd.musician":["mus"],"application/vnd.muvee.style":["msty"],"application/vnd.mynfc":["taglet"],"application/vnd.neurolanguage.nlu":["nlu"],"application/vnd.nitf":["ntf","nitf"],"application/vnd.noblenet-directory":["nnd"],"application/vnd.noblenet-sealer":["nns"],"application/vnd.noblenet-web":["nnw"],"application/vnd.nokia.n-gage.data":["ngdat"],"application/vnd.nokia.n-gage.symbian.install":["n-gage"],"application/vnd.nokia.radio-preset":["rpst"],"application/vnd.nokia.radio-presets":["rpss"],"application/vnd.novadigm.edm":["edm"],"application/vnd.novadigm.edx":["edx"],"application/vnd.novadigm.ext":["ext"],"application/vnd.oasis.opendocument.chart":["odc"],"application/vnd.oasis.opendocument.chart-template":["otc"],"application/vnd.oasis.opendocument.database":["odb"],"application/vnd.oasis.opendocument.formula":["odf"],"application/vnd.oasis.opendocument.formula-template":["odft"],"application/vnd.oasis.opendocument.graphics":["odg"],"application/vnd.oasis.opendocument.graphics-template":["otg"],"application/vnd.oasis.opendocument.image":["odi"],"application/vnd.oasis.opendocument.image-template":["oti"],"application/vnd.oasis.opendocument.presentation":["odp"],"application/vnd.oasis.opendocument.presentation-template":["otp"],"application/vnd.oasis.opendocument.spreadsheet":["ods"],"application/vnd.oasis.opendocument.spreadsheet-template":["ots"],"application/vnd.oasis.opendocument.text":["odt"],"application/vnd.oasis.opendocument.text-master":["odm"],"application/vnd.oasis.opendocument.text-template":["ott"],"application/vnd.oasis.opendocument.text-web":["oth"],"application/vnd.olpc-sugar":["xo"],"application/vnd.oma.dd2+xml":["dd2"],"application/vnd.openofficeorg.extension":["oxt"],"application/vnd.openxmlformats-officedocument.presentationml.presentation":["pptx"],"application/vnd.openxmlformats-officedocument.presentationml.slide":["sldx"],"application/vnd.openxmlformats-officedocument.presentationml.slideshow":["ppsx"],"application/vnd.openxmlformats-officedocument.presentationml.template":["potx"],"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet":["xlsx"],"application/vnd.openxmlformats-officedocument.spreadsheetml.template":["xltx"],"application/vnd.openxmlformats-officedocument.wordprocessingml.document":["docx"],"application/vnd.openxmlformats-officedocument.wordprocessingml.template":["dotx"],"application/vnd.osgeo.mapguide.package":["mgp"],"application/vnd.osgi.dp":["dp"],"application/vnd.osgi.subsystem":["esa"],"application/vnd.palm":["pdb","pqa","oprc"],"application/vnd.pawaafile":["paw"],"application/vnd.pg.format":["str"],"application/vnd.pg.osasli":["ei6"],"application/vnd.picsel":["efif"],"application/vnd.pmi.widget":["wg"],"application/vnd.pocketlearn":["plf"],"application/vnd.powerbuilder6":["pbd"],"application/vnd.previewsystems.box":["box"],"application/vnd.proteus.magazine":["mgz"],"application/vnd.publishare-delta-tree":["qps"],"application/vnd.pvi.ptid1":["ptid"],"application/vnd.quark.quarkxpress":["qxd","qxt","qwd","qwt","qxl","qxb"],"application/vnd.realvnc.bed":["bed"],"application/vnd.recordare.musicxml":["mxl"],"application/vnd.recordare.musicxml+xml":["musicxml"],"application/vnd.rig.cryptonote":["cryptonote"],"application/vnd.rim.cod":["cod"],"application/vnd.rn-realmedia":["rm"],"application/vnd.rn-realmedia-vbr":["rmvb"],"application/vnd.route66.link66+xml":["link66"],"application/vnd.sailingtracker.track":["st"],"application/vnd.seemail":["see"],"application/vnd.sema":["sema"],"application/vnd.semd":["semd"],"application/vnd.semf":["semf"],"application/vnd.shana.informed.formdata":["ifm"],"application/vnd.shana.informed.formtemplate":["itp"],"application/vnd.shana.informed.interchange":["iif"],"application/vnd.shana.informed.package":["ipk"],"application/vnd.simtech-mindmapper":["twd","twds"],"application/vnd.smaf":["mmf"],"application/vnd.smart.teacher":["teacher"],"application/vnd.solent.sdkm+xml":["sdkm","sdkd"],"application/vnd.spotfire.dxp":["dxp"],"application/vnd.spotfire.sfs":["sfs"],"application/vnd.stardivision.calc":["sdc"],"application/vnd.stardivision.draw":["sda"],"application/vnd.stardivision.impress":["sdd"],"application/vnd.stardivision.math":["smf"],"application/vnd.stardivision.writer":["sdw","vor"],"application/vnd.stardivision.writer-global":["sgl"],"application/vnd.stepmania.package":["smzip"],"application/vnd.stepmania.stepchart":["sm"],"application/vnd.sun.wadl+xml":["wadl"],"application/vnd.sun.xml.calc":["sxc"],"application/vnd.sun.xml.calc.template":["stc"],"application/vnd.sun.xml.draw":["sxd"],"application/vnd.sun.xml.draw.template":["std"],"application/vnd.sun.xml.impress":["sxi"],"application/vnd.sun.xml.impress.template":["sti"],"application/vnd.sun.xml.math":["sxm"],"application/vnd.sun.xml.writer":["sxw"],"application/vnd.sun.xml.writer.global":["sxg"],"application/vnd.sun.xml.writer.template":["stw"],"application/vnd.sus-calendar":["sus","susp"],"application/vnd.svd":["svd"],"application/vnd.symbian.install":["sis","sisx"],"application/vnd.syncml+xml":["xsm"],"application/vnd.syncml.dm+wbxml":["bdm"],"application/vnd.syncml.dm+xml":["xdm"],"application/vnd.tao.intent-module-archive":["tao"],"application/vnd.tcpdump.pcap":["pcap","cap","dmp"],"application/vnd.tmobile-livetv":["tmo"],"application/vnd.trid.tpt":["tpt"],"application/vnd.triscape.mxs":["mxs"],"application/vnd.trueapp":["tra"],"application/vnd.ufdl":["ufd","ufdl"],"application/vnd.uiq.theme":["utz"],"application/vnd.umajin":["umj"],"application/vnd.unity":["unityweb"],"application/vnd.uoml+xml":["uoml"],"application/vnd.vcx":["vcx"],"application/vnd.visio":["vsd","vst","vss","vsw"],"application/vnd.visionary":["vis"],"application/vnd.vsf":["vsf"],"application/vnd.wap.wbxml":["wbxml"],"application/vnd.wap.wmlc":["wmlc"],"application/vnd.wap.wmlscriptc":["wmlsc"],"application/vnd.webturbo":["wtb"],"application/vnd.wolfram.player":["nbp"],"application/vnd.wordperfect":["wpd"],"application/vnd.wqd":["wqd"],"application/vnd.wt.stf":["stf"],"application/vnd.xara":["xar"],"application/vnd.xfdl":["xfdl"],"application/vnd.yamaha.hv-dic":["hvd"],"application/vnd.yamaha.hv-script":["hvs"],"application/vnd.yamaha.hv-voice":["hvp"],"application/vnd.yamaha.openscoreformat":["osf"],"application/vnd.yamaha.openscoreformat.osfpvg+xml":["osfpvg"],"application/vnd.yamaha.smaf-audio":["saf"],"application/vnd.yamaha.smaf-phrase":["spf"],"application/vnd.yellowriver-custom-menu":["cmp"],"application/vnd.zul":["zir","zirz"],"application/vnd.zzazz.deck+xml":["zaz"],"application/voicexml+xml":["vxml"],"application/wasm":["wasm"],"application/widget":["wgt"],"application/winhlp":["hlp"],"application/wsdl+xml":["wsdl"],"application/wspolicy+xml":["wspolicy"],"application/x-7z-compressed":["7z"],"application/x-abiword":["abw"],"application/x-ace-compressed":["ace"],"application/x-apple-diskimage":[],"application/x-arj":["arj"],"application/x-authorware-bin":["aab","x32","u32","vox"],"application/x-authorware-map":["aam"],"application/x-authorware-seg":["aas"],"application/x-bcpio":["bcpio"],"application/x-bdoc":[],"application/x-bittorrent":["torrent"],"application/x-blorb":["blb","blorb"],"application/x-bzip":["bz"],"application/x-bzip2":["bz2","boz"],"application/x-cbr":["cbr","cba","cbt","cbz","cb7"],"application/x-cdlink":["vcd"],"application/x-cfs-compressed":["cfs"],"application/x-chat":["chat"],"application/x-chess-pgn":["pgn"],"application/x-chrome-extension":["crx"],"application/x-cocoa":["cco"],"application/x-conference":["nsc"],"application/x-cpio":["cpio"],"application/x-csh":["csh"],"application/x-debian-package":["udeb"],"application/x-dgc-compressed":["dgc"],"application/x-director":["dir","dcr","dxr","cst","cct","cxt","w3d","fgd","swa"],"application/x-doom":["wad"],"application/x-dtbncx+xml":["ncx"],"application/x-dtbook+xml":["dtb"],"application/x-dtbresource+xml":["res"],"application/x-dvi":["dvi"],"application/x-envoy":["evy"],"application/x-eva":["eva"],"application/x-font-bdf":["bdf"],"application/x-font-ghostscript":["gsf"],"application/x-font-linux-psf":["psf"],"application/x-font-pcf":["pcf"],"application/x-font-snf":["snf"],"application/x-font-type1":["pfa","pfb","pfm","afm"],"application/x-freearc":["arc"],"application/x-futuresplash":["spl"],"application/x-gca-compressed":["gca"],"application/x-glulx":["ulx"],"application/x-gnumeric":["gnumeric"],"application/x-gramps-xml":["gramps"],"application/x-gtar":["gtar"],"application/x-hdf":["hdf"],"application/x-httpd-php":["php"],"application/x-install-instructions":["install"],"application/x-iso9660-image":[],"application/x-java-archive-diff":["jardiff"],"application/x-java-jnlp-file":["jnlp"],"application/x-latex":["latex"],"application/x-lua-bytecode":["luac"],"application/x-lzh-compressed":["lzh","lha"],"application/x-makeself":["run"],"application/x-mie":["mie"],"application/x-mobipocket-ebook":["prc","mobi"],"application/x-ms-application":["application"],"application/x-ms-shortcut":["lnk"],"application/x-ms-wmd":["wmd"],"application/x-ms-wmz":["wmz"],"application/x-ms-xbap":["xbap"],"application/x-msaccess":["mdb"],"application/x-msbinder":["obd"],"application/x-mscardfile":["crd"],"application/x-msclip":["clp"],"application/x-msdos-program":[],"application/x-msdownload":["com","bat"],"application/x-msmediaview":["mvb","m13","m14"],"application/x-msmetafile":["wmf","emf","emz"],"application/x-msmoney":["mny"],"application/x-mspublisher":["pub"],"application/x-msschedule":["scd"],"application/x-msterminal":["trm"],"application/x-mswrite":["wri"],"application/x-netcdf":["nc","cdf"],"application/x-ns-proxy-autoconfig":["pac"],"application/x-nzb":["nzb"],"application/x-perl":["pl","pm"],"application/x-pilot":[],"application/x-pkcs12":["p12","pfx"],"application/x-pkcs7-certificates":["p7b","spc"],"application/x-pkcs7-certreqresp":["p7r"],"application/x-rar-compressed":["rar"],"application/x-redhat-package-manager":["rpm"],"application/x-research-info-systems":["ris"],"application/x-sea":["sea"],"application/x-sh":["sh"],"application/x-shar":["shar"],"application/x-shockwave-flash":["swf"],"application/x-silverlight-app":["xap"],"application/x-sql":["sql"],"application/x-stuffit":["sit"],"application/x-stuffitx":["sitx"],"application/x-subrip":["srt"],"application/x-sv4cpio":["sv4cpio"],"application/x-sv4crc":["sv4crc"],"application/x-t3vm-image":["t3"],"application/x-tads":["gam"],"application/x-tar":["tar"],"application/x-tcl":["tcl","tk"],"application/x-tex":["tex"],"application/x-tex-tfm":["tfm"],"application/x-texinfo":["texinfo","texi"],"application/x-tgif":["obj"],"application/x-ustar":["ustar"],"application/x-virtualbox-hdd":["hdd"],"application/x-virtualbox-ova":["ova"],"application/x-virtualbox-ovf":["ovf"],"application/x-virtualbox-vbox":["vbox"],"application/x-virtualbox-vbox-extpack":["vbox-extpack"],"application/x-virtualbox-vdi":["vdi"],"application/x-virtualbox-vhd":["vhd"],"application/x-virtualbox-vmdk":["vmdk"],"application/x-wais-source":["src"],"application/x-web-app-manifest+json":["webapp"],"application/x-x509-ca-cert":["der","crt","pem"],"application/x-xfig":["fig"],"application/x-xliff+xml":["xlf"],"application/x-xpinstall":["xpi"],"application/x-xz":["xz"],"application/x-zmachine":["z1","z2","z3","z4","z5","z6","z7","z8"],"application/xaml+xml":["xaml"],"application/xcap-diff+xml":["xdf"],"application/xenc+xml":["xenc"],"application/xhtml+xml":["xhtml","xht"],"application/xml":["xml","xsl","xsd","rng"],"application/xml-dtd":["dtd"],"application/xop+xml":["xop"],"application/xproc+xml":["xpl"],"application/xslt+xml":["xslt"],"application/xspf+xml":["xspf"],"application/xv+xml":["mxml","xhvml","xvml","xvm"],"application/yang":["yang"],"application/yin+xml":["yin"],"application/zip":["zip"],"audio/3gpp":[],"audio/adpcm":["adp"],"audio/basic":["au","snd"],"audio/midi":["mid","midi","kar","rmi"],"audio/mp3":[],"audio/mp4":["m4a","mp4a"],"audio/mpeg":["mpga","mp2","mp2a","mp3","m2a","m3a"],"audio/ogg":["oga","ogg","spx"],"audio/s3m":["s3m"],"audio/silk":["sil"],"audio/vnd.dece.audio":["uva","uvva"],"audio/vnd.digital-winds":["eol"],"audio/vnd.dra":["dra"],"audio/vnd.dts":["dts"],"audio/vnd.dts.hd":["dtshd"],"audio/vnd.lucent.voice":["lvp"],"audio/vnd.ms-playready.media.pya":["pya"],"audio/vnd.nuera.ecelp4800":["ecelp4800"],"audio/vnd.nuera.ecelp7470":["ecelp7470"],"audio/vnd.nuera.ecelp9600":["ecelp9600"],"audio/vnd.rip":["rip"],"audio/wav":["wav"],"audio/wave":[],"audio/webm":["weba"],"audio/x-aac":["aac"],"audio/x-aiff":["aif","aiff","aifc"],"audio/x-caf":["caf"],"audio/x-flac":["flac"],"audio/x-m4a":[],"audio/x-matroska":["mka"],"audio/x-mpegurl":["m3u"],"audio/x-ms-wax":["wax"],"audio/x-ms-wma":["wma"],"audio/x-pn-realaudio":["ram","ra"],"audio/x-pn-realaudio-plugin":["rmp"],"audio/x-realaudio":[],"audio/x-wav":[],"audio/xm":["xm"],"chemical/x-cdx":["cdx"],"chemical/x-cif":["cif"],"chemical/x-cmdf":["cmdf"],"chemical/x-cml":["cml"],"chemical/x-csml":["csml"],"chemical/x-xyz":["xyz"],"font/collection":["ttc"],"font/otf":["otf"],"font/ttf":["ttf"],"font/woff":["woff"],"font/woff2":["woff2"],"image/apng":["apng"],"image/bmp":["bmp"],"image/cgm":["cgm"],"image/g3fax":["g3"],"image/gif":["gif"],"image/ief":["ief"],"image/jp2":["jp2","jpg2"],"image/jpeg":["jpeg","jpg","jpe"],"image/jpm":["jpm"],"image/jpx":["jpx","jpf"],"image/ktx":["ktx"],"image/png":["png"],"image/prs.btif":["btif"],"image/sgi":["sgi"],"image/svg+xml":["svg","svgz"],"image/tiff":["tiff","tif"],"image/vnd.adobe.photoshop":["psd"],"image/vnd.dece.graphic":["uvi","uvvi","uvg","uvvg"],"image/vnd.djvu":["djvu","djv"],"image/vnd.dvb.subtitle":[],"image/vnd.dwg":["dwg"],"image/vnd.dxf":["dxf"],"image/vnd.fastbidsheet":["fbs"],"image/vnd.fpx":["fpx"],"image/vnd.fst":["fst"],"image/vnd.fujixerox.edmics-mmr":["mmr"],"image/vnd.fujixerox.edmics-rlc":["rlc"],"image/vnd.ms-modi":["mdi"],"image/vnd.ms-photo":["wdp"],"image/vnd.net-fpx":["npx"],"image/vnd.wap.wbmp":["wbmp"],"image/vnd.xiff":["xif"],"image/webp":["webp"],"image/x-3ds":["3ds"],"image/x-cmu-raster":["ras"],"image/x-cmx":["cmx"],"image/x-freehand":["fh","fhc","fh4","fh5","fh7"],"image/x-icon":["ico"],"image/x-jng":["jng"],"image/x-mrsid-image":["sid"],"image/x-ms-bmp":[],"image/x-pcx":["pcx"],"image/x-pict":["pic","pct"],"image/x-portable-anymap":["pnm"],"image/x-portable-bitmap":["pbm"],"image/x-portable-graymap":["pgm"],"image/x-portable-pixmap":["ppm"],"image/x-rgb":["rgb"],"image/x-tga":["tga"],"image/x-xbitmap":["xbm"],"image/x-xpixmap":["xpm"],"image/x-xwindowdump":["xwd"],"message/rfc822":["eml","mime"],"model/gltf+json":["gltf"],"model/gltf-binary":["glb"],"model/iges":["igs","iges"],"model/mesh":["msh","mesh","silo"],"model/vnd.collada+xml":["dae"],"model/vnd.dwf":["dwf"],"model/vnd.gdl":["gdl"],"model/vnd.gtw":["gtw"],"model/vnd.mts":["mts"],"model/vnd.vtu":["vtu"],"model/vrml":["wrl","vrml"],"model/x3d+binary":["x3db","x3dbz"],"model/x3d+vrml":["x3dv","x3dvz"],"model/x3d+xml":["x3d","x3dz"],"text/cache-manifest":["appcache","manifest"],"text/calendar":["ics","ifb"],"text/coffeescript":["coffee","litcoffee"],"text/css":["css"],"text/csv":["csv"],"text/hjson":["hjson"],"text/html":["html","htm","shtml"],"text/jade":["jade"],"text/jsx":["jsx"],"text/less":["less"],"text/markdown":["markdown","md"],"text/mathml":["mml"],"text/n3":["n3"],"text/plain":["txt","text","conf","def","list","log","in","ini"],"text/prs.lines.tag":["dsc"],"text/richtext":["rtx"],"text/rtf":[],"text/sgml":["sgml","sgm"],"text/slim":["slim","slm"],"text/stylus":["stylus","styl"],"text/tab-separated-values":["tsv"],"text/troff":["t","tr","roff","man","me","ms"],"text/turtle":["ttl"],"text/uri-list":["uri","uris","urls"],"text/vcard":["vcard"],"text/vnd.curl":["curl"],"text/vnd.curl.dcurl":["dcurl"],"text/vnd.curl.mcurl":["mcurl"],"text/vnd.curl.scurl":["scurl"],"text/vnd.dvb.subtitle":["sub"],"text/vnd.fly":["fly"],"text/vnd.fmi.flexstor":["flx"],"text/vnd.graphviz":["gv"],"text/vnd.in3d.3dml":["3dml"],"text/vnd.in3d.spot":["spot"],"text/vnd.sun.j2me.app-descriptor":["jad"],"text/vnd.wap.wml":["wml"],"text/vnd.wap.wmlscript":["wmls"],"text/vtt":["vtt"],"text/x-asm":["s","asm"],"text/x-c":["c","cc","cxx","cpp","h","hh","dic"],"text/x-component":["htc"],"text/x-fortran":["f","for","f77","f90"],"text/x-handlebars-template":["hbs"],"text/x-java-source":["java"],"text/x-lua":["lua"],"text/x-markdown":["mkd"],"text/x-nfo":["nfo"],"text/x-opml":["opml"],"text/x-org":[],"text/x-pascal":["p","pas"],"text/x-processing":["pde"],"text/x-sass":["sass"],"text/x-scss":["scss"],"text/x-setext":["etx"],"text/x-sfv":["sfv"],"text/x-suse-ymp":["ymp"],"text/x-uuencode":["uu"],"text/x-vcalendar":["vcs"],"text/x-vcard":["vcf"],"text/xml":[],"text/yaml":["yaml","yml"],"video/3gpp":["3gp","3gpp"],"video/3gpp2":["3g2"],"video/h261":["h261"],"video/h263":["h263"],"video/h264":["h264"],"video/jpeg":["jpgv"],"video/jpm":["jpgm"],"video/mj2":["mj2","mjp2"],"video/mp2t":["ts"],"video/mp4":["mp4","mp4v","mpg4"],"video/mpeg":["mpeg","mpg","mpe","m1v","m2v"],"video/ogg":["ogv"],"video/quicktime":["qt","mov"],"video/vnd.dece.hd":["uvh","uvvh"],"video/vnd.dece.mobile":["uvm","uvvm"],"video/vnd.dece.pd":["uvp","uvvp"],"video/vnd.dece.sd":["uvs","uvvs"],"video/vnd.dece.video":["uvv","uvvv"],"video/vnd.dvb.file":["dvb"],"video/vnd.fvt":["fvt"],"video/vnd.mpegurl":["mxu","m4u"],"video/vnd.ms-playready.media.pyv":["pyv"],"video/vnd.uvvu.mp4":["uvu","uvvu"],"video/vnd.vivo":["viv"],"video/webm":["webm"],"video/x-f4v":["f4v"],"video/x-fli":["fli"],"video/x-flv":["flv"],"video/x-m4v":["m4v"],"video/x-matroska":["mkv","mk3d","mks"],"video/x-mng":["mng"],"video/x-ms-asf":["asf","asx"],"video/x-ms-vob":["vob"],"video/x-ms-wm":["wm"],"video/x-ms-wmv":["wmv"],"video/x-ms-wmx":["wmx"],"video/x-ms-wvx":["wvx"],"video/x-msvideo":["avi"],"video/x-sgi-movie":["movie"],"video/x-smv":["smv"],"x-conference/x-cooltalk":["ice"]}');

/***/ }),

/***/ 17662:
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('{"100":"Continue","101":"Switching Protocols","102":"Processing","103":"Early Hints","200":"OK","201":"Created","202":"Accepted","203":"Non-Authoritative Information","204":"No Content","205":"Reset Content","206":"Partial Content","207":"Multi-Status","208":"Already Reported","226":"IM Used","300":"Multiple Choices","301":"Moved Permanently","302":"Found","303":"See Other","304":"Not Modified","305":"Use Proxy","307":"Temporary Redirect","308":"Permanent Redirect","400":"Bad Request","401":"Unauthorized","402":"Payment Required","403":"Forbidden","404":"Not Found","405":"Method Not Allowed","406":"Not Acceptable","407":"Proxy Authentication Required","408":"Request Timeout","409":"Conflict","410":"Gone","411":"Length Required","412":"Precondition Failed","413":"Payload Too Large","414":"URI Too Long","415":"Unsupported Media Type","416":"Range Not Satisfiable","417":"Expectation Failed","418":"I\'m a Teapot","421":"Misdirected Request","422":"Unprocessable Entity","423":"Locked","424":"Failed Dependency","425":"Too Early","426":"Upgrade Required","428":"Precondition Required","429":"Too Many Requests","431":"Request Header Fields Too Large","451":"Unavailable For Legal Reasons","500":"Internal Server Error","501":"Not Implemented","502":"Bad Gateway","503":"Service Unavailable","504":"Gateway Timeout","505":"HTTP Version Not Supported","506":"Variant Also Negotiates","507":"Insufficient Storage","508":"Loop Detected","509":"Bandwidth Limit Exceeded","510":"Not Extended","511":"Network Authentication Required"}');

/***/ }),

/***/ 6256:
/***/ ((module) => {

"use strict";
module.exports = {"version":"3.19.0"};

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __nccwpck_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		var threw = true;
/******/ 		try {
/******/ 			__webpack_modules__[moduleId].call(module.exports, module, module.exports, __nccwpck_require__);
/******/ 			threw = false;
/******/ 		} finally {
/******/ 			if(threw) delete __webpack_module_cache__[moduleId];
/******/ 		}
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/node module decorator */
/******/ 	(() => {
/******/ 		__nccwpck_require__.nmd = (module) => {
/******/ 			module.paths = [];
/******/ 			if (!module.children) module.children = [];
/******/ 			return module;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/compat */
/******/ 	
/******/ 	if (typeof __nccwpck_require__ !== 'undefined') __nccwpck_require__.ab = __dirname + "/";
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
__nccwpck_require__(59614);
module.exports = __webpack_exports__;
/******/ })()
;